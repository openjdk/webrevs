{"files":[{"patch":"@@ -117,1 +117,1 @@\n-<li><a href=\"#excluded-features\" id=\"toc-excluded-features\">Excluded\n+<li><a href=\"#forbidden-features\" id=\"toc-forbidden-features\">Forbidden\n@@ -126,2 +126,2 @@\n-<li><a href=\"#additional-excluded-features\"\n-id=\"toc-additional-excluded-features\">Additional Excluded\n+<li><a href=\"#additional-forbidden-features\"\n+id=\"toc-additional-forbidden-features\">Additional Forbidden\n@@ -509,1 +509,1 @@\n-language may be used unless explicitly excluded here. Features from\n+language may be used unless explicitly forbidden here. Features from\n@@ -511,1 +511,1 @@\n-excluded, and discussed accordingly here. There is a third category,\n+forbidden, and discussed accordingly here. There is a third category,\n@@ -514,1 +514,1 @@\n-is also excluded.<\/p>\n+is also forbidden.<\/p>\n@@ -521,1 +521,1 @@\n-sections for permitted, excluded, and undecided features.<\/p>\n+sections for permitted, forbidden, and undecided features.<\/p>\n@@ -597,2 +597,3 @@\n-(operator new and related functions). Use of these functions by HotSpot\n-code is disabled for some platforms.<\/p>\n+(global <code>operator new<\/code> and related functions), other than the\n+non-allocating forms of those functions. Use of these functions by\n+HotSpot code is disabled for some platforms.<\/p>\n@@ -601,4 +602,4 @@\n-in favor of wrappers around malloc and free that support the VM's Native\n-Memory Tracking (NMT) feature. Typically, uses of the global operator\n-new are inadvertent and therefore often associated with memory\n-leaks.<\/p>\n+in favor of wrappers around <code>malloc<\/code> and <code>free<\/code>\n+that support the JVM's Native Memory Tracking (NMT) feature. Typically,\n+uses of the global <code>operator new<\/code> are inadvertent and\n+therefore often associated with memory leaks.<\/p>\n@@ -651,1 +652,33 @@\n-<p>Avoid using the C++ Standard Library.<\/p>\n+<p>Only curated parts of the C++ Standard Library may be used by HotSpot\n+code.<\/p>\n+<p>Functions that may throw exceptions must not be used. This is in\n+accordance with the HotSpot policy of <a href=\"#error-handling\">not\n+using exceptions<\/a>.<\/p>\n+<p>Also in accordance with HotSpot policy, the <a\n+href=\"#memory-allocation\">standard global allocator must not be\n+used<\/a>. This means that uses of standard container classes cannot\n+presently be used, as doing so requires specialization on some allocator\n+type that is integrated with the existing HotSpot allocation mechanisms.\n+(Such allocators may be provided in the future.)<\/p>\n+<p>Standard Library identifiers should usually be fully qualified;\n+<code>using<\/code> directives must not be used to bring Standard Library\n+identifiers into scope just to remove the need for namespace\n+qualification. Requiring qualification makes it easy to distinguish\n+between references to external libraries and code that is part of\n+HotSpot.<\/p>\n+<p>As with language features, Standard Library facilities are either\n+permitted, explicitly forbidden, or undecided (and so implicitly\n+forbidden).<\/p>\n+<p>Most HotSpot code should not directly <code>#include<\/code> C++\n+Standard Library headers. HotSpot provides a set of wrapper headers for\n+the Standard Library headers containing permitted definitions. These\n+wrappers are in the <code>cppstdlib<\/code> directory, with the same name\n+as the corresponding Standard Library header and a <code>.hpp<\/code>\n+extension. These wrappers provide a place for any additional code (some\n+of which may be platform-specific) needed to support HotSpot usage.<\/p>\n+<p>These wrappers also provide a place to document HotSpot usage,\n+including any restrictions. The set of wrappers and the usage\n+documentation should be considered part of HotSpot style. Any changes\n+are subject to the same process as applies to this document. (For\n+historical reasons, there may be many direct inclusions of some C++\n+Standard Library headers.)<\/p>\n@@ -664,1 +697,3 @@\n-use exceptions.<\/p><\/li>\n+use exceptions. On the other hand, many don't, and can be used without\n+concern for this issue. Others may have a useful subset that doesn't use\n+exceptions.<\/p><\/li>\n@@ -668,3 +703,7 @@\n-Some mechanism for addressing this would be needed before much of the\n-Standard Library could be used. (Not all Standard Library\n-implementations use assert in header files, but some do.)<\/p><\/li>\n+(Not all Standard Library implementations use <code>assert<\/code> in\n+header files, but some do.) HotSpot provides a mechanism for addressing\n+this, by establishing a scope around the include of a library header\n+where the HotSpot <code>assert<\/code> macro is suppressed. One of the\n+reasons for using wrapper headers rather than directly including\n+standard headers is to provide a central place to deal with this issue\n+for each header.<\/p><\/li>\n@@ -673,2 +712,5 @@\n-limited to support our usage. (Changes in more recent Standards may\n-remove this limitation.)<\/p><\/li>\n+limited to support our usage. But changes to the allocator concept in\n+more recent Standards removed some of the limitations, supporting\n+stateful allocators. HotSpot may, in the future, provide\n+standard-conforming allocators that are integrated with HotSpot's\n+existing allocation mechanisms.<\/p><\/li>\n@@ -677,1 +719,4 @@\n-Libraries we need to deal with.<\/p><\/li>\n+Libraries we need to deal with. But only selected parts of the Standard\n+Library are being permitted, and one of the selection criteria is\n+maturity. Some of these facilities are among the most heavily tested and\n+used C++ codes that exist.<\/p><\/li>\n@@ -680,15 +725,7 @@\n-conventions might appear jarring and reduce readability.<\/p><\/li>\n-<\/ul>\n-<p>There are a few exceptions to this rule.<\/p>\n-<ul>\n-<li><code>#include &lt;new&gt;<\/code> to use placement <code>new<\/code>,\n-<code>std::nothrow<\/code>, and <code>std::nothrow_t<\/code>.<\/li>\n-<li><code>#include &lt;limits&gt;<\/code> to use\n-<code>std::numeric_limits<\/code>.<\/li>\n-<li><code>#include &lt;type_traits&gt;<\/code> with some restrictions,\n-listed below.<\/li>\n-<li><code>#include &lt;cstddef&gt;<\/code> to use\n-<code>std::nullptr_t<\/code> and <code>std::max_align_t<\/code>.<\/li>\n-<\/ul>\n-<p>Certain restrictions apply to the declarations provided by\n-<code>&lt;type_traits&gt;<\/code>.<\/p>\n+conventions might appear jarring and reduce readability. However,\n+experience in some other code bases suggests this isn't a significant\n+problem, so long as Standard Library names are namespace-qualified. It\n+is tempting to bring the Standard Library names into scope via a\n+<code>using std;<\/code> directive. Doing so makes writing code using\n+those names easier, since the qualifiers don't need to be included. But\n+there are several reasons not to do that.<\/p>\n@@ -696,2 +733,17 @@\n-<li>The <code>alignof<\/code> operator should be used rather than\n-<code>std::alignment_of&lt;&gt;<\/code>.<\/li>\n+<li><p>There is a risk of future name collisions. Additional Standard\n+Library headers may be included, adding to the list of names being used.\n+Also, future versions of the Standard Library may add currently unknown\n+names to the headers already being included.<\/p><\/li>\n+<li><p>It may harm readability. Code where this is relevant is a mixture\n+of the local HotSpot naming conventions and the Standard Library's (or\n+other 3rd-party library's) naming conventions. With only unqualified\n+names, any distinctions from the naming conventions for the different\n+code sources are lost. Instead one may end up with an undifferentiated\n+mess, where it's not obvious whether an identifier is from local code\n+that is inconsistent with HotSpot style (and there's a regretable amount\n+of that for historical reasons), or is following some other convention.\n+Having the qualifiers disambiguates that.<\/p><\/li>\n+<li><p>It can be helpful to know, at a glance, whether the definition is\n+in HotSpot or elsewhere, for purposes of looking up the definition or\n+documentation.<\/p><\/li>\n+<\/ul><\/li>\n@@ -699,5 +751,0 @@\n-<p>TODO: Rather than directly #including (permitted) Standard Library\n-headers, use a convention of #including wrapper headers (in some\n-location like hotspot\/shared\/stdcpp). This provides a single place for\n-dealing with issues we might have for any given header, esp.\n-platform-specific issues.<\/p>\n@@ -1580,1 +1627,1 @@\n-artificially disallow this syntactic regularization in any such\n+artificially forbid this syntactic regularization in any such\n@@ -1583,1 +1630,1 @@\n-<h2 id=\"excluded-features\">Excluded Features<\/h2>\n+<h2 id=\"forbidden-features\">Forbidden Features<\/h2>\n@@ -1625,1 +1672,2 @@\n-<h3 id=\"additional-excluded-features\">Additional Excluded Features<\/h3>\n+<h3 id=\"additional-forbidden-features\">Additional Forbidden\n+Features<\/h3>\n@@ -1627,0 +1675,24 @@\n+<li><p><code>&lt;algorithm&gt;<\/code>, <code>&lt;iterator&gt;<\/code>,\n+<code>&lt;numeric&gt;<\/code><br> Not useful without standard containers\n+or similar classes in HotSpot.<\/p><\/li>\n+<li><p><code>&lt;bitset&gt;<\/code> - Overlap with HotSpot\n+<code>BitMap<\/code>.<\/p><\/li>\n+<li><p><code>&lt;cassert&gt;<\/code>, <code>assert.h<\/code> - HotSpot has\n+its own <code>assert<\/code> macro.<\/p><\/li>\n+<li><p><code>&lt;exception&gt;<\/code>, <code>&lt;stdexcept&gt;<\/code> -\n+Use of <a href=\"#error-handling\">exceptions<\/a> is not\n+permitted.<\/p><\/li>\n+<li><p>Thread support - <code>&lt;thread&gt;<\/code>,\n+<code>&lt;mutex&gt;<\/code>, <code>&lt;shared_mutex&gt;<\/code>,\n+<code>&lt;condition_varible&gt;<\/code>, <code>&lt;future&gt;<\/code><br>\n+HotSpot has its own threading support.<\/p><\/li>\n+<li><p>Streams - HotSpot doesn't use the C++ I\/O library.<\/p><\/li>\n+<li><p><code>&lt;scoped_allocator&gt;<\/code> - Not useful without\n+specialized allocators.<\/p><\/li>\n+<li><p><code>&lt;string&gt;<\/code> - Requires allocator support, similar\n+to standard containers.<\/p><\/li>\n+<li><p><code>&lt;typeinfo&gt;<\/code>, <code>&lt;typeindex&gt;<\/code><br>\n+Use of <a href=\"#runtime-type-information\">runtime type information<\/a>\n+is not permitted.<\/p><\/li>\n+<li><p><code>&lt;valarray&gt;<\/code> - May allocate, but is not\n+allocator-aware.<\/p><\/li>\n@@ -1884,0 +1956,5 @@\n+<li><p><a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/header\/tuple.html\"><code>&lt;tuple&gt;<\/code><\/a>\n+— Prefer named access to class objects, rather than indexed access to\n+anonymous heterogeneous sequences. In particular, a standard-layout\n+class is preferred to a tuple.<\/p><\/li>\n@@ -1886,0 +1963,30 @@\n+<li><p><a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/header\/chrono.html\"><code>&lt;chrono&gt;<\/code><\/a>\n+— The argument for chrono is that our existing APIs aren't serving us\n+well. chrono provides strong type safety. We've had multiple cases of\n+mistakes like a double seconds being treated as double milliseconds or\n+vice versa, and other similar errors. But it would be a large effort to\n+adopt chrono. We'd also need to decide whether to use the predefined\n+clocks or hook up chrono to our clocks. It may be that using the\n+predefined clocks is fine, but it's a question that needs careful\n+study.<\/p><\/li>\n+<li><p><a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/header\/initializer_list.html\"><code>&lt;initializer_list&gt;<\/code><\/a>\n+— The potential ambiguity between some forms of direct initialization\n+and initializer list initialization, and the resolution of that\n+ambiguity, is unfortunate.<\/p><\/li>\n+<li><p><a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/header\/ratio.html\"><code>&lt;ratio&gt;<\/code><\/a>\n+— <code>&lt;ratio&gt;<\/code> is a <em>compile-time<\/em> rational\n+arithmetic package. It's also fixed (though parameterized) precision.\n+It's not a general purpose rational arithmetic facility. It appears to\n+have started out as an implementation detail of chrono, and was\n+extracted and promoted to a public facility in the belief that it has\n+broader utility.<\/p><\/li>\n+<li><p><a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/header\/system_error.html\"><code>&lt;system_error&gt;<\/code><\/a>\n+— We don't really have a generally agreed upon mechanism for managing\n+errors. Instead, we have a plethora of bespoke ad hoc mechanisms.\n+Managing errors is a topic of substantial discussion.\n+<code>&lt;system_error&gt;<\/code> might end up being a part of a result\n+from that discussion.<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":153,"deletions":46,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -416,2 +416,2 @@\n-language may be used unless explicitly excluded here.  Features from\n-C++11, C++14, and C++17 may be explicitly permitted or explicitly excluded,\n+language may be used unless explicitly forbidden here.  Features from\n+C++11, C++14, and C++17 may be explicitly permitted or explicitly forbidden,\n@@ -421,1 +421,1 @@\n-features is also excluded.\n+features is also forbidden.\n@@ -430,1 +430,1 @@\n-for permitted, excluded, and undecided features.\n+for permitted, forbidden, and undecided features.\n@@ -497,3 +497,4 @@\n-Do not use the standard global allocation and deallocation functions\n-(operator new and related functions).  Use of these functions by HotSpot\n-code is disabled for some platforms.\n+Do not use the standard global allocation and deallocation functions (global\n+`operator new` and related functions), other than the non-allocating forms of\n+those functions.  Use of these functions by HotSpot code is disabled for some\n+platforms.\n@@ -503,3 +504,3 @@\n-avoided in favor of wrappers around malloc and free that support the\n-VM's Native Memory Tracking (NMT) feature.  Typically, uses of the global\n-operator new are inadvertent and therefore often associated with memory\n+avoided in favor of wrappers around `malloc` and `free` that support the\n+JVM's Native Memory Tracking (NMT) feature.  Typically, uses of the global\n+`operator new` are inadvertent and therefore often associated with memory\n@@ -563,1 +564,33 @@\n-Avoid using the C++ Standard Library.\n+Only curated parts of the C++ Standard Library may be used by HotSpot code.\n+\n+Functions that may throw exceptions must not be used.  This is in accordance\n+with the HotSpot policy of [not using exceptions](#error-handling).\n+\n+Also in accordance with HotSpot policy, the\n+[standard global allocator must not be used](#memory-allocation).  This means\n+that uses of standard container classes cannot presently be used, as doing so\n+requires specialization on some allocator type that is integrated with the\n+existing HotSpot allocation mechanisms. (Such allocators may be provided in\n+the future.)\n+\n+Standard Library identifiers should usually be fully qualified; `using`\n+directives must not be used to bring Standard Library identifiers into scope\n+just to remove the need for namespace qualification.  Requiring qualification\n+makes it easy to distinguish between references to external libraries and code\n+that is part of HotSpot.\n+\n+As with language features, Standard Library facilities are either permitted,\n+explicitly forbidden, or undecided (and so implicitly forbidden).\n+\n+Most HotSpot code should not directly `#include` C++ Standard Library headers.\n+HotSpot provides a set of wrapper headers for the Standard Library headers\n+containing permitted definitions.  These wrappers are in the `cppstdlib`\n+directory, with the same name as the corresponding Standard Library header and\n+a `.hpp` extension.  These wrappers provide a place for any additional code\n+(some of which may be platform-specific) needed to support HotSpot usage.\n+\n+These wrappers also provide a place to document HotSpot usage, including any\n+restrictions.  The set of wrappers and the usage documentation should be\n+considered part of HotSpot style.  Any changes are subject to the same process\n+as applies to this document. (For historical reasons, there may be many direct\n+inclusions of some C++ Standard Library headers.)\n@@ -580,0 +613,2 @@\n+use exceptions. On the other hand, many don't, and can be used without\n+concern for this issue. Others may have a useful subset that doesn't\n@@ -584,8 +619,13 @@\n-Some mechanism for addressing this would be needed before much of the\n-Standard Library could be used.  (Not all Standard Library implementations\n-use assert in header files, but some do.)\n-\n-* Memory allocation. HotSpot requires explicit control over where\n-allocations occur. The C++98\/03 `std::allocator` class is too limited\n-to support our usage.  (Changes in more recent Standards may remove\n-this limitation.)\n+(Not all Standard Library implementations use `assert` in header files, but\n+some  do.) HotSpot provides a mechanism for addressing this, by establishing a\n+scope around the include of a library header where the HotSpot `assert` macro\n+is suppressed.  One of the reasons for using wrapper headers rather than\n+directly including standard headers is to provide a central place to deal with\n+this issue for each header.\n+\n+* Memory allocation. HotSpot requires explicit control over where allocations\n+occur. The C++98\/03 `std::allocator` class is too limited to support our\n+usage. But changes to the allocator concept in more recent Standards removed\n+some of the limitations, supporting stateful allocators. HotSpot may, in the\n+future, provide standard-conforming allocators that are integrated with\n+HotSpot's existing allocation mechanisms.\n@@ -595,22 +635,31 @@\n-to deal with.\n-\n-* Inconsistent naming conventions. HotSpot and the C++ Standard use\n-different naming conventions. The coexistence of those different conventions\n-might appear jarring and reduce readability.\n-\n-There are a few exceptions to this rule.\n-\n-* `#include <new>` to use placement `new`, `std::nothrow`, and `std::nothrow_t`.\n-* `#include <limits>` to use `std::numeric_limits`.\n-* `#include <type_traits>` with some restrictions, listed below.\n-* `#include <cstddef>` to use `std::nullptr_t` and `std::max_align_t`.\n-\n-Certain restrictions apply to the declarations provided by `<type_traits>`.\n-\n-* The `alignof` operator should be used rather than `std::alignment_of<>`.\n-\n-TODO: Rather than directly \\#including (permitted) Standard Library\n-headers, use a convention of \\#including wrapper headers (in some\n-location like hotspot\/shared\/stdcpp).  This provides a single place\n-for dealing with issues we might have for any given header, esp.\n-platform-specific issues.\n+to deal with. But only selected parts of the Standard Library are being\n+permitted, and one of the selection criteria is maturity. Some of these\n+facilities are among the most heavily tested and used C++ codes that exist.\n+\n+* Inconsistent naming conventions. HotSpot and the C++ Standard use different\n+naming conventions. The coexistence of those different conventions might\n+appear jarring and reduce readability. However, experience in some other code\n+bases suggests this isn't a significant problem, so long as Standard Library\n+names are namespace-qualified. It is tempting to bring the Standard Library\n+names into scope via a `using std;` directive. Doing so makes writing code\n+using those names easier, since the qualifiers don't need to be included. But\n+there are several reasons not to do that.\n+\n+    * There is a risk of future name collisions. Additional Standard Library\n+    headers may be included, adding to the list of names being used. Also,\n+    future versions of the Standard Library may add currently unknown names to\n+    the headers already being included.\n+\n+    * It may harm readability. Code where this is relevant is a mixture of the\n+    local HotSpot naming conventions and the Standard Library's (or other\n+    3rd-party library's) naming conventions. With only unqualified names, any\n+    distinctions from the naming conventions for the different code sources\n+    are lost. Instead one may end up with an undifferentiated mess, where it's\n+    not obvious whether an identifier is from local code that is inconsistent\n+    with HotSpot style (and there's a regretable amount of that for historical\n+    reasons), or is following some other convention. Having the qualifiers\n+    disambiguates that.\n+\n+    * It can be helpful to know, at a glance, whether the definition is in\n+    HotSpot or elsewhere, for purposes of looking up the definition or\n+    documentation.\n@@ -1532,1 +1581,1 @@\n-disallow this syntactic regularization in any such uses.\n+forbid this syntactic regularization in any such uses.\n@@ -1534,1 +1583,1 @@\n-## Excluded Features\n+## Forbidden Features\n@@ -1584,1 +1633,26 @@\n-### Additional Excluded Features\n+### Additional Forbidden Features\n+\n+* `<algorithm>`, `<iterator>`, `<numeric>`<br>\n+Not useful without standard containers or similar classes in HotSpot.\n+\n+* `<bitset>` - Overlap with HotSpot `BitMap`.\n+\n+* `<cassert>`, `assert.h` - HotSpot has its own `assert` macro.\n+\n+* `<exception>`, `<stdexcept>` - Use of [exceptions](#error-handling) is not\n+permitted.\n+\n+* Thread support - `<thread>`, `<mutex>`, `<shared_mutex>`,\n+`<condition_varible>`, `<future>`<br>\n+HotSpot has its own threading support.\n+\n+* Streams - HotSpot doesn't use the C++ I\/O library.\n+\n+* `<scoped_allocator>` - Not useful without specialized allocators.\n+\n+* `<string>` - Requires allocator support, similar to standard containers.\n+\n+* `<typeinfo>`, `<typeindex>`<br>\n+Use of [runtime type information](#runtime-type-information) is not permitted.\n+\n+* `<valarray>` - May allocate, but is not allocator-aware.\n@@ -1883,0 +1957,5 @@\n+* [`<tuple>`](https:\/\/en.cppreference.com\/w\/cpp\/header\/tuple.html) &mdash;\n+Prefer named access to class objects, rather than indexed access\n+to anonymous heterogeneous sequences.  In particular, a standard-layout\n+class is preferred to a tuple.\n+\n@@ -1886,0 +1965,26 @@\n+* [`<chrono>`](https:\/\/en.cppreference.com\/w\/cpp\/header\/chrono.html) &mdash;\n+The argument for chrono is that our existing APIs aren't serving us well.\n+chrono provides strong type safety. We've had multiple cases of mistakes like\n+a double seconds being treated as double milliseconds or vice versa, and other\n+similar errors. But it would be a large effort to adopt chrono. We'd also need\n+to decide whether to use the predefined clocks or hook up chrono to our\n+clocks. It may be that using the predefined clocks is fine, but it's a\n+question that needs careful study.\n+\n+* [`<initializer_list>`](https:\/\/en.cppreference.com\/w\/cpp\/header\/initializer_list.html) &mdash;\n+The potential ambiguity between some forms of direct initialization and\n+initializer list initialization, and the resolution of that ambiguity, is\n+unfortunate.\n+\n+* [`<ratio>`](https:\/\/en.cppreference.com\/w\/cpp\/header\/ratio.html) &mdash;\n+`<ratio>` is a *compile-time* rational arithmetic package. It's also fixed\n+(though parameterized) precision. It's not a general purpose rational\n+arithmetic facility. It appears to have started out as an implementation\n+detail of chrono, and was extracted and promoted to a public facility in the\n+belief that it has broader utility.\n+\n+* [`<system_error>`](https:\/\/en.cppreference.com\/w\/cpp\/header\/system_error.html) &mdash;\n+We don't really have a generally agreed upon mechanism for managing\n+errors. Instead, we have a plethora of bespoke ad hoc mechanisms. Managing\n+errors is a topic of substantial discussion. `<system_error>` might end up\n+being a part of a result from that discussion.\n","filename":"doc\/hotspot-style.md","additions":149,"deletions":44,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-$(eval $(call SetupTarget, static-launcher, \\\n+$(eval $(call SetupTarget, static-launchers, \\\n@@ -466,1 +466,1 @@\n-    TARGET := static-launcher, \\\n+    TARGET := static-launchers, \\\n@@ -1293,1 +1293,1 @@\n-static-exploded-image: static-launcher exploded-image\n+static-exploded-image: static-launchers exploded-image\n","filename":"make\/Main.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-STATIC_LIB_MODULES := $(patsubst $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/%, \\\n-    %, $(wildcard $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/*))\n+STATIC_LIB_MODULES := $(sort $(patsubst $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/%, \\\n+    %, $(wildcard $(SUPPORT_OUTPUTDIR)\/modules_static-libs\/*)))\n@@ -126,0 +126,3 @@\n+################################################################################\n+# Build the java static launcher\n+################################################################################\n@@ -132,0 +135,1 @@\n+    MACOSX_PRIVILEGED := true, \\\n@@ -133,0 +137,1 @@\n+    CFLAGS := -DSTATIC_BUILD, \\\n@@ -149,1 +154,47 @@\n-static-launcher: $(java)\n+static-launchers: $(java)\n+\n+################################################################################\n+# Build relaunchers (thin wrappers calling the java binary) for all other\n+# JDK launchers.\n+################################################################################\n+\n+RELAUNCHER_SRC := $(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS_TYPE)\/native\/launcher\n+\n+# $1: The module name\n+# $2: The launcher name\n+define SetupRelauncher\n+  $1_$2_LAUNCHER_ARGS_LINE := $$(call ReadFile, $$(SUPPORT_OUTPUTDIR)\/static-native\/relaunchers\/$1\/$2-relauncher-arguments.txt)\n+  # Restore |||| with space\n+  $1_$2_LAUNCHER_ARGS := '{ $$(subst ||||,$(SPACE),$$(strip $$(foreach a, $$($1_$2_LAUNCHER_ARGS_LINE), \"-J$$a\"$$(COMMA) )) ) }'\n+\n+  $$(eval $$(call SetupJdkExecutable, BUILD_relauncher_$2, \\\n+      NAME := $2, \\\n+      EXTRA_FILES := $$(RELAUNCHER_SRC)\/relauncher.c, \\\n+      CFLAGS := -DLAUNCHER_ARGS=$$($1_$2_LAUNCHER_ARGS), \\\n+      LIBS_windows := shlwapi.lib, \\\n+      OUTPUT_DIR := $$(STATIC_LAUNCHER_OUTPUT_DIR), \\\n+      OBJECT_DIR := $$(STATIC_LAUNCHER_OUTPUT_DIR)\/relaunchers\/$2, \\\n+  ))\n+\n+  TARGETS += $$(BUILD_relauncher_$2)\n+\n+  RELAUNCHERS += $$(BUILD_relauncher_$2_TARGET)\n+  static-launchers: $$(BUILD_relauncher_$2)\n+endef\n+\n+# Find all modules with launchers\n+LAUNCHER_MODULES := $(sort $(patsubst $(SUPPORT_OUTPUTDIR)\/modules_static-launchers\/%, \\\n+    %, $(wildcard $(SUPPORT_OUTPUTDIR)\/modules_static-launchers\/*)))\n+\n+# Find launchers for each module\n+$(foreach module, $(LAUNCHER_MODULES), \\\n+    $(eval LAUNCHERS_$(module) := $(if $(wildcard \\\n+    $(SUPPORT_OUTPUTDIR)\/modules_static-launchers\/$(module)\/module-included-launchers.txt), \\\n+    $(shell cat \\\n+    $(SUPPORT_OUTPUTDIR)\/modules_static-launchers\/$(module)\/module-included-launchers.txt))) \\\n+)\n+\n+# For all launchers (except java and javaw), setup a relauncher build\n+$(foreach module, $(LAUNCHER_MODULES), \\\n+    $(foreach launcher, $(filter-out java javaw, $(LAUNCHERS_$(module))), \\\n+    $(eval $(call SetupRelauncher,$(module),$(launcher)))))\n@@ -191,2 +242,2 @@\n-$(eval $(call SetupCopyFiles, copy-static-launcher, \\\n-    FILES := $(JAVA_LAUNCHER), \\\n+$(eval $(call SetupCopyFiles, copy-static-launchers, \\\n+    FILES := $(JAVA_LAUNCHER) $(RELAUNCHERS), \\\n@@ -196,1 +247,1 @@\n-TARGETS += $(copy-static-launcher)\n+TARGETS += $(copy-static-launchers)\n@@ -198,1 +249,1 @@\n-$(eval $(call SetupCopyFiles, copy-static-launcher-debuginfo, \\\n+$(eval $(call SetupCopyFiles, copy-static-launchers-debuginfo, \\\n@@ -204,1 +255,46 @@\n-TARGETS += $(copy-static-launcher-debuginfo)\n+TARGETS += $(copy-static-launchers-debuginfo)\n+\n+# Copy the microsoft runtime libraries on windows\n+ifeq ($(call isTargetOs, windows), true)\n+  # Chmod to avoid permission issues if bundles are unpacked on unix platforms.\n+  # Use separate macro calls in case the source files are not in the same\n+  # directory.\n+  $(eval $(call SetupCopyFiles, copy-windows-msvcr, \\\n+      DEST := $(STATIC_JDK_IMAGE_DIR)\/bin, \\\n+      FILES := $(MSVCR_DLL), \\\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n+\n+  TARGETS += $(copy-windows-msvcr)\n+\n+  $(eval $(call SetupCopyFiles, copy-windows-vcruntime, \\\n+      DEST := $(STATIC_JDK_IMAGE_DIR)\/bin, \\\n+      FILES := $(VCRUNTIME_1_DLL), \\\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n+\n+  TARGETS += $(copy-windows-vcruntime)\n+\n+  $(eval $(call SetupCopyFiles, copy-windows-msvcp, \\\n+      DEST := $(STATIC_JDK_IMAGE_DIR)\/bin, \\\n+      FILES := $(MSVCP_DLL), \\\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n+\n+  TARGETS += $(copy-windows-msvcp)\n+\n+  copy-windows-libs := $(copy-windows-msvcr) $(copy-windows-vcruntime) $(copy-windows-msvcp)\n+\n+  ifneq ($(UCRT_DLL_DIR), )\n+    $(eval $(call SetupCopyFiles, copy-windows-ucrt, \\\n+        DEST := $(STATIC_JDK_IMAGE_DIR)\/bin, \\\n+        SRC := $(UCRT_DLL_DIR), \\\n+        FILES := $(wildcard $(UCRT_DLL_DIR)\/*.dll), \\\n+        MACRO := copy-and-chmod-executable, \\\n+    ))\n+\n+    TARGETS += $(copy-windows-ucrt)\n+\n+    copy-windows-libs += $(copy-windows-ucrt)\n+  endif\n+endif\n@@ -206,1 +302,2 @@\n-static-jdk-image: $(copy-from-jdk-image) $(copy-static-launcher) $(copy-static-launcher-debuginfo)\n+static-jdk-image: $(copy-from-jdk-image) $(copy-static-launchers) \\\n+    $(copy-static-launchers-debuginfo) $(copy-windows-libs)\n@@ -210,1 +307,1 @@\n-.PHONY: static-launcher static-jdk-image\n+.PHONY: static-launchers static-jdk-image\n","filename":"make\/StaticLibs.gmk","additions":107,"deletions":10,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -307,0 +307,2 @@\n+      elif test -e $BINUTILS_INSTALL_DIR\/lib64\/libsframe.a; then\n+        HSDIS_LIBS=\"$HSDIS_LIBS $BINUTILS_INSTALL_DIR\/lib64\/libsframe.a\"\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+INCLUDED_LAUNCHERS_FILE := $(SUPPORT_OUTPUTDIR)\/modules_static-launchers\/$(MODULE)\/module-included-launchers.txt\n+INCLUDED_LAUNCHERS :=\n+\n@@ -77,0 +80,2 @@\n+  $1_RELAUNCHER_ARGUMENTS :=\n+\n@@ -82,2 +87,6 @@\n-  ifeq ($$($1_EXPAND_CLASSPATH_WILDCARDS), true)\n-    $1_CFLAGS += -DEXPAND_CLASSPATH_WILDCARDS\n+  ifeq ($$($1_ENABLE_ARG_FILES), true)\n+    $1_CFLAGS += -DDISABLE_ARGFILE=JNI_FALSE\n+  else\n+    $1_CFLAGS += -DDISABLE_ARGFILE=JNI_TRUE\n+    # This must be the first argument given, if it should be present\n+    $1_RELAUNCHER_ARGUMENTS += -DjavaLauncherArgFiles=false\n@@ -86,2 +95,5 @@\n-  ifeq ($$($1_ENABLE_ARG_FILES), true)\n-    $1_CFLAGS += -DENABLE_ARG_FILES\n+  ifeq ($$($1_EXPAND_CLASSPATH_WILDCARDS), true)\n+    $1_CFLAGS += -DCLASSPATH_WILDCARDS=JNI_TRUE\n+  else\n+    $1_CFLAGS += -DCLASSPATH_WILDCARDS=JNI_FALSE\n+    $1_RELAUNCHER_ARGUMENTS += -DjavaLauncherWildcards=false\n@@ -90,0 +102,2 @@\n+  $1_RELAUNCHER_ARGUMENTS += -DjavaLauncherProgname=$1\n+\n@@ -97,2 +111,4 @@\n-    $1_JAVA_ARGS_STR := '{ $$(strip $$(foreach a, \\\n-        $$(addprefix -J, $$($1_JAVA_ARGS)) $$($1_LAUNCHER_CLASS), \"$$a\"$(COMMA) )) }'\n+    $1_PREFIXED_JAVA_ARGS := $$(addprefix -J, $$($1_JAVA_ARGS)) \\\n+        $$($1_LAUNCHER_CLASS)\n+    $1_JAVA_ARGS_STR := '{ $$(strip $$(foreach a, $$($1_PREFIXED_JAVA_ARGS), \\\n+        \"$$a\"$(COMMA) )) }'\n@@ -100,0 +116,3 @@\n+    # To preserve spaces, substitute them with a hopefully unique pattern\n+    $1_RELAUNCHER_ARGUMENTS += \\\n+        -DjavaLauncherArgs=$$(subst $$(SPACE),||||,$$($1_PREFIXED_JAVA_ARGS))\n@@ -175,0 +194,14 @@\n+\n+  $1_RELAUNCHER_ARGUMENTS_FILE := \\\n+      $$(SUPPORT_OUTPUTDIR)\/static-native\/relaunchers\/$$(MODULE)\/$1-relauncher-arguments.txt\n+\n+  $1_VARDEPS := $$($1_RELAUNCHER_ARGUMENTS)\n+  $1_VARDEPS_FILE := $$(call DependOnVariable, $1_VARDEPS, \\\n+      $$($1_RELAUNCHER_ARGUMENTS_FILE).vardeps)\n+\n+  $$($1_RELAUNCHER_ARGUMENTS_FILE):\n+\t$$(call MakeDir, $$(@D))\n+\t$$(ECHO) '$$($1_RELAUNCHER_ARGUMENTS)' > $$@\n+\n+  $1 += $$($1_RELAUNCHER_ARGUMENTS_FILE)\n+\n@@ -177,0 +210,6 @@\n+  # Record the fact that this launcher is part of the current module.\n+  INCLUDED_LAUNCHERS += $1\n+\n+  # Add a dependency from this launcher to the launcher list\n+  $$(INCLUDED_LAUNCHERS_FILE): $$($1)\n+\n@@ -245,0 +284,9 @@\n+# We need to keep track of which launchers are created by this module. This\n+# information is required for static builds, to know which relaunchers to\n+# create. The file module-included-launchers.txt is then read in StaticLibs.gmk.\n+$(INCLUDED_LAUNCHERS_FILE):\n+\t$(call MakeDir, $(@D))\n+\t$(ECHO) $(INCLUDED_LAUNCHERS) > $@\n+\n+TARGETS += $(INCLUDED_LAUNCHERS_FILE)\n+\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -631,1 +631,1 @@\n-            result.appendLine(\"private static final int LIMB_MASK = -1 \"\n+            result.appendLine(\"private static final long LIMB_MASK = -1L \"\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,9 +148,0 @@\n-ifeq ($(call isTargetOs, linux), true)\n-  $(eval $(call SetupCopyFiles, COPY_SDP_CONF, \\\n-      FILES := $(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS_TYPE)\/conf\/sdp\/sdp.conf.template, \\\n-      DEST := $(CONF_DST_DIR)\/sdp, \\\n-  ))\n-\n-  TARGETS += $(COPY_SDP_CONF)\n-endif\n-\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/launcher, \\\n+      EXTRA_FILES := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/launcher\/jexec.c, \\\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-include LauncherCommon.gmk\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+\/\/ Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1197,1 +1198,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1200,4 +1200,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_codestub_branch_size();\n-  }\n-\n@@ -1205,1 +1201,1 @@\n-    \/\/ count one adr and one far branch instruction\n+    \/\/ count one branch instruction and one far call instruction sequence\n@@ -2255,19 +2251,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ mov rscratch1 #exception_blob_entry_point\n-  \/\/ br rscratch1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2284,0 +2261,1 @@\n+\n@@ -2285,0 +2263,3 @@\n+  Label start;\n+  __ bind(start);\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2286,2 +2267,2 @@\n-  __ adr(lr, __ pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -2291,1 +2272,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":9,"deletions":28,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -35,1 +36,0 @@\n-#include <type_traits>\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,2 +455,8 @@\n-  __ adr(lr, pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ b(start);\n+\n@@ -460,1 +466,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _deopt_handler_size = 7 * NativeInstruction::instruction_size\n+    _deopt_handler_size = 4 * NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2746,3 +2746,2 @@\n-  \/\/ - UseSVE = 0, vector_length_in_bytes = 8 or 16\n-  \/\/ - UseSVE = 1, vector_length_in_bytes = 8 or 16\n-  \/\/ - UseSVE = 2, vector_length_in_bytes >= 8\n+  \/\/ - UseSVE = 0\/1, vector_length_in_bytes = 8 or 16, excluding double and long types\n+  \/\/ - UseSVE = 2, vector_length_in_bytes >= 8, for all types\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -210,0 +210,35 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  intptr_t* sp = _top_frame.sp();\n+  if (_top_frame.is_interpreted_frame()) {\n+    \/\/ In case the top frame is interpreted we need to set up the anchor using\n+    \/\/ the last_sp saved in the frame (remove possible alignment added while\n+    \/\/ thawing, see ThawBase::finish_thaw()). We also clear last_sp to match\n+    \/\/ the behavior when calling the VM from the interpreter (we check for this\n+    \/\/ in FreezeBase::prepare_freeze_interpreted_top_frame, which can be reached\n+    \/\/ if preempting again at redo_vmcall()).\n+    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n+    assert(_last_sp_from_frame != nullptr, \"\");\n+    _top_frame.interpreter_frame_set_last_sp(nullptr);\n+    if (sp != _last_sp_from_frame) {\n+      \/\/ We need to move up return pc and fp. They will be read next in\n+      \/\/ set_anchor() and set as _last_Java_pc and _last_Java_fp respectively.\n+      _last_sp_from_frame[-1] = (intptr_t)_top_frame.pc();\n+      _last_sp_from_frame[-2] = (intptr_t)_top_frame.fp();\n+    }\n+    _is_interpreted = true;\n+    sp = _last_sp_from_frame;\n+  }\n+  return sp;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  if (_is_interpreted) {\n+    \/\/ Restore last_sp_from_frame and possibly overwritten pc.\n+    _top_frame.interpreter_frame_set_last_sp(_last_sp_from_frame);\n+    intptr_t* sp = _top_frame.sp();\n+    if (sp != _last_sp_from_frame) {\n+      sp[-1] = (intptr_t)_top_frame.pc();\n+    }\n+  }\n+}\n+\n@@ -313,0 +348,1 @@\n+  \/\/ We only need to set the return pc. rfp will be restored back in gen_continuation_enter().\n@@ -314,1 +350,6 @@\n-  sp[-2] = (intptr_t)enterSpecial.fp();\n+  return sp;\n+}\n+\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n@@ -316,1 +357,2 @@\n-  log_develop_trace(continuations, preempt)(\"push_cleanup_continuation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT, p2i(sp + 2 * frame::metadata_words), p2i(sp));\n+  \/\/ We only need to set the return pc. rfp will be restored back in generate_cont_preempt_stub().\n+  sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_entry(), \"unexpected sender pc\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -37,1 +37,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,25 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register src, Register dst, Register count, RegSet saved_regs) {\n+\n+  if (is_oop) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register start, Register count, Register tmp,\n+                                                      RegSet saved_regs) {\n+  if (is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -31,1 +31,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -33,1 +33,2 @@\n-  void store_check(MacroAssembler* masm, Register obj, Address dst);\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count, RegSet saved_regs) {}\n@@ -40,0 +41,9 @@\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register src, Register dst, Register count, RegSet saved_regs);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n+\n+  void store_check(MacroAssembler* masm, Register obj, Address dst);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register src, Register dst, Register count, RegSet saved_regs) {\n-\n-  if (is_oop) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register start, Register count, Register tmp,\n-                                                   RegSet saved_regs) {\n-  if (is_oop) {\n-    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/modRefBarrierSetAssembler_aarch64.cpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_AARCH64_GC_SHARED_MODREFBARRIERSETASSEMBLER_AARCH64_HPP\n-#define CPU_AARCH64_GC_SHARED_MODREFBARRIERSETASSEMBLER_AARCH64_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count, RegSet saved_regs) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register start, Register count, Register tmp, RegSet saved_regs) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register src, Register dst, Register count, RegSet saved_regs);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register start, Register count, Register tmp, RegSet saved_regs);\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-};\n-\n-#endif \/\/ CPU_AARCH64_GC_SHARED_MODREFBARRIERSETASSEMBLER_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/modRefBarrierSetAssembler_aarch64.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -573,0 +573,8 @@\n+#ifdef ASSERT\n+  Label not_preempted;\n+  ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  cbz(rscratch1, not_preempted);\n+  stop(\"remove_activation: should not have alternate return address set\");\n+  bind(not_preempted);\n+#endif \/* ASSERT *\/\n+\n@@ -1624,0 +1632,1 @@\n+                                             Label*   return_pc,\n@@ -1647,2 +1656,2 @@\n-                               entry_point, number_of_arguments,\n-                     check_exceptions);\n+                               return_pc, entry_point,\n+                               number_of_arguments, check_exceptions);\n@@ -1654,4 +1663,5 @@\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                                                    address entry_point,\n-                                                    Register arg_1) {\n-  assert(arg_1 == c_rarg1, \"\");\n+void InterpreterMacroAssembler::call_VM_preemptable_helper(Register oop_result,\n+                                                           address entry_point,\n+                                                           int number_of_arguments,\n+                                                           bool check_exceptions) {\n+  assert(InterpreterRuntime::is_preemptable_call(entry_point), \"VM call not preemptable, should use call_VM()\");\n@@ -1662,1 +1672,1 @@\n-    Label L;\n+    Label L1, L2;\n@@ -1664,3 +1674,10 @@\n-    cbz(rscratch1, L);\n-    stop(\"Should not have alternate return address set\");\n-    bind(L);\n+    cbz(rscratch1, L1);\n+    stop(\"call_VM_preemptable_helper: Should not have alternate return address set\");\n+    bind(L1);\n+    \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+    incrementw(Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    ldrw(rscratch1, Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpw(rscratch1, 0);\n+    br(Assembler::GT, L2);\n+    stop(\"call_VM_preemptable_helper: should be > 0\");\n+    bind(L2);\n@@ -1674,3 +1691,2 @@\n-  adr(rscratch1, resume_pc);\n-  str(rscratch1, Address(rthread, JavaThread::last_Java_pc_offset()));\n-  call_VM_base(oop_result, noreg, noreg, entry_point, 1, false \/*check_exceptions*\/);\n+  \/\/ Note: call_VM_base will use resume_pc label to set last_Java_pc.\n+  call_VM_base(noreg, noreg, noreg, &resume_pc, entry_point, number_of_arguments, false \/*check_exceptions*\/);\n@@ -1680,0 +1696,12 @@\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    decrementw(Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    ldrw(rscratch1, Address(rthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpw(rscratch1, 0);\n+    br(Assembler::GE, L);\n+    stop(\"call_VM_preemptable_helper: should be >= 0\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n@@ -1691,0 +1719,45 @@\n+  if (check_exceptions) {\n+    \/\/ check for pending exceptions\n+    ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    cbz(rscratch1, ok);\n+    lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    br(rscratch1);\n+    bind(ok);\n+  }\n+\n+  \/\/ get oop result if there is one and reset the value in the thread\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result, rthread);\n+  }\n+}\n+\n+static void pass_arg1(MacroAssembler* masm, Register arg) {\n+  if (c_rarg1 != arg ) {\n+    masm->mov(c_rarg1, arg);\n+  }\n+}\n+\n+static void pass_arg2(MacroAssembler* masm, Register arg) {\n+  if (c_rarg2 != arg ) {\n+    masm->mov(c_rarg2, arg);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         bool check_exceptions) {\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 1, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         Register arg_2,\n+                                         bool check_exceptions) {\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n+  pass_arg2(this, arg_2);\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 2, check_exceptions);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+                            Label*   return_pc,\n@@ -61,0 +62,1 @@\n+  \/\/ Use for vthread preemption\n@@ -63,1 +65,7 @@\n-                           Register arg_1);\n+                           Register arg_1,\n+                           bool check_exceptions = true);\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1,\n+                           Register arg_2,\n+                           bool check_exceptions = true);\n@@ -65,0 +73,5 @@\n+ private:\n+  void call_VM_preemptable_helper(Register oop_result,\n+                                  address entry_point,\n+                                  int number_of_arguments,\n+                                  bool check_exceptions);\n@@ -66,0 +79,1 @@\n+ public:\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -751,4 +751,0 @@\n-static bool is_preemptable(address entry_point) {\n-  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter);\n-}\n-\n@@ -758,0 +754,1 @@\n+                                  Label*   return_pc,\n@@ -790,6 +787,1 @@\n-  if (is_preemptable(entry_point)) {\n-    \/\/ skip setting last_pc since we already set it to desired value.\n-    set_last_Java_frame(last_java_sp, rfp, noreg, rscratch1);\n-  } else {\n-    set_last_Java_frame(last_java_sp, rfp, l, rscratch1);\n-  }\n+  set_last_Java_frame(last_java_sp, rfp, return_pc != nullptr ? *return_pc : l, rscratch1);\n@@ -830,1 +822,1 @@\n-  call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, noreg, noreg, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -1088,1 +1080,1 @@\n-  call_VM_base(oop_result, rthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, rthread, last_java_sp, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -3431,91 +3423,0 @@\n-\/\/ this simulates the behaviour of the x86 cmpxchg instruction using a\n-\/\/ load linked\/store conditional pair. we use the acquire\/release\n-\/\/ versions of these instructions so that we flush pending writes as\n-\/\/ per Java semantics.\n-\n-\/\/ n.b the x86 version assumes the old value to be compared against is\n-\/\/ in rax and updates rax with the value located in memory if the\n-\/\/ cmpxchg fails. we supply a register for the old value explicitly\n-\n-\/\/ the aarch64 load linked\/store conditional instructions do not\n-\/\/ accept an offset. so, unlike x86, we must provide a plain register\n-\/\/ to identify the memory word to be compared\/exchanged rather than a\n-\/\/ register+offset Address.\n-\n-void MacroAssembler::cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,\n-                                Label &succeed, Label *fail) {\n-  \/\/ oldv holds comparison value\n-  \/\/ newv holds value to write in exchange\n-  \/\/ addr identifies memory word to compare against\/update\n-  if (UseLSE) {\n-    mov(tmp, oldv);\n-    casal(Assembler::xword, oldv, newv, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::EQ, succeed);\n-    membar(AnyAny);\n-  } else {\n-    Label retry_load, nope;\n-    prfm(Address(addr), PSTL1STRM);\n-    bind(retry_load);\n-    \/\/ flush and load exclusive from the memory location\n-    \/\/ and fail if it is not what we expect\n-    ldaxr(tmp, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::NE, nope);\n-    \/\/ if we store+flush with no intervening write tmp will be zero\n-    stlxr(tmp, newv, addr);\n-    cbzw(tmp, succeed);\n-    \/\/ retry so we only ever return after a load fails to compare\n-    \/\/ ensures we don't return a stale value after a failed write.\n-    b(retry_load);\n-    \/\/ if the memory word differs we return it in oldv and signal a fail\n-    bind(nope);\n-    membar(AnyAny);\n-    mov(oldv, tmp);\n-  }\n-  if (fail)\n-    b(*fail);\n-}\n-\n-void MacroAssembler::cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,\n-                                        Label &succeed, Label *fail) {\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"assumption\");\n-  cmpxchgptr(oldv, newv, obj, tmp, succeed, fail);\n-}\n-\n-void MacroAssembler::cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,\n-                                Label &succeed, Label *fail) {\n-  \/\/ oldv holds comparison value\n-  \/\/ newv holds value to write in exchange\n-  \/\/ addr identifies memory word to compare against\/update\n-  \/\/ tmp returns 0\/1 for success\/failure\n-  if (UseLSE) {\n-    mov(tmp, oldv);\n-    casal(Assembler::word, oldv, newv, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::EQ, succeed);\n-    membar(AnyAny);\n-  } else {\n-    Label retry_load, nope;\n-    prfm(Address(addr), PSTL1STRM);\n-    bind(retry_load);\n-    \/\/ flush and load exclusive from the memory location\n-    \/\/ and fail if it is not what we expect\n-    ldaxrw(tmp, addr);\n-    cmp(tmp, oldv);\n-    br(Assembler::NE, nope);\n-    \/\/ if we store+flush with no intervening write tmp will be zero\n-    stlxrw(tmp, newv, addr);\n-    cbzw(tmp, succeed);\n-    \/\/ retry so we only ever return after a load fails to compare\n-    \/\/ ensures we don't return a stale value after a failed write.\n-    b(retry_load);\n-    \/\/ if the memory word differs we return it in oldv and signal a fail\n-    bind(nope);\n-    membar(AnyAny);\n-    mov(oldv, tmp);\n-  }\n-  if (fail)\n-    b(*fail);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":103,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+    Label*   return_pc,                \/\/ to set up last_Java_frame; use nullptr otherwise\n@@ -1256,10 +1257,0 @@\n-  \/\/ Various forms of CAS\n-\n-  void cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,\n-                          Label &succeed, Label *fail);\n-  void cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,\n-                  Label &succeed, Label *fail);\n-\n-  void cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,\n-                  Label &succeed, Label *fail);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -397,6 +397,0 @@\n-#ifdef ASSERT\n-static bool is_movk_to_zr(uint32_t insn) {\n-  return ((insn & 0xffe0001f) == 0xf280001f);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -529,0 +529,5 @@\n+private:\n+  static bool is_movk_to_zr(uint32_t insn) {\n+    return ((insn & 0xffe0001f) == 0xf280001f);\n+  }\n+\n@@ -531,6 +536,11 @@\n-    uint64_t insns = *(uint64_t*)addr_at(0);\n-    \/\/ Check for two instructions: nop; movk zr, xx\n-    \/\/ These instructions only ever appear together in a post-call\n-    \/\/ NOP, so it's unnecessary to check that the third instruction is\n-    \/\/ a MOVK as well.\n-    return (insns & 0xffe0001fffffffff) == 0xf280001fd503201f;\n+    \/\/ Check the first instruction is NOP.\n+    if (is_nop()) {\n+      uint32_t insn = *(uint32_t*)addr_at(4);\n+      \/\/ Check next instruction is MOVK zr, xx.\n+      \/\/ These instructions only ever appear together in a post-call\n+      \/\/ NOP, so it's unnecessary to check that the third instruction is\n+      \/\/ a MOVK as well.\n+      return is_movk_to_zr(insn);\n+    }\n+\n+    return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in aarch64.ad file)\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -74,1 +73,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/aarch64\/smallRegisterMap_aarch64.inline.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -139,1 +139,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n@@ -142,1 +143,0 @@\n-  InterpreterOopMap mask;\n@@ -144,6 +144,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return  mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-        + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-              (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2411,1 +2411,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -2463,1 +2463,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -3848,1 +3848,1 @@\n-  call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n+  __ call_VM_preemptable(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -111,5 +110,0 @@\n-  static uint size_exception_handler() {\n-    return ( 3 * 4 );\n-  }\n-\n-\n@@ -879,20 +873,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-\n-  \/\/ OK to trash LR, because exception blob will kill it\n-  __ jump(OptoRuntime::exception_blob()->entry_point(), relocInfo::runtime_call_type, LR_tmp);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -909,1 +883,0 @@\n-  address deopt_pc = __ pc();\n@@ -911,5 +884,3 @@\n-  __ sub(SP, SP, wordSize); \/\/ make room for saved PC\n-  __ push(LR); \/\/ save LR that may be live when we get here\n-  __ mov_relative_address(LR, deopt_pc);\n-  __ str(LR, Address(SP, wordSize)); \/\/ save deopt PC\n-  __ pop(LR); \/\/ restore LR\n+  Label start;\n+  __ bind(start);\n+\n@@ -918,0 +889,10 @@\n+  int entry_offset = __ offset();\n+  address deopt_pc = __ pc();\n+  \/\/ Preserve R0 and reserve space for the address of the entry point\n+  __ push(RegisterSet(R0) | RegisterSet(R1));\n+  \/\/ Store the entry point address\n+  __ mov_relative_address(R0, deopt_pc);\n+  __ str(R0, Address(SP, wordSize));\n+  __ pop(R0); \/\/ restore R0\n+  __ b(start);\n+\n@@ -921,1 +902,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":14,"deletions":33,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -275,0 +275,6 @@\n+  Label start;\n+  __ bind(start);\n+\n+  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+\n+  int entry_offset = __ offset();\n@@ -277,1 +283,1 @@\n-  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+  __ b(start);\n@@ -282,1 +288,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    _deopt_handler_size = 16\n+    _deopt_handler_size = 20\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,9 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  Unimplemented();\n+}\n+\n@@ -103,0 +112,5 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -37,1 +37,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/arm\/gc\/g1\/g1BarrierSetAssembler_arm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,24 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register addr, Register count, int callee_saved_regs) {\n+\n+  if (is_oop) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, addr, count, callee_saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register addr, Register count, Register tmp) {\n+  if (is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, addr, count, tmp);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address obj, Register new_val, Register tmp1, Register tmp2, Register tmp3, bool is_null) {\n+  if (type == T_OBJECT || type == T_ARRAY) {\n+    oop_store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/cardTableBarrierSetAssembler_arm.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -31,1 +31,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -40,0 +40,3 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count, int callee_saved_regs) {}\n+\n@@ -42,0 +45,1 @@\n+\n@@ -44,0 +48,9 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register addr, Register count, int callee_saved_regs);\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register addr, Register count, Register tmp);\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address obj, Register val, Register tmp1, Register tmp2, Register tmp3, bool is_null);\n+\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/cardTableBarrierSetAssembler_arm.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register addr, Register count, int callee_saved_regs) {\n-\n-  if (is_oop) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, addr, count, callee_saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register addr, Register count, Register tmp) {\n-  if (is_oop) {\n-    gen_write_ref_array_post_barrier(masm, decorators, addr, count, tmp);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address obj, Register new_val, Register tmp1, Register tmp2, Register tmp3, bool is_null) {\n-  if (type == T_OBJECT || type == T_ARRAY) {\n-    oop_store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/modRefBarrierSetAssembler_arm.cpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ARM_GC_SHARED_MODREFBARRIERSETASSEMBLER_ARM_HPP\n-#define CPU_ARM_GC_SHARED_MODREFBARRIERSETASSEMBLER_ARM_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count, int callee_saved_regs) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register tmp) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address obj, Register val, Register tmp1, Register tmp2, Register tmp3, bool is_null) = 0;\n-\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register addr, Register count, int callee_saved_regs);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register addr, Register count, Register tmp);\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address obj, Register val, Register tmp1, Register tmp2, Register tmp3, bool is_null);\n-};\n-\n-#endif \/\/ CPU_ARM_GC_SHARED_MODREFBARRIERSETASSEMBLER_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/modRefBarrierSetAssembler_arm.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -185,2 +185,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in sparc.ad file)\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -72,1 +71,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/arm\/smallRegisterMap_arm.inline.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n","filename":"src\/hotspot\/cpu\/arm\/stackChunkFrameStream_arm.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -267,0 +267,3 @@\n+  Label start;\n+\n+  __ bind(start);\n@@ -268,0 +271,2 @@\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -272,1 +277,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  _deopt_handler_size = MacroAssembler::bl64_patchable_size\n+  _deopt_handler_size = MacroAssembler::bl64_patchable_size + BytesPerInstWord\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,3 +75,10 @@\n-  \/\/ nothing to do\n-  DEBUG_ONLY( intptr_t* lspp = (intptr_t*) &(f.get_ijava_state()->top_frame_sp); )\n-  assert(*lspp == f.unextended_sp() - f.fp(), \"should be \" INTPTR_FORMAT \" usp:\" INTPTR_FORMAT \" fp:\" INTPTR_FORMAT, *lspp, p2i(f.unextended_sp()), p2i(f.fp()));\n+  \/\/ Nothing to do. We don't save a last sp since we cannot use sp as esp.\n+  \/\/ Instead the top frame is trimmed when making an i2i call. The original\n+  \/\/ top_frame_sp is set when the frame is pushed (see generate_fixed_frame()).\n+  \/\/ An interpreter top frame that was just thawed is resized to top_frame_sp by the\n+  \/\/ resume adapter (see generate_cont_resume_interpreter_adapter()). So the assertion is\n+  \/\/ false, if we freeze again right after thawing as we do when redoing a vm call wasn't\n+  \/\/ successful.\n+  assert(_thread->interp_redoing_vm_call() ||\n+         ((intptr_t*)f.at_relative(ijava_idx(top_frame_sp)) == f.unextended_sp()),\n+         \"top_frame_sp:\" PTR_FORMAT \" usp:\" PTR_FORMAT, f.at_relative(ijava_idx(top_frame_sp)), p2i(f.unextended_sp()));\n@@ -340,0 +347,9 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  \/\/ Nothing to do on PPC because the interpreter does not use SP as expression stack pointer.\n+  \/\/ Instead there is a dedicated register R15_esp which is not affected by VM calls.\n+  return _top_frame.sp();\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+}\n+\n@@ -569,0 +585,13 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  frame enterSpecial = new_entry_frame();\n+  frame::common_abi* enterSpecial_abi = (frame::common_abi*)enterSpecial.sp();\n+\n+  enterSpecial_abi->lr = (intptr_t)StubRoutines::cont_preempt_stub();\n+\n+  log_develop_trace(continuations, preempt)(\"push_preempt_adapter enterSpecial sp: \" INTPTR_FORMAT \" adapter pc: \" INTPTR_FORMAT,\n+                                            p2i(enterSpecial_abi),\n+                                            p2i(StubRoutines::cont_preempt_stub()));\n+\n+  return enterSpecial.sp();\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-    uint64_t top_frame_sp; \/\/ Maybe define parent_frame_abi and move there.\n+    uint64_t top_frame_sp; \/\/ Original sp to be restored when returning from an i2i call\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -324,4 +324,4 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type,\n-                                     base, ind_or_offs, dst,\n-                                     tmp1, tmp2,\n-                                     preservation_level, L_handle_null);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type,\n+                                        base, ind_or_offs, dst,\n+                                        tmp1, tmp2,\n+                                        preservation_level, L_handle_null);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -42,1 +42,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -43,0 +44,60 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count, Register preserve1, Register preserve2) {\n+  if (type == T_OBJECT) {\n+    gen_write_ref_array_pre_barrier(masm, decorators,\n+                                    src, dst, count,\n+                                    preserve1, preserve2);\n+\n+    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+    if (!checkcast) {\n+      assert_different_registers(dst, count, R9_ARG7, R10_ARG8);\n+      \/\/ Save some arguments for epilogue, e.g. disjoint_long_copy_core destroys them.\n+      __ mr(R9_ARG7, dst);\n+      __ mr(R10_ARG8, count);\n+    }\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register dst, Register count, Register preserve) {\n+  if (type == T_OBJECT) {\n+    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+    if (!checkcast) {\n+      gen_write_ref_array_post_barrier(masm, decorators, R9_ARG7, R10_ARG8, preserve);\n+    } else {\n+      gen_write_ref_array_post_barrier(masm, decorators, dst, count, preserve);\n+    }\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Register base, RegisterOrConstant ind_or_offs, Register val,\n+                                            Register tmp1, Register tmp2, Register tmp3,\n+                                            MacroAssembler::PreservationLevel preservation_level) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type,\n+                 base, ind_or_offs, val,\n+                 tmp1, tmp2, tmp3,\n+                 preservation_level);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type,\n+                                  base, ind_or_offs, val,\n+                                  tmp1, tmp2, tmp3,\n+                                  preservation_level);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value,\n+                                                   Register tmp1, Register tmp2,\n+                                                   MacroAssembler::PreservationLevel preservation_level) {\n+  Label done;\n+  __ cmpdi(CR0, value, 0);\n+  __ beq(CR0, done);         \/\/ Use null as-is.\n+\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n+  __ ld(value, 0, tmp1);      \/\/ Resolve (untagged) jobject.\n+\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -32,1 +32,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -34,3 +34,0 @@\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register preserve);\n-\n@@ -41,0 +38,6 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register from, Register to, Register count,\n+                                               Register preserve1, Register preserve2) {}\n+  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                Register addr, Register count, Register preserve);\n+\n@@ -45,0 +48,18 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count,\n+                                  Register preserve1, Register preserve2);\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register dst, Register count,\n+                                  Register preserve);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Register base, RegisterOrConstant ind_or_offs, Register val,\n+                        Register tmp1, Register tmp2, Register tmp3,\n+                        MacroAssembler::PreservationLevel preservation_level);\n+\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value,\n+                               Register tmp1, Register tmp2,\n+                               MacroAssembler::PreservationLevel preservation_level);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.hpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2025 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-#include \"runtime\/jniHandles.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count, Register preserve1, Register preserve2) {\n-  if (type == T_OBJECT) {\n-    gen_write_ref_array_pre_barrier(masm, decorators,\n-                                    src, dst, count,\n-                                    preserve1, preserve2);\n-\n-    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-    if (!checkcast) {\n-      assert_different_registers(dst, count, R9_ARG7, R10_ARG8);\n-      \/\/ Save some arguments for epilogue, e.g. disjoint_long_copy_core destroys them.\n-      __ mr(R9_ARG7, dst);\n-      __ mr(R10_ARG8, count);\n-    }\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register dst, Register count, Register preserve) {\n-  if (type == T_OBJECT) {\n-    bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-    if (!checkcast) {\n-      gen_write_ref_array_post_barrier(masm, decorators, R9_ARG7, R10_ARG8, preserve);\n-    } else {\n-      gen_write_ref_array_post_barrier(masm, decorators, dst, count, preserve);\n-    }\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Register base, RegisterOrConstant ind_or_offs, Register val,\n-                                         Register tmp1, Register tmp2, Register tmp3,\n-                                         MacroAssembler::PreservationLevel preservation_level) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type,\n-                 base, ind_or_offs, val,\n-                 tmp1, tmp2, tmp3,\n-                 preservation_level);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type,\n-                                  base, ind_or_offs, val,\n-                                  tmp1, tmp2, tmp3,\n-                                  preservation_level);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value,\n-                                                Register tmp1, Register tmp2,\n-                                                MacroAssembler::PreservationLevel preservation_level) {\n-  Label done;\n-  __ cmpdi(CR0, value, 0);\n-  __ beq(CR0, done);         \/\/ Use null as-is.\n-\n-  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n-  __ ld(value, 0, tmp1);      \/\/ Resolve (untagged) jobject.\n-\n-  __ verify_oop(value, FILE_AND_LINE);\n-  __ bind(done);\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_PPC_GC_SHARED_MODREFBARRIERSETASSEMBLER_PPC_HPP\n-#define CPU_PPC_GC_SHARED_MODREFBARRIERSETASSEMBLER_PPC_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register from, Register to, Register count,\n-                                               Register preserve1, Register preserve2) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register preserve) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Register base, RegisterOrConstant ind_or_offs, Register val,\n-                            Register tmp1, Register tmp2, Register tmp3,\n-                            MacroAssembler::PreservationLevel preservation_level) = 0;\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count,\n-                                  Register preserve1, Register preserve2);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register dst, Register count,\n-                                  Register preserve);\n-\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Register base, RegisterOrConstant ind_or_offs, Register val,\n-                        Register tmp1, Register tmp2, Register tmp3,\n-                        MacroAssembler::PreservationLevel preservation_level);\n-\n-  virtual void resolve_jobject(MacroAssembler* masm, Register value,\n-                               Register tmp1, Register tmp2,\n-                               MacroAssembler::PreservationLevel preservation_level);\n-};\n-\n-#endif \/\/ CPU_PPC_GC_SHARED_MODREFBARRIERSETASSEMBLER_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.hpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -52,0 +52,1 @@\n+  \/\/ Use for vthread preemption\n@@ -53,0 +54,1 @@\n+  void call_VM_preemptable(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);\n@@ -57,1 +59,1 @@\n-    return r->is_nonvolatile() && ((r == R22) || (r == R31));\n+    return r->is_nonvolatile() && ((r == R24) || (r == R31));\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,2 @@\n+  assert(nonvolatile_accross_vthread_preemtion(R24_dispatch_addr),\n+         \"Requirement of field accesses (e.g. putstatic)\");\n@@ -865,0 +867,3 @@\n+  asm_assert_mem8_is_zero(in_bytes(JavaThread::preempt_alternate_return_offset()), R16_thread,\n+                          \"remove_activation: should not have alternate return address set\");\n+\n@@ -2017,1 +2022,2 @@\n-                                        Register arg_1, bool check_exceptions) {\n+                                                    Register arg_1,\n+                                                    bool check_exceptions) {\n@@ -2022,0 +2028,10 @@\n+  call_VM_preemptable(oop_result, entry_point, arg_1, noreg \/* arg_2 *\/, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result, address entry_point,\n+                                                    Register arg_1, Register arg_2,\n+                                                    bool check_exceptions) {\n+  if (!Continuations::enabled()) {\n+    call_VM(oop_result, entry_point, arg_1, arg_2, check_exceptions);\n+    return;\n+  }\n@@ -2024,0 +2040,3 @@\n+  Register tmp = R11_scratch1;\n+  assert_different_registers(arg_1, tmp);\n+  assert_different_registers(arg_2, tmp);\n@@ -2025,3 +2044,10 @@\n-  DEBUG_ONLY(ld(R0, in_bytes(JavaThread::preempt_alternate_return_offset()), R16_thread));\n-  DEBUG_ONLY(cmpdi(CR0, R0, 0));\n-  asm_assert_eq(\"Should not have alternate return address set\");\n+#ifdef ASSERT\n+  asm_assert_mem8_is_zero(in_bytes(JavaThread::preempt_alternate_return_offset()), R16_thread,\n+                          \"Should not have alternate return address set\");\n+  \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+  lwa(tmp, in_bytes(JavaThread::interp_at_preemptable_vmcall_cnt_offset()), R16_thread);\n+  addi(tmp, tmp, 1);\n+  cmpwi(CR0, tmp, 0);\n+  stw(tmp, in_bytes(JavaThread::interp_at_preemptable_vmcall_cnt_offset()), R16_thread);\n+  asm_assert(gt, \"call_VM_preemptable: should be > 0\");\n+#endif \/\/ ASSERT\n@@ -2030,1 +2056,1 @@\n-  assert(nonvolatile_accross_vthread_preemtion(R31) && nonvolatile_accross_vthread_preemtion(R22), \"\");\n+  assert(nonvolatile_accross_vthread_preemtion(R31) && nonvolatile_accross_vthread_preemtion(R24), \"\");\n@@ -2033,1 +2059,1 @@\n-  std(R22, _ijava_state_neg(fresult), R3_ARG1);\n+  std(R24, _ijava_state_neg(fresult), R3_ARG1);\n@@ -2038,0 +2064,2 @@\n+  assert(arg_2 != R4_ARG2, \"smashed argument\");\n+  mr_if_needed(R5_ARG3, arg_2, true \/* allow_noreg *\/);\n@@ -2039,1 +2067,1 @@\n-  call_VM(oop_result, entry_point, false \/*check_exceptions*\/, &resume_pc \/* last_java_pc *\/);\n+  call_VM(noreg \/* oop_result *\/, entry_point, false \/*check_exceptions*\/, &resume_pc \/* last_java_pc *\/);\n@@ -2042,0 +2070,8 @@\n+#ifdef ASSERT\n+  lwa(tmp, in_bytes(JavaThread::interp_at_preemptable_vmcall_cnt_offset()), R16_thread);\n+  addi(tmp, tmp, -1);\n+  cmpwi(CR0, tmp, 0);\n+  stw(tmp, in_bytes(JavaThread::interp_at_preemptable_vmcall_cnt_offset()), R16_thread);\n+  asm_assert(ge, \"call_VM_preemptable: should be >= 0\");\n+#endif \/\/ ASSERT\n+\n@@ -2046,0 +2082,1 @@\n+  \/\/ Preempted. Frames are already frozen on heap.\n@@ -2053,0 +2090,1 @@\n+\n@@ -2054,0 +2092,6 @@\n+  if (check_exceptions) {\n+    check_and_forward_exception(R11_scratch1, R12_scratch2);\n+  }\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result);\n+  }\n@@ -2057,2 +2101,0 @@\n-  if (!Continuations::enabled()) return;\n-\n@@ -2063,5 +2105,0 @@\n-  \/\/ Restore registers that are preserved across vthread preemption\n-  assert(nonvolatile_accross_vthread_preemtion(R31) && nonvolatile_accross_vthread_preemtion(R22), \"\");\n-  ld(R3_ARG1, _abi0(callers_sp), R1_SP); \/\/ load FP\n-  ld(R31, _ijava_state_neg(lresult), R3_ARG1);\n-  ld(R22, _ijava_state_neg(fresult), R3_ARG1);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -760,3 +760,3 @@\n-  load_const_optimized(bad, 0xbad0101babe11111);\n-  for (uint32_t i = 1; i < (sizeof(regs) \/ sizeof(Register)); i++) {\n-    mr(regs[i], bad);\n+  load_const_optimized(bad, 0xbad0101babe00000);\n+  for (int i = (sizeof(regs) \/ sizeof(Register)) - 1; i >= 0; i--) {\n+    addi(regs[i], bad, regs[i]->encoding());\n@@ -4344,1 +4344,0 @@\n-void MacroAssembler::asm_assert(bool check_equal, const char *msg) {\n@@ -4346,0 +4345,1 @@\n+void MacroAssembler::asm_assert(AsmAssertCond cond, const char *msg) {\n@@ -4347,1 +4347,2 @@\n-  if (check_equal) {\n+  switch (cond) {\n+  case eq:\n@@ -4349,1 +4350,2 @@\n-  } else {\n+    break;\n+  case ne:\n@@ -4351,0 +4353,15 @@\n+    break;\n+  case ge:\n+    bge(CR0, ok);\n+    break;\n+  case gt:\n+    bgt(CR0, ok);\n+    break;\n+  case lt:\n+    blt(CR0, ok);\n+    break;\n+  case le:\n+    ble(CR0, ok);\n+    break;\n+  default:\n+    assert(false, \"unknown cond:%d\", cond);\n@@ -4354,1 +4371,0 @@\n-#endif\n@@ -4357,2 +4373,1 @@\n-#ifdef ASSERT\n-void MacroAssembler::asm_assert_mems_zero(bool check_equal, int size, int mem_offset,\n+void MacroAssembler::asm_assert_mems_zero(AsmAssertCond cond, int size, int mem_offset,\n@@ -4372,1 +4387,1 @@\n-  asm_assert(check_equal, msg);\n+  asm_assert(cond, msg);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  inline void mr_if_needed(Register rd, Register rs);\n+  inline void mr_if_needed(Register rd, Register rs, bool allow_invalid = false);\n@@ -945,3 +945,11 @@\n-  void asm_assert(bool check_equal, const char* msg);\n-  void asm_assert_eq(const char* msg) { asm_assert(true, msg); }\n-  void asm_assert_ne(const char* msg) { asm_assert(false, msg); }\n+  enum AsmAssertCond {\n+    eq,\n+    ne,\n+    ge,\n+    gt,\n+    lt,\n+    le\n+  };\n+  void asm_assert(AsmAssertCond cond, const char* msg) PRODUCT_RETURN;\n+  void asm_assert_eq(const char* msg) { asm_assert(eq, msg); }\n+  void asm_assert_ne(const char* msg) { asm_assert(ne, msg); }\n@@ -950,1 +958,1 @@\n-  void asm_assert_mems_zero(bool check_equal, int size, int mem_offset, Register mem_base,\n+  void asm_assert_mems_zero(AsmAssertCond cond, int size, int mem_offset, Register mem_base,\n@@ -956,1 +964,1 @@\n-    asm_assert_mems_zero(true,  8, mem_offset, mem_base, msg);\n+    asm_assert_mems_zero(eq,  8, mem_offset, mem_base, msg);\n@@ -959,1 +967,1 @@\n-    asm_assert_mems_zero(false, 8, mem_offset, mem_base, msg);\n+    asm_assert_mems_zero(ne, 8, mem_offset, mem_base, msg);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-inline void MacroAssembler::mr_if_needed(Register rd, Register rs) {\n+inline void MacroAssembler::mr_if_needed(Register rd, Register rs, bool allow_noreg) {\n+  if (allow_noreg && (rs == noreg)) return;\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2091,1 +2091,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2094,5 +2093,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ The exception_handler is a b64_patchable.\n-    return MacroAssembler::b64_patchable_size;\n-  }\n-\n@@ -2101,1 +2095,1 @@\n-    return MacroAssembler::bl64_patchable_size;\n+    return MacroAssembler::bl64_patchable_size + BytesPerInstWord;\n@@ -2117,16 +2111,0 @@\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  __ b64_patchable((address)OptoRuntime::exception_blob()->content_begin(),\n-                       relocInfo::runtime_call_type);\n-  assert(__ offset() - offset == (int)size_exception_handler(), \"must be fixed size\");\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -2143,0 +2121,4 @@\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -2145,0 +2127,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ b(start);\n+\n@@ -2148,1 +2135,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-                         int return_pc_adjustment,\n@@ -265,1 +264,0 @@\n-                         int return_pc_adjustment,\n@@ -274,1 +272,0 @@\n-  \/\/ If return_pc_adjustment != 0 adjust the return pc by return_pc_adjustment.\n@@ -308,1 +305,1 @@\n-    case return_pc_is_pre_saved: assert(return_pc_adjustment == 0, \"unsupported\"); break;\n+    case return_pc_is_pre_saved: break;\n@@ -313,3 +310,0 @@\n-    if (return_pc_adjustment != 0) {\n-      __ addi(R31, R31, return_pc_adjustment);\n-    }\n@@ -2910,2 +2904,0 @@\n-  \/\/ So currently SR_LR points behind the call in the deopt handler.\n-  \/\/ We adjust it such that it points to the start of the deopt handler.\n@@ -2915,4 +2907,0 @@\n-  \/\/ We can't grab a free register here, because all registers may\n-  \/\/ contain live values, so let the RegisterSaver do the adjustment\n-  \/\/ of the return pc.\n-  const int return_pc_adjustment_no_exception = -MacroAssembler::bl64_patchable_size;\n@@ -2925,1 +2913,0 @@\n-                                                                   return_pc_adjustment_no_exception,\n@@ -2960,1 +2947,0 @@\n-                                                             \/*return_pc_adjustment_exception=*\/ 0,\n@@ -2978,1 +2964,0 @@\n-                                                             \/*return_pc_adjustment_reexecute=*\/ 0,\n@@ -3269,1 +3254,0 @@\n-                                                                   \/*return_pc_adjustment=*\/0,\n@@ -3370,1 +3354,0 @@\n-                                                                   \/*return_pc_adjustment*\/ 0,\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,3 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n@@ -37,5 +38,3 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -43,0 +42,1 @@\n+ public:\n@@ -64,1 +64,1 @@\n-    guarantee (false, \"\");\n+    guarantee (false, \"unreachable\");\n@@ -71,1 +71,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n@@ -79,1 +79,1 @@\n-    Unimplemented();\n+    assert(false, \"Shouldn't reach here! p:\" PTR_FORMAT \" sp:\" PTR_FORMAT, p2i(p), p2i(p));\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -179,1 +179,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n@@ -182,1 +183,0 @@\n-  InterpreterOopMap mask;\n@@ -184,6 +184,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return  mask.num_oops()\n-          + 1 \/\/ for the mirror oop\n-          + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-          + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-                                 (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -705,0 +705,5 @@\n+  \/\/ Restore registers that are preserved across vthread preemption\n+  assert(__ nonvolatile_accross_vthread_preemtion(R31) && __ nonvolatile_accross_vthread_preemtion(R24), \"\");\n+  __ ld(R3_ARG1, _abi0(callers_sp), R1_SP); \/\/ load FP\n+  __ ld(R31, _ijava_state_neg(lresult), R3_ARG1);\n+  __ ld(R24, _ijava_state_neg(fresult), R3_ARG1);\n@@ -1252,1 +1257,1 @@\n-  const Register access_flags         = R22_tmp2;\n+  const Register access_flags         = R24_tmp4;\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2217,1 +2217,1 @@\n-  __ call_VM(noreg, entry, R4_ARG2);\n+  __ call_VM_preemptable(noreg, entry, R4_ARG2);\n@@ -2265,1 +2265,1 @@\n-  __ call_VM(noreg, entry, R4_ARG2);\n+  __ call_VM_preemptable(noreg, entry, R4_ARG2);\n@@ -3867,1 +3867,1 @@\n-  call_VM(R17_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), Rcpool, Rindex);\n+  __ call_VM_preemptable(R17_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), Rcpool, Rindex);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -37,1 +38,0 @@\n-#include <type_traits>\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -380,2 +380,8 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ j(start);\n+\n@@ -385,1 +391,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    \/\/ auipc (1) + far_jump (2)\n+    \/\/ far_call (2) + j (1)\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -210,0 +210,35 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  intptr_t* sp = _top_frame.sp();\n+  if (_top_frame.is_interpreted_frame()) {\n+    \/\/ In case the top frame is interpreted we need to set up the anchor using\n+    \/\/ the last_sp saved in the frame (remove possible alignment added while\n+    \/\/ thawing, see ThawBase::finish_thaw()). We also clear last_sp to match\n+    \/\/ the behavior when calling the VM from the interpreter (we check for this\n+    \/\/ in FreezeBase::prepare_freeze_interpreted_top_frame, which can be reached\n+    \/\/ if preempting again at redo_vmcall()).\n+    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n+    assert(_last_sp_from_frame != nullptr, \"\");\n+    _top_frame.interpreter_frame_set_last_sp(nullptr);\n+    if (sp != _last_sp_from_frame) {\n+      \/\/ We need to move up return pc and fp. They will be read next in\n+      \/\/ set_anchor() and set as _last_Java_pc and _last_Java_fp respectively.\n+      _last_sp_from_frame[-1] = (intptr_t)_top_frame.pc();\n+      _last_sp_from_frame[-2] = (intptr_t)_top_frame.fp();\n+    }\n+    _is_interpreted = true;\n+    sp = _last_sp_from_frame;\n+  }\n+  return sp;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  if (_is_interpreted) {\n+    \/\/ Restore last_sp_from_frame and possibly overwritten pc.\n+    _top_frame.interpreter_frame_set_last_sp(_last_sp_from_frame);\n+    intptr_t* sp = _top_frame.sp();\n+    if (sp != _last_sp_from_frame) {\n+      sp[-1] = (intptr_t)_top_frame.pc();\n+    }\n+  }\n+}\n+\n@@ -308,0 +343,1 @@\n+  \/\/ We only need to set the return pc. fp will be restored back in gen_continuation_enter().\n@@ -309,1 +345,6 @@\n-  sp[-2] = (intptr_t)enterSpecial.fp();\n+  return sp;\n+}\n+\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n@@ -311,1 +352,2 @@\n-  log_develop_trace(continuations, preempt)(\"push_cleanup_continuation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT, p2i(sp + 2 * frame::metadata_words), p2i(sp));\n+  \/\/ We only need to set the return pc. fp will be restored back in generate_cont_preempt_stub().\n+  sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -40,1 +40,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,23 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register src, Register dst, Register count, RegSet saved_regs) {\n+  if (is_oop) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                      Register start, Register count, Register tmp,\n+                                                      RegSet saved_regs) {\n+  if (is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/cardTableBarrierSetAssembler_riscv.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -32,1 +32,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -36,0 +36,3 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count, RegSet saved_regs) {}\n+\n@@ -38,0 +41,1 @@\n+\n@@ -40,0 +44,10 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register src, Register dst, Register count, RegSet saved_regs);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/cardTableBarrierSetAssembler_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register src, Register dst, Register count, RegSet saved_regs) {\n-  if (is_oop) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                                   Register start, Register count, Register tmp,\n-                                                   RegSet saved_regs) {\n-  if (is_oop) {\n-    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/modRefBarrierSetAssembler_riscv.cpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_RISCV_GC_SHARED_MODREFBARRIERSETASSEMBLER_RISCV_HPP\n-#define CPU_RISCV_GC_SHARED_MODREFBARRIERSETASSEMBLER_RISCV_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count, RegSet saved_regs) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register start, Register count, Register tmp, RegSet saved_regs) {}\n-\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register src, Register dst, Register count, RegSet saved_regs);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n-                                  Register start, Register count, Register tmp, RegSet saved_regs);\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-};\n-\n-#endif \/\/ CPU_RISCV_GC_SHARED_MODREFBARRIERSETASSEMBLER_RISCV_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/modRefBarrierSetAssembler_riscv.hpp","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -521,0 +521,8 @@\n+#ifdef ASSERT\n+  Label not_preempted;\n+  ld(t0, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+  beqz(t0, not_preempted);\n+  stop(\"remove_activation: should not have alternate return address set\");\n+  bind(not_preempted);\n+#endif \/* ASSERT *\/\n+\n@@ -1444,0 +1452,1 @@\n+                                             Label*   return_pc,\n@@ -1466,3 +1475,3 @@\n-                               entry_point, number_of_arguments,\n-                               check_exceptions);\n-\/\/ interpreter specific\n+                               return_pc, entry_point,\n+                               number_of_arguments, check_exceptions);\n+  \/\/ interpreter specific\n@@ -1473,4 +1482,6 @@\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                                                    address entry_point,\n-                                                    Register arg_1) {\n-  assert(arg_1 == c_rarg1, \"\");\n+void InterpreterMacroAssembler::call_VM_preemptable_helper(Register oop_result,\n+                                                           address entry_point,\n+                                                           int number_of_arguments,\n+                                                           bool check_exceptions) {\n+  assert(InterpreterRuntime::is_preemptable_call(entry_point),\n+         \"VM call not preemptable, should use call_VM()\");\n@@ -1481,1 +1492,1 @@\n-    Label L;\n+    Label L1, L2;\n@@ -1483,3 +1494,9 @@\n-    beqz(t0, L);\n-    stop(\"Should not have alternate return address set\");\n-    bind(L);\n+    beqz(t0, L1);\n+    stop(\"call_VM_preemptable_helper: Should not have alternate return address set\");\n+    bind(L1);\n+    \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+    incrementw(Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    lw(t0, Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    bgtz(t0, L2);\n+    stop(\"call_VM_preemptable_helper: should be > 0\");\n+    bind(L2);\n@@ -1493,3 +1510,2 @@\n-  la(t0, resume_pc);\n-  sd(t0, Address(xthread, JavaThread::last_Java_pc_offset()));\n-  call_VM_base(oop_result, noreg, noreg, entry_point, 1, false \/*check_exceptions*\/);\n+  \/\/ Note: call_VM_base will use resume_pc label to set last_Java_pc.\n+  call_VM_base(noreg, noreg, noreg, &resume_pc, entry_point, number_of_arguments, false \/*check_exceptions*\/);\n@@ -1499,0 +1515,11 @@\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    decrementw(Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    lw(t0, Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    bgez(t0, L);\n+    stop(\"call_VM_preemptable_helper: should be >= 0\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n@@ -1510,0 +1537,45 @@\n+  if (check_exceptions) {\n+    \/\/ check for pending exceptions\n+    ld(t0, Address(xthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    beqz(t0, ok);\n+    la(t1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    jr(t1);\n+    bind(ok);\n+  }\n+\n+  \/\/ get oop result if there is one and reset the value in the thread\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result, xthread);\n+  }\n+}\n+\n+static void pass_arg1(MacroAssembler* masm, Register arg) {\n+  if (c_rarg1 != arg) {\n+    masm->mv(c_rarg1, arg);\n+  }\n+}\n+\n+static void pass_arg2(MacroAssembler* masm, Register arg) {\n+  if (c_rarg2 != arg) {\n+    masm->mv(c_rarg2, arg);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         bool check_exceptions) {\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 1, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         Register arg_2,\n+                                         bool check_exceptions) {\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n+  pass_arg2(this, arg_2);\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 2, check_exceptions);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":86,"deletions":14,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                            Label*   return_pc,\n@@ -62,0 +63,1 @@\n+  \/\/ Use for vthread preemption\n@@ -64,1 +66,9 @@\n-                           Register arg_1);\n+                           Register arg_1,\n+                           bool check_exceptions = true);\n+\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1,\n+                           Register arg_2,\n+                           bool check_exceptions = true);\n+\n@@ -67,0 +77,7 @@\n+ private:\n+  void call_VM_preemptable_helper(Register oop_result,\n+                                  address entry_point,\n+                                  int number_of_arguments,\n+                                  bool check_exceptions);\n+\n+ public:\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, noreg, noreg, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -287,1 +287,1 @@\n-  call_VM_base(oop_result, xthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, xthread, last_java_sp, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -412,4 +412,0 @@\n-static bool is_preemptable(address entry_point) {\n-  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter);\n-}\n-\n@@ -419,0 +415,1 @@\n+                                  Label*   return_pc,\n@@ -426,0 +423,1 @@\n+\n@@ -445,6 +443,1 @@\n-  if (is_preemptable(entry_point)) {\n-    \/\/ skip setting last_pc since we already set it to desired value.\n-    set_last_Java_frame(last_java_sp, fp, noreg);\n-  } else {\n-    set_last_Java_frame(last_java_sp, fp, l, t0);\n-  }\n+  set_last_Java_frame(last_java_sp, fp, return_pc != nullptr ? *return_pc : l, t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+    Label*   return_pc,                \/\/ to set up last_Java_frame; use nullptr otherwise\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1052,1 +1052,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1055,4 +1054,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_branch_size();\n-  }\n-\n@@ -1060,1 +1055,1 @@\n-    \/\/ count auipc + far branch\n+    \/\/ count far call + j\n@@ -1187,0 +1182,2 @@\n+constexpr uint64_t MAJIK_DWORD = 0xabbaabbaabbaabbaull;\n+\n@@ -1366,3 +1363,0 @@\n-  st->print(\"sd  fp, [sp, #%d]\\n\\t\", - 2 * wordSize);\n-  st->print(\"sd  ra, [sp, #%d]\\n\\t\", - wordSize);\n-  if (PreserveFramePointer) { st->print(\"sub  fp, sp, #%d\\n\\t\", 2 * wordSize); }\n@@ -1370,0 +1364,8 @@\n+  st->print(\"sd  fp, [sp, #%d]\\n\\t\", framesize - 2 * wordSize);\n+  st->print(\"sd  ra, [sp, #%d]\\n\\t\", framesize - wordSize);\n+  if (PreserveFramePointer) { st->print(\"add fp, sp, #%d\\n\\t\", framesize); }\n+\n+  if (VerifyStackAtCalls) {\n+    st->print(\"mv  t2, %ld\\n\\t\", MAJIK_DWORD);\n+    st->print(\"sd  t2, [sp, #%d]\\n\\t\", framesize - 3 * wordSize);\n+  }\n@@ -1411,0 +1413,5 @@\n+  if (VerifyStackAtCalls) {\n+    __ mv(t2, MAJIK_DWORD);\n+    __ sd(t2, Address(sp, framesize - 3 * wordSize));\n+  }\n+\n@@ -1432,4 +1439,0 @@\n-  if (VerifyStackAtCalls) {\n-    Unimplemented();\n-  }\n-\n@@ -1833,19 +1836,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ auipc t1, #exception_blob_entry_point\n-  \/\/ jr (offset)t1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -1862,2 +1846,7 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ j(start);\n@@ -1867,1 +1856,1 @@\n-  return offset;\n+  return entry_offset;\n@@ -2434,1 +2423,7 @@\n-      __ call_Unimplemented();\n+      int framesize = ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3 * VMRegImpl::slots_per_word));\n+      Label stack_ok;\n+      __ ld(t1, Address(sp, framesize));\n+      __ mv(t2, MAJIK_DWORD);\n+      __ beq(t2, t1, stack_ok);\n+      __ stop(\"MAJIK_DWORD not found\");\n+      __ bind(stack_ok);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":31,"deletions":36,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -252,2 +252,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in riscv.ad file)\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2371,1 +2371,1 @@\n-  return 2 * VMRegImpl::slots_per_word;\n+  return 2 * VMRegImpl::slots_per_word + (VerifyStackAtCalls ? 0 : 2) ;\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -45,0 +44,1 @@\n+\n@@ -74,1 +74,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n@@ -112,1 +113,0 @@\n-  InterpreterOopMap mask;\n@@ -114,6 +114,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-        + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-              (intptr_t*)f.interpreter_frame_monitor_end()) \/ BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2210,1 +2210,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -2263,1 +2263,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -3616,1 +3616,1 @@\n-  call_VM(x10, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n+  __ call_VM_preemptable(x10, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -275,1 +275,7 @@\n-  }  int offset = code_offset();\n+  }\n+\n+  int offset = code_offset();\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -279,0 +285,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -282,1 +293,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,0 +71,9 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  Unimplemented();\n+}\n+\n@@ -103,0 +112,5 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, src, dst, tmp1, tmp2, L_handle_null);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, src, dst, tmp1, tmp2, L_handle_null);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -38,1 +38,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -45,0 +46,38 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count) {\n+  if (is_reference_type(type)) {\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register dst, Register count, bool do_return) {\n+  if (is_reference_type(type)) {\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, do_return);\n+  } else {\n+    if (do_return) { __ z_br(Z_R14); }\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n+  NearLabel done;\n+\n+  __ z_ltgr(value, value);\n+  __ z_bre(done);  \/\/ use null as-is.\n+\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n+  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n+\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/cardTableBarrierSetAssembler_s390.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -32,1 +32,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -36,0 +36,2 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count) {}\n+\n@@ -41,0 +43,11 @@\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register dst, Register count, bool do_return = false);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n+\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/cardTableBarrierSetAssembler_s390.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-#include \"runtime\/jniHandles.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count,\n-                                                                 bool do_return) {\n-  if (do_return) { __ z_br(Z_R14); }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count) {\n-  if (is_reference_type(type)) {\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register dst, Register count, bool do_return) {\n-  if (is_reference_type(type)) {\n-    gen_write_ref_array_post_barrier(masm, decorators, dst, count, do_return);\n-  } else {\n-    if (do_return) { __ z_br(Z_R14); }\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n-  NearLabel done;\n-\n-  __ z_ltgr(value, value);\n-  __ z_bre(done);  \/\/ use null as-is.\n-\n-  __ z_nill(value, ~JNIHandles::tag_mask);\n-  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n-\n-  __ verify_oop(value, FILE_AND_LINE);\n-  __ bind(done);\n-}\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.cpp","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_S390_GC_SHARED_MODREFBARRIERSETASSEMBLER_S390_HPP\n-#define CPU_S390_GC_SHARED_MODREFBARRIERSETASSEMBLER_S390_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators, Register addr, Register count,\n-                                                bool do_return);\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register dst, Register count, bool do_return = false);\n-\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        const Address& dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-\n-  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n-};\n-\n-#endif \/\/ CPU_S390_GC_SHARED_MODREFBARRIERSETASSEMBLER_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.hpp","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -578,5 +578,11 @@\n-  \/\/ Record top_frame_sp, because the callee might modify it, if it's compiled.\n-  assert_different_registers(Z_R1, method);\n-  z_sgrk(Z_R1, Z_SP, Z_fp);\n-  z_srag(Z_R1, Z_R1, Interpreter::logStackElementSize);\n-  z_stg(Z_R1, _z_ijava_state_neg(top_frame_sp), Z_fp);\n+#ifdef ASSERT\n+  NearLabel ok;\n+  Register tmp = Z_R1;\n+  z_lg(tmp, Address(Z_fp, _z_ijava_state_neg(top_frame_sp)));\n+  z_slag(tmp, tmp, Interpreter::logStackElementSize);\n+  z_agr(tmp, Z_fp);\n+  z_cgr(tmp, Z_SP);\n+  z_bre(ok);\n+  stop(\"corrupted top_frame_sp\");\n+  bind(ok);\n+#endif\n@@ -1921,0 +1927,5 @@\n+  \/\/ Rtemp3 is free at this point, use it to store top_frame_sp\n+  z_sgrk(Rtemp3, Z_SP, Z_fp);\n+  z_srag(Rtemp3, Rtemp3, Interpreter::logStackElementSize);\n+  reg2mem_opt(Rtemp3, Address(Z_fp, _z_ijava_state_neg(top_frame_sp)));\n+\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in s390.ad file)\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1652,1 +1652,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1655,4 +1654,0 @@\n-  static uint size_exception_handler() {\n-    return NativeJump::max_instruction_size();\n-  }\n-\n@@ -1660,1 +1655,1 @@\n-    return NativeCall::max_instruction_size();\n+    return NativeCall::max_instruction_size() + MacroAssembler::jump_pcrelative_size();\n@@ -1675,37 +1670,0 @@\n-\/\/ This exception handler code snippet is placed after the method's\n-\/\/ code. It is the return point if an exception occurred. it jumps to\n-\/\/ the exception blob.\n-\/\/\n-\/\/ If the method gets deoptimized, the method and this code snippet\n-\/\/ get patched.\n-\/\/\n-\/\/ 1) Trampoline code gets patched into the end of this exception\n-\/\/   handler. the trampoline code jumps to the deoptimization blob.\n-\/\/\n-\/\/ 2) The return address in the method's code will get patched such\n-\/\/   that it jumps to the trampoline.\n-\/\/\n-\/\/ 3) The handler will get patched such that it does not jump to the\n-\/\/   exception blob, but to an entry in the deoptimization blob being\n-\/\/   aware of the exception.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  Register temp_reg = Z_R1;\n-\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;          \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  \/\/ Use unconditional pc-relative jump with 32-bit range here.\n-  __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()->content_begin());\n-  __ z_br(temp_reg);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -1723,0 +1681,3 @@\n+  Label start;\n+  __ bind(start);\n+\n@@ -1727,0 +1688,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -1730,1 +1696,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2547,2 +2547,1 @@\n-  \/\/ Z_R14 points behind the call in the deopt handler. We adjust\n-  \/\/ it such that it points to the start of the deopt handler.\n+  \/\/ Z_R14 points to the entry point of the deopt handler.\n@@ -2552,3 +2551,0 @@\n-  \/\/ The (int) cast is necessary, because -((unsigned int)14)\n-  \/\/ is an unsigned int.\n-  __ add2reg(Z_R14, -(int)NativeCall::max_instruction_size());\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,5 +31,10 @@\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+class SmallRegisterMap;\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller SmallRegisterMapType\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -72,1 +71,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/s390\/smallRegisterMap_s390.inline.hpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n","filename":"src\/hotspot\/cpu\/s390\/stackChunkFrameStream_s390.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1103,0 +1103,5 @@\n+\n+  __ z_lcgr(top_frame_size);  \/\/ negate\n+  __ z_srag(top_frame_size, top_frame_size, Interpreter::logStackElementSize);\n+  \/\/ Store relativized top_frame_sp\n+  __ z_stg(top_frame_size, _z_ijava_state_neg(top_frame_sp), fp);\n@@ -2077,0 +2082,8 @@\n+  {\n+    Register top_frame_sp = Z_R1_scratch; \/\/ anyway going to load it with correct value\n+    __ z_lg(top_frame_sp, Address(Z_fp, _z_ijava_state_neg(top_frame_sp)));\n+    __ z_slag(top_frame_sp, top_frame_sp, Interpreter::logStackElementSize);\n+    __ z_agr(top_frame_sp, Z_fp);\n+\n+    __ resize_frame_absolute(top_frame_sp, \/* temp = *\/ Z_R0, \/* load_fp = *\/ true);\n+  }\n@@ -2184,0 +2197,8 @@\n+  {\n+    Register top_frame_sp = Z_R1_scratch;\n+    __ z_lg(top_frame_sp, Address(Z_fp, _z_ijava_state_neg(top_frame_sp)));\n+    __ z_slag(top_frame_sp, top_frame_sp, Interpreter::logStackElementSize);\n+    __ z_agr(top_frame_sp, Z_fp);\n+\n+    __ resize_frame_absolute(top_frame_sp, \/* temp = *\/ Z_R0, \/* load_fp = *\/ true);\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -123,21 +123,0 @@\n-#ifndef _LP64\n-int AbstractInterpreter::BasicType_as_index(BasicType type) {\n-  int i = 0;\n-  switch (type) {\n-    case T_BOOLEAN: i = 0; break;\n-    case T_CHAR   : i = 1; break;\n-    case T_BYTE   : i = 2; break;\n-    case T_SHORT  : i = 3; break;\n-    case T_INT    : \/\/ fall through\n-    case T_LONG   : \/\/ fall through\n-    case T_VOID   : i = 4; break;\n-    case T_FLOAT  : i = 5; break;  \/\/ have to treat float and double separately for SSE\n-    case T_DOUBLE : i = 6; break;\n-    case T_OBJECT : \/\/ fall through\n-    case T_ARRAY  : i = 7; break;\n-    default       : ShouldNotReachHere();\n-  }\n-  assert(0 <= i && i < AbstractInterpreter::number_of_result_handlers, \"index out of bounds\");\n-  return i;\n-}\n-#else\n@@ -164,1 +143,0 @@\n-#endif \/\/ _LP64\n@@ -176,3 +154,0 @@\n-#ifndef _LP64\n-  const int stub_code = 4;  \/\/ see generate_call_stub\n-#else\n@@ -180,1 +155,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/abstractInterpreter_x86.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2938,1 +2938,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n@@ -8074,1 +8073,0 @@\n-  NOT_LP64(assert(VM_Version::supports_sse2(), \"\"));\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -456,1 +456,0 @@\n-  InternalAddress here(__ pc());\n@@ -458,2 +457,9 @@\n-  __ pushptr(here.addr(), rscratch1);\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n+\n@@ -463,1 +469,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    _deopt_handler_size = 17\n+    _deopt_handler_size = 10\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#ifdef AMD64\n@@ -50,1 +49,1 @@\n-define_pd_global(size_t, NewSizeThreadIncrease,     ScaleForWordSize(4*K));\n+define_pd_global(size_t, NewSizeThreadIncrease,      ScaleForWordSize(4*K));\n@@ -55,8 +54,1 @@\n-#else\n-define_pd_global(intx,  InteriorEntryAlignment,      4);\n-define_pd_global(size_t, NewSizeThreadIncrease,      4*K);\n-define_pd_global(intx,  LoopUnrollLimit,             50);     \/\/ Design center runs on 1.3.1\n-\/\/ InitialCodeCacheSize derived from specjbb2000 run.\n-define_pd_global(size_t, InitialCodeCacheSize,       2304*K); \/\/ Integral multiple of CodeCacheExpansionSize\n-define_pd_global(size_t, CodeCacheExpansionSize,     32*K);\n-#endif \/\/ AMD64\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,8 +36,0 @@\n-  \/\/ QQQ presumably all 64bit cpu's support this. Seems like the ifdef could\n-  \/\/ simply be left out.\n-#ifndef AMD64\n-  if (!VM_Version::supports_cmov()) {\n-    ConditionalMoveLimit = 0;\n-  }\n-#endif \/\/ AMD64\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_init_x86.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-  return NOT_LP64(10)    \/\/ movl; jmp\n-         LP64_ONLY(15);  \/\/ movq (1+1+8); jmp (1+4)\n+  return 15;  \/\/ movq (1+1+8); jmp (1+4)\n","filename":"src\/hotspot\/cpu\/x86\/compiledIC_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#ifdef _LP64\n-\n@@ -57,2 +55,0 @@\n-\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -201,0 +201,35 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  intptr_t* sp = _top_frame.sp();\n+  if (_top_frame.is_interpreted_frame()) {\n+    \/\/ In case the top frame is interpreted we need to set up the anchor using\n+    \/\/ the last_sp saved in the frame (remove possible alignment added while\n+    \/\/ thawing, see ThawBase::finish_thaw()). We also clear last_sp to match\n+    \/\/ the behavior when calling the VM from the interpreter (we check for this\n+    \/\/ in FreezeBase::prepare_freeze_interpreted_top_frame, which can be reached\n+    \/\/ if preempting again at redo_vmcall()).\n+    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n+    assert(_last_sp_from_frame != nullptr, \"\");\n+    _top_frame.interpreter_frame_set_last_sp(nullptr);\n+    if (sp != _last_sp_from_frame) {\n+      \/\/ We need to move up return pc and fp. They will be read next in\n+      \/\/ set_anchor() and set as _last_Java_pc and _last_Java_fp respectively.\n+      _last_sp_from_frame[-1] = (intptr_t)_top_frame.pc();\n+      _last_sp_from_frame[-2] = (intptr_t)_top_frame.fp();\n+    }\n+    _is_interpreted = true;\n+    sp = _last_sp_from_frame;\n+  }\n+  return sp;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  if (_is_interpreted) {\n+    \/\/ Restore last_sp_from_frame and possibly overwritten pc.\n+    _top_frame.interpreter_frame_set_last_sp(_last_sp_from_frame);\n+    intptr_t* sp = _top_frame.sp();\n+    if (sp != _last_sp_from_frame) {\n+      sp[-1] = (intptr_t)_top_frame.pc();\n+    }\n+  }\n+}\n+\n@@ -301,0 +336,1 @@\n+  \/\/ We only need to set the return pc. rbp will be restored back in gen_continuation_enter().\n@@ -302,1 +338,6 @@\n-  sp[-2] = (intptr_t)enterSpecial.fp();\n+  return sp;\n+}\n+\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n@@ -304,1 +345,2 @@\n-  log_develop_trace(continuations, preempt)(\"push_cleanup_continuation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT, p2i(sp + 2 * frame::metadata_words), p2i(sp));\n+  \/\/ We only need to set the return pc. rbp will be restored back in generate_cont_preempt_stub().\n+  sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#ifdef AMD64\n@@ -37,7 +36,0 @@\n-#else\n-  juint* to = (juint*)tohw;\n-  count *= HeapWordSize \/ BytesPerInt;\n-  while (count-- > 0) {\n-    *to++ = value;\n-  }\n-#endif \/\/ AMD64\n@@ -63,1 +55,0 @@\n-#if defined AMD64 || defined _WINDOWS\n@@ -65,40 +56,0 @@\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp = 0;\n-  __asm__ volatile(\"        testl   %6,%6         ;\"\n-                   \"        jz      7f            ;\"\n-                   \"        cmpl    %4,%5         ;\"\n-                   \"        leal    -4(%4,%6,4),%3;\"\n-                   \"        jbe     1f            ;\"\n-                   \"        cmpl    %7,%5         ;\"\n-                   \"        jbe     4f            ;\"\n-                   \"1:      cmpl    $32,%6        ;\"\n-                   \"        ja      3f            ;\"\n-                   \"        subl    %4,%1         ;\"\n-                   \"2:      movl    (%4),%3       ;\"\n-                   \"        movl    %7,(%5,%4,1)  ;\"\n-                   \"        addl    $4,%0         ;\"\n-                   \"        subl    $1,%2          ;\"\n-                   \"        jnz     2b            ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"3:      rep;    smovl         ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"4:      cmpl    $32,%2        ;\"\n-                   \"        movl    %7,%0         ;\"\n-                   \"        leal    -4(%5,%6,4),%1;\"\n-                   \"        ja      6f            ;\"\n-                   \"        subl    %4,%1         ;\"\n-                   \"5:      movl    (%4),%3       ;\"\n-                   \"        movl    %7,(%5,%4,1)  ;\"\n-                   \"        subl    $4,%0         ;\"\n-                   \"        subl    $1,%2          ;\"\n-                   \"        jnz     5b            ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"6:      std                   ;\"\n-                   \"        rep;    smovl         ;\"\n-                   \"        cld                   ;\"\n-                   \"7:      nop                    \"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"flags\");\n-#endif \/\/ AMD64\n@@ -108,1 +59,0 @@\n-#ifdef AMD64\n@@ -123,24 +73,0 @@\n-#else\n-#if defined _WINDOWS\n-  (void)memcpy(to, from, count * HeapWordSize);\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp = 0;\n-  __asm__ volatile(\"        testl   %6,%6       ;\"\n-                   \"        jz      3f          ;\"\n-                   \"        cmpl    $32,%6      ;\"\n-                   \"        ja      2f          ;\"\n-                   \"        subl    %4,%1       ;\"\n-                   \"1:      movl    (%4),%3     ;\"\n-                   \"        movl    %7,(%5,%4,1);\"\n-                   \"        addl    $4,%0       ;\"\n-                   \"        subl    $1,%2        ;\"\n-                   \"        jnz     1b          ;\"\n-                   \"        jmp     3f          ;\"\n-                   \"2:      rep;    smovl       ;\"\n-                   \"3:      nop                  \"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"cc\");\n-#endif \/\/ _WINDOWS\n-#endif \/\/ AMD64\n@@ -150,1 +76,0 @@\n-#ifdef AMD64\n@@ -152,4 +77,0 @@\n-#else\n-  \/\/ pd_disjoint_words is word-atomic in this implementation.\n-  pd_disjoint_words(from, to, count);\n-#endif \/\/ AMD64\n@@ -167,1 +88,0 @@\n-#if defined AMD64 || defined _WINDOWS\n@@ -169,74 +89,0 @@\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp = 0;\n-  __asm__ volatile(\"        testl   %6,%6          ;\"\n-                   \"        jz      13f            ;\"\n-                   \"        cmpl    %4,%5          ;\"\n-                   \"        leal    -1(%4,%6),%3   ;\"\n-                   \"        jbe     1f             ;\"\n-                   \"        cmpl    %7,%5          ;\"\n-                   \"        jbe     8f             ;\"\n-                   \"1:      cmpl    $3,%6          ;\"\n-                   \"        jbe     6f             ;\"\n-                   \"        movl    %6,%3          ;\"\n-                   \"        movl    $4,%2          ;\"\n-                   \"        subl    %4,%2          ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      2f             ;\"\n-                   \"        subl    %6,%3          ;\"\n-                   \"        rep;    smovb          ;\"\n-                   \"2:      movl    %7,%2          ;\"\n-                   \"        shrl    $2,%2          ;\"\n-                   \"        jz      5f             ;\"\n-                   \"        cmpl    $32,%2         ;\"\n-                   \"        ja      4f             ;\"\n-                   \"        subl    %4,%1          ;\"\n-                   \"3:      movl    (%4),%%edx     ;\"\n-                   \"        movl    %%edx,(%5,%4,1);\"\n-                   \"        addl    $4,%0          ;\"\n-                   \"        subl    $1,%2           ;\"\n-                   \"        jnz     3b             ;\"\n-                   \"        addl    %4,%1          ;\"\n-                   \"        jmp     5f             ;\"\n-                   \"4:      rep;    smovl          ;\"\n-                   \"5:      movl    %7,%2          ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      13f            ;\"\n-                   \"6:      xorl    %7,%3          ;\"\n-                   \"7:      movb    (%4,%7,1),%%dl ;\"\n-                   \"        movb    %%dl,(%5,%7,1) ;\"\n-                   \"        addl    $1,%3          ;\"\n-                   \"        subl    $1,%2           ;\"\n-                   \"        jnz     7b             ;\"\n-                   \"        jmp     13f            ;\"\n-                   \"8:      std                    ;\"\n-                   \"        cmpl    $12,%2         ;\"\n-                   \"        ja      9f             ;\"\n-                   \"        movl    %7,%0          ;\"\n-                   \"        leal    -1(%6,%5),%1   ;\"\n-                   \"        jmp     11f            ;\"\n-                   \"9:      xchgl   %3,%2          ;\"\n-                   \"        movl    %6,%0          ;\"\n-                   \"        addl    $1,%2          ;\"\n-                   \"        leal    -1(%7,%5),%1   ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      10f            ;\"\n-                   \"        subl    %6,%3          ;\"\n-                   \"        rep;    smovb          ;\"\n-                   \"10:     movl    %7,%2          ;\"\n-                   \"        subl    $3,%0          ;\"\n-                   \"        shrl    $2,%2          ;\"\n-                   \"        subl    $3,%1          ;\"\n-                   \"        rep;    smovl          ;\"\n-                   \"        andl    $3,%3          ;\"\n-                   \"        jz      12f            ;\"\n-                   \"        movl    %7,%2          ;\"\n-                   \"        addl    $3,%0          ;\"\n-                   \"        addl    $3,%1          ;\"\n-                   \"11:     rep;    smovb          ;\"\n-                   \"12:     cld                    ;\"\n-                   \"13:     nop                    ;\"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"flags\", \"%edx\");\n-#endif \/\/ AMD64\n@@ -256,1 +102,0 @@\n-#ifdef AMD64\n@@ -258,5 +103,0 @@\n-#else\n-  assert(HeapWordSize == BytesPerInt, \"heapwords and jints must be the same size\");\n-  \/\/ pd_conjoint_words is word-atomic in this implementation.\n-  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n-#endif \/\/ AMD64\n@@ -266,1 +106,0 @@\n-#ifdef AMD64\n@@ -268,20 +107,0 @@\n-#else\n-  \/\/ Guarantee use of fild\/fistp or xmm regs via some asm code, because compilers won't.\n-  if (from > to) {\n-    while (count-- > 0) {\n-      __asm__ volatile(\"fildll (%0); fistpll (%1)\"\n-                       :\n-                       : \"r\" (from), \"r\" (to)\n-                       : \"memory\" );\n-      ++from;\n-      ++to;\n-    }\n-  } else {\n-    while (count-- > 0) {\n-      __asm__ volatile(\"fildll (%0,%2,8); fistpll (%1,%2,8)\"\n-                       :\n-                       : \"r\" (from), \"r\" (to), \"r\" (count)\n-                       : \"memory\" );\n-    }\n-  }\n-#endif \/\/ AMD64\n@@ -291,1 +110,0 @@\n-#ifdef AMD64\n@@ -294,5 +112,0 @@\n-#else\n-  assert(HeapWordSize == BytesPerOop, \"heapwords and oops must be the same size\");\n-  \/\/ pd_conjoint_words is word-atomic in this implementation.\n-  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n-#endif \/\/ AMD64\n@@ -310,1 +123,0 @@\n-#ifdef AMD64\n@@ -312,3 +124,0 @@\n-#else\n-  pd_conjoint_jints_atomic((const jint*)from, (jint*)to, count);\n-#endif \/\/ AMD64\n@@ -318,1 +127,0 @@\n-#ifdef AMD64\n@@ -320,3 +128,0 @@\n-#else\n-  pd_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n-#endif \/\/ AMD64\n@@ -326,1 +131,0 @@\n-#ifdef AMD64\n@@ -329,3 +133,0 @@\n-#else\n-  pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/copy_x86.hpp","additions":1,"deletions":200,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -542,2 +542,0 @@\n-    \/\/ QQQ seems like this code is equivalent on the two platforms\n-#ifdef AMD64\n@@ -547,3 +545,0 @@\n-#else\n-      tos_addr += 2;\n-#endif \/\/ AMD64\n@@ -575,13 +570,1 @@\n-    case T_FLOAT   : {\n-#ifdef AMD64\n-        value_result->f = *(jfloat*)tos_addr;\n-#else\n-      if (method->is_native()) {\n-        jdouble d = *(jdouble*)tos_addr;  \/\/ Result was in ST0 so need to convert to jfloat\n-        value_result->f = (jfloat)d;\n-      } else {\n-        value_result->f = *(jfloat*)tos_addr;\n-      }\n-#endif \/\/ AMD64\n-      break;\n-    }\n+    case T_FLOAT   : value_result->f = *(jfloat*)tos_addr; break;\n@@ -617,1 +600,0 @@\n-#ifdef AMD64\n@@ -625,1 +607,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-#ifdef AMD64\n-#ifdef _WIN64\n+#ifdef _WINDOWS\n@@ -94,4 +93,1 @@\n-#endif \/\/ _WIN64\n-#else\n-    entry_frame_call_wrapper_offset                  =  2,\n-#endif \/\/ AMD64\n+#endif \/\/ _WINDOWS\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_entry(), \"unexpected sender pc\");\n@@ -525,1 +525,0 @@\n-#ifdef AMD64\n@@ -533,1 +532,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n+  CardTableBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/cardTableBarrierSetAssembler.hpp\"\n@@ -37,1 +37,1 @@\n-class G1BarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class G1BarrierSetAssembler: public CardTableBarrierSetAssembler {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,52 @@\n+void CardTableBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count) {\n+  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n+\n+  if (is_reference_type(type)) {\n+    if (!checkcast) {\n+      if (!obj_int) {\n+        \/\/ Save count for barrier\n+        __ movptr(r11, count);\n+      } else if (disjoint) {\n+        \/\/ Save dst in r11 in the disjoint case\n+        __ movq(r11, dst);\n+      }\n+    }\n+    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                                      Register src, Register dst, Register count) {\n+  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n+  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n+  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n+  Register tmp = rax;\n+\n+  if (is_reference_type(type)) {\n+    if (!checkcast) {\n+      if (!obj_int) {\n+        \/\/ Save count for barrier\n+        count = r11;\n+      } else if (disjoint) {\n+        \/\/ Use the saved dst in the disjoint case\n+        dst = r11;\n+      }\n+    } else {\n+      tmp = rscratch1;\n+    }\n+    gen_write_ref_array_post_barrier(masm, decorators, dst, count, tmp);\n+  }\n+}\n+\n+void CardTableBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n+  if (is_reference_type(type)) {\n+    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  } else {\n+    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -31,1 +31,1 @@\n-class CardTableBarrierSetAssembler: public ModRefBarrierSetAssembler {\n+class CardTableBarrierSetAssembler: public BarrierSetAssembler {\n@@ -33,0 +33,3 @@\n+  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                               Register addr, Register count) {}\n+\n@@ -39,0 +42,11 @@\n+\n+public:\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n+\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                                  Register src, Register dst, Register count);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSetAssembler.hpp\"\n-\n-#define __ masm->\n-\n-void ModRefBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count) {\n-  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n-  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n-\n-  if (is_reference_type(type)) {\n-    if (!checkcast) {\n-      if (!obj_int) {\n-        \/\/ Save count for barrier\n-        __ movptr(r11, count);\n-      } else if (disjoint) {\n-        \/\/ Save dst in r11 in the disjoint case\n-        __ movq(r11, dst);\n-      }\n-    }\n-    gen_write_ref_array_pre_barrier(masm, decorators, dst, count);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                                   Register src, Register dst, Register count) {\n-  bool checkcast = (decorators & ARRAYCOPY_CHECKCAST) != 0;\n-  bool disjoint = (decorators & ARRAYCOPY_DISJOINT) != 0;\n-  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n-  Register tmp = rax;\n-\n-  if (is_reference_type(type)) {\n-    if (!checkcast) {\n-      if (!obj_int) {\n-        \/\/ Save count for barrier\n-        count = r11;\n-      } else if (disjoint) {\n-        \/\/ Use the saved dst in the disjoint case\n-        dst = r11;\n-      }\n-    } else {\n-      tmp = rscratch1;\n-    }\n-    gen_write_ref_array_post_barrier(masm, decorators, dst, count, tmp);\n-  }\n-}\n-\n-void ModRefBarrierSetAssembler::store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                         Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) {\n-  if (is_reference_type(type)) {\n-    oop_store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  } else {\n-    BarrierSetAssembler::store_at(masm, decorators, type, dst, val, tmp1, tmp2, tmp3);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/modRefBarrierSetAssembler_x86.cpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_X86_GC_SHARED_MODREFBARRIERSETASSEMBLER_X86_HPP\n-#define CPU_X86_GC_SHARED_MODREFBARRIERSETASSEMBLER_X86_HPP\n-\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"gc\/shared\/barrierSetAssembler.hpp\"\n-\n-\/\/ The ModRefBarrierSetAssembler filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetAssembler: public BarrierSetAssembler {\n-protected:\n-  virtual void gen_write_ref_array_pre_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                               Register addr, Register count) {}\n-  virtual void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n-                                                Register addr, Register count, Register tmp) {}\n-  virtual void oop_store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                            Address dst, Register val, Register tmp1, Register tmp2, Register tmp3) = 0;\n-public:\n-  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count);\n-  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                                  Register src, Register dst, Register count);\n-\n-  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n-};\n-\n-#endif \/\/ CPU_X86_GC_SHARED_MODREFBARRIERSETASSEMBLER_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/modRefBarrierSetAssembler_x86.hpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -331,4 +331,5 @@\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                                                    address entry_point,\n-                                                    Register arg_1) {\n-  assert(arg_1 == c_rarg1, \"\");\n+void InterpreterMacroAssembler::call_VM_preemptable_helper(Register oop_result,\n+                                                           address entry_point,\n+                                                           int number_of_arguments,\n+                                                           bool check_exceptions) {\n+  assert(InterpreterRuntime::is_preemptable_call(entry_point), \"VM call not preemptable, should use call_VM()\");\n@@ -339,1 +340,1 @@\n-    Label L;\n+    Label L1, L2;\n@@ -341,3 +342,9 @@\n-    jcc(Assembler::equal, L);\n-    stop(\"Should not have alternate return address set\");\n-    bind(L);\n+    jcc(Assembler::equal, L1);\n+    stop(\"call_VM_preemptable_helper: should not have alternate return address set\");\n+    bind(L1);\n+    \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+    incrementl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()), 0);\n+    jcc(Assembler::greater, L2);\n+    stop(\"call_VM_preemptable_helper: should be > 0\");\n+    bind(L2);\n@@ -351,1 +358,0 @@\n-  \/\/ Note: call_VM_helper requires last_Java_pc for anchor to be at the top of the stack.\n@@ -354,1 +360,2 @@\n-  MacroAssembler::call_VM_helper(oop_result, entry_point, 1, false \/*check_exceptions*\/);\n+  lea(rax, Address(rsp, wordSize));\n+  call_VM_base(noreg, rax, entry_point, number_of_arguments, false);\n@@ -359,0 +366,11 @@\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    decrementl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    cmpl(Address(r15_thread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()), 0);\n+    jcc(Assembler::greaterEqual, L);\n+    stop(\"call_VM_preemptable_helper: should be >= 0\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n@@ -371,0 +389,48 @@\n+  if (check_exceptions) {\n+    \/\/ check for pending exceptions\n+    cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+    Label ok;\n+    jcc(Assembler::equal, ok);\n+    \/\/ Exception stub expects return pc to be at top of stack. We only need\n+    \/\/ it to check Interpreter::contains(return_address) so anything will do.\n+    lea(rscratch1, resume_pc);\n+    push(rscratch1);\n+    jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    bind(ok);\n+  }\n+\n+  \/\/ get oop result if there is one and reset the value in the thread\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result);\n+  }\n+}\n+\n+static void pass_arg1(MacroAssembler* masm, Register arg) {\n+  if (c_rarg1 != arg ) {\n+    masm->mov(c_rarg1, arg);\n+  }\n+}\n+\n+static void pass_arg2(MacroAssembler* masm, Register arg) {\n+  if (c_rarg2 != arg ) {\n+    masm->mov(c_rarg2, arg);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         bool check_exceptions) {\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 1, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         Register arg_2,\n+                                         bool check_exceptions) {\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n+  pass_arg2(this, arg_2);\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 2, check_exceptions);\n@@ -524,2 +590,2 @@\n-  LP64_ONLY(assert(Rsub_klass != r14, \"r14 holds locals\");)\n-  LP64_ONLY(assert(Rsub_klass != r13, \"r13 holds bcp\");)\n+  assert(Rsub_klass != r14, \"r14 holds locals\");\n+  assert(Rsub_klass != r13, \"r13 holds bcp\");\n@@ -808,0 +874,8 @@\n+#ifdef ASSERT\n+  Label not_preempted;\n+  cmpptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+  jcc(Assembler::equal, not_preempted);\n+  stop(\"remove_activation: should not have alternate return address set\");\n+  bind(not_preempted);\n+#endif \/* ASSERT *\/\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":86,"deletions":12,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  \/\/ Use for vthread preemption\n@@ -67,1 +68,7 @@\n-                           Register arg_1);\n+                           Register arg_1,\n+                           bool check_exceptions = true);\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1,\n+                           Register arg_2,\n+                           bool check_exceptions = true);\n@@ -69,0 +76,5 @@\n+ private:\n+  void call_VM_preemptable_helper(Register oop_result,\n+                                  address entry_point,\n+                                  int number_of_arguments,\n+                                  bool check_exceptions);\n@@ -70,0 +82,1 @@\n+ public:\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,9 +45,0 @@\n-private:\n-\n-#ifndef AMD64\n-  \/\/ 32bit Helper routines.\n-  static inline void    put_int2r(jint *from, intptr_t *to)           { *(jint *)(to++) = from[1];\n-                                                                        *(jint *)(to  ) = from[0]; }\n-  static inline void    put_int2r(jint *from, intptr_t *to, int& pos) { put_int2r(from, to + pos); pos += 2; }\n-#endif \/\/ AMD64\n-\n@@ -60,1 +51,0 @@\n-#ifdef AMD64\n@@ -76,7 +66,0 @@\n-#else\n-  \/\/ Longs are stored in big-endian word format in two JavaCallArgument slots at *to.\n-  \/\/ The high half is in *to and the low half in *(to+1).\n-  static inline void    put_long(jlong  from, intptr_t *to)           { put_int2r((jint *)&from, to); }\n-  static inline void    put_long(jlong  from, intptr_t *to, int& pos) { put_int2r((jint *)&from, to, pos); }\n-  static inline void    put_long(jlong *from, intptr_t *to, int& pos) { put_int2r((jint *) from, to, pos); }\n-#endif \/\/ AMD64\n@@ -94,1 +77,0 @@\n-#ifdef AMD64\n@@ -111,8 +93,0 @@\n-#else\n-#define _JNI_SLOT_OFFSET 0\n-  \/\/ Doubles are stored in big-endian word format in two JavaCallArgument slots at *to.\n-  \/\/ The high half is in *to and the low half in *(to+1).\n-  static inline void    put_double(jdouble  from, intptr_t *to)           { put_int2r((jint *)&from, to); }\n-  static inline void    put_double(jdouble  from, intptr_t *to, int& pos) { put_int2r((jint *)&from, to, pos); }\n-  static inline void    put_double(jdouble *from, intptr_t *to, int& pos) { put_int2r((jint *) from, to, pos); }\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/jniTypes_x86.hpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-#ifdef _LP64\n@@ -85,3 +84,0 @@\n-#else\n-    JVMCI_ERROR(\"compressed oop on 32bit\");\n-#endif\n@@ -99,1 +95,0 @@\n-#ifdef _LP64\n@@ -103,3 +98,0 @@\n-#else\n-    JVMCI_ERROR(\"compressed Klass* on 32bit\");\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -568,1 +568,0 @@\n-#ifdef AMD64\n@@ -577,3 +576,0 @@\n-#else\n-      ls.print(\"%3s=\" PTR_FORMAT, r->name(), saved_regs[((saved_regs_count - 1) - i)]);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#ifdef AMD64\n@@ -79,7 +78,0 @@\n-#else\n-  if (verify_only) {\n-    guarantee(*pd_address_in_code() == x, \"instructions must match\");\n-  } else {\n-    *pd_address_in_code() = x;\n-  }\n-#endif \/\/ AMD64\n@@ -153,1 +145,0 @@\n-#ifdef AMD64\n@@ -160,3 +151,0 @@\n-#else\n-  assert(which == Assembler::disp32_operand || which == Assembler::imm_operand, \"format unpacks ok\");\n-#endif \/\/ AMD64\n@@ -168,1 +156,0 @@\n-#ifdef AMD64\n@@ -185,1 +172,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n-#ifndef AMD64\n-    format_width       =  1\n-#else\n@@ -40,1 +37,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -245,2 +245,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in x86_64.ad file)\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,3 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n@@ -37,5 +38,3 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -43,1 +42,0 @@\n-private:\n@@ -75,1 +73,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/x86\/smallRegisterMap_x86.inline.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n@@ -134,1 +135,0 @@\n-  InterpreterOopMap mask;\n@@ -136,6 +136,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return  mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-        + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-              (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2343,1 +2343,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -2390,1 +2390,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -3761,2 +3761,2 @@\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n-   __ verify_oop(rax);\n+  __ call_VM_preemptable(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n+  __ verify_oop(rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1263,1 +1263,0 @@\n-#ifdef _LP64\n@@ -1269,1 +1268,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/\/ X86 Common Architecture Description File\n+\/\/ X86 AMD64 Architecture Description File\n@@ -62,0 +62,160 @@\n+\/\/ General Registers\n+\/\/ R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when\n+\/\/ used as byte registers)\n+\n+\/\/ Previously set RBX, RSI, and RDI as save-on-entry for java code\n+\/\/ Turn off SOE in java-code due to frequent use of uncommon-traps.\n+\/\/ Now that allocator is better, turn on RSI and RDI as SOE registers.\n+\n+reg_def RAX  (SOC, SOC, Op_RegI,  0, rax->as_VMReg());\n+reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax->as_VMReg()->next());\n+\n+reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx->as_VMReg());\n+reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx->as_VMReg()->next());\n+\n+reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx->as_VMReg());\n+reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx->as_VMReg()->next());\n+\n+reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx->as_VMReg());\n+reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx->as_VMReg()->next());\n+\n+reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp->as_VMReg());\n+reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp->as_VMReg()->next());\n+\n+\/\/ now that adapter frames are gone RBP is always saved and restored by the prolog\/epilog code\n+reg_def RBP  (NS, SOE, Op_RegI,  5, rbp->as_VMReg());\n+reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp->as_VMReg()->next());\n+\n+#ifdef _WIN64\n+\n+reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi->as_VMReg());\n+reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi->as_VMReg()->next());\n+\n+reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi->as_VMReg());\n+reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi->as_VMReg()->next());\n+\n+#else\n+\n+reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi->as_VMReg());\n+reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi->as_VMReg()->next());\n+\n+reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi->as_VMReg());\n+reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi->as_VMReg()->next());\n+\n+#endif\n+\n+reg_def R8   (SOC, SOC, Op_RegI,  8, r8->as_VMReg());\n+reg_def R8_H (SOC, SOC, Op_RegI,  8, r8->as_VMReg()->next());\n+\n+reg_def R9   (SOC, SOC, Op_RegI,  9, r9->as_VMReg());\n+reg_def R9_H (SOC, SOC, Op_RegI,  9, r9->as_VMReg()->next());\n+\n+reg_def R10  (SOC, SOC, Op_RegI, 10, r10->as_VMReg());\n+reg_def R10_H(SOC, SOC, Op_RegI, 10, r10->as_VMReg()->next());\n+\n+reg_def R11  (SOC, SOC, Op_RegI, 11, r11->as_VMReg());\n+reg_def R11_H(SOC, SOC, Op_RegI, 11, r11->as_VMReg()->next());\n+\n+reg_def R12  (SOC, SOE, Op_RegI, 12, r12->as_VMReg());\n+reg_def R12_H(SOC, SOE, Op_RegI, 12, r12->as_VMReg()->next());\n+\n+reg_def R13  (SOC, SOE, Op_RegI, 13, r13->as_VMReg());\n+reg_def R13_H(SOC, SOE, Op_RegI, 13, r13->as_VMReg()->next());\n+\n+reg_def R14  (SOC, SOE, Op_RegI, 14, r14->as_VMReg());\n+reg_def R14_H(SOC, SOE, Op_RegI, 14, r14->as_VMReg()->next());\n+\n+reg_def R15  (SOC, SOE, Op_RegI, 15, r15->as_VMReg());\n+reg_def R15_H(SOC, SOE, Op_RegI, 15, r15->as_VMReg()->next());\n+\n+reg_def R16  (SOC, SOC, Op_RegI, 16, r16->as_VMReg());\n+reg_def R16_H(SOC, SOC, Op_RegI, 16, r16->as_VMReg()->next());\n+\n+reg_def R17  (SOC, SOC, Op_RegI, 17, r17->as_VMReg());\n+reg_def R17_H(SOC, SOC, Op_RegI, 17, r17->as_VMReg()->next());\n+\n+reg_def R18  (SOC, SOC, Op_RegI, 18, r18->as_VMReg());\n+reg_def R18_H(SOC, SOC, Op_RegI, 18, r18->as_VMReg()->next());\n+\n+reg_def R19  (SOC, SOC, Op_RegI, 19, r19->as_VMReg());\n+reg_def R19_H(SOC, SOC, Op_RegI, 19, r19->as_VMReg()->next());\n+\n+reg_def R20  (SOC, SOC, Op_RegI, 20, r20->as_VMReg());\n+reg_def R20_H(SOC, SOC, Op_RegI, 20, r20->as_VMReg()->next());\n+\n+reg_def R21  (SOC, SOC, Op_RegI, 21, r21->as_VMReg());\n+reg_def R21_H(SOC, SOC, Op_RegI, 21, r21->as_VMReg()->next());\n+\n+reg_def R22  (SOC, SOC, Op_RegI, 22, r22->as_VMReg());\n+reg_def R22_H(SOC, SOC, Op_RegI, 22, r22->as_VMReg()->next());\n+\n+reg_def R23  (SOC, SOC, Op_RegI, 23, r23->as_VMReg());\n+reg_def R23_H(SOC, SOC, Op_RegI, 23, r23->as_VMReg()->next());\n+\n+reg_def R24  (SOC, SOC, Op_RegI, 24, r24->as_VMReg());\n+reg_def R24_H(SOC, SOC, Op_RegI, 24, r24->as_VMReg()->next());\n+\n+reg_def R25  (SOC, SOC, Op_RegI, 25, r25->as_VMReg());\n+reg_def R25_H(SOC, SOC, Op_RegI, 25, r25->as_VMReg()->next());\n+\n+reg_def R26  (SOC, SOC, Op_RegI, 26, r26->as_VMReg());\n+reg_def R26_H(SOC, SOC, Op_RegI, 26, r26->as_VMReg()->next());\n+\n+reg_def R27  (SOC, SOC, Op_RegI, 27, r27->as_VMReg());\n+reg_def R27_H(SOC, SOC, Op_RegI, 27, r27->as_VMReg()->next());\n+\n+reg_def R28  (SOC, SOC, Op_RegI, 28, r28->as_VMReg());\n+reg_def R28_H(SOC, SOC, Op_RegI, 28, r28->as_VMReg()->next());\n+\n+reg_def R29  (SOC, SOC, Op_RegI, 29, r29->as_VMReg());\n+reg_def R29_H(SOC, SOC, Op_RegI, 29, r29->as_VMReg()->next());\n+\n+reg_def R30  (SOC, SOC, Op_RegI, 30, r30->as_VMReg());\n+reg_def R30_H(SOC, SOC, Op_RegI, 30, r30->as_VMReg()->next());\n+\n+reg_def R31  (SOC, SOC, Op_RegI, 31, r31->as_VMReg());\n+reg_def R31_H(SOC, SOC, Op_RegI, 31, r31->as_VMReg()->next());\n+\n+\/\/ Floating Point Registers\n+\n+\/\/ Specify priority of register selection within phases of register\n+\/\/ allocation.  Highest priority is first.  A useful heuristic is to\n+\/\/ give registers a low priority when they are required by machine\n+\/\/ instructions, like EAX and EDX on I486, and choose no-save registers\n+\/\/ before save-on-call, & save-on-call before save-on-entry.  Registers\n+\/\/ which participate in fixed calling sequences should come last.\n+\/\/ Registers which are used as pairs must fall on an even boundary.\n+\n+alloc_class chunk0(R10,         R10_H,\n+                   R11,         R11_H,\n+                   R8,          R8_H,\n+                   R9,          R9_H,\n+                   R12,         R12_H,\n+                   RCX,         RCX_H,\n+                   RBX,         RBX_H,\n+                   RDI,         RDI_H,\n+                   RDX,         RDX_H,\n+                   RSI,         RSI_H,\n+                   RAX,         RAX_H,\n+                   RBP,         RBP_H,\n+                   R13,         R13_H,\n+                   R14,         R14_H,\n+                   R15,         R15_H,\n+                   R16,         R16_H,\n+                   R17,         R17_H,\n+                   R18,         R18_H,\n+                   R19,         R19_H,\n+                   R20,         R20_H,\n+                   R21,         R21_H,\n+                   R22,         R22_H,\n+                   R23,         R23_H,\n+                   R24,         R24_H,\n+                   R25,         R25_H,\n+                   R26,         R26_H,\n+                   R27,         R27_H,\n+                   R28,         R28_H,\n+                   R29,         R29_H,\n+                   R30,         R30_H,\n+                   R31,         R31_H,\n+                   RSP,         RSP_H);\n+\n@@ -646,0 +806,192 @@\n+\/\/----------Architecture Description Register Classes--------------------------\n+\/\/ Several register classes are automatically defined based upon information in\n+\/\/ this architecture description.\n+\/\/ 1) reg_class inline_cache_reg           ( \/* as def'd in frame section *\/ )\n+\/\/ 2) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n+\/\/\n+\n+\/\/ Empty register class.\n+reg_class no_reg();\n+\n+\/\/ Class for all pointer\/long registers including APX extended GPRs.\n+reg_class all_reg(RAX, RAX_H,\n+                  RDX, RDX_H,\n+                  RBP, RBP_H,\n+                  RDI, RDI_H,\n+                  RSI, RSI_H,\n+                  RCX, RCX_H,\n+                  RBX, RBX_H,\n+                  RSP, RSP_H,\n+                  R8,  R8_H,\n+                  R9,  R9_H,\n+                  R10, R10_H,\n+                  R11, R11_H,\n+                  R12, R12_H,\n+                  R13, R13_H,\n+                  R14, R14_H,\n+                  R15, R15_H,\n+                  R16, R16_H,\n+                  R17, R17_H,\n+                  R18, R18_H,\n+                  R19, R19_H,\n+                  R20, R20_H,\n+                  R21, R21_H,\n+                  R22, R22_H,\n+                  R23, R23_H,\n+                  R24, R24_H,\n+                  R25, R25_H,\n+                  R26, R26_H,\n+                  R27, R27_H,\n+                  R28, R28_H,\n+                  R29, R29_H,\n+                  R30, R30_H,\n+                  R31, R31_H);\n+\n+\/\/ Class for all int registers including APX extended GPRs.\n+reg_class all_int_reg(RAX\n+                      RDX,\n+                      RBP,\n+                      RDI,\n+                      RSI,\n+                      RCX,\n+                      RBX,\n+                      R8,\n+                      R9,\n+                      R10,\n+                      R11,\n+                      R12,\n+                      R13,\n+                      R14,\n+                      R16,\n+                      R17,\n+                      R18,\n+                      R19,\n+                      R20,\n+                      R21,\n+                      R22,\n+                      R23,\n+                      R24,\n+                      R25,\n+                      R26,\n+                      R27,\n+                      R28,\n+                      R29,\n+                      R30,\n+                      R31);\n+\n+\/\/ Class for all pointer registers\n+reg_class any_reg %{\n+  return _ANY_REG_mask;\n+%}\n+\n+\/\/ Class for all pointer registers (excluding RSP)\n+reg_class ptr_reg %{\n+  return _PTR_REG_mask;\n+%}\n+\n+\/\/ Class for all pointer registers (excluding RSP and RBP)\n+reg_class ptr_reg_no_rbp %{\n+  return _PTR_REG_NO_RBP_mask;\n+%}\n+\n+\/\/ Class for all pointer registers (excluding RAX and RSP)\n+reg_class ptr_no_rax_reg %{\n+  return _PTR_NO_RAX_REG_mask;\n+%}\n+\n+\/\/ Class for all pointer registers (excluding RAX, RBX, and RSP)\n+reg_class ptr_no_rax_rbx_reg %{\n+  return _PTR_NO_RAX_RBX_REG_mask;\n+%}\n+\n+\/\/ Class for all long registers (excluding RSP)\n+reg_class long_reg %{\n+  return _LONG_REG_mask;\n+%}\n+\n+\/\/ Class for all long registers (excluding RAX, RDX and RSP)\n+reg_class long_no_rax_rdx_reg %{\n+  return _LONG_NO_RAX_RDX_REG_mask;\n+%}\n+\n+\/\/ Class for all long registers (excluding RCX and RSP)\n+reg_class long_no_rcx_reg %{\n+  return _LONG_NO_RCX_REG_mask;\n+%}\n+\n+\/\/ Class for all long registers (excluding RBP and R13)\n+reg_class long_no_rbp_r13_reg %{\n+  return _LONG_NO_RBP_R13_REG_mask;\n+%}\n+\n+\/\/ Class for all int registers (excluding RSP)\n+reg_class int_reg %{\n+  return _INT_REG_mask;\n+%}\n+\n+\/\/ Class for all int registers (excluding RAX, RDX, and RSP)\n+reg_class int_no_rax_rdx_reg %{\n+  return _INT_NO_RAX_RDX_REG_mask;\n+%}\n+\n+\/\/ Class for all int registers (excluding RCX and RSP)\n+reg_class int_no_rcx_reg %{\n+  return _INT_NO_RCX_REG_mask;\n+%}\n+\n+\/\/ Class for all int registers (excluding RBP and R13)\n+reg_class int_no_rbp_r13_reg %{\n+  return _INT_NO_RBP_R13_REG_mask;\n+%}\n+\n+\/\/ Singleton class for RAX pointer register\n+reg_class ptr_rax_reg(RAX, RAX_H);\n+\n+\/\/ Singleton class for RBX pointer register\n+reg_class ptr_rbx_reg(RBX, RBX_H);\n+\n+\/\/ Singleton class for RSI pointer register\n+reg_class ptr_rsi_reg(RSI, RSI_H);\n+\n+\/\/ Singleton class for RBP pointer register\n+reg_class ptr_rbp_reg(RBP, RBP_H);\n+\n+\/\/ Singleton class for RDI pointer register\n+reg_class ptr_rdi_reg(RDI, RDI_H);\n+\n+\/\/ Singleton class for stack pointer\n+reg_class ptr_rsp_reg(RSP, RSP_H);\n+\n+\/\/ Singleton class for TLS pointer\n+reg_class ptr_r15_reg(R15, R15_H);\n+\n+\/\/ Singleton class for RAX long register\n+reg_class long_rax_reg(RAX, RAX_H);\n+\n+\/\/ Singleton class for RCX long register\n+reg_class long_rcx_reg(RCX, RCX_H);\n+\n+\/\/ Singleton class for RDX long register\n+reg_class long_rdx_reg(RDX, RDX_H);\n+\n+\/\/ Singleton class for R11 long register\n+reg_class long_r11_reg(R11, R11_H);\n+\n+\/\/ Singleton class for RAX int register\n+reg_class int_rax_reg(RAX);\n+\n+\/\/ Singleton class for RBX int register\n+reg_class int_rbx_reg(RBX);\n+\n+\/\/ Singleton class for RCX int register\n+reg_class int_rcx_reg(RCX);\n+\n+\/\/ Singleton class for RDX int register\n+reg_class int_rdx_reg(RDX);\n+\n+\/\/ Singleton class for RDI int register\n+reg_class int_rdi_reg(RDI);\n+\n+\/\/ Singleton class for instruction pointer\n+\/\/ reg_class ip_reg(RIP);\n+\n@@ -706,1 +1058,0 @@\n-\n@@ -1096,0 +1447,1 @@\n+\n@@ -1104,6 +1456,0 @@\n-\/\/ Header information of the source block.\n-\/\/ Method declarations\/definitions which are used outside\n-\/\/ the ad-scope can conveniently be defined here.\n-\/\/\n-\/\/ To keep related declarations\/definitions\/uses close together,\n-\/\/ we switch between source %{ }% and source_hpp %{ }% freely as needed.\n@@ -1111,1 +1457,1 @@\n-#include \"runtime\/vm_version.hpp\"\n+#include \"peephole_x86_64.hpp\"\n@@ -1113,1 +1459,1 @@\n-class NativeJump;\n+bool castLL_is_imm32(const Node* n);\n@@ -1115,1 +1461,1 @@\n-class CallStubImpl {\n+%}\n@@ -1117,3 +1463,1 @@\n-  \/\/--------------------------------------------------------------\n-  \/\/---<  Used for optimization in Compile::shorten_branches  >---\n-  \/\/--------------------------------------------------------------\n+source %{\n@@ -1121,5 +1465,5 @@\n- public:\n-  \/\/ Size of call trampoline stub.\n-  static uint size_call_trampoline() {\n-    return 0; \/\/ no call trampolines on this platform\n-  }\n+bool castLL_is_imm32(const Node* n) {\n+  assert(n->is_CastLL(), \"must be a CastLL\");\n+  const TypeLong* t = n->bottom_type()->is_long();\n+  return (t->_lo == min_jlong || Assembler::is_simm32(t->_lo)) && (t->_hi == max_jlong || Assembler::is_simm32(t->_hi));\n+}\n@@ -1127,5 +1471,1 @@\n-  \/\/ number of relocations needed by a call trampoline stub\n-  static uint reloc_call_trampoline() {\n-    return 0; \/\/ no call trampolines on this platform\n-  }\n-};\n+%}\n@@ -1133,1 +1473,2 @@\n-class HandlerImpl {\n+\/\/ Register masks\n+source_hpp %{\n@@ -1135,1 +1476,14 @@\n- public:\n+extern RegMask _ANY_REG_mask;\n+extern RegMask _PTR_REG_mask;\n+extern RegMask _PTR_REG_NO_RBP_mask;\n+extern RegMask _PTR_NO_RAX_REG_mask;\n+extern RegMask _PTR_NO_RAX_RBX_REG_mask;\n+extern RegMask _LONG_REG_mask;\n+extern RegMask _LONG_NO_RAX_RDX_REG_mask;\n+extern RegMask _LONG_NO_RCX_REG_mask;\n+extern RegMask _LONG_NO_RBP_R13_REG_mask;\n+extern RegMask _INT_REG_mask;\n+extern RegMask _INT_NO_RAX_RDX_REG_mask;\n+extern RegMask _INT_NO_RCX_REG_mask;\n+extern RegMask _INT_NO_RBP_R13_REG_mask;\n+extern RegMask _FLOAT_REG_mask;\n@@ -1137,2 +1491,37 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n-  static int emit_deopt_handler(C2_MacroAssembler* masm);\n+extern RegMask _STACK_OR_PTR_REG_mask;\n+extern RegMask _STACK_OR_LONG_REG_mask;\n+extern RegMask _STACK_OR_INT_REG_mask;\n+\n+inline const RegMask& STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }\n+inline const RegMask& STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }\n+inline const RegMask& STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }\n+\n+%}\n+\n+source %{\n+#define   RELOC_IMM64    Assembler::imm_operand\n+#define   RELOC_DISP32   Assembler::disp32_operand\n+\n+#define __ masm->\n+\n+RegMask _ANY_REG_mask;\n+RegMask _PTR_REG_mask;\n+RegMask _PTR_REG_NO_RBP_mask;\n+RegMask _PTR_NO_RAX_REG_mask;\n+RegMask _PTR_NO_RAX_RBX_REG_mask;\n+RegMask _LONG_REG_mask;\n+RegMask _LONG_NO_RAX_RDX_REG_mask;\n+RegMask _LONG_NO_RCX_REG_mask;\n+RegMask _LONG_NO_RBP_R13_REG_mask;\n+RegMask _INT_REG_mask;\n+RegMask _INT_NO_RAX_RDX_REG_mask;\n+RegMask _INT_NO_RCX_REG_mask;\n+RegMask _INT_NO_RBP_R13_REG_mask;\n+RegMask _FLOAT_REG_mask;\n+RegMask _STACK_OR_PTR_REG_mask;\n+RegMask _STACK_OR_LONG_REG_mask;\n+RegMask _STACK_OR_INT_REG_mask;\n+\n+static bool need_r12_heapbase() {\n+  return UseCompressedOops;\n+}\n@@ -1140,7 +1529,14 @@\n-  static uint size_exception_handler() {\n-    \/\/ NativeCall instruction size is the same as NativeJump.\n-    \/\/ exception handler starts out as jump and can be patched to\n-    \/\/ a call be deoptimization.  (4932387)\n-    \/\/ Note that this value is also credited (in output.cpp) to\n-    \/\/ the size of the code section.\n-    return NativeJump::instruction_size;\n+void reg_mask_init() {\n+  constexpr Register egprs[] = {r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31};\n+\n+  \/\/ _ALL_REG_mask is generated by adlc from the all_reg register class below.\n+  \/\/ We derive a number of subsets from it.\n+  _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n+\n+  if (PreserveFramePointer) {\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  }\n+  if (need_r12_heapbase()) {\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n@@ -1149,3 +1545,10 @@\n-  static uint size_deopt_handler() {\n-    \/\/ three 5 byte instructions plus one move for unreachable address.\n-    return 15+3;\n+  _PTR_REG_mask.assignFrom(_ANY_REG_mask);\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n+  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n+  if (!UseAPX) {\n+    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n+      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n+      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n+    }\n@@ -1153,1 +1556,0 @@\n-};\n@@ -1155,7 +1557,2 @@\n-inline Assembler::AvxVectorLen vector_length_encoding(int bytes) {\n-  switch(bytes) {\n-    case  4: \/\/ fall-through\n-    case  8: \/\/ fall-through\n-    case 16: return Assembler::AVX_128bit;\n-    case 32: return Assembler::AVX_256bit;\n-    case 64: return Assembler::AVX_512bit;\n+  _STACK_OR_PTR_REG_mask.assignFrom(_PTR_REG_mask);\n+  _STACK_OR_PTR_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n@@ -1163,3 +1560,37 @@\n-    default: {\n-      ShouldNotReachHere();\n-      return Assembler::AVX_NoVec;\n+  _PTR_REG_NO_RBP_mask.assignFrom(_PTR_REG_mask);\n+  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+\n+  _PTR_NO_RAX_REG_mask.assignFrom(_PTR_REG_mask);\n+  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+\n+  _PTR_NO_RAX_RBX_REG_mask.assignFrom(_PTR_NO_RAX_REG_mask);\n+  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n+  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n+\n+\n+  _LONG_REG_mask.assignFrom(_PTR_REG_mask);\n+  _STACK_OR_LONG_REG_mask.assignFrom(_LONG_REG_mask);\n+  _STACK_OR_LONG_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n+\n+  _LONG_NO_RAX_RDX_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n+\n+  _LONG_NO_RCX_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n+\n+  _LONG_NO_RBP_R13_REG_mask.assignFrom(_LONG_REG_mask);\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n+\n+  _INT_REG_mask.assignFrom(_ALL_INT_REG_mask);\n+  if (!UseAPX) {\n+    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n+      _INT_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n@@ -1168,0 +1599,25 @@\n+\n+  if (PreserveFramePointer) {\n+    _INT_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  }\n+  if (need_r12_heapbase()) {\n+    _INT_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n+  }\n+\n+  _STACK_OR_INT_REG_mask.assignFrom(_INT_REG_mask);\n+  _STACK_OR_INT_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n+\n+  _INT_NO_RAX_RDX_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n+  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n+\n+  _INT_NO_RCX_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n+\n+  _INT_NO_RBP_R13_REG_mask.assignFrom(_INT_REG_mask);\n+  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+\n+  \/\/ _FLOAT_REG_LEGACY_mask\/_FLOAT_REG_EVEX_mask is generated by adlc\n+  \/\/ from the float_reg_legacy\/float_reg_evex register class.\n+  _FLOAT_REG_mask.assignFrom(VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask);\n@@ -1170,2 +1626,2 @@\n-static inline Assembler::AvxVectorLen vector_length_encoding(const Node* n) {\n-  return vector_length_encoding(Matcher::vector_length_in_bytes(n));\n+static bool generate_vzeroupper(Compile* C) {\n+  return (VM_Version::supports_vzeroupper() && (C->max_vector_size() > 16 || C->clear_upper_avx() == true)) ? true: false;  \/\/ Generate vzeroupper\n@@ -1174,4 +1630,2 @@\n-static inline Assembler::AvxVectorLen vector_length_encoding(const MachNode* use, MachOper* opnd) {\n-  uint def_idx = use->operand_index(opnd);\n-  Node* def = use->in(def_idx);\n-  return vector_length_encoding(def);\n+static int clear_avx_size() {\n+  return generate_vzeroupper(Compile::current()) ? 3: 0;  \/\/ vzeroupper\n@@ -1180,3 +1634,8 @@\n-static inline bool is_vector_popcount_predicate(BasicType bt) {\n-  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n-         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+\/\/ !!!!! Special hack to get all types of calls to specify the byte offset\n+\/\/       from the start of the call to the point where the return address\n+\/\/       will point.\n+int MachCallStaticJavaNode::ret_addr_offset()\n+{\n+  int offset = 5; \/\/ 5 bytes from start of call to where return address points\n+  offset += clear_avx_size();\n+  return offset;\n@@ -1185,3 +1644,5 @@\n-static inline bool is_clz_non_subword_predicate_evex(BasicType bt, int vlen_bytes) {\n-  return is_non_subword_integral_type(bt) && VM_Version::supports_avx512cd() &&\n-           (VM_Version::supports_avx512vl() || vlen_bytes == 64);\n+int MachCallDynamicJavaNode::ret_addr_offset()\n+{\n+  int offset = 15; \/\/ 15 bytes from start of call to where return address points\n+  offset += clear_avx_size();\n+  return offset;\n@@ -1190,17 +1651,11 @@\n-class Node::PD {\n-public:\n-  enum NodeFlags {\n-    Flag_intel_jcc_erratum    = Node::_last_flag << 1,\n-    Flag_sets_carry_flag      = Node::_last_flag << 2,\n-    Flag_sets_parity_flag     = Node::_last_flag << 3,\n-    Flag_sets_zero_flag       = Node::_last_flag << 4,\n-    Flag_sets_overflow_flag   = Node::_last_flag << 5,\n-    Flag_sets_sign_flag       = Node::_last_flag << 6,\n-    Flag_clears_carry_flag    = Node::_last_flag << 7,\n-    Flag_clears_parity_flag   = Node::_last_flag << 8,\n-    Flag_clears_zero_flag     = Node::_last_flag << 9,\n-    Flag_clears_overflow_flag = Node::_last_flag << 10,\n-    Flag_clears_sign_flag     = Node::_last_flag << 11,\n-    _last_flag                = Flag_clears_sign_flag\n-  };\n-};\n+int MachCallRuntimeNode::ret_addr_offset() {\n+  if (_entry_point == nullptr) {\n+    \/\/ CallLeafNoFPInDirect\n+    return 3; \/\/ callq (register)\n+  }\n+  int offset = 13; \/\/ movq r10,#addr; callq (r10)\n+  if (this->ideal_Opcode() != Op_CallLeafVector) {\n+    offset += clear_avx_size();\n+  }\n+  return offset;\n+}\n@@ -1208,1 +1663,3 @@\n-%} \/\/ end source_hpp\n+\/\/\n+\/\/ Compute padding required for nodes which need alignment\n+\/\/\n@@ -1210,1 +1667,8 @@\n-source %{\n+\/\/ The address of the call instruction needs to be 4-byte aligned to\n+\/\/ ensure that it does not span a cache line so that it can be patched.\n+int CallStaticJavaDirectNode::compute_padding(int current_offset) const\n+{\n+  current_offset += clear_avx_size(); \/\/ skip vzeroupper\n+  current_offset += 1; \/\/ skip call opcode byte\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n@@ -1212,2 +1676,8 @@\n-#include \"opto\/addnode.hpp\"\n-#include \"c2_intelJccErratum_x86.hpp\"\n+\/\/ The address of the call instruction needs to be 4-byte aligned to\n+\/\/ ensure that it does not span a cache line so that it can be patched.\n+int CallDynamicJavaDirectNode::compute_padding(int current_offset) const\n+{\n+  current_offset += clear_avx_size(); \/\/ skip vzeroupper\n+  current_offset += 11; \/\/ skip movq instruction + call opcode byte\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n@@ -1215,5 +1685,19 @@\n-void PhaseOutput::pd_perform_mach_node_analysis() {\n-  if (VM_Version::has_intel_jcc_erratum()) {\n-    int extra_padding = IntelJccErratum::tag_affected_machnodes(C, C->cfg(), C->regalloc());\n-    _buf_sizes._code += extra_padding;\n-  }\n+\/\/ This could be in MacroAssembler but it's fairly C2 specific\n+static void emit_cmpfp_fixup(MacroAssembler* masm) {\n+  Label exit;\n+  __ jccb(Assembler::noParity, exit);\n+  __ pushf();\n+  \/\/\n+  \/\/ comiss\/ucomiss instructions set ZF,PF,CF flags and\n+  \/\/ zero OF,AF,SF for NaN values.\n+  \/\/ Fixup flags by zeroing ZF,PF so that compare of NaN\n+  \/\/ values returns 'less than' result (CF is set).\n+  \/\/ Leave the rest of flags unchanged.\n+  \/\/\n+  \/\/    7 6 5 4 3 2 1 0\n+  \/\/   |S|Z|r|A|r|P|r|C|  (r - reserved bit)\n+  \/\/    0 0 1 0 1 0 1 1   (0x2B)\n+  \/\/\n+  __ andq(Address(rsp, 0), 0xffffff2b);\n+  __ popf();\n+  __ bind(exit);\n@@ -1222,7 +1706,7 @@\n-int MachNode::pd_alignment_required() const {\n-  if (VM_Version::has_intel_jcc_erratum() && IntelJccErratum::is_jcc_erratum_branch(this)) {\n-    \/\/ Conservatively add worst case padding. We assume that relocInfo::addr_unit() is 1 on x86.\n-    return IntelJccErratum::largest_jcc_size() + 1;\n-  } else {\n-    return 1;\n-  }\n+static void emit_cmpfp3(MacroAssembler* masm, Register dst) {\n+  Label done;\n+  __ movl(dst, -1);\n+  __ jcc(Assembler::parity, done);\n+  __ jcc(Assembler::below, done);\n+  __ setcc(Assembler::notEqual, dst);\n+  __ bind(done);\n@@ -1231,9 +1715,37 @@\n-int MachNode::compute_padding(int current_offset) const {\n-  if (flags() & Node::PD::Flag_intel_jcc_erratum) {\n-    Compile* C = Compile::current();\n-    PhaseOutput* output = C->output();\n-    Block* block = output->block();\n-    int index = output->index();\n-    return IntelJccErratum::compute_padding(current_offset, this, block, index, C->regalloc());\n-  } else {\n-    return 0;\n+\/\/ Math.min()    # Math.max()\n+\/\/ --------------------------\n+\/\/ ucomis[s\/d]   #\n+\/\/ ja   -> b     # a\n+\/\/ jp   -> NaN   # NaN\n+\/\/ jb   -> a     # b\n+\/\/ je            #\n+\/\/ |-jz -> a | b # a & b\n+\/\/ |    -> a     #\n+static void emit_fp_min_max(MacroAssembler* masm, XMMRegister dst,\n+                            XMMRegister a, XMMRegister b,\n+                            XMMRegister xmmt, Register rt,\n+                            bool min, bool single) {\n+\n+  Label nan, zero, below, above, done;\n+\n+  if (single)\n+    __ ucomiss(a, b);\n+  else\n+    __ ucomisd(a, b);\n+\n+  if (dst->encoding() != (min ? b : a)->encoding())\n+    __ jccb(Assembler::above, above); \/\/ CF=0 & ZF=0\n+  else\n+    __ jccb(Assembler::above, done);\n+\n+  __ jccb(Assembler::parity, nan);  \/\/ PF=1\n+  __ jccb(Assembler::below, below); \/\/ CF=1\n+\n+  \/\/ equal\n+  __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);\n+  if (single) {\n+    __ ucomiss(a, xmmt);\n+    __ jccb(Assembler::equal, zero);\n+\n+    __ movflt(dst, a);\n+    __ jmp(done);\n@@ -1241,1 +1753,3 @@\n-}\n+  else {\n+    __ ucomisd(a, xmmt);\n+    __ jccb(Assembler::equal, zero);\n@@ -1243,3 +1757,3 @@\n-\/\/ Emit exception handler code.\n-\/\/ Stuff framesize into a register and call a VM stub routine.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n+    __ movdbl(dst, a);\n+    __ jmp(done);\n+  }\n@@ -1247,6 +1761,20 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n+  __ bind(zero);\n+  if (min)\n+    __ vpor(dst, a, b, Assembler::AVX_128bit);\n+  else\n+    __ vpand(dst, a, b, Assembler::AVX_128bit);\n+\n+  __ jmp(done);\n+\n+  __ bind(above);\n+  if (single)\n+    __ movflt(dst, min ? b : a);\n+  else\n+    __ movdbl(dst, min ? b : a);\n+\n+  __ jmp(done);\n+\n+  __ bind(nan);\n+  if (single) {\n+    __ movl(rt, 0x7fc00000); \/\/ Float.NaN\n+    __ movdl(dst, rt);\n@@ -1254,5 +1782,13 @@\n-  int offset = __ offset();\n-  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n+  else {\n+    __ mov64(rt, 0x7ff8000000000000L); \/\/ Double.NaN\n+    __ movdq(dst, rt);\n+  }\n+  __ jmp(done);\n+\n+  __ bind(below);\n+  if (single)\n+    __ movflt(dst, min ? a : b);\n+  else\n+    __ movdbl(dst, min ? a : b);\n+\n+  __ bind(done);\n@@ -1261,2 +1797,2 @@\n-\/\/ Emit deopt handler code.\n-int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm) {\n+\/\/=============================================================================\n+const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n@@ -1264,8 +1800,3 @@\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_deopt_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n+int ConstantTable::calculate_table_base_offset() const {\n+  return 0;  \/\/ absolute addressing, no offset\n+}\n@@ -1273,4 +1804,4 @@\n-  address the_pc = (address) __ pc();\n-  Label next;\n-  \/\/ push a \"the_pc\" on the stack without destroying any registers\n-  \/\/ as they all may be live.\n+bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }\n+void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {\n+  ShouldNotReachHere();\n+}\n@@ -1278,5 +1809,3 @@\n-  \/\/ push address of \"next\"\n-  __ call(next, relocInfo::none); \/\/ reloc none is fine since it is a disp32\n-  __ bind(next);\n-  \/\/ adjust it so it matches \"the_pc\"\n-  __ subptr(Address(rsp, 0), __ offset() - offset);\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n+  \/\/ Empty encoding\n+}\n@@ -1284,4 +1813,2 @@\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n-  assert(__ offset() - offset <= (int) size_deopt_handler(), \"overflow %d\", (__ offset() - offset));\n-  __ end_a_stub();\n-  return offset;\n+uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {\n+  return 0;\n@@ -1290,11 +1817,3 @@\n-static Assembler::Width widthForType(BasicType bt) {\n-  if (bt == T_BYTE) {\n-    return Assembler::B;\n-  } else if (bt == T_SHORT) {\n-    return Assembler::W;\n-  } else if (bt == T_INT) {\n-    return Assembler::D;\n-  } else {\n-    assert(bt == T_LONG, \"not a long: %s\", type2name(bt));\n-    return Assembler::Q;\n-  }\n+#ifndef PRODUCT\n+void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {\n+  st->print(\"# MachConstantBaseNode (empty encoding)\");\n@@ -1302,0 +1821,1 @@\n+#endif\n@@ -1303,1 +1823,0 @@\n-\/\/=============================================================================\n@@ -1305,20 +1824,89 @@\n-  \/\/ Float masks come from different places depending on platform.\n-  static address float_signmask()  { return StubRoutines::x86::float_sign_mask(); }\n-  static address float_signflip()  { return StubRoutines::x86::float_sign_flip(); }\n-  static address double_signmask() { return StubRoutines::x86::double_sign_mask(); }\n-  static address double_signflip() { return StubRoutines::x86::double_sign_flip(); }\n-  static address vector_short_to_byte_mask() { return StubRoutines::x86::vector_short_to_byte_mask(); }\n-  static address vector_int_to_byte_mask() { return StubRoutines::x86::vector_int_to_byte_mask(); }\n-  static address vector_byte_perm_mask() { return StubRoutines::x86::vector_byte_perm_mask(); }\n-  static address vector_long_sign_mask() { return StubRoutines::x86::vector_long_sign_mask(); }\n-  static address vector_all_bits_set() { return StubRoutines::x86::vector_all_bits_set(); }\n-  static address vector_int_mask_cmp_bits() { return StubRoutines::x86::vector_int_mask_cmp_bits(); }\n-  static address vector_int_to_short_mask() { return StubRoutines::x86::vector_int_to_short_mask(); }\n-  static address vector_byte_shufflemask() { return StubRoutines::x86::vector_byte_shuffle_mask(); }\n-  static address vector_short_shufflemask() { return StubRoutines::x86::vector_short_shuffle_mask(); }\n-  static address vector_int_shufflemask() { return StubRoutines::x86::vector_int_shuffle_mask(); }\n-  static address vector_long_shufflemask() { return StubRoutines::x86::vector_long_shuffle_mask(); }\n-  static address vector_32_bit_mask() { return StubRoutines::x86::vector_32_bit_mask(); }\n-  static address vector_64_bit_mask() { return StubRoutines::x86::vector_64_bit_mask(); }\n-  static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}\n-  static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}\n+\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {\n+  Compile* C = ra_->C;\n+\n+  int framesize = C->output()->frame_size_in_bytes();\n+  int bangsize = C->output()->bang_size_in_bytes();\n+  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+  \/\/ Remove wordSize for return addr which is already pushed.\n+  framesize -= wordSize;\n+\n+  if (C->output()->need_stack_bang(bangsize)) {\n+    framesize -= wordSize;\n+    st->print(\"# stack bang (%d bytes)\", bangsize);\n+    st->print(\"\\n\\t\");\n+    st->print(\"pushq   rbp\\t# Save rbp\");\n+    if (PreserveFramePointer) {\n+        st->print(\"\\n\\t\");\n+        st->print(\"movq    rbp, rsp\\t# Save the caller's SP into rbp\");\n+    }\n+    if (framesize) {\n+      st->print(\"\\n\\t\");\n+      st->print(\"subq    rsp, #%d\\t# Create frame\",framesize);\n+    }\n+  } else {\n+    st->print(\"subq    rsp, #%d\\t# Create frame\",framesize);\n+    st->print(\"\\n\\t\");\n+    framesize -= wordSize;\n+    st->print(\"movq    [rsp + #%d], rbp\\t# Save rbp\",framesize);\n+    if (PreserveFramePointer) {\n+      st->print(\"\\n\\t\");\n+      st->print(\"movq    rbp, rsp\\t# Save the caller's SP into rbp\");\n+      if (framesize > 0) {\n+        st->print(\"\\n\\t\");\n+        st->print(\"addq    rbp, #%d\", framesize);\n+      }\n+    }\n+  }\n+\n+  if (VerifyStackAtCalls) {\n+    st->print(\"\\n\\t\");\n+    framesize -= wordSize;\n+    st->print(\"movq    [rsp + #%d], 0xbadb100d\\t# Majik cookie for stack depth check\",framesize);\n+#ifdef ASSERT\n+    st->print(\"\\n\\t\");\n+    st->print(\"# stack alignment check\");\n+#endif\n+  }\n+  if (C->stub_function() != nullptr) {\n+    st->print(\"\\n\\t\");\n+    st->print(\"cmpl    [r15_thread + #disarmed_guard_value_offset], #disarmed_guard_value\\t\");\n+    st->print(\"\\n\\t\");\n+    st->print(\"je      fast_entry\\t\");\n+    st->print(\"\\n\\t\");\n+    st->print(\"call    #nmethod_entry_barrier_stub\\t\");\n+    st->print(\"\\n\\tfast_entry:\");\n+  }\n+  st->cr();\n+}\n+#endif\n+\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  Compile* C = ra_->C;\n+\n+  __ verified_entry(C);\n+\n+  if (ra_->C->stub_function() == nullptr) {\n+    __ entry_barrier();\n+  }\n+\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    __ bind(*_verified_entry);\n+  }\n+\n+  C->output()->set_frame_complete(__ offset());\n+\n+  if (C->has_mach_constant_base_node()) {\n+    \/\/ NOTE: We set the table base offset here because users might be\n+    \/\/ emitted before MachConstantBaseNode.\n+    ConstantTable& constant_table = C->output()->constant_table();\n+    constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());\n+  }\n+}\n+\n+\n+int MachPrologNode::reloc() const\n+{\n+  return 0; \/\/ a large enough number\n+}\n@@ -1327,3 +1915,7 @@\n-bool Matcher::match_rule_supported(int opcode) {\n-  if (!has_match_rule(opcode)) {\n-    return false; \/\/ no match rule present\n+#ifndef PRODUCT\n+void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  Compile* C = ra_->C;\n+  if (generate_vzeroupper(C)) {\n+    st->print(\"vzeroupper\");\n+    st->cr(); st->print(\"\\t\");\n@@ -1331,6 +1923,105 @@\n-  switch (opcode) {\n-    case Op_AbsVL:\n-    case Op_StoreVectorScatter:\n-      if (UseAVX < 3) {\n-        return false;\n-      }\n+\n+  int framesize = C->output()->frame_size_in_bytes();\n+  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+  \/\/ Remove word for return adr already pushed\n+  \/\/ and RBP\n+  framesize -= 2*wordSize;\n+\n+  if (framesize) {\n+    st->print_cr(\"addq    rsp, %d\\t# Destroy frame\", framesize);\n+    st->print(\"\\t\");\n+  }\n+\n+  st->print_cr(\"popq    rbp\");\n+  if (do_polling() && C->is_method_compilation()) {\n+    st->print(\"\\t\");\n+    st->print_cr(\"cmpq    rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja      #safepoint_stub\\t\"\n+                 \"# Safepoint: poll for GC\");\n+  }\n+}\n+#endif\n+\n+void MachEpilogNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n+{\n+  Compile* C = ra_->C;\n+\n+  if (generate_vzeroupper(C)) {\n+    \/\/ Clear upper bits of YMM registers when current compiled code uses\n+    \/\/ wide vectors to avoid AVX <-> SSE transition penalty during call.\n+    __ vzeroupper();\n+  }\n+\n+  \/\/ Subtract two words to account for return address and rbp\n+  int initial_framesize = C->output()->frame_size_in_bytes() - 2*wordSize;\n+  __ remove_frame(initial_framesize, C->needs_stack_repair());\n+\n+  if (StackReservedPages > 0 && C->has_reserved_stack_access()) {\n+    __ reserved_stack_check();\n+  }\n+\n+  if (do_polling() && C->is_method_compilation()) {\n+    Label dummy_label;\n+    Label* code_stub = &dummy_label;\n+    if (!C->output()->in_scratch_emit_size()) {\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n+    }\n+    __ relocate(relocInfo::poll_return_type);\n+    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n+  }\n+}\n+\n+int MachEpilogNode::reloc() const\n+{\n+  return 2; \/\/ a large enough number\n+}\n+\n+const Pipeline* MachEpilogNode::pipeline() const\n+{\n+  return MachNode::pipeline_class();\n+}\n+\n+\/\/=============================================================================\n+\n+enum RC {\n+  rc_bad,\n+  rc_int,\n+  rc_kreg,\n+  rc_float,\n+  rc_stack\n+};\n+\n+static enum RC rc_class(OptoReg::Name reg)\n+{\n+  if( !OptoReg::is_valid(reg)  ) return rc_bad;\n+\n+  if (OptoReg::is_stack(reg)) return rc_stack;\n+\n+  VMReg r = OptoReg::as_VMReg(reg);\n+\n+  if (r->is_Register()) return rc_int;\n+\n+  if (r->is_KRegister()) return rc_kreg;\n+\n+  assert(r->is_XMMRegister(), \"must be\");\n+  return rc_float;\n+}\n+\n+\/\/ Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n+                          int src_hi, int dst_hi, uint ireg, outputStream* st);\n+\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n+                     int stack_offset, int reg, uint ireg, outputStream* st);\n+\n+static void vec_stack_to_stack_helper(C2_MacroAssembler *masm, int src_offset,\n+                                      int dst_offset, uint ireg, outputStream* st) {\n+  if (masm) {\n+    switch (ireg) {\n+    case Op_VecS:\n+      __ movq(Address(rsp, -8), rax);\n+      __ movl(rax, Address(rsp, src_offset));\n+      __ movl(Address(rsp, dst_offset), rax);\n+      __ movq(rax, Address(rsp, -8));\n@@ -1338,5 +2029,3 @@\n-    case Op_PopCountI:\n-    case Op_PopCountL:\n-      if (!UsePopCountInstruction) {\n-        return false;\n-      }\n+    case Op_VecD:\n+      __ pushq(Address(rsp, src_offset));\n+      __ popq (Address(rsp, dst_offset));\n@@ -1344,4 +2033,5 @@\n-    case Op_PopCountVI:\n-      if (UseAVX < 2) {\n-        return false;\n-      }\n+    case Op_VecX:\n+      __ pushq(Address(rsp, src_offset));\n+      __ popq (Address(rsp, dst_offset));\n+      __ pushq(Address(rsp, src_offset+8));\n+      __ popq (Address(rsp, dst_offset+8));\n@@ -1349,6 +2039,5 @@\n-    case Op_CompressV:\n-    case Op_ExpandV:\n-    case Op_PopCountVL:\n-      if (UseAVX < 2) {\n-        return false;\n-      }\n+    case Op_VecY:\n+      __ vmovdqu(Address(rsp, -32), xmm0);\n+      __ vmovdqu(xmm0, Address(rsp, src_offset));\n+      __ vmovdqu(Address(rsp, dst_offset), xmm0);\n+      __ vmovdqu(xmm0, Address(rsp, -32));\n@@ -1356,4 +2045,5 @@\n-    case Op_MulVI:\n-      if ((UseSSE < 4) && (UseAVX < 1)) { \/\/ only with SSE4_1 or AVX\n-        return false;\n-      }\n+    case Op_VecZ:\n+      __ evmovdquq(Address(rsp, -64), xmm0, 2);\n+      __ evmovdquq(xmm0, Address(rsp, src_offset), 2);\n+      __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);\n+      __ evmovdquq(xmm0, Address(rsp, -64), 2);\n@@ -1361,4 +2051,12 @@\n-    case Op_MulVL:\n-      if (UseSSE < 4) { \/\/ only with SSE4_1 or AVX\n-        return false;\n-      }\n+    default:\n+      ShouldNotReachHere();\n+    }\n+#ifndef PRODUCT\n+  } else {\n+    switch (ireg) {\n+    case Op_VecS:\n+      st->print(\"movq    [rsp - #8], rax\\t# 32-bit mem-mem spill\\n\\t\"\n+                \"movl    rax, [rsp + #%d]\\n\\t\"\n+                \"movl    [rsp + #%d], rax\\n\\t\"\n+                \"movq    rax, [rsp - #8]\",\n+                src_offset, dst_offset);\n@@ -1366,4 +2064,4 @@\n-    case Op_MulReductionVL:\n-      if (VM_Version::supports_avx512dq() == false) {\n-        return false;\n-      }\n+    case Op_VecD:\n+      st->print(\"pushq   [rsp + #%d]\\t# 64-bit mem-mem spill\\n\\t\"\n+                \"popq    [rsp + #%d]\",\n+                src_offset, dst_offset);\n@@ -1371,10 +2069,6 @@\n-    case Op_AbsVB:\n-    case Op_AbsVS:\n-    case Op_AbsVI:\n-    case Op_AddReductionVI:\n-    case Op_AndReductionV:\n-    case Op_OrReductionV:\n-    case Op_XorReductionV:\n-      if (UseSSE < 3) { \/\/ requires at least SSSE3\n-        return false;\n-      }\n+     case Op_VecX:\n+      st->print(\"pushq   [rsp + #%d]\\t# 128-bit mem-mem spill\\n\\t\"\n+                \"popq    [rsp + #%d]\\n\\t\"\n+                \"pushq   [rsp + #%d]\\n\\t\"\n+                \"popq    [rsp + #%d]\",\n+                src_offset, dst_offset, src_offset+8, dst_offset+8);\n@@ -1382,16 +2076,6 @@\n-    case Op_MaxHF:\n-    case Op_MinHF:\n-      if (!VM_Version::supports_avx512vlbw()) {\n-        return false;\n-      }  \/\/ fallthrough\n-    case Op_AddHF:\n-    case Op_DivHF:\n-    case Op_FmaHF:\n-    case Op_MulHF:\n-    case Op_ReinterpretS2HF:\n-    case Op_ReinterpretHF2S:\n-    case Op_SubHF:\n-    case Op_SqrtHF:\n-      if (!VM_Version::supports_avx512_fp16()) {\n-        return false;\n-      }\n+    case Op_VecY:\n+      st->print(\"vmovdqu [rsp - #32], xmm0\\t# 256-bit mem-mem spill\\n\\t\"\n+                \"vmovdqu xmm0, [rsp + #%d]\\n\\t\"\n+                \"vmovdqu [rsp + #%d], xmm0\\n\\t\"\n+                \"vmovdqu xmm0, [rsp - #32]\",\n+                src_offset, dst_offset);\n@@ -1399,6 +2083,6 @@\n-    case Op_VectorLoadShuffle:\n-    case Op_VectorRearrange:\n-    case Op_MulReductionVI:\n-      if (UseSSE < 4) { \/\/ requires at least SSE4\n-        return false;\n-      }\n+    case Op_VecZ:\n+      st->print(\"vmovdqu [rsp - #64], xmm0\\t# 512-bit mem-mem spill\\n\\t\"\n+                \"vmovdqu xmm0, [rsp + #%d]\\n\\t\"\n+                \"vmovdqu [rsp + #%d], xmm0\\n\\t\"\n+                \"vmovdqu xmm0, [rsp - #64]\",\n+                src_offset, dst_offset);\n@@ -1406,4 +2090,93 @@\n-    case Op_IsInfiniteF:\n-    case Op_IsInfiniteD:\n-      if (!VM_Version::supports_avx512dq()) {\n-        return false;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+#endif\n+  }\n+}\n+\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler* masm,\n+                                       PhaseRegAlloc* ra_,\n+                                       bool do_size,\n+                                       outputStream* st) const {\n+  assert(masm != nullptr || st  != nullptr, \"sanity\");\n+  \/\/ Get registers to move\n+  OptoReg::Name src_second = ra_->get_reg_second(in(1));\n+  OptoReg::Name src_first = ra_->get_reg_first(in(1));\n+  OptoReg::Name dst_second = ra_->get_reg_second(this);\n+  OptoReg::Name dst_first = ra_->get_reg_first(this);\n+\n+  enum RC src_second_rc = rc_class(src_second);\n+  enum RC src_first_rc = rc_class(src_first);\n+  enum RC dst_second_rc = rc_class(dst_second);\n+  enum RC dst_first_rc = rc_class(dst_first);\n+\n+  assert(OptoReg::is_valid(src_first) && OptoReg::is_valid(dst_first),\n+         \"must move at least 1 register\" );\n+\n+  if (src_first == dst_first && src_second == dst_second) {\n+    \/\/ Self copy, no move\n+    return 0;\n+  }\n+  if (bottom_type()->isa_vect() != nullptr && bottom_type()->isa_vectmask() == nullptr) {\n+    uint ireg = ideal_reg();\n+    assert((src_first_rc != rc_int && dst_first_rc != rc_int), \"sanity\");\n+    assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), \"sanity\");\n+    if( src_first_rc == rc_stack && dst_first_rc == rc_stack ) {\n+      \/\/ mem -> mem\n+      int src_offset = ra_->reg2offset(src_first);\n+      int dst_offset = ra_->reg2offset(dst_first);\n+      vec_stack_to_stack_helper(masm, src_offset, dst_offset, ireg, st);\n+    } else if (src_first_rc == rc_float && dst_first_rc == rc_float ) {\n+      vec_mov_helper(masm, src_first, dst_first, src_second, dst_second, ireg, st);\n+    } else if (src_first_rc == rc_float && dst_first_rc == rc_stack ) {\n+      int stack_offset = ra_->reg2offset(dst_first);\n+      vec_spill_helper(masm, false, stack_offset, src_first, ireg, st);\n+    } else if (src_first_rc == rc_stack && dst_first_rc == rc_float ) {\n+      int stack_offset = ra_->reg2offset(src_first);\n+      vec_spill_helper(masm, true,  stack_offset, dst_first, ireg, st);\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+    return 0;\n+  }\n+  if (src_first_rc == rc_stack) {\n+    \/\/ mem ->\n+    if (dst_first_rc == rc_stack) {\n+      \/\/ mem -> mem\n+      assert(src_second != dst_first, \"overlap\");\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int src_offset = ra_->reg2offset(src_first);\n+        int dst_offset = ra_->reg2offset(dst_first);\n+        if (masm) {\n+          __ pushq(Address(rsp, src_offset));\n+          __ popq (Address(rsp, dst_offset));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"pushq   [rsp + #%d]\\t# 64-bit mem-mem spill\\n\\t\"\n+                    \"popq    [rsp + #%d]\",\n+                     src_offset, dst_offset);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        \/\/ No pushl\/popl, so:\n+        int src_offset = ra_->reg2offset(src_first);\n+        int dst_offset = ra_->reg2offset(dst_first);\n+        if (masm) {\n+          __ movq(Address(rsp, -8), rax);\n+          __ movl(rax, Address(rsp, src_offset));\n+          __ movl(Address(rsp, dst_offset), rax);\n+          __ movq(rax, Address(rsp, -8));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movq    [rsp - #8], rax\\t# 32-bit mem-mem spill\\n\\t\"\n+                    \"movl    rax, [rsp + #%d]\\n\\t\"\n+                    \"movl    [rsp + #%d], rax\\n\\t\"\n+                    \"movq    rax, [rsp - #8]\",\n+                     src_offset, dst_offset);\n+#endif\n+        }\n@@ -1411,16 +2184,30 @@\n-      break;\n-    case Op_SqrtVD:\n-    case Op_SqrtVF:\n-    case Op_VectorMaskCmp:\n-    case Op_VectorCastB2X:\n-    case Op_VectorCastS2X:\n-    case Op_VectorCastI2X:\n-    case Op_VectorCastL2X:\n-    case Op_VectorCastF2X:\n-    case Op_VectorCastD2X:\n-    case Op_VectorUCastB2X:\n-    case Op_VectorUCastS2X:\n-    case Op_VectorUCastI2X:\n-    case Op_VectorMaskCast:\n-      if (UseAVX < 1) { \/\/ enabled for AVX only\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_int) {\n+      \/\/ mem -> gpr\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(src_first);\n+        if (masm) {\n+          __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movq    %s, [rsp + #%d]\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     offset);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        int offset = ra_->reg2offset(src_first);\n+        if (masm) {\n+          __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movl    %s, [rsp + #%d]\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     offset);\n+#endif\n+        }\n@@ -1428,4 +2215,31 @@\n-      break;\n-    case Op_PopulateIndex:\n-      if (UseAVX < 2) {\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_float) {\n+      \/\/ mem-> xmm\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(src_first);\n+        if (masm) {\n+          __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"%s  %s, [rsp + #%d]\\t# spill\",\n+                     UseXmmLoadAndClearUpper ? \"movsd \" : \"movlpd\",\n+                     Matcher::regName[dst_first],\n+                     offset);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        int offset = ra_->reg2offset(src_first);\n+        if (masm) {\n+          __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movss   %s, [rsp + #%d]\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     offset);\n+#endif\n+        }\n@@ -1433,4 +2247,16 @@\n-      break;\n-    case Op_RoundVF:\n-      if (UseAVX < 2) { \/\/ enabled for AVX2 only\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_kreg) {\n+      \/\/ mem -> kreg\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(src_first);\n+        if (masm) {\n+          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"kmovq   %s, [rsp + #%d]\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     offset);\n+#endif\n+        }\n@@ -1438,4 +2264,33 @@\n-      break;\n-    case Op_RoundVD:\n-      if (UseAVX < 3) {\n-        return false;  \/\/ enabled for AVX3 only\n+      return 0;\n+    }\n+  } else if (src_first_rc == rc_int) {\n+    \/\/ gpr ->\n+    if (dst_first_rc == rc_stack) {\n+      \/\/ gpr -> mem\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(dst_first);\n+        if (masm) {\n+          __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movq    [rsp + #%d], %s\\t# spill\",\n+                     offset,\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        int offset = ra_->reg2offset(dst_first);\n+        if (masm) {\n+          __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movl    [rsp + #%d], %s\\t# spill\",\n+                     offset,\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1443,76 +2298,32 @@\n-      break;\n-    case Op_CompareAndSwapL:\n-    case Op_CompareAndSwapP:\n-      break;\n-    case Op_StrIndexOf:\n-      if (!UseSSE42Intrinsics) {\n-        return false;\n-      }\n-      break;\n-    case Op_StrIndexOfChar:\n-      if (!UseSSE42Intrinsics) {\n-        return false;\n-      }\n-      break;\n-    case Op_OnSpinWait:\n-      if (VM_Version::supports_on_spin_wait() == false) {\n-        return false;\n-      }\n-      break;\n-    case Op_MulVB:\n-    case Op_LShiftVB:\n-    case Op_RShiftVB:\n-    case Op_URShiftVB:\n-    case Op_VectorInsert:\n-    case Op_VectorLoadMask:\n-    case Op_VectorStoreMask:\n-    case Op_VectorBlend:\n-      if (UseSSE < 4) {\n-        return false;\n-      }\n-      break;\n-    case Op_MaxD:\n-    case Op_MaxF:\n-    case Op_MinD:\n-    case Op_MinF:\n-      if (UseAVX < 1) { \/\/ enabled for AVX only\n-        return false;\n-      }\n-      break;\n-    case Op_CacheWB:\n-    case Op_CacheWBPreSync:\n-    case Op_CacheWBPostSync:\n-      if (!VM_Version::supports_data_cache_line_flush()) {\n-        return false;\n-      }\n-      break;\n-    case Op_ExtractB:\n-    case Op_ExtractL:\n-    case Op_ExtractI:\n-    case Op_RoundDoubleMode:\n-      if (UseSSE < 4) {\n-        return false;\n-      }\n-      break;\n-    case Op_RoundDoubleModeV:\n-      if (VM_Version::supports_avx() == false) {\n-        return false; \/\/ 128bit vroundpd is not available\n-      }\n-      break;\n-    case Op_LoadVectorGather:\n-    case Op_LoadVectorGatherMasked:\n-      if (UseAVX < 2) {\n-        return false;\n-      }\n-      break;\n-    case Op_FmaF:\n-    case Op_FmaD:\n-    case Op_FmaVD:\n-    case Op_FmaVF:\n-      if (!UseFMA) {\n-        return false;\n-      }\n-      break;\n-    case Op_MacroLogicV:\n-      if (UseAVX < 3 || !UseVectorMacroLogic) {\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_int) {\n+      \/\/ gpr -> gpr\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (masm) {\n+          __ movq(as_Register(Matcher::_regEncode[dst_first]),\n+                  as_Register(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movq    %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+        return 0;\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        if (masm) {\n+          __ movl(as_Register(Matcher::_regEncode[dst_first]),\n+                  as_Register(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movl    %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+        return 0;\n@@ -1520,6 +2331,27 @@\n-      break;\n-\n-    case Op_VectorCmpMasked:\n-    case Op_VectorMaskGen:\n-      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n-        return false;\n+    } else if (dst_first_rc == rc_float) {\n+      \/\/ gpr -> xmm\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (masm) {\n+          __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movdq   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        if (masm) {\n+          __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movdl   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1527,7 +2359,14 @@\n-      break;\n-    case Op_VectorMaskFirstTrue:\n-    case Op_VectorMaskLastTrue:\n-    case Op_VectorMaskTrueCount:\n-    case Op_VectorMaskToLong:\n-      if (UseAVX < 1) {\n-         return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_kreg) {\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (masm) {\n+          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));\n+  #ifndef PRODUCT\n+        } else {\n+           st->print(\"kmovq   %s, %s\\t# spill\",\n+                       Matcher::regName[dst_first],\n+                       Matcher::regName[src_first]);\n+  #endif\n+        }\n@@ -1535,8 +2374,34 @@\n-      break;\n-    case Op_RoundF:\n-    case Op_RoundD:\n-      break;\n-    case Op_CopySignD:\n-    case Op_CopySignF:\n-      if (UseAVX < 3)  {\n-        return false;\n+      Unimplemented();\n+      return 0;\n+    }\n+  } else if (src_first_rc == rc_float) {\n+    \/\/ xmm ->\n+    if (dst_first_rc == rc_stack) {\n+      \/\/ xmm -> mem\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(dst_first);\n+        if (masm) {\n+          __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movsd   [rsp + #%d], %s\\t# spill\",\n+                     offset,\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        int offset = ra_->reg2offset(dst_first);\n+        if (masm) {\n+          __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movss   [rsp + #%d], %s\\t# spill\",\n+                     offset,\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1544,2 +2409,28 @@\n-      if (!VM_Version::supports_avx512vl()) {\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_int) {\n+      \/\/ xmm -> gpr\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (masm) {\n+          __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movdq   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        if (masm) {\n+          __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"movdl   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1547,5 +2438,30 @@\n-      break;\n-    case Op_CompressBits:\n-    case Op_ExpandBits:\n-      if (!VM_Version::supports_bmi2()) {\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_float) {\n+      \/\/ xmm -> xmm\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (masm) {\n+          __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"%s  %s, %s\\t# spill\",\n+                     UseXmmRegToRegMoveAll ? \"movapd\" : \"movsd \",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      } else {\n+        \/\/ 32-bit\n+        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n+        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n+        if (masm) {\n+          __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"%s  %s, %s\\t# spill\",\n+                     UseXmmRegToRegMoveAll ? \"movaps\" : \"movss \",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1553,4 +2469,21 @@\n-      break;\n-    case Op_CompressM:\n-      if (!VM_Version::supports_avx512vl() || !VM_Version::supports_bmi2()) {\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_kreg) {\n+      assert(false, \"Illegal spilling\");\n+      return 0;\n+    }\n+  } else if (src_first_rc == rc_kreg) {\n+    if (dst_first_rc == rc_stack) {\n+      \/\/ mem -> kreg\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(dst_first);\n+        if (masm) {\n+          __ kmov(Address(rsp, offset), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"kmovq   [rsp + #%d] , %s\\t# spill\",\n+                     offset,\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1558,5 +2491,14 @@\n-      break;\n-    case Op_ConvF2HF:\n-    case Op_ConvHF2F:\n-      if (!VM_Version::supports_float16()) {\n-        return false;\n+      return 0;\n+    } else if (dst_first_rc == rc_int) {\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (masm) {\n+          __ kmov(as_Register(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+         st->print(\"kmovq   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1564,5 +2506,15 @@\n-      break;\n-    case Op_VectorCastF2HF:\n-    case Op_VectorCastHF2F:\n-      if (!VM_Version::supports_f16c() && !VM_Version::supports_evex()) {\n-        return false;\n+      Unimplemented();\n+      return 0;\n+    } else if (dst_first_rc == rc_kreg) {\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (masm) {\n+          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+         st->print(\"kmovq   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n@@ -1570,1 +2522,5 @@\n-      break;\n+      return 0;\n+    } else if (dst_first_rc == rc_float) {\n+      assert(false, \"Illegal spill\");\n+      return 0;\n+    }\n@@ -1572,1 +2528,4 @@\n-  return true;  \/\/ Match rules are supported by default.\n+\n+  assert(0,\" foo \");\n+  Unimplemented();\n+  return 0;\n@@ -1575,1 +2534,5 @@\n-\/\/------------------------------------------------------------------------\n+#ifndef PRODUCT\n+void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {\n+  implementation(nullptr, ra_, false, st);\n+}\n+#endif\n@@ -1577,3 +2540,2 @@\n-static inline bool is_pop_count_instr_target(BasicType bt) {\n-  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n-         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -1582,2 +2544,2 @@\n-bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n-  return match_rule_supported_vector(opcode, vlen, bt);\n+uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {\n+  return MachNode::size(ra_);\n@@ -1586,5 +2548,26 @@\n-\/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n-\/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n-bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n-  if (!match_rule_supported(opcode)) {\n-    return false;\n+\/\/=============================================================================\n+#ifndef PRODUCT\n+void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());\n+  int reg = ra_->get_reg_first(this);\n+  st->print(\"leaq    %s, [rsp + #%d]\\t# box lock\",\n+            Matcher::regName[reg], offset);\n+}\n+#endif\n+\n+void BoxLockNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n+{\n+  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());\n+  int reg = ra_->get_encode(this);\n+\n+  __ lea(as_Register(reg), Address(rsp, offset));\n+}\n+\n+uint BoxLockNode::size(PhaseRegAlloc *ra_) const\n+{\n+  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());\n+  if (ra_->get_encode(this) > 15) {\n+    return (offset < 0x80) ? 6 : 9; \/\/ REX2\n+  } else {\n+    return (offset < 0x80) ? 5 : 8; \/\/ REX\n@@ -1592,10 +2575,35 @@\n-  \/\/ Matcher::vector_size_supported() restricts vector sizes in the following way (see Matcher::vector_width_in_bytes):\n-  \/\/   * SSE2 supports 128bit vectors for all types;\n-  \/\/   * AVX1 supports 256bit vectors only for FLOAT and DOUBLE types;\n-  \/\/   * AVX2 supports 256bit vectors for all types;\n-  \/\/   * AVX512F supports 512bit vectors only for INT, FLOAT, and DOUBLE types;\n-  \/\/   * AVX512BW supports 512bit vectors for BYTE, SHORT, and CHAR types.\n-  \/\/ There's also a limit on minimum vector size supported: 2 elements (or 4 bytes for BYTE).\n-  \/\/ And MaxVectorSize is taken into account as well.\n-  if (!vector_size_supported(bt, vlen)) {\n-    return false;\n+}\n+\n+\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"MachVEPNode\");\n+}\n+#endif\n+\n+void MachVEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n+{\n+  CodeBuffer* cbuf = masm->code();\n+  uint insts_size = cbuf->insts_size();\n+  if (!_verified) {\n+    __ ic_check(1);\n+  } else {\n+    \/\/ TODO 8284443 Avoid creation of temporary frame\n+    if (ra_->C->stub_function() == nullptr) {\n+      __ verified_entry(ra_->C, 0);\n+      __ entry_barrier();\n+      int initial_framesize = ra_->C->output()->frame_size_in_bytes() - 2*wordSize;\n+      __ remove_frame(initial_framesize, false);\n+    }\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    if (Compile::current()->output()->in_scratch_emit_size()) {\n+      Label dummy_verified_entry;\n+      __ jmp(dummy_verified_entry);\n+    } else {\n+      __ jmp(*_verified_entry);\n+    }\n@@ -1603,21 +2611,337 @@\n-  \/\/ Special cases which require vector length follow:\n-  \/\/   * implementation limitations\n-  \/\/   * some 512bit vector operations on FLOAT and DOUBLE types require AVX512DQ\n-  \/\/   * 128bit vroundpd instruction is present only in AVX1\n-  int size_in_bits = vlen * type2aelembytes(bt) * BitsPerByte;\n-  switch (opcode) {\n-    case Op_MaxVHF:\n-    case Op_MinVHF:\n-      if (!VM_Version::supports_avx512bw()) {\n-        return false;\n-      }\n-    case Op_AddVHF:\n-    case Op_DivVHF:\n-    case Op_FmaVHF:\n-    case Op_MulVHF:\n-    case Op_SubVHF:\n-    case Op_SqrtVHF:\n-      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n-        return false;\n-      }\n-      if (!VM_Version::supports_avx512_fp16()) {\n+  \/* WARNING these NOPs are critical so that verified entry point is properly\n+     4 bytes aligned for patching by NativeJump::patch_verified_entry() *\/\n+  int nops_cnt = 4 - ((cbuf->insts_size() - insts_size) & 0x3);\n+  nops_cnt &= 0x3; \/\/ Do not add nops if code is aligned.\n+  if (nops_cnt > 0) {\n+    __ nop(nops_cnt);\n+  }\n+}\n+\n+\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  if (UseCompressedClassPointers) {\n+    st->print_cr(\"movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n+    st->print_cr(\"\\tcmpl    rscratch1, [rax + CompiledICData::speculated_klass_offset()]\\t # Inline cache check\");\n+  } else {\n+    st->print_cr(\"movq    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n+    st->print_cr(\"\\tcmpq    rscratch1, [rax + CompiledICData::speculated_klass_offset()]\\t # Inline cache check\");\n+  }\n+  st->print_cr(\"\\tjne     SharedRuntime::_ic_miss_stub\");\n+}\n+#endif\n+\n+void MachUEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n+{\n+  __ ic_check(InteriorEntryAlignment);\n+}\n+\n+\n+\/\/=============================================================================\n+\n+bool Matcher::supports_vector_calling_convention(void) {\n+  return EnableVectorSupport;\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  assert(EnableVectorSupport, \"sanity\");\n+  int lo = XMM0_num;\n+  int hi = XMM0b_num;\n+  if (ideal_reg == Op_VecX) hi = XMM0d_num;\n+  else if (ideal_reg == Op_VecY) hi = XMM0h_num;\n+  else if (ideal_reg == Op_VecZ) hi = XMM0p_num;\n+  return OptoRegPair(hi, lo);\n+}\n+\n+\/\/ Is this branch offset short enough that a short branch can be used?\n+\/\/\n+\/\/ NOTE: If the platform does not provide any short branch variants, then\n+\/\/       this method should return false for offset 0.\n+bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {\n+  \/\/ The passed offset is relative to address of the branch.\n+  \/\/ On 86 a branch displacement is calculated relative to address\n+  \/\/ of a next instruction.\n+  offset -= br_size;\n+\n+  \/\/ the short version of jmpConUCF2 contains multiple branches,\n+  \/\/ making the reach slightly less\n+  if (rule == jmpConUCF2_rule)\n+    return (-126 <= offset && offset <= 125);\n+  return (-128 <= offset && offset <= 127);\n+}\n+\n+\/\/ Return whether or not this register is ever used as an argument.\n+\/\/ This function is used on startup to build the trampoline stubs in\n+\/\/ generateOptoStub.  Registers not mentioned will be killed by the VM\n+\/\/ call in the trampoline, and arguments in those registers not be\n+\/\/ available to the callee.\n+bool Matcher::can_be_java_arg(int reg)\n+{\n+  return\n+    reg ==  RDI_num || reg == RDI_H_num ||\n+    reg ==  RSI_num || reg == RSI_H_num ||\n+    reg ==  RDX_num || reg == RDX_H_num ||\n+    reg ==  RCX_num || reg == RCX_H_num ||\n+    reg ==   R8_num || reg ==  R8_H_num ||\n+    reg ==   R9_num || reg ==  R9_H_num ||\n+    reg ==  R12_num || reg == R12_H_num ||\n+    reg == XMM0_num || reg == XMM0b_num ||\n+    reg == XMM1_num || reg == XMM1b_num ||\n+    reg == XMM2_num || reg == XMM2b_num ||\n+    reg == XMM3_num || reg == XMM3b_num ||\n+    reg == XMM4_num || reg == XMM4b_num ||\n+    reg == XMM5_num || reg == XMM5b_num ||\n+    reg == XMM6_num || reg == XMM6b_num ||\n+    reg == XMM7_num || reg == XMM7b_num;\n+}\n+\n+bool Matcher::is_spillable_arg(int reg)\n+{\n+  return can_be_java_arg(reg);\n+}\n+\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? _INT_REG_mask.size() : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ After experiment around with different values, the following default threshold\n+  \/\/ works best for LCM's register pressure scheduling on x64.\n+  uint dec_count  = VM_Version::supports_evex() ? 4 : 2;\n+  uint default_float_pressure_threshold = _FLOAT_REG_mask.size() - dec_count;\n+  return (FLOATPRESSURE == -1) ? default_float_pressure_threshold : FLOATPRESSURE;\n+}\n+\n+bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {\n+  \/\/ In 64 bit mode a code which use multiply when\n+  \/\/ devisor is constant is faster than hardware\n+  \/\/ DIV instruction (it uses MulHiL).\n+  return false;\n+}\n+\n+\/\/ Register for DIVI projection of divmodI\n+const RegMask& Matcher::divI_proj_mask() {\n+  return INT_RAX_REG_mask();\n+}\n+\n+\/\/ Register for MODI projection of divmodI\n+const RegMask& Matcher::modI_proj_mask() {\n+  return INT_RDX_REG_mask();\n+}\n+\n+\/\/ Register for DIVL projection of divmodL\n+const RegMask& Matcher::divL_proj_mask() {\n+  return LONG_RAX_REG_mask();\n+}\n+\n+\/\/ Register for MODL projection of divmodL\n+const RegMask& Matcher::modL_proj_mask() {\n+  return LONG_RDX_REG_mask();\n+}\n+\n+%}\n+\n+source_hpp %{\n+\/\/ Header information of the source block.\n+\/\/ Method declarations\/definitions which are used outside\n+\/\/ the ad-scope can conveniently be defined here.\n+\/\/\n+\/\/ To keep related declarations\/definitions\/uses close together,\n+\/\/ we switch between source %{ }% and source_hpp %{ }% freely as needed.\n+\n+#include \"runtime\/vm_version.hpp\"\n+\n+class NativeJump;\n+\n+class CallStubImpl {\n+\n+  \/\/--------------------------------------------------------------\n+  \/\/---<  Used for optimization in Compile::shorten_branches  >---\n+  \/\/--------------------------------------------------------------\n+\n+ public:\n+  \/\/ Size of call trampoline stub.\n+  static uint size_call_trampoline() {\n+    return 0; \/\/ no call trampolines on this platform\n+  }\n+\n+  \/\/ number of relocations needed by a call trampoline stub\n+  static uint reloc_call_trampoline() {\n+    return 0; \/\/ no call trampolines on this platform\n+  }\n+};\n+\n+class HandlerImpl {\n+\n+ public:\n+\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n+\n+  static uint size_deopt_handler() {\n+    \/\/ one call and one jmp.\n+    return 10;\n+  }\n+};\n+\n+inline Assembler::AvxVectorLen vector_length_encoding(int bytes) {\n+  switch(bytes) {\n+    case  4: \/\/ fall-through\n+    case  8: \/\/ fall-through\n+    case 16: return Assembler::AVX_128bit;\n+    case 32: return Assembler::AVX_256bit;\n+    case 64: return Assembler::AVX_512bit;\n+\n+    default: {\n+      ShouldNotReachHere();\n+      return Assembler::AVX_NoVec;\n+    }\n+  }\n+}\n+\n+static inline Assembler::AvxVectorLen vector_length_encoding(const Node* n) {\n+  return vector_length_encoding(Matcher::vector_length_in_bytes(n));\n+}\n+\n+static inline Assembler::AvxVectorLen vector_length_encoding(const MachNode* use, MachOper* opnd) {\n+  uint def_idx = use->operand_index(opnd);\n+  Node* def = use->in(def_idx);\n+  return vector_length_encoding(def);\n+}\n+\n+static inline bool is_vector_popcount_predicate(BasicType bt) {\n+  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n+         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+}\n+\n+static inline bool is_clz_non_subword_predicate_evex(BasicType bt, int vlen_bytes) {\n+  return is_non_subword_integral_type(bt) && VM_Version::supports_avx512cd() &&\n+           (VM_Version::supports_avx512vl() || vlen_bytes == 64);\n+}\n+\n+class Node::PD {\n+public:\n+  enum NodeFlags {\n+    Flag_intel_jcc_erratum    = Node::_last_flag << 1,\n+    Flag_sets_carry_flag      = Node::_last_flag << 2,\n+    Flag_sets_parity_flag     = Node::_last_flag << 3,\n+    Flag_sets_zero_flag       = Node::_last_flag << 4,\n+    Flag_sets_overflow_flag   = Node::_last_flag << 5,\n+    Flag_sets_sign_flag       = Node::_last_flag << 6,\n+    Flag_clears_carry_flag    = Node::_last_flag << 7,\n+    Flag_clears_parity_flag   = Node::_last_flag << 8,\n+    Flag_clears_zero_flag     = Node::_last_flag << 9,\n+    Flag_clears_overflow_flag = Node::_last_flag << 10,\n+    Flag_clears_sign_flag     = Node::_last_flag << 11,\n+    _last_flag                = Flag_clears_sign_flag\n+  };\n+};\n+\n+%} \/\/ end source_hpp\n+\n+source %{\n+\n+#include \"opto\/addnode.hpp\"\n+#include \"c2_intelJccErratum_x86.hpp\"\n+\n+void PhaseOutput::pd_perform_mach_node_analysis() {\n+  if (VM_Version::has_intel_jcc_erratum()) {\n+    int extra_padding = IntelJccErratum::tag_affected_machnodes(C, C->cfg(), C->regalloc());\n+    _buf_sizes._code += extra_padding;\n+  }\n+}\n+\n+int MachNode::pd_alignment_required() const {\n+  if (VM_Version::has_intel_jcc_erratum() && IntelJccErratum::is_jcc_erratum_branch(this)) {\n+    \/\/ Conservatively add worst case padding. We assume that relocInfo::addr_unit() is 1 on x86.\n+    return IntelJccErratum::largest_jcc_size() + 1;\n+  } else {\n+    return 1;\n+  }\n+}\n+\n+int MachNode::compute_padding(int current_offset) const {\n+  if (flags() & Node::PD::Flag_intel_jcc_erratum) {\n+    Compile* C = Compile::current();\n+    PhaseOutput* output = C->output();\n+    Block* block = output->block();\n+    int index = output->index();\n+    return IntelJccErratum::compute_padding(current_offset, this, block, index, C->regalloc());\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+\/\/ Emit deopt handler code.\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm) {\n+\n+  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n+  \/\/ That's why we must use the macroassembler to generate a handler.\n+  address base = __ start_a_stub(size_deopt_handler());\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n+  int offset = __ offset();\n+\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n+\n+  assert(__ offset() - offset <= (int) size_deopt_handler(), \"overflow %d\", (__ offset() - offset));\n+  __ end_a_stub();\n+  return entry_offset;\n+}\n+\n+static Assembler::Width widthForType(BasicType bt) {\n+  if (bt == T_BYTE) {\n+    return Assembler::B;\n+  } else if (bt == T_SHORT) {\n+    return Assembler::W;\n+  } else if (bt == T_INT) {\n+    return Assembler::D;\n+  } else {\n+    assert(bt == T_LONG, \"not a long: %s\", type2name(bt));\n+    return Assembler::Q;\n+  }\n+}\n+\n+\/\/=============================================================================\n+\n+  \/\/ Float masks come from different places depending on platform.\n+  static address float_signmask()  { return StubRoutines::x86::float_sign_mask(); }\n+  static address float_signflip()  { return StubRoutines::x86::float_sign_flip(); }\n+  static address double_signmask() { return StubRoutines::x86::double_sign_mask(); }\n+  static address double_signflip() { return StubRoutines::x86::double_sign_flip(); }\n+  static address vector_short_to_byte_mask() { return StubRoutines::x86::vector_short_to_byte_mask(); }\n+  static address vector_int_to_byte_mask() { return StubRoutines::x86::vector_int_to_byte_mask(); }\n+  static address vector_byte_perm_mask() { return StubRoutines::x86::vector_byte_perm_mask(); }\n+  static address vector_long_sign_mask() { return StubRoutines::x86::vector_long_sign_mask(); }\n+  static address vector_all_bits_set() { return StubRoutines::x86::vector_all_bits_set(); }\n+  static address vector_int_mask_cmp_bits() { return StubRoutines::x86::vector_int_mask_cmp_bits(); }\n+  static address vector_int_to_short_mask() { return StubRoutines::x86::vector_int_to_short_mask(); }\n+  static address vector_byte_shufflemask() { return StubRoutines::x86::vector_byte_shuffle_mask(); }\n+  static address vector_short_shufflemask() { return StubRoutines::x86::vector_short_shuffle_mask(); }\n+  static address vector_int_shufflemask() { return StubRoutines::x86::vector_int_shuffle_mask(); }\n+  static address vector_long_shufflemask() { return StubRoutines::x86::vector_long_shuffle_mask(); }\n+  static address vector_32_bit_mask() { return StubRoutines::x86::vector_32_bit_mask(); }\n+  static address vector_64_bit_mask() { return StubRoutines::x86::vector_64_bit_mask(); }\n+  static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}\n+  static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}\n+\n+\/\/=============================================================================\n+bool Matcher::match_rule_supported(int opcode) {\n+  if (!has_match_rule(opcode)) {\n+    return false; \/\/ no match rule present\n+  }\n+  switch (opcode) {\n+    case Op_AbsVL:\n+    case Op_StoreVectorScatter:\n+      if (UseAVX < 3) {\n@@ -1627,4 +2951,4 @@\n-    case Op_AbsVF:\n-    case Op_NegVF:\n-      if ((vlen == 16) && (VM_Version::supports_avx512dq() == false)) {\n-        return false; \/\/ 512bit vandps and vxorps are not available\n+    case Op_PopCountI:\n+    case Op_PopCountL:\n+      if (!UsePopCountInstruction) {\n+        return false;\n@@ -1633,4 +2957,3 @@\n-    case Op_AbsVD:\n-    case Op_NegVD:\n-      if ((vlen == 8) && (VM_Version::supports_avx512dq() == false)) {\n-        return false; \/\/ 512bit vpmullq, vandpd and vxorpd are not available\n+    case Op_PopCountVI:\n+      if (UseAVX < 2) {\n+        return false;\n@@ -1639,24 +2962,4 @@\n-    case Op_RotateRightV:\n-    case Op_RotateLeftV:\n-      if (bt != T_INT && bt != T_LONG) {\n-        return false;\n-      } \/\/ fallthrough\n-    case Op_MacroLogicV:\n-      if (!VM_Version::supports_evex() ||\n-          ((size_in_bits != 512) && !VM_Version::supports_avx512vl())) {\n-        return false;\n-      }\n-      break;\n-    case Op_ClearArray:\n-    case Op_VectorMaskGen:\n-    case Op_VectorCmpMasked:\n-      if (!VM_Version::supports_avx512bw()) {\n-        return false;\n-      }\n-      if ((size_in_bits != 512) && !VM_Version::supports_avx512vl()) {\n-        return false;\n-      }\n-      break;\n-    case Op_LoadVectorMasked:\n-    case Op_StoreVectorMasked:\n-      if (!VM_Version::supports_avx512bw() && (is_subword_type(bt) || UseAVX < 1)) {\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+    case Op_PopCountVL:\n+      if (UseAVX < 2) {\n@@ -1666,3 +2969,2 @@\n-    case Op_UMinV:\n-    case Op_UMaxV:\n-      if (UseAVX == 0) {\n+    case Op_MulVI:\n+      if ((UseSSE < 4) && (UseAVX < 1)) { \/\/ only with SSE4_1 or AVX\n@@ -1672,3 +2974,2 @@\n-    case Op_MaxV:\n-    case Op_MinV:\n-      if (UseSSE < 4 && is_integral_type(bt)) {\n+    case Op_MulVL:\n+      if (UseSSE < 4) { \/\/ only with SSE4_1 or AVX\n@@ -1677,9 +2978,0 @@\n-      if ((bt == T_FLOAT || bt == T_DOUBLE)) {\n-          \/\/ Float\/Double intrinsics are enabled for AVX family currently.\n-          if (UseAVX == 0) {\n-            return false;\n-          }\n-          if (UseAVX > 2 && (!VM_Version::supports_avx512dq() && size_in_bits == 512)) { \/\/ 512 bit Float\/Double intrinsics need AVX512DQ\n-            return false;\n-          }\n-      }\n@@ -1687,2 +2979,2 @@\n-    case Op_CallLeafVector:\n-      if (size_in_bits == 512 && !VM_Version::supports_avx512vlbwdq()) {\n+    case Op_MulReductionVL:\n+      if (VM_Version::supports_avx512dq() == false) {\n@@ -1692,0 +2984,3 @@\n+    case Op_AbsVB:\n+    case Op_AbsVS:\n+    case Op_AbsVI:\n@@ -1693,4 +2988,0 @@\n-      if (bt == T_INT && (UseSSE < 3 || !VM_Version::supports_ssse3())) {\n-        return false;\n-      }\n-      \/\/ fallthrough\n@@ -1700,1 +2991,1 @@\n-      if (is_subword_type(bt) && (UseSSE < 4)) {\n+      if (UseSSE < 3) { \/\/ requires at least SSSE3\n@@ -1704,9 +2995,3 @@\n-    case Op_MinReductionV:\n-    case Op_MaxReductionV:\n-      if ((bt == T_INT || is_subword_type(bt)) && UseSSE < 4) {\n-        return false;\n-      } else if (bt == T_LONG && (UseAVX < 3 || !VM_Version::supports_avx512vlbwdq())) {\n-        return false;\n-      }\n-      \/\/ Float\/Double intrinsics enabled for AVX family.\n-      if (UseAVX == 0 && (bt == T_FLOAT || bt == T_DOUBLE)) {\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+      if (!VM_Version::supports_avx512vlbw()) {\n@@ -1714,2 +2999,10 @@\n-      }\n-      if (UseAVX > 2 && (!VM_Version::supports_avx512dq() && size_in_bits == 512)) {\n+      }  \/\/ fallthrough\n+    case Op_AddHF:\n+    case Op_DivHF:\n+    case Op_FmaHF:\n+    case Op_MulHF:\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n+    case Op_SubHF:\n+    case Op_SqrtHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n@@ -1719,7 +3012,0 @@\n-    case Op_VectorTest:\n-      if (UseSSE < 4) {\n-        return false; \/\/ Implementation limitation\n-      } else if (size_in_bits < 32) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      break;\n@@ -1728,15 +3014,3 @@\n-      if(vlen == 2) {\n-        return false; \/\/ Implementation limitation due to how shuffle is loaded\n-      } else if (size_in_bits == 256 && UseAVX < 2) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      break;\n-    case Op_VectorLoadMask:\n-    case Op_VectorMaskCast:\n-      if (size_in_bits == 256 && UseAVX < 2) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      \/\/ fallthrough\n-    case Op_VectorStoreMask:\n-      if (vlen == 2) {\n-        return false; \/\/ Implementation limitation\n+    case Op_MulReductionVI:\n+      if (UseSSE < 4) { \/\/ requires at least SSE4\n+        return false;\n@@ -1745,2 +3019,3 @@\n-    case Op_PopulateIndex:\n-      if (size_in_bits > 256 && !VM_Version::supports_avx512bw()) {\n+    case Op_IsInfiniteF:\n+    case Op_IsInfiniteD:\n+      if (!VM_Version::supports_avx512dq()) {\n@@ -1750,0 +3025,3 @@\n+    case Op_SqrtVD:\n+    case Op_SqrtVF:\n+    case Op_VectorMaskCmp:\n@@ -1753,4 +3031,0 @@\n-      if (bt != T_DOUBLE && size_in_bits == 256 && UseAVX < 2) {\n-        return false;\n-      }\n-      break;\n@@ -1758,3 +3032,7 @@\n-      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n-        return false;\n-      } else if (!is_integral_type(bt) && !VM_Version::supports_avx512dq()) {\n+    case Op_VectorCastF2X:\n+    case Op_VectorCastD2X:\n+    case Op_VectorUCastB2X:\n+    case Op_VectorUCastS2X:\n+    case Op_VectorUCastI2X:\n+    case Op_VectorMaskCast:\n+      if (UseAVX < 1) { \/\/ enabled for AVX only\n@@ -1764,12 +3042,2 @@\n-    case Op_VectorCastF2X: {\n-        \/\/ As per JLS section 5.1.3 narrowing conversion to sub-word types\n-        \/\/ happen after intermediate conversion to integer and special handling\n-        \/\/ code needs AVX2 vpcmpeqd instruction for 256 bit vectors.\n-        int src_size_in_bits = type2aelembytes(T_FLOAT) * vlen * BitsPerByte;\n-        if (is_integral_type(bt) && src_size_in_bits == 256 && UseAVX < 2) {\n-          return false;\n-        }\n-      }\n-      \/\/ fallthrough\n-    case Op_VectorCastD2X:\n-      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n+    case Op_PopulateIndex:\n+      if (UseAVX < 2) {\n@@ -1779,5 +3047,2 @@\n-    case Op_VectorCastF2HF:\n-    case Op_VectorCastHF2F:\n-      if (!VM_Version::supports_f16c() &&\n-         ((!VM_Version::supports_evex() ||\n-         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n+    case Op_RoundVF:\n+      if (UseAVX < 2) { \/\/ enabled for AVX2 only\n@@ -1788,2 +3053,2 @@\n-      if (!VM_Version::supports_avx512dq()) {\n-        return false;\n+      if (UseAVX < 3) {\n+        return false;  \/\/ enabled for AVX3 only\n@@ -1792,2 +3057,5 @@\n-    case Op_MulReductionVI:\n-      if (bt == T_BYTE && size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+    case Op_CompareAndSwapL:\n+    case Op_CompareAndSwapP:\n+      break;\n+    case Op_StrIndexOf:\n+      if (!UseSSE42Intrinsics) {\n@@ -1797,2 +3065,2 @@\n-    case Op_LoadVectorGatherMasked:\n-      if (!is_subword_type(bt) && size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+    case Op_StrIndexOfChar:\n+      if (!UseSSE42Intrinsics) {\n@@ -1801,4 +3069,3 @@\n-      if (is_subword_type(bt) &&\n-         ((size_in_bits > 256 && !VM_Version::supports_avx512bw()) ||\n-          (size_in_bits < 64)                                      ||\n-          (bt == T_SHORT && !VM_Version::supports_bmi2()))) {\n+      break;\n+    case Op_OnSpinWait:\n+      if (VM_Version::supports_on_spin_wait() == false) {\n@@ -1808,5 +3075,9 @@\n-    case Op_StoreVectorScatterMasked:\n-    case Op_StoreVectorScatter:\n-      if (is_subword_type(bt)) {\n-        return false;\n-      } else if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+    case Op_MulVB:\n+    case Op_LShiftVB:\n+    case Op_RShiftVB:\n+    case Op_URShiftVB:\n+    case Op_VectorInsert:\n+    case Op_VectorLoadMask:\n+    case Op_VectorStoreMask:\n+    case Op_VectorBlend:\n+      if (UseSSE < 4) {\n@@ -1815,3 +3086,6 @@\n-      \/\/ fallthrough\n-    case Op_LoadVectorGather:\n-      if (!is_subword_type(bt) && size_in_bits == 64) {\n+      break;\n+    case Op_MaxD:\n+    case Op_MaxF:\n+    case Op_MinD:\n+    case Op_MinF:\n+      if (UseAVX < 1) { \/\/ enabled for AVX only\n@@ -1820,1 +3094,5 @@\n-      if (is_subword_type(bt) && size_in_bits < 64) {\n+      break;\n+    case Op_CacheWB:\n+    case Op_CacheWBPreSync:\n+    case Op_CacheWBPostSync:\n+      if (!VM_Version::supports_data_cache_line_flush()) {\n@@ -1824,6 +3102,5 @@\n-    case Op_SaturatingAddV:\n-    case Op_SaturatingSubV:\n-      if (UseAVX < 1) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      if (is_subword_type(bt) && size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+    case Op_ExtractB:\n+    case Op_ExtractL:\n+    case Op_ExtractI:\n+    case Op_RoundDoubleMode:\n+      if (UseSSE < 4) {\n@@ -1833,20 +3110,3 @@\n-    case Op_SelectFromTwoVector:\n-       if (size_in_bits < 128) {\n-         return false;\n-       }\n-       if ((size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n-         return false;\n-       }\n-       if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n-         return false;\n-       }\n-       if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n-         return false;\n-       }\n-       if ((bt == T_INT || bt == T_FLOAT || bt == T_DOUBLE) && !VM_Version::supports_evex()) {\n-         return false;\n-       }\n-       break;\n-    case Op_MaskAll:\n-      if (!VM_Version::supports_evex()) {\n-        return false;\n+    case Op_RoundDoubleModeV:\n+      if (VM_Version::supports_avx() == false) {\n+        return false; \/\/ 128bit vroundpd is not available\n@@ -1854,1 +3114,4 @@\n-      if ((vlen > 16 || is_subword_type(bt)) && !VM_Version::supports_avx512bw()) {\n+      break;\n+    case Op_LoadVectorGather:\n+    case Op_LoadVectorGatherMasked:\n+      if (UseAVX < 2) {\n@@ -1857,1 +3120,6 @@\n-      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+      break;\n+    case Op_FmaF:\n+    case Op_FmaD:\n+    case Op_FmaVD:\n+    case Op_FmaVF:\n+      if (!UseFMA) {\n@@ -1861,2 +3129,2 @@\n-    case Op_VectorMaskCmp:\n-      if (vlen < 2 || size_in_bits < 32) {\n+    case Op_MacroLogicV:\n+      if (UseAVX < 3 || !UseVectorMacroLogic) {\n@@ -1866,1 +3134,3 @@\n-    case Op_CompressM:\n+\n+    case Op_VectorCmpMasked:\n+    case Op_VectorMaskGen:\n@@ -1871,3 +3141,14 @@\n-    case Op_CompressV:\n-    case Op_ExpandV:\n-      if (is_subword_type(bt) && !VM_Version::supports_avx512_vbmi2()) {\n+    case Op_VectorMaskFirstTrue:\n+    case Op_VectorMaskLastTrue:\n+    case Op_VectorMaskTrueCount:\n+    case Op_VectorMaskToLong:\n+      if (UseAVX < 1) {\n+         return false;\n+      }\n+      break;\n+    case Op_RoundF:\n+    case Op_RoundD:\n+      break;\n+    case Op_CopySignD:\n+    case Op_CopySignF:\n+      if (UseAVX < 3)  {\n@@ -1876,1 +3157,1 @@\n-      if (size_in_bits < 128 ) {\n+      if (!VM_Version::supports_avx512vl()) {\n@@ -1879,2 +3160,4 @@\n-    case Op_VectorLongToMask:\n-      if (UseAVX < 1) {\n+      break;\n+    case Op_CompressBits:\n+    case Op_ExpandBits:\n+      if (!VM_Version::supports_bmi2()) {\n@@ -1883,1 +3166,3 @@\n-      if (UseAVX < 3 && !VM_Version::supports_bmi2()) {\n+      break;\n+    case Op_CompressM:\n+      if (!VM_Version::supports_avx512vl() || !VM_Version::supports_bmi2()) {\n@@ -1887,3 +3172,3 @@\n-    case Op_SignumVD:\n-    case Op_SignumVF:\n-      if (UseAVX < 1) {\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      if (!VM_Version::supports_float16()) {\n@@ -1893,6 +3178,4 @@\n-    case Op_PopCountVI:\n-    case Op_PopCountVL: {\n-        if (!is_pop_count_instr_target(bt) &&\n-            (size_in_bits == 512) && !VM_Version::supports_avx512bw()) {\n-          return false;\n-        }\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_evex()) {\n+        return false;\n@@ -1901,3 +3184,53 @@\n-    case Op_ReverseV:\n-    case Op_ReverseBytesV:\n-      if (UseAVX < 2) {\n+  }\n+  return true;  \/\/ Match rules are supported by default.\n+}\n+\n+\/\/------------------------------------------------------------------------\n+\n+static inline bool is_pop_count_instr_target(BasicType bt) {\n+  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n+         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+}\n+\n+bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n+  return match_rule_supported_vector(opcode, vlen, bt);\n+}\n+\n+\/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n+\/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n+bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+  if (!match_rule_supported(opcode)) {\n+    return false;\n+  }\n+  \/\/ Matcher::vector_size_supported() restricts vector sizes in the following way (see Matcher::vector_width_in_bytes):\n+  \/\/   * SSE2 supports 128bit vectors for all types;\n+  \/\/   * AVX1 supports 256bit vectors only for FLOAT and DOUBLE types;\n+  \/\/   * AVX2 supports 256bit vectors for all types;\n+  \/\/   * AVX512F supports 512bit vectors only for INT, FLOAT, and DOUBLE types;\n+  \/\/   * AVX512BW supports 512bit vectors for BYTE, SHORT, and CHAR types.\n+  \/\/ There's also a limit on minimum vector size supported: 2 elements (or 4 bytes for BYTE).\n+  \/\/ And MaxVectorSize is taken into account as well.\n+  if (!vector_size_supported(bt, vlen)) {\n+    return false;\n+  }\n+  \/\/ Special cases which require vector length follow:\n+  \/\/   * implementation limitations\n+  \/\/   * some 512bit vector operations on FLOAT and DOUBLE types require AVX512DQ\n+  \/\/   * 128bit vroundpd instruction is present only in AVX1\n+  int size_in_bits = vlen * type2aelembytes(bt) * BitsPerByte;\n+  switch (opcode) {\n+    case Op_MaxVHF:\n+    case Op_MinVHF:\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+    case Op_AddVHF:\n+    case Op_DivVHF:\n+    case Op_FmaVHF:\n+    case Op_MulVHF:\n+    case Op_SubVHF:\n+    case Op_SqrtVHF:\n+      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      if (!VM_Version::supports_avx512_fp16()) {\n@@ -1907,3 +3240,20 @@\n-    case Op_CountTrailingZerosV:\n-    case Op_CountLeadingZerosV:\n-      if (UseAVX < 2) {\n+    case Op_AbsVF:\n+    case Op_NegVF:\n+      if ((vlen == 16) && (VM_Version::supports_avx512dq() == false)) {\n+        return false; \/\/ 512bit vandps and vxorps are not available\n+      }\n+      break;\n+    case Op_AbsVD:\n+    case Op_NegVD:\n+      if ((vlen == 8) && (VM_Version::supports_avx512dq() == false)) {\n+        return false; \/\/ 512bit vpmullq, vandpd and vxorpd are not available\n+      }\n+      break;\n+    case Op_RotateRightV:\n+    case Op_RotateLeftV:\n+      if (bt != T_INT && bt != T_LONG) {\n+        return false;\n+      } \/\/ fallthrough\n+    case Op_MacroLogicV:\n+      if (!VM_Version::supports_evex() ||\n+          ((size_in_bits != 512) && !VM_Version::supports_avx512vl())) {\n@@ -1913,3 +3263,13239 @@\n-  }\n-  return true;  \/\/ Per default match rules are supported.\n-}\n+    case Op_ClearArray:\n+    case Op_VectorMaskGen:\n+    case Op_VectorCmpMasked:\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      if ((size_in_bits != 512) && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n+    case Op_LoadVectorMasked:\n+    case Op_StoreVectorMasked:\n+      if (!VM_Version::supports_avx512bw() && (is_subword_type(bt) || UseAVX < 1)) {\n+        return false;\n+      }\n+      break;\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+      if (UseAVX == 0) {\n+        return false;\n+      }\n+      break;\n+    case Op_MaxV:\n+    case Op_MinV:\n+      if (UseSSE < 4 && is_integral_type(bt)) {\n+        return false;\n+      }\n+      if ((bt == T_FLOAT || bt == T_DOUBLE)) {\n+          \/\/ Float\/Double intrinsics are enabled for AVX family currently.\n+          if (UseAVX == 0) {\n+            return false;\n+          }\n+          if (UseAVX > 2 && (!VM_Version::supports_avx512dq() && size_in_bits == 512)) { \/\/ 512 bit Float\/Double intrinsics need AVX512DQ\n+            return false;\n+          }\n+      }\n+      break;\n+    case Op_CallLeafVector:\n+      if (size_in_bits == 512 && !VM_Version::supports_avx512vlbwdq()) {\n+        return false;\n+      }\n+      break;\n+    case Op_AddReductionVI:\n+      if (bt == T_INT && (UseSSE < 3 || !VM_Version::supports_ssse3())) {\n+        return false;\n+      }\n+      \/\/ fallthrough\n+    case Op_AndReductionV:\n+    case Op_OrReductionV:\n+    case Op_XorReductionV:\n+      if (is_subword_type(bt) && (UseSSE < 4)) {\n+        return false;\n+      }\n+      break;\n+    case Op_MinReductionV:\n+    case Op_MaxReductionV:\n+      if ((bt == T_INT || is_subword_type(bt)) && UseSSE < 4) {\n+        return false;\n+      } else if (bt == T_LONG && (UseAVX < 3 || !VM_Version::supports_avx512vlbwdq())) {\n+        return false;\n+      }\n+      \/\/ Float\/Double intrinsics enabled for AVX family.\n+      if (UseAVX == 0 && (bt == T_FLOAT || bt == T_DOUBLE)) {\n+        return false;\n+      }\n+      if (UseAVX > 2 && (!VM_Version::supports_avx512dq() && size_in_bits == 512)) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorTest:\n+      if (UseSSE < 4) {\n+        return false; \/\/ Implementation limitation\n+      } else if (size_in_bits < 32) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      break;\n+    case Op_VectorLoadShuffle:\n+    case Op_VectorRearrange:\n+      if(vlen == 2) {\n+        return false; \/\/ Implementation limitation due to how shuffle is loaded\n+      } else if (size_in_bits == 256 && UseAVX < 2) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      break;\n+    case Op_VectorLoadMask:\n+    case Op_VectorMaskCast:\n+      if (size_in_bits == 256 && UseAVX < 2) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      \/\/ fallthrough\n+    case Op_VectorStoreMask:\n+      if (vlen == 2) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      break;\n+    case Op_PopulateIndex:\n+      if (size_in_bits > 256 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastB2X:\n+    case Op_VectorCastS2X:\n+    case Op_VectorCastI2X:\n+      if (bt != T_DOUBLE && size_in_bits == 256 && UseAVX < 2) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastL2X:\n+      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n+        return false;\n+      } else if (!is_integral_type(bt) && !VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastF2X: {\n+        \/\/ As per JLS section 5.1.3 narrowing conversion to sub-word types\n+        \/\/ happen after intermediate conversion to integer and special handling\n+        \/\/ code needs AVX2 vpcmpeqd instruction for 256 bit vectors.\n+        int src_size_in_bits = type2aelembytes(T_FLOAT) * vlen * BitsPerByte;\n+        if (is_integral_type(bt) && src_size_in_bits == 256 && UseAVX < 2) {\n+          return false;\n+        }\n+      }\n+      \/\/ fallthrough\n+    case Op_VectorCastD2X:\n+      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastF2HF:\n+    case Op_VectorCastHF2F:\n+      if (!VM_Version::supports_f16c() &&\n+         ((!VM_Version::supports_evex() ||\n+         ((size_in_bits != 512) && !VM_Version::supports_avx512vl())))) {\n+        return false;\n+      }\n+      break;\n+    case Op_RoundVD:\n+      if (!VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n+      break;\n+    case Op_MulReductionVI:\n+      if (bt == T_BYTE && size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n+    case Op_LoadVectorGatherMasked:\n+      if (!is_subword_type(bt) && size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      if (is_subword_type(bt) &&\n+         ((size_in_bits > 256 && !VM_Version::supports_avx512bw()) ||\n+          (size_in_bits < 64)                                      ||\n+          (bt == T_SHORT && !VM_Version::supports_bmi2()))) {\n+        return false;\n+      }\n+      break;\n+    case Op_StoreVectorScatterMasked:\n+    case Op_StoreVectorScatter:\n+      if (is_subword_type(bt)) {\n+        return false;\n+      } else if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      \/\/ fallthrough\n+    case Op_LoadVectorGather:\n+      if (!is_subword_type(bt) && size_in_bits == 64) {\n+        return false;\n+      }\n+      if (is_subword_type(bt) && size_in_bits < 64) {\n+        return false;\n+      }\n+      break;\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (UseAVX < 1) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      if (is_subword_type(bt) && size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n+    case Op_SelectFromTwoVector:\n+       if (size_in_bits < 128) {\n+         return false;\n+       }\n+       if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+         return false;\n+       }\n+       if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n+         return false;\n+       }\n+       if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n+         return false;\n+       }\n+       if ((bt == T_INT || bt == T_FLOAT || bt == T_DOUBLE) && !VM_Version::supports_evex()) {\n+         return false;\n+       }\n+       break;\n+    case Op_MaskAll:\n+      if (!VM_Version::supports_evex()) {\n+        return false;\n+      }\n+      if ((vlen > 16 || is_subword_type(bt)) && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorMaskCmp:\n+      if (vlen < 2 || size_in_bits < 32) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressM:\n+      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+      if (is_subword_type(bt) && !VM_Version::supports_avx512_vbmi2()) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 ) {\n+        return false;\n+      }\n+    case Op_VectorLongToMask:\n+      if (UseAVX < 1) {\n+        return false;\n+      }\n+      if (UseAVX < 3 && !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_SignumVD:\n+    case Op_SignumVF:\n+      if (UseAVX < 1) {\n+        return false;\n+      }\n+      break;\n+    case Op_PopCountVI:\n+    case Op_PopCountVL: {\n+        if (!is_pop_count_instr_target(bt) &&\n+            (size_in_bits == 512) && !VM_Version::supports_avx512bw()) {\n+          return false;\n+        }\n+      }\n+      break;\n+    case Op_ReverseV:\n+    case Op_ReverseBytesV:\n+      if (UseAVX < 2) {\n+        return false;\n+      }\n+      break;\n+    case Op_CountTrailingZerosV:\n+    case Op_CountLeadingZerosV:\n+      if (UseAVX < 2) {\n+        return false;\n+      }\n+      break;\n+  }\n+  return true;  \/\/ Per default match rules are supported.\n+}\n+\n+bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+  \/\/ ADLC based match_rule_supported routine checks for the existence of pattern based\n+  \/\/ on IR opcode. Most of the unary\/binary\/ternary masked operation share the IR nodes\n+  \/\/ of their non-masked counterpart with mask edge being the differentiator.\n+  \/\/ This routine does a strict check on the existence of masked operation patterns\n+  \/\/ by returning a default false value for all the other opcodes apart from the\n+  \/\/ ones whose masked instruction patterns are defined in this file.\n+  if (!match_rule_supported_vector(opcode, vlen, bt)) {\n+    return false;\n+  }\n+\n+  int size_in_bits = vlen * type2aelembytes(bt) * BitsPerByte;\n+  if (size_in_bits != 512 && !VM_Version::supports_avx512vl()) {\n+    return false;\n+  }\n+  switch(opcode) {\n+    \/\/ Unary masked operations\n+    case Op_AbsVB:\n+    case Op_AbsVS:\n+      if(!VM_Version::supports_avx512bw()) {\n+        return false;  \/\/ Implementation limitation\n+      }\n+    case Op_AbsVI:\n+    case Op_AbsVL:\n+      return true;\n+\n+    \/\/ Ternary masked operations\n+    case Op_FmaVF:\n+    case Op_FmaVD:\n+      return true;\n+\n+    case Op_MacroLogicV:\n+      if(bt != T_INT && bt != T_LONG) {\n+        return false;\n+      }\n+      return true;\n+\n+    \/\/ Binary masked operations\n+    case Op_AddVB:\n+    case Op_AddVS:\n+    case Op_SubVB:\n+    case Op_SubVS:\n+    case Op_MulVS:\n+    case Op_LShiftVS:\n+    case Op_RShiftVS:\n+    case Op_URShiftVS:\n+      assert(size_in_bits == 512 || VM_Version::supports_avx512vl(), \"\");\n+      if (!VM_Version::supports_avx512bw()) {\n+        return false;  \/\/ Implementation limitation\n+      }\n+      return true;\n+\n+    case Op_MulVL:\n+      assert(size_in_bits == 512 || VM_Version::supports_avx512vl(), \"\");\n+      if (!VM_Version::supports_avx512dq()) {\n+        return false;  \/\/ Implementation limitation\n+      }\n+      return true;\n+\n+    case Op_AndV:\n+    case Op_OrV:\n+    case Op_XorV:\n+    case Op_RotateRightV:\n+    case Op_RotateLeftV:\n+      if (bt != T_INT && bt != T_LONG) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n+\n+    case Op_VectorLoadMask:\n+      assert(size_in_bits == 512 || VM_Version::supports_avx512vl(), \"\");\n+      if (is_subword_type(bt) && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      return true;\n+\n+    case Op_AddVI:\n+    case Op_AddVL:\n+    case Op_AddVF:\n+    case Op_AddVD:\n+    case Op_SubVI:\n+    case Op_SubVL:\n+    case Op_SubVF:\n+    case Op_SubVD:\n+    case Op_MulVI:\n+    case Op_MulVF:\n+    case Op_MulVD:\n+    case Op_DivVF:\n+    case Op_DivVD:\n+    case Op_SqrtVF:\n+    case Op_SqrtVD:\n+    case Op_LShiftVI:\n+    case Op_LShiftVL:\n+    case Op_RShiftVI:\n+    case Op_RShiftVL:\n+    case Op_URShiftVI:\n+    case Op_URShiftVL:\n+    case Op_LoadVectorMasked:\n+    case Op_StoreVectorMasked:\n+    case Op_LoadVectorGatherMasked:\n+    case Op_StoreVectorScatterMasked:\n+      return true;\n+\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      } \/\/ fallthrough\n+    case Op_MaxV:\n+    case Op_MinV:\n+      if (is_subword_type(bt) && !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      if (is_floating_point_type(bt) && !VM_Version::supports_avx10_2()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (!is_subword_type(bt)) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 || !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n+\n+    case Op_VectorMaskCmp:\n+      if (is_subword_type(bt) && !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n+\n+    case Op_VectorRearrange:\n+      if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n+        return false; \/\/ Implementation limitation\n+      } else if ((bt == T_INT || bt == T_FLOAT) && size_in_bits < 256) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n+\n+    \/\/ Binary Logical operations\n+    case Op_AndVMask:\n+    case Op_OrVMask:\n+    case Op_XorVMask:\n+      if (vlen > 16 && !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n+\n+    case Op_PopCountVI:\n+    case Op_PopCountVL:\n+      if (!is_pop_count_instr_target(bt)) {\n+        return false;\n+      }\n+      return true;\n+\n+    case Op_MaskAll:\n+      return true;\n+\n+    case Op_CountLeadingZerosV:\n+      if (is_non_subword_integral_type(bt) && VM_Version::supports_avx512cd()) {\n+        return true;\n+      }\n+    default:\n+      return false;\n+  }\n+}\n+\n+bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+  return false;\n+}\n+\n+\/\/ Return true if Vector::rearrange needs preparation of the shuffle argument\n+bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n+  switch (elem_bt) {\n+    case T_BYTE:  return false;\n+    case T_SHORT: return !VM_Version::supports_avx512bw();\n+    case T_INT:   return !VM_Version::supports_avx();\n+    case T_LONG:  return vlen < 8 && !VM_Version::supports_avx512vl();\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n+MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {\n+  assert(Matcher::is_generic_vector(generic_opnd), \"not generic\");\n+  bool legacy = (generic_opnd->opcode() == LEGVEC);\n+  if (!VM_Version::supports_avx512vlbwdq() && \/\/ KNL\n+      is_temp && !legacy && (ideal_reg == Op_VecZ)) {\n+    \/\/ Conservatively specialize 512bit vec TEMP operands to legVecZ (zmm0-15) on KNL.\n+    return new legVecZOper();\n+  }\n+  if (legacy) {\n+    switch (ideal_reg) {\n+      case Op_VecS: return new legVecSOper();\n+      case Op_VecD: return new legVecDOper();\n+      case Op_VecX: return new legVecXOper();\n+      case Op_VecY: return new legVecYOper();\n+      case Op_VecZ: return new legVecZOper();\n+    }\n+  } else {\n+    switch (ideal_reg) {\n+      case Op_VecS: return new vecSOper();\n+      case Op_VecD: return new vecDOper();\n+      case Op_VecX: return new vecXOper();\n+      case Op_VecY: return new vecYOper();\n+      case Op_VecZ: return new vecZOper();\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n+  switch (m->rule()) {\n+    case MoveVec2Leg_rule:\n+    case MoveLeg2Vec_rule:\n+    case MoveF2VL_rule:\n+    case MoveF2LEG_rule:\n+    case MoveVL2F_rule:\n+    case MoveLEG2F_rule:\n+    case MoveD2VL_rule:\n+    case MoveD2LEG_rule:\n+    case MoveVL2D_rule:\n+    case MoveLEG2D_rule:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+bool Matcher::is_generic_vector(MachOper* opnd) {\n+  switch (opnd->opcode()) {\n+    case VEC:\n+    case LEGVEC:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/\/------------------------------------------------------------------------\n+\n+const RegMask* Matcher::predicate_reg_mask(void) {\n+  return &_VECTMASK_REG_mask;\n+}\n+\n+\/\/ Max vector size in bytes. 0 if not supported.\n+int Matcher::vector_width_in_bytes(BasicType bt) {\n+  assert(is_java_primitive(bt), \"only primitive type vectors\");\n+  \/\/ SSE2 supports 128bit vectors for all types.\n+  \/\/ AVX2 supports 256bit vectors for all types.\n+  \/\/ AVX2\/EVEX supports 512bit vectors for all types.\n+  int size = (UseAVX > 1) ? (1 << UseAVX) * 8 : 16;\n+  \/\/ AVX1 supports 256bit vectors only for FLOAT and DOUBLE.\n+  if (UseAVX > 0 && (bt == T_FLOAT || bt == T_DOUBLE))\n+    size = (UseAVX > 2) ? 64 : 32;\n+  if (UseAVX > 2 && (bt == T_BYTE || bt == T_SHORT || bt == T_CHAR))\n+    size = (VM_Version::supports_avx512bw()) ? 64 : 32;\n+  \/\/ Use flag to limit vector size.\n+  size = MIN2(size,(int)MaxVectorSize);\n+  \/\/ Minimum 2 values in vector (or 4 for bytes).\n+  switch (bt) {\n+  case T_DOUBLE:\n+  case T_LONG:\n+    if (size < 16) return 0;\n+    break;\n+  case T_FLOAT:\n+  case T_INT:\n+    if (size < 8) return 0;\n+    break;\n+  case T_BOOLEAN:\n+    if (size < 4) return 0;\n+    break;\n+  case T_CHAR:\n+    if (size < 4) return 0;\n+    break;\n+  case T_BYTE:\n+    if (size < 4) return 0;\n+    break;\n+  case T_SHORT:\n+    if (size < 4) return 0;\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+  return size;\n+}\n+\n+\/\/ Limits on vector size (number of elements) loaded into vector.\n+int Matcher::max_vector_size(const BasicType bt) {\n+  return vector_width_in_bytes(bt)\/type2aelembytes(bt);\n+}\n+int Matcher::min_vector_size(const BasicType bt) {\n+  int max_size = max_vector_size(bt);\n+  \/\/ Min size which can be loaded into vector is 4 bytes.\n+  int size = (type2aelembytes(bt) == 1) ? 4 : 2;\n+  \/\/ Support for calling svml double64 vectors\n+  if (bt == T_DOUBLE) {\n+    size = 1;\n+  }\n+  return MIN2(size,max_size);\n+}\n+\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n+  \/\/ Limit the max vector size for auto vectorization to 256 bits (32 bytes)\n+  \/\/ by default on Cascade Lake\n+  if (VM_Version::is_default_intel_cascade_lake()) {\n+    return MIN2(Matcher::max_vector_size(bt), 32 \/ type2aelembytes(bt));\n+  }\n+  return Matcher::max_vector_size(bt);\n+}\n+\n+int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n+\/\/ Vector ideal reg corresponding to specified size in bytes\n+uint Matcher::vector_ideal_reg(int size) {\n+  assert(MaxVectorSize >= size, \"\");\n+  switch(size) {\n+    case  4: return Op_VecS;\n+    case  8: return Op_VecD;\n+    case 16: return Op_VecX;\n+    case 32: return Op_VecY;\n+    case 64: return Op_VecZ;\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n+\/\/ Check for shift by small constant as well\n+static bool clone_shift(Node* shift, Matcher* matcher, Matcher::MStack& mstack, VectorSet& address_visited) {\n+  if (shift->Opcode() == Op_LShiftX && shift->in(2)->is_Con() &&\n+      shift->in(2)->get_int() <= 3 &&\n+      \/\/ Are there other uses besides address expressions?\n+      !matcher->is_visited(shift)) {\n+    address_visited.set(shift->_idx); \/\/ Flag as address_visited\n+    mstack.push(shift->in(2), Matcher::Visit);\n+    Node *conv = shift->in(1);\n+    \/\/ Allow Matcher to match the rule which bypass\n+    \/\/ ConvI2L operation for an array index on LP64\n+    \/\/ if the index value is positive.\n+    if (conv->Opcode() == Op_ConvI2L &&\n+        conv->as_Type()->type()->is_long()->_lo >= 0 &&\n+        \/\/ Are there other uses besides address expressions?\n+        !matcher->is_visited(conv)) {\n+      address_visited.set(conv->_idx); \/\/ Flag as address_visited\n+      mstack.push(conv->in(1), Matcher::Pre_Visit);\n+    } else {\n+      mstack.push(conv, Matcher::Pre_Visit);\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ This function identifies sub-graphs in which a 'load' node is\n+\/\/ input to two different nodes, and such that it can be matched\n+\/\/ with BMI instructions like blsi, blsr, etc.\n+\/\/ Example : for b = -a[i] & a[i] can be matched to blsi r32, m32.\n+\/\/ The graph is (AndL (SubL Con0 LoadL*) LoadL*), where LoadL*\n+\/\/ refers to the same node.\n+\/\/\n+\/\/ Match the generic fused operations pattern (op1 (op2 Con{ConType} mop) mop)\n+\/\/ This is a temporary solution until we make DAGs expressible in ADL.\n+template<typename ConType>\n+class FusedPatternMatcher {\n+  Node* _op1_node;\n+  Node* _mop_node;\n+  int _con_op;\n+\n+  static int match_next(Node* n, int next_op, int next_op_idx) {\n+    if (n->in(1) == nullptr || n->in(2) == nullptr) {\n+      return -1;\n+    }\n+\n+    if (next_op_idx == -1) { \/\/ n is commutative, try rotations\n+      if (n->in(1)->Opcode() == next_op) {\n+        return 1;\n+      } else if (n->in(2)->Opcode() == next_op) {\n+        return 2;\n+      }\n+    } else {\n+      assert(next_op_idx > 0 && next_op_idx <= 2, \"Bad argument index\");\n+      if (n->in(next_op_idx)->Opcode() == next_op) {\n+        return next_op_idx;\n+      }\n+    }\n+    return -1;\n+  }\n+\n+ public:\n+  FusedPatternMatcher(Node* op1_node, Node* mop_node, int con_op) :\n+    _op1_node(op1_node), _mop_node(mop_node), _con_op(con_op) { }\n+\n+  bool match(int op1, int op1_op2_idx,  \/\/ op1 and the index of the op1->op2 edge, -1 if op1 is commutative\n+             int op2, int op2_con_idx,  \/\/ op2 and the index of the op2->con edge, -1 if op2 is commutative\n+             typename ConType::NativeType con_value) {\n+    if (_op1_node->Opcode() != op1) {\n+      return false;\n+    }\n+    if (_mop_node->outcnt() > 2) {\n+      return false;\n+    }\n+    op1_op2_idx = match_next(_op1_node, op2, op1_op2_idx);\n+    if (op1_op2_idx == -1) {\n+      return false;\n+    }\n+    \/\/ Memory operation must be the other edge\n+    int op1_mop_idx = (op1_op2_idx & 1) + 1;\n+\n+    \/\/ Check that the mop node is really what we want\n+    if (_op1_node->in(op1_mop_idx) == _mop_node) {\n+      Node* op2_node = _op1_node->in(op1_op2_idx);\n+      if (op2_node->outcnt() > 1) {\n+        return false;\n+      }\n+      assert(op2_node->Opcode() == op2, \"Should be\");\n+      op2_con_idx = match_next(op2_node, _con_op, op2_con_idx);\n+      if (op2_con_idx == -1) {\n+        return false;\n+      }\n+      \/\/ Memory operation must be the other edge\n+      int op2_mop_idx = (op2_con_idx & 1) + 1;\n+      \/\/ Check that the memory operation is the same node\n+      if (op2_node->in(op2_mop_idx) == _mop_node) {\n+        \/\/ Now check the constant\n+        const Type* con_type = op2_node->in(op2_con_idx)->bottom_type();\n+        if (con_type != Type::TOP && ConType::as_self(con_type)->get_con() == con_value) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+};\n+\n+static bool is_bmi_pattern(Node* n, Node* m) {\n+  assert(UseBMI1Instructions, \"sanity\");\n+  if (n != nullptr && m != nullptr) {\n+    if (m->Opcode() == Op_LoadI) {\n+      FusedPatternMatcher<TypeInt> bmii(n, m, Op_ConI);\n+      return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||\n+             bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||\n+             bmii.match(Op_XorI, -1, Op_AddI, -1, -1);\n+    } else if (m->Opcode() == Op_LoadL) {\n+      FusedPatternMatcher<TypeLong> bmil(n, m, Op_ConL);\n+      return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||\n+             bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||\n+             bmil.match(Op_XorL, -1, Op_AddL, -1, -1);\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Should the matcher clone input 'm' of node 'n'?\n+bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack& mstack) {\n+  \/\/ If 'n' and 'm' are part of a graph for BMI instruction, clone the input 'm'.\n+  if (UseBMI1Instructions && is_bmi_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n+  if (is_vshift_con_pattern(n, m)) { \/\/ ShiftV src (ShiftCntV con)\n+    mstack.push(m, Visit);           \/\/ m = ShiftCntV\n+    return true;\n+  }\n+  if (is_encode_and_store_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ Should the Matcher clone shifts on addressing modes, expecting them\n+\/\/ to be subsumed into complex addressing expressions or compute them\n+\/\/ into registers?\n+bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack& mstack, VectorSet& address_visited) {\n+  Node *off = m->in(AddPNode::Offset);\n+  if (off->is_Con()) {\n+    address_visited.test_set(m->_idx); \/\/ Flag as address_visited\n+    Node *adr = m->in(AddPNode::Address);\n+\n+    \/\/ Intel can handle 2 adds in addressing mode, with one of them using an immediate offset.\n+    \/\/ AtomicAdd is not an addressing expression.\n+    \/\/ Cheap to find it by looking for screwy base.\n+    if (adr->is_AddP() &&\n+        !adr->in(AddPNode::Base)->is_top() &&\n+        !adr->in(AddPNode::Offset)->is_Con() &&\n+        off->get_long() == (int) (off->get_long()) && \/\/ immL32\n+        \/\/ Are there other uses besides address expressions?\n+        !is_visited(adr)) {\n+      address_visited.set(adr->_idx); \/\/ Flag as address_visited\n+      Node *shift = adr->in(AddPNode::Offset);\n+      if (!clone_shift(shift, this, mstack, address_visited)) {\n+        mstack.push(shift, Pre_Visit);\n+      }\n+      mstack.push(adr->in(AddPNode::Address), Pre_Visit);\n+      mstack.push(adr->in(AddPNode::Base), Pre_Visit);\n+    } else {\n+      mstack.push(adr, Pre_Visit);\n+    }\n+\n+    \/\/ Clone X+offset as it also folds into most addressing expressions\n+    mstack.push(off, Visit);\n+    mstack.push(m->in(AddPNode::Base), Pre_Visit);\n+    return true;\n+  } else if (clone_shift(off, this, mstack, address_visited)) {\n+    address_visited.test_set(m->_idx); \/\/ Flag as address_visited\n+    mstack.push(m->in(AddPNode::Address), Pre_Visit);\n+    mstack.push(m->in(AddPNode::Base), Pre_Visit);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static inline Assembler::ComparisonPredicate booltest_pred_to_comparison_pred(int bt) {\n+  switch (bt) {\n+    case BoolTest::eq:\n+      return Assembler::eq;\n+    case BoolTest::ne:\n+      return Assembler::neq;\n+    case BoolTest::le:\n+    case BoolTest::ule:\n+      return Assembler::le;\n+    case BoolTest::ge:\n+    case BoolTest::uge:\n+      return Assembler::nlt;\n+    case BoolTest::lt:\n+    case BoolTest::ult:\n+      return Assembler::lt;\n+    case BoolTest::gt:\n+    case BoolTest::ugt:\n+      return Assembler::nle;\n+    default : ShouldNotReachHere(); return Assembler::_false;\n+  }\n+}\n+\n+static inline Assembler::ComparisonPredicateFP booltest_pred_to_comparison_pred_fp(int bt) {\n+  switch (bt) {\n+  case BoolTest::eq: return Assembler::EQ_OQ;  \/\/ ordered non-signaling\n+  \/\/ As per JLS 15.21.1, != of NaNs is true. Thus use unordered compare.\n+  case BoolTest::ne: return Assembler::NEQ_UQ; \/\/ unordered non-signaling\n+  case BoolTest::le: return Assembler::LE_OQ;  \/\/ ordered non-signaling\n+  case BoolTest::ge: return Assembler::GE_OQ;  \/\/ ordered non-signaling\n+  case BoolTest::lt: return Assembler::LT_OQ;  \/\/ ordered non-signaling\n+  case BoolTest::gt: return Assembler::GT_OQ;  \/\/ ordered non-signaling\n+  default: ShouldNotReachHere(); return Assembler::FALSE_OS;\n+  }\n+}\n+\n+\/\/ Helper methods for MachSpillCopyNode::implementation().\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n+                          int src_hi, int dst_hi, uint ireg, outputStream* st) {\n+  assert(ireg == Op_VecS || \/\/ 32bit vector\n+         ((src_lo & 1) == 0 && (src_lo + 1) == src_hi &&\n+          (dst_lo & 1) == 0 && (dst_lo + 1) == dst_hi),\n+         \"no non-adjacent vector moves\" );\n+  if (masm) {\n+    switch (ireg) {\n+    case Op_VecS: \/\/ copy whole register\n+    case Op_VecD:\n+    case Op_VecX:\n+      if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n+        __ movdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));\n+      } else {\n+        __ vextractf32x4(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]), 0x0);\n+     }\n+      break;\n+    case Op_VecY:\n+      if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n+        __ vmovdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));\n+      } else {\n+        __ vextractf64x4(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]), 0x0);\n+     }\n+      break;\n+    case Op_VecZ:\n+      __ evmovdquq(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]), 2);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+#ifndef PRODUCT\n+  } else {\n+    switch (ireg) {\n+    case Op_VecS:\n+    case Op_VecD:\n+    case Op_VecX:\n+      st->print(\"movdqu  %s,%s\\t# spill\",Matcher::regName[dst_lo],Matcher::regName[src_lo]);\n+      break;\n+    case Op_VecY:\n+    case Op_VecZ:\n+      st->print(\"vmovdqu %s,%s\\t# spill\",Matcher::regName[dst_lo],Matcher::regName[src_lo]);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+#endif\n+  }\n+}\n+\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n+                     int stack_offset, int reg, uint ireg, outputStream* st) {\n+  if (masm) {\n+    if (is_load) {\n+      switch (ireg) {\n+      case Op_VecS:\n+        __ movdl(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n+        break;\n+      case Op_VecD:\n+        __ movq(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n+        break;\n+      case Op_VecX:\n+        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n+          __ movdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n+        } else {\n+          __ vpxor(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), 2);\n+          __ vinsertf32x4(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset),0x0);\n+        }\n+        break;\n+      case Op_VecY:\n+        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n+          __ vmovdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n+        } else {\n+          __ vpxor(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), 2);\n+          __ vinsertf64x4(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset),0x0);\n+        }\n+        break;\n+      case Op_VecZ:\n+        __ evmovdquq(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset), 2);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      }\n+    } else { \/\/ store\n+      switch (ireg) {\n+      case Op_VecS:\n+        __ movdl(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n+        break;\n+      case Op_VecD:\n+        __ movq(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n+        break;\n+      case Op_VecX:\n+        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n+          __ movdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n+        }\n+        else {\n+          __ vextractf32x4(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]), 0x0);\n+        }\n+        break;\n+      case Op_VecY:\n+        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n+          __ vmovdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n+        }\n+        else {\n+          __ vextractf64x4(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]), 0x0);\n+        }\n+        break;\n+      case Op_VecZ:\n+        __ evmovdquq(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]), 2);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      }\n+    }\n+#ifndef PRODUCT\n+  } else {\n+    if (is_load) {\n+      switch (ireg) {\n+      case Op_VecS:\n+        st->print(\"movd    %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n+        break;\n+      case Op_VecD:\n+        st->print(\"movq    %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n+        break;\n+       case Op_VecX:\n+        st->print(\"movdqu  %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n+        break;\n+      case Op_VecY:\n+      case Op_VecZ:\n+        st->print(\"vmovdqu %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      }\n+    } else { \/\/ store\n+      switch (ireg) {\n+      case Op_VecS:\n+        st->print(\"movd    [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n+        break;\n+      case Op_VecD:\n+        st->print(\"movq    [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n+        break;\n+       case Op_VecX:\n+        st->print(\"movdqu  [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n+        break;\n+      case Op_VecY:\n+      case Op_VecZ:\n+        st->print(\"vmovdqu [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      }\n+    }\n+#endif\n+  }\n+}\n+\n+template <class T>\n+static inline GrowableArray<jbyte>* vreplicate_imm(BasicType bt, T con, int len) {\n+  int size = type2aelembytes(bt) * len;\n+  GrowableArray<jbyte>* val = new GrowableArray<jbyte>(size, size, 0);\n+  for (int i = 0; i < len; i++) {\n+    int offset = i * type2aelembytes(bt);\n+    switch (bt) {\n+      case T_BYTE: val->at(i) = con; break;\n+      case T_SHORT: {\n+        jshort c = con;\n+        memcpy(val->adr_at(offset), &c, sizeof(jshort));\n+        break;\n+      }\n+      case T_INT: {\n+        jint c = con;\n+        memcpy(val->adr_at(offset), &c, sizeof(jint));\n+        break;\n+      }\n+      case T_LONG: {\n+        jlong c = con;\n+        memcpy(val->adr_at(offset), &c, sizeof(jlong));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        jfloat c = con;\n+        memcpy(val->adr_at(offset), &c, sizeof(jfloat));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        jdouble c = con;\n+        memcpy(val->adr_at(offset), &c, sizeof(jdouble));\n+        break;\n+      }\n+      default: assert(false, \"%s\", type2name(bt));\n+    }\n+  }\n+  return val;\n+}\n+\n+static inline jlong high_bit_set(BasicType bt) {\n+  switch (bt) {\n+    case T_BYTE:  return 0x8080808080808080;\n+    case T_SHORT: return 0x8000800080008000;\n+    case T_INT:   return 0x8000000080000000;\n+    case T_LONG:  return 0x8000000000000000;\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+#ifndef PRODUCT\n+  void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const {\n+    st->print(\"nop \\t# %d bytes pad for loops and calls\", _count);\n+  }\n+#endif\n+\n+  void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc*) const {\n+    __ nop(_count);\n+  }\n+\n+  uint MachNopNode::size(PhaseRegAlloc*) const {\n+    return _count;\n+  }\n+\n+#ifndef PRODUCT\n+  void MachBreakpointNode::format(PhaseRegAlloc*, outputStream* st) const {\n+    st->print(\"# breakpoint\");\n+  }\n+#endif\n+\n+  void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const {\n+    __ int3();\n+  }\n+\n+  uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {\n+    return MachNode::size(ra_);\n+  }\n+\n+%}\n+\n+\/\/----------ENCODING BLOCK-----------------------------------------------------\n+\/\/ This block specifies the encoding classes used by the compiler to\n+\/\/ output byte streams.  Encoding classes are parameterized macros\n+\/\/ used by Machine Instruction Nodes in order to generate the bit\n+\/\/ encoding of the instruction.  Operands specify their base encoding\n+\/\/ interface with the interface keyword.  There are currently\n+\/\/ supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &\n+\/\/ COND_INTER.  REG_INTER causes an operand to generate a function\n+\/\/ which returns its register number when queried.  CONST_INTER causes\n+\/\/ an operand to generate a function which returns the value of the\n+\/\/ constant when queried.  MEMORY_INTER causes an operand to generate\n+\/\/ four functions which return the Base Register, the Index Register,\n+\/\/ the Scale Value, and the Offset Value of the operand when queried.\n+\/\/ COND_INTER causes an operand to generate six functions which return\n+\/\/ the encoding code (ie - encoding bits for the instruction)\n+\/\/ associated with each basic boolean condition for a conditional\n+\/\/ instruction.\n+\/\/\n+\/\/ Instructions specify two basic values for encoding.  Again, a\n+\/\/ function is available to check if the constant displacement is an\n+\/\/ oop. They use the ins_encode keyword to specify their encoding\n+\/\/ classes (which must be a sequence of enc_class names, and their\n+\/\/ parameters, specified in the encoding block), and they use the\n+\/\/ opcode keyword to specify, in order, their primary, secondary, and\n+\/\/ tertiary opcode.  Only the opcode sections which a particular\n+\/\/ instruction needs for encoding need to be specified.\n+encode %{\n+  enc_class cdql_enc(no_rax_rdx_RegI div)\n+  %{\n+    \/\/ Full implementation of Java idiv and irem; checks for\n+    \/\/ special case as described in JVM spec., p.243 & p.271.\n+    \/\/\n+    \/\/         normal case                           special case\n+    \/\/\n+    \/\/ input : rax: dividend                         min_int\n+    \/\/         reg: divisor                          -1\n+    \/\/\n+    \/\/ output: rax: quotient  (= rax idiv reg)       min_int\n+    \/\/         rdx: remainder (= rax irem reg)       0\n+    \/\/\n+    \/\/  Code sequnce:\n+    \/\/\n+    \/\/    0:   3d 00 00 00 80          cmp    $0x80000000,%eax\n+    \/\/    5:   75 07\/08                jne    e <normal>\n+    \/\/    7:   33 d2                   xor    %edx,%edx\n+    \/\/  [div >= 8 -> offset + 1]\n+    \/\/  [REX_B]\n+    \/\/    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div\n+    \/\/    c:   74 03\/04                je     11 <done>\n+    \/\/ 000000000000000e <normal>:\n+    \/\/    e:   99                      cltd\n+    \/\/  [div >= 8 -> offset + 1]\n+    \/\/  [REX_B]\n+    \/\/    f:   f7 f9                   idiv   $div\n+    \/\/ 0000000000000011 <done>:\n+    Label normal;\n+    Label done;\n+\n+    \/\/ cmp    $0x80000000,%eax\n+    __ cmpl(as_Register(RAX_enc), 0x80000000);\n+\n+    \/\/ jne    e <normal>\n+    __ jccb(Assembler::notEqual, normal);\n+\n+    \/\/ xor    %edx,%edx\n+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n+\n+    \/\/ cmp    $0xffffffffffffffff,%ecx\n+    __ cmpl($div$$Register, -1);\n+\n+    \/\/ je     11 <done>\n+    __ jccb(Assembler::equal, done);\n+\n+    \/\/ <normal>\n+    \/\/ cltd\n+    __ bind(normal);\n+    __ cdql();\n+\n+    \/\/ idivl\n+    \/\/ <done>\n+    __ idivl($div$$Register);\n+    __ bind(done);\n+  %}\n+\n+  enc_class cdqq_enc(no_rax_rdx_RegL div)\n+  %{\n+    \/\/ Full implementation of Java ldiv and lrem; checks for\n+    \/\/ special case as described in JVM spec., p.243 & p.271.\n+    \/\/\n+    \/\/         normal case                           special case\n+    \/\/\n+    \/\/ input : rax: dividend                         min_long\n+    \/\/         reg: divisor                          -1\n+    \/\/\n+    \/\/ output: rax: quotient  (= rax idiv reg)       min_long\n+    \/\/         rdx: remainder (= rax irem reg)       0\n+    \/\/\n+    \/\/  Code sequnce:\n+    \/\/\n+    \/\/    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx\n+    \/\/    7:   00 00 80\n+    \/\/    a:   48 39 d0                cmp    %rdx,%rax\n+    \/\/    d:   75 08                   jne    17 <normal>\n+    \/\/    f:   33 d2                   xor    %edx,%edx\n+    \/\/   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div\n+    \/\/   15:   74 05                   je     1c <done>\n+    \/\/ 0000000000000017 <normal>:\n+    \/\/   17:   48 99                   cqto\n+    \/\/   19:   48 f7 f9                idiv   $div\n+    \/\/ 000000000000001c <done>:\n+    Label normal;\n+    Label done;\n+\n+    \/\/ mov    $0x8000000000000000,%rdx\n+    __ mov64(as_Register(RDX_enc), 0x8000000000000000);\n+\n+    \/\/ cmp    %rdx,%rax\n+    __ cmpq(as_Register(RAX_enc), as_Register(RDX_enc));\n+\n+    \/\/ jne    17 <normal>\n+    __ jccb(Assembler::notEqual, normal);\n+\n+    \/\/ xor    %edx,%edx\n+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n+\n+    \/\/ cmp    $0xffffffffffffffff,$div\n+    __ cmpq($div$$Register, -1);\n+\n+    \/\/ je     1e <done>\n+    __ jccb(Assembler::equal, done);\n+\n+    \/\/ <normal>\n+    \/\/ cqto\n+    __ bind(normal);\n+    __ cdqq();\n+\n+    \/\/ idivq (note: must be emitted by the user of this rule)\n+    \/\/ <done>\n+    __ idivq($div$$Register);\n+    __ bind(done);\n+  %}\n+\n+  enc_class clear_avx %{\n+    DEBUG_ONLY(int off0 = __ offset());\n+    if (generate_vzeroupper(Compile::current())) {\n+      \/\/ Clear upper bits of YMM registers to avoid AVX <-> SSE transition penalty\n+      \/\/ Clear upper bits of YMM registers when current compiled code uses\n+      \/\/ wide vectors to avoid AVX <-> SSE transition penalty during call.\n+      __ vzeroupper();\n+    }\n+    DEBUG_ONLY(int off1 = __ offset());\n+    assert(off1 - off0 == clear_avx_size(), \"correct size prediction\");\n+  %}\n+\n+  enc_class Java_To_Runtime(method meth) %{\n+    __ lea(r10, RuntimeAddress((address)$meth$$method));\n+    __ call(r10);\n+    __ post_call_nop();\n+  %}\n+\n+  enc_class Java_Static_Call(method meth)\n+  %{\n+    \/\/ JAVA STATIC CALL\n+    \/\/ CALL to fixup routine.  Fixup routine uses ScopeDesc info to\n+    \/\/ determine who we intended to call.\n+    if (!_method) {\n+      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, $meth$$method)));\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ addr_nop_5();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n+    } else {\n+      int method_index = resolved_method_index(masm);\n+      RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)\n+                                                  : static_call_Relocation::spec(method_index);\n+      address mark = __ pc();\n+      int call_offset = __ offset();\n+      __ call(AddressLiteral(CAST_FROM_FN_PTR(address, $meth$$method), rspec));\n+      if (CodeBuffer::supports_shared_stubs() && _method->can_be_statically_bound()) {\n+        \/\/ Calls of the same statically bound method can share\n+        \/\/ a stub to the interpreter.\n+        __ code()->shared_stub_to_interp_for(_method, call_offset);\n+      } else {\n+        \/\/ Emit stubs for static call.\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, mark);\n+        __ clear_inst_mark();\n+        if (stub == nullptr) {\n+          ciEnv::current()->record_failure(\"CodeCache is full\");\n+          return;\n+        }\n+      }\n+    }\n+    __ post_call_nop();\n+  %}\n+\n+  enc_class Java_Dynamic_Call(method meth) %{\n+    __ ic_call((address)$meth$$method, resolved_method_index(masm));\n+    __ post_call_nop();\n+  %}\n+\n+  enc_class call_epilog %{\n+    if (VerifyStackAtCalls) {\n+      \/\/ Check that stack depth is unchanged: find majik cookie on stack\n+      int framesize = ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3*VMRegImpl::slots_per_word));\n+      Label L;\n+      __ cmpptr(Address(rsp, framesize), (int32_t)0xbadb100d);\n+      __ jccb(Assembler::equal, L);\n+      \/\/ Die if stack mismatch\n+      __ int3();\n+      __ bind(L);\n+    }\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic() && _method->return_type()->is_loaded()) {\n+      \/\/ The last return value is not set by the callee but used to pass the null marker to compiled code.\n+      \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+      uint con = (tf()->range_cc()->cnt() - 1);\n+      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+        ProjNode* proj = fast_out(i)->as_Proj();\n+        if (proj->_con == con) {\n+          \/\/ Set null marker if rax is non-null (a non-null value is returned buffered or scalarized)\n+          OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+          VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+          Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+          __ testq(rax, rax);\n+          __ setb(Assembler::notZero, toReg);\n+          __ movzbl(toReg, toReg);\n+          if (reg->is_stack()) {\n+            int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+            __ movq(Address(rsp, st_off), toReg);\n+          }\n+          break;\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ rax &= (rax & 1) - 1\n+        __ movptr(rscratch1, rax);\n+        __ andptr(rscratch1, 0x1);\n+        __ subptr(rscratch1, 0x1);\n+        __ andptr(rax, rscratch1);\n+      }\n+    }\n+  %}\n+\n+%}\n+\n+\/\/----------FRAME--------------------------------------------------------------\n+\/\/ Definition of frame structure and management information.\n+\/\/\n+\/\/  S T A C K   L A Y O U T    Allocators stack-slot number\n+\/\/                             |   (to get allocators register number\n+\/\/  G  Owned by    |        |  v    add OptoReg::stack0())\n+\/\/  r   CALLER     |        |\n+\/\/  o     |        +--------+      pad to even-align allocators stack-slot\n+\/\/  w     V        |  pad0  |        numbers; owned by CALLER\n+\/\/  t   -----------+--------+----> Matcher::_in_arg_limit, unaligned\n+\/\/  h     ^        |   in   |  5\n+\/\/        |        |  args  |  4   Holes in incoming args owned by SELF\n+\/\/  |     |        |        |  3\n+\/\/  |     |        +--------+\n+\/\/  V     |        | old out|      Empty on Intel, window on Sparc\n+\/\/        |    old |preserve|      Must be even aligned.\n+\/\/        |     SP-+--------+----> Matcher::_old_SP, even aligned\n+\/\/        |        |   in   |  3   area for Intel ret address\n+\/\/     Owned by    |preserve|      Empty on Sparc.\n+\/\/       SELF      +--------+\n+\/\/        |        |  pad2  |  2   pad to align old SP\n+\/\/        |        +--------+  1\n+\/\/        |        | locks  |  0\n+\/\/        |        +--------+----> OptoReg::stack0(), even aligned\n+\/\/        |        |  pad1  | 11   pad to align new SP\n+\/\/        |        +--------+\n+\/\/        |        |        | 10\n+\/\/        |        | spills |  9   spills\n+\/\/        V        |        |  8   (pad0 slot for callee)\n+\/\/      -----------+--------+----> Matcher::_out_arg_limit, unaligned\n+\/\/        ^        |  out   |  7\n+\/\/        |        |  args  |  6   Holes in outgoing args owned by CALLEE\n+\/\/     Owned by    +--------+\n+\/\/      CALLEE     | new out|  6   Empty on Intel, window on Sparc\n+\/\/        |    new |preserve|      Must be even-aligned.\n+\/\/        |     SP-+--------+----> Matcher::_new_SP, even aligned\n+\/\/        |        |        |\n+\/\/\n+\/\/ Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is\n+\/\/         known from SELF's arguments and the Java calling convention.\n+\/\/         Region 6-7 is determined per call site.\n+\/\/ Note 2: If the calling convention leaves holes in the incoming argument\n+\/\/         area, those holes are owned by SELF.  Holes in the outgoing area\n+\/\/         are owned by the CALLEE.  Holes should not be necessary in the\n+\/\/         incoming area, as the Java calling convention is completely under\n+\/\/         the control of the AD file.  Doubles can be sorted and packed to\n+\/\/         avoid holes.  Holes in the outgoing arguments may be necessary for\n+\/\/         varargs C calling conventions.\n+\/\/ Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is\n+\/\/         even aligned with pad0 as needed.\n+\/\/         Region 6 is even aligned.  Region 6-7 is NOT even aligned;\n+\/\/         region 6-11 is even aligned; it may be padded out more so that\n+\/\/         the region from SP to FP meets the minimum stack alignment.\n+\/\/ Note 4: For I2C adapters, the incoming FP may not meet the minimum stack\n+\/\/         alignment.  Region 11, pad1, may be dynamically extended so that\n+\/\/         SP meets the minimum alignment.\n+\n+frame\n+%{\n+  \/\/ These three registers define part of the calling convention\n+  \/\/ between compiled code and the interpreter.\n+  inline_cache_reg(RAX);                \/\/ Inline Cache Register\n+\n+  \/\/ Optional: name the operand used by cisc-spilling to access\n+  \/\/ [stack_pointer + offset]\n+  cisc_spilling_operand_name(indOffset32);\n+\n+  \/\/ Number of stack slots consumed by locking an object\n+  sync_stack_slots(2);\n+\n+  \/\/ Compiled code's Frame Pointer\n+  frame_pointer(RSP);\n+\n+  \/\/ Interpreter stores its frame pointer in a register which is\n+  \/\/ stored to the stack by I2CAdaptors.\n+  \/\/ I2CAdaptors convert from interpreted java to compiled java.\n+  interpreter_frame_pointer(RBP);\n+\n+  \/\/ Stack alignment requirement\n+  stack_alignment(StackAlignmentInBytes); \/\/ Alignment size in bytes (128-bit -> 16 bytes)\n+\n+  \/\/ Number of outgoing stack slots killed above the out_preserve_stack_slots\n+  \/\/ for calls to C.  Supports the var-args backing area for register parms.\n+  varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes\/BytesPerInt);\n+\n+  \/\/ The after-PROLOG location of the return address.  Location of\n+  \/\/ return address specifies a type (REG or STACK) and a number\n+  \/\/ representing the register number (i.e. - use a register name) or\n+  \/\/ stack slot.\n+  \/\/ Ret Addr is on stack in slot 0 if no locks or verification or alignment.\n+  \/\/ Otherwise, it is above the locks and verification slot and alignment word\n+  return_addr(STACK - 2 +\n+              align_up((Compile::current()->in_preserve_stack_slots() +\n+                        Compile::current()->fixed_slots()),\n+                       stack_alignment_in_slots()));\n+\n+  \/\/ Location of compiled Java return values.  Same as C for now.\n+  return_value\n+  %{\n+    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,\n+           \"only return normal values\");\n+\n+    static const int lo[Op_RegL + 1] = {\n+      0,\n+      0,\n+      RAX_num,  \/\/ Op_RegN\n+      RAX_num,  \/\/ Op_RegI\n+      RAX_num,  \/\/ Op_RegP\n+      XMM0_num, \/\/ Op_RegF\n+      XMM0_num, \/\/ Op_RegD\n+      RAX_num   \/\/ Op_RegL\n+    };\n+    static const int hi[Op_RegL + 1] = {\n+      0,\n+      0,\n+      OptoReg::Bad, \/\/ Op_RegN\n+      OptoReg::Bad, \/\/ Op_RegI\n+      RAX_H_num,    \/\/ Op_RegP\n+      OptoReg::Bad, \/\/ Op_RegF\n+      XMM0b_num,    \/\/ Op_RegD\n+      RAX_H_num     \/\/ Op_RegL\n+    };\n+    \/\/ Excluded flags and vector registers.\n+    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 8, \"missing type\");\n+    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);\n+  %}\n+%}\n+\n+\/\/----------ATTRIBUTES---------------------------------------------------------\n+\/\/----------Operand Attributes-------------------------------------------------\n+op_attrib op_cost(0);        \/\/ Required cost attribute\n+\n+\/\/----------Instruction Attributes---------------------------------------------\n+ins_attrib ins_cost(100);       \/\/ Required cost attribute\n+ins_attrib ins_size(8);         \/\/ Required size attribute (in bits)\n+ins_attrib ins_short_branch(0); \/\/ Required flag: is this instruction\n+                                \/\/ a non-matching short branch variant\n+                                \/\/ of some long branch?\n+ins_attrib ins_alignment(1);    \/\/ Required alignment attribute (must\n+                                \/\/ be a power of 2) specifies the\n+                                \/\/ alignment that some part of the\n+                                \/\/ instruction (not necessarily the\n+                                \/\/ start) requires.  If > 1, a\n+                                \/\/ compute_padding() function must be\n+                                \/\/ provided for the instruction\n+\n+\/\/ Whether this node is expanded during code emission into a sequence of\n+\/\/ instructions and the first instruction can perform an implicit null check.\n+ins_attrib ins_is_late_expanded_null_check_candidate(false);\n+\n+\/\/----------OPERANDS-----------------------------------------------------------\n+\/\/ Operand definitions must precede instruction definitions for correct parsing\n+\/\/ in the ADLC because operands constitute user defined types which are used in\n+\/\/ instruction definitions.\n+\n+\/\/----------Simple Operands----------------------------------------------------\n+\/\/ Immediate Operands\n+\/\/ Integer Immediate\n+operand immI()\n+%{\n+  match(ConI);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for test vs zero\n+operand immI_0()\n+%{\n+  predicate(n->get_int() == 0);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for increment\n+operand immI_1()\n+%{\n+  predicate(n->get_int() == 1);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for decrement\n+operand immI_M1()\n+%{\n+  predicate(n->get_int() == -1);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI_2()\n+%{\n+  predicate(n->get_int() == 2);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI_4()\n+%{\n+  predicate(n->get_int() == 4);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI_8()\n+%{\n+  predicate(n->get_int() == 8);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Valid scale values for addressing modes\n+operand immI2()\n+%{\n+  predicate(0 <= n->get_int() && (n->get_int() <= 3));\n+  match(ConI);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immU7()\n+%{\n+  predicate((0 <= n->get_int()) && (n->get_int() <= 0x7F));\n+  match(ConI);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI8()\n+%{\n+  predicate((-0x80 <= n->get_int()) && (n->get_int() < 0x80));\n+  match(ConI);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immU8()\n+%{\n+  predicate((0 <= n->get_int()) && (n->get_int() <= 255));\n+  match(ConI);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI16()\n+%{\n+  predicate((-32768 <= n->get_int()) && (n->get_int() <= 32767));\n+  match(ConI);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Int Immediate non-negative\n+operand immU31()\n+%{\n+  predicate(n->get_int() >= 0);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Pointer Immediate\n+operand immP()\n+%{\n+  match(ConP);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Null Pointer Immediate\n+operand immP0()\n+%{\n+  predicate(n->get_ptr() == 0);\n+  match(ConP);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Pointer Immediate\n+operand immN() %{\n+  match(ConN);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immNKlass() %{\n+  match(ConNKlass);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Null Pointer Immediate\n+operand immN0() %{\n+  predicate(n->get_narrowcon() == 0);\n+  match(ConN);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immP31()\n+%{\n+  predicate(n->as_Type()->type()->reloc() == relocInfo::none\n+            && (n->get_ptr() >> 31) == 0);\n+  match(ConP);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\n+\/\/ Long Immediate\n+operand immL()\n+%{\n+  match(ConL);\n+\n+  op_cost(20);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Long Immediate 8-bit\n+operand immL8()\n+%{\n+  predicate(-0x80L <= n->get_long() && n->get_long() < 0x80L);\n+  match(ConL);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Long Immediate 32-bit unsigned\n+operand immUL32()\n+%{\n+  predicate(n->get_long() == (unsigned int) (n->get_long()));\n+  match(ConL);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Long Immediate 32-bit signed\n+operand immL32()\n+%{\n+  predicate(n->get_long() == (int) (n->get_long()));\n+  match(ConL);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immL_Pow2()\n+%{\n+  predicate(is_power_of_2((julong)n->get_long()));\n+  match(ConL);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immL_NotPow2()\n+%{\n+  predicate(is_power_of_2((julong)~n->get_long()));\n+  match(ConL);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Long Immediate zero\n+operand immL0()\n+%{\n+  predicate(n->get_long() == 0L);\n+  match(ConL);\n+\n+  op_cost(10);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for increment\n+operand immL1()\n+%{\n+  predicate(n->get_long() == 1);\n+  match(ConL);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for decrement\n+operand immL_M1()\n+%{\n+  predicate(n->get_long() == -1);\n+  match(ConL);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Long Immediate: low 32-bit mask\n+operand immL_32bits()\n+%{\n+  predicate(n->get_long() == 0xFFFFFFFFL);\n+  match(ConL);\n+  op_cost(20);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Int Immediate: 2^n-1, positive\n+operand immI_Pow2M1()\n+%{\n+  predicate((n->get_int() > 0)\n+            && is_power_of_2((juint)n->get_int() + 1));\n+  match(ConI);\n+\n+  op_cost(20);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Float Immediate zero\n+operand immF0()\n+%{\n+  predicate(jint_cast(n->getf()) == 0);\n+  match(ConF);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Float Immediate\n+operand immF()\n+%{\n+  match(ConF);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Half Float Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Double Immediate zero\n+operand immD0()\n+%{\n+  predicate(jlong_cast(n->getd()) == 0);\n+  match(ConD);\n+\n+  op_cost(5);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Double Immediate\n+operand immD()\n+%{\n+  match(ConD);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Immediates for special shifts (sign extend)\n+\n+\/\/ Constants for increment\n+operand immI_16()\n+%{\n+  predicate(n->get_int() == 16);\n+  match(ConI);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI_24()\n+%{\n+  predicate(n->get_int() == 24);\n+  match(ConI);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for byte-wide masking\n+operand immI_255()\n+%{\n+  predicate(n->get_int() == 255);\n+  match(ConI);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for short-wide masking\n+operand immI_65535()\n+%{\n+  predicate(n->get_int() == 65535);\n+  match(ConI);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for byte-wide masking\n+operand immL_255()\n+%{\n+  predicate(n->get_long() == 255);\n+  match(ConL);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Constant for short-wide masking\n+operand immL_65535()\n+%{\n+  predicate(n->get_long() == 65535);\n+  match(ConL);\n+\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand kReg()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Register Operands\n+\/\/ Integer Register\n+operand rRegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_reg));\n+  match(RegI);\n+\n+  match(rax_RegI);\n+  match(rbx_RegI);\n+  match(rcx_RegI);\n+  match(rdx_RegI);\n+  match(rdi_RegI);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+operand rax_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_rax_reg));\n+  match(RegI);\n+  match(rRegI);\n+\n+  format %{ \"RAX\" %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+operand rbx_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_rbx_reg));\n+  match(RegI);\n+  match(rRegI);\n+\n+  format %{ \"RBX\" %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rcx_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_rcx_reg));\n+  match(RegI);\n+  match(rRegI);\n+\n+  format %{ \"RCX\" %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rdx_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_rdx_reg));\n+  match(RegI);\n+  match(rRegI);\n+\n+  format %{ \"RDX\" %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rdi_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_rdi_reg));\n+  match(RegI);\n+  match(rRegI);\n+\n+  format %{ \"RDI\" %}\n+  interface(REG_INTER);\n+%}\n+\n+operand no_rax_rdx_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));\n+  match(RegI);\n+  match(rbx_RegI);\n+  match(rcx_RegI);\n+  match(rdi_RegI);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand no_rbp_r13_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_no_rbp_r13_reg));\n+  match(RegI);\n+  match(rRegI);\n+  match(rax_RegI);\n+  match(rbx_RegI);\n+  match(rcx_RegI);\n+  match(rdx_RegI);\n+  match(rdi_RegI);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Pointer Register\n+operand any_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(any_reg));\n+  match(RegP);\n+  match(rax_RegP);\n+  match(rbx_RegP);\n+  match(rdi_RegP);\n+  match(rsi_RegP);\n+  match(rbp_RegP);\n+  match(r15_RegP);\n+  match(rRegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rRegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(RegP);\n+  match(rax_RegP);\n+  match(rbx_RegP);\n+  match(rdi_RegP);\n+  match(rsi_RegP);\n+  match(rbp_RegP);  \/\/ See Q&A below about\n+  match(r15_RegP);  \/\/ r15_RegP and rbp_RegP.\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rRegN() %{\n+  constraint(ALLOC_IN_RC(int_reg));\n+  match(RegN);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?\n+\/\/ Answer: Operand match rules govern the DFA as it processes instruction inputs.\n+\/\/ It's fine for an instruction input that expects rRegP to match a r15_RegP.\n+\/\/ The output of an instruction is controlled by the allocator, which respects\n+\/\/ register class masks, not match rules.  Unless an instruction mentions\n+\/\/ r15_RegP or any_RegP explicitly as its output, r15 will not be considered\n+\/\/ by the allocator as an input.\n+\/\/ The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,\n+\/\/ the RBP is used as a proper frame pointer and is not included in ptr_reg. As a\n+\/\/ result, RBP is not included in the output of the instruction either.\n+\n+\/\/ This operand is not allowed to use RBP even if\n+\/\/ RBP is not used to hold the frame pointer.\n+operand no_rbp_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg_no_rbp));\n+  match(RegP);\n+  match(rbx_RegP);\n+  match(rsi_RegP);\n+  match(rdi_RegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+\/\/ Return a pointer value\n+operand rax_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_rax_reg));\n+  match(RegP);\n+  match(rRegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+\/\/ Return a compressed pointer value\n+operand rax_RegN()\n+%{\n+  constraint(ALLOC_IN_RC(int_rax_reg));\n+  match(RegN);\n+  match(rRegN);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Used in AtomicAdd\n+operand rbx_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_rbx_reg));\n+  match(RegP);\n+  match(rRegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rsi_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_rsi_reg));\n+  match(RegP);\n+  match(rRegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rbp_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_rbp_reg));\n+  match(RegP);\n+  match(rRegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Used in rep stosq\n+operand rdi_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_rdi_reg));\n+  match(RegP);\n+  match(rRegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand r15_RegP()\n+%{\n+  constraint(ALLOC_IN_RC(ptr_r15_reg));\n+  match(RegP);\n+  match(rRegP);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rRegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_reg));\n+  match(RegL);\n+  match(rax_RegL);\n+  match(rdx_RegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+operand no_rax_rdx_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rax_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_rax_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ \"RAX\" %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rcx_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_rcx_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rdx_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_rdx_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand r11_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_r11_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand no_rbp_r13_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_no_rbp_r13_reg));\n+  match(RegL);\n+  match(rRegL);\n+  match(rax_RegL);\n+  match(rcx_RegL);\n+  match(rdx_RegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Flags register, used as output of compare instructions\n+operand rFlagsReg()\n+%{\n+  constraint(ALLOC_IN_RC(int_flags));\n+  match(RegFlags);\n+\n+  format %{ \"RFLAGS\" %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Flags register, used as output of FLOATING POINT compare instructions\n+operand rFlagsRegU()\n+%{\n+  constraint(ALLOC_IN_RC(int_flags));\n+  match(RegFlags);\n+\n+  format %{ \"RFLAGS_U\" %}\n+  interface(REG_INTER);\n+%}\n+\n+operand rFlagsRegUCF() %{\n+  constraint(ALLOC_IN_RC(int_flags));\n+  match(RegFlags);\n+  predicate(false);\n+\n+  format %{ \"RFLAGS_U_CF\" %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Float register operands\n+operand regF() %{\n+   constraint(ALLOC_IN_RC(float_reg));\n+   match(RegF);\n+\n+   format %{ %}\n+   interface(REG_INTER);\n+%}\n+\n+\/\/ Float register operands\n+operand legRegF() %{\n+   constraint(ALLOC_IN_RC(float_reg_legacy));\n+   match(RegF);\n+\n+   format %{ %}\n+   interface(REG_INTER);\n+%}\n+\n+\/\/ Float register operands\n+operand vlRegF() %{\n+   constraint(ALLOC_IN_RC(float_reg_vl));\n+   match(RegF);\n+\n+   format %{ %}\n+   interface(REG_INTER);\n+%}\n+\n+\/\/ Double register operands\n+operand regD() %{\n+   constraint(ALLOC_IN_RC(double_reg));\n+   match(RegD);\n+\n+   format %{ %}\n+   interface(REG_INTER);\n+%}\n+\n+\/\/ Double register operands\n+operand legRegD() %{\n+   constraint(ALLOC_IN_RC(double_reg_legacy));\n+   match(RegD);\n+\n+   format %{ %}\n+   interface(REG_INTER);\n+%}\n+\n+\/\/ Double register operands\n+operand vlRegD() %{\n+   constraint(ALLOC_IN_RC(double_reg_vl));\n+   match(RegD);\n+\n+   format %{ %}\n+   interface(REG_INTER);\n+%}\n+\n+\/\/----------Memory Operands----------------------------------------------------\n+\/\/ Direct Memory Operand\n+\/\/ operand direct(immP addr)\n+\/\/ %{\n+\/\/   match(addr);\n+\n+\/\/   format %{ \"[$addr]\" %}\n+\/\/   interface(MEMORY_INTER) %{\n+\/\/     base(0xFFFFFFFF);\n+\/\/     index(0x4);\n+\/\/     scale(0x0);\n+\/\/     disp($addr);\n+\/\/   %}\n+\/\/ %}\n+\n+\/\/ Indirect Memory Operand\n+operand indirect(any_RegP reg)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(reg);\n+\n+  format %{ \"[$reg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0x4);\n+    scale(0x0);\n+    disp(0x0);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Short Offset Operand\n+operand indOffset8(any_RegP reg, immL8 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+\n+  format %{ \"[$reg + $off (8-bit)]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0x4);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Long Offset Operand\n+operand indOffset32(any_RegP reg, immL32 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+\n+  format %{ \"[$reg + $off (32-bit)]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0x4);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n+operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (AddP reg lreg) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $lreg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n+operand indIndex(any_RegP reg, rRegL lreg)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg lreg);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $lreg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale(0x0);\n+    disp(0x0);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Times Scale Plus Index Register\n+operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg (LShiftL lreg scale));\n+\n+  op_cost(10);\n+  format %{\"[$reg + $lreg << $scale]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale($scale);\n+    disp(0x0);\n+  %}\n+%}\n+\n+operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  predicate(n->in(3)->in(1)->as_Type()->type()->is_long()->_lo >= 0);\n+  match(AddP reg (LShiftL (ConvI2L idx) scale));\n+\n+  op_cost(10);\n+  format %{\"[$reg + pos $idx << $scale]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($idx);\n+    scale($scale);\n+    disp(0x0);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Times Scale Plus Index Register Plus Offset Operand\n+operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (AddP reg (LShiftL lreg scale)) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $lreg << $scale]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale($scale);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Positive Index Register Plus Offset Operand\n+operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  predicate(n->in(2)->in(3)->as_Type()->type()->is_long()->_lo >= 0);\n+  match(AddP (AddP reg (ConvI2L idx)) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $idx]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($idx);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand\n+operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  predicate(n->in(2)->in(3)->in(1)->as_Type()->type()->is_long()->_lo >= 0);\n+  match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $idx << $scale]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($idx);\n+    scale($scale);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Narrow Oop Operand\n+operand indCompressedOop(rRegN reg) %{\n+  predicate(UseCompressedOops && (CompressedOops::shift() == Address::times_8));\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(DecodeN reg);\n+\n+  op_cost(10);\n+  format %{\"[R12 + $reg << 3] (compressed oop addressing)\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0xc); \/\/ R12\n+    index($reg);\n+    scale(0x3);\n+    disp(0x0);\n+  %}\n+%}\n+\n+\/\/ Indirect Narrow Oop Plus Offset Operand\n+\/\/ Note: x86 architecture doesn't support \"scale * index + offset\" without a base\n+\/\/ we can't free r12 even with CompressedOops::base() == nullptr.\n+operand indCompressedOopOffset(rRegN reg, immL32 off) %{\n+  predicate(UseCompressedOops && (CompressedOops::shift() == Address::times_8));\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+\n+  op_cost(10);\n+  format %{\"[R12 + $reg << 3 + $off] (compressed oop addressing)\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0xc); \/\/ R12\n+    index($reg);\n+    scale(0x3);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Operand\n+operand indirectNarrow(rRegN reg)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(DecodeN reg);\n+\n+  format %{ \"[$reg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0x4);\n+    scale(0x0);\n+    disp(0x0);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Short Offset Operand\n+operand indOffset8Narrow(rRegN reg, immL8 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+\n+  format %{ \"[$reg + $off (8-bit)]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0x4);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Long Offset Operand\n+operand indOffset32Narrow(rRegN reg, immL32 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+\n+  format %{ \"[$reg + $off (32-bit)]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0x4);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n+operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (AddP (DecodeN reg) lreg) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $lreg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n+operand indIndexNarrow(rRegN reg, rRegL lreg)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) lreg);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $lreg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale(0x0);\n+    disp(0x0);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Times Scale Plus Index Register\n+operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) (LShiftL lreg scale));\n+\n+  op_cost(10);\n+  format %{\"[$reg + $lreg << $scale]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale($scale);\n+    disp(0x0);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Times Scale Plus Index Register Plus Offset Operand\n+operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $lreg << $scale]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($lreg);\n+    scale($scale);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Times Plus Positive Index Register Plus Offset Operand\n+operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  predicate(CompressedOops::shift() == 0 && n->in(2)->in(3)->as_Type()->type()->is_long()->_lo >= 0);\n+  match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $idx]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($idx);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/ Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand\n+operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  predicate(CompressedOops::shift() == 0 && n->in(2)->in(3)->in(1)->as_Type()->type()->is_long()->_lo >= 0);\n+  match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);\n+\n+  op_cost(10);\n+  format %{\"[$reg + $off + $idx << $scale]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index($idx);\n+    scale($scale);\n+    disp($off);\n+  %}\n+%}\n+\n+\/\/----------Special Memory Operands--------------------------------------------\n+\/\/ Stack Slot Operand - This operand is used for loading and storing temporary\n+\/\/                      values on the stack where a match requires a value to\n+\/\/                      flow through memory.\n+operand stackSlotP(sRegP reg)\n+%{\n+  constraint(ALLOC_IN_RC(stack_slots));\n+  \/\/ No match rule because this operand is only generated in matching\n+\n+  format %{ \"[$reg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0x4);   \/\/ RSP\n+    index(0x4);  \/\/ No Index\n+    scale(0x0);  \/\/ No Scale\n+    disp($reg);  \/\/ Stack Offset\n+  %}\n+%}\n+\n+operand stackSlotI(sRegI reg)\n+%{\n+  constraint(ALLOC_IN_RC(stack_slots));\n+  \/\/ No match rule because this operand is only generated in matching\n+\n+  format %{ \"[$reg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0x4);   \/\/ RSP\n+    index(0x4);  \/\/ No Index\n+    scale(0x0);  \/\/ No Scale\n+    disp($reg);  \/\/ Stack Offset\n+  %}\n+%}\n+\n+operand stackSlotF(sRegF reg)\n+%{\n+  constraint(ALLOC_IN_RC(stack_slots));\n+  \/\/ No match rule because this operand is only generated in matching\n+\n+  format %{ \"[$reg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0x4);   \/\/ RSP\n+    index(0x4);  \/\/ No Index\n+    scale(0x0);  \/\/ No Scale\n+    disp($reg);  \/\/ Stack Offset\n+  %}\n+%}\n+\n+operand stackSlotD(sRegD reg)\n+%{\n+  constraint(ALLOC_IN_RC(stack_slots));\n+  \/\/ No match rule because this operand is only generated in matching\n+\n+  format %{ \"[$reg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0x4);   \/\/ RSP\n+    index(0x4);  \/\/ No Index\n+    scale(0x0);  \/\/ No Scale\n+    disp($reg);  \/\/ Stack Offset\n+  %}\n+%}\n+operand stackSlotL(sRegL reg)\n+%{\n+  constraint(ALLOC_IN_RC(stack_slots));\n+  \/\/ No match rule because this operand is only generated in matching\n+\n+  format %{ \"[$reg]\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0x4);   \/\/ RSP\n+    index(0x4);  \/\/ No Index\n+    scale(0x0);  \/\/ No Scale\n+    disp($reg);  \/\/ Stack Offset\n+  %}\n+%}\n+\n+\/\/----------Conditional Branch Operands----------------------------------------\n+\/\/ Comparison Op  - This is the operation of the comparison, and is limited to\n+\/\/                  the following set of codes:\n+\/\/                  L (<), LE (<=), G (>), GE (>=), E (==), NE (!=)\n+\/\/\n+\/\/ Other attributes of the comparison, such as unsignedness, are specified\n+\/\/ by the comparison instruction that sets a condition code flags register.\n+\/\/ That result is represented by a flags operand whose subtype is appropriate\n+\/\/ to the unsignedness (etc.) of the comparison.\n+\/\/\n+\/\/ Later, the instruction which matches both the Comparison Op (a Bool) and\n+\/\/ the flags (produced by the Cmp) specifies the coding of the comparison op\n+\/\/ by matching a specific subtype of Bool operand below, such as cmpOpU.\n+\n+\/\/ Comparison Code\n+operand cmpOp()\n+%{\n+  match(Bool);\n+\n+  format %{ \"\" %}\n+  interface(COND_INTER) %{\n+    equal(0x4, \"e\");\n+    not_equal(0x5, \"ne\");\n+    less(0xC, \"l\");\n+    greater_equal(0xD, \"ge\");\n+    less_equal(0xE, \"le\");\n+    greater(0xF, \"g\");\n+    overflow(0x0, \"o\");\n+    no_overflow(0x1, \"no\");\n+  %}\n+%}\n+\n+\/\/ Comparison Code, unsigned compare.  Used by FP also, with\n+\/\/ C2 (unordered) turned into GT or LT already.  The other bits\n+\/\/ C0 and C3 are turned into Carry & Zero flags.\n+operand cmpOpU()\n+%{\n+  match(Bool);\n+\n+  format %{ \"\" %}\n+  interface(COND_INTER) %{\n+    equal(0x4, \"e\");\n+    not_equal(0x5, \"ne\");\n+    less(0x2, \"b\");\n+    greater_equal(0x3, \"ae\");\n+    less_equal(0x6, \"be\");\n+    greater(0x7, \"a\");\n+    overflow(0x0, \"o\");\n+    no_overflow(0x1, \"no\");\n+  %}\n+%}\n+\n+\n+\/\/ Floating comparisons that don't require any fixup for the unordered case,\n+\/\/ If both inputs of the comparison are the same, ZF is always set so we\n+\/\/ don't need to use cmpOpUCF2 for eq\/ne\n+operand cmpOpUCF() %{\n+  match(Bool);\n+  predicate(n->as_Bool()->_test._test == BoolTest::lt ||\n+            n->as_Bool()->_test._test == BoolTest::ge ||\n+            n->as_Bool()->_test._test == BoolTest::le ||\n+            n->as_Bool()->_test._test == BoolTest::gt ||\n+            n->in(1)->in(1) == n->in(1)->in(2));\n+  format %{ \"\" %}\n+  interface(COND_INTER) %{\n+    equal(0xb, \"np\");\n+    not_equal(0xa, \"p\");\n+    less(0x2, \"b\");\n+    greater_equal(0x3, \"ae\");\n+    less_equal(0x6, \"be\");\n+    greater(0x7, \"a\");\n+    overflow(0x0, \"o\");\n+    no_overflow(0x1, \"no\");\n+  %}\n+%}\n+\n+\n+\/\/ Floating comparisons that can be fixed up with extra conditional jumps\n+operand cmpOpUCF2() %{\n+  match(Bool);\n+  predicate((n->as_Bool()->_test._test == BoolTest::ne ||\n+             n->as_Bool()->_test._test == BoolTest::eq) &&\n+            n->in(1)->in(1) != n->in(1)->in(2));\n+  format %{ \"\" %}\n+  interface(COND_INTER) %{\n+    equal(0x4, \"e\");\n+    not_equal(0x5, \"ne\");\n+    less(0x2, \"b\");\n+    greater_equal(0x3, \"ae\");\n+    less_equal(0x6, \"be\");\n+    greater(0x7, \"a\");\n+    overflow(0x0, \"o\");\n+    no_overflow(0x1, \"no\");\n+  %}\n+%}\n+\n+\/\/ Operands for bound floating pointer register arguments\n+operand rxmm0() %{\n+  constraint(ALLOC_IN_RC(xmm0_reg));\n+  match(VecX);\n+  format%{%}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Vectors\n+\n+\/\/ Dummy generic vector class. Should be used for all vector operands.\n+\/\/ Replaced with vec[SDXYZ] during post-selection pass.\n+operand vec() %{\n+  constraint(ALLOC_IN_RC(dynamic));\n+  match(VecX);\n+  match(VecY);\n+  match(VecZ);\n+  match(VecS);\n+  match(VecD);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Dummy generic legacy vector class. Should be used for all legacy vector operands.\n+\/\/ Replaced with legVec[SDXYZ] during post-selection cleanup.\n+\/\/ Note: legacy register class is used to avoid extra (unneeded in 32-bit VM)\n+\/\/ runtime code generation via reg_class_dynamic.\n+operand legVec() %{\n+  constraint(ALLOC_IN_RC(dynamic));\n+  match(VecX);\n+  match(VecY);\n+  match(VecZ);\n+  match(VecS);\n+  match(VecD);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces vec during post-selection cleanup. See above.\n+operand vecS() %{\n+  constraint(ALLOC_IN_RC(vectors_reg_vlbwdq));\n+  match(VecS);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces legVec during post-selection cleanup. See above.\n+operand legVecS() %{\n+  constraint(ALLOC_IN_RC(vectors_reg_legacy));\n+  match(VecS);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces vec during post-selection cleanup. See above.\n+operand vecD() %{\n+  constraint(ALLOC_IN_RC(vectord_reg_vlbwdq));\n+  match(VecD);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces legVec during post-selection cleanup. See above.\n+operand legVecD() %{\n+  constraint(ALLOC_IN_RC(vectord_reg_legacy));\n+  match(VecD);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces vec during post-selection cleanup. See above.\n+operand vecX() %{\n+  constraint(ALLOC_IN_RC(vectorx_reg_vlbwdq));\n+  match(VecX);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces legVec during post-selection cleanup. See above.\n+operand legVecX() %{\n+  constraint(ALLOC_IN_RC(vectorx_reg_legacy));\n+  match(VecX);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces vec during post-selection cleanup. See above.\n+operand vecY() %{\n+  constraint(ALLOC_IN_RC(vectory_reg_vlbwdq));\n+  match(VecY);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces legVec during post-selection cleanup. See above.\n+operand legVecY() %{\n+  constraint(ALLOC_IN_RC(vectory_reg_legacy));\n+  match(VecY);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces vec during post-selection cleanup. See above.\n+operand vecZ() %{\n+  constraint(ALLOC_IN_RC(vectorz_reg));\n+  match(VecZ);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Replaces legVec during post-selection cleanup. See above.\n+operand legVecZ() %{\n+  constraint(ALLOC_IN_RC(vectorz_reg_legacy));\n+  match(VecZ);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/----------OPERAND CLASSES----------------------------------------------------\n+\/\/ Operand Classes are groups of operands that are used as to simplify\n+\/\/ instruction definitions by not requiring the AD writer to specify separate\n+\/\/ instructions for every form of operand when the instruction accepts\n+\/\/ multiple operand types with the same basic encoding and format.  The classic\n+\/\/ case of this is memory operands.\n+\n+opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,\n+               indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,\n+               indCompressedOop, indCompressedOopOffset,\n+               indirectNarrow, indOffset8Narrow, indOffset32Narrow,\n+               indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,\n+               indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);\n+\n+\/\/----------PIPELINE-----------------------------------------------------------\n+\/\/ Rules which define the behavior of the target architectures pipeline.\n+pipeline %{\n+\n+\/\/----------ATTRIBUTES---------------------------------------------------------\n+attributes %{\n+  variable_size_instructions;        \/\/ Fixed size instructions\n+  max_instructions_per_bundle = 3;   \/\/ Up to 3 instructions per bundle\n+  instruction_unit_size = 1;         \/\/ An instruction is 1 bytes long\n+  instruction_fetch_unit_size = 16;  \/\/ The processor fetches one line\n+  instruction_fetch_units = 1;       \/\/ of 16 bytes\n+%}\n+\n+\/\/----------RESOURCES----------------------------------------------------------\n+\/\/ Resources are the functional units available to the machine\n+\n+\/\/ Generic P2\/P3 pipeline\n+\/\/ 3 decoders, only D0 handles big operands; a \"bundle\" is the limit of\n+\/\/ 3 instructions decoded per cycle.\n+\/\/ 2 load\/store ops per cycle, 1 branch, 1 FPU,\n+\/\/ 3 ALU op, only ALU0 handles mul instructions.\n+resources( D0, D1, D2, DECODE = D0 | D1 | D2,\n+           MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,\n+           BR, FPU,\n+           ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);\n+\n+\/\/----------PIPELINE DESCRIPTION-----------------------------------------------\n+\/\/ Pipeline Description specifies the stages in the machine's pipeline\n+\n+\/\/ Generic P2\/P3 pipeline\n+pipe_desc(S0, S1, S2, S3, S4, S5);\n+\n+\/\/----------PIPELINE CLASSES---------------------------------------------------\n+\/\/ Pipeline Classes describe the stages in which input and output are\n+\/\/ referenced by the hardware pipeline.\n+\n+\/\/ Naming convention: ialu or fpu\n+\/\/ Then: _reg\n+\/\/ Then: _reg if there is a 2nd register\n+\/\/ Then: _long if it's a pair of instructions implementing a long\n+\/\/ Then: _fat if it requires the big decoder\n+\/\/   Or: _mem if it requires the big decoder and a memory unit.\n+\n+\/\/ Integer ALU reg operation\n+pipe_class ialu_reg(rRegI dst)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    dst    : S3(read);\n+    DECODE : S0;        \/\/ any decoder\n+    ALU    : S3;        \/\/ any alu\n+%}\n+\n+\/\/ Long ALU reg operation\n+pipe_class ialu_reg_long(rRegL dst)\n+%{\n+    instruction_count(2);\n+    dst    : S4(write);\n+    dst    : S3(read);\n+    DECODE : S0(2);     \/\/ any 2 decoders\n+    ALU    : S3(2);     \/\/ both alus\n+%}\n+\n+\/\/ Integer ALU reg operation using big decoder\n+pipe_class ialu_reg_fat(rRegI dst)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    dst    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    ALU    : S3;        \/\/ any alu\n+%}\n+\n+\/\/ Integer ALU reg-reg operation\n+pipe_class ialu_reg_reg(rRegI dst, rRegI src)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    src    : S3(read);\n+    DECODE : S0;        \/\/ any decoder\n+    ALU    : S3;        \/\/ any alu\n+%}\n+\n+\/\/ Integer ALU reg-reg operation\n+pipe_class ialu_reg_reg_fat(rRegI dst, memory src)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    src    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    ALU    : S3;        \/\/ any alu\n+%}\n+\n+\/\/ Integer ALU reg-mem operation\n+pipe_class ialu_reg_mem(rRegI dst, memory mem)\n+%{\n+    single_instruction;\n+    dst    : S5(write);\n+    mem    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    ALU    : S4;        \/\/ any alu\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+\/\/ Integer mem operation (prefetch)\n+pipe_class ialu_mem(memory mem)\n+%{\n+    single_instruction;\n+    mem    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+\/\/ Integer Store to Memory\n+pipe_class ialu_mem_reg(memory mem, rRegI src)\n+%{\n+    single_instruction;\n+    mem    : S3(read);\n+    src    : S5(read);\n+    D0     : S0;        \/\/ big decoder only\n+    ALU    : S4;        \/\/ any alu\n+    MEM    : S3;\n+%}\n+\n+\/\/ \/\/ Long Store to Memory\n+\/\/ pipe_class ialu_mem_long_reg(memory mem, rRegL src)\n+\/\/ %{\n+\/\/     instruction_count(2);\n+\/\/     mem    : S3(read);\n+\/\/     src    : S5(read);\n+\/\/     D0     : S0(2);          \/\/ big decoder only; twice\n+\/\/     ALU    : S4(2);     \/\/ any 2 alus\n+\/\/     MEM    : S3(2);  \/\/ Both mems\n+\/\/ %}\n+\n+\/\/ Integer Store to Memory\n+pipe_class ialu_mem_imm(memory mem)\n+%{\n+    single_instruction;\n+    mem    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    ALU    : S4;        \/\/ any alu\n+    MEM    : S3;\n+%}\n+\n+\/\/ Integer ALU0 reg-reg operation\n+pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    src    : S3(read);\n+    D0     : S0;        \/\/ Big decoder only\n+    ALU0   : S3;        \/\/ only alu0\n+%}\n+\n+\/\/ Integer ALU0 reg-mem operation\n+pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)\n+%{\n+    single_instruction;\n+    dst    : S5(write);\n+    mem    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    ALU0   : S4;        \/\/ ALU0 only\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+\/\/ Integer ALU reg-reg operation\n+pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)\n+%{\n+    single_instruction;\n+    cr     : S4(write);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    DECODE : S0;        \/\/ any decoder\n+    ALU    : S3;        \/\/ any alu\n+%}\n+\n+\/\/ Integer ALU reg-imm operation\n+pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)\n+%{\n+    single_instruction;\n+    cr     : S4(write);\n+    src1   : S3(read);\n+    DECODE : S0;        \/\/ any decoder\n+    ALU    : S3;        \/\/ any alu\n+%}\n+\n+\/\/ Integer ALU reg-mem operation\n+pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)\n+%{\n+    single_instruction;\n+    cr     : S4(write);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    ALU    : S4;        \/\/ any alu\n+    MEM    : S3;\n+%}\n+\n+\/\/ Conditional move reg-reg\n+pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)\n+%{\n+    instruction_count(4);\n+    y      : S4(read);\n+    q      : S3(read);\n+    p      : S3(read);\n+    DECODE : S0(4);     \/\/ any decoder\n+%}\n+\n+\/\/ Conditional move reg-reg\n+pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    src    : S3(read);\n+    cr     : S3(read);\n+    DECODE : S0;        \/\/ any decoder\n+%}\n+\n+\/\/ Conditional move reg-mem\n+pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    src    : S3(read);\n+    cr     : S3(read);\n+    DECODE : S0;        \/\/ any decoder\n+    MEM    : S3;\n+%}\n+\n+\/\/ Conditional move reg-reg long\n+pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)\n+%{\n+    single_instruction;\n+    dst    : S4(write);\n+    src    : S3(read);\n+    cr     : S3(read);\n+    DECODE : S0(2);     \/\/ any 2 decoders\n+%}\n+\n+\/\/ Float reg-reg operation\n+pipe_class fpu_reg(regD dst)\n+%{\n+    instruction_count(2);\n+    dst    : S3(read);\n+    DECODE : S0(2);     \/\/ any 2 decoders\n+    FPU    : S3;\n+%}\n+\n+\/\/ Float reg-reg operation\n+pipe_class fpu_reg_reg(regD dst, regD src)\n+%{\n+    instruction_count(2);\n+    dst    : S4(write);\n+    src    : S3(read);\n+    DECODE : S0(2);     \/\/ any 2 decoders\n+    FPU    : S3;\n+%}\n+\n+\/\/ Float reg-reg operation\n+pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)\n+%{\n+    instruction_count(3);\n+    dst    : S4(write);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    DECODE : S0(3);     \/\/ any 3 decoders\n+    FPU    : S3(2);\n+%}\n+\n+\/\/ Float reg-reg operation\n+pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)\n+%{\n+    instruction_count(4);\n+    dst    : S4(write);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    src3   : S3(read);\n+    DECODE : S0(4);     \/\/ any 3 decoders\n+    FPU    : S3(2);\n+%}\n+\n+\/\/ Float reg-reg operation\n+pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)\n+%{\n+    instruction_count(4);\n+    dst    : S4(write);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    src3   : S3(read);\n+    DECODE : S1(3);     \/\/ any 3 decoders\n+    D0     : S0;        \/\/ Big decoder only\n+    FPU    : S3(2);\n+    MEM    : S3;\n+%}\n+\n+\/\/ Float reg-mem operation\n+pipe_class fpu_reg_mem(regD dst, memory mem)\n+%{\n+    instruction_count(2);\n+    dst    : S5(write);\n+    mem    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    DECODE : S1;        \/\/ any decoder for FPU POP\n+    FPU    : S4;\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+\/\/ Float reg-mem operation\n+pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)\n+%{\n+    instruction_count(3);\n+    dst    : S5(write);\n+    src1   : S3(read);\n+    mem    : S3(read);\n+    D0     : S0;        \/\/ big decoder only\n+    DECODE : S1(2);     \/\/ any decoder for FPU POP\n+    FPU    : S4;\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+\/\/ Float mem-reg operation\n+pipe_class fpu_mem_reg(memory mem, regD src)\n+%{\n+    instruction_count(2);\n+    src    : S5(read);\n+    mem    : S3(read);\n+    DECODE : S0;        \/\/ any decoder for FPU PUSH\n+    D0     : S1;        \/\/ big decoder only\n+    FPU    : S4;\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)\n+%{\n+    instruction_count(3);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    mem    : S3(read);\n+    DECODE : S0(2);     \/\/ any decoder for FPU PUSH\n+    D0     : S1;        \/\/ big decoder only\n+    FPU    : S4;\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)\n+%{\n+    instruction_count(3);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    mem    : S4(read);\n+    DECODE : S0;        \/\/ any decoder for FPU PUSH\n+    D0     : S0(2);     \/\/ big decoder only\n+    FPU    : S4;\n+    MEM    : S3(2);     \/\/ any mem\n+%}\n+\n+pipe_class fpu_mem_mem(memory dst, memory src1)\n+%{\n+    instruction_count(2);\n+    src1   : S3(read);\n+    dst    : S4(read);\n+    D0     : S0(2);     \/\/ big decoder only\n+    MEM    : S3(2);     \/\/ any mem\n+%}\n+\n+pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)\n+%{\n+    instruction_count(3);\n+    src1   : S3(read);\n+    src2   : S3(read);\n+    dst    : S4(read);\n+    D0     : S0(3);     \/\/ big decoder only\n+    FPU    : S4;\n+    MEM    : S3(3);     \/\/ any mem\n+%}\n+\n+pipe_class fpu_mem_reg_con(memory mem, regD src1)\n+%{\n+    instruction_count(3);\n+    src1   : S4(read);\n+    mem    : S4(read);\n+    DECODE : S0;        \/\/ any decoder for FPU PUSH\n+    D0     : S0(2);     \/\/ big decoder only\n+    FPU    : S4;\n+    MEM    : S3(2);     \/\/ any mem\n+%}\n+\n+\/\/ Float load constant\n+pipe_class fpu_reg_con(regD dst)\n+%{\n+    instruction_count(2);\n+    dst    : S5(write);\n+    D0     : S0;        \/\/ big decoder only for the load\n+    DECODE : S1;        \/\/ any decoder for FPU POP\n+    FPU    : S4;\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+\/\/ Float load constant\n+pipe_class fpu_reg_reg_con(regD dst, regD src)\n+%{\n+    instruction_count(3);\n+    dst    : S5(write);\n+    src    : S3(read);\n+    D0     : S0;        \/\/ big decoder only for the load\n+    DECODE : S1(2);     \/\/ any decoder for FPU POP\n+    FPU    : S4;\n+    MEM    : S3;        \/\/ any mem\n+%}\n+\n+\/\/ UnConditional branch\n+pipe_class pipe_jmp(label labl)\n+%{\n+    single_instruction;\n+    BR   : S3;\n+%}\n+\n+\/\/ Conditional branch\n+pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)\n+%{\n+    single_instruction;\n+    cr    : S1(read);\n+    BR    : S3;\n+%}\n+\n+\/\/ Allocation idiom\n+pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)\n+%{\n+    instruction_count(1); force_serialization;\n+    fixed_latency(6);\n+    heap_ptr : S3(read);\n+    DECODE   : S0(3);\n+    D0       : S2;\n+    MEM      : S3;\n+    ALU      : S3(2);\n+    dst      : S5(write);\n+    BR       : S5;\n+%}\n+\n+\/\/ Generic big\/slow expanded idiom\n+pipe_class pipe_slow()\n+%{\n+    instruction_count(10); multiple_bundles; force_serialization;\n+    fixed_latency(100);\n+    D0  : S0(2);\n+    MEM : S3(2);\n+%}\n+\n+\/\/ The real do-nothing guy\n+pipe_class empty()\n+%{\n+    instruction_count(0);\n+%}\n+\n+\/\/ Define the class for the Nop node\n+define\n+%{\n+   MachNop = empty;\n+%}\n+\n+%}\n+\n+\/\/----------INSTRUCTIONS-------------------------------------------------------\n+\/\/\n+\/\/ match      -- States which machine-independent subtree may be replaced\n+\/\/               by this instruction.\n+\/\/ ins_cost   -- The estimated cost of this instruction is used by instruction\n+\/\/               selection to identify a minimum cost tree of machine\n+\/\/               instructions that matches a tree of machine-independent\n+\/\/               instructions.\n+\/\/ format     -- A string providing the disassembly for this instruction.\n+\/\/               The value of an instruction's operand may be inserted\n+\/\/               by referring to it with a '$' prefix.\n+\/\/ opcode     -- Three instruction opcodes may be provided.  These are referred\n+\/\/               to within an encode class as $primary, $secondary, and $tertiary\n+\/\/               rrspectively.  The primary opcode is commonly used to\n+\/\/               indicate the type of machine instruction, while secondary\n+\/\/               and tertiary are often used for prefix options or addressing\n+\/\/               modes.\n+\/\/ ins_encode -- A list of encode classes with parameters. The encode class\n+\/\/               name must have been defined in an 'enc_class' specification\n+\/\/               in the encode section of the architecture description.\n+\n+\/\/ ============================================================================\n+\n+instruct ShouldNotReachHere() %{\n+  match(Halt);\n+  format %{ \"stop\\t# ShouldNotReachHere\" %}\n+  ins_encode %{\n+    if (is_reachable()) {\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ============================================================================\n+\n+\/\/ Dummy reg-to-reg vector moves. Removed during post-selection cleanup.\n+\/\/ Load Float\n+instruct MoveF2VL(vlRegF dst, regF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveF2LEG(legRegF dst, regF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveVL2F(regF dst, vlRegF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Float\n+instruct MoveLEG2F(regF dst, legRegF src) %{\n+  match(Set dst src);\n+  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveD2VL(vlRegD dst, regD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveD2LEG(legRegD dst, regD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveVL2D(regD dst, vlRegD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/ Load Double\n+instruct MoveLEG2D(regD dst, legRegD src) %{\n+  match(Set dst src);\n+  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n+  ins_encode %{\n+    ShouldNotReachHere();\n+  %}\n+  ins_pipe( fpu_reg_reg );\n+%}\n+\n+\/\/----------Load\/Store\/Move Instructions---------------------------------------\n+\/\/----------Load Instructions--------------------------------------------------\n+\n+\/\/ Load Byte (8 bit signed)\n+instruct loadB(rRegI dst, memory mem)\n+%{\n+  match(Set dst (LoadB mem));\n+\n+  ins_cost(125);\n+  format %{ \"movsbl  $dst, $mem\\t# byte\" %}\n+\n+  ins_encode %{\n+    __ movsbl($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Byte (8 bit signed) into Long Register\n+instruct loadB2L(rRegL dst, memory mem)\n+%{\n+  match(Set dst (ConvI2L (LoadB mem)));\n+\n+  ins_cost(125);\n+  format %{ \"movsbq  $dst, $mem\\t# byte -> long\" %}\n+\n+  ins_encode %{\n+    __ movsbq($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Byte (8 bit UNsigned)\n+instruct loadUB(rRegI dst, memory mem)\n+%{\n+  match(Set dst (LoadUB mem));\n+\n+  ins_cost(125);\n+  format %{ \"movzbl  $dst, $mem\\t# ubyte\" %}\n+\n+  ins_encode %{\n+    __ movzbl($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Byte (8 bit UNsigned) into Long Register\n+instruct loadUB2L(rRegL dst, memory mem)\n+%{\n+  match(Set dst (ConvI2L (LoadUB mem)));\n+\n+  ins_cost(125);\n+  format %{ \"movzbq  $dst, $mem\\t# ubyte -> long\" %}\n+\n+  ins_encode %{\n+    __ movzbq($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register\n+instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{\n+  match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));\n+  effect(KILL cr);\n+\n+  format %{ \"movzbq  $dst, $mem\\t# ubyte & 32-bit mask -> long\\n\\t\"\n+            \"andl    $dst, right_n_bits($mask, 8)\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    __ movzbq(Rdst, $mem$$Address);\n+    __ andl(Rdst, $mask$$constant & right_n_bits(8));\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Short (16 bit signed)\n+instruct loadS(rRegI dst, memory mem)\n+%{\n+  match(Set dst (LoadS mem));\n+\n+  ins_cost(125);\n+  format %{ \"movswl $dst, $mem\\t# short\" %}\n+\n+  ins_encode %{\n+    __ movswl($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Short (16 bit signed) to Byte (8 bit signed)\n+instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{\n+  match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));\n+\n+  ins_cost(125);\n+  format %{ \"movsbl $dst, $mem\\t# short -> byte\" %}\n+  ins_encode %{\n+    __ movsbl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Short (16 bit signed) into Long Register\n+instruct loadS2L(rRegL dst, memory mem)\n+%{\n+  match(Set dst (ConvI2L (LoadS mem)));\n+\n+  ins_cost(125);\n+  format %{ \"movswq $dst, $mem\\t# short -> long\" %}\n+\n+  ins_encode %{\n+    __ movswq($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Short\/Char (16 bit UNsigned)\n+instruct loadUS(rRegI dst, memory mem)\n+%{\n+  match(Set dst (LoadUS mem));\n+\n+  ins_cost(125);\n+  format %{ \"movzwl  $dst, $mem\\t# ushort\/char\" %}\n+\n+  ins_encode %{\n+    __ movzwl($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Short\/Char (16 bit UNsigned) to Byte (8 bit signed)\n+instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{\n+  match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));\n+\n+  ins_cost(125);\n+  format %{ \"movsbl $dst, $mem\\t# ushort -> byte\" %}\n+  ins_encode %{\n+    __ movsbl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Short\/Char (16 bit UNsigned) into Long Register\n+instruct loadUS2L(rRegL dst, memory mem)\n+%{\n+  match(Set dst (ConvI2L (LoadUS mem)));\n+\n+  ins_cost(125);\n+  format %{ \"movzwq  $dst, $mem\\t# ushort\/char -> long\" %}\n+\n+  ins_encode %{\n+    __ movzwq($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Short\/Char (16 bit UNsigned) with mask 0xFF into Long Register\n+instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{\n+  match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));\n+\n+  format %{ \"movzbq  $dst, $mem\\t# ushort\/char & 0xFF -> long\" %}\n+  ins_encode %{\n+    __ movzbq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Short\/Char (16 bit UNsigned) with 32-bit mask into Long Register\n+instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{\n+  match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));\n+  effect(KILL cr);\n+\n+  format %{ \"movzwq  $dst, $mem\\t# ushort\/char & 32-bit mask -> long\\n\\t\"\n+            \"andl    $dst, right_n_bits($mask, 16)\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    __ movzwq(Rdst, $mem$$Address);\n+    __ andl(Rdst, $mask$$constant & right_n_bits(16));\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer\n+instruct loadI(rRegI dst, memory mem)\n+%{\n+  match(Set dst (LoadI mem));\n+\n+  ins_cost(125);\n+  format %{ \"movl    $dst, $mem\\t# int\" %}\n+\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer (32 bit signed) to Byte (8 bit signed)\n+instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{\n+  match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));\n+\n+  ins_cost(125);\n+  format %{ \"movsbl  $dst, $mem\\t# int -> byte\" %}\n+  ins_encode %{\n+    __ movsbl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)\n+instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{\n+  match(Set dst (AndI (LoadI mem) mask));\n+\n+  ins_cost(125);\n+  format %{ \"movzbl  $dst, $mem\\t# int -> ubyte\" %}\n+  ins_encode %{\n+    __ movzbl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer (32 bit signed) to Short (16 bit signed)\n+instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{\n+  match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));\n+\n+  ins_cost(125);\n+  format %{ \"movswl  $dst, $mem\\t# int -> short\" %}\n+  ins_encode %{\n+    __ movswl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer (32 bit signed) to Unsigned Short\/Char (16 bit UNsigned)\n+instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{\n+  match(Set dst (AndI (LoadI mem) mask));\n+\n+  ins_cost(125);\n+  format %{ \"movzwl  $dst, $mem\\t# int -> ushort\/char\" %}\n+  ins_encode %{\n+    __ movzwl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer into Long Register\n+instruct loadI2L(rRegL dst, memory mem)\n+%{\n+  match(Set dst (ConvI2L (LoadI mem)));\n+\n+  ins_cost(125);\n+  format %{ \"movslq  $dst, $mem\\t# int -> long\" %}\n+\n+  ins_encode %{\n+    __ movslq($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer with mask 0xFF into Long Register\n+instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{\n+  match(Set dst (ConvI2L (AndI (LoadI mem) mask)));\n+\n+  format %{ \"movzbq  $dst, $mem\\t# int & 0xFF -> long\" %}\n+  ins_encode %{\n+    __ movzbq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer with mask 0xFFFF into Long Register\n+instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{\n+  match(Set dst (ConvI2L (AndI (LoadI mem) mask)));\n+\n+  format %{ \"movzwq  $dst, $mem\\t# int & 0xFFFF -> long\" %}\n+  ins_encode %{\n+    __ movzwq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Integer with a 31-bit mask into Long Register\n+instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{\n+  match(Set dst (ConvI2L (AndI (LoadI mem) mask)));\n+  effect(KILL cr);\n+\n+  format %{ \"movl    $dst, $mem\\t# int & 31-bit mask -> long\\n\\t\"\n+            \"andl    $dst, $mask\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    __ movl(Rdst, $mem$$Address);\n+    __ andl(Rdst, $mask$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Unsigned Integer into Long Register\n+instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)\n+%{\n+  match(Set dst (AndL (ConvI2L (LoadI mem)) mask));\n+\n+  ins_cost(125);\n+  format %{ \"movl    $dst, $mem\\t# uint -> long\" %}\n+\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Long\n+instruct loadL(rRegL dst, memory mem)\n+%{\n+  match(Set dst (LoadL mem));\n+\n+  ins_cost(125);\n+  format %{ \"movq    $dst, $mem\\t# long\" %}\n+\n+  ins_encode %{\n+    __ movq($dst$$Register, $mem$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+\/\/ Load Range\n+instruct loadRange(rRegI dst, memory mem)\n+%{\n+  match(Set dst (LoadRange mem));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $dst, $mem\\t# range\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Pointer\n+instruct loadP(rRegP dst, memory mem)\n+%{\n+  match(Set dst (LoadP mem));\n+  predicate(n->as_Load()->barrier_data() == 0);\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $dst, $mem\\t# ptr\" %}\n+  ins_encode %{\n+    __ movq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+\/\/ Load Compressed Pointer\n+instruct loadN(rRegN dst, memory mem)\n+%{\n+   predicate(n->as_Load()->barrier_data() == 0);\n+   match(Set dst (LoadN mem));\n+\n+   ins_cost(125); \/\/ XXX\n+   format %{ \"movl    $dst, $mem\\t# compressed ptr\" %}\n+   ins_encode %{\n+     __ movl($dst$$Register, $mem$$Address);\n+   %}\n+   ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+\n+\/\/ Load Klass Pointer\n+instruct loadKlass(rRegP dst, memory mem)\n+%{\n+  match(Set dst (LoadKlass mem));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $dst, $mem\\t# class\" %}\n+  ins_encode %{\n+    __ movq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+\/\/ Load narrow Klass Pointer\n+instruct loadNKlass(rRegN dst, memory mem)\n+%{\n+  predicate(!UseCompactObjectHeaders);\n+  match(Set dst (LoadNKlass mem));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $dst, $mem\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n+%}\n+\n+instruct loadNKlassCompactHeaders(rRegN dst, memory mem, rFlagsReg cr)\n+%{\n+  predicate(UseCompactObjectHeaders);\n+  match(Set dst (LoadNKlass mem));\n+  effect(KILL cr);\n+  ins_cost(125);\n+  format %{\n+    \"movl    $dst, $mem\\t# compressed klass ptr, shifted\\n\\t\"\n+    \"shrl    $dst, markWord::klass_shift_at_offset\"\n+  %}\n+  ins_encode %{\n+    if (UseAPX) {\n+      __ eshrl($dst$$Register, $mem$$Address, markWord::klass_shift_at_offset, false);\n+    }\n+    else {\n+      __ movl($dst$$Register, $mem$$Address);\n+      __ shrl($dst$$Register, markWord::klass_shift_at_offset);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Load Float\n+instruct loadF(regF dst, memory mem)\n+%{\n+  match(Set dst (LoadF mem));\n+\n+  ins_cost(145); \/\/ XXX\n+  format %{ \"movss   $dst, $mem\\t# float\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, $mem$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/ Load Double\n+instruct loadD_partial(regD dst, memory mem)\n+%{\n+  predicate(!UseXmmLoadAndClearUpper);\n+  match(Set dst (LoadD mem));\n+\n+  ins_cost(145); \/\/ XXX\n+  format %{ \"movlpd  $dst, $mem\\t# double\" %}\n+  ins_encode %{\n+    __ movdbl($dst$$XMMRegister, $mem$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct loadD(regD dst, memory mem)\n+%{\n+  predicate(UseXmmLoadAndClearUpper);\n+  match(Set dst (LoadD mem));\n+\n+  ins_cost(145); \/\/ XXX\n+  format %{ \"movsd   $dst, $mem\\t# double\" %}\n+  ins_encode %{\n+    __ movdbl($dst$$XMMRegister, $mem$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/ max = java.lang.Math.max(float a, float b)\n+instruct maxF_avx10_reg(regF dst, regF a, regF b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxF a b));\n+  format %{ \"maxF $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ max = java.lang.Math.max(float a, float b)\n+instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  match(Set dst (MaxF a b));\n+  effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);\n+  format %{ \"maxF $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n+  ins_encode %{\n+    __ vminmax_fp(Op_MaxV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xtmp, rRegI rtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  match(Set dst (MaxF a b));\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n+\n+  format %{ \"maxF_reduction $dst, $a, $b \\t!using $xtmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n+                    false \/*min*\/, true \/*single*\/);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ max = java.lang.Math.max(double a, double b)\n+instruct maxD_avx10_reg(regD dst, regD a, regD b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxD a b));\n+  format %{ \"maxD $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ max = java.lang.Math.max(double a, double b)\n+instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  match(Set dst (MaxD a b));\n+  effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);\n+  format %{ \"maxD $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n+  ins_encode %{\n+    __ vminmax_fp(Op_MaxV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xtmp, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  match(Set dst (MaxD a b));\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n+\n+  format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n+                    false \/*min*\/, false \/*single*\/);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ max = java.lang.Math.min(float a, float b)\n+instruct minF_avx10_reg(regF dst, regF a, regF b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinF a b));\n+  format %{ \"minF $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ min = java.lang.Math.min(float a, float b)\n+instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  match(Set dst (MinF a b));\n+  effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);\n+  format %{ \"minF $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n+  ins_encode %{\n+    __ vminmax_fp(Op_MinV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xtmp, rRegI rtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  match(Set dst (MinF a b));\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n+\n+  format %{ \"minF_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n+                    true \/*min*\/, true \/*single*\/);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ max = java.lang.Math.min(double a, double b)\n+instruct minD_avx10_reg(regD dst, regD a, regD b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinD a b));\n+  format %{ \"minD $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ min = java.lang.Math.min(double a, double b)\n+instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  match(Set dst (MinD a b));\n+  effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);\n+    format %{ \"minD $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n+  ins_encode %{\n+    __ vminmax_fp(Op_MinV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xtmp, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  match(Set dst (MinD a b));\n+  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n+\n+  format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n+                    true \/*min*\/, false \/*single*\/);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Load Effective Address\n+instruct leaP8(rRegP dst, indOffset8 mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110); \/\/ XXX\n+  format %{ \"leaq    $dst, $mem\\t# ptr 8\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaP32(rRegP dst, indOffset32 mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr 32\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPIdxOff(rRegP dst, indIndexOffset mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr idxoff\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPIdxScale(rRegP dst, indIndexScale mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr idxscale\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr idxscale\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr idxscaleoff\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr posidxoff\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)\n+%{\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr posidxscaleoff\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+\/\/ Load Effective Address which uses Narrow (32-bits) oop\n+instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::shift() != 0));\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr compressedoopoff32\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst mem);\n+\n+  ins_cost(110); \/\/ XXX\n+  format %{ \"leaq    $dst, $mem\\t# ptr off8narrow\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr off32narrow\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr idxoffnarrow\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr idxscalenarrow\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr idxscaleoffnarrow\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr posidxoffnarrow\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst mem);\n+\n+  ins_cost(110);\n+  format %{ \"leaq    $dst, $mem\\t# ptr posidxscaleoffnarrow\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg_reg_fat);\n+%}\n+\n+instruct loadConI(rRegI dst, immI src)\n+%{\n+  match(Set dst src);\n+\n+  format %{ \"movl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg_fat); \/\/ XXX\n+%}\n+\n+instruct loadConI0(rRegI dst, immI_0 src, rFlagsReg cr)\n+%{\n+  match(Set dst src);\n+  effect(KILL cr);\n+\n+  ins_cost(50);\n+  format %{ \"xorl    $dst, $dst\\t# int\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct loadConL(rRegL dst, immL src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(150);\n+  format %{ \"movq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ mov64($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)\n+%{\n+  match(Set dst src);\n+  effect(KILL cr);\n+\n+  ins_cost(50);\n+  format %{ \"xorl    $dst, $dst\\t# long\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg); \/\/ XXX\n+%}\n+\n+instruct loadConUL32(rRegL dst, immUL32 src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(60);\n+  format %{ \"movl    $dst, $src\\t# long (unsigned 32-bit)\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct loadConL32(rRegL dst, immL32 src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(70);\n+  format %{ \"movq    $dst, $src\\t# long (32-bit)\" %}\n+  ins_encode %{\n+    __ movq($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct loadConP(rRegP dst, immP con) %{\n+  match(Set dst con);\n+\n+  format %{ \"movq    $dst, $con\\t# ptr\" %}\n+  ins_encode %{\n+    __ mov64($dst$$Register, $con$$constant, $con->constant_reloc(), RELOC_IMM64);\n+  %}\n+  ins_pipe(ialu_reg_fat); \/\/ XXX\n+%}\n+\n+instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)\n+%{\n+  match(Set dst src);\n+  effect(KILL cr);\n+\n+  ins_cost(50);\n+  format %{ \"xorl    $dst, $dst\\t# ptr\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)\n+%{\n+  match(Set dst src);\n+  effect(KILL cr);\n+\n+  ins_cost(60);\n+  format %{ \"movl    $dst, $src\\t# ptr (positive 32-bit)\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct loadConF(regF dst, immF con) %{\n+  match(Set dst con);\n+  ins_cost(125);\n+  format %{ \"movss   $dst, [$constantaddress]\\t# load from constant table: float=$con\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct loadConH(regF dst, immH con) %{\n+  match(Set dst con);\n+  ins_cost(125);\n+  format %{ \"movss   $dst, [$constantaddress]\\t# load from constant table: halffloat=$con\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{\n+  match(Set dst src);\n+  effect(KILL cr);\n+  format %{ \"xorq    $dst, $src\\t# compressed null pointer\" %}\n+  ins_encode %{\n+    __ xorq($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct loadConN(rRegN dst, immN src) %{\n+  match(Set dst src);\n+\n+  ins_cost(125);\n+  format %{ \"movl    $dst, $src\\t# compressed ptr\" %}\n+  ins_encode %{\n+    address con = (address)$src$$constant;\n+    if (con == nullptr) {\n+      ShouldNotReachHere();\n+    } else {\n+      __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_fat); \/\/ XXX\n+%}\n+\n+instruct loadConNKlass(rRegN dst, immNKlass src) %{\n+  match(Set dst src);\n+\n+  ins_cost(125);\n+  format %{ \"movl    $dst, $src\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    address con = (address)$src$$constant;\n+    if (con == nullptr) {\n+      ShouldNotReachHere();\n+    } else {\n+      __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_fat); \/\/ XXX\n+%}\n+\n+instruct loadConF0(regF dst, immF0 src)\n+%{\n+  match(Set dst src);\n+  ins_cost(100);\n+\n+  format %{ \"xorps   $dst, $dst\\t# float 0.0\" %}\n+  ins_encode %{\n+    __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Use the same format since predicate() can not be used here.\n+instruct loadConD(regD dst, immD con) %{\n+  match(Set dst con);\n+  ins_cost(125);\n+  format %{ \"movsd   $dst, [$constantaddress]\\t# load from constant table: double=$con\" %}\n+  ins_encode %{\n+    __ movdbl($dst$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct loadConD0(regD dst, immD0 src)\n+%{\n+  match(Set dst src);\n+  ins_cost(100);\n+\n+  format %{ \"xorpd   $dst, $dst\\t# double 0.0\" %}\n+  ins_encode %{\n+    __ xorpd($dst$$XMMRegister, $dst$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct loadSSI(rRegI dst, stackSlotI src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(125);\n+  format %{ \"movl    $dst, $src\\t# int stk\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct loadSSL(rRegL dst, stackSlotL src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(125);\n+  format %{ \"movq    $dst, $src\\t# long stk\" %}\n+  ins_encode %{\n+    __ movq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct loadSSP(rRegP dst, stackSlotP src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(125);\n+  format %{ \"movq    $dst, $src\\t# ptr stk\" %}\n+  ins_encode %{\n+    __ movq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct loadSSF(regF dst, stackSlotF src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(125);\n+  format %{ \"movss   $dst, $src\\t# float stk\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/ Use the same format since predicate() can not be used here.\n+instruct loadSSD(regD dst, stackSlotD src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(125);\n+  format %{ \"movsd   $dst, $src\\t# double stk\" %}\n+  ins_encode  %{\n+    __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/ Prefetch instructions for allocation.\n+\/\/ Must be safe to execute with invalid address (cannot fault).\n+\n+instruct prefetchAlloc( memory mem ) %{\n+  predicate(AllocatePrefetchInstr==3);\n+  match(PrefetchAllocation mem);\n+  ins_cost(125);\n+\n+  format %{ \"PREFETCHW $mem\\t# Prefetch allocation into level 1 cache and mark modified\" %}\n+  ins_encode %{\n+    __ prefetchw($mem$$Address);\n+  %}\n+  ins_pipe(ialu_mem);\n+%}\n+\n+instruct prefetchAllocNTA( memory mem ) %{\n+  predicate(AllocatePrefetchInstr==0);\n+  match(PrefetchAllocation mem);\n+  ins_cost(125);\n+\n+  format %{ \"PREFETCHNTA $mem\\t# Prefetch allocation to non-temporal cache for write\" %}\n+  ins_encode %{\n+    __ prefetchnta($mem$$Address);\n+  %}\n+  ins_pipe(ialu_mem);\n+%}\n+\n+instruct prefetchAllocT0( memory mem ) %{\n+  predicate(AllocatePrefetchInstr==1);\n+  match(PrefetchAllocation mem);\n+  ins_cost(125);\n+\n+  format %{ \"PREFETCHT0 $mem\\t# Prefetch allocation to level 1 and 2 caches for write\" %}\n+  ins_encode %{\n+    __ prefetcht0($mem$$Address);\n+  %}\n+  ins_pipe(ialu_mem);\n+%}\n+\n+instruct prefetchAllocT2( memory mem ) %{\n+  predicate(AllocatePrefetchInstr==2);\n+  match(PrefetchAllocation mem);\n+  ins_cost(125);\n+\n+  format %{ \"PREFETCHT2 $mem\\t# Prefetch allocation to level 2 cache for write\" %}\n+  ins_encode %{\n+    __ prefetcht2($mem$$Address);\n+  %}\n+  ins_pipe(ialu_mem);\n+%}\n+\n+\/\/----------Store Instructions-------------------------------------------------\n+\n+\/\/ Store Byte\n+instruct storeB(memory mem, rRegI src)\n+%{\n+  match(Set mem (StoreB mem src));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movb    $mem, $src\\t# byte\" %}\n+  ins_encode %{\n+    __ movb($mem$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Store Char\/Short\n+instruct storeC(memory mem, rRegI src)\n+%{\n+  match(Set mem (StoreC mem src));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movw    $mem, $src\\t# char\/short\" %}\n+  ins_encode %{\n+    __ movw($mem$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Store Integer\n+instruct storeI(memory mem, rRegI src)\n+%{\n+  match(Set mem (StoreI mem src));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $mem, $src\\t# int\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Store Long\n+instruct storeL(memory mem, rRegL src)\n+%{\n+  match(Set mem (StoreL mem src));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $mem, $src\\t# long\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg); \/\/ XXX\n+%}\n+\n+\/\/ Store Pointer\n+instruct storeP(memory mem, any_RegP src)\n+%{\n+  predicate(n->as_Store()->barrier_data() == 0);\n+  match(Set mem (StoreP mem src));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeImmP0(memory mem, immP0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr) && n->as_Store()->barrier_data() == 0);\n+  match(Set mem (StoreP mem zero));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $mem, R12\\t# ptr (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Store Null Pointer, mark word, or other simple pointer constant.\n+instruct storeImmP(memory mem, immP31 src)\n+%{\n+  predicate(n->as_Store()->barrier_data() == 0);\n+  match(Set mem (StoreP mem src));\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"movq    $mem, $src\\t# ptr\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Store Compressed Pointer\n+instruct storeN(memory mem, rRegN src)\n+%{\n+  predicate(n->as_Store()->barrier_data() == 0);\n+  match(Set mem (StoreN mem src));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $mem, $src\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeNKlass(memory mem, rRegN src)\n+%{\n+  match(Set mem (StoreNKlass mem src));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $mem, $src\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeImmN0(memory mem, immN0 zero)\n+%{\n+  predicate(CompressedOops::base() == nullptr && n->as_Store()->barrier_data() == 0);\n+  match(Set mem (StoreN mem zero));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $mem, R12\\t# compressed ptr (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeImmN(memory mem, immN src)\n+%{\n+  predicate(n->as_Store()->barrier_data() == 0);\n+  match(Set mem (StoreN mem src));\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"movl    $mem, $src\\t# compressed ptr\" %}\n+  ins_encode %{\n+    address con = (address)$src$$constant;\n+    if (con == nullptr) {\n+      __ movl($mem$$Address, 0);\n+    } else {\n+      __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);\n+    }\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct storeImmNKlass(memory mem, immNKlass src)\n+%{\n+  match(Set mem (StoreNKlass mem src));\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"movl    $mem, $src\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Store Integer Immediate\n+instruct storeImmI0(memory mem, immI_0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n+  match(Set mem (StoreI mem zero));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $mem, R12\\t# int (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeImmI(memory mem, immI src)\n+%{\n+  match(Set mem (StoreI mem src));\n+\n+  ins_cost(150);\n+  format %{ \"movl    $mem, $src\\t# int\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Store Long Immediate\n+instruct storeImmL0(memory mem, immL0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n+  match(Set mem (StoreL mem zero));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movq    $mem, R12\\t# long (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeImmL(memory mem, immL32 src)\n+%{\n+  match(Set mem (StoreL mem src));\n+\n+  ins_cost(150);\n+  format %{ \"movq    $mem, $src\\t# long\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Store Short\/Char Immediate\n+instruct storeImmC0(memory mem, immI_0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n+  match(Set mem (StoreC mem zero));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movw    $mem, R12\\t# short\/char (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movw($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeImmI16(memory mem, immI16 src)\n+%{\n+  predicate(UseStoreImmI16);\n+  match(Set mem (StoreC mem src));\n+\n+  ins_cost(150);\n+  format %{ \"movw    $mem, $src\\t# short\/char\" %}\n+  ins_encode %{\n+    __ movw($mem$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Store Byte Immediate\n+instruct storeImmB0(memory mem, immI_0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n+  match(Set mem (StoreB mem zero));\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movb    $mem, R12\\t# short\/char (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movb($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeImmB(memory mem, immI8 src)\n+%{\n+  match(Set mem (StoreB mem src));\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"movb    $mem, $src\\t# byte\" %}\n+  ins_encode %{\n+    __ movb($mem$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Store Float\n+instruct storeF(memory mem, regF src)\n+%{\n+  match(Set mem (StoreF mem src));\n+\n+  ins_cost(95); \/\/ XXX\n+  format %{ \"movss   $mem, $src\\t# float\" %}\n+  ins_encode %{\n+    __ movflt($mem$$Address, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/ Store immediate Float value (it is faster than store from XMM register)\n+instruct storeF0(memory mem, immF0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n+  match(Set mem (StoreF mem zero));\n+\n+  ins_cost(25); \/\/ XXX\n+  format %{ \"movl    $mem, R12\\t# float 0. (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeF_imm(memory mem, immF src)\n+%{\n+  match(Set mem (StoreF mem src));\n+\n+  ins_cost(50);\n+  format %{ \"movl    $mem, $src\\t# float\" %}\n+  ins_encode %{\n+    __ movl($mem$$Address, jint_cast($src$$constant));\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Store Double\n+instruct storeD(memory mem, regD src)\n+%{\n+  match(Set mem (StoreD mem src));\n+\n+  ins_cost(95); \/\/ XXX\n+  format %{ \"movsd   $mem, $src\\t# double\" %}\n+  ins_encode %{\n+    __ movdbl($mem$$Address, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/ Store immediate double 0.0 (it is faster than store from XMM register)\n+instruct storeD0_imm(memory mem, immD0 src)\n+%{\n+  predicate(!UseCompressedOops || (CompressedOops::base() != nullptr));\n+  match(Set mem (StoreD mem src));\n+\n+  ins_cost(50);\n+  format %{ \"movq    $mem, $src\\t# double 0.\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct storeD0(memory mem, immD0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n+  match(Set mem (StoreD mem zero));\n+\n+  ins_cost(25); \/\/ XXX\n+  format %{ \"movq    $mem, R12\\t# double 0. (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ movq($mem$$Address, r12);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeSSI(stackSlotI dst, rRegI src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(100);\n+  format %{ \"movl    $dst, $src\\t# int stk\" %}\n+  ins_encode %{\n+    __ movl($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe( ialu_mem_reg );\n+%}\n+\n+instruct storeSSL(stackSlotL dst, rRegL src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(100);\n+  format %{ \"movq    $dst, $src\\t# long stk\" %}\n+  ins_encode %{\n+    __ movq($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeSSP(stackSlotP dst, rRegP src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(100);\n+  format %{ \"movq    $dst, $src\\t# ptr stk\" %}\n+  ins_encode %{\n+    __ movq($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct storeSSF(stackSlotF dst, regF src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(95); \/\/ XXX\n+  format %{ \"movss   $dst, $src\\t# float stk\" %}\n+  ins_encode %{\n+    __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct storeSSD(stackSlotD dst, regD src)\n+%{\n+  match(Set dst src);\n+\n+  ins_cost(95); \/\/ XXX\n+  format %{ \"movsd   $dst, $src\\t# double stk\" %}\n+  ins_encode %{\n+    __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct cacheWB(indirect addr)\n+%{\n+  predicate(VM_Version::supports_data_cache_line_flush());\n+  match(CacheWB addr);\n+\n+  ins_cost(100);\n+  format %{\"cache wb $addr\" %}\n+  ins_encode %{\n+    assert($addr->index_position() < 0, \"should be\");\n+    assert($addr$$disp == 0, \"should be\");\n+    __ cache_wb(Address($addr$$base$$Register, 0));\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct cacheWBPreSync()\n+%{\n+  predicate(VM_Version::supports_data_cache_line_flush());\n+  match(CacheWBPreSync);\n+\n+  ins_cost(100);\n+  format %{\"cache wb presync\" %}\n+  ins_encode %{\n+    __ cache_wbsync(true);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct cacheWBPostSync()\n+%{\n+  predicate(VM_Version::supports_data_cache_line_flush());\n+  match(CacheWBPostSync);\n+\n+  ins_cost(100);\n+  format %{\"cache wb postsync\" %}\n+  ins_encode %{\n+    __ cache_wbsync(false);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/----------BSWAP Instructions-------------------------------------------------\n+instruct bytes_reverse_int(rRegI dst) %{\n+  match(Set dst (ReverseBytesI dst));\n+\n+  format %{ \"bswapl  $dst\" %}\n+  ins_encode %{\n+    __ bswapl($dst$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reverse_long(rRegL dst) %{\n+  match(Set dst (ReverseBytesL dst));\n+\n+  format %{ \"bswapq  $dst\" %}\n+  ins_encode %{\n+    __ bswapq($dst$$Register);\n+  %}\n+  ins_pipe( ialu_reg);\n+%}\n+\n+instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{\n+  match(Set dst (ReverseBytesUS dst));\n+  effect(KILL cr);\n+\n+  format %{ \"bswapl  $dst\\n\\t\"\n+            \"shrl    $dst,16\\n\\t\" %}\n+  ins_encode %{\n+    __ bswapl($dst$$Register);\n+    __ shrl($dst$$Register, 16);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{\n+  match(Set dst (ReverseBytesS dst));\n+  effect(KILL cr);\n+\n+  format %{ \"bswapl  $dst\\n\\t\"\n+            \"sar     $dst,16\\n\\t\" %}\n+  ins_encode %{\n+    __ bswapl($dst$$Register);\n+    __ sarl($dst$$Register, 16);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+\/\/---------- Zeros Count Instructions ------------------------------------------\n+\n+instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{\n+  predicate(UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosI src));\n+  effect(KILL cr);\n+\n+  format %{ \"lzcntl  $dst, $src\\t# count leading zeros (int)\" %}\n+  ins_encode %{\n+    __ lzcntl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countLeadingZerosI_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosI (LoadI src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"lzcntl  $dst, $src\\t# count leading zeros (int)\" %}\n+  ins_encode %{\n+    __ lzcntl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{\n+  predicate(!UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosI src));\n+  effect(KILL cr);\n+\n+  format %{ \"bsrl    $dst, $src\\t# count leading zeros (int)\\n\\t\"\n+            \"jnz     skip\\n\\t\"\n+            \"movl    $dst, -1\\n\"\n+      \"skip:\\n\\t\"\n+            \"negl    $dst\\n\\t\"\n+            \"addl    $dst, 31\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    Register Rsrc = $src$$Register;\n+    Label skip;\n+    __ bsrl(Rdst, Rsrc);\n+    __ jccb(Assembler::notZero, skip);\n+    __ movl(Rdst, -1);\n+    __ bind(skip);\n+    __ negl(Rdst);\n+    __ addl(Rdst, BitsPerInt - 1);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{\n+  predicate(UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosL src));\n+  effect(KILL cr);\n+\n+  format %{ \"lzcntq  $dst, $src\\t# count leading zeros (long)\" %}\n+  ins_encode %{\n+    __ lzcntq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countLeadingZerosL_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosL (LoadL src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"lzcntq  $dst, $src\\t# count leading zeros (long)\" %}\n+  ins_encode %{\n+    __ lzcntq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{\n+  predicate(!UseCountLeadingZerosInstruction);\n+  match(Set dst (CountLeadingZerosL src));\n+  effect(KILL cr);\n+\n+  format %{ \"bsrq    $dst, $src\\t# count leading zeros (long)\\n\\t\"\n+            \"jnz     skip\\n\\t\"\n+            \"movl    $dst, -1\\n\"\n+      \"skip:\\n\\t\"\n+            \"negl    $dst\\n\\t\"\n+            \"addl    $dst, 63\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    Register Rsrc = $src$$Register;\n+    Label skip;\n+    __ bsrq(Rdst, Rsrc);\n+    __ jccb(Assembler::notZero, skip);\n+    __ movl(Rdst, -1);\n+    __ bind(skip);\n+    __ negl(Rdst);\n+    __ addl(Rdst, BitsPerLong - 1);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{\n+  predicate(UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosI src));\n+  effect(KILL cr);\n+\n+  format %{ \"tzcntl    $dst, $src\\t# count trailing zeros (int)\" %}\n+  ins_encode %{\n+    __ tzcntl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countTrailingZerosI_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosI (LoadI src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"tzcntl    $dst, $src\\t# count trailing zeros (int)\" %}\n+  ins_encode %{\n+    __ tzcntl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{\n+  predicate(!UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosI src));\n+  effect(KILL cr);\n+\n+  format %{ \"bsfl    $dst, $src\\t# count trailing zeros (int)\\n\\t\"\n+            \"jnz     done\\n\\t\"\n+            \"movl    $dst, 32\\n\"\n+      \"done:\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    Label done;\n+    __ bsfl(Rdst, $src$$Register);\n+    __ jccb(Assembler::notZero, done);\n+    __ movl(Rdst, BitsPerInt);\n+    __ bind(done);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{\n+  predicate(UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosL src));\n+  effect(KILL cr);\n+\n+  format %{ \"tzcntq    $dst, $src\\t# count trailing zeros (long)\" %}\n+  ins_encode %{\n+    __ tzcntq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countTrailingZerosL_mem(rRegI dst, memory src, rFlagsReg cr) %{\n+  predicate(UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosL (LoadL src)));\n+  effect(KILL cr);\n+  ins_cost(175);\n+  format %{ \"tzcntq    $dst, $src\\t# count trailing zeros (long)\" %}\n+  ins_encode %{\n+    __ tzcntq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{\n+  predicate(!UseCountTrailingZerosInstruction);\n+  match(Set dst (CountTrailingZerosL src));\n+  effect(KILL cr);\n+\n+  format %{ \"bsfq    $dst, $src\\t# count trailing zeros (long)\\n\\t\"\n+            \"jnz     done\\n\\t\"\n+            \"movl    $dst, 64\\n\"\n+      \"done:\" %}\n+  ins_encode %{\n+    Register Rdst = $dst$$Register;\n+    Label done;\n+    __ bsfq(Rdst, $src$$Register);\n+    __ jccb(Assembler::notZero, done);\n+    __ movl(Rdst, BitsPerLong);\n+    __ bind(done);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/--------------- Reverse Operation Instructions ----------------\n+instruct bytes_reversebit_int(rRegI dst, rRegI src, rRegI rtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseI src));\n+  effect(TEMP dst, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_int $dst $src\\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    __ reverseI($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_int_gfni(rRegI dst, rRegI src, vlRegF xtmp1, vlRegF xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseI src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_int $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseI($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_long(rRegL dst, rRegL src, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseL src));\n+  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, KILL cr);\n+  format %{ \"reverse_long $dst $src\\t! using $rtmp1 and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseL($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp1$$Register, $rtmp2$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_long_gfni(rRegL dst, rRegL src, vlRegD xtmp1, vlRegD xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseL src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_long $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseL($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register, noreg);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+\/\/---------- Population Count Instructions -------------------------------------\n+\n+instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{\n+  predicate(UsePopCountInstruction);\n+  match(Set dst (PopCountI src));\n+  effect(KILL cr);\n+\n+  format %{ \"popcnt  $dst, $src\" %}\n+  ins_encode %{\n+    __ popcntl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{\n+  predicate(UsePopCountInstruction);\n+  match(Set dst (PopCountI (LoadI mem)));\n+  effect(KILL cr);\n+\n+  format %{ \"popcnt  $dst, $mem\" %}\n+  ins_encode %{\n+    __ popcntl($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Note: Long.bitCount(long) returns an int.\n+instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{\n+  predicate(UsePopCountInstruction);\n+  match(Set dst (PopCountL src));\n+  effect(KILL cr);\n+\n+  format %{ \"popcnt  $dst, $src\" %}\n+  ins_encode %{\n+    __ popcntq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Note: Long.bitCount(long) returns an int.\n+instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{\n+  predicate(UsePopCountInstruction);\n+  match(Set dst (PopCountL (LoadL mem)));\n+  effect(KILL cr);\n+\n+  format %{ \"popcnt  $dst, $mem\" %}\n+  ins_encode %{\n+    __ popcntq($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\n+\/\/----------MemBar Instructions-----------------------------------------------\n+\/\/ Memory barrier flavors\n+\n+instruct membar_acquire()\n+%{\n+  match(MemBarAcquire);\n+  match(LoadFence);\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"MEMBAR-acquire ! (empty encoding)\" %}\n+  ins_encode();\n+  ins_pipe(empty);\n+%}\n+\n+instruct membar_acquire_lock()\n+%{\n+  match(MemBarAcquireLock);\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)\" %}\n+  ins_encode();\n+  ins_pipe(empty);\n+%}\n+\n+instruct membar_release()\n+%{\n+  match(MemBarRelease);\n+  match(StoreFence);\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"MEMBAR-release ! (empty encoding)\" %}\n+  ins_encode();\n+  ins_pipe(empty);\n+%}\n+\n+instruct membar_release_lock()\n+%{\n+  match(MemBarReleaseLock);\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"MEMBAR-release (a FastUnlock follows so empty encoding)\" %}\n+  ins_encode();\n+  ins_pipe(empty);\n+%}\n+\n+instruct membar_volatile(rFlagsReg cr) %{\n+  match(MemBarVolatile);\n+  effect(KILL cr);\n+  ins_cost(400);\n+\n+  format %{\n+    $$template\n+    $$emit$$\"lock addl [rsp + #0], 0\\t! membar_volatile\"\n+  %}\n+  ins_encode %{\n+    __ membar(Assembler::StoreLoad);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct unnecessary_membar_volatile()\n+%{\n+  match(MemBarVolatile);\n+  predicate(Matcher::post_store_load_barrier(n));\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"MEMBAR-volatile (unnecessary so empty encoding)\" %}\n+  ins_encode();\n+  ins_pipe(empty);\n+%}\n+\n+instruct membar_storestore() %{\n+  match(MemBarStoreStore);\n+  match(StoreStoreFence);\n+  ins_cost(0);\n+\n+  size(0);\n+  format %{ \"MEMBAR-storestore (empty encoding)\" %}\n+  ins_encode( );\n+  ins_pipe(empty);\n+%}\n+\n+\/\/----------Move Instructions--------------------------------------------------\n+\n+instruct castX2P(rRegP dst, rRegL src)\n+%{\n+  match(Set dst (CastX2P src));\n+\n+  format %{ \"movq    $dst, $src\\t# long->ptr\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movptr($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n+instruct castI2N(rRegN dst, rRegI src)\n+%{\n+  match(Set dst (CastI2N src));\n+\n+  format %{ \"movq    $dst, $src\\t# int -> narrow ptr\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movl($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n+instruct castN2X(rRegL dst, rRegN src)\n+%{\n+  match(Set dst (CastP2X src));\n+\n+  format %{ \"movq    $dst, $src\\t# ptr -> long\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movptr($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n+instruct castP2X(rRegL dst, rRegP src)\n+%{\n+  match(Set dst (CastP2X src));\n+\n+  format %{ \"movq    $dst, $src\\t# ptr -> long\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movptr($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n+\/\/ Convert oop into int for vectors alignment masking\n+instruct convP2I(rRegI dst, rRegP src)\n+%{\n+  match(Set dst (ConvL2I (CastP2X src)));\n+\n+  format %{ \"movl    $dst, $src\\t# ptr -> int\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n+\/\/ Convert compressed oop into int for vectors alignment masking\n+\/\/ in case of 32bit oops (heap < 4Gb).\n+instruct convN2I(rRegI dst, rRegN src)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  match(Set dst (ConvL2I (CastP2X (DecodeN src))));\n+\n+  format %{ \"movl    $dst, $src\\t# compressed ptr -> int\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n+\/\/ Convert oop pointer into compressed form\n+instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{\n+  predicate(n->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);\n+  match(Set dst (EncodeP src));\n+  effect(KILL cr);\n+  format %{ \"encode_heap_oop $dst,$src\" %}\n+  ins_encode %{\n+    Register s = $src$$Register;\n+    Register d = $dst$$Register;\n+    if (s != d) {\n+      __ movq(d, s);\n+    }\n+    __ encode_heap_oop(d);\n+  %}\n+  ins_pipe(ialu_reg_long);\n+%}\n+\n+instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{\n+  predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n+  match(Set dst (EncodeP src));\n+  effect(KILL cr);\n+  format %{ \"encode_heap_oop_not_null $dst,$src\" %}\n+  ins_encode %{\n+    __ encode_heap_oop_not_null($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_long);\n+%}\n+\n+instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{\n+  predicate(n->bottom_type()->is_ptr()->ptr() != TypePtr::NotNull &&\n+            n->bottom_type()->is_ptr()->ptr() != TypePtr::Constant);\n+  match(Set dst (DecodeN src));\n+  effect(KILL cr);\n+  format %{ \"decode_heap_oop $dst,$src\" %}\n+  ins_encode %{\n+    Register s = $src$$Register;\n+    Register d = $dst$$Register;\n+    if (s != d) {\n+      __ movq(d, s);\n+    }\n+    __ decode_heap_oop(d);\n+  %}\n+  ins_pipe(ialu_reg_long);\n+%}\n+\n+instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{\n+  predicate(n->bottom_type()->is_ptr()->ptr() == TypePtr::NotNull ||\n+            n->bottom_type()->is_ptr()->ptr() == TypePtr::Constant);\n+  match(Set dst (DecodeN src));\n+  effect(KILL cr);\n+  format %{ \"decode_heap_oop_not_null $dst,$src\" %}\n+  ins_encode %{\n+    Register s = $src$$Register;\n+    Register d = $dst$$Register;\n+    if (s != d) {\n+      __ decode_heap_oop_not_null(d, s);\n+    } else {\n+      __ decode_heap_oop_not_null(d);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_long);\n+%}\n+\n+instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{\n+  match(Set dst (EncodePKlass src));\n+  effect(TEMP dst, KILL cr);\n+  format %{ \"encode_and_move_klass_not_null $dst,$src\" %}\n+  ins_encode %{\n+    __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_long);\n+%}\n+\n+instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{\n+  match(Set dst (DecodeNKlass src));\n+  effect(TEMP dst, KILL cr);\n+  format %{ \"decode_and_move_klass_not_null $dst,$src\" %}\n+  ins_encode %{\n+    __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_long);\n+%}\n+\n+\/\/----------Conditional Move---------------------------------------------------\n+\/\/ Jump\n+\/\/ dummy instruction for generating temp registers\n+instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{\n+  match(Jump (LShiftL switch_val shift));\n+  ins_cost(350);\n+  predicate(false);\n+  effect(TEMP dest);\n+\n+  format %{ \"leaq    $dest, [$constantaddress]\\n\\t\"\n+            \"jmp     [$dest + $switch_val << $shift]\\n\\t\" %}\n+  ins_encode %{\n+    \/\/ We could use jump(ArrayAddress) except that the macro assembler needs to use r10\n+    \/\/ to do that and the compiler is using that register as one it can allocate.\n+    \/\/ So we build it all by hand.\n+    \/\/ Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);\n+    \/\/ ArrayAddress dispatch(table, index);\n+    Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);\n+    __ lea($dest$$Register, $constantaddress);\n+    __ jmp(dispatch);\n+  %}\n+  ins_pipe(pipe_jmp);\n+%}\n+\n+instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{\n+  match(Jump (AddL (LShiftL switch_val shift) offset));\n+  ins_cost(350);\n+  effect(TEMP dest);\n+\n+  format %{ \"leaq    $dest, [$constantaddress]\\n\\t\"\n+            \"jmp     [$dest + $switch_val << $shift + $offset]\\n\\t\" %}\n+  ins_encode %{\n+    \/\/ We could use jump(ArrayAddress) except that the macro assembler needs to use r10\n+    \/\/ to do that and the compiler is using that register as one it can allocate.\n+    \/\/ So we build it all by hand.\n+    \/\/ Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);\n+    \/\/ ArrayAddress dispatch(table, index);\n+    Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);\n+    __ lea($dest$$Register, $constantaddress);\n+    __ jmp(dispatch);\n+  %}\n+  ins_pipe(pipe_jmp);\n+%}\n+\n+instruct jumpXtnd(rRegL switch_val, rRegI dest) %{\n+  match(Jump switch_val);\n+  ins_cost(350);\n+  effect(TEMP dest);\n+\n+  format %{ \"leaq    $dest, [$constantaddress]\\n\\t\"\n+            \"jmp     [$dest + $switch_val]\\n\\t\" %}\n+  ins_encode %{\n+    \/\/ We could use jump(ArrayAddress) except that the macro assembler needs to use r10\n+    \/\/ to do that and the compiler is using that register as one it can allocate.\n+    \/\/ So we build it all by hand.\n+    \/\/ Address index(noreg, switch_reg, Address::times_1);\n+    \/\/ ArrayAddress dispatch(table, index);\n+    Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);\n+    __ lea($dest$$Register, $constantaddress);\n+    __ jmp(dispatch);\n+  %}\n+  ins_pipe(pipe_jmp);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovI_imm_01(rRegI dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# signed, int\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovl$cop $dst, $src\\t# signed, int\" %}\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_reg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_imm_01U(rRegI dst, immI_1 src, rFlagsRegU cr, cmpOpU cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, int\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovl$cop $dst, $src\\t# unsigned, int\" %}\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_regU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_imm_01UCF(rRegI dst, immI_1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, int\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovI_regU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+instruct cmovI_regUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+  effect(TEMP dst);\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n+            \"cmovnel  $dst, $src2\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n+\/\/ inputs of the CMove\n+instruct cmovI_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+  effect(TEMP dst);\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ We need this special handling for only eq \/ neq comparison since NaN == NaN is false,\n+\/\/ and parity flag bit is set if any of the operand is a NaN.\n+instruct cmovI_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src2 src1)));\n+  effect(TEMP dst);\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n+            \"cmovnel  $dst, $src2\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));\n+\n+  ins_cost(250); \/\/ XXX\n+  format %{ \"cmovl$cop $dst, $src\\t# signed, int\" %}\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovI_rReg_rReg_mem_ndd(rRegI dst, cmpOp cop, rFlagsReg cr, rRegI src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));\n+\n+  ins_cost(250); \/\/ XXX\n+  format %{ \"cmovl$cop $dst, $src\\t# unsigned, int\" %}\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));\n+  ins_cost(250);\n+  expand %{\n+    cmovI_memU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+instruct cmovI_rReg_rReg_memU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovl$cop $dst, $src\\t# signed, compressed ptr\" %}\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Conditional move ndd\n+instruct cmovN_reg_ndd(rRegN dst, rRegN src1, rRegN src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovl$cop $dst, $src\\t# unsigned, compressed ptr\" %}\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovN_regU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+\/\/ Conditional move ndd\n+instruct cmovN_regU_ndd(rRegN dst, cmpOpU cop, rFlagsRegU cr, rRegN src1, rRegN src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovN_regUCF_ndd(rRegN dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegN src1, rRegN src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovN_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n+\/\/ inputs of the CMove\n+instruct cmovN_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpl  $dst, $src\\n\\t\"\n+            \"cmovnel $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovq$cop $dst, $src\\t# signed, ptr\" %}\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);  \/\/ XXX\n+%}\n+\n+\/\/ Conditional move ndd\n+instruct cmovP_reg_ndd(rRegP dst, rRegP src1, rRegP src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Conditional move\n+instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovq$cop $dst, $src\\t# unsigned, ptr\" %}\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg); \/\/ XXX\n+%}\n+\n+\/\/ Conditional move ndd\n+instruct cmovP_regU_ndd(rRegP dst, cmpOpU cop, rFlagsRegU cr, rRegP src1, rRegP src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovP_regU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+instruct cmovP_regUCF_ndd(rRegP dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegP src1, rRegP src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovP_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovP_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+  effect(TEMP dst);\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"cmovneq  $dst, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n+\/\/ inputs of the CMove\n+instruct cmovP_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovP_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src2 src1)));\n+  effect(TEMP dst);\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"cmovneq  $dst, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# signed, long\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovq$cop $dst, $src\\t# signed, long\" %}\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);  \/\/ XXX\n+%}\n+\n+instruct cmovL_reg_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, rRegL src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovq$cop $dst, $src\\t# signed, long\" %}\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);  \/\/ XXX\n+%}\n+\n+instruct cmovL_rReg_rReg_mem_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovL_imm_01U(rRegL dst, immL1 src, rFlagsRegU cr, cmpOpU cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, long\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovq$cop $dst, $src\\t# unsigned, long\" %}\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg); \/\/ XXX\n+%}\n+\n+instruct cmovL_regU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, rRegL src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_imm_01UCF(rRegL dst, immL1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# unsigned, long\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovL_regU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+  effect(TEMP dst);\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"cmovneq  $dst, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n+\/\/ inputs of the CMove\n+instruct cmovL_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovpq  $dst, $src\\n\\t\"\n+            \"cmovneq $dst, $src\" %}\n+  ins_encode %{\n+    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src2 src1)));\n+  effect(TEMP dst);\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"cmovneq $dst, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"cmovq$cop $dst, $src\\t# unsigned, long\" %}\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem); \/\/ XXX\n+%}\n+\n+instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{\n+  predicate(!UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));\n+  ins_cost(200);\n+  expand %{\n+    cmovL_memU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+instruct cmovL_rReg_rReg_memU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)\n+%{\n+  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"jn$cop    skip\\t# signed cmove float\\n\\t\"\n+            \"movss     $dst, $src\\n\"\n+    \"skip:\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ Invert sense of branch from sense of CMOV\n+    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n+    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)\n+%{\n+  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"jn$cop    skip\\t# unsigned cmove float\\n\\t\"\n+            \"movss     $dst, $src\\n\"\n+    \"skip:\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ Invert sense of branch from sense of CMOV\n+    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n+    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{\n+  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovF_regU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)\n+%{\n+  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"jn$cop    skip\\t# signed cmove double\\n\\t\"\n+            \"movsd     $dst, $src\\n\"\n+    \"skip:\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ Invert sense of branch from sense of CMOV\n+    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n+    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)\n+%{\n+  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"jn$cop    skip\\t# unsigned cmove double\\n\\t\"\n+            \"movsd     $dst, $src\\n\"\n+    \"skip:\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ Invert sense of branch from sense of CMOV\n+    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n+    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{\n+  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovD_regU(cop, cr, dst, src);\n+  %}\n+%}\n+\n+\/\/----------Arithmetic Instructions--------------------------------------------\n+\/\/----------Addition Instructions----------------------------------------------\n+\n+instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AddI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+  format %{ \"addl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ addl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct addI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AddI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"addl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ addl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AddI dst (LoadI src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"addl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ addl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"addl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ addl($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"addl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ addl($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct incI_rReg(rRegI dst, immI_1 src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && UseIncDec);\n+  match(Set dst (AddI dst src));\n+  effect(KILL cr);\n+\n+  format %{ \"incl    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ incrementl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incI_rReg_ndd(rRegI dst, rRegI src, immI_1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI src val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eincl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incI_rReg_mem_ndd(rRegI dst, memory src, immI_1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI (LoadI src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eincl($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incI_mem(memory dst, immI_1 src, rFlagsReg cr)\n+%{\n+  predicate(UseIncDec);\n+  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n+  effect(KILL cr);\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"incl    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ incrementl($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ XXX why does that use AddI\n+instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && UseIncDec);\n+  match(Set dst (AddI dst src));\n+  effect(KILL cr);\n+\n+  format %{ \"decl    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ decrementl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decI_rReg_ndd(rRegI dst, rRegI src, immI_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI src val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ edecl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decI_rReg_mem_ndd(rRegI dst, memory src, immI_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI (LoadI src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ edecl($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ XXX why does that use AddI\n+instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)\n+%{\n+  predicate(UseIncDec);\n+  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n+  effect(KILL cr);\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"decl    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ decrementl($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct leaI_rReg_immI2_immI(rRegI dst, rRegI index, immI2 scale, immI disp)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddI (LShiftI index scale) disp));\n+\n+  format %{ \"leal $dst, [$index << $scale + $disp]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI(rRegI dst, rRegI base, rRegI index, immI disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddI (AddI base index) disp));\n+\n+  format %{ \"leal $dst, [$base + $index + $disp]\\t# int\" %}\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI2(rRegI dst, no_rbp_r13_RegI base, rRegI index, immI2 scale)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddI base (LShiftI index scale)));\n+\n+  format %{ \"leal $dst, [$base + $index << $scale]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI2_immI(rRegI dst, rRegI base, rRegI index, immI2 scale, immI disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddI (AddI base (LShiftI index scale)) disp));\n+\n+  format %{ \"leal $dst, [$base + $index << $scale + $disp]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AddL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"addq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct addL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AddL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"addq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AddL dst (LoadL src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"addq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150); \/\/ XXX\n+  format %{ \"addq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ addq($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"addq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ addq($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct incL_rReg(rRegL dst, immL1 src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && UseIncDec);\n+  match(Set dst (AddL dst src));\n+  effect(KILL cr);\n+\n+  format %{ \"incq    $dst\\t# long\" %}\n+  ins_encode %{\n+    __ incrementq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incL_rReg_ndd(rRegL dst, rRegI src, immL1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL src val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eincq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incL_rReg_mem_ndd(rRegL dst, memory src, immL1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL (LoadL src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eincq($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)\n+%{\n+  predicate(UseIncDec);\n+  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n+  effect(KILL cr);\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"incq    $dst\\t# long\" %}\n+  ins_encode %{\n+    __ incrementq($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ XXX why does that use AddL\n+instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && UseIncDec);\n+  match(Set dst (AddL dst src));\n+  effect(KILL cr);\n+\n+  format %{ \"decq    $dst\\t# long\" %}\n+  ins_encode %{\n+    __ decrementq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decL_rReg_ndd(rRegL dst, rRegL src, immL_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL src val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ edecq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decL_rReg_mem_ndd(rRegL dst, memory src, immL_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL (LoadL src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ edecq($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ XXX why does that use AddL\n+instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)\n+%{\n+  predicate(UseIncDec);\n+  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n+  effect(KILL cr);\n+\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"decq    $dst\\t# long\" %}\n+  ins_encode %{\n+    __ decrementq($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct leaL_rReg_immI2_immL32(rRegL dst, rRegL index, immI2 scale, immL32 disp)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddL (LShiftL index scale) disp));\n+\n+  format %{ \"leaq $dst, [$index << $scale + $disp]\\t# long\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immL32(rRegL dst, rRegL base, rRegL index, immL32 disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddL (AddL base index) disp));\n+\n+  format %{ \"leaq $dst, [$base + $index + $disp]\\t# long\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immI2(rRegL dst, no_rbp_r13_RegL base, rRegL index, immI2 scale)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddL base (LShiftL index scale)));\n+\n+  format %{ \"leaq $dst, [$base + $index << $scale]\\t# long\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immI2_immL32(rRegL dst, rRegL base, rRegL index, immI2 scale, immL32 disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddL (AddL base (LShiftL index scale)) disp));\n+\n+  format %{ \"leaq $dst, [$base + $index << $scale + $disp]\\t# long\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)\n+%{\n+  match(Set dst (AddP dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"addq    $dst, $src\\t# ptr\" %}\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)\n+%{\n+  match(Set dst (AddP dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"addq    $dst, $src\\t# ptr\" %}\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+\/\/ XXX addP mem ops ????\n+\n+instruct checkCastPP(rRegP dst)\n+%{\n+  match(Set dst (CheckCastPP dst));\n+\n+  size(0);\n+  format %{ \"# checkcastPP of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castPP(rRegP dst)\n+%{\n+  match(Set dst (CastPP dst));\n+\n+  size(0);\n+  format %{ \"# castPP of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castII(rRegI dst)\n+%{\n+  predicate(VerifyConstraintCasts == 0);\n+  match(Set dst (CastII dst));\n+\n+  size(0);\n+  format %{ \"# castII of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castII_checked(rRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_II $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct castLL(rRegL dst)\n+%{\n+  predicate(VerifyConstraintCasts == 0);\n+  match(Set dst (CastLL dst));\n+\n+  size(0);\n+  format %{ \"# castLL of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castLL_checked_L32(rRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_LL $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, noreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct castLL_checked(rRegL dst, rRegL tmp, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && !castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr, TEMP tmp);\n+  format %{ \"# cast_checked_LL $dst\\tusing $tmp as TEMP\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct castFF(regF dst)\n+%{\n+  match(Set dst (CastFF dst));\n+\n+  size(0);\n+  format %{ \"# castFF of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castHH(regF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castDD(regD dst)\n+%{\n+  match(Set dst (CastDD dst));\n+\n+  size(0);\n+  format %{ \"# castDD of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+\/\/ XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them\n+instruct compareAndSwapP(rRegI res,\n+                         memory mem_ptr,\n+                         rax_RegP oldval, rRegP newval,\n+                         rFlagsReg cr)\n+%{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));\n+  effect(KILL cr, KILL oldval);\n+\n+  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+    __ setcc(Assembler::equal, $res$$Register);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndSwapL(rRegI res,\n+                         memory mem_ptr,\n+                         rax_RegL oldval, rRegL newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));\n+  effect(KILL cr, KILL oldval);\n+\n+  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+    __ setcc(Assembler::equal, $res$$Register);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndSwapI(rRegI res,\n+                         memory mem_ptr,\n+                         rax_RegI oldval, rRegI newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));\n+  effect(KILL cr, KILL oldval);\n+\n+  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+    __ setcc(Assembler::equal, $res$$Register);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndSwapB(rRegI res,\n+                         memory mem_ptr,\n+                         rax_RegI oldval, rRegI newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));\n+  effect(KILL cr, KILL oldval);\n+\n+  format %{ \"cmpxchgb $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgb($newval$$Register, $mem_ptr$$Address);\n+    __ setcc(Assembler::equal, $res$$Register);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndSwapS(rRegI res,\n+                         memory mem_ptr,\n+                         rax_RegI oldval, rRegI newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));\n+  effect(KILL cr, KILL oldval);\n+\n+  format %{ \"cmpxchgw $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgw($newval$$Register, $mem_ptr$$Address);\n+    __ setcc(Assembler::equal, $res$$Register);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndSwapN(rRegI res,\n+                          memory mem_ptr,\n+                          rax_RegN oldval, rRegN newval,\n+                          rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));\n+  effect(KILL cr, KILL oldval);\n+\n+  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+    __ setcc(Assembler::equal, $res$$Register);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndExchangeB(\n+                         memory mem_ptr,\n+                         rax_RegI oldval, rRegI newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));\n+  effect(KILL cr);\n+\n+  format %{ \"cmpxchgb $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgb($newval$$Register, $mem_ptr$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndExchangeS(\n+                         memory mem_ptr,\n+                         rax_RegI oldval, rRegI newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));\n+  effect(KILL cr);\n+\n+  format %{ \"cmpxchgw $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgw($newval$$Register, $mem_ptr$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndExchangeI(\n+                         memory mem_ptr,\n+                         rax_RegI oldval, rRegI newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));\n+  effect(KILL cr);\n+\n+  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndExchangeL(\n+                         memory mem_ptr,\n+                         rax_RegL oldval, rRegL newval,\n+                         rFlagsReg cr)\n+%{\n+  match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));\n+  effect(KILL cr);\n+\n+  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndExchangeN(\n+                          memory mem_ptr,\n+                          rax_RegN oldval, rRegN newval,\n+                          rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));\n+  effect(KILL cr);\n+\n+  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct compareAndExchangeP(\n+                         memory mem_ptr,\n+                         rax_RegP oldval, rRegP newval,\n+                         rFlagsReg cr)\n+%{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));\n+  effect(KILL cr);\n+\n+  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n+            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct xaddB_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddB mem add));\n+  effect(KILL cr);\n+  format %{ \"addb_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addb($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddB_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddB mem add));\n+  effect(KILL cr);\n+  format %{ \"addb_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addb($mem$$Address, $add$$constant);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddB(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n+  match(Set newval (GetAndAddB mem newval));\n+  effect(KILL cr);\n+  format %{ \"xaddb_lock  $mem, $newval\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ xaddb($mem$$Address, $newval$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddS_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddS mem add));\n+  effect(KILL cr);\n+  format %{ \"addw_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addw($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddS_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(UseStoreImmI16 && n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddS mem add));\n+  effect(KILL cr);\n+  format %{ \"addw_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addw($mem$$Address, $add$$constant);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddS(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n+  match(Set newval (GetAndAddS mem newval));\n+  effect(KILL cr);\n+  format %{ \"xaddw_lock  $mem, $newval\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ xaddw($mem$$Address, $newval$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddI_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddI mem add));\n+  effect(KILL cr);\n+  format %{ \"addl_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addl($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddI_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddI mem add));\n+  effect(KILL cr);\n+  format %{ \"addl_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addl($mem$$Address, $add$$constant);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddI(memory mem, rRegI newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n+  match(Set newval (GetAndAddI mem newval));\n+  effect(KILL cr);\n+  format %{ \"xaddl_lock  $mem, $newval\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ xaddl($mem$$Address, $newval$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddL_reg_no_res(memory mem, Universe dummy, rRegL add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddL mem add));\n+  effect(KILL cr);\n+  format %{ \"addq_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addq($mem$$Address, $add$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddL_imm_no_res(memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{\n+  predicate(n->as_LoadStore()->result_not_used());\n+  match(Set dummy (GetAndAddL mem add));\n+  effect(KILL cr);\n+  format %{ \"addq_lock   $mem, $add\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ addq($mem$$Address, $add$$constant);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xaddL(memory mem, rRegL newval, rFlagsReg cr) %{\n+  predicate(!n->as_LoadStore()->result_not_used());\n+  match(Set newval (GetAndAddL mem newval));\n+  effect(KILL cr);\n+  format %{ \"xaddq_lock  $mem, $newval\" %}\n+  ins_encode %{\n+    __ lock();\n+    __ xaddq($mem$$Address, $newval$$Register);\n+  %}\n+  ins_pipe(pipe_cmpxchg);\n+%}\n+\n+instruct xchgB( memory mem, rRegI newval) %{\n+  match(Set newval (GetAndSetB mem newval));\n+  format %{ \"XCHGB  $newval,[$mem]\" %}\n+  ins_encode %{\n+    __ xchgb($newval$$Register, $mem$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct xchgS( memory mem, rRegI newval) %{\n+  match(Set newval (GetAndSetS mem newval));\n+  format %{ \"XCHGW  $newval,[$mem]\" %}\n+  ins_encode %{\n+    __ xchgw($newval$$Register, $mem$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct xchgI( memory mem, rRegI newval) %{\n+  match(Set newval (GetAndSetI mem newval));\n+  format %{ \"XCHGL  $newval,[$mem]\" %}\n+  ins_encode %{\n+    __ xchgl($newval$$Register, $mem$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct xchgL( memory mem, rRegL newval) %{\n+  match(Set newval (GetAndSetL mem newval));\n+  format %{ \"XCHGL  $newval,[$mem]\" %}\n+  ins_encode %{\n+    __ xchgq($newval$$Register, $mem$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct xchgP( memory mem, rRegP newval) %{\n+  match(Set newval (GetAndSetP mem newval));\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  format %{ \"XCHGQ  $newval,[$mem]\" %}\n+  ins_encode %{\n+    __ xchgq($newval$$Register, $mem$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+instruct xchgN( memory mem, rRegN newval) %{\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n+  match(Set newval (GetAndSetN mem newval));\n+  format %{ \"XCHGL  $newval,$mem]\" %}\n+  ins_encode %{\n+    __ xchgl($newval$$Register, $mem$$Address);\n+  %}\n+  ins_pipe( pipe_cmpxchg );\n+%}\n+\n+\/\/----------Abs Instructions-------------------------------------------\n+\n+\/\/ Integer Absolute Instructions\n+instruct absI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (AbsI src));\n+  effect(TEMP dst, KILL cr);\n+  format %{ \"xorl    $dst, $dst\\t# abs int\\n\\t\"\n+            \"subl    $dst, $src\\n\\t\"\n+            \"cmovll  $dst, $src\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+    __ subl($dst$$Register, $src$$Register);\n+    __ cmovl(Assembler::less, $dst$$Register, $src$$Register);\n+  %}\n+\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Long Absolute Instructions\n+instruct absL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  match(Set dst (AbsL src));\n+  effect(TEMP dst, KILL cr);\n+  format %{ \"xorl    $dst, $dst\\t# abs long\\n\\t\"\n+            \"subq    $dst, $src\\n\\t\"\n+            \"cmovlq  $dst, $src\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+    __ subq($dst$$Register, $src$$Register);\n+    __ cmovq(Assembler::less, $dst$$Register, $src$$Register);\n+  %}\n+\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/----------Subtraction Instructions-------------------------------------------\n+\n+\/\/ Integer Subtraction Instructions\n+instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (SubI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"subl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ subl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (SubI dst (LoadI src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"subl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ subl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (SubI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"subl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ subl($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (SubL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"subq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ subq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (SubL dst (LoadL src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"subq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ subq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (SubL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"subq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ subq($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Subtract from a pointer\n+\/\/ XXX hmpf???\n+instruct subP_rReg(rRegP dst, rRegI src, immI_0 zero, rFlagsReg cr)\n+%{\n+  match(Set dst (AddP dst (SubI zero src)));\n+  effect(KILL cr);\n+\n+  format %{ \"subq    $dst, $src\\t# ptr - int\" %}\n+  ins_encode %{\n+    __ subq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct negI_rReg(rRegI dst, immI_0 zero, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (SubI zero dst));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"negl    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ negl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negI_rReg_ndd(rRegI dst, rRegI src, immI_0 zero, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI zero src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ enegl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negI_rReg_2(rRegI dst, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (NegI dst));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"negl    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ negl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negI_rReg_2_ndd(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (NegI src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ enegl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negI_mem(memory dst, immI_0 zero, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (SubI zero (LoadI dst))));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"negl    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ negl($dst$$Address);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (SubL zero dst));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"negq    $dst\\t# long\" %}\n+  ins_encode %{\n+    __ negq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negL_rReg_ndd(rRegL dst, rRegL src, immL0 zero, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL zero src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ enegq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negL_rReg_2(rRegL dst, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (NegL dst));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"negq    $dst\\t# int\" %}\n+  ins_encode %{\n+    __ negq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negL_rReg_2_ndd(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (NegL src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ enegq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (SubL zero (LoadL dst))));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"negq    $dst\\t# long\" %}\n+  ins_encode %{\n+    __ negq($dst$$Address);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/----------Multiplication\/Division Instructions-------------------------------\n+\/\/ Integer Multiplication Instructions\n+\/\/ Multiply Register\n+\n+instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (MulI dst src));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"imull   $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct mulI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)\n+%{\n+  match(Set dst (MulI src imm));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"imull   $dst, $src, $imm\\t# int\" %}\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Register, $imm$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (MulI dst (LoadI src)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"imull   $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 (LoadI src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)\n+%{\n+  match(Set dst (MulI (LoadI src) imm));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"imull   $dst, $src, $imm\\t# int\" %}\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Address, $imm$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)\n+%{\n+  match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));\n+  effect(KILL cr, KILL src2);\n+\n+  expand %{ mulI_rReg(dst, src1, cr);\n+           mulI_rReg(src2, src3, cr);\n+           addI_rReg(dst, src2, cr); %}\n+%}\n+\n+instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (MulL dst src));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"imulq   $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct mulL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)\n+%{\n+  match(Set dst (MulL src imm));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Register, $imm$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (MulL dst (LoadL src)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"imulq   $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 (LoadL src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"eimulq   $dst, $src1, $src2 \\t# long\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)\n+%{\n+  match(Set dst (MulL (LoadL src) imm));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n+%{\n+  match(Set dst (MulHiL src rax));\n+  effect(USE_KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"imulq   RDX:RAX, RAX, $src\\t# mulhi\" %}\n+  ins_encode %{\n+    __ imulq($src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct umulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n+%{\n+  match(Set dst (UMulHiL src rax));\n+  effect(USE_KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"mulq   RDX:RAX, RAX, $src\\t# umulhi\" %}\n+  ins_encode %{\n+    __ mulq($src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,\n+                   rFlagsReg cr)\n+%{\n+  match(Set rax (DivI rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpl    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdql\\n\\t\"\n+            \"idivl   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdql_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,\n+                   rFlagsReg cr)\n+%{\n+  match(Set rax (DivL rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n+            \"cmpq    rax, rdx\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpq    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdqq\\n\\t\"\n+            \"idivq   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdqq_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct udivI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div, rFlagsReg cr)\n+%{\n+  match(Set rax (UDivI rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivl $rax,$rax,$div\\t# UDivI\\n\" %}\n+  ins_encode %{\n+    __ udivI($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct udivL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div, rFlagsReg cr)\n+%{\n+  match(Set rax (UDivL rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivq $rax,$rax,$div\\t# UDivL\\n\" %}\n+  ins_encode %{\n+     __ udivL($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+\/\/ Integer DIVMOD with Register, both quotient and mod results\n+instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,\n+                             rFlagsReg cr)\n+%{\n+  match(DivModI rax div);\n+  effect(KILL cr);\n+\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpl    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdql\\n\\t\"\n+            \"idivl   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdql_enc(div));\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Long DIVMOD with Register, both quotient and mod results\n+instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,\n+                             rFlagsReg cr)\n+%{\n+  match(DivModL rax div);\n+  effect(KILL cr);\n+\n+  ins_cost(30*100+10*100); \/\/ XXX\n+  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n+            \"cmpq    rax, rdx\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpq    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdqq\\n\\t\"\n+            \"idivq   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdqq_enc(div));\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Unsigned integer DIVMOD with Register, both quotient and mod results\n+instruct udivModI_rReg_divmod(rax_RegI rax, no_rax_rdx_RegI tmp, rdx_RegI rdx,\n+                              no_rax_rdx_RegI div, rFlagsReg cr)\n+%{\n+  match(UDivModI rax div);\n+  effect(TEMP tmp, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivl $rax,$rax,$div\\t# begin UDivModI\\n\\t\"\n+            \"umodl $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModI\\n\"\n+          %}\n+  ins_encode %{\n+    __ udivmodI($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Unsigned long DIVMOD with Register, both quotient and mod results\n+instruct udivModL_rReg_divmod(rax_RegL rax, no_rax_rdx_RegL tmp, rdx_RegL rdx,\n+                              no_rax_rdx_RegL div, rFlagsReg cr)\n+%{\n+  match(UDivModL rax div);\n+  effect(TEMP tmp, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivq $rax,$rax,$div\\t# begin UDivModL\\n\\t\"\n+            \"umodq $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModL\\n\"\n+          %}\n+  ins_encode %{\n+    __ udivmodL($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,\n+                   rFlagsReg cr)\n+%{\n+  match(Set rdx (ModI rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300); \/\/ XXX\n+  format %{ \"cmpl    rax, 0x80000000\\t# irem\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpl    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdql\\n\\t\"\n+            \"idivl   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdql_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,\n+                   rFlagsReg cr)\n+%{\n+  match(Set rdx (ModL rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300); \/\/ XXX\n+  format %{ \"movq    rdx, 0x8000000000000000\\t# lrem\\n\\t\"\n+            \"cmpq    rax, rdx\\n\\t\"\n+            \"jne,s   normal\\n\\t\"\n+            \"xorl    rdx, rdx\\n\\t\"\n+            \"cmpq    $div, -1\\n\\t\"\n+            \"je,s    done\\n\"\n+    \"normal: cdqq\\n\\t\"\n+            \"idivq   $div\\n\"\n+    \"done:\"        %}\n+  ins_encode(cdqq_enc(div));\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct umodI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div, rFlagsReg cr)\n+%{\n+  match(Set rdx (UModI rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"umodl $rdx,$rax,$div\\t# UModI\\n\" %}\n+  ins_encode %{\n+    __ umodI($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct umodL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div, rFlagsReg cr)\n+%{\n+  match(Set rdx (UModL rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"umodq $rdx,$rax,$div\\t# UModL\\n\" %}\n+  ins_encode %{\n+    __ umodL($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+\/\/ Integer Shift Instructions\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2(rRegI dst, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2_ndd(rRegI dst, rRegI src, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int(ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by 8-bit immediate\n+instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by 8-bit immediate\n+instruct salI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct salI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by 8-bit immediate\n+instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Shift Left by variable\n+instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Shift Left by variable\n+instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct salI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftI src shift));\n+\n+  format %{ \"shlxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxl($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct salI_mem_rReg(rRegI dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftI (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"shlxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxl($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (RShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sarl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarl($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esarl($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct sarI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esarl($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"sarl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarl($dst$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Arithmetic Shift Right by variable\n+instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (RShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sarl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Arithmetic Shift Right by variable\n+instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"sarl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarl($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct sarI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftI src shift));\n+\n+  format %{ \"sarxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxl($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct sarI_mem_rReg(rRegI dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftI (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"sarxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxl($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (URShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"shrl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrl($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n+  ins_encode %{\n+    __ eshrl($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct shrI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n+  ins_encode %{\n+    __ eshrl($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"shrl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrl($dst$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Logical Shift Right by variable\n+instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (URShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"shrl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Logical Shift Right by variable\n+instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"shrl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrl($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct shrI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftI src shift));\n+\n+  format %{ \"shrxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxl($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct shrI_mem_rReg(rRegI dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftI (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"shrxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxl($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Long Shift Instructions\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2(rRegL dst, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2_ndd(rRegL dst, rRegL src, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by 8-bit immediate\n+instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by 8-bit immediate\n+instruct salL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct salL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Shift Left by 8-bit immediate\n+instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Shift Left by variable\n+instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Shift Left by variable\n+instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct salL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftL src shift));\n+\n+  format %{ \"shlxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxq($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct salL_mem_rReg(rRegL dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (LShiftL (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"shlxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shlxq($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarL_rReg_imm(rRegL dst, immI shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (RShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sarq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarq($dst$$Register, (unsigned char)($shift$$constant & 0x3F));\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarL_rReg_imm_ndd(rRegL dst, rRegL src, immI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esarq($dst$$Register, $src$$Register, (unsigned char)($shift$$constant & 0x3F), false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct sarL_rReg_mem_imm_ndd(rRegL dst, memory src, immI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esarq($dst$$Register, $src$$Address, (unsigned char)($shift$$constant & 0x3F), false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarL_mem_imm(memory dst, immI shift, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"sarq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarq($dst$$Address, (unsigned char)($shift$$constant & 0x3F));\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Arithmetic Shift Right by variable\n+instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (RShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sarq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Arithmetic Shift Right by variable\n+instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"sarq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sarq($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct sarL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftL src shift));\n+\n+  format %{ \"sarxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxq($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct sarL_mem_rReg(rRegL dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (RShiftL (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"sarxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ sarxq($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (URShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"shrq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ eshrq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct shrL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ eshrq($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"shrq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrq($dst$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Logical Shift Right by variable\n+instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (URShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"shrq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Logical Shift Right by variable\n+instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2());\n+  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));\n+  effect(KILL cr);\n+\n+  format %{ \"shrq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ shrq($dst$$Address);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct shrL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftL src shift));\n+\n+  format %{ \"shrxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxq($dst$$Register, $src$$Register, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct shrL_mem_rReg(rRegL dst, memory src, rRegI shift)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  match(Set dst (URShiftL (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"shrxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ shrxq($dst$$Register, $src$$Address, $shift$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.\n+\/\/ This idiom is used by the compiler for the i2b bytecode.\n+instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)\n+%{\n+  match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));\n+\n+  format %{ \"movsbl  $dst, $src\\t# i2b\" %}\n+  ins_encode %{\n+    __ movsbl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.\n+\/\/ This idiom is used by the compiler the i2s bytecode.\n+instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)\n+%{\n+  match(Set dst (RShiftI (LShiftI src sixteen) sixteen));\n+\n+  format %{ \"movswl  $dst, $src\\t# i2s\" %}\n+  ins_encode %{\n+    __ movswl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ ROL\/ROR instructions\n+\n+\/\/ Rotate left by constant.\n+instruct rolI_immI8_legacy(rRegI dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n+  format %{ \"roll    $dst, $shift\" %}\n+  ins_encode %{\n+    __ roll($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct rolI_immI8(rRegI dst, rRegI src, immI8 shift)\n+%{\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft src shift));\n+  format %{ \"rolxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 32 - ($shift$$constant & 31);\n+    __ rorxl($dst$$Register, $src$$Register, shift);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rolI_mem_immI8(rRegI dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"rolxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 32 - ($shift$$constant & 31);\n+    __ rorxl($dst$$Register, $src$$Address, shift);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Rotate Left by variable\n+instruct rolI_rReg_Var(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n+  format %{ \"roll    $dst, $shift\" %}\n+  ins_encode %{\n+    __ roll($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Rotate Left by variable\n+instruct rolI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eroll    $dst, $src, $shift\\t# rotate left (int ndd)\" %}\n+  ins_encode %{\n+    __ eroll($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Rotate Right by constant.\n+instruct rorI_immI8_legacy(rRegI dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n+  format %{ \"rorl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorl($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Rotate Right by constant.\n+instruct rorI_immI8(rRegI dst, rRegI src, immI8 shift)\n+%{\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight src shift));\n+  format %{ \"rorxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ rorxl($dst$$Register, $src$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rorI_mem_immI8(rRegI dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight (LoadI src) shift));\n+  ins_cost(175);\n+  format %{ \"rorxl   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ rorxl($dst$$Register, $src$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Rotate Right by variable\n+instruct rorI_rReg_Var(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n+  format %{ \"rorl    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Rotate Right by variable\n+instruct rorI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erorl    $dst, $src, $shift\\t# rotate right(int ndd)\" %}\n+  ins_encode %{\n+    __ erorl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Rotate Left by constant.\n+instruct rolL_immI8_legacy(rRegL dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n+  format %{ \"rolq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rolq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct rolL_immI8(rRegL dst, rRegL src, immI8 shift)\n+%{\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft src shift));\n+  format %{ \"rolxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 64 - ($shift$$constant & 63);\n+    __ rorxq($dst$$Register, $src$$Register, shift);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rolL_mem_immI8(rRegL dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"rolxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    int shift = 64 - ($shift$$constant & 63);\n+    __ rorxq($dst$$Register, $src$$Address, shift);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Rotate Left by variable\n+instruct rolL_rReg_Var(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft dst shift));\n+  effect(KILL cr);\n+  format %{ \"rolq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rolq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Rotate Left by variable\n+instruct rolL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erolq    $dst, $src, $shift\\t# rotate left(long ndd)\" %}\n+  ins_encode %{\n+    __ erolq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Rotate Right by constant.\n+instruct rorL_immI8_legacy(rRegL dst, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n+  format %{ \"rorq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Rotate Right by constant\n+instruct rorL_immI8(rRegL dst, rRegL src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight src shift));\n+  format %{ \"rorxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ rorxq($dst$$Register, $src$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rorL_mem_immI8(rRegL dst, memory src, immI8 shift)\n+%{\n+  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight (LoadL src) shift));\n+  ins_cost(175);\n+  format %{ \"rorxq   $dst, $src, $shift\" %}\n+  ins_encode %{\n+    __ rorxq($dst$$Register, $src$$Address, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Rotate Right by variable\n+instruct rorL_rReg_Var(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight dst shift));\n+  effect(KILL cr);\n+  format %{ \"rorq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ rorq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Rotate Right by variable\n+instruct rorL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erorq    $dst, $src, $shift\\t# rotate right(long ndd)\" %}\n+  ins_encode %{\n+    __ erorq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/----------------------------- CompressBits\/ExpandBits ------------------------\n+\n+instruct compressBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (CompressBits src mask));\n+  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextq($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (ExpandBits src mask));\n+  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepq($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct compressBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (CompressBits src (LoadL mask)));\n+  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextq($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (ExpandBits src (LoadL mask)));\n+  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepq($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+\/\/ Logical Instructions\n+\n+\/\/ Integer Logical Instructions\n+\n+\/\/ And Instructions\n+\/\/ And Register with Register\n+instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AndI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"andl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ andl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ And Register with Register using New Data Destination (NDD)\n+instruct andI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ And Register with Immediate 255\n+instruct andI_rReg_imm255(rRegI dst, rRegI src, immI_255 mask)\n+%{\n+  match(Set dst (AndI src mask));\n+\n+  format %{ \"movzbl  $dst, $src\\t# int & 0xFF\" %}\n+  ins_encode %{\n+    __ movzbl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ And Register with Immediate 255 and promote to long\n+instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)\n+%{\n+  match(Set dst (ConvI2L (AndI src mask)));\n+\n+  format %{ \"movzbl  $dst, $src\\t# int & 0xFF -> long\" %}\n+  ins_encode %{\n+    __ movzbl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ And Register with Immediate 65535\n+instruct andI_rReg_imm65535(rRegI dst, rRegI src, immI_65535 mask)\n+%{\n+  match(Set dst (AndI src mask));\n+\n+  format %{ \"movzwl  $dst, $src\\t# int & 0xFFFF\" %}\n+  ins_encode %{\n+    __ movzwl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ And Register with Immediate 65535 and promote to long\n+instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)\n+%{\n+  match(Set dst (ConvI2L (AndI src mask)));\n+\n+  format %{ \"movzwl  $dst, $src\\t# int & 0xFFFF -> long\" %}\n+  ins_encode %{\n+    __ movzwl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Can skip int2long conversions after AND with small bitmask\n+instruct convI2LAndI_reg_immIbitmask(rRegL dst, rRegI src,  immI_Pow2M1 mask, rRegI tmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  ins_cost(125);\n+  effect(TEMP tmp, KILL cr);\n+  match(Set dst (ConvI2L (AndI src mask)));\n+  format %{ \"bzhiq $dst, $src, $mask \\t# using $tmp as TEMP, int &  immI_Pow2M1 -> long\" %}\n+  ins_encode %{\n+    __ movl($tmp$$Register, exact_log2($mask$$constant + 1));\n+    __ bzhiq($dst$$Register, $src$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ And Register with Immediate\n+instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AndI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"andl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ andl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ And Register with Memory\n+instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AndI dst (LoadI src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"andl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ andl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct andI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ And Memory with Register\n+instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreB dst (AndI (LoadB dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"andb    $dst, $src\\t# byte\" %}\n+  ins_encode %{\n+    __ andb($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (AndI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"andl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ andl($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ And Memory with Immediate\n+instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (AndI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"andl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ andl($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ BMI1 instructions\n+instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{\n+  match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"andnl  $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ andnl($dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{\n+  match(Set dst (AndI (XorI src1 minus_1) src2));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"andnl  $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ andnl($dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI_0 imm_zero, rFlagsReg cr) %{\n+  match(Set dst (AndI (SubI imm_zero src) src));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  format %{ \"blsil  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsil($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct blsiI_rReg_mem(rRegI dst, memory src, immI_0 imm_zero, rFlagsReg cr) %{\n+  match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  ins_cost(125);\n+  format %{ \"blsil  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsil($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  ins_cost(125);\n+  format %{ \"blsmskl $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsmskl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (XorI (AddI src minus_1) src));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  format %{ \"blsmskl $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsmskl($dst$$Register, $src$$Register);\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (AndI (AddI src minus_1) src) );\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  format %{ \"blsrl  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsrl($dst$$Register, $src$$Register);\n+  %}\n+\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  ins_cost(125);\n+  format %{ \"blsrl  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsrl($dst$$Register, $src$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Or Instructions\n+\/\/ Or Register with Register\n+instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (OrI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"orl     $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Or Register with Register using New Data Destination (NDD)\n+instruct orI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Or Register with Immediate\n+instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (OrI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"orl     $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_imm_rReg_ndd(rRegI dst, immI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src2, $src1\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src2$$Register, $src1$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Or Register with Memory\n+instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (OrI dst (LoadI src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"orl     $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct orI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Or Memory with Register\n+instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreB dst (OrI (LoadB dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"orb    $dst, $src\\t# byte\" %}\n+  ins_encode %{\n+    __ orb($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (OrI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"orl     $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ orl($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Or Memory with Immediate\n+instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (OrI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"orl     $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ orl($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Xor Instructions\n+\/\/ Xor Register with Register\n+instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (XorI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"xorl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Xor Register with Register using New Data Destination (NDD)\n+instruct xorI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Xor Register with Immediate -1\n+instruct xorI_rReg_im1(rRegI dst, immI_M1 imm)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (XorI dst imm));\n+\n+  format %{ \"notl    $dst\" %}\n+  ins_encode %{\n+     __ notl($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct xorI_rReg_im1_ndd(rRegI dst, rRegI src, immI_M1 imm)\n+%{\n+  match(Set dst (XorI src imm));\n+  predicate(UseAPX);\n+\n+  format %{ \"enotl    $dst, $src\" %}\n+  ins_encode %{\n+     __ enotl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Register with Immediate\n+instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n+%{\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1 cost agnostic if immI src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n+  match(Set dst (XorI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"xorl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct xorI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1_ndd cost agnostic if immI src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n+  match(Set dst (XorI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI (LoadI src1) src2));\n+  effect(KILL cr);\n+  ins_cost(150);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Register with Memory\n+instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (XorI dst (LoadI src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"xorl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct xorI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Xor Memory with Register\n+instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreB dst (XorI (LoadB dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"xorb    $dst, $src\\t# byte\" %}\n+  ins_encode %{\n+    __ xorb($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (XorI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"xorl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreI dst (XorI (LoadI dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"xorl    $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ xorl($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\n+\/\/ Long Logical Instructions\n+\n+\/\/ And Instructions\n+\/\/ And Register with Register\n+instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AndL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"andq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ andq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ And Register with Register using New Data Destination (NDD)\n+instruct andL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ And Register with Immediate 255\n+instruct andL_rReg_imm255(rRegL dst, rRegL src, immL_255 mask)\n+%{\n+  match(Set dst (AndL src mask));\n+\n+  format %{ \"movzbl  $dst, $src\\t# long & 0xFF\" %}\n+  ins_encode %{\n+    \/\/ movzbl zeroes out the upper 32-bit and does not need REX.W\n+    __ movzbl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ And Register with Immediate 65535\n+instruct andL_rReg_imm65535(rRegL dst, rRegL src, immL_65535 mask)\n+%{\n+  match(Set dst (AndL src mask));\n+\n+  format %{ \"movzwl  $dst, $src\\t# long & 0xFFFF\" %}\n+  ins_encode %{\n+    \/\/ movzwl zeroes out the upper 32-bit and does not need REX.W\n+    __ movzwl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ And Register with Immediate\n+instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AndL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"andq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ andq($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ And Register with Memory\n+instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (AndL dst (LoadL src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"andq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ andq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct andL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ And Memory with Register\n+instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (AndL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"andq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ andq($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ And Memory with Immediate\n+instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (AndL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"andq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ andq($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)\n+%{\n+  \/\/ con should be a pure 64-bit immediate given that not(con) is a power of 2\n+  \/\/ because AND\/OR works well enough for 8\/32-bit values.\n+  predicate(log2i_graceful(~n->in(3)->in(2)->get_long()) > 30);\n+\n+  match(Set dst (StoreL dst (AndL (LoadL dst) con)));\n+  effect(KILL cr);\n+\n+  ins_cost(125);\n+  format %{ \"btrq    $dst, log2(not($con))\\t# long\" %}\n+  ins_encode %{\n+    __ btrq($dst$$Address, log2i_exact((julong)~$con$$constant));\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ BMI1 instructions\n+instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{\n+  match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"andnq  $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ andnq($dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{\n+  match(Set dst (AndL (XorL src1 minus_1) src2));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"andnq  $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+  __ andnq($dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{\n+  match(Set dst (AndL (SubL imm_zero src) src));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  format %{ \"blsiq  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsiq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{\n+  match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  ins_cost(125);\n+  format %{ \"blsiq  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsiq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  ins_cost(125);\n+  format %{ \"blsmskq $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsmskq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (XorL (AddL src minus_1) src));\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  format %{ \"blsmskq $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsmskq($dst$$Register, $src$$Register);\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (AndL (AddL src minus_1) src) );\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  format %{ \"blsrq  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsrq($dst$$Register, $src$$Register);\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)\n+%{\n+  match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );\n+  predicate(UseBMI1Instructions);\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n+\n+  ins_cost(125);\n+  format %{ \"blsrq  $dst, $src\" %}\n+\n+  ins_encode %{\n+    __ blsrq($dst$$Register, $src$$Address);\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Or Instructions\n+\/\/ Or Register with Register\n+instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (OrL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"orq     $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Or Register with Register using New Data Destination (NDD)\n+instruct orL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Use any_RegP to match R15 (TLS register) without spilling.\n+instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{\n+  match(Set dst (OrL dst (CastP2X src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"orq     $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct orL_rReg_castP2X_ndd(rRegL dst, any_RegP src1, any_RegP src2, rFlagsReg cr) %{\n+  match(Set dst (OrL src1 (CastP2X src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Or Register with Immediate\n+instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (OrL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"orq     $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orL_rReg_imm_rReg_ndd(rRegL dst, immL32 src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src2, $src1\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src2$$Register, $src1$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Or Memory with Immediate\n+instruct orL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Or Register with Memory\n+instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (OrL dst (LoadL src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"orq     $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct orL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Or Memory with Register\n+instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (OrL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"orq     $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ orq($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Or Memory with Immediate\n+instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (OrL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"orq     $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ orq($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)\n+%{\n+  \/\/ con should be a pure 64-bit power of 2 immediate\n+  \/\/ because AND\/OR works well enough for 8\/32-bit values.\n+  predicate(log2i_graceful(n->in(3)->in(2)->get_long()) > 31);\n+\n+  match(Set dst (StoreL dst (OrL (LoadL dst) con)));\n+  effect(KILL cr);\n+\n+  ins_cost(125);\n+  format %{ \"btsq    $dst, log2($con)\\t# long\" %}\n+  ins_encode %{\n+    __ btsq($dst$$Address, log2i_exact((julong)$con$$constant));\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+\/\/ Xor Instructions\n+\/\/ Xor Register with Register\n+instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (XorL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"xorq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ xorq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Xor Register with Register using New Data Destination (NDD)\n+instruct xorL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Xor Register with Immediate -1\n+instruct xorL_rReg_im1(rRegL dst, immL_M1 imm)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (XorL dst imm));\n+\n+  format %{ \"notq   $dst\" %}\n+  ins_encode %{\n+     __ notq($dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct xorL_rReg_im1_ndd(rRegL dst,rRegL src, immL_M1 imm)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src imm));\n+\n+  format %{ \"enotq   $dst, $src\" %}\n+  ins_encode %{\n+    __ enotq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Register with Immediate\n+instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n+%{\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1 cost agnostic if immL32 src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n+  match(Set dst (XorL dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"xorq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ xorq($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct xorL_rReg_rReg_imm(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1_ndd cost agnostic if immL32 src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n+  match(Set dst (XorL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorL_rReg_mem_imm(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+  ins_cost(150);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Register with Memory\n+instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (XorL dst (LoadL src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"xorq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ xorq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct xorL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+\/\/ Xor Memory with Register\n+instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (XorL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"xorq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ xorq($dst$$Address, $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n+%{\n+  match(Set dst (StoreL dst (XorL (LoadL dst) src)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(125);\n+  format %{ \"xorq    $dst, $src\\t# long\" %}\n+  ins_encode %{\n+    __ xorq($dst$$Address, $src$$constant);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)\n+%{\n+  match(Set dst (CmpLTMask p q));\n+  effect(KILL cr);\n+\n+  ins_cost(400);\n+  format %{ \"cmpl    $p, $q\\t# cmpLTMask\\n\\t\"\n+            \"setcc   $dst \\t# emits setlt + movzbl or setzul for APX\"\n+            \"negl    $dst\" %}\n+  ins_encode %{\n+    __ cmpl($p$$Register, $q$$Register);\n+    __ setcc(Assembler::less, $dst$$Register);\n+    __ negl($dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpLTMask0(rRegI dst, immI_0 zero, rFlagsReg cr)\n+%{\n+  match(Set dst (CmpLTMask dst zero));\n+  effect(KILL cr);\n+\n+  ins_cost(100);\n+  format %{ \"sarl    $dst, #31\\t# cmpLTMask0\" %}\n+  ins_encode %{\n+    __ sarl($dst$$Register, 31);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/* Better to save a register than avoid a branch *\/\n+instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)\n+%{\n+  match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));\n+  effect(KILL cr);\n+  ins_cost(300);\n+  format %{ \"subl    $p,$q\\t# cadd_cmpLTMask\\n\\t\"\n+            \"jge     done\\n\\t\"\n+            \"addl    $p,$y\\n\"\n+            \"done:   \" %}\n+  ins_encode %{\n+    Register Rp = $p$$Register;\n+    Register Rq = $q$$Register;\n+    Register Ry = $y$$Register;\n+    Label done;\n+    __ subl(Rp, Rq);\n+    __ jccb(Assembler::greaterEqual, done);\n+    __ addl(Rp, Ry);\n+    __ bind(done);\n+  %}\n+  ins_pipe(pipe_cmplt);\n+%}\n+\n+\/* Better to save a register than avoid a branch *\/\n+instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)\n+%{\n+  match(Set y (AndI (CmpLTMask p q) y));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+\n+  format %{ \"cmpl    $p, $q\\t# and_cmpLTMask\\n\\t\"\n+            \"jlt     done\\n\\t\"\n+            \"xorl    $y, $y\\n\"\n+            \"done:   \" %}\n+  ins_encode %{\n+    Register Rp = $p$$Register;\n+    Register Rq = $q$$Register;\n+    Register Ry = $y$$Register;\n+    Label done;\n+    __ cmpl(Rp, Rq);\n+    __ jccb(Assembler::less, done);\n+    __ xorl(Ry, Ry);\n+    __ bind(done);\n+  %}\n+  ins_pipe(pipe_cmplt);\n+%}\n+\n+\n+\/\/---------- FP Instructions------------------------------------------------\n+\n+\/\/ Really expensive, avoid\n+instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)\n+%{\n+  match(Set cr (CmpF src1 src2));\n+\n+  ins_cost(500);\n+  format %{ \"ucomiss $src1, $src2\\n\\t\"\n+            \"jnp,s   exit\\n\\t\"\n+            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n+            \"andq    [rsp], #0xffffff2b\\n\\t\"\n+            \"popfq\\n\"\n+    \"exit:\" %}\n+  ins_encode %{\n+    __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);\n+    emit_cmpfp_fixup(masm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{\n+  match(Set cr (CmpF src1 src2));\n+\n+  ins_cost(100);\n+  format %{ \"ucomiss $src1, $src2\" %}\n+  ins_encode %{\n+    __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{\n+  match(Set cr (CmpF src1 (LoadF src2)));\n+\n+  ins_cost(100);\n+  format %{ \"ucomiss $src1, $src2\" %}\n+  ins_encode %{\n+    __ ucomiss($src1$$XMMRegister, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{\n+  match(Set cr (CmpF src con));\n+  ins_cost(100);\n+  format %{ \"ucomiss $src, [$constantaddress]\\t# load from constant table: float=$con\" %}\n+  ins_encode %{\n+    __ ucomiss($src$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Really expensive, avoid\n+instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)\n+%{\n+  match(Set cr (CmpD src1 src2));\n+\n+  ins_cost(500);\n+  format %{ \"ucomisd $src1, $src2\\n\\t\"\n+            \"jnp,s   exit\\n\\t\"\n+            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n+            \"andq    [rsp], #0xffffff2b\\n\\t\"\n+            \"popfq\\n\"\n+    \"exit:\" %}\n+  ins_encode %{\n+    __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);\n+    emit_cmpfp_fixup(masm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{\n+  match(Set cr (CmpD src1 src2));\n+\n+  ins_cost(100);\n+  format %{ \"ucomisd $src1, $src2 test\" %}\n+  ins_encode %{\n+    __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{\n+  match(Set cr (CmpD src1 (LoadD src2)));\n+\n+  ins_cost(100);\n+  format %{ \"ucomisd $src1, $src2\" %}\n+  ins_encode %{\n+    __ ucomisd($src1$$XMMRegister, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{\n+  match(Set cr (CmpD src con));\n+  ins_cost(100);\n+  format %{ \"ucomisd $src, [$constantaddress]\\t# load from constant table: double=$con\" %}\n+  ins_encode %{\n+    __ ucomisd($src$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Compare into -1,0,1\n+instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)\n+%{\n+  match(Set dst (CmpF3 src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(275);\n+  format %{ \"ucomiss $src1, $src2\\n\\t\"\n+            \"movl    $dst, #-1\\n\\t\"\n+            \"jp,s    done\\n\\t\"\n+            \"jb,s    done\\n\\t\"\n+            \"setne   $dst\\n\\t\"\n+            \"movzbl  $dst, $dst\\n\"\n+    \"done:\" %}\n+  ins_encode %{\n+    __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);\n+    emit_cmpfp3(masm, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Compare into -1,0,1\n+instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)\n+%{\n+  match(Set dst (CmpF3 src1 (LoadF src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(275);\n+  format %{ \"ucomiss $src1, $src2\\n\\t\"\n+            \"movl    $dst, #-1\\n\\t\"\n+            \"jp,s    done\\n\\t\"\n+            \"jb,s    done\\n\\t\"\n+            \"setne   $dst\\n\\t\"\n+            \"movzbl  $dst, $dst\\n\"\n+    \"done:\" %}\n+  ins_encode %{\n+    __ ucomiss($src1$$XMMRegister, $src2$$Address);\n+    emit_cmpfp3(masm, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Compare into -1,0,1\n+instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{\n+  match(Set dst (CmpF3 src con));\n+  effect(KILL cr);\n+\n+  ins_cost(275);\n+  format %{ \"ucomiss $src, [$constantaddress]\\t# load from constant table: float=$con\\n\\t\"\n+            \"movl    $dst, #-1\\n\\t\"\n+            \"jp,s    done\\n\\t\"\n+            \"jb,s    done\\n\\t\"\n+            \"setne   $dst\\n\\t\"\n+            \"movzbl  $dst, $dst\\n\"\n+    \"done:\" %}\n+  ins_encode %{\n+    __ ucomiss($src$$XMMRegister, $constantaddress($con));\n+    emit_cmpfp3(masm, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Compare into -1,0,1\n+instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)\n+%{\n+  match(Set dst (CmpD3 src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(275);\n+  format %{ \"ucomisd $src1, $src2\\n\\t\"\n+            \"movl    $dst, #-1\\n\\t\"\n+            \"jp,s    done\\n\\t\"\n+            \"jb,s    done\\n\\t\"\n+            \"setne   $dst\\n\\t\"\n+            \"movzbl  $dst, $dst\\n\"\n+    \"done:\" %}\n+  ins_encode %{\n+    __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);\n+    emit_cmpfp3(masm, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Compare into -1,0,1\n+instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)\n+%{\n+  match(Set dst (CmpD3 src1 (LoadD src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(275);\n+  format %{ \"ucomisd $src1, $src2\\n\\t\"\n+            \"movl    $dst, #-1\\n\\t\"\n+            \"jp,s    done\\n\\t\"\n+            \"jb,s    done\\n\\t\"\n+            \"setne   $dst\\n\\t\"\n+            \"movzbl  $dst, $dst\\n\"\n+    \"done:\" %}\n+  ins_encode %{\n+    __ ucomisd($src1$$XMMRegister, $src2$$Address);\n+    emit_cmpfp3(masm, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Compare into -1,0,1\n+instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{\n+  match(Set dst (CmpD3 src con));\n+  effect(KILL cr);\n+\n+  ins_cost(275);\n+  format %{ \"ucomisd $src, [$constantaddress]\\t# load from constant table: double=$con\\n\\t\"\n+            \"movl    $dst, #-1\\n\\t\"\n+            \"jp,s    done\\n\\t\"\n+            \"jb,s    done\\n\\t\"\n+            \"setne   $dst\\n\\t\"\n+            \"movzbl  $dst, $dst\\n\"\n+    \"done:\" %}\n+  ins_encode %{\n+    __ ucomisd($src$$XMMRegister, $constantaddress($con));\n+    emit_cmpfp3(masm, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/----------Arithmetic Conversion Instructions---------------------------------\n+\n+instruct convF2D_reg_reg(regD dst, regF src)\n+%{\n+  match(Set dst (ConvF2D src));\n+\n+  format %{ \"cvtss2sd $dst, $src\" %}\n+  ins_encode %{\n+    __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convF2D_reg_mem(regD dst, memory src)\n+%{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ConvF2D (LoadF src)));\n+\n+  format %{ \"cvtss2sd $dst, $src\" %}\n+  ins_encode %{\n+    __ cvtss2sd ($dst$$XMMRegister, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convD2F_reg_reg(regF dst, regD src)\n+%{\n+  match(Set dst (ConvD2F src));\n+\n+  format %{ \"cvtsd2ss $dst, $src\" %}\n+  ins_encode %{\n+    __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convD2F_reg_mem(regF dst, memory src)\n+%{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ConvD2F (LoadD src)));\n+\n+  format %{ \"cvtsd2ss $dst, $src\" %}\n+  ins_encode %{\n+    __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+\/\/ XXX do mem variants\n+instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I src));\n+  effect(KILL cr);\n+  format %{ \"convert_f2i $dst, $src\" %}\n+  ins_encode %{\n+    __ convertF2I(T_INT, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2I_reg_reg_avx10(rRegI dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I src));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2I_reg_mem_avx10(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2I (LoadF src)));\n+  format %{ \"evcvttss2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L src));\n+  effect(KILL cr);\n+  format %{ \"convert_f2l $dst, $src\"%}\n+  ins_encode %{\n+    __ convertF2I(T_LONG, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2L_reg_reg_avx10(rRegL dst, regF src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L src));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2L_reg_mem_avx10(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvF2L (LoadF src)));\n+  format %{ \"evcvttss2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttss2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I src));\n+  effect(KILL cr);\n+  format %{ \"convert_d2i $dst, $src\"%}\n+  ins_encode %{\n+    __ convertF2I(T_INT, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2I_reg_reg_avx10(rRegI dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I src));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2I_reg_mem_avx10(rRegI dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2I (LoadD src)));\n+  format %{ \"evcvttsd2sisl $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L src));\n+  effect(KILL cr);\n+  format %{ \"convert_d2l $dst, $src\"%}\n+  ins_encode %{\n+    __ convertF2I(T_LONG, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2L_reg_reg_avx10(rRegL dst, regD src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L src));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convD2L_reg_mem_avx10(rRegL dst, memory src)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (ConvD2L (LoadD src)));\n+  format %{ \"evcvttsd2sisq $dst, $src\" %}\n+  ins_encode %{\n+    __ evcvttsd2sisq($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct round_double_reg(rRegL dst, regD src, rRegL rtmp, rcx_RegL rcx, rFlagsReg cr)\n+%{\n+  match(Set dst (RoundD src));\n+  effect(TEMP dst, TEMP rtmp, TEMP rcx, KILL cr);\n+  format %{ \"round_double $dst,$src \\t! using $rtmp and $rcx as TEMP\"%}\n+  ins_encode %{\n+    __ round_double($dst$$Register, $src$$XMMRegister, $rtmp$$Register, $rcx$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct round_float_reg(rRegI dst, regF src, rRegL rtmp, rcx_RegL rcx, rFlagsReg cr)\n+%{\n+  match(Set dst (RoundF src));\n+  effect(TEMP dst, TEMP rtmp, TEMP rcx, KILL cr);\n+  format %{ \"round_float $dst,$src\" %}\n+  ins_encode %{\n+    __ round_float($dst$$Register, $src$$XMMRegister, $rtmp$$Register, $rcx$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convI2F_reg_reg(vlRegF dst, rRegI src)\n+%{\n+  predicate(!UseXmmI2F);\n+  match(Set dst (ConvI2F src));\n+\n+  format %{ \"cvtsi2ssl $dst, $src\\t# i2f\" %}\n+  ins_encode %{\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n+    __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convI2F_reg_mem(regF dst, memory src)\n+%{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ConvI2F (LoadI src)));\n+\n+  format %{ \"cvtsi2ssl $dst, $src\\t# i2f\" %}\n+  ins_encode %{\n+    __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convI2D_reg_reg(vlRegD dst, rRegI src)\n+%{\n+  predicate(!UseXmmI2D);\n+  match(Set dst (ConvI2D src));\n+\n+  format %{ \"cvtsi2sdl $dst, $src\\t# i2d\" %}\n+  ins_encode %{\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n+    __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convI2D_reg_mem(regD dst, memory src)\n+%{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ConvI2D (LoadI src)));\n+\n+  format %{ \"cvtsi2sdl $dst, $src\\t# i2d\" %}\n+  ins_encode %{\n+    __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convXI2F_reg(regF dst, rRegI src)\n+%{\n+  predicate(UseXmmI2F);\n+  match(Set dst (ConvI2F src));\n+\n+  format %{ \"movdl $dst, $src\\n\\t\"\n+            \"cvtdq2psl $dst, $dst\\t# i2f\" %}\n+  ins_encode %{\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convXI2D_reg(regD dst, rRegI src)\n+%{\n+  predicate(UseXmmI2D);\n+  match(Set dst (ConvI2D src));\n+\n+  format %{ \"movdl $dst, $src\\n\\t\"\n+            \"cvtdq2pdl $dst, $dst\\t# i2d\" %}\n+  ins_encode %{\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convL2F_reg_reg(vlRegF dst, rRegL src)\n+%{\n+  match(Set dst (ConvL2F src));\n+\n+  format %{ \"cvtsi2ssq $dst, $src\\t# l2f\" %}\n+  ins_encode %{\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n+    __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convL2F_reg_mem(regF dst, memory src)\n+%{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ConvL2F (LoadL src)));\n+\n+  format %{ \"cvtsi2ssq $dst, $src\\t# l2f\" %}\n+  ins_encode %{\n+    __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convL2D_reg_reg(vlRegD dst, rRegL src)\n+%{\n+  match(Set dst (ConvL2D src));\n+\n+  format %{ \"cvtsi2sdq $dst, $src\\t# l2d\" %}\n+  ins_encode %{\n+    if (UseAVX > 0) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n+    __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convL2D_reg_mem(regD dst, memory src)\n+%{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ConvL2D (LoadL src)));\n+\n+  format %{ \"cvtsi2sdq $dst, $src\\t# l2d\" %}\n+  ins_encode %{\n+    __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n+instruct convI2L_reg_reg(rRegL dst, rRegI src)\n+%{\n+  match(Set dst (ConvI2L src));\n+\n+  ins_cost(125);\n+  format %{ \"movslq  $dst, $src\\t# i2l\" %}\n+  ins_encode %{\n+    __ movslq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Zero-extend convert int to long\n+instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)\n+%{\n+  match(Set dst (AndL (ConvI2L src) mask));\n+\n+  format %{ \"movl    $dst, $src\\t# i2l zero-extend\\n\\t\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movl($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ Zero-extend convert int to long\n+instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)\n+%{\n+  match(Set dst (AndL (ConvI2L (LoadI src)) mask));\n+\n+  format %{ \"movl    $dst, $src\\t# i2l zero-extend\\n\\t\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$Address);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)\n+%{\n+  match(Set dst (AndL src mask));\n+\n+  format %{ \"movl    $dst, $src\\t# zero-extend long\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct convL2I_reg_reg(rRegI dst, rRegL src)\n+%{\n+  match(Set dst (ConvL2I src));\n+\n+  format %{ \"movl    $dst, $src\\t# l2i\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\n+instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{\n+  match(Set dst (MoveF2I src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(125);\n+  format %{ \"movl    $dst, $src\\t# MoveF2I_stack_reg\" %}\n+  ins_encode %{\n+    __ movl($dst$$Register, Address(rsp, $src$$disp));\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{\n+  match(Set dst (MoveI2F src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(125);\n+  format %{ \"movss   $dst, $src\\t# MoveI2F_stack_reg\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{\n+  match(Set dst (MoveD2L src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(125);\n+  format %{ \"movq    $dst, $src\\t# MoveD2L_stack_reg\" %}\n+  ins_encode %{\n+    __ movq($dst$$Register, Address(rsp, $src$$disp));\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{\n+  predicate(!UseXmmLoadAndClearUpper);\n+  match(Set dst (MoveL2D src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(125);\n+  format %{ \"movlpd  $dst, $src\\t# MoveL2D_stack_reg\" %}\n+  ins_encode %{\n+    __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{\n+  predicate(UseXmmLoadAndClearUpper);\n+  match(Set dst (MoveL2D src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(125);\n+  format %{ \"movsd   $dst, $src\\t# MoveL2D_stack_reg\" %}\n+  ins_encode %{\n+    __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{\n+  match(Set dst (MoveF2I src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(95); \/\/ XXX\n+  format %{ \"movss   $dst, $src\\t# MoveF2I_reg_stack\" %}\n+  ins_encode %{\n+    __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{\n+  match(Set dst (MoveI2F src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(100);\n+  format %{ \"movl    $dst, $src\\t# MoveI2F_reg_stack\" %}\n+  ins_encode %{\n+    __ movl(Address(rsp, $dst$$disp), $src$$Register);\n+  %}\n+  ins_pipe( ialu_mem_reg );\n+%}\n+\n+instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{\n+  match(Set dst (MoveD2L src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(95); \/\/ XXX\n+  format %{ \"movsd   $dst, $src\\t# MoveL2D_reg_stack\" %}\n+  ins_encode %{\n+    __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{\n+  match(Set dst (MoveL2D src));\n+  effect(DEF dst, USE src);\n+\n+  ins_cost(100);\n+  format %{ \"movq    $dst, $src\\t# MoveL2D_reg_stack\" %}\n+  ins_encode %{\n+    __ movq(Address(rsp, $dst$$disp), $src$$Register);\n+  %}\n+  ins_pipe(ialu_mem_reg);\n+%}\n+\n+instruct MoveF2I_reg_reg(rRegI dst, regF src) %{\n+  match(Set dst (MoveF2I src));\n+  effect(DEF dst, USE src);\n+  ins_cost(85);\n+  format %{ \"movd    $dst,$src\\t# MoveF2I\" %}\n+  ins_encode %{\n+    __ movdl($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct MoveD2L_reg_reg(rRegL dst, regD src) %{\n+  match(Set dst (MoveD2L src));\n+  effect(DEF dst, USE src);\n+  ins_cost(85);\n+  format %{ \"movd    $dst,$src\\t# MoveD2L\" %}\n+  ins_encode %{\n+    __ movdq($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct MoveI2F_reg_reg(regF dst, rRegI src) %{\n+  match(Set dst (MoveI2F src));\n+  effect(DEF dst, USE src);\n+  ins_cost(100);\n+  format %{ \"movd    $dst,$src\\t# MoveI2F\" %}\n+  ins_encode %{\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct MoveL2D_reg_reg(regD dst, rRegL src) %{\n+  match(Set dst (MoveL2D src));\n+  effect(DEF dst, USE src);\n+  ins_cost(100);\n+  format %{ \"movd    $dst,$src\\t# MoveL2D\" %}\n+  ins_encode %{\n+     __ movdq($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+\/\/ Fast clearing of an array\n+\/\/ Small non-constant lenght ClearArray for non-AVX512 targets.\n+instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                  Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                            Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Small non-constant length ClearArray for AVX512 targets.\n+instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                       Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  ins_cost(125);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"mov     rdi,rax\\n\\t\"\n+       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                 Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  ins_cost(125);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"mov     rdi,rax\\n\\t\"\n+       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Large non-constant length ClearArray for non-AVX512 targets.\n+instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                        Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                                  Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Large non-constant length ClearArray for AVX512 targets.\n+instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                             Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"mov     rdi,rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_large_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                       Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"mov     rdi,rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Small constant length ClearArray for AVX512 targets.\n+instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rax_RegL val, kReg ktmp, Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() &&\n+            ((MaxVectorSize >= 32) && VM_Version::supports_avx512vl()));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  ins_cost(100);\n+  effect(TEMP tmp, USE_KILL val, TEMP ktmp, KILL cr);\n+  format %{ \"clear_mem_imm $base , $cnt  \\n\\t\" %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$constant, $val$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                         rax_RegI result, legRegD tmp1, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareL_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                              rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                         rax_RegI result, legRegD tmp1, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareU_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                              rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                          rax_RegI result, legRegD tmp1, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareLU_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                               rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,\n+                          rax_RegI result, legRegD tmp1, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str2$$Register, $str1$$Register,\n+                      $cnt2$$Register, $cnt1$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareUL_evex(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,\n+                               rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str2$$Register, $str1$$Register,\n+                      $cnt2$$Register, $cnt1$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ fast search of substring with known size.\n+instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,\n+                             rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));\n+  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);\n+\n+  format %{ \"String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -> $result   \/\/ KILL $tmp_vec, $cnt1, $cnt2, $tmp\" %}\n+  ins_encode %{\n+    int icnt2 = (int)$int_cnt2$$constant;\n+    if (icnt2 >= 16) {\n+      \/\/ IndexOf for constant substrings with size >= 16 elements\n+      \/\/ which don't need to be loaded through stack.\n+      __ string_indexofC8($str1$$Register, $str2$$Register,\n+                          $cnt1$$Register, $cnt2$$Register,\n+                          icnt2, $result$$Register,\n+                          $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);\n+    } else {\n+      \/\/ Small strings are loaded through stack if they cross page boundary.\n+      __ string_indexof($str1$$Register, $str2$$Register,\n+                        $cnt1$$Register, $cnt2$$Register,\n+                        icnt2, $result$$Register,\n+                        $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ fast search of substring with known size.\n+instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,\n+                             rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));\n+  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);\n+\n+  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -> $result   \/\/ KILL $tmp_vec, $cnt1, $cnt2, $tmp\" %}\n+  ins_encode %{\n+    int icnt2 = (int)$int_cnt2$$constant;\n+    if (icnt2 >= 8) {\n+      \/\/ IndexOf for constant substrings with size >= 8 elements\n+      \/\/ which don't need to be loaded through stack.\n+      __ string_indexofC8($str1$$Register, $str2$$Register,\n+                          $cnt1$$Register, $cnt2$$Register,\n+                          icnt2, $result$$Register,\n+                          $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);\n+    } else {\n+      \/\/ Small strings are loaded through stack if they cross page boundary.\n+      __ string_indexof($str1$$Register, $str2$$Register,\n+                        $cnt1$$Register, $cnt2$$Register,\n+                        icnt2, $result$$Register,\n+                        $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ fast search of substring with known size.\n+instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,\n+                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));\n+  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);\n+\n+  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -> $result   \/\/ KILL $tmp_vec, $cnt1, $cnt2, $tmp\" %}\n+  ins_encode %{\n+    int icnt2 = (int)$int_cnt2$$constant;\n+    if (icnt2 >= 8) {\n+      \/\/ IndexOf for constant substrings with size >= 8 elements\n+      \/\/ which don't need to be loaded through stack.\n+      __ string_indexofC8($str1$$Register, $str2$$Register,\n+                          $cnt1$$Register, $cnt2$$Register,\n+                          icnt2, $result$$Register,\n+                          $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);\n+    } else {\n+      \/\/ Small strings are loaded through stack if they cross page boundary.\n+      __ string_indexof($str1$$Register, $str2$$Register,\n+                        $cnt1$$Register, $cnt2$$Register,\n+                        icnt2, $result$$Register,\n+                        $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,\n+                         rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);\n+\n+  format %{ \"String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ string_indexof($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register,\n+                      (-1), $result$$Register,\n+                      $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,\n+                         rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);\n+\n+  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ string_indexof($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register,\n+                      (-1), $result$$Register,\n+                      $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,\n+                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);\n+\n+  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ string_indexof($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register,\n+                      (-1), $result$$Register,\n+                      $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n+                              rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                           $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct stringL_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n+                              rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                           $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ fast string equals\n+instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,\n+                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw());\n+  match(Set result (StrEquals (Binary str1 str2) cnt));\n+  effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);\n+\n+  format %{ \"String Equals $str1,$str2,$cnt -> $result    \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ arrays_equals(false, $str1$$Register, $str2$$Register,\n+                     $cnt$$Register, $result$$Register, $tmp3$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_equals_evex(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,\n+                           legRegD tmp1, legRegD tmp2, kReg ktmp, rbx_RegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw());\n+  match(Set result (StrEquals (Binary str1 str2) cnt));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);\n+\n+  format %{ \"String Equals $str1,$str2,$cnt -> $result    \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ arrays_equals(false, $str1$$Register, $str2$$Register,\n+                     $cnt$$Register, $result$$Register, $tmp3$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ fast array equals\n+instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n+                       legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+\n+  format %{ \"Array Equals byte[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_equalsB_evex(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n+                            legRegD tmp1, legRegD tmp2, kReg ktmp, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+\n+  format %{ \"Array Equals byte[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n+                       legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+\n+  format %{ \"Array Equals char[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_equalsC_evex(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n+                            legRegD tmp1, legRegD tmp2, kReg ktmp, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+\n+  format %{ \"Array Equals char[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result, immU8 basic_type,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1) (Binary result basic_type)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL ary1, USE_KILL cnt1,\n+         USE basic_type, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary1,$cnt1,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct count_positives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                         legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+%{\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n+  match(Set result (CountPositives ary1 len));\n+  effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);\n+\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct count_positives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                              legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+%{\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n+  match(Set result (CountPositives ary1 len));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp1, TEMP ktmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);\n+\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ fast char[] to byte[] compression\n+instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3,\n+                         legRegD tmp4, rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n+  match(Set result (StrCompressedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst,\n+         USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL RAX, RCX, RDX\" %}\n+  ins_encode %{\n+    __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,\n+                           $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n+                           knoreg, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compress_evex(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3,\n+                              legRegD tmp4, kReg ktmp1, kReg ktmp2, rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n+  match(Set result (StrCompressedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ktmp1, TEMP ktmp2, USE_KILL src, USE_KILL dst,\n+         USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL RAX, RCX, RDX\" %}\n+  ins_encode %{\n+    __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,\n+                           $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n+                           $ktmp1$$KRegister, $ktmp2$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\/\/ fast byte[] to char[] inflation\n+instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n+                        legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n+  match(Set dummy (StrInflatedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+\n+  format %{ \"String Inflate $src,$dst    \/\/ KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,\n+                          $tmp1$$XMMRegister, $tmp2$$Register, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_inflate_evex(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n+                             legRegD tmp1, kReg ktmp, rcx_RegI tmp2, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n+  match(Set dummy (StrInflatedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+\n+  format %{ \"String Inflate $src,$dst    \/\/ KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,\n+                          $tmp1$$XMMRegister, $tmp2$$Register, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ encode char[] to byte[] in ISO_8859_1\n+instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n+                          legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,\n+                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+  predicate(!((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"Encode iso array $src,$dst,$len -> $result    \/\/ KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI \" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ encode char[] to byte[] in ASCII\n+instruct encode_ascii_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n+                            legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,\n+                            rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n+  match(Set result (EncodeISOArray src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"Encode ascii array $src,$dst,$len -> $result    \/\/ KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI \" %}\n+  ins_encode %{\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n+                        $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, true);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/----------Overflow Math Instructions-----------------------------------------\n+\n+instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)\n+%{\n+  match(Set cr (OverflowAddI op1 op2));\n+  effect(DEF cr, USE_KILL op1, USE op2);\n+\n+  format %{ \"addl    $op1, $op2\\t# overflow check int\" %}\n+\n+  ins_encode %{\n+    __ addl($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)\n+%{\n+  match(Set cr (OverflowAddI op1 op2));\n+  effect(DEF cr, USE_KILL op1, USE op2);\n+\n+  format %{ \"addl    $op1, $op2\\t# overflow check int\" %}\n+\n+  ins_encode %{\n+    __ addl($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)\n+%{\n+  match(Set cr (OverflowAddL op1 op2));\n+  effect(DEF cr, USE_KILL op1, USE op2);\n+\n+  format %{ \"addq    $op1, $op2\\t# overflow check long\" %}\n+  ins_encode %{\n+    __ addq($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)\n+%{\n+  match(Set cr (OverflowAddL op1 op2));\n+  effect(DEF cr, USE_KILL op1, USE op2);\n+\n+  format %{ \"addq    $op1, $op2\\t# overflow check long\" %}\n+  ins_encode %{\n+    __ addq($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)\n+%{\n+  match(Set cr (OverflowSubI op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\\t# overflow check int\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)\n+%{\n+  match(Set cr (OverflowSubI op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\\t# overflow check int\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)\n+%{\n+  match(Set cr (OverflowSubL op1 op2));\n+\n+  format %{ \"cmpq    $op1, $op2\\t# overflow check long\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)\n+%{\n+  match(Set cr (OverflowSubL op1 op2));\n+\n+  format %{ \"cmpq    $op1, $op2\\t# overflow check long\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowNegI_rReg(rFlagsReg cr, immI_0 zero, rax_RegI op2)\n+%{\n+  match(Set cr (OverflowSubI zero op2));\n+  effect(DEF cr, USE_KILL op2);\n+\n+  format %{ \"negl    $op2\\t# overflow check int\" %}\n+  ins_encode %{\n+    __ negl($op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)\n+%{\n+  match(Set cr (OverflowSubL zero op2));\n+  effect(DEF cr, USE_KILL op2);\n+\n+  format %{ \"negq    $op2\\t# overflow check long\" %}\n+  ins_encode %{\n+    __ negq($op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)\n+%{\n+  match(Set cr (OverflowMulI op1 op2));\n+  effect(DEF cr, USE_KILL op1, USE op2);\n+\n+  format %{ \"imull    $op1, $op2\\t# overflow check int\" %}\n+  ins_encode %{\n+    __ imull($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)\n+%{\n+  match(Set cr (OverflowMulI op1 op2));\n+  effect(DEF cr, TEMP tmp, USE op1, USE op2);\n+\n+  format %{ \"imull    $tmp, $op1, $op2\\t# overflow check int\" %}\n+  ins_encode %{\n+    __ imull($tmp$$Register, $op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)\n+%{\n+  match(Set cr (OverflowMulL op1 op2));\n+  effect(DEF cr, USE_KILL op1, USE op2);\n+\n+  format %{ \"imulq    $op1, $op2\\t# overflow check long\" %}\n+  ins_encode %{\n+    __ imulq($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)\n+%{\n+  match(Set cr (OverflowMulL op1 op2));\n+  effect(DEF cr, TEMP tmp, USE op1, USE op2);\n+\n+  format %{ \"imulq    $tmp, $op1, $op2\\t# overflow check long\" %}\n+  ins_encode %{\n+    __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+\n+\/\/----------Control Flow Instructions------------------------------------------\n+\/\/ Signed compare Instructions\n+\n+\/\/ XXX more variants!!\n+instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)\n+%{\n+  match(Set cr (CmpI op1 op2));\n+  effect(DEF cr, USE op1, USE op2);\n+\n+  format %{ \"cmpl    $op1, $op2\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n+\n+instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)\n+%{\n+  match(Set cr (CmpI op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)\n+%{\n+  match(Set cr (CmpI op1 (LoadI op2)));\n+\n+  ins_cost(500); \/\/ XXX\n+  format %{ \"cmpl    $op1, $op2\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+instruct testI_reg(rFlagsReg cr, rRegI src, immI_0 zero)\n+%{\n+  match(Set cr (CmpI src zero));\n+\n+  format %{ \"testl   $src, $src\" %}\n+  ins_encode %{\n+    __ testl($src$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI_0 zero)\n+%{\n+  match(Set cr (CmpI (AndI src con) zero));\n+\n+  format %{ \"testl   $src, $con\" %}\n+  ins_encode %{\n+    __ testl($src$$Register, $con$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct testI_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2, immI_0 zero)\n+%{\n+  match(Set cr (CmpI (AndI src1 src2) zero));\n+\n+  format %{ \"testl   $src1, $src2\" %}\n+  ins_encode %{\n+    __ testl($src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI_0 zero)\n+%{\n+  match(Set cr (CmpI (AndI src (LoadI mem)) zero));\n+\n+  format %{ \"testl   $src, $mem\" %}\n+  ins_encode %{\n+    __ testl($src$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+\/\/ Unsigned compare Instructions; really, same as signed except they\n+\/\/ produce an rFlagsRegU instead of rFlagsReg.\n+instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)\n+%{\n+  match(Set cr (CmpU op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\\t# unsigned\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n+\n+instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)\n+%{\n+  match(Set cr (CmpU op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\\t# unsigned\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)\n+%{\n+  match(Set cr (CmpU op1 (LoadI op2)));\n+\n+  ins_cost(500); \/\/ XXX\n+  format %{ \"cmpl    $op1, $op2\\t# unsigned\" %}\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+instruct testU_reg(rFlagsRegU cr, rRegI src, immI_0 zero)\n+%{\n+  match(Set cr (CmpU src zero));\n+\n+  format %{ \"testl   $src, $src\\t# unsigned\" %}\n+  ins_encode %{\n+    __ testl($src$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)\n+%{\n+  match(Set cr (CmpP op1 op2));\n+\n+  format %{ \"cmpq    $op1, $op2\\t# ptr\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n+\n+instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)\n+%{\n+  match(Set cr (CmpP op1 (LoadP op2)));\n+  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n+\n+  ins_cost(500); \/\/ XXX\n+  format %{ \"cmpq    $op1, $op2\\t# ptr\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+\/\/ XXX this is generalized by compP_rReg_mem???\n+\/\/ Compare raw pointer (used in out-of-heap check).\n+\/\/ Only works because non-oop pointers must be raw pointers\n+\/\/ and raw pointers have no anti-dependencies.\n+instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)\n+%{\n+  predicate(n->in(2)->in(2)->bottom_type()->reloc() == relocInfo::none &&\n+            n->in(2)->as_Load()->barrier_data() == 0);\n+  match(Set cr (CmpP op1 (LoadP op2)));\n+\n+  format %{ \"cmpq    $op1, $op2\\t# raw ptr\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+\/\/ This will generate a signed flags result. This should be OK since\n+\/\/ any compare to a zero should be eq\/neq.\n+instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)\n+%{\n+  match(Set cr (CmpP src zero));\n+\n+  format %{ \"testq   $src, $src\\t# ptr\" %}\n+  ins_encode %{\n+    __ testq($src$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+\/\/ This will generate a signed flags result. This should be OK since\n+\/\/ any compare to a zero should be eq\/neq.\n+instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)\n+%{\n+  predicate((!UseCompressedOops || (CompressedOops::base() != nullptr)) &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n+  match(Set cr (CmpP (LoadP op) zero));\n+\n+  ins_cost(500); \/\/ XXX\n+  format %{ \"testq   $op, 0xffffffffffffffff\\t# ptr\" %}\n+  ins_encode %{\n+    __ testq($op$$Address, 0xFFFFFFFF);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)\n+%{\n+  predicate(UseCompressedOops && (CompressedOops::base() == nullptr) &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n+  match(Set cr (CmpP (LoadP mem) zero));\n+\n+  format %{ \"cmpq    R12, $mem\\t# ptr (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ cmpq(r12, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)\n+%{\n+  match(Set cr (CmpN op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\\t# compressed ptr\" %}\n+  ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n+\n+instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)\n+%{\n+  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n+  match(Set cr (CmpN src (LoadN mem)));\n+\n+  format %{ \"cmpl    $src, $mem\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ cmpl($src$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{\n+  match(Set cr (CmpN op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)\n+%{\n+  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n+  match(Set cr (CmpN src (LoadN mem)));\n+\n+  format %{ \"cmpl    $mem, $src\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{\n+  match(Set cr (CmpN op1 op2));\n+\n+  format %{ \"cmpl    $op1, $op2\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n@@ -1917,10 +16503,4 @@\n-bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n-  \/\/ ADLC based match_rule_supported routine checks for the existence of pattern based\n-  \/\/ on IR opcode. Most of the unary\/binary\/ternary masked operation share the IR nodes\n-  \/\/ of their non-masked counterpart with mask edge being the differentiator.\n-  \/\/ This routine does a strict check on the existence of masked operation patterns\n-  \/\/ by returning a default false value for all the other opcodes apart from the\n-  \/\/ ones whose masked instruction patterns are defined in this file.\n-  if (!match_rule_supported_vector(opcode, vlen, bt)) {\n-    return false;\n-  }\n+instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)\n+%{\n+  predicate(!UseCompactObjectHeaders);\n+  match(Set cr (CmpN src (LoadNKlass mem)));\n@@ -1928,14 +16508,6 @@\n-  int size_in_bits = vlen * type2aelembytes(bt) * BitsPerByte;\n-  if (size_in_bits != 512 && !VM_Version::supports_avx512vl()) {\n-    return false;\n-  }\n-  switch(opcode) {\n-    \/\/ Unary masked operations\n-    case Op_AbsVB:\n-    case Op_AbsVS:\n-      if(!VM_Version::supports_avx512bw()) {\n-        return false;  \/\/ Implementation limitation\n-      }\n-    case Op_AbsVI:\n-    case Op_AbsVL:\n-      return true;\n+  format %{ \"cmpl    $mem, $src\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n@@ -1943,4 +16515,2 @@\n-    \/\/ Ternary masked operations\n-    case Op_FmaVF:\n-    case Op_FmaVD:\n-      return true;\n+instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{\n+  match(Set cr (CmpN src zero));\n@@ -1948,5 +16518,4 @@\n-    case Op_MacroLogicV:\n-      if(bt != T_INT && bt != T_LONG) {\n-        return false;\n-      }\n-      return true;\n+  format %{ \"testl   $src, $src\\t# compressed ptr\" %}\n+  ins_encode %{ __ testl($src$$Register, $src$$Register); %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n@@ -1954,14 +16523,5 @@\n-    \/\/ Binary masked operations\n-    case Op_AddVB:\n-    case Op_AddVS:\n-    case Op_SubVB:\n-    case Op_SubVS:\n-    case Op_MulVS:\n-    case Op_LShiftVS:\n-    case Op_RShiftVS:\n-    case Op_URShiftVS:\n-      assert(size_in_bits == 512 || VM_Version::supports_avx512vl(), \"\");\n-      if (!VM_Version::supports_avx512bw()) {\n-        return false;  \/\/ Implementation limitation\n-      }\n-      return true;\n+instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)\n+%{\n+  predicate(CompressedOops::base() != nullptr &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n+  match(Set cr (CmpN (LoadN mem) zero));\n@@ -1969,6 +16529,7 @@\n-    case Op_MulVL:\n-      assert(size_in_bits == 512 || VM_Version::supports_avx512vl(), \"\");\n-      if (!VM_Version::supports_avx512dq()) {\n-        return false;  \/\/ Implementation limitation\n-      }\n-      return true;\n+  ins_cost(500); \/\/ XXX\n+  format %{ \"testl   $mem, 0xffffffff\\t# compressed ptr\" %}\n+  ins_encode %{\n+    __ cmpl($mem$$Address, (int)0xFFFFFFFF);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n@@ -1976,9 +16537,5 @@\n-    case Op_AndV:\n-    case Op_OrV:\n-    case Op_XorV:\n-    case Op_RotateRightV:\n-    case Op_RotateLeftV:\n-      if (bt != T_INT && bt != T_LONG) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      return true;\n+instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)\n+%{\n+  predicate(CompressedOops::base() == nullptr &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n+  match(Set cr (CmpN (LoadN mem) zero));\n@@ -1986,6 +16543,6 @@\n-    case Op_VectorLoadMask:\n-      assert(size_in_bits == 512 || VM_Version::supports_avx512vl(), \"\");\n-      if (is_subword_type(bt) && !VM_Version::supports_avx512bw()) {\n-        return false;\n-      }\n-      return true;\n+  format %{ \"cmpl    R12, $mem\\t# compressed ptr (R12_heapbase==0)\" %}\n+  ins_encode %{\n+    __ cmpl(r12, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n@@ -1993,26 +16550,2 @@\n-    case Op_AddVI:\n-    case Op_AddVL:\n-    case Op_AddVF:\n-    case Op_AddVD:\n-    case Op_SubVI:\n-    case Op_SubVL:\n-    case Op_SubVF:\n-    case Op_SubVD:\n-    case Op_MulVI:\n-    case Op_MulVF:\n-    case Op_MulVD:\n-    case Op_DivVF:\n-    case Op_DivVD:\n-    case Op_SqrtVF:\n-    case Op_SqrtVD:\n-    case Op_LShiftVI:\n-    case Op_LShiftVL:\n-    case Op_RShiftVI:\n-    case Op_RShiftVL:\n-    case Op_URShiftVI:\n-    case Op_URShiftVL:\n-    case Op_LoadVectorMasked:\n-    case Op_StoreVectorMasked:\n-    case Op_LoadVectorGatherMasked:\n-    case Op_StoreVectorScatterMasked:\n-      return true;\n+\/\/ Yanked all unsigned pointer compare operations.\n+\/\/ Pointer compares are done with CmpP which is already unsigned.\n@@ -2020,23 +16553,3 @@\n-    case Op_UMinV:\n-    case Op_UMaxV:\n-      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n-        return false;\n-      } \/\/ fallthrough\n-    case Op_MaxV:\n-    case Op_MinV:\n-      if (is_subword_type(bt) && !VM_Version::supports_avx512bw()) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      if (is_floating_point_type(bt) && !VM_Version::supports_avx10_2()) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      return true;\n-    case Op_SaturatingAddV:\n-    case Op_SaturatingSubV:\n-      if (!is_subword_type(bt)) {\n-        return false;\n-      }\n-      if (size_in_bits < 128 || !VM_Version::supports_avx512bw()) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      return true;\n+instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)\n+%{\n+  match(Set cr (CmpL op1 op2));\n@@ -2044,5 +16557,6 @@\n-    case Op_VectorMaskCmp:\n-      if (is_subword_type(bt) && !VM_Version::supports_avx512bw()) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      return true;\n+  format %{ \"cmpq    $op1, $op2\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n@@ -2050,10 +16564,3 @@\n-    case Op_VectorRearrange:\n-      if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n-        return false; \/\/ Implementation limitation\n-      } else if ((bt == T_INT || bt == T_FLOAT) && size_in_bits < 256) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      return true;\n+instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)\n+%{\n+  match(Set cr (CmpL op1 op2));\n@@ -2061,8 +16568,6 @@\n-    \/\/ Binary Logical operations\n-    case Op_AndVMask:\n-    case Op_OrVMask:\n-    case Op_XorVMask:\n-      if (vlen > 16 && !VM_Version::supports_avx512bw()) {\n-        return false; \/\/ Implementation limitation\n-      }\n-      return true;\n+  format %{ \"cmpq    $op1, $op2\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n@@ -2070,6 +16575,3 @@\n-    case Op_PopCountVI:\n-    case Op_PopCountVL:\n-      if (!is_pop_count_instr_target(bt)) {\n-        return false;\n-      }\n-      return true;\n+instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)\n+%{\n+  match(Set cr (CmpL op1 (LoadL op2)));\n@@ -2077,2 +16579,6 @@\n-    case Op_MaskAll:\n-      return true;\n+  format %{ \"cmpq    $op1, $op2\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n@@ -2080,8 +16586,3 @@\n-    case Op_CountLeadingZerosV:\n-      if (is_non_subword_integral_type(bt) && VM_Version::supports_avx512cd()) {\n-        return true;\n-      }\n-    default:\n-      return false;\n-  }\n-}\n+instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)\n+%{\n+  match(Set cr (CmpL src zero));\n@@ -2089,3 +16590,6 @@\n-bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n-  return false;\n-}\n+  format %{ \"testq   $src, $src\" %}\n+  ins_encode %{\n+    __ testq($src$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n@@ -2093,12 +16597,3 @@\n-\/\/ Return true if Vector::rearrange needs preparation of the shuffle argument\n-bool Matcher::vector_rearrange_requires_load_shuffle(BasicType elem_bt, int vlen) {\n-  switch (elem_bt) {\n-    case T_BYTE:  return false;\n-    case T_SHORT: return !VM_Version::supports_avx512bw();\n-    case T_INT:   return !VM_Version::supports_avx();\n-    case T_LONG:  return vlen < 8 && !VM_Version::supports_avx512vl();\n-    default:\n-      ShouldNotReachHere();\n-      return false;\n-  }\n-}\n+instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)\n+%{\n+  match(Set cr (CmpL (AndL src con) zero));\n@@ -2106,28 +16601,63 @@\n-MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {\n-  assert(Matcher::is_generic_vector(generic_opnd), \"not generic\");\n-  bool legacy = (generic_opnd->opcode() == LEGVEC);\n-  if (!VM_Version::supports_avx512vlbwdq() && \/\/ KNL\n-      is_temp && !legacy && (ideal_reg == Op_VecZ)) {\n-    \/\/ Conservatively specialize 512bit vec TEMP operands to legVecZ (zmm0-15) on KNL.\n-    return new legVecZOper();\n-  }\n-  if (legacy) {\n-    switch (ideal_reg) {\n-      case Op_VecS: return new legVecSOper();\n-      case Op_VecD: return new legVecDOper();\n-      case Op_VecX: return new legVecXOper();\n-      case Op_VecY: return new legVecYOper();\n-      case Op_VecZ: return new legVecZOper();\n-    }\n-  } else {\n-    switch (ideal_reg) {\n-      case Op_VecS: return new vecSOper();\n-      case Op_VecD: return new vecDOper();\n-      case Op_VecX: return new vecXOper();\n-      case Op_VecY: return new vecYOper();\n-      case Op_VecZ: return new vecZOper();\n-    }\n-  }\n-  ShouldNotReachHere();\n-  return nullptr;\n-}\n+  format %{ \"testq   $src, $con\\t# long\" %}\n+  ins_encode %{\n+    __ testq($src$$Register, $con$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct testL_reg_reg(rFlagsReg cr, rRegL src1, rRegL src2, immL0 zero)\n+%{\n+  match(Set cr (CmpL (AndL src1 src2) zero));\n+\n+  format %{ \"testq   $src1, $src2\\t# long\" %}\n+  ins_encode %{\n+    __ testq($src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n+\n+instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)\n+%{\n+  match(Set cr (CmpL (AndL src (LoadL mem)) zero));\n+\n+  format %{ \"testq   $src, $mem\" %}\n+  ins_encode %{\n+    __ testq($src$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)\n+%{\n+  match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));\n+\n+  format %{ \"testq   $src, $mem\" %}\n+  ins_encode %{\n+    __ testq($src$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+\/\/ Manifest a CmpU result in an integer register.  Very painful.\n+\/\/ This is the test to avoid.\n+instruct cmpU3_reg_reg(rRegI dst, rRegI src1, rRegI src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(275); \/\/ XXX\n+  format %{ \"cmpl    $src1, $src2\\t# CmpL3\\n\\t\"\n+            \"movl    $dst, -1\\n\\t\"\n+            \"jb,u    done\\n\\t\"\n+            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n+    \"done:\" %}\n+  ins_encode %{\n+    Label done;\n+    __ cmpl($src1$$Register, $src2$$Register);\n+    __ movl($dst$$Register, -1);\n+    __ jccb(Assembler::below, done);\n+    __ setcc(Assembler::notZero, $dst$$Register);\n+    __ bind(done);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2135,17 +16665,23 @@\n-bool Matcher::is_reg2reg_move(MachNode* m) {\n-  switch (m->rule()) {\n-    case MoveVec2Leg_rule:\n-    case MoveLeg2Vec_rule:\n-    case MoveF2VL_rule:\n-    case MoveF2LEG_rule:\n-    case MoveVL2F_rule:\n-    case MoveLEG2F_rule:\n-    case MoveD2VL_rule:\n-    case MoveD2LEG_rule:\n-    case MoveVL2D_rule:\n-    case MoveLEG2D_rule:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n+\/\/ Manifest a CmpL result in an integer register.  Very painful.\n+\/\/ This is the test to avoid.\n+instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(275); \/\/ XXX\n+  format %{ \"cmpq    $src1, $src2\\t# CmpL3\\n\\t\"\n+            \"movl    $dst, -1\\n\\t\"\n+            \"jl,s    done\\n\\t\"\n+            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n+    \"done:\" %}\n+  ins_encode %{\n+    Label done;\n+    __ cmpq($src1$$Register, $src2$$Register);\n+    __ movl($dst$$Register, -1);\n+    __ jccb(Assembler::less, done);\n+    __ setcc(Assembler::notZero, $dst$$Register);\n+    __ bind(done);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2153,9 +16689,23 @@\n-bool Matcher::is_generic_vector(MachOper* opnd) {\n-  switch (opnd->opcode()) {\n-    case VEC:\n-    case LEGVEC:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n+\/\/ Manifest a CmpUL result in an integer register.  Very painful.\n+\/\/ This is the test to avoid.\n+instruct cmpUL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(275); \/\/ XXX\n+  format %{ \"cmpq    $src1, $src2\\t# CmpL3\\n\\t\"\n+            \"movl    $dst, -1\\n\\t\"\n+            \"jb,u    done\\n\\t\"\n+            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n+    \"done:\" %}\n+  ins_encode %{\n+    Label done;\n+    __ cmpq($src1$$Register, $src2$$Register);\n+    __ movl($dst$$Register, -1);\n+    __ jccb(Assembler::below, done);\n+    __ setcc(Assembler::notZero, $dst$$Register);\n+    __ bind(done);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2163,1 +16713,5 @@\n-\/\/------------------------------------------------------------------------\n+\/\/ Unsigned long compare Instructions; really, same as signed long except they\n+\/\/ produce an rFlagsRegU instead of rFlagsReg.\n+instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)\n+%{\n+  match(Set cr (CmpUL op1 op2));\n@@ -2165,3 +16719,6 @@\n-const RegMask* Matcher::predicate_reg_mask(void) {\n-  return &_VECTMASK_REG_mask;\n-}\n+  format %{ \"cmpq    $op1, $op2\\t# unsigned\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n@@ -2169,41 +16726,3 @@\n-\/\/ Max vector size in bytes. 0 if not supported.\n-int Matcher::vector_width_in_bytes(BasicType bt) {\n-  assert(is_java_primitive(bt), \"only primitive type vectors\");\n-  \/\/ SSE2 supports 128bit vectors for all types.\n-  \/\/ AVX2 supports 256bit vectors for all types.\n-  \/\/ AVX2\/EVEX supports 512bit vectors for all types.\n-  int size = (UseAVX > 1) ? (1 << UseAVX) * 8 : 16;\n-  \/\/ AVX1 supports 256bit vectors only for FLOAT and DOUBLE.\n-  if (UseAVX > 0 && (bt == T_FLOAT || bt == T_DOUBLE))\n-    size = (UseAVX > 2) ? 64 : 32;\n-  if (UseAVX > 2 && (bt == T_BYTE || bt == T_SHORT || bt == T_CHAR))\n-    size = (VM_Version::supports_avx512bw()) ? 64 : 32;\n-  \/\/ Use flag to limit vector size.\n-  size = MIN2(size,(int)MaxVectorSize);\n-  \/\/ Minimum 2 values in vector (or 4 for bytes).\n-  switch (bt) {\n-  case T_DOUBLE:\n-  case T_LONG:\n-    if (size < 16) return 0;\n-    break;\n-  case T_FLOAT:\n-  case T_INT:\n-    if (size < 8) return 0;\n-    break;\n-  case T_BOOLEAN:\n-    if (size < 4) return 0;\n-    break;\n-  case T_CHAR:\n-    if (size < 4) return 0;\n-    break;\n-  case T_BYTE:\n-    if (size < 4) return 0;\n-    break;\n-  case T_SHORT:\n-    if (size < 4) return 0;\n-    break;\n-  default:\n-    ShouldNotReachHere();\n-  }\n-  return size;\n-}\n+instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)\n+%{\n+  match(Set cr (CmpUL op1 op2));\n@@ -2211,14 +16730,6 @@\n-\/\/ Limits on vector size (number of elements) loaded into vector.\n-int Matcher::max_vector_size(const BasicType bt) {\n-  return vector_width_in_bytes(bt)\/type2aelembytes(bt);\n-}\n-int Matcher::min_vector_size(const BasicType bt) {\n-  int max_size = max_vector_size(bt);\n-  \/\/ Min size which can be loaded into vector is 4 bytes.\n-  int size = (type2aelembytes(bt) == 1) ? 4 : 2;\n-  \/\/ Support for calling svml double64 vectors\n-  if (bt == T_DOUBLE) {\n-    size = 1;\n-  }\n-  return MIN2(size,max_size);\n-}\n+  format %{ \"cmpq    $op1, $op2\\t# unsigned\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$constant);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n@@ -2226,8 +16737,3 @@\n-int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n-  \/\/ Limit the max vector size for auto vectorization to 256 bits (32 bytes)\n-  \/\/ by default on Cascade Lake\n-  if (VM_Version::is_default_intel_cascade_lake()) {\n-    return MIN2(Matcher::max_vector_size(bt), 32 \/ type2aelembytes(bt));\n-  }\n-  return Matcher::max_vector_size(bt);\n-}\n+instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)\n+%{\n+  match(Set cr (CmpUL op1 (LoadL op2)));\n@@ -2235,3 +16741,6 @@\n-int Matcher::scalable_vector_reg_size(const BasicType bt) {\n-  return -1;\n-}\n+  format %{ \"cmpq    $op1, $op2\\t# unsigned\" %}\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n@@ -2239,13 +16748,3 @@\n-\/\/ Vector ideal reg corresponding to specified size in bytes\n-uint Matcher::vector_ideal_reg(int size) {\n-  assert(MaxVectorSize >= size, \"\");\n-  switch(size) {\n-    case  4: return Op_VecS;\n-    case  8: return Op_VecD;\n-    case 16: return Op_VecX;\n-    case 32: return Op_VecY;\n-    case 64: return Op_VecZ;\n-  }\n-  ShouldNotReachHere();\n-  return 0;\n-}\n+instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)\n+%{\n+  match(Set cr (CmpUL src zero));\n@@ -2253,25 +16752,6 @@\n-\/\/ Check for shift by small constant as well\n-static bool clone_shift(Node* shift, Matcher* matcher, Matcher::MStack& mstack, VectorSet& address_visited) {\n-  if (shift->Opcode() == Op_LShiftX && shift->in(2)->is_Con() &&\n-      shift->in(2)->get_int() <= 3 &&\n-      \/\/ Are there other uses besides address expressions?\n-      !matcher->is_visited(shift)) {\n-    address_visited.set(shift->_idx); \/\/ Flag as address_visited\n-    mstack.push(shift->in(2), Matcher::Visit);\n-    Node *conv = shift->in(1);\n-    \/\/ Allow Matcher to match the rule which bypass\n-    \/\/ ConvI2L operation for an array index on LP64\n-    \/\/ if the index value is positive.\n-    if (conv->Opcode() == Op_ConvI2L &&\n-        conv->as_Type()->type()->is_long()->_lo >= 0 &&\n-        \/\/ Are there other uses besides address expressions?\n-        !matcher->is_visited(conv)) {\n-      address_visited.set(conv->_idx); \/\/ Flag as address_visited\n-      mstack.push(conv->in(1), Matcher::Pre_Visit);\n-    } else {\n-      mstack.push(conv, Matcher::Pre_Visit);\n-    }\n-    return true;\n-  }\n-  return false;\n-}\n+  format %{ \"testq   $src, $src\\t# unsigned\" %}\n+  ins_encode %{\n+    __ testq($src$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_cr_reg_imm);\n+%}\n@@ -2279,14 +16759,3 @@\n-\/\/ This function identifies sub-graphs in which a 'load' node is\n-\/\/ input to two different nodes, and such that it can be matched\n-\/\/ with BMI instructions like blsi, blsr, etc.\n-\/\/ Example : for b = -a[i] & a[i] can be matched to blsi r32, m32.\n-\/\/ The graph is (AndL (SubL Con0 LoadL*) LoadL*), where LoadL*\n-\/\/ refers to the same node.\n-\/\/\n-\/\/ Match the generic fused operations pattern (op1 (op2 Con{ConType} mop) mop)\n-\/\/ This is a temporary solution until we make DAGs expressible in ADL.\n-template<typename ConType>\n-class FusedPatternMatcher {\n-  Node* _op1_node;\n-  Node* _mop_node;\n-  int _con_op;\n+instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)\n+%{\n+  match(Set cr (CmpI (LoadB mem) imm));\n@@ -2294,4 +16763,5 @@\n-  static int match_next(Node* n, int next_op, int next_op_idx) {\n-    if (n->in(1) == nullptr || n->in(2) == nullptr) {\n-      return -1;\n-    }\n+  ins_cost(125);\n+  format %{ \"cmpb    $mem, $imm\" %}\n+  ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n@@ -2299,14 +16769,3 @@\n-    if (next_op_idx == -1) { \/\/ n is commutative, try rotations\n-      if (n->in(1)->Opcode() == next_op) {\n-        return 1;\n-      } else if (n->in(2)->Opcode() == next_op) {\n-        return 2;\n-      }\n-    } else {\n-      assert(next_op_idx > 0 && next_op_idx <= 2, \"Bad argument index\");\n-      if (n->in(next_op_idx)->Opcode() == next_op) {\n-        return next_op_idx;\n-      }\n-    }\n-    return -1;\n-  }\n+instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU7 imm, immI_0 zero)\n+%{\n+  match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));\n@@ -2314,3 +16773,5 @@\n- public:\n-  FusedPatternMatcher(Node* op1_node, Node* mop_node, int con_op) :\n-    _op1_node(op1_node), _mop_node(mop_node), _con_op(con_op) { }\n+  ins_cost(125);\n+  format %{ \"testb   $mem, $imm\\t# ubyte\" %}\n+  ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n@@ -2318,15 +16779,3 @@\n-  bool match(int op1, int op1_op2_idx,  \/\/ op1 and the index of the op1->op2 edge, -1 if op1 is commutative\n-             int op2, int op2_con_idx,  \/\/ op2 and the index of the op2->con edge, -1 if op2 is commutative\n-             typename ConType::NativeType con_value) {\n-    if (_op1_node->Opcode() != op1) {\n-      return false;\n-    }\n-    if (_mop_node->outcnt() > 2) {\n-      return false;\n-    }\n-    op1_op2_idx = match_next(_op1_node, op2, op1_op2_idx);\n-    if (op1_op2_idx == -1) {\n-      return false;\n-    }\n-    \/\/ Memory operation must be the other edge\n-    int op1_mop_idx = (op1_op2_idx & 1) + 1;\n+instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI_0 zero)\n+%{\n+  match(Set cr (CmpI (AndI (LoadB mem) imm) zero));\n@@ -2334,25 +16783,37 @@\n-    \/\/ Check that the mop node is really what we want\n-    if (_op1_node->in(op1_mop_idx) == _mop_node) {\n-      Node* op2_node = _op1_node->in(op1_op2_idx);\n-      if (op2_node->outcnt() > 1) {\n-        return false;\n-      }\n-      assert(op2_node->Opcode() == op2, \"Should be\");\n-      op2_con_idx = match_next(op2_node, _con_op, op2_con_idx);\n-      if (op2_con_idx == -1) {\n-        return false;\n-      }\n-      \/\/ Memory operation must be the other edge\n-      int op2_mop_idx = (op2_con_idx & 1) + 1;\n-      \/\/ Check that the memory operation is the same node\n-      if (op2_node->in(op2_mop_idx) == _mop_node) {\n-        \/\/ Now check the constant\n-        const Type* con_type = op2_node->in(op2_con_idx)->bottom_type();\n-        if (con_type != Type::TOP && ConType::as_self(con_type)->get_con() == con_value) {\n-          return true;\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-};\n+  ins_cost(125);\n+  format %{ \"testb   $mem, $imm\\t# byte\" %}\n+  ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}\n+  ins_pipe(ialu_cr_reg_mem);\n+%}\n+\n+\/\/----------Max and Min--------------------------------------------------------\n+\/\/ Min Instructions\n+\n+instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  effect(USE_DEF dst, USE src, USE cr);\n+\n+  format %{ \"cmovlgt $dst, $src\\t# min\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::greater, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovI_reg_g_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+\n+  format %{ \"ecmovlgt $dst, $src1, $src2\\t# min ndd\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::greater, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct minI_rReg(rRegI dst, rRegI src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (MinI dst src));\n@@ -2360,17 +16821,7 @@\n-static bool is_bmi_pattern(Node* n, Node* m) {\n-  assert(UseBMI1Instructions, \"sanity\");\n-  if (n != nullptr && m != nullptr) {\n-    if (m->Opcode() == Op_LoadI) {\n-      FusedPatternMatcher<TypeInt> bmii(n, m, Op_ConI);\n-      return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||\n-             bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||\n-             bmii.match(Op_XorI, -1, Op_AddI, -1, -1);\n-    } else if (m->Opcode() == Op_LoadL) {\n-      FusedPatternMatcher<TypeLong> bmil(n, m, Op_ConL);\n-      return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||\n-             bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||\n-             bmil.match(Op_XorL, -1, Op_AddL, -1, -1);\n-    }\n-  }\n-  return false;\n-}\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, dst, src);\n+    cmovI_reg_g(dst, src, cr);\n+  %}\n+%}\n@@ -2378,17 +16829,5 @@\n-\/\/ Should the matcher clone input 'm' of node 'n'?\n-bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack& mstack) {\n-  \/\/ If 'n' and 'm' are part of a graph for BMI instruction, clone the input 'm'.\n-  if (UseBMI1Instructions && is_bmi_pattern(n, m)) {\n-    mstack.push(m, Visit);\n-    return true;\n-  }\n-  if (is_vshift_con_pattern(n, m)) { \/\/ ShiftV src (ShiftCntV con)\n-    mstack.push(m, Visit);           \/\/ m = ShiftCntV\n-    return true;\n-  }\n-  if (is_encode_and_store_pattern(n, m)) {\n-    mstack.push(m, Visit);\n-    return true;\n-  }\n-  return false;\n-}\n+instruct minI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MinI src1 src2));\n+  effect(DEF dst, USE src1, USE src2);\n@@ -2396,8 +16835,7 @@\n-\/\/ Should the Matcher clone shifts on addressing modes, expecting them\n-\/\/ to be subsumed into complex addressing expressions or compute them\n-\/\/ into registers?\n-bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack& mstack, VectorSet& address_visited) {\n-  Node *off = m->in(AddPNode::Offset);\n-  if (off->is_Con()) {\n-    address_visited.test_set(m->_idx); \/\/ Flag as address_visited\n-    Node *adr = m->in(AddPNode::Address);\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, src1, src2);\n+    cmovI_reg_g_ndd(dst, src1, src2, cr);\n+  %}\n+%}\n@@ -2405,19 +16843,4 @@\n-    \/\/ Intel can handle 2 adds in addressing mode, with one of them using an immediate offset.\n-    \/\/ AtomicAdd is not an addressing expression.\n-    \/\/ Cheap to find it by looking for screwy base.\n-    if (adr->is_AddP() &&\n-        !adr->in(AddPNode::Base)->is_top() &&\n-        !adr->in(AddPNode::Offset)->is_Con() &&\n-        off->get_long() == (int) (off->get_long()) && \/\/ immL32\n-        \/\/ Are there other uses besides address expressions?\n-        !is_visited(adr)) {\n-      address_visited.set(adr->_idx); \/\/ Flag as address_visited\n-      Node *shift = adr->in(AddPNode::Offset);\n-      if (!clone_shift(shift, this, mstack, address_visited)) {\n-        mstack.push(shift, Pre_Visit);\n-      }\n-      mstack.push(adr->in(AddPNode::Address), Pre_Visit);\n-      mstack.push(adr->in(AddPNode::Base), Pre_Visit);\n-    } else {\n-      mstack.push(adr, Pre_Visit);\n-    }\n+instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(!UseAPX);\n+  effect(USE_DEF dst, USE src, USE cr);\n@@ -2425,12 +16848,6 @@\n-    \/\/ Clone X+offset as it also folds into most addressing expressions\n-    mstack.push(off, Visit);\n-    mstack.push(m->in(AddPNode::Base), Pre_Visit);\n-    return true;\n-  } else if (clone_shift(off, this, mstack, address_visited)) {\n-    address_visited.test_set(m->_idx); \/\/ Flag as address_visited\n-    mstack.push(m->in(AddPNode::Address), Pre_Visit);\n-    mstack.push(m->in(AddPNode::Base), Pre_Visit);\n-    return true;\n-  }\n-  return false;\n-}\n+  format %{ \"cmovllt $dst, $src\\t# max\" %}\n+  ins_encode %{\n+    __ cmovl(Assembler::less, $dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n@@ -2438,21 +16855,4 @@\n-static inline Assembler::ComparisonPredicate booltest_pred_to_comparison_pred(int bt) {\n-  switch (bt) {\n-    case BoolTest::eq:\n-      return Assembler::eq;\n-    case BoolTest::ne:\n-      return Assembler::neq;\n-    case BoolTest::le:\n-    case BoolTest::ule:\n-      return Assembler::le;\n-    case BoolTest::ge:\n-    case BoolTest::uge:\n-      return Assembler::nlt;\n-    case BoolTest::lt:\n-    case BoolTest::ult:\n-      return Assembler::lt;\n-    case BoolTest::gt:\n-    case BoolTest::ugt:\n-      return Assembler::nle;\n-    default : ShouldNotReachHere(); return Assembler::_false;\n-  }\n-}\n+instruct cmovI_reg_l_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n@@ -2460,12 +16860,6 @@\n-static inline Assembler::ComparisonPredicateFP booltest_pred_to_comparison_pred_fp(int bt) {\n-  switch (bt) {\n-  case BoolTest::eq: return Assembler::EQ_OQ;  \/\/ ordered non-signaling\n-  \/\/ As per JLS 15.21.1, != of NaNs is true. Thus use unordered compare.\n-  case BoolTest::ne: return Assembler::NEQ_UQ; \/\/ unordered non-signaling\n-  case BoolTest::le: return Assembler::LE_OQ;  \/\/ ordered non-signaling\n-  case BoolTest::ge: return Assembler::GE_OQ;  \/\/ ordered non-signaling\n-  case BoolTest::lt: return Assembler::LT_OQ;  \/\/ ordered non-signaling\n-  case BoolTest::gt: return Assembler::GT_OQ;  \/\/ ordered non-signaling\n-  default: ShouldNotReachHere(); return Assembler::FALSE_OS;\n-  }\n-}\n+  format %{ \"ecmovllt $dst, $src1, $src2\\t# max ndd\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::less, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n@@ -2473,49 +16867,4 @@\n-\/\/ Helper methods for MachSpillCopyNode::implementation().\n-static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n-                          int src_hi, int dst_hi, uint ireg, outputStream* st) {\n-  assert(ireg == Op_VecS || \/\/ 32bit vector\n-         ((src_lo & 1) == 0 && (src_lo + 1) == src_hi &&\n-          (dst_lo & 1) == 0 && (dst_lo + 1) == dst_hi),\n-         \"no non-adjacent vector moves\" );\n-  if (masm) {\n-    switch (ireg) {\n-    case Op_VecS: \/\/ copy whole register\n-    case Op_VecD:\n-    case Op_VecX:\n-      if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n-        __ movdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));\n-      } else {\n-        __ vextractf32x4(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]), 0x0);\n-     }\n-      break;\n-    case Op_VecY:\n-      if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n-        __ vmovdqu(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]));\n-      } else {\n-        __ vextractf64x4(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]), 0x0);\n-     }\n-      break;\n-    case Op_VecZ:\n-      __ evmovdquq(as_XMMRegister(Matcher::_regEncode[dst_lo]), as_XMMRegister(Matcher::_regEncode[src_lo]), 2);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-    }\n-#ifndef PRODUCT\n-  } else {\n-    switch (ireg) {\n-    case Op_VecS:\n-    case Op_VecD:\n-    case Op_VecX:\n-      st->print(\"movdqu  %s,%s\\t# spill\",Matcher::regName[dst_lo],Matcher::regName[src_lo]);\n-      break;\n-    case Op_VecY:\n-    case Op_VecZ:\n-      st->print(\"vmovdqu %s,%s\\t# spill\",Matcher::regName[dst_lo],Matcher::regName[src_lo]);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-    }\n-#endif\n-  }\n-}\n+instruct maxI_rReg(rRegI dst, rRegI src)\n+%{\n+  predicate(!UseAPX);\n+  match(Set dst (MaxI dst src));\n@@ -2523,63 +16872,115 @@\n-void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n-                     int stack_offset, int reg, uint ireg, outputStream* st) {\n-  if (masm) {\n-    if (is_load) {\n-      switch (ireg) {\n-      case Op_VecS:\n-        __ movdl(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n-        break;\n-      case Op_VecD:\n-        __ movq(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n-        break;\n-      case Op_VecX:\n-        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n-          __ movdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n-        } else {\n-          __ vpxor(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), 2);\n-          __ vinsertf32x4(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset),0x0);\n-        }\n-        break;\n-      case Op_VecY:\n-        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n-          __ vmovdqu(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));\n-        } else {\n-          __ vpxor(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), 2);\n-          __ vinsertf64x4(as_XMMRegister(Matcher::_regEncode[reg]), as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset),0x0);\n-        }\n-        break;\n-      case Op_VecZ:\n-        __ evmovdquq(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset), 2);\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n-    } else { \/\/ store\n-      switch (ireg) {\n-      case Op_VecS:\n-        __ movdl(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n-        break;\n-      case Op_VecD:\n-        __ movq(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n-        break;\n-      case Op_VecX:\n-        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n-          __ movdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n-        }\n-        else {\n-          __ vextractf32x4(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]), 0x0);\n-        }\n-        break;\n-      case Op_VecY:\n-        if ((UseAVX < 3) || VM_Version::supports_avx512vl()) {\n-          __ vmovdqu(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]));\n-        }\n-        else {\n-          __ vextractf64x4(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]), 0x0);\n-        }\n-        break;\n-      case Op_VecZ:\n-        __ evmovdquq(Address(rsp, stack_offset), as_XMMRegister(Matcher::_regEncode[reg]), 2);\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, dst, src);\n+    cmovI_reg_l(dst, src, cr);\n+  %}\n+%}\n+\n+instruct maxI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MaxI src1 src2));\n+  effect(DEF dst, USE src1, USE src2);\n+\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, src1, src2);\n+    cmovI_reg_l_ndd(dst, src1, src2, cr);\n+  %}\n+%}\n+\n+\/\/ ============================================================================\n+\/\/ Branch Instructions\n+\n+\/\/ Jump Direct - Label defines a relative address from JMP+1\n+instruct jmpDir(label labl)\n+%{\n+  match(Goto);\n+  effect(USE labl);\n+\n+  ins_cost(300);\n+  format %{ \"jmp     $labl\" %}\n+  size(5);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jmp(*L, false); \/\/ Always long jump\n+  %}\n+  ins_pipe(pipe_jmp);\n+%}\n+\n+\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n+instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)\n+%{\n+  match(If cop cr);\n+  effect(USE labl);\n+\n+  ins_cost(300);\n+  format %{ \"j$cop     $labl\" %}\n+  size(6);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n+  %}\n+  ins_pipe(pipe_jcc);\n+%}\n+\n+\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n+instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)\n+%{\n+  match(CountedLoopEnd cop cr);\n+  effect(USE labl);\n+\n+  ins_cost(300);\n+  format %{ \"j$cop     $labl\\t# loop end\" %}\n+  size(6);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n+  %}\n+  ins_pipe(pipe_jcc);\n+%}\n+\n+\/\/ Jump Direct Conditional - using unsigned comparison\n+instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n+\n+  ins_cost(300);\n+  format %{ \"j$cop,u   $labl\" %}\n+  size(6);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n+  %}\n+  ins_pipe(pipe_jcc);\n+%}\n+\n+instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n+\n+  ins_cost(200);\n+  format %{ \"j$cop,u   $labl\" %}\n+  size(6);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n+  %}\n+  ins_pipe(pipe_jcc);\n+%}\n+\n+instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n+\n+  ins_cost(200);\n+  format %{ $$template\n+    if ($cop$$cmpcode == Assembler::notEqual) {\n+      $$emit$$\"jp,u    $labl\\n\\t\"\n+      $$emit$$\"j$cop,u   $labl\"\n+    } else {\n+      $$emit$$\"jp,u    done\\n\\t\"\n+      $$emit$$\"j$cop,u   $labl\\n\\t\"\n+      $$emit$$\"done:\"\n@@ -2587,38 +16988,13 @@\n-#ifndef PRODUCT\n-  } else {\n-    if (is_load) {\n-      switch (ireg) {\n-      case Op_VecS:\n-        st->print(\"movd    %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n-        break;\n-      case Op_VecD:\n-        st->print(\"movq    %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n-        break;\n-       case Op_VecX:\n-        st->print(\"movdqu  %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n-        break;\n-      case Op_VecY:\n-      case Op_VecZ:\n-        st->print(\"vmovdqu %s,[rsp + %d]\\t# spill\", Matcher::regName[reg], stack_offset);\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n-    } else { \/\/ store\n-      switch (ireg) {\n-      case Op_VecS:\n-        st->print(\"movd    [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n-        break;\n-      case Op_VecD:\n-        st->print(\"movq    [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n-        break;\n-       case Op_VecX:\n-        st->print(\"movdqu  [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n-        break;\n-      case Op_VecY:\n-      case Op_VecZ:\n-        st->print(\"vmovdqu [rsp + %d],%s\\t# spill\", stack_offset, Matcher::regName[reg]);\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n+  %}\n+  ins_encode %{\n+    Label* l = $labl$$label;\n+    if ($cop$$cmpcode == Assembler::notEqual) {\n+      __ jcc(Assembler::parity, *l, false);\n+      __ jcc(Assembler::notEqual, *l, false);\n+    } else if ($cop$$cmpcode == Assembler::equal) {\n+      Label done;\n+      __ jccb(Assembler::parity, done);\n+      __ jcc(Assembler::equal, *l, false);\n+      __ bind(done);\n+    } else {\n+       ShouldNotReachHere();\n@@ -2626,3 +17002,3 @@\n-#endif\n-  }\n-}\n+  %}\n+  ins_pipe(pipe_jcc);\n+%}\n@@ -2630,34 +17006,87 @@\n-template <class T>\n-static inline GrowableArray<jbyte>* vreplicate_imm(BasicType bt, T con, int len) {\n-  int size = type2aelembytes(bt) * len;\n-  GrowableArray<jbyte>* val = new GrowableArray<jbyte>(size, size, 0);\n-  for (int i = 0; i < len; i++) {\n-    int offset = i * type2aelembytes(bt);\n-    switch (bt) {\n-      case T_BYTE: val->at(i) = con; break;\n-      case T_SHORT: {\n-        jshort c = con;\n-        memcpy(val->adr_at(offset), &c, sizeof(jshort));\n-        break;\n-      }\n-      case T_INT: {\n-        jint c = con;\n-        memcpy(val->adr_at(offset), &c, sizeof(jint));\n-        break;\n-      }\n-      case T_LONG: {\n-        jlong c = con;\n-        memcpy(val->adr_at(offset), &c, sizeof(jlong));\n-        break;\n-      }\n-      case T_FLOAT: {\n-        jfloat c = con;\n-        memcpy(val->adr_at(offset), &c, sizeof(jfloat));\n-        break;\n-      }\n-      case T_DOUBLE: {\n-        jdouble c = con;\n-        memcpy(val->adr_at(offset), &c, sizeof(jdouble));\n-        break;\n-      }\n-      default: assert(false, \"%s\", type2name(bt));\n+\/\/ ============================================================================\n+\/\/ The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary\n+\/\/ superklass array for an instance of the superklass.  Set a hidden\n+\/\/ internal cache on a hit (cache is checked with exposed code in\n+\/\/ gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The\n+\/\/ encoding ALSO sets flags.\n+\n+instruct partialSubtypeCheck(rdi_RegP result,\n+                             rsi_RegP sub, rax_RegP super, rcx_RegI rcx,\n+                             rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(!UseSecondarySupersTable);\n+  effect(KILL rcx, KILL cr);\n+\n+  ins_cost(1100);  \/\/ slightly larger than the next version\n+  format %{ \"movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\\n\\t\"\n+            \"movl    rcx, [rdi + Array<Klass*>::length_offset_in_bytes()]\\t# length to scan\\n\\t\"\n+            \"addq    rdi, Array<Klass*>::base_offset_in_bytes()\\t# Skip to start of data; set NZ in case count is zero\\n\\t\"\n+            \"repne   scasq\\t# Scan *rdi++ for a match with rax while rcx--\\n\\t\"\n+            \"jne,s   miss\\t\\t# Missed: rdi not-zero\\n\\t\"\n+            \"movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\\t# Hit: update cache\\n\\t\"\n+            \"xorq    $result, $result\\t\\t Hit: rdi zero\\n\\t\"\n+    \"miss:\\t\" %}\n+\n+  ins_encode %{\n+    Label miss;\n+    \/\/ NB: Callers may assume that, when $result is a valid register,\n+    \/\/ check_klass_subtype_slow_path_linear sets it to a nonzero\n+    \/\/ value.\n+    __ check_klass_subtype_slow_path_linear($sub$$Register, $super$$Register,\n+                                            $rcx$$Register, $result$$Register,\n+                                            nullptr, &miss,\n+                                            \/*set_cond_codes:*\/ true);\n+    __ xorptr($result$$Register, $result$$Register);\n+    __ bind(miss);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ============================================================================\n+\/\/ Two versions of hashtable-based partialSubtypeCheck, both used when\n+\/\/ we need to search for a super class in the secondary supers array.\n+\/\/ The first is used when we don't know _a priori_ the class being\n+\/\/ searched for. The second, far more common, is used when we do know:\n+\/\/ this is used for instanceof, checkcast, and any case where C2 can\n+\/\/ determine it by constant propagation.\n+\n+instruct partialSubtypeCheckVarSuper(rsi_RegP sub, rax_RegP super, rdi_RegP result,\n+                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+\n+  ins_cost(1000);\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register, $temp1$$Register, $temp2$$Register,\n+\t\t\t\t\t $temp3$$Register, $temp4$$Register, $result$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct partialSubtypeCheckConstSuper(rsi_RegP sub, rax_RegP super_reg, immP super_con, rdi_RegP result,\n+                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super_reg, $super_con\" %}\n+\n+  ins_encode %{\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      __ lookup_secondary_supers_table_const($sub$$Register, $super_reg$$Register, $temp1$$Register, $temp2$$Register,\n+                                       $temp3$$Register, $temp4$$Register, $result$$Register,\n+                                       super_klass_slot);\n+    } else {\n+      __ call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n@@ -2665,3 +17094,1 @@\n-  }\n-  return val;\n-}\n+  %}\n@@ -2669,11 +17096,2 @@\n-static inline jlong high_bit_set(BasicType bt) {\n-  switch (bt) {\n-    case T_BYTE:  return 0x8080808080808080;\n-    case T_SHORT: return 0x8000800080008000;\n-    case T_INT:   return 0x8000000080000000;\n-    case T_LONG:  return 0x8000000000000000;\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2681,5 +17099,11 @@\n-#ifndef PRODUCT\n-  void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const {\n-    st->print(\"nop \\t# %d bytes pad for loops and calls\", _count);\n-  }\n-#endif\n+\/\/ ============================================================================\n+\/\/ Branch Instructions -- short offset versions\n+\/\/\n+\/\/ These instructions are used to replace jumps of a long offset (the default\n+\/\/ match) with jumps of a shorter offset.  These instructions are all tagged\n+\/\/ with the ins_short_branch attribute, which causes the ADLC to suppress the\n+\/\/ match rules in general matching.  Instead, the ADLC generates a conversion\n+\/\/ method in the MachNode which can be used to do in-place replacement of the\n+\/\/ long variant with the shorter variant.  The compiler will determine if a\n+\/\/ branch can be taken by the is_short_branch_offset() predicate in the machine\n+\/\/ specific code section of the file.\n@@ -2687,3 +17111,4 @@\n-  void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc*) const {\n-    __ nop(_count);\n-  }\n+\/\/ Jump Direct - Label defines a relative address from JMP+1\n+instruct jmpDir_short(label labl) %{\n+  match(Goto);\n+  effect(USE labl);\n@@ -2691,3 +17116,10 @@\n-  uint MachNopNode::size(PhaseRegAlloc*) const {\n-    return _count;\n-  }\n+  ins_cost(300);\n+  format %{ \"jmp,s   $labl\" %}\n+  size(2);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jmpb(*L);\n+  %}\n+  ins_pipe(pipe_jmp);\n+  ins_short_branch(1);\n+%}\n@@ -2695,5 +17127,4 @@\n-#ifndef PRODUCT\n-  void MachBreakpointNode::format(PhaseRegAlloc*, outputStream* st) const {\n-    st->print(\"# breakpoint\");\n-  }\n-#endif\n+\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n+instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{\n+  match(If cop cr);\n+  effect(USE labl);\n@@ -2701,3 +17132,10 @@\n-  void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const {\n-    __ int3();\n-  }\n+  ins_cost(300);\n+  format %{ \"j$cop,s   $labl\" %}\n+  size(2);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n+  %}\n+  ins_pipe(pipe_jcc);\n+  ins_short_branch(1);\n+%}\n@@ -2705,3 +17143,4 @@\n-  uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {\n-    return MachNode::size(ra_);\n-  }\n+\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n+instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{\n+  match(CountedLoopEnd cop cr);\n+  effect(USE labl);\n@@ -2709,0 +17148,9 @@\n+  ins_cost(300);\n+  format %{ \"j$cop,s   $labl\\t# loop end\" %}\n+  size(2);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n+  %}\n+  ins_pipe(pipe_jcc);\n+  ins_short_branch(1);\n@@ -2711,1 +17159,4 @@\n-encode %{\n+\/\/ Jump Direct Conditional - using unsigned comparison\n+instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n@@ -2713,10 +17164,39 @@\n-  enc_class call_epilog %{\n-    if (VerifyStackAtCalls) {\n-      \/\/ Check that stack depth is unchanged: find majik cookie on stack\n-      int framesize = ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3*VMRegImpl::slots_per_word));\n-      Label L;\n-      __ cmpptr(Address(rsp, framesize), (int32_t)0xbadb100d);\n-      __ jccb(Assembler::equal, L);\n-      \/\/ Die if stack mismatch\n-      __ int3();\n-      __ bind(L);\n+  ins_cost(300);\n+  format %{ \"j$cop,us  $labl\" %}\n+  size(2);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n+  %}\n+  ins_pipe(pipe_jcc);\n+  ins_short_branch(1);\n+%}\n+\n+instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n+\n+  ins_cost(300);\n+  format %{ \"j$cop,us  $labl\" %}\n+  size(2);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n+  %}\n+  ins_pipe(pipe_jcc);\n+  ins_short_branch(1);\n+%}\n+\n+instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n+\n+  ins_cost(300);\n+  format %{ $$template\n+    if ($cop$$cmpcode == Assembler::notEqual) {\n+      $$emit$$\"jp,u,s  $labl\\n\\t\"\n+      $$emit$$\"j$cop,u,s  $labl\"\n+    } else {\n+      $$emit$$\"jp,u,s  done\\n\\t\"\n+      $$emit$$\"j$cop,u,s  $labl\\n\\t\"\n+      $$emit$$\"done:\"\n@@ -2724,32 +17204,14 @@\n-    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic() && _method->return_type()->is_loaded()) {\n-      \/\/ The last return value is not set by the callee but used to pass the null marker to compiled code.\n-      \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n-      uint con = (tf()->range_cc()->cnt() - 1);\n-      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-        ProjNode* proj = fast_out(i)->as_Proj();\n-        if (proj->_con == con) {\n-          \/\/ Set null marker if rax is non-null (a non-null value is returned buffered or scalarized)\n-          OptoReg::Name optoReg = ra_->get_reg_first(proj);\n-          VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n-          Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n-          __ testq(rax, rax);\n-          __ setb(Assembler::notZero, toReg);\n-          __ movzbl(toReg, toReg);\n-          if (reg->is_stack()) {\n-            int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n-            __ movq(Address(rsp, st_off), toReg);\n-          }\n-          break;\n-        }\n-      }\n-      if (return_value_is_used()) {\n-        \/\/ An inline type is returned as fields in multiple registers.\n-        \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n-        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n-        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n-        \/\/ rax &= (rax & 1) - 1\n-        __ movptr(rscratch1, rax);\n-        __ andptr(rscratch1, 0x1);\n-        __ subptr(rscratch1, 0x1);\n-        __ andptr(rax, rscratch1);\n-      }\n+  %}\n+  size(4);\n+  ins_encode %{\n+    Label* l = $labl$$label;\n+    if ($cop$$cmpcode == Assembler::notEqual) {\n+      __ jccb(Assembler::parity, *l);\n+      __ jccb(Assembler::notEqual, *l);\n+    } else if ($cop$$cmpcode == Assembler::equal) {\n+      Label done;\n+      __ jccb(Assembler::parity, done);\n+      __ jccb(Assembler::equal, *l);\n+      __ bind(done);\n+    } else {\n+       ShouldNotReachHere();\n@@ -2758,1 +17220,57 @@\n-\n+  ins_pipe(pipe_jcc);\n+  ins_short_branch(1);\n+%}\n+\n+\/\/ ============================================================================\n+\/\/ inlined locking and unlocking\n+\n+instruct cmpFastLockLightweight(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI rax_reg, rRegP tmp) %{\n+  match(Set cr (FastLock object box));\n+  effect(TEMP rax_reg, TEMP tmp, USE_KILL box);\n+  ins_cost(300);\n+  format %{ \"fastlock $object,$box\\t! kills $box,$rax_reg,$tmp\" %}\n+  ins_encode %{\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, rRegP object, rax_RegP rax_reg, rRegP tmp) %{\n+  match(Set cr (FastUnlock object rax_reg));\n+  effect(TEMP tmp, USE_KILL rax_reg);\n+  ins_cost(300);\n+  format %{ \"fastunlock $object,$rax_reg\\t! kills $rax_reg,$tmp\" %}\n+  ins_encode %{\n+    __ fast_unlock_lightweight($object$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+\/\/ ============================================================================\n+\/\/ Safepoint Instructions\n+instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)\n+%{\n+  match(SafePoint poll);\n+  effect(KILL cr, USE poll);\n+\n+  format %{ \"testl   rax, [$poll]\\t\"\n+            \"# Safepoint: poll for GC\" %}\n+  ins_cost(125);\n+  ins_encode %{\n+    __ relocate(relocInfo::poll_type);\n+    address pre_pc = __ pc();\n+    __ testl(rax, Address($poll$$Register, 0));\n+    assert(nativeInstruction_at(pre_pc)->is_safepoint_poll(), \"must emit test %%eax [reg]\");\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct mask_all_evexL(kReg dst, rRegL src) %{\n+  match(Set dst (MaskAll src));\n+  format %{ \"mask_all_evexL $dst, $src \\t! mask all operation\" %}\n+  ins_encode %{\n+    int mask_len = Matcher::vector_length(this);\n+    __ vector_maskall_operation($dst$$KRegister, $src$$Register, mask_len);\n+  %}\n+  ins_pipe( pipe_slow );\n@@ -2761,6 +17279,11 @@\n-\/\/ Operands for bound floating pointer register arguments\n-operand rxmm0() %{\n-  constraint(ALLOC_IN_RC(xmm0_reg));\n-  match(VecX);\n-  format%{%}\n-  interface(REG_INTER);\n+instruct mask_all_evexI_GT32(kReg dst, rRegI src, rRegL tmp) %{\n+  predicate(Matcher::vector_length(n) > 32);\n+  match(Set dst (MaskAll src));\n+  effect(TEMP tmp);\n+  format %{ \"mask_all_evexI_GT32 $dst, $src \\t! using $tmp as TEMP\" %}\n+  ins_encode %{\n+    int mask_len = Matcher::vector_length(this);\n+    __ movslq($tmp$$Register, $src$$Register);\n+    __ vector_maskall_operation($dst$$KRegister, $tmp$$Register, mask_len);\n+  %}\n+  ins_pipe( pipe_slow );\n@@ -2769,19 +17292,15 @@\n-\/\/----------OPERANDS-----------------------------------------------------------\n-\/\/ Operand definitions must precede instruction definitions for correct parsing\n-\/\/ in the ADLC because operands constitute user defined types which are used in\n-\/\/ instruction definitions.\n-\n-\/\/ Vectors\n-\n-\/\/ Dummy generic vector class. Should be used for all vector operands.\n-\/\/ Replaced with vec[SDXYZ] during post-selection pass.\n-operand vec() %{\n-  constraint(ALLOC_IN_RC(dynamic));\n-  match(VecX);\n-  match(VecY);\n-  match(VecZ);\n-  match(VecS);\n-  match(VecD);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n+\/\/ ============================================================================\n+\/\/ Procedure Call\/Return Instructions\n+\/\/ Call Java Static Instruction\n+\/\/ Note: If this code changes, the corresponding ret_addr_offset() and\n+\/\/       compute_padding() functions will have to be adjusted.\n+instruct CallStaticJavaDirect(method meth) %{\n+  match(CallStaticJava);\n+  effect(USE meth);\n+\n+  ins_cost(300);\n+  format %{ \"call,static \" %}\n+  opcode(0xE8); \/* E8 cd *\/\n+  ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);\n+  ins_pipe(pipe_slow);\n+  ins_alignment(4);\n@@ -2790,11 +17309,7 @@\n-\/\/ Dummy generic legacy vector class. Should be used for all legacy vector operands.\n-\/\/ Replaced with legVec[SDXYZ] during post-selection cleanup.\n-\/\/ Note: legacy register class is used to avoid extra (unneeded in 32-bit VM)\n-\/\/ runtime code generation via reg_class_dynamic.\n-operand legVec() %{\n-  constraint(ALLOC_IN_RC(dynamic));\n-  match(VecX);\n-  match(VecY);\n-  match(VecZ);\n-  match(VecS);\n-  match(VecD);\n+\/\/ Call Java Dynamic Instruction\n+\/\/ Note: If this code changes, the corresponding ret_addr_offset() and\n+\/\/       compute_padding() functions will have to be adjusted.\n+instruct CallDynamicJavaDirect(method meth)\n+%{\n+  match(CallDynamicJava);\n+  effect(USE meth);\n@@ -2802,2 +17317,6 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"movq    rax, #Universe::non_oop_word()\\n\\t\"\n+            \"call,dynamic \" %}\n+  ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);\n+  ins_pipe(pipe_slow);\n+  ins_alignment(4);\n@@ -2806,4 +17325,5 @@\n-\/\/ Replaces vec during post-selection cleanup. See above.\n-operand vecS() %{\n-  constraint(ALLOC_IN_RC(vectors_reg_vlbwdq));\n-  match(VecS);\n+\/\/ Call Runtime Instruction\n+instruct CallRuntimeDirect(method meth)\n+%{\n+  match(CallRuntime);\n+  effect(USE meth);\n@@ -2811,2 +17331,4 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"call,runtime \" %}\n+  ins_encode(clear_avx, Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n@@ -2815,4 +17337,5 @@\n-\/\/ Replaces legVec during post-selection cleanup. See above.\n-operand legVecS() %{\n-  constraint(ALLOC_IN_RC(vectors_reg_legacy));\n-  match(VecS);\n+\/\/ Call runtime without safepoint\n+instruct CallLeafDirect(method meth)\n+%{\n+  match(CallLeaf);\n+  effect(USE meth);\n@@ -2820,2 +17343,4 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"call_leaf,runtime \" %}\n+  ins_encode(clear_avx, Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n@@ -2824,4 +17349,5 @@\n-\/\/ Replaces vec during post-selection cleanup. See above.\n-operand vecD() %{\n-  constraint(ALLOC_IN_RC(vectord_reg_vlbwdq));\n-  match(VecD);\n+\/\/ Call runtime without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+  effect(USE meth);\n@@ -2829,2 +17355,4 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"call_leaf,vector \" %}\n+  ins_encode(Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n@@ -2833,4 +17361,6 @@\n-\/\/ Replaces legVec during post-selection cleanup. See above.\n-operand legVecD() %{\n-  constraint(ALLOC_IN_RC(vectord_reg_legacy));\n-  match(VecD);\n+\/\/ Call runtime without safepoint\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPInDirect(rRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == nullptr);\n+  match(CallLeafNoFP target);\n@@ -2838,2 +17368,7 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"call_leaf_nofp,runtime indirect \" %}\n+  ins_encode %{\n+     __ call($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n@@ -2842,4 +17377,6 @@\n-\/\/ Replaces vec during post-selection cleanup. See above.\n-operand vecX() %{\n-  constraint(ALLOC_IN_RC(vectorx_reg_vlbwdq));\n-  match(VecX);\n+\/\/ Call runtime without safepoint\n+instruct CallLeafNoFPDirect(method meth)\n+%{\n+  predicate(n->as_Call()->entry_point() != nullptr);\n+  match(CallLeafNoFP);\n+  effect(USE meth);\n@@ -2847,2 +17384,4 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"call_leaf_nofp,runtime \" %}\n+  ins_encode(clear_avx, Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n@@ -2851,4 +17390,7 @@\n-\/\/ Replaces legVec during post-selection cleanup. See above.\n-operand legVecX() %{\n-  constraint(ALLOC_IN_RC(vectorx_reg_legacy));\n-  match(VecX);\n+\/\/ Return Instruction\n+\/\/ Remove the return address & jump to it.\n+\/\/ Notice: We always emit a nop after a ret to make sure there is room\n+\/\/ for safepoint patching\n+instruct Ret()\n+%{\n+  match(Return);\n@@ -2856,2 +17398,5 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  format %{ \"ret\" %}\n+  ins_encode %{\n+    __ ret(0);\n+  %}\n+  ins_pipe(pipe_jmp);\n@@ -2860,4 +17405,9 @@\n-\/\/ Replaces vec during post-selection cleanup. See above.\n-operand vecY() %{\n-  constraint(ALLOC_IN_RC(vectory_reg_vlbwdq));\n-  match(VecY);\n+\/\/ Tail Call; Jump from runtime stub to Java code.\n+\/\/ Also known as an 'interprocedural jump'.\n+\/\/ Target of jump will eventually return to caller.\n+\/\/ TailJump below removes the return address.\n+\/\/ Don't use rbp for 'jump_target' because a MachEpilogNode has already been\n+\/\/ emitted just above the TailCall which has reset rbp to the caller state.\n+instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_ptr)\n+%{\n+  match(TailCall jump_target method_ptr);\n@@ -2865,2 +17415,6 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"jmp     $jump_target\\t# rbx holds method\" %}\n+  ins_encode %{\n+    __ jmp($jump_target$$Register);\n+  %}\n+  ins_pipe(pipe_jmp);\n@@ -2869,4 +17423,5 @@\n-\/\/ Replaces legVec during post-selection cleanup. See above.\n-operand legVecY() %{\n-  constraint(ALLOC_IN_RC(vectory_reg_legacy));\n-  match(VecY);\n+\/\/ Tail Jump; remove the return address; jump to target.\n+\/\/ TailCall above leaves the return address around.\n+instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)\n+%{\n+  match(TailJump jump_target ex_oop);\n@@ -2874,2 +17429,8 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  ins_cost(300);\n+  format %{ \"popq    rdx\\t# pop return address\\n\\t\"\n+            \"jmp     $jump_target\" %}\n+  ins_encode %{\n+    __ popq(as_Register(RDX_enc));\n+    __ jmp($jump_target$$Register);\n+  %}\n+  ins_pipe(pipe_jmp);\n@@ -2878,4 +17439,4 @@\n-\/\/ Replaces vec during post-selection cleanup. See above.\n-operand vecZ() %{\n-  constraint(ALLOC_IN_RC(vectorz_reg));\n-  match(VecZ);\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp()\n+%{\n+  match(ForwardException);\n@@ -2883,2 +17444,5 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  format %{ \"jmp     forward_exception_stub\" %}\n+  ins_encode %{\n+    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()), noreg);\n+  %}\n+  ins_pipe(pipe_jmp);\n@@ -2887,4 +17451,6 @@\n-\/\/ Replaces legVec during post-selection cleanup. See above.\n-operand legVecZ() %{\n-  constraint(ALLOC_IN_RC(vectorz_reg_legacy));\n-  match(VecZ);\n+\/\/ Create exception oop: created by stack-crawling runtime code.\n+\/\/ Created exception is now available to this handler, and is setup\n+\/\/ just prior to jumping to this handler.  No code emitted.\n+instruct CreateException(rax_RegP ex_oop)\n+%{\n+  match(Set ex_oop (CreateEx));\n@@ -2892,2 +17458,5 @@\n-  format %{ %}\n-  interface(REG_INTER);\n+  size(0);\n+  \/\/ use the following format syntax\n+  format %{ \"# exception oop is in rax; no code emitted\" %}\n+  ins_encode();\n+  ins_pipe(empty);\n@@ -2896,3 +17465,6 @@\n-\/\/ INSTRUCTIONS -- Platform independent definitions (same for 32- and 64-bit)\n-\n-\/\/ ============================================================================\n+\/\/ Rethrow exception:\n+\/\/ The exception oop will come in the first argument position.\n+\/\/ Then JUMP (not call) to the rethrow stub code.\n+instruct RethrowException()\n+%{\n+  match(Rethrow);\n@@ -2900,3 +17472,2 @@\n-instruct ShouldNotReachHere() %{\n-  match(Halt);\n-  format %{ \"stop\\t# ShouldNotReachHere\" %}\n+  \/\/ use the following format syntax\n+  format %{ \"jmp     rethrow_stub\" %}\n@@ -2904,4 +17475,1 @@\n-    if (is_reachable()) {\n-      const char* str = __ code_string(_halt_reason);\n-      __ stop(str);\n-    }\n+    __ jump(RuntimeAddress(OptoRuntime::rethrow_stub()), noreg);\n@@ -2909,1 +17477,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_jmp);\n@@ -2913,0 +17481,12 @@\n+\/\/ This name is KNOWN by the ADLC and cannot be changed.\n+\/\/ The ADLC forces a 'TypeRawPtr::BOTTOM' output type\n+\/\/ for this guy.\n+instruct tlsLoadP(r15_RegP dst) %{\n+  match(Set dst (ThreadLocal));\n+  effect(DEF dst);\n+\n+  size(0);\n+  format %{ \"# TLS is in R15\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -10975,0 +25555,326 @@\n+\n+\/\/----------PEEPHOLE RULES-----------------------------------------------------\n+\/\/ These must follow all instruction definitions as they use the names\n+\/\/ defined in the instructions definitions.\n+\/\/\n+\/\/ peeppredicate ( rule_predicate );\n+\/\/ \/\/ the predicate unless which the peephole rule will be ignored\n+\/\/\n+\/\/ peepmatch ( root_instr_name [preceding_instruction]* );\n+\/\/\n+\/\/ peepprocedure ( procedure_name );\n+\/\/ \/\/ provide a procedure name to perform the optimization, the procedure should\n+\/\/ \/\/ reside in the architecture dependent peephole file, the method has the\n+\/\/ \/\/ signature of MachNode* (Block*, int, PhaseRegAlloc*, (MachNode*)(*)(), int...)\n+\/\/ \/\/ with the arguments being the basic block, the current node index inside the\n+\/\/ \/\/ block, the register allocator, the functions upon invoked return a new node\n+\/\/ \/\/ defined in peepreplace, and the rules of the nodes appearing in the\n+\/\/ \/\/ corresponding peepmatch, the function return true if successful, else\n+\/\/ \/\/ return false\n+\/\/\n+\/\/ peepconstraint %{\n+\/\/ (instruction_number.operand_name relational_op instruction_number.operand_name\n+\/\/  [, ...] );\n+\/\/ \/\/ instruction numbers are zero-based using left to right order in peepmatch\n+\/\/\n+\/\/ peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );\n+\/\/ \/\/ provide an instruction_number.operand_name for each operand that appears\n+\/\/ \/\/ in the replacement instruction's match rule\n+\/\/\n+\/\/ ---------VM FLAGS---------------------------------------------------------\n+\/\/\n+\/\/ All peephole optimizations can be turned off using -XX:-OptoPeephole\n+\/\/\n+\/\/ Each peephole rule is given an identifying number starting with zero and\n+\/\/ increasing by one in the order seen by the parser.  An individual peephole\n+\/\/ can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#\n+\/\/ on the command-line.\n+\/\/\n+\/\/ ---------CURRENT LIMITATIONS----------------------------------------------\n+\/\/\n+\/\/ Only transformations inside a basic block (do we need more for peephole)\n+\/\/\n+\/\/ ---------EXAMPLE----------------------------------------------------------\n+\/\/\n+\/\/ \/\/ pertinent parts of existing instructions in architecture description\n+\/\/ instruct movI(rRegI dst, rRegI src)\n+\/\/ %{\n+\/\/   match(Set dst (CopyI src));\n+\/\/ %}\n+\/\/\n+\/\/ instruct incI_rReg(rRegI dst, immI_1 src, rFlagsReg cr)\n+\/\/ %{\n+\/\/   match(Set dst (AddI dst src));\n+\/\/   effect(KILL cr);\n+\/\/ %}\n+\/\/\n+\/\/ instruct leaI_rReg_immI(rRegI dst, immI_1 src)\n+\/\/ %{\n+\/\/   match(Set dst (AddI dst src));\n+\/\/ %}\n+\/\/\n+\/\/ 1. Simple replacement\n+\/\/ - Only match adjacent instructions in same basic block\n+\/\/ - Only equality constraints\n+\/\/ - Only constraints between operands, not (0.dest_reg == RAX_enc)\n+\/\/ - Only one replacement instruction\n+\/\/\n+\/\/ \/\/ Change (inc mov) to lea\n+\/\/ peephole %{\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n+\/\/   \/\/ increment preceded by register-register move\n+\/\/   peepmatch ( incI_rReg movI );\n+\/\/   \/\/ require that the destination register of the increment\n+\/\/   \/\/ match the destination register of the move\n+\/\/   peepconstraint ( 0.dst == 1.dst );\n+\/\/   \/\/ construct a replacement instruction that sets\n+\/\/   \/\/ the destination to ( move's source register + one )\n+\/\/   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );\n+\/\/ %}\n+\/\/\n+\/\/ 2. Procedural replacement\n+\/\/ - More flexible finding relevent nodes\n+\/\/ - More flexible constraints\n+\/\/ - More flexible transformations\n+\/\/ - May utilise architecture-dependent API more effectively\n+\/\/ - Currently only one replacement instruction due to adlc parsing capabilities\n+\/\/\n+\/\/ \/\/ Change (inc mov) to lea\n+\/\/ peephole %{\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n+\/\/   \/\/ the rule numbers of these nodes inside are passed into the function below\n+\/\/   peepmatch ( incI_rReg movI );\n+\/\/   \/\/ the method that takes the responsibility of transformation\n+\/\/   peepprocedure ( inc_mov_to_lea );\n+\/\/   \/\/ the replacement is a leaI_rReg_immI, a lambda upon invoked creating this\n+\/\/   \/\/ node is passed into the function above\n+\/\/   peepreplace ( leaI_rReg_immI() );\n+\/\/ %}\n+\n+\/\/ These instructions is not matched by the matcher but used by the peephole\n+instruct leaI_rReg_rReg_peep(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leal(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leal(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_immI_peep(rRegI dst, rRegI src1, immI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_immI2_peep(rRegI dst, rRegI src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftI src shift));\n+  format %{ \"leal    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leal($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leal($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_peep(rRegL dst, rRegL src1, rRegL src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leaq(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leaq(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_immL32_peep(rRegL dst, rRegL src1, immL32 src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_immI2_peep(rRegL dst, rRegL src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftL src shift));\n+  format %{ \"leaq    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leaq($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leaq($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ These peephole rules replace mov + I pairs (where I is one of {add, inc, dec,\n+\/\/ sal}) with lea instructions. The {add, sal} rules are beneficial in\n+\/\/ processors with at least partial ALU support for lea\n+\/\/ (supports_fast_2op_lea()), whereas the {inc, dec} rules are only generally\n+\/\/ beneficial for processors with full ALU support\n+\/\/ (VM_Version::supports_fast_3op_lea()) and Intel Cascade Lake.\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaI_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n+  peepmatch (incI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n+  peepmatch (decI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salI_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI2_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaL_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n+  peepmatch (incL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n+  peepmatch (decL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salL_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immI2_peep());\n+%}\n+\n+peephole\n+%{\n+  peepmatch (leaPCompressedOopOffset);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n+peephole\n+%{\n+  peepmatch (leaP8Narrow);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n+peephole\n+%{\n+  peepmatch (leaP32Narrow);\n+  peepprocedure (lea_remove_redundant);\n+%}\n+\n+\/\/ These peephole rules matches instructions which set flags and are followed by a testI\/L_reg\n+\/\/ The test instruction is redudanent in case the downstream instuctions (like JCC or CMOV) only use flags that are already set by the previous instruction\n+\n+\/\/int variant\n+peephole\n+%{\n+  peepmatch (testI_reg);\n+  peepprocedure (test_may_remove);\n+%}\n+\n+\/\/long variant\n+peephole\n+%{\n+  peepmatch (testL_reg);\n+  peepprocedure (test_may_remove);\n+%}\n+\n+\n+\/\/----------SMARTSPILL RULES---------------------------------------------------\n+\/\/ These must follow all instruction definitions as they use the names\n+\/\/ defined in the instructions definitions.\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":16419,"deletions":1513,"binary":false,"changes":17932,"status":"modified"},{"patch":"@@ -1,15015 +0,0 @@\n-\/\/\n-\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it\n-\/\/ under the terms of the GNU General Public License version 2 only, as\n-\/\/ published by the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n-\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-\/\/ version 2 for more details (a copy is included in the LICENSE file that\n-\/\/ accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version\n-\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n-\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-\/\/ or visit www.oracle.com if you need additional information or have any\n-\/\/ questions.\n-\/\/\n-\/\/\n-\n-\/\/ AMD64 Architecture Description File\n-\n-\/\/----------REGISTER DEFINITION BLOCK------------------------------------------\n-\/\/ This information is used by the matcher and the register allocator to\n-\/\/ describe individual registers and classes of registers within the target\n-\/\/ architecture.\n-\n-register %{\n-\/\/----------Architecture Description Register Definitions----------------------\n-\/\/ General Registers\n-\/\/ \"reg_def\"  name ( register save type, C convention save type,\n-\/\/                   ideal register type, encoding );\n-\/\/ Register Save Types:\n-\/\/\n-\/\/ NS  = No-Save:       The register allocator assumes that these registers\n-\/\/                      can be used without saving upon entry to the method, &\n-\/\/                      that they do not need to be saved at call sites.\n-\/\/\n-\/\/ SOC = Save-On-Call:  The register allocator assumes that these registers\n-\/\/                      can be used without saving upon entry to the method,\n-\/\/                      but that they must be saved at call sites.\n-\/\/\n-\/\/ SOE = Save-On-Entry: The register allocator assumes that these registers\n-\/\/                      must be saved before using them upon entry to the\n-\/\/                      method, but they do not need to be saved at call\n-\/\/                      sites.\n-\/\/\n-\/\/ AS  = Always-Save:   The register allocator assumes that these registers\n-\/\/                      must be saved before using them upon entry to the\n-\/\/                      method, & that they must be saved at call sites.\n-\/\/\n-\/\/ Ideal Register Type is used to determine how to save & restore a\n-\/\/ register.  Op_RegI will get spilled with LoadI\/StoreI, Op_RegP will get\n-\/\/ spilled with LoadP\/StoreP.  If the register supports both, use Op_RegI.\n-\/\/\n-\/\/ The encoding number is the actual bit-pattern placed into the opcodes.\n-\n-\/\/ General Registers\n-\/\/ R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when\n-\/\/ used as byte registers)\n-\n-\/\/ Previously set RBX, RSI, and RDI as save-on-entry for java code\n-\/\/ Turn off SOE in java-code due to frequent use of uncommon-traps.\n-\/\/ Now that allocator is better, turn on RSI and RDI as SOE registers.\n-\n-reg_def RAX  (SOC, SOC, Op_RegI,  0, rax->as_VMReg());\n-reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax->as_VMReg()->next());\n-\n-reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx->as_VMReg());\n-reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx->as_VMReg()->next());\n-\n-reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx->as_VMReg());\n-reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx->as_VMReg()->next());\n-\n-reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx->as_VMReg());\n-reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx->as_VMReg()->next());\n-\n-reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp->as_VMReg());\n-reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp->as_VMReg()->next());\n-\n-\/\/ now that adapter frames are gone RBP is always saved and restored by the prolog\/epilog code\n-reg_def RBP  (NS, SOE, Op_RegI,  5, rbp->as_VMReg());\n-reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp->as_VMReg()->next());\n-\n-#ifdef _WIN64\n-\n-reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi->as_VMReg());\n-reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi->as_VMReg()->next());\n-\n-reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi->as_VMReg());\n-reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi->as_VMReg()->next());\n-\n-#else\n-\n-reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi->as_VMReg());\n-reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi->as_VMReg()->next());\n-\n-reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi->as_VMReg());\n-reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi->as_VMReg()->next());\n-\n-#endif\n-\n-reg_def R8   (SOC, SOC, Op_RegI,  8, r8->as_VMReg());\n-reg_def R8_H (SOC, SOC, Op_RegI,  8, r8->as_VMReg()->next());\n-\n-reg_def R9   (SOC, SOC, Op_RegI,  9, r9->as_VMReg());\n-reg_def R9_H (SOC, SOC, Op_RegI,  9, r9->as_VMReg()->next());\n-\n-reg_def R10  (SOC, SOC, Op_RegI, 10, r10->as_VMReg());\n-reg_def R10_H(SOC, SOC, Op_RegI, 10, r10->as_VMReg()->next());\n-\n-reg_def R11  (SOC, SOC, Op_RegI, 11, r11->as_VMReg());\n-reg_def R11_H(SOC, SOC, Op_RegI, 11, r11->as_VMReg()->next());\n-\n-reg_def R12  (SOC, SOE, Op_RegI, 12, r12->as_VMReg());\n-reg_def R12_H(SOC, SOE, Op_RegI, 12, r12->as_VMReg()->next());\n-\n-reg_def R13  (SOC, SOE, Op_RegI, 13, r13->as_VMReg());\n-reg_def R13_H(SOC, SOE, Op_RegI, 13, r13->as_VMReg()->next());\n-\n-reg_def R14  (SOC, SOE, Op_RegI, 14, r14->as_VMReg());\n-reg_def R14_H(SOC, SOE, Op_RegI, 14, r14->as_VMReg()->next());\n-\n-reg_def R15  (SOC, SOE, Op_RegI, 15, r15->as_VMReg());\n-reg_def R15_H(SOC, SOE, Op_RegI, 15, r15->as_VMReg()->next());\n-\n-reg_def R16  (SOC, SOC, Op_RegI, 16, r16->as_VMReg());\n-reg_def R16_H(SOC, SOC, Op_RegI, 16, r16->as_VMReg()->next());\n-\n-reg_def R17  (SOC, SOC, Op_RegI, 17, r17->as_VMReg());\n-reg_def R17_H(SOC, SOC, Op_RegI, 17, r17->as_VMReg()->next());\n-\n-reg_def R18  (SOC, SOC, Op_RegI, 18, r18->as_VMReg());\n-reg_def R18_H(SOC, SOC, Op_RegI, 18, r18->as_VMReg()->next());\n-\n-reg_def R19  (SOC, SOC, Op_RegI, 19, r19->as_VMReg());\n-reg_def R19_H(SOC, SOC, Op_RegI, 19, r19->as_VMReg()->next());\n-\n-reg_def R20  (SOC, SOC, Op_RegI, 20, r20->as_VMReg());\n-reg_def R20_H(SOC, SOC, Op_RegI, 20, r20->as_VMReg()->next());\n-\n-reg_def R21  (SOC, SOC, Op_RegI, 21, r21->as_VMReg());\n-reg_def R21_H(SOC, SOC, Op_RegI, 21, r21->as_VMReg()->next());\n-\n-reg_def R22  (SOC, SOC, Op_RegI, 22, r22->as_VMReg());\n-reg_def R22_H(SOC, SOC, Op_RegI, 22, r22->as_VMReg()->next());\n-\n-reg_def R23  (SOC, SOC, Op_RegI, 23, r23->as_VMReg());\n-reg_def R23_H(SOC, SOC, Op_RegI, 23, r23->as_VMReg()->next());\n-\n-reg_def R24  (SOC, SOC, Op_RegI, 24, r24->as_VMReg());\n-reg_def R24_H(SOC, SOC, Op_RegI, 24, r24->as_VMReg()->next());\n-\n-reg_def R25  (SOC, SOC, Op_RegI, 25, r25->as_VMReg());\n-reg_def R25_H(SOC, SOC, Op_RegI, 25, r25->as_VMReg()->next());\n-\n-reg_def R26  (SOC, SOC, Op_RegI, 26, r26->as_VMReg());\n-reg_def R26_H(SOC, SOC, Op_RegI, 26, r26->as_VMReg()->next());\n-\n-reg_def R27  (SOC, SOC, Op_RegI, 27, r27->as_VMReg());\n-reg_def R27_H(SOC, SOC, Op_RegI, 27, r27->as_VMReg()->next());\n-\n-reg_def R28  (SOC, SOC, Op_RegI, 28, r28->as_VMReg());\n-reg_def R28_H(SOC, SOC, Op_RegI, 28, r28->as_VMReg()->next());\n-\n-reg_def R29  (SOC, SOC, Op_RegI, 29, r29->as_VMReg());\n-reg_def R29_H(SOC, SOC, Op_RegI, 29, r29->as_VMReg()->next());\n-\n-reg_def R30  (SOC, SOC, Op_RegI, 30, r30->as_VMReg());\n-reg_def R30_H(SOC, SOC, Op_RegI, 30, r30->as_VMReg()->next());\n-\n-reg_def R31  (SOC, SOC, Op_RegI, 31, r31->as_VMReg());\n-reg_def R31_H(SOC, SOC, Op_RegI, 31, r31->as_VMReg()->next());\n-\n-\/\/ Floating Point Registers\n-\n-\/\/ Specify priority of register selection within phases of register\n-\/\/ allocation.  Highest priority is first.  A useful heuristic is to\n-\/\/ give registers a low priority when they are required by machine\n-\/\/ instructions, like EAX and EDX on I486, and choose no-save registers\n-\/\/ before save-on-call, & save-on-call before save-on-entry.  Registers\n-\/\/ which participate in fixed calling sequences should come last.\n-\/\/ Registers which are used as pairs must fall on an even boundary.\n-\n-alloc_class chunk0(R10,         R10_H,\n-                   R11,         R11_H,\n-                   R8,          R8_H,\n-                   R9,          R9_H,\n-                   R12,         R12_H,\n-                   RCX,         RCX_H,\n-                   RBX,         RBX_H,\n-                   RDI,         RDI_H,\n-                   RDX,         RDX_H,\n-                   RSI,         RSI_H,\n-                   RAX,         RAX_H,\n-                   RBP,         RBP_H,\n-                   R13,         R13_H,\n-                   R14,         R14_H,\n-                   R15,         R15_H,\n-                   R16,         R16_H,\n-                   R17,         R17_H,\n-                   R18,         R18_H,\n-                   R19,         R19_H,\n-                   R20,         R20_H,\n-                   R21,         R21_H,\n-                   R22,         R22_H,\n-                   R23,         R23_H,\n-                   R24,         R24_H,\n-                   R25,         R25_H,\n-                   R26,         R26_H,\n-                   R27,         R27_H,\n-                   R28,         R28_H,\n-                   R29,         R29_H,\n-                   R30,         R30_H,\n-                   R31,         R31_H,\n-                   RSP,         RSP_H);\n-\n-\n-\/\/----------Architecture Description Register Classes--------------------------\n-\/\/ Several register classes are automatically defined based upon information in\n-\/\/ this architecture description.\n-\/\/ 1) reg_class inline_cache_reg           ( \/* as def'd in frame section *\/ )\n-\/\/ 2) reg_class stack_slots( \/* one chunk of stack-based \"registers\" *\/ )\n-\/\/\n-\n-\/\/ Empty register class.\n-reg_class no_reg();\n-\n-\/\/ Class for all pointer\/long registers including APX extended GPRs.\n-reg_class all_reg(RAX, RAX_H,\n-                  RDX, RDX_H,\n-                  RBP, RBP_H,\n-                  RDI, RDI_H,\n-                  RSI, RSI_H,\n-                  RCX, RCX_H,\n-                  RBX, RBX_H,\n-                  RSP, RSP_H,\n-                  R8,  R8_H,\n-                  R9,  R9_H,\n-                  R10, R10_H,\n-                  R11, R11_H,\n-                  R12, R12_H,\n-                  R13, R13_H,\n-                  R14, R14_H,\n-                  R15, R15_H,\n-                  R16, R16_H,\n-                  R17, R17_H,\n-                  R18, R18_H,\n-                  R19, R19_H,\n-                  R20, R20_H,\n-                  R21, R21_H,\n-                  R22, R22_H,\n-                  R23, R23_H,\n-                  R24, R24_H,\n-                  R25, R25_H,\n-                  R26, R26_H,\n-                  R27, R27_H,\n-                  R28, R28_H,\n-                  R29, R29_H,\n-                  R30, R30_H,\n-                  R31, R31_H);\n-\n-\/\/ Class for all int registers including APX extended GPRs.\n-reg_class all_int_reg(RAX\n-                      RDX,\n-                      RBP,\n-                      RDI,\n-                      RSI,\n-                      RCX,\n-                      RBX,\n-                      R8,\n-                      R9,\n-                      R10,\n-                      R11,\n-                      R12,\n-                      R13,\n-                      R14,\n-                      R16,\n-                      R17,\n-                      R18,\n-                      R19,\n-                      R20,\n-                      R21,\n-                      R22,\n-                      R23,\n-                      R24,\n-                      R25,\n-                      R26,\n-                      R27,\n-                      R28,\n-                      R29,\n-                      R30,\n-                      R31);\n-\n-\/\/ Class for all pointer registers\n-reg_class any_reg %{\n-  return _ANY_REG_mask;\n-%}\n-\n-\/\/ Class for all pointer registers (excluding RSP)\n-reg_class ptr_reg %{\n-  return _PTR_REG_mask;\n-%}\n-\n-\/\/ Class for all pointer registers (excluding RSP and RBP)\n-reg_class ptr_reg_no_rbp %{\n-  return _PTR_REG_NO_RBP_mask;\n-%}\n-\n-\/\/ Class for all pointer registers (excluding RAX and RSP)\n-reg_class ptr_no_rax_reg %{\n-  return _PTR_NO_RAX_REG_mask;\n-%}\n-\n-\/\/ Class for all pointer registers (excluding RAX, RBX, and RSP)\n-reg_class ptr_no_rax_rbx_reg %{\n-  return _PTR_NO_RAX_RBX_REG_mask;\n-%}\n-\n-\/\/ Class for all long registers (excluding RSP)\n-reg_class long_reg %{\n-  return _LONG_REG_mask;\n-%}\n-\n-\/\/ Class for all long registers (excluding RAX, RDX and RSP)\n-reg_class long_no_rax_rdx_reg %{\n-  return _LONG_NO_RAX_RDX_REG_mask;\n-%}\n-\n-\/\/ Class for all long registers (excluding RCX and RSP)\n-reg_class long_no_rcx_reg %{\n-  return _LONG_NO_RCX_REG_mask;\n-%}\n-\n-\/\/ Class for all long registers (excluding RBP and R13)\n-reg_class long_no_rbp_r13_reg %{\n-  return _LONG_NO_RBP_R13_REG_mask;\n-%}\n-\n-\/\/ Class for all int registers (excluding RSP)\n-reg_class int_reg %{\n-  return _INT_REG_mask;\n-%}\n-\n-\/\/ Class for all int registers (excluding RAX, RDX, and RSP)\n-reg_class int_no_rax_rdx_reg %{\n-  return _INT_NO_RAX_RDX_REG_mask;\n-%}\n-\n-\/\/ Class for all int registers (excluding RCX and RSP)\n-reg_class int_no_rcx_reg %{\n-  return _INT_NO_RCX_REG_mask;\n-%}\n-\n-\/\/ Class for all int registers (excluding RBP and R13)\n-reg_class int_no_rbp_r13_reg %{\n-  return _INT_NO_RBP_R13_REG_mask;\n-%}\n-\n-\/\/ Singleton class for RAX pointer register\n-reg_class ptr_rax_reg(RAX, RAX_H);\n-\n-\/\/ Singleton class for RBX pointer register\n-reg_class ptr_rbx_reg(RBX, RBX_H);\n-\n-\/\/ Singleton class for RSI pointer register\n-reg_class ptr_rsi_reg(RSI, RSI_H);\n-\n-\/\/ Singleton class for RBP pointer register\n-reg_class ptr_rbp_reg(RBP, RBP_H);\n-\n-\/\/ Singleton class for RDI pointer register\n-reg_class ptr_rdi_reg(RDI, RDI_H);\n-\n-\/\/ Singleton class for stack pointer\n-reg_class ptr_rsp_reg(RSP, RSP_H);\n-\n-\/\/ Singleton class for TLS pointer\n-reg_class ptr_r15_reg(R15, R15_H);\n-\n-\/\/ Singleton class for RAX long register\n-reg_class long_rax_reg(RAX, RAX_H);\n-\n-\/\/ Singleton class for RCX long register\n-reg_class long_rcx_reg(RCX, RCX_H);\n-\n-\/\/ Singleton class for RDX long register\n-reg_class long_rdx_reg(RDX, RDX_H);\n-\n-\/\/ Singleton class for R11 long register\n-reg_class long_r11_reg(R11, R11_H);\n-\n-\/\/ Singleton class for RAX int register\n-reg_class int_rax_reg(RAX);\n-\n-\/\/ Singleton class for RBX int register\n-reg_class int_rbx_reg(RBX);\n-\n-\/\/ Singleton class for RCX int register\n-reg_class int_rcx_reg(RCX);\n-\n-\/\/ Singleton class for RDX int register\n-reg_class int_rdx_reg(RDX);\n-\n-\/\/ Singleton class for RDI int register\n-reg_class int_rdi_reg(RDI);\n-\n-\/\/ Singleton class for instruction pointer\n-\/\/ reg_class ip_reg(RIP);\n-\n-%}\n-\n-\/\/----------SOURCE BLOCK-------------------------------------------------------\n-\/\/ This is a block of C++ code which provides values, functions, and\n-\/\/ definitions necessary in the rest of the architecture description\n-\n-source_hpp %{\n-\n-#include \"peephole_x86_64.hpp\"\n-\n-bool castLL_is_imm32(const Node* n);\n-\n-%}\n-\n-source %{\n-\n-bool castLL_is_imm32(const Node* n) {\n-  assert(n->is_CastLL(), \"must be a CastLL\");\n-  const TypeLong* t = n->bottom_type()->is_long();\n-  return (t->_lo == min_jlong || Assembler::is_simm32(t->_lo)) && (t->_hi == max_jlong || Assembler::is_simm32(t->_hi));\n-}\n-\n-%}\n-\n-\/\/ Register masks\n-source_hpp %{\n-\n-extern RegMask _ANY_REG_mask;\n-extern RegMask _PTR_REG_mask;\n-extern RegMask _PTR_REG_NO_RBP_mask;\n-extern RegMask _PTR_NO_RAX_REG_mask;\n-extern RegMask _PTR_NO_RAX_RBX_REG_mask;\n-extern RegMask _LONG_REG_mask;\n-extern RegMask _LONG_NO_RAX_RDX_REG_mask;\n-extern RegMask _LONG_NO_RCX_REG_mask;\n-extern RegMask _LONG_NO_RBP_R13_REG_mask;\n-extern RegMask _INT_REG_mask;\n-extern RegMask _INT_NO_RAX_RDX_REG_mask;\n-extern RegMask _INT_NO_RCX_REG_mask;\n-extern RegMask _INT_NO_RBP_R13_REG_mask;\n-extern RegMask _FLOAT_REG_mask;\n-\n-extern RegMask _STACK_OR_PTR_REG_mask;\n-extern RegMask _STACK_OR_LONG_REG_mask;\n-extern RegMask _STACK_OR_INT_REG_mask;\n-\n-inline const RegMask& STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }\n-inline const RegMask& STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }\n-inline const RegMask& STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }\n-\n-%}\n-\n-source %{\n-#define   RELOC_IMM64    Assembler::imm_operand\n-#define   RELOC_DISP32   Assembler::disp32_operand\n-\n-#define __ masm->\n-\n-RegMask _ANY_REG_mask;\n-RegMask _PTR_REG_mask;\n-RegMask _PTR_REG_NO_RBP_mask;\n-RegMask _PTR_NO_RAX_REG_mask;\n-RegMask _PTR_NO_RAX_RBX_REG_mask;\n-RegMask _LONG_REG_mask;\n-RegMask _LONG_NO_RAX_RDX_REG_mask;\n-RegMask _LONG_NO_RCX_REG_mask;\n-RegMask _LONG_NO_RBP_R13_REG_mask;\n-RegMask _INT_REG_mask;\n-RegMask _INT_NO_RAX_RDX_REG_mask;\n-RegMask _INT_NO_RCX_REG_mask;\n-RegMask _INT_NO_RBP_R13_REG_mask;\n-RegMask _FLOAT_REG_mask;\n-RegMask _STACK_OR_PTR_REG_mask;\n-RegMask _STACK_OR_LONG_REG_mask;\n-RegMask _STACK_OR_INT_REG_mask;\n-\n-static bool need_r12_heapbase() {\n-  return UseCompressedOops;\n-}\n-\n-void reg_mask_init() {\n-  constexpr Register egprs[] = {r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31};\n-\n-  \/\/ _ALL_REG_mask is generated by adlc from the all_reg register class below.\n-  \/\/ We derive a number of subsets from it.\n-  _ANY_REG_mask.assignFrom(_ALL_REG_mask);\n-\n-  if (PreserveFramePointer) {\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n-  }\n-  if (need_r12_heapbase()) {\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n-    _ANY_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()->next()));\n-  }\n-\n-  _PTR_REG_mask.assignFrom(_ANY_REG_mask);\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()));\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(rsp->as_VMReg()->next()));\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()));\n-  _PTR_REG_mask.remove(OptoReg::as_OptoReg(r15->as_VMReg()->next()));\n-  if (!UseAPX) {\n-    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n-      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n-      _PTR_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()->next()));\n-    }\n-  }\n-\n-  _STACK_OR_PTR_REG_mask.assignFrom(_PTR_REG_mask);\n-  _STACK_OR_PTR_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n-\n-  _PTR_REG_NO_RBP_mask.assignFrom(_PTR_REG_mask);\n-  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _PTR_REG_NO_RBP_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n-\n-  _PTR_NO_RAX_REG_mask.assignFrom(_PTR_REG_mask);\n-  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _PTR_NO_RAX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n-\n-  _PTR_NO_RAX_RBX_REG_mask.assignFrom(_PTR_NO_RAX_REG_mask);\n-  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()));\n-  _PTR_NO_RAX_RBX_REG_mask.remove(OptoReg::as_OptoReg(rbx->as_VMReg()->next()));\n-\n-\n-  _LONG_REG_mask.assignFrom(_PTR_REG_mask);\n-  _STACK_OR_LONG_REG_mask.assignFrom(_LONG_REG_mask);\n-  _STACK_OR_LONG_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n-\n-  _LONG_NO_RAX_RDX_REG_mask.assignFrom(_LONG_REG_mask);\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()->next()));\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-  _LONG_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()->next()));\n-\n-  _LONG_NO_RCX_REG_mask.assignFrom(_LONG_REG_mask);\n-  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-  _LONG_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()->next()));\n-\n-  _LONG_NO_RBP_R13_REG_mask.assignFrom(_LONG_REG_mask);\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n-  _LONG_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n-\n-  _INT_REG_mask.assignFrom(_ALL_INT_REG_mask);\n-  if (!UseAPX) {\n-    for (uint i = 0; i < sizeof(egprs)\/sizeof(Register); i++) {\n-      _INT_REG_mask.remove(OptoReg::as_OptoReg(egprs[i]->as_VMReg()));\n-    }\n-  }\n-\n-  if (PreserveFramePointer) {\n-    _INT_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  }\n-  if (need_r12_heapbase()) {\n-    _INT_REG_mask.remove(OptoReg::as_OptoReg(r12->as_VMReg()));\n-  }\n-\n-  _STACK_OR_INT_REG_mask.assignFrom(_INT_REG_mask);\n-  _STACK_OR_INT_REG_mask.or_with(STACK_OR_STACK_SLOTS_mask());\n-\n-  _INT_NO_RAX_RDX_REG_mask.assignFrom(_INT_REG_mask);\n-  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rax->as_VMReg()));\n-  _INT_NO_RAX_RDX_REG_mask.remove(OptoReg::as_OptoReg(rdx->as_VMReg()));\n-\n-  _INT_NO_RCX_REG_mask.assignFrom(_INT_REG_mask);\n-  _INT_NO_RCX_REG_mask.remove(OptoReg::as_OptoReg(rcx->as_VMReg()));\n-\n-  _INT_NO_RBP_R13_REG_mask.assignFrom(_INT_REG_mask);\n-  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n-  _INT_NO_RBP_R13_REG_mask.remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n-\n-  \/\/ _FLOAT_REG_LEGACY_mask\/_FLOAT_REG_EVEX_mask is generated by adlc\n-  \/\/ from the float_reg_legacy\/float_reg_evex register class.\n-  _FLOAT_REG_mask.assignFrom(VM_Version::supports_evex() ? _FLOAT_REG_EVEX_mask : _FLOAT_REG_LEGACY_mask);\n-}\n-\n-static bool generate_vzeroupper(Compile* C) {\n-  return (VM_Version::supports_vzeroupper() && (C->max_vector_size() > 16 || C->clear_upper_avx() == true)) ? true: false;  \/\/ Generate vzeroupper\n-}\n-\n-static int clear_avx_size() {\n-  return generate_vzeroupper(Compile::current()) ? 3: 0;  \/\/ vzeroupper\n-}\n-\n-\/\/ !!!!! Special hack to get all types of calls to specify the byte offset\n-\/\/       from the start of the call to the point where the return address\n-\/\/       will point.\n-int MachCallStaticJavaNode::ret_addr_offset()\n-{\n-  int offset = 5; \/\/ 5 bytes from start of call to where return address points\n-  offset += clear_avx_size();\n-  return offset;\n-}\n-\n-int MachCallDynamicJavaNode::ret_addr_offset()\n-{\n-  int offset = 15; \/\/ 15 bytes from start of call to where return address points\n-  offset += clear_avx_size();\n-  return offset;\n-}\n-\n-int MachCallRuntimeNode::ret_addr_offset() {\n-  if (_entry_point == nullptr) {\n-    \/\/ CallLeafNoFPInDirect\n-    return 3; \/\/ callq (register)\n-  }\n-  int offset = 13; \/\/ movq r10,#addr; callq (r10)\n-  if (this->ideal_Opcode() != Op_CallLeafVector) {\n-    offset += clear_avx_size();\n-  }\n-  return offset;\n-}\n-\n-\/\/\n-\/\/ Compute padding required for nodes which need alignment\n-\/\/\n-\n-\/\/ The address of the call instruction needs to be 4-byte aligned to\n-\/\/ ensure that it does not span a cache line so that it can be patched.\n-int CallStaticJavaDirectNode::compute_padding(int current_offset) const\n-{\n-  current_offset += clear_avx_size(); \/\/ skip vzeroupper\n-  current_offset += 1; \/\/ skip call opcode byte\n-  return align_up(current_offset, alignment_required()) - current_offset;\n-}\n-\n-\/\/ The address of the call instruction needs to be 4-byte aligned to\n-\/\/ ensure that it does not span a cache line so that it can be patched.\n-int CallDynamicJavaDirectNode::compute_padding(int current_offset) const\n-{\n-  current_offset += clear_avx_size(); \/\/ skip vzeroupper\n-  current_offset += 11; \/\/ skip movq instruction + call opcode byte\n-  return align_up(current_offset, alignment_required()) - current_offset;\n-}\n-\n-\/\/ This could be in MacroAssembler but it's fairly C2 specific\n-static void emit_cmpfp_fixup(MacroAssembler* masm) {\n-  Label exit;\n-  __ jccb(Assembler::noParity, exit);\n-  __ pushf();\n-  \/\/\n-  \/\/ comiss\/ucomiss instructions set ZF,PF,CF flags and\n-  \/\/ zero OF,AF,SF for NaN values.\n-  \/\/ Fixup flags by zeroing ZF,PF so that compare of NaN\n-  \/\/ values returns 'less than' result (CF is set).\n-  \/\/ Leave the rest of flags unchanged.\n-  \/\/\n-  \/\/    7 6 5 4 3 2 1 0\n-  \/\/   |S|Z|r|A|r|P|r|C|  (r - reserved bit)\n-  \/\/    0 0 1 0 1 0 1 1   (0x2B)\n-  \/\/\n-  __ andq(Address(rsp, 0), 0xffffff2b);\n-  __ popf();\n-  __ bind(exit);\n-}\n-\n-static void emit_cmpfp3(MacroAssembler* masm, Register dst) {\n-  Label done;\n-  __ movl(dst, -1);\n-  __ jcc(Assembler::parity, done);\n-  __ jcc(Assembler::below, done);\n-  __ setcc(Assembler::notEqual, dst);\n-  __ bind(done);\n-}\n-\n-\/\/ Math.min()    # Math.max()\n-\/\/ --------------------------\n-\/\/ ucomis[s\/d]   #\n-\/\/ ja   -> b     # a\n-\/\/ jp   -> NaN   # NaN\n-\/\/ jb   -> a     # b\n-\/\/ je            #\n-\/\/ |-jz -> a | b # a & b\n-\/\/ |    -> a     #\n-static void emit_fp_min_max(MacroAssembler* masm, XMMRegister dst,\n-                            XMMRegister a, XMMRegister b,\n-                            XMMRegister xmmt, Register rt,\n-                            bool min, bool single) {\n-\n-  Label nan, zero, below, above, done;\n-\n-  if (single)\n-    __ ucomiss(a, b);\n-  else\n-    __ ucomisd(a, b);\n-\n-  if (dst->encoding() != (min ? b : a)->encoding())\n-    __ jccb(Assembler::above, above); \/\/ CF=0 & ZF=0\n-  else\n-    __ jccb(Assembler::above, done);\n-\n-  __ jccb(Assembler::parity, nan);  \/\/ PF=1\n-  __ jccb(Assembler::below, below); \/\/ CF=1\n-\n-  \/\/ equal\n-  __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);\n-  if (single) {\n-    __ ucomiss(a, xmmt);\n-    __ jccb(Assembler::equal, zero);\n-\n-    __ movflt(dst, a);\n-    __ jmp(done);\n-  }\n-  else {\n-    __ ucomisd(a, xmmt);\n-    __ jccb(Assembler::equal, zero);\n-\n-    __ movdbl(dst, a);\n-    __ jmp(done);\n-  }\n-\n-  __ bind(zero);\n-  if (min)\n-    __ vpor(dst, a, b, Assembler::AVX_128bit);\n-  else\n-    __ vpand(dst, a, b, Assembler::AVX_128bit);\n-\n-  __ jmp(done);\n-\n-  __ bind(above);\n-  if (single)\n-    __ movflt(dst, min ? b : a);\n-  else\n-    __ movdbl(dst, min ? b : a);\n-\n-  __ jmp(done);\n-\n-  __ bind(nan);\n-  if (single) {\n-    __ movl(rt, 0x7fc00000); \/\/ Float.NaN\n-    __ movdl(dst, rt);\n-  }\n-  else {\n-    __ mov64(rt, 0x7ff8000000000000L); \/\/ Double.NaN\n-    __ movdq(dst, rt);\n-  }\n-  __ jmp(done);\n-\n-  __ bind(below);\n-  if (single)\n-    __ movflt(dst, min ? a : b);\n-  else\n-    __ movdbl(dst, min ? a : b);\n-\n-  __ bind(done);\n-}\n-\n-\/\/=============================================================================\n-const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::EMPTY;\n-\n-int ConstantTable::calculate_table_base_offset() const {\n-  return 0;  \/\/ absolute addressing, no offset\n-}\n-\n-bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }\n-void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {\n-  ShouldNotReachHere();\n-}\n-\n-void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n-  \/\/ Empty encoding\n-}\n-\n-uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {\n-  return 0;\n-}\n-\n-#ifndef PRODUCT\n-void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {\n-  st->print(\"# MachConstantBaseNode (empty encoding)\");\n-}\n-#endif\n-\n-\n-\/\/=============================================================================\n-#ifndef PRODUCT\n-void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {\n-  Compile* C = ra_->C;\n-\n-  int framesize = C->output()->frame_size_in_bytes();\n-  int bangsize = C->output()->bang_size_in_bytes();\n-  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n-  \/\/ Remove wordSize for return addr which is already pushed.\n-  framesize -= wordSize;\n-\n-  if (C->output()->need_stack_bang(bangsize)) {\n-    framesize -= wordSize;\n-    st->print(\"# stack bang (%d bytes)\", bangsize);\n-    st->print(\"\\n\\t\");\n-    st->print(\"pushq   rbp\\t# Save rbp\");\n-    if (PreserveFramePointer) {\n-        st->print(\"\\n\\t\");\n-        st->print(\"movq    rbp, rsp\\t# Save the caller's SP into rbp\");\n-    }\n-    if (framesize) {\n-      st->print(\"\\n\\t\");\n-      st->print(\"subq    rsp, #%d\\t# Create frame\",framesize);\n-    }\n-  } else {\n-    st->print(\"subq    rsp, #%d\\t# Create frame\",framesize);\n-    st->print(\"\\n\\t\");\n-    framesize -= wordSize;\n-    st->print(\"movq    [rsp + #%d], rbp\\t# Save rbp\",framesize);\n-    if (PreserveFramePointer) {\n-      st->print(\"\\n\\t\");\n-      st->print(\"movq    rbp, rsp\\t# Save the caller's SP into rbp\");\n-      if (framesize > 0) {\n-        st->print(\"\\n\\t\");\n-        st->print(\"addq    rbp, #%d\", framesize);\n-      }\n-    }\n-  }\n-\n-  if (VerifyStackAtCalls) {\n-    st->print(\"\\n\\t\");\n-    framesize -= wordSize;\n-    st->print(\"movq    [rsp + #%d], 0xbadb100d\\t# Majik cookie for stack depth check\",framesize);\n-#ifdef ASSERT\n-    st->print(\"\\n\\t\");\n-    st->print(\"# stack alignment check\");\n-#endif\n-  }\n-  if (C->stub_function() != nullptr) {\n-    st->print(\"\\n\\t\");\n-    st->print(\"cmpl    [r15_thread + #disarmed_guard_value_offset], #disarmed_guard_value\\t\");\n-    st->print(\"\\n\\t\");\n-    st->print(\"je      fast_entry\\t\");\n-    st->print(\"\\n\\t\");\n-    st->print(\"call    #nmethod_entry_barrier_stub\\t\");\n-    st->print(\"\\n\\tfast_entry:\");\n-  }\n-  st->cr();\n-}\n-#endif\n-\n-void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n-  Compile* C = ra_->C;\n-\n-  __ verified_entry(C);\n-\n-  if (ra_->C->stub_function() == nullptr) {\n-    __ entry_barrier();\n-  }\n-\n-  if (!Compile::current()->output()->in_scratch_emit_size()) {\n-    __ bind(*_verified_entry);\n-  }\n-\n-  C->output()->set_frame_complete(__ offset());\n-\n-  if (C->has_mach_constant_base_node()) {\n-    \/\/ NOTE: We set the table base offset here because users might be\n-    \/\/ emitted before MachConstantBaseNode.\n-    ConstantTable& constant_table = C->output()->constant_table();\n-    constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());\n-  }\n-}\n-\n-int MachPrologNode::reloc() const\n-{\n-  return 0; \/\/ a large enough number\n-}\n-\n-\/\/=============================================================================\n-#ifndef PRODUCT\n-void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n-{\n-  Compile* C = ra_->C;\n-  if (generate_vzeroupper(C)) {\n-    st->print(\"vzeroupper\");\n-    st->cr(); st->print(\"\\t\");\n-  }\n-\n-  int framesize = C->output()->frame_size_in_bytes();\n-  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n-  \/\/ Remove word for return adr already pushed\n-  \/\/ and RBP\n-  framesize -= 2*wordSize;\n-\n-  if (framesize) {\n-    st->print_cr(\"addq    rsp, %d\\t# Destroy frame\", framesize);\n-    st->print(\"\\t\");\n-  }\n-\n-  st->print_cr(\"popq    rbp\");\n-  if (do_polling() && C->is_method_compilation()) {\n-    st->print(\"\\t\");\n-    st->print_cr(\"cmpq    rsp, poll_offset[r15_thread] \\n\\t\"\n-                 \"ja      #safepoint_stub\\t\"\n-                 \"# Safepoint: poll for GC\");\n-  }\n-}\n-#endif\n-\n-void MachEpilogNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n-{\n-  Compile* C = ra_->C;\n-\n-  if (generate_vzeroupper(C)) {\n-    \/\/ Clear upper bits of YMM registers when current compiled code uses\n-    \/\/ wide vectors to avoid AVX <-> SSE transition penalty during call.\n-    __ vzeroupper();\n-  }\n-\n-  \/\/ Subtract two words to account for return address and rbp\n-  int initial_framesize = C->output()->frame_size_in_bytes() - 2*wordSize;\n-  __ remove_frame(initial_framesize, C->needs_stack_repair());\n-\n-  if (StackReservedPages > 0 && C->has_reserved_stack_access()) {\n-    __ reserved_stack_check();\n-  }\n-\n-  if (do_polling() && C->is_method_compilation()) {\n-    Label dummy_label;\n-    Label* code_stub = &dummy_label;\n-    if (!C->output()->in_scratch_emit_size()) {\n-      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n-      C->output()->add_stub(stub);\n-      code_stub = &stub->entry();\n-    }\n-    __ relocate(relocInfo::poll_return_type);\n-    __ safepoint_poll(*code_stub, true \/* at_return *\/, true \/* in_nmethod *\/);\n-  }\n-}\n-\n-int MachEpilogNode::reloc() const\n-{\n-  return 2; \/\/ a large enough number\n-}\n-\n-const Pipeline* MachEpilogNode::pipeline() const\n-{\n-  return MachNode::pipeline_class();\n-}\n-\n-\/\/=============================================================================\n-\n-enum RC {\n-  rc_bad,\n-  rc_int,\n-  rc_kreg,\n-  rc_float,\n-  rc_stack\n-};\n-\n-static enum RC rc_class(OptoReg::Name reg)\n-{\n-  if( !OptoReg::is_valid(reg)  ) return rc_bad;\n-\n-  if (OptoReg::is_stack(reg)) return rc_stack;\n-\n-  VMReg r = OptoReg::as_VMReg(reg);\n-\n-  if (r->is_Register()) return rc_int;\n-\n-  if (r->is_KRegister()) return rc_kreg;\n-\n-  assert(r->is_XMMRegister(), \"must be\");\n-  return rc_float;\n-}\n-\n-\/\/ Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.\n-static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n-                          int src_hi, int dst_hi, uint ireg, outputStream* st);\n-\n-void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n-                     int stack_offset, int reg, uint ireg, outputStream* st);\n-\n-static void vec_stack_to_stack_helper(C2_MacroAssembler *masm, int src_offset,\n-                                      int dst_offset, uint ireg, outputStream* st) {\n-  if (masm) {\n-    switch (ireg) {\n-    case Op_VecS:\n-      __ movq(Address(rsp, -8), rax);\n-      __ movl(rax, Address(rsp, src_offset));\n-      __ movl(Address(rsp, dst_offset), rax);\n-      __ movq(rax, Address(rsp, -8));\n-      break;\n-    case Op_VecD:\n-      __ pushq(Address(rsp, src_offset));\n-      __ popq (Address(rsp, dst_offset));\n-      break;\n-    case Op_VecX:\n-      __ pushq(Address(rsp, src_offset));\n-      __ popq (Address(rsp, dst_offset));\n-      __ pushq(Address(rsp, src_offset+8));\n-      __ popq (Address(rsp, dst_offset+8));\n-      break;\n-    case Op_VecY:\n-      __ vmovdqu(Address(rsp, -32), xmm0);\n-      __ vmovdqu(xmm0, Address(rsp, src_offset));\n-      __ vmovdqu(Address(rsp, dst_offset), xmm0);\n-      __ vmovdqu(xmm0, Address(rsp, -32));\n-      break;\n-    case Op_VecZ:\n-      __ evmovdquq(Address(rsp, -64), xmm0, 2);\n-      __ evmovdquq(xmm0, Address(rsp, src_offset), 2);\n-      __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);\n-      __ evmovdquq(xmm0, Address(rsp, -64), 2);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-    }\n-#ifndef PRODUCT\n-  } else {\n-    switch (ireg) {\n-    case Op_VecS:\n-      st->print(\"movq    [rsp - #8], rax\\t# 32-bit mem-mem spill\\n\\t\"\n-                \"movl    rax, [rsp + #%d]\\n\\t\"\n-                \"movl    [rsp + #%d], rax\\n\\t\"\n-                \"movq    rax, [rsp - #8]\",\n-                src_offset, dst_offset);\n-      break;\n-    case Op_VecD:\n-      st->print(\"pushq   [rsp + #%d]\\t# 64-bit mem-mem spill\\n\\t\"\n-                \"popq    [rsp + #%d]\",\n-                src_offset, dst_offset);\n-      break;\n-     case Op_VecX:\n-      st->print(\"pushq   [rsp + #%d]\\t# 128-bit mem-mem spill\\n\\t\"\n-                \"popq    [rsp + #%d]\\n\\t\"\n-                \"pushq   [rsp + #%d]\\n\\t\"\n-                \"popq    [rsp + #%d]\",\n-                src_offset, dst_offset, src_offset+8, dst_offset+8);\n-      break;\n-    case Op_VecY:\n-      st->print(\"vmovdqu [rsp - #32], xmm0\\t# 256-bit mem-mem spill\\n\\t\"\n-                \"vmovdqu xmm0, [rsp + #%d]\\n\\t\"\n-                \"vmovdqu [rsp + #%d], xmm0\\n\\t\"\n-                \"vmovdqu xmm0, [rsp - #32]\",\n-                src_offset, dst_offset);\n-      break;\n-    case Op_VecZ:\n-      st->print(\"vmovdqu [rsp - #64], xmm0\\t# 512-bit mem-mem spill\\n\\t\"\n-                \"vmovdqu xmm0, [rsp + #%d]\\n\\t\"\n-                \"vmovdqu [rsp + #%d], xmm0\\n\\t\"\n-                \"vmovdqu xmm0, [rsp - #64]\",\n-                src_offset, dst_offset);\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-    }\n-#endif\n-  }\n-}\n-\n-uint MachSpillCopyNode::implementation(C2_MacroAssembler* masm,\n-                                       PhaseRegAlloc* ra_,\n-                                       bool do_size,\n-                                       outputStream* st) const {\n-  assert(masm != nullptr || st  != nullptr, \"sanity\");\n-  \/\/ Get registers to move\n-  OptoReg::Name src_second = ra_->get_reg_second(in(1));\n-  OptoReg::Name src_first = ra_->get_reg_first(in(1));\n-  OptoReg::Name dst_second = ra_->get_reg_second(this);\n-  OptoReg::Name dst_first = ra_->get_reg_first(this);\n-\n-  enum RC src_second_rc = rc_class(src_second);\n-  enum RC src_first_rc = rc_class(src_first);\n-  enum RC dst_second_rc = rc_class(dst_second);\n-  enum RC dst_first_rc = rc_class(dst_first);\n-\n-  assert(OptoReg::is_valid(src_first) && OptoReg::is_valid(dst_first),\n-         \"must move at least 1 register\" );\n-\n-  if (src_first == dst_first && src_second == dst_second) {\n-    \/\/ Self copy, no move\n-    return 0;\n-  }\n-  if (bottom_type()->isa_vect() != nullptr && bottom_type()->isa_vectmask() == nullptr) {\n-    uint ireg = ideal_reg();\n-    assert((src_first_rc != rc_int && dst_first_rc != rc_int), \"sanity\");\n-    assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), \"sanity\");\n-    if( src_first_rc == rc_stack && dst_first_rc == rc_stack ) {\n-      \/\/ mem -> mem\n-      int src_offset = ra_->reg2offset(src_first);\n-      int dst_offset = ra_->reg2offset(dst_first);\n-      vec_stack_to_stack_helper(masm, src_offset, dst_offset, ireg, st);\n-    } else if (src_first_rc == rc_float && dst_first_rc == rc_float ) {\n-      vec_mov_helper(masm, src_first, dst_first, src_second, dst_second, ireg, st);\n-    } else if (src_first_rc == rc_float && dst_first_rc == rc_stack ) {\n-      int stack_offset = ra_->reg2offset(dst_first);\n-      vec_spill_helper(masm, false, stack_offset, src_first, ireg, st);\n-    } else if (src_first_rc == rc_stack && dst_first_rc == rc_float ) {\n-      int stack_offset = ra_->reg2offset(src_first);\n-      vec_spill_helper(masm, true,  stack_offset, dst_first, ireg, st);\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-    return 0;\n-  }\n-  if (src_first_rc == rc_stack) {\n-    \/\/ mem ->\n-    if (dst_first_rc == rc_stack) {\n-      \/\/ mem -> mem\n-      assert(src_second != dst_first, \"overlap\");\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        int src_offset = ra_->reg2offset(src_first);\n-        int dst_offset = ra_->reg2offset(dst_first);\n-        if (masm) {\n-          __ pushq(Address(rsp, src_offset));\n-          __ popq (Address(rsp, dst_offset));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"pushq   [rsp + #%d]\\t# 64-bit mem-mem spill\\n\\t\"\n-                    \"popq    [rsp + #%d]\",\n-                     src_offset, dst_offset);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        \/\/ No pushl\/popl, so:\n-        int src_offset = ra_->reg2offset(src_first);\n-        int dst_offset = ra_->reg2offset(dst_first);\n-        if (masm) {\n-          __ movq(Address(rsp, -8), rax);\n-          __ movl(rax, Address(rsp, src_offset));\n-          __ movl(Address(rsp, dst_offset), rax);\n-          __ movq(rax, Address(rsp, -8));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movq    [rsp - #8], rax\\t# 32-bit mem-mem spill\\n\\t\"\n-                    \"movl    rax, [rsp + #%d]\\n\\t\"\n-                    \"movl    [rsp + #%d], rax\\n\\t\"\n-                    \"movq    rax, [rsp - #8]\",\n-                     src_offset, dst_offset);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_int) {\n-      \/\/ mem -> gpr\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        int offset = ra_->reg2offset(src_first);\n-        if (masm) {\n-          __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movq    %s, [rsp + #%d]\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     offset);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        int offset = ra_->reg2offset(src_first);\n-        if (masm) {\n-          __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movl    %s, [rsp + #%d]\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     offset);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_float) {\n-      \/\/ mem-> xmm\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        int offset = ra_->reg2offset(src_first);\n-        if (masm) {\n-          __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"%s  %s, [rsp + #%d]\\t# spill\",\n-                     UseXmmLoadAndClearUpper ? \"movsd \" : \"movlpd\",\n-                     Matcher::regName[dst_first],\n-                     offset);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        int offset = ra_->reg2offset(src_first);\n-        if (masm) {\n-          __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movss   %s, [rsp + #%d]\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     offset);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_kreg) {\n-      \/\/ mem -> kreg\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        int offset = ra_->reg2offset(src_first);\n-        if (masm) {\n-          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"kmovq   %s, [rsp + #%d]\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     offset);\n-#endif\n-        }\n-      }\n-      return 0;\n-    }\n-  } else if (src_first_rc == rc_int) {\n-    \/\/ gpr ->\n-    if (dst_first_rc == rc_stack) {\n-      \/\/ gpr -> mem\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        int offset = ra_->reg2offset(dst_first);\n-        if (masm) {\n-          __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movq    [rsp + #%d], %s\\t# spill\",\n-                     offset,\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        int offset = ra_->reg2offset(dst_first);\n-        if (masm) {\n-          __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movl    [rsp + #%d], %s\\t# spill\",\n-                     offset,\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_int) {\n-      \/\/ gpr -> gpr\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        if (masm) {\n-          __ movq(as_Register(Matcher::_regEncode[dst_first]),\n-                  as_Register(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movq    %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-        return 0;\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        if (masm) {\n-          __ movl(as_Register(Matcher::_regEncode[dst_first]),\n-                  as_Register(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movl    %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-        return 0;\n-      }\n-    } else if (dst_first_rc == rc_float) {\n-      \/\/ gpr -> xmm\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        if (masm) {\n-          __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movdq   %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        if (masm) {\n-          __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movdl   %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_kreg) {\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        if (masm) {\n-          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));\n-  #ifndef PRODUCT\n-        } else {\n-           st->print(\"kmovq   %s, %s\\t# spill\",\n-                       Matcher::regName[dst_first],\n-                       Matcher::regName[src_first]);\n-  #endif\n-        }\n-      }\n-      Unimplemented();\n-      return 0;\n-    }\n-  } else if (src_first_rc == rc_float) {\n-    \/\/ xmm ->\n-    if (dst_first_rc == rc_stack) {\n-      \/\/ xmm -> mem\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        int offset = ra_->reg2offset(dst_first);\n-        if (masm) {\n-          __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movsd   [rsp + #%d], %s\\t# spill\",\n-                     offset,\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        int offset = ra_->reg2offset(dst_first);\n-        if (masm) {\n-          __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movss   [rsp + #%d], %s\\t# spill\",\n-                     offset,\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_int) {\n-      \/\/ xmm -> gpr\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        if (masm) {\n-          __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movdq   %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        if (masm) {\n-          __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"movdl   %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_float) {\n-      \/\/ xmm -> xmm\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        if (masm) {\n-          __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"%s  %s, %s\\t# spill\",\n-                     UseXmmRegToRegMoveAll ? \"movapd\" : \"movsd \",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      } else {\n-        \/\/ 32-bit\n-        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), \"no transform\");\n-        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), \"no transform\");\n-        if (masm) {\n-          __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"%s  %s, %s\\t# spill\",\n-                     UseXmmRegToRegMoveAll ? \"movaps\" : \"movss \",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_kreg) {\n-      assert(false, \"Illegal spilling\");\n-      return 0;\n-    }\n-  } else if (src_first_rc == rc_kreg) {\n-    if (dst_first_rc == rc_stack) {\n-      \/\/ mem -> kreg\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        int offset = ra_->reg2offset(dst_first);\n-        if (masm) {\n-          __ kmov(Address(rsp, offset), as_KRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-          st->print(\"kmovq   [rsp + #%d] , %s\\t# spill\",\n-                     offset,\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_int) {\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        if (masm) {\n-          __ kmov(as_Register(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-         st->print(\"kmovq   %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      Unimplemented();\n-      return 0;\n-    } else if (dst_first_rc == rc_kreg) {\n-      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n-          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n-        \/\/ 64-bit\n-        if (masm) {\n-          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n-#ifndef PRODUCT\n-        } else {\n-         st->print(\"kmovq   %s, %s\\t# spill\",\n-                     Matcher::regName[dst_first],\n-                     Matcher::regName[src_first]);\n-#endif\n-        }\n-      }\n-      return 0;\n-    } else if (dst_first_rc == rc_float) {\n-      assert(false, \"Illegal spill\");\n-      return 0;\n-    }\n-  }\n-\n-  assert(0,\" foo \");\n-  Unimplemented();\n-  return 0;\n-}\n-\n-#ifndef PRODUCT\n-void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {\n-  implementation(nullptr, ra_, false, st);\n-}\n-#endif\n-\n-void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n-  implementation(masm, ra_, false, nullptr);\n-}\n-\n-uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {\n-  return MachNode::size(ra_);\n-}\n-\n-\/\/=============================================================================\n-#ifndef PRODUCT\n-void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n-{\n-  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());\n-  int reg = ra_->get_reg_first(this);\n-  st->print(\"leaq    %s, [rsp + #%d]\\t# box lock\",\n-            Matcher::regName[reg], offset);\n-}\n-#endif\n-\n-void BoxLockNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n-{\n-  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());\n-  int reg = ra_->get_encode(this);\n-\n-  __ lea(as_Register(reg), Address(rsp, offset));\n-}\n-\n-uint BoxLockNode::size(PhaseRegAlloc *ra_) const\n-{\n-  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());\n-  if (ra_->get_encode(this) > 15) {\n-    return (offset < 0x80) ? 6 : 9; \/\/ REX2\n-  } else {\n-    return (offset < 0x80) ? 5 : 8; \/\/ REX\n-  }\n-}\n-\n-\/\/=============================================================================\n-#ifndef PRODUCT\n-void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n-{\n-  st->print_cr(\"MachVEPNode\");\n-}\n-#endif\n-\n-void MachVEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n-{\n-  CodeBuffer* cbuf = masm->code();\n-  uint insts_size = cbuf->insts_size();\n-  if (!_verified) {\n-    __ ic_check(1);\n-  } else {\n-    \/\/ TODO 8284443 Avoid creation of temporary frame\n-    if (ra_->C->stub_function() == nullptr) {\n-      __ verified_entry(ra_->C, 0);\n-      __ entry_barrier();\n-      int initial_framesize = ra_->C->output()->frame_size_in_bytes() - 2*wordSize;\n-      __ remove_frame(initial_framesize, false);\n-    }\n-    \/\/ Unpack inline type args passed as oop and then jump to\n-    \/\/ the verified entry point (skipping the unverified entry).\n-    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n-    \/\/ Emit code for verified entry and save increment for stack repair on return\n-    __ verified_entry(ra_->C, sp_inc);\n-    if (Compile::current()->output()->in_scratch_emit_size()) {\n-      Label dummy_verified_entry;\n-      __ jmp(dummy_verified_entry);\n-    } else {\n-      __ jmp(*_verified_entry);\n-    }\n-  }\n-  \/* WARNING these NOPs are critical so that verified entry point is properly\n-     4 bytes aligned for patching by NativeJump::patch_verified_entry() *\/\n-  int nops_cnt = 4 - ((cbuf->insts_size() - insts_size) & 0x3);\n-  nops_cnt &= 0x3; \/\/ Do not add nops if code is aligned.\n-  if (nops_cnt > 0) {\n-    __ nop(nops_cnt);\n-  }\n-}\n-\n-\/\/=============================================================================\n-#ifndef PRODUCT\n-void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n-{\n-  if (UseCompressedClassPointers) {\n-    st->print_cr(\"movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n-    st->print_cr(\"\\tcmpl    rscratch1, [rax + CompiledICData::speculated_klass_offset()]\\t # Inline cache check\");\n-  } else {\n-    st->print_cr(\"movq    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n-    st->print_cr(\"\\tcmpq    rscratch1, [rax + CompiledICData::speculated_klass_offset()]\\t # Inline cache check\");\n-  }\n-  st->print_cr(\"\\tjne     SharedRuntime::_ic_miss_stub\");\n-}\n-#endif\n-\n-void MachUEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n-{\n-  __ ic_check(InteriorEntryAlignment);\n-}\n-\n-\/\/=============================================================================\n-\n-bool Matcher::supports_vector_calling_convention(void) {\n-  return EnableVectorSupport;\n-}\n-\n-OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n-  assert(EnableVectorSupport, \"sanity\");\n-  int lo = XMM0_num;\n-  int hi = XMM0b_num;\n-  if (ideal_reg == Op_VecX) hi = XMM0d_num;\n-  else if (ideal_reg == Op_VecY) hi = XMM0h_num;\n-  else if (ideal_reg == Op_VecZ) hi = XMM0p_num;\n-  return OptoRegPair(hi, lo);\n-}\n-\n-\/\/ Is this branch offset short enough that a short branch can be used?\n-\/\/\n-\/\/ NOTE: If the platform does not provide any short branch variants, then\n-\/\/       this method should return false for offset 0.\n-bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {\n-  \/\/ The passed offset is relative to address of the branch.\n-  \/\/ On 86 a branch displacement is calculated relative to address\n-  \/\/ of a next instruction.\n-  offset -= br_size;\n-\n-  \/\/ the short version of jmpConUCF2 contains multiple branches,\n-  \/\/ making the reach slightly less\n-  if (rule == jmpConUCF2_rule)\n-    return (-126 <= offset && offset <= 125);\n-  return (-128 <= offset && offset <= 127);\n-}\n-\n-\/\/ Return whether or not this register is ever used as an argument.\n-\/\/ This function is used on startup to build the trampoline stubs in\n-\/\/ generateOptoStub.  Registers not mentioned will be killed by the VM\n-\/\/ call in the trampoline, and arguments in those registers not be\n-\/\/ available to the callee.\n-bool Matcher::can_be_java_arg(int reg)\n-{\n-  return\n-    reg ==  RDI_num || reg == RDI_H_num ||\n-    reg ==  RSI_num || reg == RSI_H_num ||\n-    reg ==  RDX_num || reg == RDX_H_num ||\n-    reg ==  RCX_num || reg == RCX_H_num ||\n-    reg ==   R8_num || reg ==  R8_H_num ||\n-    reg ==   R9_num || reg ==  R9_H_num ||\n-    reg ==  R12_num || reg == R12_H_num ||\n-    reg == XMM0_num || reg == XMM0b_num ||\n-    reg == XMM1_num || reg == XMM1b_num ||\n-    reg == XMM2_num || reg == XMM2b_num ||\n-    reg == XMM3_num || reg == XMM3b_num ||\n-    reg == XMM4_num || reg == XMM4b_num ||\n-    reg == XMM5_num || reg == XMM5b_num ||\n-    reg == XMM6_num || reg == XMM6b_num ||\n-    reg == XMM7_num || reg == XMM7b_num;\n-}\n-\n-bool Matcher::is_spillable_arg(int reg)\n-{\n-  return can_be_java_arg(reg);\n-}\n-\n-uint Matcher::int_pressure_limit()\n-{\n-  return (INTPRESSURE == -1) ? _INT_REG_mask.size() : INTPRESSURE;\n-}\n-\n-uint Matcher::float_pressure_limit()\n-{\n-  \/\/ After experiment around with different values, the following default threshold\n-  \/\/ works best for LCM's register pressure scheduling on x64.\n-  uint dec_count  = VM_Version::supports_evex() ? 4 : 2;\n-  uint default_float_pressure_threshold = _FLOAT_REG_mask.size() - dec_count;\n-  return (FLOATPRESSURE == -1) ? default_float_pressure_threshold : FLOATPRESSURE;\n-}\n-\n-bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {\n-  \/\/ In 64 bit mode a code which use multiply when\n-  \/\/ devisor is constant is faster than hardware\n-  \/\/ DIV instruction (it uses MulHiL).\n-  return false;\n-}\n-\n-\/\/ Register for DIVI projection of divmodI\n-const RegMask& Matcher::divI_proj_mask() {\n-  return INT_RAX_REG_mask();\n-}\n-\n-\/\/ Register for MODI projection of divmodI\n-const RegMask& Matcher::modI_proj_mask() {\n-  return INT_RDX_REG_mask();\n-}\n-\n-\/\/ Register for DIVL projection of divmodL\n-const RegMask& Matcher::divL_proj_mask() {\n-  return LONG_RAX_REG_mask();\n-}\n-\n-\/\/ Register for MODL projection of divmodL\n-const RegMask& Matcher::modL_proj_mask() {\n-  return LONG_RDX_REG_mask();\n-}\n-\n-%}\n-\n-\/\/----------ENCODING BLOCK-----------------------------------------------------\n-\/\/ This block specifies the encoding classes used by the compiler to\n-\/\/ output byte streams.  Encoding classes are parameterized macros\n-\/\/ used by Machine Instruction Nodes in order to generate the bit\n-\/\/ encoding of the instruction.  Operands specify their base encoding\n-\/\/ interface with the interface keyword.  There are currently\n-\/\/ supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &\n-\/\/ COND_INTER.  REG_INTER causes an operand to generate a function\n-\/\/ which returns its register number when queried.  CONST_INTER causes\n-\/\/ an operand to generate a function which returns the value of the\n-\/\/ constant when queried.  MEMORY_INTER causes an operand to generate\n-\/\/ four functions which return the Base Register, the Index Register,\n-\/\/ the Scale Value, and the Offset Value of the operand when queried.\n-\/\/ COND_INTER causes an operand to generate six functions which return\n-\/\/ the encoding code (ie - encoding bits for the instruction)\n-\/\/ associated with each basic boolean condition for a conditional\n-\/\/ instruction.\n-\/\/\n-\/\/ Instructions specify two basic values for encoding.  Again, a\n-\/\/ function is available to check if the constant displacement is an\n-\/\/ oop. They use the ins_encode keyword to specify their encoding\n-\/\/ classes (which must be a sequence of enc_class names, and their\n-\/\/ parameters, specified in the encoding block), and they use the\n-\/\/ opcode keyword to specify, in order, their primary, secondary, and\n-\/\/ tertiary opcode.  Only the opcode sections which a particular\n-\/\/ instruction needs for encoding need to be specified.\n-encode %{\n-  enc_class cdql_enc(no_rax_rdx_RegI div)\n-  %{\n-    \/\/ Full implementation of Java idiv and irem; checks for\n-    \/\/ special case as described in JVM spec., p.243 & p.271.\n-    \/\/\n-    \/\/         normal case                           special case\n-    \/\/\n-    \/\/ input : rax: dividend                         min_int\n-    \/\/         reg: divisor                          -1\n-    \/\/\n-    \/\/ output: rax: quotient  (= rax idiv reg)       min_int\n-    \/\/         rdx: remainder (= rax irem reg)       0\n-    \/\/\n-    \/\/  Code sequnce:\n-    \/\/\n-    \/\/    0:   3d 00 00 00 80          cmp    $0x80000000,%eax\n-    \/\/    5:   75 07\/08                jne    e <normal>\n-    \/\/    7:   33 d2                   xor    %edx,%edx\n-    \/\/  [div >= 8 -> offset + 1]\n-    \/\/  [REX_B]\n-    \/\/    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div\n-    \/\/    c:   74 03\/04                je     11 <done>\n-    \/\/ 000000000000000e <normal>:\n-    \/\/    e:   99                      cltd\n-    \/\/  [div >= 8 -> offset + 1]\n-    \/\/  [REX_B]\n-    \/\/    f:   f7 f9                   idiv   $div\n-    \/\/ 0000000000000011 <done>:\n-    Label normal;\n-    Label done;\n-\n-    \/\/ cmp    $0x80000000,%eax\n-    __ cmpl(as_Register(RAX_enc), 0x80000000);\n-\n-    \/\/ jne    e <normal>\n-    __ jccb(Assembler::notEqual, normal);\n-\n-    \/\/ xor    %edx,%edx\n-    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n-\n-    \/\/ cmp    $0xffffffffffffffff,%ecx\n-    __ cmpl($div$$Register, -1);\n-\n-    \/\/ je     11 <done>\n-    __ jccb(Assembler::equal, done);\n-\n-    \/\/ <normal>\n-    \/\/ cltd\n-    __ bind(normal);\n-    __ cdql();\n-\n-    \/\/ idivl\n-    \/\/ <done>\n-    __ idivl($div$$Register);\n-    __ bind(done);\n-  %}\n-\n-  enc_class cdqq_enc(no_rax_rdx_RegL div)\n-  %{\n-    \/\/ Full implementation of Java ldiv and lrem; checks for\n-    \/\/ special case as described in JVM spec., p.243 & p.271.\n-    \/\/\n-    \/\/         normal case                           special case\n-    \/\/\n-    \/\/ input : rax: dividend                         min_long\n-    \/\/         reg: divisor                          -1\n-    \/\/\n-    \/\/ output: rax: quotient  (= rax idiv reg)       min_long\n-    \/\/         rdx: remainder (= rax irem reg)       0\n-    \/\/\n-    \/\/  Code sequnce:\n-    \/\/\n-    \/\/    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx\n-    \/\/    7:   00 00 80\n-    \/\/    a:   48 39 d0                cmp    %rdx,%rax\n-    \/\/    d:   75 08                   jne    17 <normal>\n-    \/\/    f:   33 d2                   xor    %edx,%edx\n-    \/\/   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div\n-    \/\/   15:   74 05                   je     1c <done>\n-    \/\/ 0000000000000017 <normal>:\n-    \/\/   17:   48 99                   cqto\n-    \/\/   19:   48 f7 f9                idiv   $div\n-    \/\/ 000000000000001c <done>:\n-    Label normal;\n-    Label done;\n-\n-    \/\/ mov    $0x8000000000000000,%rdx\n-    __ mov64(as_Register(RDX_enc), 0x8000000000000000);\n-\n-    \/\/ cmp    %rdx,%rax\n-    __ cmpq(as_Register(RAX_enc), as_Register(RDX_enc));\n-\n-    \/\/ jne    17 <normal>\n-    __ jccb(Assembler::notEqual, normal);\n-\n-    \/\/ xor    %edx,%edx\n-    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n-\n-    \/\/ cmp    $0xffffffffffffffff,$div\n-    __ cmpq($div$$Register, -1);\n-\n-    \/\/ je     1e <done>\n-    __ jccb(Assembler::equal, done);\n-\n-    \/\/ <normal>\n-    \/\/ cqto\n-    __ bind(normal);\n-    __ cdqq();\n-\n-    \/\/ idivq (note: must be emitted by the user of this rule)\n-    \/\/ <done>\n-    __ idivq($div$$Register);\n-    __ bind(done);\n-  %}\n-\n-  enc_class clear_avx %{\n-    DEBUG_ONLY(int off0 = __ offset());\n-    if (generate_vzeroupper(Compile::current())) {\n-      \/\/ Clear upper bits of YMM registers to avoid AVX <-> SSE transition penalty\n-      \/\/ Clear upper bits of YMM registers when current compiled code uses\n-      \/\/ wide vectors to avoid AVX <-> SSE transition penalty during call.\n-      __ vzeroupper();\n-    }\n-    DEBUG_ONLY(int off1 = __ offset());\n-    assert(off1 - off0 == clear_avx_size(), \"correct size prediction\");\n-  %}\n-\n-  enc_class Java_To_Runtime(method meth) %{\n-    __ lea(r10, RuntimeAddress((address)$meth$$method));\n-    __ call(r10);\n-    __ post_call_nop();\n-  %}\n-\n-  enc_class Java_Static_Call(method meth)\n-  %{\n-    \/\/ JAVA STATIC CALL\n-    \/\/ CALL to fixup routine.  Fixup routine uses ScopeDesc info to\n-    \/\/ determine who we intended to call.\n-    if (!_method) {\n-      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, $meth$$method)));\n-    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n-      \/\/ The NOP here is purely to ensure that eliding a call to\n-      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n-      __ addr_nop_5();\n-      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n-    } else {\n-      int method_index = resolved_method_index(masm);\n-      RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)\n-                                                  : static_call_Relocation::spec(method_index);\n-      address mark = __ pc();\n-      int call_offset = __ offset();\n-      __ call(AddressLiteral(CAST_FROM_FN_PTR(address, $meth$$method), rspec));\n-      if (CodeBuffer::supports_shared_stubs() && _method->can_be_statically_bound()) {\n-        \/\/ Calls of the same statically bound method can share\n-        \/\/ a stub to the interpreter.\n-        __ code()->shared_stub_to_interp_for(_method, call_offset);\n-      } else {\n-        \/\/ Emit stubs for static call.\n-        address stub = CompiledDirectCall::emit_to_interp_stub(masm, mark);\n-        __ clear_inst_mark();\n-        if (stub == nullptr) {\n-          ciEnv::current()->record_failure(\"CodeCache is full\");\n-          return;\n-        }\n-      }\n-    }\n-    __ post_call_nop();\n-  %}\n-\n-  enc_class Java_Dynamic_Call(method meth) %{\n-    __ ic_call((address)$meth$$method, resolved_method_index(masm));\n-    __ post_call_nop();\n-  %}\n-\n-%}\n-\n-\n-\n-\/\/----------FRAME--------------------------------------------------------------\n-\/\/ Definition of frame structure and management information.\n-\/\/\n-\/\/  S T A C K   L A Y O U T    Allocators stack-slot number\n-\/\/                             |   (to get allocators register number\n-\/\/  G  Owned by    |        |  v    add OptoReg::stack0())\n-\/\/  r   CALLER     |        |\n-\/\/  o     |        +--------+      pad to even-align allocators stack-slot\n-\/\/  w     V        |  pad0  |        numbers; owned by CALLER\n-\/\/  t   -----------+--------+----> Matcher::_in_arg_limit, unaligned\n-\/\/  h     ^        |   in   |  5\n-\/\/        |        |  args  |  4   Holes in incoming args owned by SELF\n-\/\/  |     |        |        |  3\n-\/\/  |     |        +--------+\n-\/\/  V     |        | old out|      Empty on Intel, window on Sparc\n-\/\/        |    old |preserve|      Must be even aligned.\n-\/\/        |     SP-+--------+----> Matcher::_old_SP, even aligned\n-\/\/        |        |   in   |  3   area for Intel ret address\n-\/\/     Owned by    |preserve|      Empty on Sparc.\n-\/\/       SELF      +--------+\n-\/\/        |        |  pad2  |  2   pad to align old SP\n-\/\/        |        +--------+  1\n-\/\/        |        | locks  |  0\n-\/\/        |        +--------+----> OptoReg::stack0(), even aligned\n-\/\/        |        |  pad1  | 11   pad to align new SP\n-\/\/        |        +--------+\n-\/\/        |        |        | 10\n-\/\/        |        | spills |  9   spills\n-\/\/        V        |        |  8   (pad0 slot for callee)\n-\/\/      -----------+--------+----> Matcher::_out_arg_limit, unaligned\n-\/\/        ^        |  out   |  7\n-\/\/        |        |  args  |  6   Holes in outgoing args owned by CALLEE\n-\/\/     Owned by    +--------+\n-\/\/      CALLEE     | new out|  6   Empty on Intel, window on Sparc\n-\/\/        |    new |preserve|      Must be even-aligned.\n-\/\/        |     SP-+--------+----> Matcher::_new_SP, even aligned\n-\/\/        |        |        |\n-\/\/\n-\/\/ Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is\n-\/\/         known from SELF's arguments and the Java calling convention.\n-\/\/         Region 6-7 is determined per call site.\n-\/\/ Note 2: If the calling convention leaves holes in the incoming argument\n-\/\/         area, those holes are owned by SELF.  Holes in the outgoing area\n-\/\/         are owned by the CALLEE.  Holes should not be necessary in the\n-\/\/         incoming area, as the Java calling convention is completely under\n-\/\/         the control of the AD file.  Doubles can be sorted and packed to\n-\/\/         avoid holes.  Holes in the outgoing arguments may be necessary for\n-\/\/         varargs C calling conventions.\n-\/\/ Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is\n-\/\/         even aligned with pad0 as needed.\n-\/\/         Region 6 is even aligned.  Region 6-7 is NOT even aligned;\n-\/\/         region 6-11 is even aligned; it may be padded out more so that\n-\/\/         the region from SP to FP meets the minimum stack alignment.\n-\/\/ Note 4: For I2C adapters, the incoming FP may not meet the minimum stack\n-\/\/         alignment.  Region 11, pad1, may be dynamically extended so that\n-\/\/         SP meets the minimum alignment.\n-\n-frame\n-%{\n-  \/\/ These three registers define part of the calling convention\n-  \/\/ between compiled code and the interpreter.\n-  inline_cache_reg(RAX);                \/\/ Inline Cache Register\n-\n-  \/\/ Optional: name the operand used by cisc-spilling to access\n-  \/\/ [stack_pointer + offset]\n-  cisc_spilling_operand_name(indOffset32);\n-\n-  \/\/ Number of stack slots consumed by locking an object\n-  sync_stack_slots(2);\n-\n-  \/\/ Compiled code's Frame Pointer\n-  frame_pointer(RSP);\n-\n-  \/\/ Interpreter stores its frame pointer in a register which is\n-  \/\/ stored to the stack by I2CAdaptors.\n-  \/\/ I2CAdaptors convert from interpreted java to compiled java.\n-  interpreter_frame_pointer(RBP);\n-\n-  \/\/ Stack alignment requirement\n-  stack_alignment(StackAlignmentInBytes); \/\/ Alignment size in bytes (128-bit -> 16 bytes)\n-\n-  \/\/ Number of outgoing stack slots killed above the out_preserve_stack_slots\n-  \/\/ for calls to C.  Supports the var-args backing area for register parms.\n-  varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes\/BytesPerInt);\n-\n-  \/\/ The after-PROLOG location of the return address.  Location of\n-  \/\/ return address specifies a type (REG or STACK) and a number\n-  \/\/ representing the register number (i.e. - use a register name) or\n-  \/\/ stack slot.\n-  \/\/ Ret Addr is on stack in slot 0 if no locks or verification or alignment.\n-  \/\/ Otherwise, it is above the locks and verification slot and alignment word\n-  return_addr(STACK - 2 +\n-              align_up((Compile::current()->in_preserve_stack_slots() +\n-                        Compile::current()->fixed_slots()),\n-                       stack_alignment_in_slots()));\n-\n-  \/\/ Location of compiled Java return values.  Same as C for now.\n-  return_value\n-  %{\n-    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,\n-           \"only return normal values\");\n-\n-    static const int lo[Op_RegL + 1] = {\n-      0,\n-      0,\n-      RAX_num,  \/\/ Op_RegN\n-      RAX_num,  \/\/ Op_RegI\n-      RAX_num,  \/\/ Op_RegP\n-      XMM0_num, \/\/ Op_RegF\n-      XMM0_num, \/\/ Op_RegD\n-      RAX_num   \/\/ Op_RegL\n-    };\n-    static const int hi[Op_RegL + 1] = {\n-      0,\n-      0,\n-      OptoReg::Bad, \/\/ Op_RegN\n-      OptoReg::Bad, \/\/ Op_RegI\n-      RAX_H_num,    \/\/ Op_RegP\n-      OptoReg::Bad, \/\/ Op_RegF\n-      XMM0b_num,    \/\/ Op_RegD\n-      RAX_H_num     \/\/ Op_RegL\n-    };\n-    \/\/ Excluded flags and vector registers.\n-    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 8, \"missing type\");\n-    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);\n-  %}\n-%}\n-\n-\/\/----------ATTRIBUTES---------------------------------------------------------\n-\/\/----------Operand Attributes-------------------------------------------------\n-op_attrib op_cost(0);        \/\/ Required cost attribute\n-\n-\/\/----------Instruction Attributes---------------------------------------------\n-ins_attrib ins_cost(100);       \/\/ Required cost attribute\n-ins_attrib ins_size(8);         \/\/ Required size attribute (in bits)\n-ins_attrib ins_short_branch(0); \/\/ Required flag: is this instruction\n-                                \/\/ a non-matching short branch variant\n-                                \/\/ of some long branch?\n-ins_attrib ins_alignment(1);    \/\/ Required alignment attribute (must\n-                                \/\/ be a power of 2) specifies the\n-                                \/\/ alignment that some part of the\n-                                \/\/ instruction (not necessarily the\n-                                \/\/ start) requires.  If > 1, a\n-                                \/\/ compute_padding() function must be\n-                                \/\/ provided for the instruction\n-\n-\/\/ Whether this node is expanded during code emission into a sequence of\n-\/\/ instructions and the first instruction can perform an implicit null check.\n-ins_attrib ins_is_late_expanded_null_check_candidate(false);\n-\n-\/\/----------OPERANDS-----------------------------------------------------------\n-\/\/ Operand definitions must precede instruction definitions for correct parsing\n-\/\/ in the ADLC because operands constitute user defined types which are used in\n-\/\/ instruction definitions.\n-\n-\/\/----------Simple Operands----------------------------------------------------\n-\/\/ Immediate Operands\n-\/\/ Integer Immediate\n-operand immI()\n-%{\n-  match(ConI);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for test vs zero\n-operand immI_0()\n-%{\n-  predicate(n->get_int() == 0);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for increment\n-operand immI_1()\n-%{\n-  predicate(n->get_int() == 1);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for decrement\n-operand immI_M1()\n-%{\n-  predicate(n->get_int() == -1);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_2()\n-%{\n-  predicate(n->get_int() == 2);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_4()\n-%{\n-  predicate(n->get_int() == 4);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_8()\n-%{\n-  predicate(n->get_int() == 8);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Valid scale values for addressing modes\n-operand immI2()\n-%{\n-  predicate(0 <= n->get_int() && (n->get_int() <= 3));\n-  match(ConI);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immU7()\n-%{\n-  predicate((0 <= n->get_int()) && (n->get_int() <= 0x7F));\n-  match(ConI);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI8()\n-%{\n-  predicate((-0x80 <= n->get_int()) && (n->get_int() < 0x80));\n-  match(ConI);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immU8()\n-%{\n-  predicate((0 <= n->get_int()) && (n->get_int() <= 255));\n-  match(ConI);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI16()\n-%{\n-  predicate((-32768 <= n->get_int()) && (n->get_int() <= 32767));\n-  match(ConI);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Int Immediate non-negative\n-operand immU31()\n-%{\n-  predicate(n->get_int() >= 0);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Pointer Immediate\n-operand immP()\n-%{\n-  match(ConP);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Null Pointer Immediate\n-operand immP0()\n-%{\n-  predicate(n->get_ptr() == 0);\n-  match(ConP);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Pointer Immediate\n-operand immN() %{\n-  match(ConN);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immNKlass() %{\n-  match(ConNKlass);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Null Pointer Immediate\n-operand immN0() %{\n-  predicate(n->get_narrowcon() == 0);\n-  match(ConN);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immP31()\n-%{\n-  predicate(n->as_Type()->type()->reloc() == relocInfo::none\n-            && (n->get_ptr() >> 31) == 0);\n-  match(ConP);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\n-\/\/ Long Immediate\n-operand immL()\n-%{\n-  match(ConL);\n-\n-  op_cost(20);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate 8-bit\n-operand immL8()\n-%{\n-  predicate(-0x80L <= n->get_long() && n->get_long() < 0x80L);\n-  match(ConL);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate 32-bit unsigned\n-operand immUL32()\n-%{\n-  predicate(n->get_long() == (unsigned int) (n->get_long()));\n-  match(ConL);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate 32-bit signed\n-operand immL32()\n-%{\n-  predicate(n->get_long() == (int) (n->get_long()));\n-  match(ConL);\n-\n-  op_cost(15);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immL_Pow2()\n-%{\n-  predicate(is_power_of_2((julong)n->get_long()));\n-  match(ConL);\n-\n-  op_cost(15);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immL_NotPow2()\n-%{\n-  predicate(is_power_of_2((julong)~n->get_long()));\n-  match(ConL);\n-\n-  op_cost(15);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate zero\n-operand immL0()\n-%{\n-  predicate(n->get_long() == 0L);\n-  match(ConL);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for increment\n-operand immL1()\n-%{\n-  predicate(n->get_long() == 1);\n-  match(ConL);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for decrement\n-operand immL_M1()\n-%{\n-  predicate(n->get_long() == -1);\n-  match(ConL);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long Immediate: low 32-bit mask\n-operand immL_32bits()\n-%{\n-  predicate(n->get_long() == 0xFFFFFFFFL);\n-  match(ConL);\n-  op_cost(20);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Int Immediate: 2^n-1, positive\n-operand immI_Pow2M1()\n-%{\n-  predicate((n->get_int() > 0)\n-            && is_power_of_2((juint)n->get_int() + 1));\n-  match(ConI);\n-\n-  op_cost(20);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Float Immediate zero\n-operand immF0()\n-%{\n-  predicate(jint_cast(n->getf()) == 0);\n-  match(ConF);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Float Immediate\n-operand immF()\n-%{\n-  match(ConF);\n-\n-  op_cost(15);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Half Float Immediate\n-operand immH()\n-%{\n-  match(ConH);\n-\n-  op_cost(15);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Double Immediate zero\n-operand immD0()\n-%{\n-  predicate(jlong_cast(n->getd()) == 0);\n-  match(ConD);\n-\n-  op_cost(5);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Double Immediate\n-operand immD()\n-%{\n-  match(ConD);\n-\n-  op_cost(15);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Immediates for special shifts (sign extend)\n-\n-\/\/ Constants for increment\n-operand immI_16()\n-%{\n-  predicate(n->get_int() == 16);\n-  match(ConI);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_24()\n-%{\n-  predicate(n->get_int() == 24);\n-  match(ConI);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for byte-wide masking\n-operand immI_255()\n-%{\n-  predicate(n->get_int() == 255);\n-  match(ConI);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for short-wide masking\n-operand immI_65535()\n-%{\n-  predicate(n->get_int() == 65535);\n-  match(ConI);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for byte-wide masking\n-operand immL_255()\n-%{\n-  predicate(n->get_long() == 255);\n-  match(ConL);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for short-wide masking\n-operand immL_65535()\n-%{\n-  predicate(n->get_long() == 65535);\n-  match(ConL);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand kReg()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Register Operands\n-\/\/ Integer Register\n-operand rRegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_reg));\n-  match(RegI);\n-\n-  match(rax_RegI);\n-  match(rbx_RegI);\n-  match(rcx_RegI);\n-  match(rdx_RegI);\n-  match(rdi_RegI);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand rax_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_rax_reg));\n-  match(RegI);\n-  match(rRegI);\n-\n-  format %{ \"RAX\" %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand rbx_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_rbx_reg));\n-  match(RegI);\n-  match(rRegI);\n-\n-  format %{ \"RBX\" %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rcx_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_rcx_reg));\n-  match(RegI);\n-  match(rRegI);\n-\n-  format %{ \"RCX\" %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rdx_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_rdx_reg));\n-  match(RegI);\n-  match(rRegI);\n-\n-  format %{ \"RDX\" %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rdi_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_rdi_reg));\n-  match(RegI);\n-  match(rRegI);\n-\n-  format %{ \"RDI\" %}\n-  interface(REG_INTER);\n-%}\n-\n-operand no_rax_rdx_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));\n-  match(RegI);\n-  match(rbx_RegI);\n-  match(rcx_RegI);\n-  match(rdi_RegI);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand no_rbp_r13_RegI()\n-%{\n-  constraint(ALLOC_IN_RC(int_no_rbp_r13_reg));\n-  match(RegI);\n-  match(rRegI);\n-  match(rax_RegI);\n-  match(rbx_RegI);\n-  match(rcx_RegI);\n-  match(rdx_RegI);\n-  match(rdi_RegI);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Pointer Register\n-operand any_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(any_reg));\n-  match(RegP);\n-  match(rax_RegP);\n-  match(rbx_RegP);\n-  match(rdi_RegP);\n-  match(rsi_RegP);\n-  match(rbp_RegP);\n-  match(r15_RegP);\n-  match(rRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rRegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(RegP);\n-  match(rax_RegP);\n-  match(rbx_RegP);\n-  match(rdi_RegP);\n-  match(rsi_RegP);\n-  match(rbp_RegP);  \/\/ See Q&A below about\n-  match(r15_RegP);  \/\/ r15_RegP and rbp_RegP.\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rRegN() %{\n-  constraint(ALLOC_IN_RC(int_reg));\n-  match(RegN);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?\n-\/\/ Answer: Operand match rules govern the DFA as it processes instruction inputs.\n-\/\/ It's fine for an instruction input that expects rRegP to match a r15_RegP.\n-\/\/ The output of an instruction is controlled by the allocator, which respects\n-\/\/ register class masks, not match rules.  Unless an instruction mentions\n-\/\/ r15_RegP or any_RegP explicitly as its output, r15 will not be considered\n-\/\/ by the allocator as an input.\n-\/\/ The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,\n-\/\/ the RBP is used as a proper frame pointer and is not included in ptr_reg. As a\n-\/\/ result, RBP is not included in the output of the instruction either.\n-\n-\/\/ This operand is not allowed to use RBP even if\n-\/\/ RBP is not used to hold the frame pointer.\n-operand no_rbp_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg_no_rbp));\n-  match(RegP);\n-  match(rbx_RegP);\n-  match(rsi_RegP);\n-  match(rdi_RegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-\/\/ Return a pointer value\n-operand rax_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_rax_reg));\n-  match(RegP);\n-  match(rRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-\/\/ Return a compressed pointer value\n-operand rax_RegN()\n-%{\n-  constraint(ALLOC_IN_RC(int_rax_reg));\n-  match(RegN);\n-  match(rRegN);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Used in AtomicAdd\n-operand rbx_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_rbx_reg));\n-  match(RegP);\n-  match(rRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rsi_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_rsi_reg));\n-  match(RegP);\n-  match(rRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rbp_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_rbp_reg));\n-  match(RegP);\n-  match(rRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Used in rep stosq\n-operand rdi_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_rdi_reg));\n-  match(RegP);\n-  match(rRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand r15_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_r15_reg));\n-  match(RegP);\n-  match(rRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rRegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_reg));\n-  match(RegL);\n-  match(rax_RegL);\n-  match(rdx_RegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand no_rax_rdx_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));\n-  match(RegL);\n-  match(rRegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rax_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_rax_reg));\n-  match(RegL);\n-  match(rRegL);\n-\n-  format %{ \"RAX\" %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rcx_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_rcx_reg));\n-  match(RegL);\n-  match(rRegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rdx_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_rdx_reg));\n-  match(RegL);\n-  match(rRegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand r11_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_r11_reg));\n-  match(RegL);\n-  match(rRegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand no_rbp_r13_RegL()\n-%{\n-  constraint(ALLOC_IN_RC(long_no_rbp_r13_reg));\n-  match(RegL);\n-  match(rRegL);\n-  match(rax_RegL);\n-  match(rcx_RegL);\n-  match(rdx_RegL);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Flags register, used as output of compare instructions\n-operand rFlagsReg()\n-%{\n-  constraint(ALLOC_IN_RC(int_flags));\n-  match(RegFlags);\n-\n-  format %{ \"RFLAGS\" %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Flags register, used as output of FLOATING POINT compare instructions\n-operand rFlagsRegU()\n-%{\n-  constraint(ALLOC_IN_RC(int_flags));\n-  match(RegFlags);\n-\n-  format %{ \"RFLAGS_U\" %}\n-  interface(REG_INTER);\n-%}\n-\n-operand rFlagsRegUCF() %{\n-  constraint(ALLOC_IN_RC(int_flags));\n-  match(RegFlags);\n-  predicate(false);\n-\n-  format %{ \"RFLAGS_U_CF\" %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Float register operands\n-operand regF() %{\n-   constraint(ALLOC_IN_RC(float_reg));\n-   match(RegF);\n-\n-   format %{ %}\n-   interface(REG_INTER);\n-%}\n-\n-\/\/ Float register operands\n-operand legRegF() %{\n-   constraint(ALLOC_IN_RC(float_reg_legacy));\n-   match(RegF);\n-\n-   format %{ %}\n-   interface(REG_INTER);\n-%}\n-\n-\/\/ Float register operands\n-operand vlRegF() %{\n-   constraint(ALLOC_IN_RC(float_reg_vl));\n-   match(RegF);\n-\n-   format %{ %}\n-   interface(REG_INTER);\n-%}\n-\n-\/\/ Double register operands\n-operand regD() %{\n-   constraint(ALLOC_IN_RC(double_reg));\n-   match(RegD);\n-\n-   format %{ %}\n-   interface(REG_INTER);\n-%}\n-\n-\/\/ Double register operands\n-operand legRegD() %{\n-   constraint(ALLOC_IN_RC(double_reg_legacy));\n-   match(RegD);\n-\n-   format %{ %}\n-   interface(REG_INTER);\n-%}\n-\n-\/\/ Double register operands\n-operand vlRegD() %{\n-   constraint(ALLOC_IN_RC(double_reg_vl));\n-   match(RegD);\n-\n-   format %{ %}\n-   interface(REG_INTER);\n-%}\n-\n-\/\/----------Memory Operands----------------------------------------------------\n-\/\/ Direct Memory Operand\n-\/\/ operand direct(immP addr)\n-\/\/ %{\n-\/\/   match(addr);\n-\n-\/\/   format %{ \"[$addr]\" %}\n-\/\/   interface(MEMORY_INTER) %{\n-\/\/     base(0xFFFFFFFF);\n-\/\/     index(0x4);\n-\/\/     scale(0x0);\n-\/\/     disp($addr);\n-\/\/   %}\n-\/\/ %}\n-\n-\/\/ Indirect Memory Operand\n-operand indirect(any_RegP reg)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(reg);\n-\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Short Offset Operand\n-operand indOffset8(any_RegP reg, immL8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-\n-  format %{ \"[$reg + $off (8-bit)]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Long Offset Operand\n-operand indOffset32(any_RegP reg, immL32 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-\n-  format %{ \"[$reg + $off (32-bit)]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n-operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (AddP reg lreg) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $lreg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n-operand indIndex(any_RegP reg, rRegL lreg)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg lreg);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $lreg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale(0x0);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Index Register\n-operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg (LShiftL lreg scale));\n-\n-  op_cost(10);\n-  format %{\"[$reg + $lreg << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale($scale);\n-    disp(0x0);\n-  %}\n-%}\n-\n-operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  predicate(n->in(3)->in(1)->as_Type()->type()->is_long()->_lo >= 0);\n-  match(AddP reg (LShiftL (ConvI2L idx) scale));\n-\n-  op_cost(10);\n-  format %{\"[$reg + pos $idx << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($idx);\n-    scale($scale);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Index Register Plus Offset Operand\n-operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (AddP reg (LShiftL lreg scale)) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $lreg << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale($scale);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Positive Index Register Plus Offset Operand\n-operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  predicate(n->in(2)->in(3)->as_Type()->type()->is_long()->_lo >= 0);\n-  match(AddP (AddP reg (ConvI2L idx)) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $idx]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($idx);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand\n-operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  predicate(n->in(2)->in(3)->in(1)->as_Type()->type()->is_long()->_lo >= 0);\n-  match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $idx << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($idx);\n-    scale($scale);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Narrow Oop Operand\n-operand indCompressedOop(rRegN reg) %{\n-  predicate(UseCompressedOops && (CompressedOops::shift() == Address::times_8));\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(DecodeN reg);\n-\n-  op_cost(10);\n-  format %{\"[R12 + $reg << 3] (compressed oop addressing)\" %}\n-  interface(MEMORY_INTER) %{\n-    base(0xc); \/\/ R12\n-    index($reg);\n-    scale(0x3);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Narrow Oop Plus Offset Operand\n-\/\/ Note: x86 architecture doesn't support \"scale * index + offset\" without a base\n-\/\/ we can't free r12 even with CompressedOops::base() == nullptr.\n-operand indCompressedOopOffset(rRegN reg, immL32 off) %{\n-  predicate(UseCompressedOops && (CompressedOops::shift() == Address::times_8));\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-\n-  op_cost(10);\n-  format %{\"[R12 + $reg << 3 + $off] (compressed oop addressing)\" %}\n-  interface(MEMORY_INTER) %{\n-    base(0xc); \/\/ R12\n-    index($reg);\n-    scale(0x3);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Operand\n-operand indirectNarrow(rRegN reg)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(DecodeN reg);\n-\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Short Offset Operand\n-operand indOffset8Narrow(rRegN reg, immL8 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-\n-  format %{ \"[$reg + $off (8-bit)]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Long Offset Operand\n-operand indOffset32Narrow(rRegN reg, immL32 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-\n-  format %{ \"[$reg + $off (32-bit)]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0x4);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n-operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (AddP (DecodeN reg) lreg) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $lreg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Plus Index Register Plus Offset Operand\n-operand indIndexNarrow(rRegN reg, rRegL lreg)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) lreg);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $lreg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale(0x0);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Index Register\n-operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) (LShiftL lreg scale));\n-\n-  op_cost(10);\n-  format %{\"[$reg + $lreg << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale($scale);\n-    disp(0x0);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Index Register Plus Offset Operand\n-operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $lreg << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($lreg);\n-    scale($scale);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Plus Positive Index Register Plus Offset Operand\n-operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  predicate(CompressedOops::shift() == 0 && n->in(2)->in(3)->as_Type()->type()->is_long()->_lo >= 0);\n-  match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $idx]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($idx);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/ Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand\n-operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  predicate(CompressedOops::shift() == 0 && n->in(2)->in(3)->in(1)->as_Type()->type()->is_long()->_lo >= 0);\n-  match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);\n-\n-  op_cost(10);\n-  format %{\"[$reg + $off + $idx << $scale]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index($idx);\n-    scale($scale);\n-    disp($off);\n-  %}\n-%}\n-\n-\/\/----------Special Memory Operands--------------------------------------------\n-\/\/ Stack Slot Operand - This operand is used for loading and storing temporary\n-\/\/                      values on the stack where a match requires a value to\n-\/\/                      flow through memory.\n-operand stackSlotP(sRegP reg)\n-%{\n-  constraint(ALLOC_IN_RC(stack_slots));\n-  \/\/ No match rule because this operand is only generated in matching\n-\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base(0x4);   \/\/ RSP\n-    index(0x4);  \/\/ No Index\n-    scale(0x0);  \/\/ No Scale\n-    disp($reg);  \/\/ Stack Offset\n-  %}\n-%}\n-\n-operand stackSlotI(sRegI reg)\n-%{\n-  constraint(ALLOC_IN_RC(stack_slots));\n-  \/\/ No match rule because this operand is only generated in matching\n-\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base(0x4);   \/\/ RSP\n-    index(0x4);  \/\/ No Index\n-    scale(0x0);  \/\/ No Scale\n-    disp($reg);  \/\/ Stack Offset\n-  %}\n-%}\n-\n-operand stackSlotF(sRegF reg)\n-%{\n-  constraint(ALLOC_IN_RC(stack_slots));\n-  \/\/ No match rule because this operand is only generated in matching\n-\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base(0x4);   \/\/ RSP\n-    index(0x4);  \/\/ No Index\n-    scale(0x0);  \/\/ No Scale\n-    disp($reg);  \/\/ Stack Offset\n-  %}\n-%}\n-\n-operand stackSlotD(sRegD reg)\n-%{\n-  constraint(ALLOC_IN_RC(stack_slots));\n-  \/\/ No match rule because this operand is only generated in matching\n-\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base(0x4);   \/\/ RSP\n-    index(0x4);  \/\/ No Index\n-    scale(0x0);  \/\/ No Scale\n-    disp($reg);  \/\/ Stack Offset\n-  %}\n-%}\n-operand stackSlotL(sRegL reg)\n-%{\n-  constraint(ALLOC_IN_RC(stack_slots));\n-  \/\/ No match rule because this operand is only generated in matching\n-\n-  format %{ \"[$reg]\" %}\n-  interface(MEMORY_INTER) %{\n-    base(0x4);   \/\/ RSP\n-    index(0x4);  \/\/ No Index\n-    scale(0x0);  \/\/ No Scale\n-    disp($reg);  \/\/ Stack Offset\n-  %}\n-%}\n-\n-\/\/----------Conditional Branch Operands----------------------------------------\n-\/\/ Comparison Op  - This is the operation of the comparison, and is limited to\n-\/\/                  the following set of codes:\n-\/\/                  L (<), LE (<=), G (>), GE (>=), E (==), NE (!=)\n-\/\/\n-\/\/ Other attributes of the comparison, such as unsignedness, are specified\n-\/\/ by the comparison instruction that sets a condition code flags register.\n-\/\/ That result is represented by a flags operand whose subtype is appropriate\n-\/\/ to the unsignedness (etc.) of the comparison.\n-\/\/\n-\/\/ Later, the instruction which matches both the Comparison Op (a Bool) and\n-\/\/ the flags (produced by the Cmp) specifies the coding of the comparison op\n-\/\/ by matching a specific subtype of Bool operand below, such as cmpOpU.\n-\n-\/\/ Comparison Code\n-operand cmpOp()\n-%{\n-  match(Bool);\n-\n-  format %{ \"\" %}\n-  interface(COND_INTER) %{\n-    equal(0x4, \"e\");\n-    not_equal(0x5, \"ne\");\n-    less(0xC, \"l\");\n-    greater_equal(0xD, \"ge\");\n-    less_equal(0xE, \"le\");\n-    greater(0xF, \"g\");\n-    overflow(0x0, \"o\");\n-    no_overflow(0x1, \"no\");\n-  %}\n-%}\n-\n-\/\/ Comparison Code, unsigned compare.  Used by FP also, with\n-\/\/ C2 (unordered) turned into GT or LT already.  The other bits\n-\/\/ C0 and C3 are turned into Carry & Zero flags.\n-operand cmpOpU()\n-%{\n-  match(Bool);\n-\n-  format %{ \"\" %}\n-  interface(COND_INTER) %{\n-    equal(0x4, \"e\");\n-    not_equal(0x5, \"ne\");\n-    less(0x2, \"b\");\n-    greater_equal(0x3, \"ae\");\n-    less_equal(0x6, \"be\");\n-    greater(0x7, \"a\");\n-    overflow(0x0, \"o\");\n-    no_overflow(0x1, \"no\");\n-  %}\n-%}\n-\n-\n-\/\/ Floating comparisons that don't require any fixup for the unordered case,\n-\/\/ If both inputs of the comparison are the same, ZF is always set so we\n-\/\/ don't need to use cmpOpUCF2 for eq\/ne\n-operand cmpOpUCF() %{\n-  match(Bool);\n-  predicate(n->as_Bool()->_test._test == BoolTest::lt ||\n-            n->as_Bool()->_test._test == BoolTest::ge ||\n-            n->as_Bool()->_test._test == BoolTest::le ||\n-            n->as_Bool()->_test._test == BoolTest::gt ||\n-            n->in(1)->in(1) == n->in(1)->in(2));\n-  format %{ \"\" %}\n-  interface(COND_INTER) %{\n-    equal(0xb, \"np\");\n-    not_equal(0xa, \"p\");\n-    less(0x2, \"b\");\n-    greater_equal(0x3, \"ae\");\n-    less_equal(0x6, \"be\");\n-    greater(0x7, \"a\");\n-    overflow(0x0, \"o\");\n-    no_overflow(0x1, \"no\");\n-  %}\n-%}\n-\n-\n-\/\/ Floating comparisons that can be fixed up with extra conditional jumps\n-operand cmpOpUCF2() %{\n-  match(Bool);\n-  predicate((n->as_Bool()->_test._test == BoolTest::ne ||\n-             n->as_Bool()->_test._test == BoolTest::eq) &&\n-            n->in(1)->in(1) != n->in(1)->in(2));\n-  format %{ \"\" %}\n-  interface(COND_INTER) %{\n-    equal(0x4, \"e\");\n-    not_equal(0x5, \"ne\");\n-    less(0x2, \"b\");\n-    greater_equal(0x3, \"ae\");\n-    less_equal(0x6, \"be\");\n-    greater(0x7, \"a\");\n-    overflow(0x0, \"o\");\n-    no_overflow(0x1, \"no\");\n-  %}\n-%}\n-\n-\/\/----------OPERAND CLASSES----------------------------------------------------\n-\/\/ Operand Classes are groups of operands that are used as to simplify\n-\/\/ instruction definitions by not requiring the AD writer to specify separate\n-\/\/ instructions for every form of operand when the instruction accepts\n-\/\/ multiple operand types with the same basic encoding and format.  The classic\n-\/\/ case of this is memory operands.\n-\n-opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,\n-               indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,\n-               indCompressedOop, indCompressedOopOffset,\n-               indirectNarrow, indOffset8Narrow, indOffset32Narrow,\n-               indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,\n-               indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);\n-\n-\/\/----------PIPELINE-----------------------------------------------------------\n-\/\/ Rules which define the behavior of the target architectures pipeline.\n-pipeline %{\n-\n-\/\/----------ATTRIBUTES---------------------------------------------------------\n-attributes %{\n-  variable_size_instructions;        \/\/ Fixed size instructions\n-  max_instructions_per_bundle = 3;   \/\/ Up to 3 instructions per bundle\n-  instruction_unit_size = 1;         \/\/ An instruction is 1 bytes long\n-  instruction_fetch_unit_size = 16;  \/\/ The processor fetches one line\n-  instruction_fetch_units = 1;       \/\/ of 16 bytes\n-%}\n-\n-\/\/----------RESOURCES----------------------------------------------------------\n-\/\/ Resources are the functional units available to the machine\n-\n-\/\/ Generic P2\/P3 pipeline\n-\/\/ 3 decoders, only D0 handles big operands; a \"bundle\" is the limit of\n-\/\/ 3 instructions decoded per cycle.\n-\/\/ 2 load\/store ops per cycle, 1 branch, 1 FPU,\n-\/\/ 3 ALU op, only ALU0 handles mul instructions.\n-resources( D0, D1, D2, DECODE = D0 | D1 | D2,\n-           MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,\n-           BR, FPU,\n-           ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);\n-\n-\/\/----------PIPELINE DESCRIPTION-----------------------------------------------\n-\/\/ Pipeline Description specifies the stages in the machine's pipeline\n-\n-\/\/ Generic P2\/P3 pipeline\n-pipe_desc(S0, S1, S2, S3, S4, S5);\n-\n-\/\/----------PIPELINE CLASSES---------------------------------------------------\n-\/\/ Pipeline Classes describe the stages in which input and output are\n-\/\/ referenced by the hardware pipeline.\n-\n-\/\/ Naming convention: ialu or fpu\n-\/\/ Then: _reg\n-\/\/ Then: _reg if there is a 2nd register\n-\/\/ Then: _long if it's a pair of instructions implementing a long\n-\/\/ Then: _fat if it requires the big decoder\n-\/\/   Or: _mem if it requires the big decoder and a memory unit.\n-\n-\/\/ Integer ALU reg operation\n-pipe_class ialu_reg(rRegI dst)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    dst    : S3(read);\n-    DECODE : S0;        \/\/ any decoder\n-    ALU    : S3;        \/\/ any alu\n-%}\n-\n-\/\/ Long ALU reg operation\n-pipe_class ialu_reg_long(rRegL dst)\n-%{\n-    instruction_count(2);\n-    dst    : S4(write);\n-    dst    : S3(read);\n-    DECODE : S0(2);     \/\/ any 2 decoders\n-    ALU    : S3(2);     \/\/ both alus\n-%}\n-\n-\/\/ Integer ALU reg operation using big decoder\n-pipe_class ialu_reg_fat(rRegI dst)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    dst    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    ALU    : S3;        \/\/ any alu\n-%}\n-\n-\/\/ Integer ALU reg-reg operation\n-pipe_class ialu_reg_reg(rRegI dst, rRegI src)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    src    : S3(read);\n-    DECODE : S0;        \/\/ any decoder\n-    ALU    : S3;        \/\/ any alu\n-%}\n-\n-\/\/ Integer ALU reg-reg operation\n-pipe_class ialu_reg_reg_fat(rRegI dst, memory src)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    src    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    ALU    : S3;        \/\/ any alu\n-%}\n-\n-\/\/ Integer ALU reg-mem operation\n-pipe_class ialu_reg_mem(rRegI dst, memory mem)\n-%{\n-    single_instruction;\n-    dst    : S5(write);\n-    mem    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    ALU    : S4;        \/\/ any alu\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-\/\/ Integer mem operation (prefetch)\n-pipe_class ialu_mem(memory mem)\n-%{\n-    single_instruction;\n-    mem    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-\/\/ Integer Store to Memory\n-pipe_class ialu_mem_reg(memory mem, rRegI src)\n-%{\n-    single_instruction;\n-    mem    : S3(read);\n-    src    : S5(read);\n-    D0     : S0;        \/\/ big decoder only\n-    ALU    : S4;        \/\/ any alu\n-    MEM    : S3;\n-%}\n-\n-\/\/ \/\/ Long Store to Memory\n-\/\/ pipe_class ialu_mem_long_reg(memory mem, rRegL src)\n-\/\/ %{\n-\/\/     instruction_count(2);\n-\/\/     mem    : S3(read);\n-\/\/     src    : S5(read);\n-\/\/     D0     : S0(2);          \/\/ big decoder only; twice\n-\/\/     ALU    : S4(2);     \/\/ any 2 alus\n-\/\/     MEM    : S3(2);  \/\/ Both mems\n-\/\/ %}\n-\n-\/\/ Integer Store to Memory\n-pipe_class ialu_mem_imm(memory mem)\n-%{\n-    single_instruction;\n-    mem    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    ALU    : S4;        \/\/ any alu\n-    MEM    : S3;\n-%}\n-\n-\/\/ Integer ALU0 reg-reg operation\n-pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    src    : S3(read);\n-    D0     : S0;        \/\/ Big decoder only\n-    ALU0   : S3;        \/\/ only alu0\n-%}\n-\n-\/\/ Integer ALU0 reg-mem operation\n-pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)\n-%{\n-    single_instruction;\n-    dst    : S5(write);\n-    mem    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    ALU0   : S4;        \/\/ ALU0 only\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-\/\/ Integer ALU reg-reg operation\n-pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)\n-%{\n-    single_instruction;\n-    cr     : S4(write);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    DECODE : S0;        \/\/ any decoder\n-    ALU    : S3;        \/\/ any alu\n-%}\n-\n-\/\/ Integer ALU reg-imm operation\n-pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)\n-%{\n-    single_instruction;\n-    cr     : S4(write);\n-    src1   : S3(read);\n-    DECODE : S0;        \/\/ any decoder\n-    ALU    : S3;        \/\/ any alu\n-%}\n-\n-\/\/ Integer ALU reg-mem operation\n-pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)\n-%{\n-    single_instruction;\n-    cr     : S4(write);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    ALU    : S4;        \/\/ any alu\n-    MEM    : S3;\n-%}\n-\n-\/\/ Conditional move reg-reg\n-pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)\n-%{\n-    instruction_count(4);\n-    y      : S4(read);\n-    q      : S3(read);\n-    p      : S3(read);\n-    DECODE : S0(4);     \/\/ any decoder\n-%}\n-\n-\/\/ Conditional move reg-reg\n-pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    src    : S3(read);\n-    cr     : S3(read);\n-    DECODE : S0;        \/\/ any decoder\n-%}\n-\n-\/\/ Conditional move reg-mem\n-pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    src    : S3(read);\n-    cr     : S3(read);\n-    DECODE : S0;        \/\/ any decoder\n-    MEM    : S3;\n-%}\n-\n-\/\/ Conditional move reg-reg long\n-pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)\n-%{\n-    single_instruction;\n-    dst    : S4(write);\n-    src    : S3(read);\n-    cr     : S3(read);\n-    DECODE : S0(2);     \/\/ any 2 decoders\n-%}\n-\n-\/\/ Float reg-reg operation\n-pipe_class fpu_reg(regD dst)\n-%{\n-    instruction_count(2);\n-    dst    : S3(read);\n-    DECODE : S0(2);     \/\/ any 2 decoders\n-    FPU    : S3;\n-%}\n-\n-\/\/ Float reg-reg operation\n-pipe_class fpu_reg_reg(regD dst, regD src)\n-%{\n-    instruction_count(2);\n-    dst    : S4(write);\n-    src    : S3(read);\n-    DECODE : S0(2);     \/\/ any 2 decoders\n-    FPU    : S3;\n-%}\n-\n-\/\/ Float reg-reg operation\n-pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)\n-%{\n-    instruction_count(3);\n-    dst    : S4(write);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    DECODE : S0(3);     \/\/ any 3 decoders\n-    FPU    : S3(2);\n-%}\n-\n-\/\/ Float reg-reg operation\n-pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)\n-%{\n-    instruction_count(4);\n-    dst    : S4(write);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    src3   : S3(read);\n-    DECODE : S0(4);     \/\/ any 3 decoders\n-    FPU    : S3(2);\n-%}\n-\n-\/\/ Float reg-reg operation\n-pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)\n-%{\n-    instruction_count(4);\n-    dst    : S4(write);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    src3   : S3(read);\n-    DECODE : S1(3);     \/\/ any 3 decoders\n-    D0     : S0;        \/\/ Big decoder only\n-    FPU    : S3(2);\n-    MEM    : S3;\n-%}\n-\n-\/\/ Float reg-mem operation\n-pipe_class fpu_reg_mem(regD dst, memory mem)\n-%{\n-    instruction_count(2);\n-    dst    : S5(write);\n-    mem    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    DECODE : S1;        \/\/ any decoder for FPU POP\n-    FPU    : S4;\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-\/\/ Float reg-mem operation\n-pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)\n-%{\n-    instruction_count(3);\n-    dst    : S5(write);\n-    src1   : S3(read);\n-    mem    : S3(read);\n-    D0     : S0;        \/\/ big decoder only\n-    DECODE : S1(2);     \/\/ any decoder for FPU POP\n-    FPU    : S4;\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-\/\/ Float mem-reg operation\n-pipe_class fpu_mem_reg(memory mem, regD src)\n-%{\n-    instruction_count(2);\n-    src    : S5(read);\n-    mem    : S3(read);\n-    DECODE : S0;        \/\/ any decoder for FPU PUSH\n-    D0     : S1;        \/\/ big decoder only\n-    FPU    : S4;\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)\n-%{\n-    instruction_count(3);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    mem    : S3(read);\n-    DECODE : S0(2);     \/\/ any decoder for FPU PUSH\n-    D0     : S1;        \/\/ big decoder only\n-    FPU    : S4;\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)\n-%{\n-    instruction_count(3);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    mem    : S4(read);\n-    DECODE : S0;        \/\/ any decoder for FPU PUSH\n-    D0     : S0(2);     \/\/ big decoder only\n-    FPU    : S4;\n-    MEM    : S3(2);     \/\/ any mem\n-%}\n-\n-pipe_class fpu_mem_mem(memory dst, memory src1)\n-%{\n-    instruction_count(2);\n-    src1   : S3(read);\n-    dst    : S4(read);\n-    D0     : S0(2);     \/\/ big decoder only\n-    MEM    : S3(2);     \/\/ any mem\n-%}\n-\n-pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)\n-%{\n-    instruction_count(3);\n-    src1   : S3(read);\n-    src2   : S3(read);\n-    dst    : S4(read);\n-    D0     : S0(3);     \/\/ big decoder only\n-    FPU    : S4;\n-    MEM    : S3(3);     \/\/ any mem\n-%}\n-\n-pipe_class fpu_mem_reg_con(memory mem, regD src1)\n-%{\n-    instruction_count(3);\n-    src1   : S4(read);\n-    mem    : S4(read);\n-    DECODE : S0;        \/\/ any decoder for FPU PUSH\n-    D0     : S0(2);     \/\/ big decoder only\n-    FPU    : S4;\n-    MEM    : S3(2);     \/\/ any mem\n-%}\n-\n-\/\/ Float load constant\n-pipe_class fpu_reg_con(regD dst)\n-%{\n-    instruction_count(2);\n-    dst    : S5(write);\n-    D0     : S0;        \/\/ big decoder only for the load\n-    DECODE : S1;        \/\/ any decoder for FPU POP\n-    FPU    : S4;\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-\/\/ Float load constant\n-pipe_class fpu_reg_reg_con(regD dst, regD src)\n-%{\n-    instruction_count(3);\n-    dst    : S5(write);\n-    src    : S3(read);\n-    D0     : S0;        \/\/ big decoder only for the load\n-    DECODE : S1(2);     \/\/ any decoder for FPU POP\n-    FPU    : S4;\n-    MEM    : S3;        \/\/ any mem\n-%}\n-\n-\/\/ UnConditional branch\n-pipe_class pipe_jmp(label labl)\n-%{\n-    single_instruction;\n-    BR   : S3;\n-%}\n-\n-\/\/ Conditional branch\n-pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)\n-%{\n-    single_instruction;\n-    cr    : S1(read);\n-    BR    : S3;\n-%}\n-\n-\/\/ Allocation idiom\n-pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)\n-%{\n-    instruction_count(1); force_serialization;\n-    fixed_latency(6);\n-    heap_ptr : S3(read);\n-    DECODE   : S0(3);\n-    D0       : S2;\n-    MEM      : S3;\n-    ALU      : S3(2);\n-    dst      : S5(write);\n-    BR       : S5;\n-%}\n-\n-\/\/ Generic big\/slow expanded idiom\n-pipe_class pipe_slow()\n-%{\n-    instruction_count(10); multiple_bundles; force_serialization;\n-    fixed_latency(100);\n-    D0  : S0(2);\n-    MEM : S3(2);\n-%}\n-\n-\/\/ The real do-nothing guy\n-pipe_class empty()\n-%{\n-    instruction_count(0);\n-%}\n-\n-\/\/ Define the class for the Nop node\n-define\n-%{\n-   MachNop = empty;\n-%}\n-\n-%}\n-\n-\/\/----------INSTRUCTIONS-------------------------------------------------------\n-\/\/\n-\/\/ match      -- States which machine-independent subtree may be replaced\n-\/\/               by this instruction.\n-\/\/ ins_cost   -- The estimated cost of this instruction is used by instruction\n-\/\/               selection to identify a minimum cost tree of machine\n-\/\/               instructions that matches a tree of machine-independent\n-\/\/               instructions.\n-\/\/ format     -- A string providing the disassembly for this instruction.\n-\/\/               The value of an instruction's operand may be inserted\n-\/\/               by referring to it with a '$' prefix.\n-\/\/ opcode     -- Three instruction opcodes may be provided.  These are referred\n-\/\/               to within an encode class as $primary, $secondary, and $tertiary\n-\/\/               rrspectively.  The primary opcode is commonly used to\n-\/\/               indicate the type of machine instruction, while secondary\n-\/\/               and tertiary are often used for prefix options or addressing\n-\/\/               modes.\n-\/\/ ins_encode -- A list of encode classes with parameters. The encode class\n-\/\/               name must have been defined in an 'enc_class' specification\n-\/\/               in the encode section of the architecture description.\n-\n-\/\/ Dummy reg-to-reg vector moves. Removed during post-selection cleanup.\n-\/\/ Load Float\n-instruct MoveF2VL(vlRegF dst, regF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveF2LEG(legRegF dst, regF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveVL2F(regF dst, vlRegF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t! load float (4 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Float\n-instruct MoveLEG2F(regF dst, legRegF src) %{\n-  match(Set dst src);\n-  format %{ \"movss $dst,$src\\t# if src != dst load float (4 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveD2VL(vlRegD dst, regD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveD2LEG(legRegD dst, regD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveVL2D(regD dst, vlRegD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t! load double (8 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/ Load Double\n-instruct MoveLEG2D(regD dst, legRegD src) %{\n-  match(Set dst src);\n-  format %{ \"movsd $dst,$src\\t# if src != dst load double (8 bytes)\" %}\n-  ins_encode %{\n-    ShouldNotReachHere();\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-\/\/----------Load\/Store\/Move Instructions---------------------------------------\n-\/\/----------Load Instructions--------------------------------------------------\n-\n-\/\/ Load Byte (8 bit signed)\n-instruct loadB(rRegI dst, memory mem)\n-%{\n-  match(Set dst (LoadB mem));\n-\n-  ins_cost(125);\n-  format %{ \"movsbl  $dst, $mem\\t# byte\" %}\n-\n-  ins_encode %{\n-    __ movsbl($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Byte (8 bit signed) into Long Register\n-instruct loadB2L(rRegL dst, memory mem)\n-%{\n-  match(Set dst (ConvI2L (LoadB mem)));\n-\n-  ins_cost(125);\n-  format %{ \"movsbq  $dst, $mem\\t# byte -> long\" %}\n-\n-  ins_encode %{\n-    __ movsbq($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Byte (8 bit UNsigned)\n-instruct loadUB(rRegI dst, memory mem)\n-%{\n-  match(Set dst (LoadUB mem));\n-\n-  ins_cost(125);\n-  format %{ \"movzbl  $dst, $mem\\t# ubyte\" %}\n-\n-  ins_encode %{\n-    __ movzbl($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Byte (8 bit UNsigned) into Long Register\n-instruct loadUB2L(rRegL dst, memory mem)\n-%{\n-  match(Set dst (ConvI2L (LoadUB mem)));\n-\n-  ins_cost(125);\n-  format %{ \"movzbq  $dst, $mem\\t# ubyte -> long\" %}\n-\n-  ins_encode %{\n-    __ movzbq($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register\n-instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{\n-  match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));\n-  effect(KILL cr);\n-\n-  format %{ \"movzbq  $dst, $mem\\t# ubyte & 32-bit mask -> long\\n\\t\"\n-            \"andl    $dst, right_n_bits($mask, 8)\" %}\n-  ins_encode %{\n-    Register Rdst = $dst$$Register;\n-    __ movzbq(Rdst, $mem$$Address);\n-    __ andl(Rdst, $mask$$constant & right_n_bits(8));\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Short (16 bit signed)\n-instruct loadS(rRegI dst, memory mem)\n-%{\n-  match(Set dst (LoadS mem));\n-\n-  ins_cost(125);\n-  format %{ \"movswl $dst, $mem\\t# short\" %}\n-\n-  ins_encode %{\n-    __ movswl($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Short (16 bit signed) to Byte (8 bit signed)\n-instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{\n-  match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));\n-\n-  ins_cost(125);\n-  format %{ \"movsbl $dst, $mem\\t# short -> byte\" %}\n-  ins_encode %{\n-    __ movsbl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Short (16 bit signed) into Long Register\n-instruct loadS2L(rRegL dst, memory mem)\n-%{\n-  match(Set dst (ConvI2L (LoadS mem)));\n-\n-  ins_cost(125);\n-  format %{ \"movswq $dst, $mem\\t# short -> long\" %}\n-\n-  ins_encode %{\n-    __ movswq($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Short\/Char (16 bit UNsigned)\n-instruct loadUS(rRegI dst, memory mem)\n-%{\n-  match(Set dst (LoadUS mem));\n-\n-  ins_cost(125);\n-  format %{ \"movzwl  $dst, $mem\\t# ushort\/char\" %}\n-\n-  ins_encode %{\n-    __ movzwl($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Short\/Char (16 bit UNsigned) to Byte (8 bit signed)\n-instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{\n-  match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));\n-\n-  ins_cost(125);\n-  format %{ \"movsbl $dst, $mem\\t# ushort -> byte\" %}\n-  ins_encode %{\n-    __ movsbl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Short\/Char (16 bit UNsigned) into Long Register\n-instruct loadUS2L(rRegL dst, memory mem)\n-%{\n-  match(Set dst (ConvI2L (LoadUS mem)));\n-\n-  ins_cost(125);\n-  format %{ \"movzwq  $dst, $mem\\t# ushort\/char -> long\" %}\n-\n-  ins_encode %{\n-    __ movzwq($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Short\/Char (16 bit UNsigned) with mask 0xFF into Long Register\n-instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{\n-  match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));\n-\n-  format %{ \"movzbq  $dst, $mem\\t# ushort\/char & 0xFF -> long\" %}\n-  ins_encode %{\n-    __ movzbq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Short\/Char (16 bit UNsigned) with 32-bit mask into Long Register\n-instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{\n-  match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));\n-  effect(KILL cr);\n-\n-  format %{ \"movzwq  $dst, $mem\\t# ushort\/char & 32-bit mask -> long\\n\\t\"\n-            \"andl    $dst, right_n_bits($mask, 16)\" %}\n-  ins_encode %{\n-    Register Rdst = $dst$$Register;\n-    __ movzwq(Rdst, $mem$$Address);\n-    __ andl(Rdst, $mask$$constant & right_n_bits(16));\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer\n-instruct loadI(rRegI dst, memory mem)\n-%{\n-  match(Set dst (LoadI mem));\n-\n-  ins_cost(125);\n-  format %{ \"movl    $dst, $mem\\t# int\" %}\n-\n-  ins_encode %{\n-    __ movl($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer (32 bit signed) to Byte (8 bit signed)\n-instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{\n-  match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));\n-\n-  ins_cost(125);\n-  format %{ \"movsbl  $dst, $mem\\t# int -> byte\" %}\n-  ins_encode %{\n-    __ movsbl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)\n-instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{\n-  match(Set dst (AndI (LoadI mem) mask));\n-\n-  ins_cost(125);\n-  format %{ \"movzbl  $dst, $mem\\t# int -> ubyte\" %}\n-  ins_encode %{\n-    __ movzbl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer (32 bit signed) to Short (16 bit signed)\n-instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{\n-  match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));\n-\n-  ins_cost(125);\n-  format %{ \"movswl  $dst, $mem\\t# int -> short\" %}\n-  ins_encode %{\n-    __ movswl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer (32 bit signed) to Unsigned Short\/Char (16 bit UNsigned)\n-instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{\n-  match(Set dst (AndI (LoadI mem) mask));\n-\n-  ins_cost(125);\n-  format %{ \"movzwl  $dst, $mem\\t# int -> ushort\/char\" %}\n-  ins_encode %{\n-    __ movzwl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer into Long Register\n-instruct loadI2L(rRegL dst, memory mem)\n-%{\n-  match(Set dst (ConvI2L (LoadI mem)));\n-\n-  ins_cost(125);\n-  format %{ \"movslq  $dst, $mem\\t# int -> long\" %}\n-\n-  ins_encode %{\n-    __ movslq($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer with mask 0xFF into Long Register\n-instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{\n-  match(Set dst (ConvI2L (AndI (LoadI mem) mask)));\n-\n-  format %{ \"movzbq  $dst, $mem\\t# int & 0xFF -> long\" %}\n-  ins_encode %{\n-    __ movzbq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer with mask 0xFFFF into Long Register\n-instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{\n-  match(Set dst (ConvI2L (AndI (LoadI mem) mask)));\n-\n-  format %{ \"movzwq  $dst, $mem\\t# int & 0xFFFF -> long\" %}\n-  ins_encode %{\n-    __ movzwq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Integer with a 31-bit mask into Long Register\n-instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{\n-  match(Set dst (ConvI2L (AndI (LoadI mem) mask)));\n-  effect(KILL cr);\n-\n-  format %{ \"movl    $dst, $mem\\t# int & 31-bit mask -> long\\n\\t\"\n-            \"andl    $dst, $mask\" %}\n-  ins_encode %{\n-    Register Rdst = $dst$$Register;\n-    __ movl(Rdst, $mem$$Address);\n-    __ andl(Rdst, $mask$$constant);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Unsigned Integer into Long Register\n-instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)\n-%{\n-  match(Set dst (AndL (ConvI2L (LoadI mem)) mask));\n-\n-  ins_cost(125);\n-  format %{ \"movl    $dst, $mem\\t# uint -> long\" %}\n-\n-  ins_encode %{\n-    __ movl($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Long\n-instruct loadL(rRegL dst, memory mem)\n-%{\n-  match(Set dst (LoadL mem));\n-\n-  ins_cost(125);\n-  format %{ \"movq    $dst, $mem\\t# long\" %}\n-\n-  ins_encode %{\n-    __ movq($dst$$Register, $mem$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n-%}\n-\n-\/\/ Load Range\n-instruct loadRange(rRegI dst, memory mem)\n-%{\n-  match(Set dst (LoadRange mem));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movl    $dst, $mem\\t# range\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Pointer\n-instruct loadP(rRegP dst, memory mem)\n-%{\n-  match(Set dst (LoadP mem));\n-  predicate(n->as_Load()->barrier_data() == 0);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $dst, $mem\\t# ptr\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n-%}\n-\n-\/\/ Load Compressed Pointer\n-instruct loadN(rRegN dst, memory mem)\n-%{\n-   predicate(n->as_Load()->barrier_data() == 0);\n-   match(Set dst (LoadN mem));\n-\n-   ins_cost(125); \/\/ XXX\n-   format %{ \"movl    $dst, $mem\\t# compressed ptr\" %}\n-   ins_encode %{\n-     __ movl($dst$$Register, $mem$$Address);\n-   %}\n-   ins_pipe(ialu_reg_mem); \/\/ XXX\n-%}\n-\n-\n-\/\/ Load Klass Pointer\n-instruct loadKlass(rRegP dst, memory mem)\n-%{\n-  match(Set dst (LoadKlass mem));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $dst, $mem\\t# class\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n-%}\n-\n-\/\/ Load narrow Klass Pointer\n-instruct loadNKlass(rRegN dst, memory mem)\n-%{\n-  predicate(!UseCompactObjectHeaders);\n-  match(Set dst (LoadNKlass mem));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movl    $dst, $mem\\t# compressed klass ptr\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n-%}\n-\n-instruct loadNKlassCompactHeaders(rRegN dst, memory mem, rFlagsReg cr)\n-%{\n-  predicate(UseCompactObjectHeaders);\n-  match(Set dst (LoadNKlass mem));\n-  effect(KILL cr);\n-  ins_cost(125);\n-  format %{\n-    \"movl    $dst, $mem\\t# compressed klass ptr, shifted\\n\\t\"\n-    \"shrl    $dst, markWord::klass_shift_at_offset\"\n-  %}\n-  ins_encode %{\n-    if (UseAPX) {\n-      __ eshrl($dst$$Register, $mem$$Address, markWord::klass_shift_at_offset, false);\n-    }\n-    else {\n-      __ movl($dst$$Register, $mem$$Address);\n-      __ shrl($dst$$Register, markWord::klass_shift_at_offset);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Load Float\n-instruct loadF(regF dst, memory mem)\n-%{\n-  match(Set dst (LoadF mem));\n-\n-  ins_cost(145); \/\/ XXX\n-  format %{ \"movss   $dst, $mem\\t# float\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $mem$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Load Double\n-instruct loadD_partial(regD dst, memory mem)\n-%{\n-  predicate(!UseXmmLoadAndClearUpper);\n-  match(Set dst (LoadD mem));\n-\n-  ins_cost(145); \/\/ XXX\n-  format %{ \"movlpd  $dst, $mem\\t# double\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $mem$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct loadD(regD dst, memory mem)\n-%{\n-  predicate(UseXmmLoadAndClearUpper);\n-  match(Set dst (LoadD mem));\n-\n-  ins_cost(145); \/\/ XXX\n-  format %{ \"movsd   $dst, $mem\\t# double\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $mem$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ max = java.lang.Math.max(float a, float b)\n-instruct maxF_avx10_reg(regF dst, regF a, regF b) %{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (MaxF a b));\n-  format %{ \"maxF $dst, $a, $b\" %}\n-  ins_encode %{\n-    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ max = java.lang.Math.max(float a, float b)\n-instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n-  match(Set dst (MaxF a b));\n-  effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);\n-  format %{ \"maxF $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n-  ins_encode %{\n-    __ vminmax_fp(Op_MaxV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xtmp, rRegI rtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n-  match(Set dst (MaxF a b));\n-  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n-\n-  format %{ \"maxF_reduction $dst, $a, $b \\t!using $xtmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n-                    false \/*min*\/, true \/*single*\/);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ max = java.lang.Math.max(double a, double b)\n-instruct maxD_avx10_reg(regD dst, regD a, regD b) %{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (MaxD a b));\n-  format %{ \"maxD $dst, $a, $b\" %}\n-  ins_encode %{\n-    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ max = java.lang.Math.max(double a, double b)\n-instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n-  match(Set dst (MaxD a b));\n-  effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);\n-  format %{ \"maxD $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n-  ins_encode %{\n-    __ vminmax_fp(Op_MaxV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xtmp, rRegL rtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n-  match(Set dst (MaxD a b));\n-  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n-\n-  format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n-                    false \/*min*\/, false \/*single*\/);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ max = java.lang.Math.min(float a, float b)\n-instruct minF_avx10_reg(regF dst, regF a, regF b) %{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (MinF a b));\n-  format %{ \"minF $dst, $a, $b\" %}\n-  ins_encode %{\n-    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ min = java.lang.Math.min(float a, float b)\n-instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n-  match(Set dst (MinF a b));\n-  effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);\n-  format %{ \"minF $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n-  ins_encode %{\n-    __ vminmax_fp(Op_MinV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xtmp, rRegI rtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n-  match(Set dst (MinF a b));\n-  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n-\n-  format %{ \"minF_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n-                    true \/*min*\/, true \/*single*\/);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ max = java.lang.Math.min(double a, double b)\n-instruct minD_avx10_reg(regD dst, regD a, regD b) %{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (MinD a b));\n-  format %{ \"minD $dst, $a, $b\" %}\n-  ins_encode %{\n-    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ min = java.lang.Math.min(double a, double b)\n-instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n-  match(Set dst (MinD a b));\n-  effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);\n-    format %{ \"minD $dst, $a, $b \\t! using $tmp, $atmp and $btmp as TEMP\" %}\n-  ins_encode %{\n-    __ vminmax_fp(Op_MinV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xtmp, rRegL rtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n-  match(Set dst (MinD a b));\n-  effect(USE a, USE b, TEMP xtmp, TEMP rtmp, KILL cr);\n-\n-  format %{ \"maxD_reduction $dst, $a, $b \\t! using $xtmp and $rtmp as TEMP\" %}\n-  ins_encode %{\n-    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp$$XMMRegister, $rtmp$$Register,\n-                    true \/*min*\/, false \/*single*\/);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ Load Effective Address\n-instruct leaP8(rRegP dst, indOffset8 mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110); \/\/ XXX\n-  format %{ \"leaq    $dst, $mem\\t# ptr 8\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaP32(rRegP dst, indOffset32 mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr 32\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPIdxOff(rRegP dst, indIndexOffset mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr idxoff\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPIdxScale(rRegP dst, indIndexScale mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr idxscale\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr idxscale\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr idxscaleoff\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr posidxoff\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)\n-%{\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr posidxscaleoff\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-\/\/ Load Effective Address which uses Narrow (32-bits) oop\n-instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::shift() != 0));\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr compressedoopoff32\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst mem);\n-\n-  ins_cost(110); \/\/ XXX\n-  format %{ \"leaq    $dst, $mem\\t# ptr off8narrow\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr off32narrow\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr idxoffnarrow\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr idxscalenarrow\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr idxscaleoffnarrow\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr posidxoffnarrow\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst mem);\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, $mem\\t# ptr posidxscaleoffnarrow\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_reg_fat);\n-%}\n-\n-instruct loadConI(rRegI dst, immI src)\n-%{\n-  match(Set dst src);\n-\n-  format %{ \"movl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg_fat); \/\/ XXX\n-%}\n-\n-instruct loadConI0(rRegI dst, immI_0 src, rFlagsReg cr)\n-%{\n-  match(Set dst src);\n-  effect(KILL cr);\n-\n-  ins_cost(50);\n-  format %{ \"xorl    $dst, $dst\\t# int\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct loadConL(rRegL dst, immL src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(150);\n-  format %{ \"movq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ mov64($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)\n-%{\n-  match(Set dst src);\n-  effect(KILL cr);\n-\n-  ins_cost(50);\n-  format %{ \"xorl    $dst, $dst\\t# long\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg); \/\/ XXX\n-%}\n-\n-instruct loadConUL32(rRegL dst, immUL32 src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(60);\n-  format %{ \"movl    $dst, $src\\t# long (unsigned 32-bit)\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct loadConL32(rRegL dst, immL32 src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(70);\n-  format %{ \"movq    $dst, $src\\t# long (32-bit)\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct loadConP(rRegP dst, immP con) %{\n-  match(Set dst con);\n-\n-  format %{ \"movq    $dst, $con\\t# ptr\" %}\n-  ins_encode %{\n-    __ mov64($dst$$Register, $con$$constant, $con->constant_reloc(), RELOC_IMM64);\n-  %}\n-  ins_pipe(ialu_reg_fat); \/\/ XXX\n-%}\n-\n-instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)\n-%{\n-  match(Set dst src);\n-  effect(KILL cr);\n-\n-  ins_cost(50);\n-  format %{ \"xorl    $dst, $dst\\t# ptr\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)\n-%{\n-  match(Set dst src);\n-  effect(KILL cr);\n-\n-  ins_cost(60);\n-  format %{ \"movl    $dst, $src\\t# ptr (positive 32-bit)\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct loadConF(regF dst, immF con) %{\n-  match(Set dst con);\n-  ins_cost(125);\n-  format %{ \"movss   $dst, [$constantaddress]\\t# load from constant table: float=$con\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $constantaddress($con));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadConH(regF dst, immH con) %{\n-  match(Set dst con);\n-  ins_cost(125);\n-  format %{ \"movss   $dst, [$constantaddress]\\t# load from constant table: halffloat=$con\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, $constantaddress($con));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{\n-  match(Set dst src);\n-  effect(KILL cr);\n-  format %{ \"xorq    $dst, $src\\t# compressed null pointer\" %}\n-  ins_encode %{\n-    __ xorq($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct loadConN(rRegN dst, immN src) %{\n-  match(Set dst src);\n-\n-  ins_cost(125);\n-  format %{ \"movl    $dst, $src\\t# compressed ptr\" %}\n-  ins_encode %{\n-    address con = (address)$src$$constant;\n-    if (con == nullptr) {\n-      ShouldNotReachHere();\n-    } else {\n-      __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_fat); \/\/ XXX\n-%}\n-\n-instruct loadConNKlass(rRegN dst, immNKlass src) %{\n-  match(Set dst src);\n-\n-  ins_cost(125);\n-  format %{ \"movl    $dst, $src\\t# compressed klass ptr\" %}\n-  ins_encode %{\n-    address con = (address)$src$$constant;\n-    if (con == nullptr) {\n-      ShouldNotReachHere();\n-    } else {\n-      __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_fat); \/\/ XXX\n-%}\n-\n-instruct loadConF0(regF dst, immF0 src)\n-%{\n-  match(Set dst src);\n-  ins_cost(100);\n-\n-  format %{ \"xorps   $dst, $dst\\t# float 0.0\" %}\n-  ins_encode %{\n-    __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Use the same format since predicate() can not be used here.\n-instruct loadConD(regD dst, immD con) %{\n-  match(Set dst con);\n-  ins_cost(125);\n-  format %{ \"movsd   $dst, [$constantaddress]\\t# load from constant table: double=$con\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, $constantaddress($con));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadConD0(regD dst, immD0 src)\n-%{\n-  match(Set dst src);\n-  ins_cost(100);\n-\n-  format %{ \"xorpd   $dst, $dst\\t# double 0.0\" %}\n-  ins_encode %{\n-    __ xorpd($dst$$XMMRegister, $dst$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadSSI(rRegI dst, stackSlotI src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(125);\n-  format %{ \"movl    $dst, $src\\t# int stk\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct loadSSL(rRegL dst, stackSlotL src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(125);\n-  format %{ \"movq    $dst, $src\\t# long stk\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct loadSSP(rRegP dst, stackSlotP src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(125);\n-  format %{ \"movq    $dst, $src\\t# ptr stk\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct loadSSF(regF dst, stackSlotF src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(125);\n-  format %{ \"movss   $dst, $src\\t# float stk\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Use the same format since predicate() can not be used here.\n-instruct loadSSD(regD dst, stackSlotD src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(125);\n-  format %{ \"movsd   $dst, $src\\t# double stk\" %}\n-  ins_encode  %{\n-    __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Prefetch instructions for allocation.\n-\/\/ Must be safe to execute with invalid address (cannot fault).\n-\n-instruct prefetchAlloc( memory mem ) %{\n-  predicate(AllocatePrefetchInstr==3);\n-  match(PrefetchAllocation mem);\n-  ins_cost(125);\n-\n-  format %{ \"PREFETCHW $mem\\t# Prefetch allocation into level 1 cache and mark modified\" %}\n-  ins_encode %{\n-    __ prefetchw($mem$$Address);\n-  %}\n-  ins_pipe(ialu_mem);\n-%}\n-\n-instruct prefetchAllocNTA( memory mem ) %{\n-  predicate(AllocatePrefetchInstr==0);\n-  match(PrefetchAllocation mem);\n-  ins_cost(125);\n-\n-  format %{ \"PREFETCHNTA $mem\\t# Prefetch allocation to non-temporal cache for write\" %}\n-  ins_encode %{\n-    __ prefetchnta($mem$$Address);\n-  %}\n-  ins_pipe(ialu_mem);\n-%}\n-\n-instruct prefetchAllocT0( memory mem ) %{\n-  predicate(AllocatePrefetchInstr==1);\n-  match(PrefetchAllocation mem);\n-  ins_cost(125);\n-\n-  format %{ \"PREFETCHT0 $mem\\t# Prefetch allocation to level 1 and 2 caches for write\" %}\n-  ins_encode %{\n-    __ prefetcht0($mem$$Address);\n-  %}\n-  ins_pipe(ialu_mem);\n-%}\n-\n-instruct prefetchAllocT2( memory mem ) %{\n-  predicate(AllocatePrefetchInstr==2);\n-  match(PrefetchAllocation mem);\n-  ins_cost(125);\n-\n-  format %{ \"PREFETCHT2 $mem\\t# Prefetch allocation to level 2 cache for write\" %}\n-  ins_encode %{\n-    __ prefetcht2($mem$$Address);\n-  %}\n-  ins_pipe(ialu_mem);\n-%}\n-\n-\/\/----------Store Instructions-------------------------------------------------\n-\n-\/\/ Store Byte\n-instruct storeB(memory mem, rRegI src)\n-%{\n-  match(Set mem (StoreB mem src));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movb    $mem, $src\\t# byte\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Store Char\/Short\n-instruct storeC(memory mem, rRegI src)\n-%{\n-  match(Set mem (StoreC mem src));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movw    $mem, $src\\t# char\/short\" %}\n-  ins_encode %{\n-    __ movw($mem$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Store Integer\n-instruct storeI(memory mem, rRegI src)\n-%{\n-  match(Set mem (StoreI mem src));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movl    $mem, $src\\t# int\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Store Long\n-instruct storeL(memory mem, rRegL src)\n-%{\n-  match(Set mem (StoreL mem src));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $mem, $src\\t# long\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg); \/\/ XXX\n-%}\n-\n-\/\/ Store Pointer\n-instruct storeP(memory mem, any_RegP src)\n-%{\n-  predicate(n->as_Store()->barrier_data() == 0);\n-  match(Set mem (StoreP mem src));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $mem, $src\\t# ptr\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmP0(memory mem, immP0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr) && n->as_Store()->barrier_data() == 0);\n-  match(Set mem (StoreP mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $mem, R12\\t# ptr (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Store Null Pointer, mark word, or other simple pointer constant.\n-instruct storeImmP(memory mem, immP31 src)\n-%{\n-  predicate(n->as_Store()->barrier_data() == 0);\n-  match(Set mem (StoreP mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movq    $mem, $src\\t# ptr\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Store Compressed Pointer\n-instruct storeN(memory mem, rRegN src)\n-%{\n-  predicate(n->as_Store()->barrier_data() == 0);\n-  match(Set mem (StoreN mem src));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movl    $mem, $src\\t# compressed ptr\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeNKlass(memory mem, rRegN src)\n-%{\n-  match(Set mem (StoreNKlass mem src));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movl    $mem, $src\\t# compressed klass ptr\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmN0(memory mem, immN0 zero)\n-%{\n-  predicate(CompressedOops::base() == nullptr && n->as_Store()->barrier_data() == 0);\n-  match(Set mem (StoreN mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movl    $mem, R12\\t# compressed ptr (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmN(memory mem, immN src)\n-%{\n-  predicate(n->as_Store()->barrier_data() == 0);\n-  match(Set mem (StoreN mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movl    $mem, $src\\t# compressed ptr\" %}\n-  ins_encode %{\n-    address con = (address)$src$$constant;\n-    if (con == nullptr) {\n-      __ movl($mem$$Address, 0);\n-    } else {\n-      __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);\n-    }\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct storeImmNKlass(memory mem, immNKlass src)\n-%{\n-  match(Set mem (StoreNKlass mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movl    $mem, $src\\t# compressed klass ptr\" %}\n-  ins_encode %{\n-    __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Store Integer Immediate\n-instruct storeImmI0(memory mem, immI_0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreI mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movl    $mem, R12\\t# int (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmI(memory mem, immI src)\n-%{\n-  match(Set mem (StoreI mem src));\n-\n-  ins_cost(150);\n-  format %{ \"movl    $mem, $src\\t# int\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Store Long Immediate\n-instruct storeImmL0(memory mem, immL0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreL mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $mem, R12\\t# long (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmL(memory mem, immL32 src)\n-%{\n-  match(Set mem (StoreL mem src));\n-\n-  ins_cost(150);\n-  format %{ \"movq    $mem, $src\\t# long\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Store Short\/Char Immediate\n-instruct storeImmC0(memory mem, immI_0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreC mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movw    $mem, R12\\t# short\/char (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movw($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmI16(memory mem, immI16 src)\n-%{\n-  predicate(UseStoreImmI16);\n-  match(Set mem (StoreC mem src));\n-\n-  ins_cost(150);\n-  format %{ \"movw    $mem, $src\\t# short\/char\" %}\n-  ins_encode %{\n-    __ movw($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Store Byte Immediate\n-instruct storeImmB0(memory mem, immI_0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreB mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movb    $mem, R12\\t# short\/char (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmB(memory mem, immI8 src)\n-%{\n-  match(Set mem (StoreB mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movb    $mem, $src\\t# byte\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Store Float\n-instruct storeF(memory mem, regF src)\n-%{\n-  match(Set mem (StoreF mem src));\n-\n-  ins_cost(95); \/\/ XXX\n-  format %{ \"movss   $mem, $src\\t# float\" %}\n-  ins_encode %{\n-    __ movflt($mem$$Address, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Store immediate Float value (it is faster than store from XMM register)\n-instruct storeF0(memory mem, immF0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreF mem zero));\n-\n-  ins_cost(25); \/\/ XXX\n-  format %{ \"movl    $mem, R12\\t# float 0. (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeF_imm(memory mem, immF src)\n-%{\n-  match(Set mem (StoreF mem src));\n-\n-  ins_cost(50);\n-  format %{ \"movl    $mem, $src\\t# float\" %}\n-  ins_encode %{\n-    __ movl($mem$$Address, jint_cast($src$$constant));\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Store Double\n-instruct storeD(memory mem, regD src)\n-%{\n-  match(Set mem (StoreD mem src));\n-\n-  ins_cost(95); \/\/ XXX\n-  format %{ \"movsd   $mem, $src\\t# double\" %}\n-  ins_encode %{\n-    __ movdbl($mem$$Address, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ Store immediate double 0.0 (it is faster than store from XMM register)\n-instruct storeD0_imm(memory mem, immD0 src)\n-%{\n-  predicate(!UseCompressedOops || (CompressedOops::base() != nullptr));\n-  match(Set mem (StoreD mem src));\n-\n-  ins_cost(50);\n-  format %{ \"movq    $mem, $src\\t# double 0.\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct storeD0(memory mem, immD0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreD mem zero));\n-\n-  ins_cost(25); \/\/ XXX\n-  format %{ \"movq    $mem, R12\\t# double 0. (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movq($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeSSI(stackSlotI dst, rRegI src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(100);\n-  format %{ \"movl    $dst, $src\\t# int stk\" %}\n-  ins_encode %{\n-    __ movl($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe( ialu_mem_reg );\n-%}\n-\n-instruct storeSSL(stackSlotL dst, rRegL src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(100);\n-  format %{ \"movq    $dst, $src\\t# long stk\" %}\n-  ins_encode %{\n-    __ movq($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeSSP(stackSlotP dst, rRegP src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(100);\n-  format %{ \"movq    $dst, $src\\t# ptr stk\" %}\n-  ins_encode %{\n-    __ movq($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeSSF(stackSlotF dst, regF src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(95); \/\/ XXX\n-  format %{ \"movss   $dst, $src\\t# float stk\" %}\n-  ins_encode %{\n-    __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct storeSSD(stackSlotD dst, regD src)\n-%{\n-  match(Set dst src);\n-\n-  ins_cost(95); \/\/ XXX\n-  format %{ \"movsd   $dst, $src\\t# double stk\" %}\n-  ins_encode %{\n-    __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct cacheWB(indirect addr)\n-%{\n-  predicate(VM_Version::supports_data_cache_line_flush());\n-  match(CacheWB addr);\n-\n-  ins_cost(100);\n-  format %{\"cache wb $addr\" %}\n-  ins_encode %{\n-    assert($addr->index_position() < 0, \"should be\");\n-    assert($addr$$disp == 0, \"should be\");\n-    __ cache_wb(Address($addr$$base$$Register, 0));\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct cacheWBPreSync()\n-%{\n-  predicate(VM_Version::supports_data_cache_line_flush());\n-  match(CacheWBPreSync);\n-\n-  ins_cost(100);\n-  format %{\"cache wb presync\" %}\n-  ins_encode %{\n-    __ cache_wbsync(true);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct cacheWBPostSync()\n-%{\n-  predicate(VM_Version::supports_data_cache_line_flush());\n-  match(CacheWBPostSync);\n-\n-  ins_cost(100);\n-  format %{\"cache wb postsync\" %}\n-  ins_encode %{\n-    __ cache_wbsync(false);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/----------BSWAP Instructions-------------------------------------------------\n-instruct bytes_reverse_int(rRegI dst) %{\n-  match(Set dst (ReverseBytesI dst));\n-\n-  format %{ \"bswapl  $dst\" %}\n-  ins_encode %{\n-    __ bswapl($dst$$Register);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct bytes_reverse_long(rRegL dst) %{\n-  match(Set dst (ReverseBytesL dst));\n-\n-  format %{ \"bswapq  $dst\" %}\n-  ins_encode %{\n-    __ bswapq($dst$$Register);\n-  %}\n-  ins_pipe( ialu_reg);\n-%}\n-\n-instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{\n-  match(Set dst (ReverseBytesUS dst));\n-  effect(KILL cr);\n-\n-  format %{ \"bswapl  $dst\\n\\t\"\n-            \"shrl    $dst,16\\n\\t\" %}\n-  ins_encode %{\n-    __ bswapl($dst$$Register);\n-    __ shrl($dst$$Register, 16);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{\n-  match(Set dst (ReverseBytesS dst));\n-  effect(KILL cr);\n-\n-  format %{ \"bswapl  $dst\\n\\t\"\n-            \"sar     $dst,16\\n\\t\" %}\n-  ins_encode %{\n-    __ bswapl($dst$$Register);\n-    __ sarl($dst$$Register, 16);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-\/\/---------- Zeros Count Instructions ------------------------------------------\n-\n-instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{\n-  predicate(UseCountLeadingZerosInstruction);\n-  match(Set dst (CountLeadingZerosI src));\n-  effect(KILL cr);\n-\n-  format %{ \"lzcntl  $dst, $src\\t# count leading zeros (int)\" %}\n-  ins_encode %{\n-    __ lzcntl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct countLeadingZerosI_mem(rRegI dst, memory src, rFlagsReg cr) %{\n-  predicate(UseCountLeadingZerosInstruction);\n-  match(Set dst (CountLeadingZerosI (LoadI src)));\n-  effect(KILL cr);\n-  ins_cost(175);\n-  format %{ \"lzcntl  $dst, $src\\t# count leading zeros (int)\" %}\n-  ins_encode %{\n-    __ lzcntl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{\n-  predicate(!UseCountLeadingZerosInstruction);\n-  match(Set dst (CountLeadingZerosI src));\n-  effect(KILL cr);\n-\n-  format %{ \"bsrl    $dst, $src\\t# count leading zeros (int)\\n\\t\"\n-            \"jnz     skip\\n\\t\"\n-            \"movl    $dst, -1\\n\"\n-      \"skip:\\n\\t\"\n-            \"negl    $dst\\n\\t\"\n-            \"addl    $dst, 31\" %}\n-  ins_encode %{\n-    Register Rdst = $dst$$Register;\n-    Register Rsrc = $src$$Register;\n-    Label skip;\n-    __ bsrl(Rdst, Rsrc);\n-    __ jccb(Assembler::notZero, skip);\n-    __ movl(Rdst, -1);\n-    __ bind(skip);\n-    __ negl(Rdst);\n-    __ addl(Rdst, BitsPerInt - 1);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{\n-  predicate(UseCountLeadingZerosInstruction);\n-  match(Set dst (CountLeadingZerosL src));\n-  effect(KILL cr);\n-\n-  format %{ \"lzcntq  $dst, $src\\t# count leading zeros (long)\" %}\n-  ins_encode %{\n-    __ lzcntq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct countLeadingZerosL_mem(rRegI dst, memory src, rFlagsReg cr) %{\n-  predicate(UseCountLeadingZerosInstruction);\n-  match(Set dst (CountLeadingZerosL (LoadL src)));\n-  effect(KILL cr);\n-  ins_cost(175);\n-  format %{ \"lzcntq  $dst, $src\\t# count leading zeros (long)\" %}\n-  ins_encode %{\n-    __ lzcntq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{\n-  predicate(!UseCountLeadingZerosInstruction);\n-  match(Set dst (CountLeadingZerosL src));\n-  effect(KILL cr);\n-\n-  format %{ \"bsrq    $dst, $src\\t# count leading zeros (long)\\n\\t\"\n-            \"jnz     skip\\n\\t\"\n-            \"movl    $dst, -1\\n\"\n-      \"skip:\\n\\t\"\n-            \"negl    $dst\\n\\t\"\n-            \"addl    $dst, 63\" %}\n-  ins_encode %{\n-    Register Rdst = $dst$$Register;\n-    Register Rsrc = $src$$Register;\n-    Label skip;\n-    __ bsrq(Rdst, Rsrc);\n-    __ jccb(Assembler::notZero, skip);\n-    __ movl(Rdst, -1);\n-    __ bind(skip);\n-    __ negl(Rdst);\n-    __ addl(Rdst, BitsPerLong - 1);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{\n-  predicate(UseCountTrailingZerosInstruction);\n-  match(Set dst (CountTrailingZerosI src));\n-  effect(KILL cr);\n-\n-  format %{ \"tzcntl    $dst, $src\\t# count trailing zeros (int)\" %}\n-  ins_encode %{\n-    __ tzcntl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct countTrailingZerosI_mem(rRegI dst, memory src, rFlagsReg cr) %{\n-  predicate(UseCountTrailingZerosInstruction);\n-  match(Set dst (CountTrailingZerosI (LoadI src)));\n-  effect(KILL cr);\n-  ins_cost(175);\n-  format %{ \"tzcntl    $dst, $src\\t# count trailing zeros (int)\" %}\n-  ins_encode %{\n-    __ tzcntl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{\n-  predicate(!UseCountTrailingZerosInstruction);\n-  match(Set dst (CountTrailingZerosI src));\n-  effect(KILL cr);\n-\n-  format %{ \"bsfl    $dst, $src\\t# count trailing zeros (int)\\n\\t\"\n-            \"jnz     done\\n\\t\"\n-            \"movl    $dst, 32\\n\"\n-      \"done:\" %}\n-  ins_encode %{\n-    Register Rdst = $dst$$Register;\n-    Label done;\n-    __ bsfl(Rdst, $src$$Register);\n-    __ jccb(Assembler::notZero, done);\n-    __ movl(Rdst, BitsPerInt);\n-    __ bind(done);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{\n-  predicate(UseCountTrailingZerosInstruction);\n-  match(Set dst (CountTrailingZerosL src));\n-  effect(KILL cr);\n-\n-  format %{ \"tzcntq    $dst, $src\\t# count trailing zeros (long)\" %}\n-  ins_encode %{\n-    __ tzcntq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct countTrailingZerosL_mem(rRegI dst, memory src, rFlagsReg cr) %{\n-  predicate(UseCountTrailingZerosInstruction);\n-  match(Set dst (CountTrailingZerosL (LoadL src)));\n-  effect(KILL cr);\n-  ins_cost(175);\n-  format %{ \"tzcntq    $dst, $src\\t# count trailing zeros (long)\" %}\n-  ins_encode %{\n-    __ tzcntq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{\n-  predicate(!UseCountTrailingZerosInstruction);\n-  match(Set dst (CountTrailingZerosL src));\n-  effect(KILL cr);\n-\n-  format %{ \"bsfq    $dst, $src\\t# count trailing zeros (long)\\n\\t\"\n-            \"jnz     done\\n\\t\"\n-            \"movl    $dst, 64\\n\"\n-      \"done:\" %}\n-  ins_encode %{\n-    Register Rdst = $dst$$Register;\n-    Label done;\n-    __ bsfq(Rdst, $src$$Register);\n-    __ jccb(Assembler::notZero, done);\n-    __ movl(Rdst, BitsPerLong);\n-    __ bind(done);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/--------------- Reverse Operation Instructions ----------------\n-instruct bytes_reversebit_int(rRegI dst, rRegI src, rRegI rtmp, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_gfni());\n-  match(Set dst (ReverseI src));\n-  effect(TEMP dst, TEMP rtmp, KILL cr);\n-  format %{ \"reverse_int $dst $src\\t! using $rtmp as TEMP\" %}\n-  ins_encode %{\n-    __ reverseI($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp$$Register);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct bytes_reversebit_int_gfni(rRegI dst, rRegI src, vlRegF xtmp1, vlRegF xtmp2, rRegL rtmp, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_gfni());\n-  match(Set dst (ReverseI src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n-  format %{ \"reverse_int $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n-  ins_encode %{\n-    __ reverseI($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct bytes_reversebit_long(rRegL dst, rRegL src, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_gfni());\n-  match(Set dst (ReverseL src));\n-  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, KILL cr);\n-  format %{ \"reverse_long $dst $src\\t! using $rtmp1 and $rtmp2 as TEMP\" %}\n-  ins_encode %{\n-    __ reverseL($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp1$$Register, $rtmp2$$Register);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct bytes_reversebit_long_gfni(rRegL dst, rRegL src, vlRegD xtmp1, vlRegD xtmp2, rRegL rtmp, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_gfni());\n-  match(Set dst (ReverseL src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n-  format %{ \"reverse_long $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n-  ins_encode %{\n-    __ reverseL($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register, noreg);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-\/\/---------- Population Count Instructions -------------------------------------\n-\n-instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{\n-  predicate(UsePopCountInstruction);\n-  match(Set dst (PopCountI src));\n-  effect(KILL cr);\n-\n-  format %{ \"popcnt  $dst, $src\" %}\n-  ins_encode %{\n-    __ popcntl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{\n-  predicate(UsePopCountInstruction);\n-  match(Set dst (PopCountI (LoadI mem)));\n-  effect(KILL cr);\n-\n-  format %{ \"popcnt  $dst, $mem\" %}\n-  ins_encode %{\n-    __ popcntl($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Note: Long.bitCount(long) returns an int.\n-instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{\n-  predicate(UsePopCountInstruction);\n-  match(Set dst (PopCountL src));\n-  effect(KILL cr);\n-\n-  format %{ \"popcnt  $dst, $src\" %}\n-  ins_encode %{\n-    __ popcntq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Note: Long.bitCount(long) returns an int.\n-instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{\n-  predicate(UsePopCountInstruction);\n-  match(Set dst (PopCountL (LoadL mem)));\n-  effect(KILL cr);\n-\n-  format %{ \"popcnt  $dst, $mem\" %}\n-  ins_encode %{\n-    __ popcntq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\n-\/\/----------MemBar Instructions-----------------------------------------------\n-\/\/ Memory barrier flavors\n-\n-instruct membar_acquire()\n-%{\n-  match(MemBarAcquire);\n-  match(LoadFence);\n-  ins_cost(0);\n-\n-  size(0);\n-  format %{ \"MEMBAR-acquire ! (empty encoding)\" %}\n-  ins_encode();\n-  ins_pipe(empty);\n-%}\n-\n-instruct membar_acquire_lock()\n-%{\n-  match(MemBarAcquireLock);\n-  ins_cost(0);\n-\n-  size(0);\n-  format %{ \"MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)\" %}\n-  ins_encode();\n-  ins_pipe(empty);\n-%}\n-\n-instruct membar_release()\n-%{\n-  match(MemBarRelease);\n-  match(StoreFence);\n-  ins_cost(0);\n-\n-  size(0);\n-  format %{ \"MEMBAR-release ! (empty encoding)\" %}\n-  ins_encode();\n-  ins_pipe(empty);\n-%}\n-\n-instruct membar_release_lock()\n-%{\n-  match(MemBarReleaseLock);\n-  ins_cost(0);\n-\n-  size(0);\n-  format %{ \"MEMBAR-release (a FastUnlock follows so empty encoding)\" %}\n-  ins_encode();\n-  ins_pipe(empty);\n-%}\n-\n-instruct membar_volatile(rFlagsReg cr) %{\n-  match(MemBarVolatile);\n-  effect(KILL cr);\n-  ins_cost(400);\n-\n-  format %{\n-    $$template\n-    $$emit$$\"lock addl [rsp + #0], 0\\t! membar_volatile\"\n-  %}\n-  ins_encode %{\n-    __ membar(Assembler::StoreLoad);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct unnecessary_membar_volatile()\n-%{\n-  match(MemBarVolatile);\n-  predicate(Matcher::post_store_load_barrier(n));\n-  ins_cost(0);\n-\n-  size(0);\n-  format %{ \"MEMBAR-volatile (unnecessary so empty encoding)\" %}\n-  ins_encode();\n-  ins_pipe(empty);\n-%}\n-\n-instruct membar_storestore() %{\n-  match(MemBarStoreStore);\n-  match(StoreStoreFence);\n-  ins_cost(0);\n-\n-  size(0);\n-  format %{ \"MEMBAR-storestore (empty encoding)\" %}\n-  ins_encode( );\n-  ins_pipe(empty);\n-%}\n-\n-\/\/----------Move Instructions--------------------------------------------------\n-\n-instruct castX2P(rRegP dst, rRegL src)\n-%{\n-  match(Set dst (CastX2P src));\n-\n-  format %{ \"movq    $dst, $src\\t# long->ptr\" %}\n-  ins_encode %{\n-    if ($dst$$reg != $src$$reg) {\n-      __ movptr($dst$$Register, $src$$Register);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg); \/\/ XXX\n-%}\n-\n-instruct castI2N(rRegN dst, rRegI src)\n-%{\n-  match(Set dst (CastI2N src));\n-\n-  format %{ \"movq    $dst, $src\\t# int -> narrow ptr\" %}\n-  ins_encode %{\n-    if ($dst$$reg != $src$$reg) {\n-      __ movl($dst$$Register, $src$$Register);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg); \/\/ XXX\n-%}\n-\n-instruct castN2X(rRegL dst, rRegN src)\n-%{\n-  match(Set dst (CastP2X src));\n-\n-  format %{ \"movq    $dst, $src\\t# ptr -> long\" %}\n-  ins_encode %{\n-    if ($dst$$reg != $src$$reg) {\n-      __ movptr($dst$$Register, $src$$Register);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg); \/\/ XXX\n-%}\n-\n-instruct castP2X(rRegL dst, rRegP src)\n-%{\n-  match(Set dst (CastP2X src));\n-\n-  format %{ \"movq    $dst, $src\\t# ptr -> long\" %}\n-  ins_encode %{\n-    if ($dst$$reg != $src$$reg) {\n-      __ movptr($dst$$Register, $src$$Register);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg); \/\/ XXX\n-%}\n-\n-\/\/ Convert oop into int for vectors alignment masking\n-instruct convP2I(rRegI dst, rRegP src)\n-%{\n-  match(Set dst (ConvL2I (CastP2X src)));\n-\n-  format %{ \"movl    $dst, $src\\t# ptr -> int\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg); \/\/ XXX\n-%}\n-\n-\/\/ Convert compressed oop into int for vectors alignment masking\n-\/\/ in case of 32bit oops (heap < 4Gb).\n-instruct convN2I(rRegI dst, rRegN src)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  match(Set dst (ConvL2I (CastP2X (DecodeN src))));\n-\n-  format %{ \"movl    $dst, $src\\t# compressed ptr -> int\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg); \/\/ XXX\n-%}\n-\n-\/\/ Convert oop pointer into compressed form\n-instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{\n-  predicate(n->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);\n-  match(Set dst (EncodeP src));\n-  effect(KILL cr);\n-  format %{ \"encode_heap_oop $dst,$src\" %}\n-  ins_encode %{\n-    Register s = $src$$Register;\n-    Register d = $dst$$Register;\n-    if (s != d) {\n-      __ movq(d, s);\n-    }\n-    __ encode_heap_oop(d);\n-  %}\n-  ins_pipe(ialu_reg_long);\n-%}\n-\n-instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{\n-  predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);\n-  match(Set dst (EncodeP src));\n-  effect(KILL cr);\n-  format %{ \"encode_heap_oop_not_null $dst,$src\" %}\n-  ins_encode %{\n-    __ encode_heap_oop_not_null($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_long);\n-%}\n-\n-instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{\n-  predicate(n->bottom_type()->is_ptr()->ptr() != TypePtr::NotNull &&\n-            n->bottom_type()->is_ptr()->ptr() != TypePtr::Constant);\n-  match(Set dst (DecodeN src));\n-  effect(KILL cr);\n-  format %{ \"decode_heap_oop $dst,$src\" %}\n-  ins_encode %{\n-    Register s = $src$$Register;\n-    Register d = $dst$$Register;\n-    if (s != d) {\n-      __ movq(d, s);\n-    }\n-    __ decode_heap_oop(d);\n-  %}\n-  ins_pipe(ialu_reg_long);\n-%}\n-\n-instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{\n-  predicate(n->bottom_type()->is_ptr()->ptr() == TypePtr::NotNull ||\n-            n->bottom_type()->is_ptr()->ptr() == TypePtr::Constant);\n-  match(Set dst (DecodeN src));\n-  effect(KILL cr);\n-  format %{ \"decode_heap_oop_not_null $dst,$src\" %}\n-  ins_encode %{\n-    Register s = $src$$Register;\n-    Register d = $dst$$Register;\n-    if (s != d) {\n-      __ decode_heap_oop_not_null(d, s);\n-    } else {\n-      __ decode_heap_oop_not_null(d);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_long);\n-%}\n-\n-instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{\n-  match(Set dst (EncodePKlass src));\n-  effect(TEMP dst, KILL cr);\n-  format %{ \"encode_and_move_klass_not_null $dst,$src\" %}\n-  ins_encode %{\n-    __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_long);\n-%}\n-\n-instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{\n-  match(Set dst (DecodeNKlass src));\n-  effect(TEMP dst, KILL cr);\n-  format %{ \"decode_and_move_klass_not_null $dst,$src\" %}\n-  ins_encode %{\n-    __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_long);\n-%}\n-\n-\/\/----------Conditional Move---------------------------------------------------\n-\/\/ Jump\n-\/\/ dummy instruction for generating temp registers\n-instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{\n-  match(Jump (LShiftL switch_val shift));\n-  ins_cost(350);\n-  predicate(false);\n-  effect(TEMP dest);\n-\n-  format %{ \"leaq    $dest, [$constantaddress]\\n\\t\"\n-            \"jmp     [$dest + $switch_val << $shift]\\n\\t\" %}\n-  ins_encode %{\n-    \/\/ We could use jump(ArrayAddress) except that the macro assembler needs to use r10\n-    \/\/ to do that and the compiler is using that register as one it can allocate.\n-    \/\/ So we build it all by hand.\n-    \/\/ Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);\n-    \/\/ ArrayAddress dispatch(table, index);\n-    Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);\n-    __ lea($dest$$Register, $constantaddress);\n-    __ jmp(dispatch);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{\n-  match(Jump (AddL (LShiftL switch_val shift) offset));\n-  ins_cost(350);\n-  effect(TEMP dest);\n-\n-  format %{ \"leaq    $dest, [$constantaddress]\\n\\t\"\n-            \"jmp     [$dest + $switch_val << $shift + $offset]\\n\\t\" %}\n-  ins_encode %{\n-    \/\/ We could use jump(ArrayAddress) except that the macro assembler needs to use r10\n-    \/\/ to do that and the compiler is using that register as one it can allocate.\n-    \/\/ So we build it all by hand.\n-    \/\/ Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);\n-    \/\/ ArrayAddress dispatch(table, index);\n-    Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);\n-    __ lea($dest$$Register, $constantaddress);\n-    __ jmp(dispatch);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-instruct jumpXtnd(rRegL switch_val, rRegI dest) %{\n-  match(Jump switch_val);\n-  ins_cost(350);\n-  effect(TEMP dest);\n-\n-  format %{ \"leaq    $dest, [$constantaddress]\\n\\t\"\n-            \"jmp     [$dest + $switch_val]\\n\\t\" %}\n-  ins_encode %{\n-    \/\/ We could use jump(ArrayAddress) except that the macro assembler needs to use r10\n-    \/\/ to do that and the compiler is using that register as one it can allocate.\n-    \/\/ So we build it all by hand.\n-    \/\/ Address index(noreg, switch_reg, Address::times_1);\n-    \/\/ ArrayAddress dispatch(table, index);\n-    Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);\n-    __ lea($dest$$Register, $constantaddress);\n-    __ jmp(dispatch);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovI_imm_01(rRegI dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(100); \/\/ XXX\n-  format %{ \"setbn$cop $dst\\t# signed, int\" %}\n-  ins_encode %{\n-    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n-    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovl$cop $dst, $src\\t# signed, int\" %}\n-  ins_encode %{\n-    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_reg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_imm_01U(rRegI dst, immI_1 src, rFlagsRegU cr, cmpOpU cop)\n-%{\n-  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(100); \/\/ XXX\n-  format %{ \"setbn$cop $dst\\t# unsigned, int\" %}\n-  ins_encode %{\n-    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n-    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovl$cop $dst, $src\\t# unsigned, int\" %}\n-  ins_encode %{\n-    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_regU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, rRegI src2) %{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_imm_01UCF(rRegI dst, immI_1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n-%{\n-  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(100); \/\/ XXX\n-  format %{ \"setbn$cop $dst\\t# unsigned, int\" %}\n-  ins_encode %{\n-    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n-    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n-  ins_cost(200);\n-  expand %{\n-    cmovI_regU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-instruct cmovI_regUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, rRegI src2) %{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n-  ins_cost(200);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpl  $dst, $src\\n\\t\"\n-            \"cmovnel $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n-            \"cmovnel  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n-\/\/ inputs of the CMove\n-instruct cmovI_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpl  $dst, $src\\n\\t\"\n-            \"cmovnel $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ We need this special handling for only eq \/ neq comparison since NaN == NaN is false,\n-\/\/ and parity flag bit is set if any of the operand is a NaN.\n-instruct cmovI_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src2 src1)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n-            \"cmovnel  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));\n-\n-  ins_cost(250); \/\/ XXX\n-  format %{ \"cmovl$cop $dst, $src\\t# signed, int\" %}\n-  ins_encode %{\n-    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovI_rReg_rReg_mem_ndd(rRegI dst, cmpOp cop, rFlagsReg cr, rRegI src1, memory src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n-\n-  ins_cost(250);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));\n-\n-  ins_cost(250); \/\/ XXX\n-  format %{ \"cmovl$cop $dst, $src\\t# unsigned, int\" %}\n-  ins_encode %{\n-    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));\n-  ins_cost(250);\n-  expand %{\n-    cmovI_memU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-instruct cmovI_rReg_rReg_memU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, memory src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n-\n-  ins_cost(250);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n-  ins_cost(250);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovl$cop $dst, $src\\t# signed, compressed ptr\" %}\n-  ins_encode %{\n-    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Conditional move ndd\n-instruct cmovN_reg_ndd(rRegN dst, rRegN src1, rRegN src2, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, compressed ptr ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovl$cop $dst, $src\\t# unsigned, compressed ptr\" %}\n-  ins_encode %{\n-    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n-  ins_cost(200);\n-  expand %{\n-    cmovN_regU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-\/\/ Conditional move ndd\n-instruct cmovN_regU_ndd(rRegN dst, cmpOpU cop, rFlagsRegU cr, rRegN src1, rRegN src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovN_regUCF_ndd(rRegN dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegN src1, rRegN src2) %{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n-  ins_cost(200);\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n-  ins_encode %{\n-    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovN_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpl  $dst, $src\\n\\t\"\n-            \"cmovnel $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n-\/\/ inputs of the CMove\n-instruct cmovN_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveN (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpl  $dst, $src\\n\\t\"\n-            \"cmovnel $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovl(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovq$cop $dst, $src\\t# signed, ptr\" %}\n-  ins_encode %{\n-    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);  \/\/ XXX\n-%}\n-\n-\/\/ Conditional move ndd\n-instruct cmovP_reg_ndd(rRegP dst, rRegP src1, rRegP src2, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, ptr ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Conditional move\n-instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovq$cop $dst, $src\\t# unsigned, ptr\" %}\n-  ins_encode %{\n-    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg); \/\/ XXX\n-%}\n-\n-\/\/ Conditional move ndd\n-instruct cmovP_regU_ndd(rRegP dst, cmpOpU cop, rFlagsRegU cr, rRegP src1, rRegP src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n-  ins_cost(200);\n-  expand %{\n-    cmovP_regU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-instruct cmovP_regUCF_ndd(rRegP dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegP src1, rRegP src2) %{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovP_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpq  $dst, $src\\n\\t\"\n-            \"cmovneq $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovP_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n-\/\/ inputs of the CMove\n-instruct cmovP_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpq  $dst, $src\\n\\t\"\n-            \"cmovneq $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovP_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src2 src1)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)\n-%{\n-  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(100); \/\/ XXX\n-  format %{ \"setbn$cop $dst\\t# signed, long\" %}\n-  ins_encode %{\n-    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n-    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovq$cop $dst, $src\\t# signed, long\" %}\n-  ins_encode %{\n-    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);  \/\/ XXX\n-%}\n-\n-instruct cmovL_reg_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, rRegL src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovq$cop $dst, $src\\t# signed, long\" %}\n-  ins_encode %{\n-    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);  \/\/ XXX\n-%}\n-\n-instruct cmovL_rReg_rReg_mem_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, memory src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-instruct cmovL_imm_01U(rRegL dst, immL1 src, rFlagsRegU cr, cmpOpU cop)\n-%{\n-  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(100); \/\/ XXX\n-  format %{ \"setbn$cop $dst\\t# unsigned, long\" %}\n-  ins_encode %{\n-    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n-    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovq$cop $dst, $src\\t# unsigned, long\" %}\n-  ins_encode %{\n-    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg); \/\/ XXX\n-%}\n-\n-instruct cmovL_regU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, rRegL src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovL_imm_01UCF(rRegL dst, immL1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n-%{\n-  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(100); \/\/ XXX\n-  format %{ \"setbn$cop $dst\\t# unsigned, long\" %}\n-  ins_encode %{\n-    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n-    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n-  ins_cost(200);\n-  expand %{\n-    cmovL_regU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovL_regUCF2_ne(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpq  $dst, $src\\n\\t\"\n-            \"cmovneq $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovL_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-\/\/ Since (x == y) == !(x != y), we can flip the sense of the test by flipping the\n-\/\/ inputs of the CMove\n-instruct cmovL_regUCF2_eq(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovpq  $dst, $src\\n\\t\"\n-            \"cmovneq $dst, $src\" %}\n-  ins_encode %{\n-    __ cmovq(Assembler::parity, $dst$$Register, $src$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovL_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src2 src1)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"cmovq$cop $dst, $src\\t# unsigned, long\" %}\n-  ins_encode %{\n-    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem); \/\/ XXX\n-%}\n-\n-instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{\n-  predicate(!UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));\n-  ins_cost(200);\n-  expand %{\n-    cmovL_memU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-instruct cmovL_rReg_rReg_memU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, memory src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n-\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n-  ins_cost(200);\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n-  ins_encode %{\n-    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_cmov_mem);\n-%}\n-\n-instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)\n-%{\n-  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"jn$cop    skip\\t# signed cmove float\\n\\t\"\n-            \"movss     $dst, $src\\n\"\n-    \"skip:\" %}\n-  ins_encode %{\n-    Label Lskip;\n-    \/\/ Invert sense of branch from sense of CMOV\n-    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-    __ bind(Lskip);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)\n-%{\n-  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"jn$cop    skip\\t# unsigned cmove float\\n\\t\"\n-            \"movss     $dst, $src\\n\"\n-    \"skip:\" %}\n-  ins_encode %{\n-    Label Lskip;\n-    \/\/ Invert sense of branch from sense of CMOV\n-    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n-    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n-    __ bind(Lskip);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{\n-  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));\n-  ins_cost(200);\n-  expand %{\n-    cmovF_regU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)\n-%{\n-  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"jn$cop    skip\\t# signed cmove double\\n\\t\"\n-            \"movsd     $dst, $src\\n\"\n-    \"skip:\" %}\n-  ins_encode %{\n-    Label Lskip;\n-    \/\/ Invert sense of branch from sense of CMOV\n-    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-    __ bind(Lskip);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)\n-%{\n-  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));\n-\n-  ins_cost(200); \/\/ XXX\n-  format %{ \"jn$cop    skip\\t# unsigned cmove double\\n\\t\"\n-            \"movsd     $dst, $src\\n\"\n-    \"skip:\" %}\n-  ins_encode %{\n-    Label Lskip;\n-    \/\/ Invert sense of branch from sense of CMOV\n-    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n-    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n-    __ bind(Lskip);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{\n-  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));\n-  ins_cost(200);\n-  expand %{\n-    cmovD_regU(cop, cr, dst, src);\n-  %}\n-%}\n-\n-\/\/----------Arithmetic Instructions--------------------------------------------\n-\/\/----------Addition Instructions----------------------------------------------\n-\n-instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AddI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-  format %{ \"addl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ addl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct addI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eaddl($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AddI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"addl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ addl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct addI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eaddl($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct addI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eaddl($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AddI dst (LoadI src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"addl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ addl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct addI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddI src1 (LoadI src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eaddl($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"addl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ addl($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"addl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ addl($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct incI_rReg(rRegI dst, immI_1 src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && UseIncDec);\n-  match(Set dst (AddI dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"incl    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ incrementl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct incI_rReg_ndd(rRegI dst, rRegI src, immI_1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddI src val));\n-  effect(KILL cr);\n-\n-  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eincl($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct incI_rReg_mem_ndd(rRegI dst, memory src, immI_1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddI (LoadI src) val));\n-  effect(KILL cr);\n-\n-  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eincl($dst$$Register, $src$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct incI_mem(memory dst, immI_1 src, rFlagsReg cr)\n-%{\n-  predicate(UseIncDec);\n-  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"incl    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ incrementl($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ XXX why does that use AddI\n-instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && UseIncDec);\n-  match(Set dst (AddI dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"decl    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ decrementl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct decI_rReg_ndd(rRegI dst, rRegI src, immI_M1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddI src val));\n-  effect(KILL cr);\n-\n-  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n-  ins_encode %{\n-    __ edecl($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct decI_rReg_mem_ndd(rRegI dst, memory src, immI_M1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddI (LoadI src) val));\n-  effect(KILL cr);\n-\n-  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n-  ins_encode %{\n-    __ edecl($dst$$Register, $src$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ XXX why does that use AddI\n-instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)\n-%{\n-  predicate(UseIncDec);\n-  match(Set dst (StoreI dst (AddI (LoadI dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"decl    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ decrementl($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct leaI_rReg_immI2_immI(rRegI dst, rRegI index, immI2 scale, immI disp)\n-%{\n-  predicate(VM_Version::supports_fast_2op_lea());\n-  match(Set dst (AddI (LShiftI index scale) disp));\n-\n-  format %{ \"leal $dst, [$index << $scale + $disp]\\t# int\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n-    __ leal($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaI_rReg_rReg_immI(rRegI dst, rRegI base, rRegI index, immI disp)\n-%{\n-  predicate(VM_Version::supports_fast_3op_lea());\n-  match(Set dst (AddI (AddI base index) disp));\n-\n-  format %{ \"leal $dst, [$base + $index + $disp]\\t# int\" %}\n-  ins_encode %{\n-    __ leal($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaI_rReg_rReg_immI2(rRegI dst, no_rbp_r13_RegI base, rRegI index, immI2 scale)\n-%{\n-  predicate(VM_Version::supports_fast_2op_lea());\n-  match(Set dst (AddI base (LShiftI index scale)));\n-\n-  format %{ \"leal $dst, [$base + $index << $scale]\\t# int\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n-    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaI_rReg_rReg_immI2_immI(rRegI dst, rRegI base, rRegI index, immI2 scale, immI disp)\n-%{\n-  predicate(VM_Version::supports_fast_3op_lea());\n-  match(Set dst (AddI (AddI base (LShiftI index scale)) disp));\n-\n-  format %{ \"leal $dst, [$base + $index << $scale + $disp]\\t# int\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n-    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AddL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"addq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ addq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct addL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eaddq($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AddL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"addq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ addq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct addL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eaddq($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct addL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eaddq($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AddL dst (LoadL src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"addq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ addq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct addL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddL src1 (LoadL src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eaddq($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"addq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ addq($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"addq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ addq($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct incL_rReg(rRegL dst, immL1 src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && UseIncDec);\n-  match(Set dst (AddL dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"incq    $dst\\t# long\" %}\n-  ins_encode %{\n-    __ incrementq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct incL_rReg_ndd(rRegL dst, rRegI src, immL1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddL src val));\n-  effect(KILL cr);\n-\n-  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eincq($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct incL_rReg_mem_ndd(rRegL dst, memory src, immL1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddL (LoadL src) val));\n-  effect(KILL cr);\n-\n-  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eincq($dst$$Register, $src$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)\n-%{\n-  predicate(UseIncDec);\n-  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"incq    $dst\\t# long\" %}\n-  ins_encode %{\n-    __ incrementq($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ XXX why does that use AddL\n-instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && UseIncDec);\n-  match(Set dst (AddL dst src));\n-  effect(KILL cr);\n-\n-  format %{ \"decq    $dst\\t# long\" %}\n-  ins_encode %{\n-    __ decrementq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct decL_rReg_ndd(rRegL dst, rRegL src, immL_M1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddL src val));\n-  effect(KILL cr);\n-\n-  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n-  ins_encode %{\n-    __ edecq($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct decL_rReg_mem_ndd(rRegL dst, memory src, immL_M1 val, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && UseIncDec);\n-  match(Set dst (AddL (LoadL src) val));\n-  effect(KILL cr);\n-\n-  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n-  ins_encode %{\n-    __ edecq($dst$$Register, $src$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ XXX why does that use AddL\n-instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)\n-%{\n-  predicate(UseIncDec);\n-  match(Set dst (StoreL dst (AddL (LoadL dst) src)));\n-  effect(KILL cr);\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"decq    $dst\\t# long\" %}\n-  ins_encode %{\n-    __ decrementq($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct leaL_rReg_immI2_immL32(rRegL dst, rRegL index, immI2 scale, immL32 disp)\n-%{\n-  predicate(VM_Version::supports_fast_2op_lea());\n-  match(Set dst (AddL (LShiftL index scale) disp));\n-\n-  format %{ \"leaq $dst, [$index << $scale + $disp]\\t# long\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n-    __ leaq($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaL_rReg_rReg_immL32(rRegL dst, rRegL base, rRegL index, immL32 disp)\n-%{\n-  predicate(VM_Version::supports_fast_3op_lea());\n-  match(Set dst (AddL (AddL base index) disp));\n-\n-  format %{ \"leaq $dst, [$base + $index + $disp]\\t# long\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaL_rReg_rReg_immI2(rRegL dst, no_rbp_r13_RegL base, rRegL index, immI2 scale)\n-%{\n-  predicate(VM_Version::supports_fast_2op_lea());\n-  match(Set dst (AddL base (LShiftL index scale)));\n-\n-  format %{ \"leaq $dst, [$base + $index << $scale]\\t# long\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n-    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaL_rReg_rReg_immI2_immL32(rRegL dst, rRegL base, rRegL index, immI2 scale, immL32 disp)\n-%{\n-  predicate(VM_Version::supports_fast_3op_lea());\n-  match(Set dst (AddL (AddL base (LShiftL index scale)) disp));\n-\n-  format %{ \"leaq $dst, [$base + $index << $scale + $disp]\\t# long\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n-    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)\n-%{\n-  match(Set dst (AddP dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"addq    $dst, $src\\t# ptr\" %}\n-  ins_encode %{\n-    __ addq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (AddP dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"addq    $dst, $src\\t# ptr\" %}\n-  ins_encode %{\n-    __ addq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe( ialu_reg );\n-%}\n-\n-\/\/ XXX addP mem ops ????\n-\n-instruct checkCastPP(rRegP dst)\n-%{\n-  match(Set dst (CheckCastPP dst));\n-\n-  size(0);\n-  format %{ \"# checkcastPP of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_pipe(empty);\n-%}\n-\n-instruct castPP(rRegP dst)\n-%{\n-  match(Set dst (CastPP dst));\n-\n-  size(0);\n-  format %{ \"# castPP of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_pipe(empty);\n-%}\n-\n-instruct castII(rRegI dst)\n-%{\n-  predicate(VerifyConstraintCasts == 0);\n-  match(Set dst (CastII dst));\n-\n-  size(0);\n-  format %{ \"# castII of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(empty);\n-%}\n-\n-instruct castII_checked(rRegI dst, rFlagsReg cr)\n-%{\n-  predicate(VerifyConstraintCasts > 0);\n-  match(Set dst (CastII dst));\n-\n-  effect(KILL cr);\n-  format %{ \"# cast_checked_II $dst\" %}\n-  ins_encode %{\n-    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct castLL(rRegL dst)\n-%{\n-  predicate(VerifyConstraintCasts == 0);\n-  match(Set dst (CastLL dst));\n-\n-  size(0);\n-  format %{ \"# castLL of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(empty);\n-%}\n-\n-instruct castLL_checked_L32(rRegL dst, rFlagsReg cr)\n-%{\n-  predicate(VerifyConstraintCasts > 0 && castLL_is_imm32(n));\n-  match(Set dst (CastLL dst));\n-\n-  effect(KILL cr);\n-  format %{ \"# cast_checked_LL $dst\" %}\n-  ins_encode %{\n-    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, noreg);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct castLL_checked(rRegL dst, rRegL tmp, rFlagsReg cr)\n-%{\n-  predicate(VerifyConstraintCasts > 0 && !castLL_is_imm32(n));\n-  match(Set dst (CastLL dst));\n-\n-  effect(KILL cr, TEMP tmp);\n-  format %{ \"# cast_checked_LL $dst\\tusing $tmp as TEMP\" %}\n-  ins_encode %{\n-    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct castFF(regF dst)\n-%{\n-  match(Set dst (CastFF dst));\n-\n-  size(0);\n-  format %{ \"# castFF of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(empty);\n-%}\n-\n-instruct castHH(regF dst)\n-%{\n-  match(Set dst (CastHH dst));\n-\n-  size(0);\n-  format %{ \"# castHH of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(empty);\n-%}\n-\n-instruct castDD(regD dst)\n-%{\n-  match(Set dst (CastDD dst));\n-\n-  size(0);\n-  format %{ \"# castDD of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(empty);\n-%}\n-\n-\/\/ XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them\n-instruct compareAndSwapP(rRegI res,\n-                         memory mem_ptr,\n-                         rax_RegP oldval, rRegP newval,\n-                         rFlagsReg cr)\n-%{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));\n-  match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));\n-  effect(KILL cr, KILL oldval);\n-\n-  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n-            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n-    __ setcc(Assembler::equal, $res$$Register);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndSwapL(rRegI res,\n-                         memory mem_ptr,\n-                         rax_RegL oldval, rRegL newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));\n-  match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));\n-  effect(KILL cr, KILL oldval);\n-\n-  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n-            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n-    __ setcc(Assembler::equal, $res$$Register);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndSwapI(rRegI res,\n-                         memory mem_ptr,\n-                         rax_RegI oldval, rRegI newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));\n-  match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));\n-  effect(KILL cr, KILL oldval);\n-\n-  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n-            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n-    __ setcc(Assembler::equal, $res$$Register);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndSwapB(rRegI res,\n-                         memory mem_ptr,\n-                         rax_RegI oldval, rRegI newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));\n-  effect(KILL cr, KILL oldval);\n-\n-  format %{ \"cmpxchgb $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n-            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgb($newval$$Register, $mem_ptr$$Address);\n-    __ setcc(Assembler::equal, $res$$Register);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndSwapS(rRegI res,\n-                         memory mem_ptr,\n-                         rax_RegI oldval, rRegI newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));\n-  effect(KILL cr, KILL oldval);\n-\n-  format %{ \"cmpxchgw $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n-            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgw($newval$$Register, $mem_ptr$$Address);\n-    __ setcc(Assembler::equal, $res$$Register);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndSwapN(rRegI res,\n-                          memory mem_ptr,\n-                          rax_RegN oldval, rRegN newval,\n-                          rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));\n-  match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));\n-  effect(KILL cr, KILL oldval);\n-\n-  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"\n-            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n-    __ setcc(Assembler::equal, $res$$Register);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndExchangeB(\n-                         memory mem_ptr,\n-                         rax_RegI oldval, rRegI newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));\n-  effect(KILL cr);\n-\n-  format %{ \"cmpxchgb $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgb($newval$$Register, $mem_ptr$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndExchangeS(\n-                         memory mem_ptr,\n-                         rax_RegI oldval, rRegI newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));\n-  effect(KILL cr);\n-\n-  format %{ \"cmpxchgw $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgw($newval$$Register, $mem_ptr$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndExchangeI(\n-                         memory mem_ptr,\n-                         rax_RegI oldval, rRegI newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));\n-  effect(KILL cr);\n-\n-  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndExchangeL(\n-                         memory mem_ptr,\n-                         rax_RegL oldval, rRegL newval,\n-                         rFlagsReg cr)\n-%{\n-  match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));\n-  effect(KILL cr);\n-\n-  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\"  %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndExchangeN(\n-                          memory mem_ptr,\n-                          rax_RegN oldval, rRegN newval,\n-                          rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));\n-  effect(KILL cr);\n-\n-  format %{ \"cmpxchgl $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct compareAndExchangeP(\n-                         memory mem_ptr,\n-                         rax_RegP oldval, rRegP newval,\n-                         rFlagsReg cr)\n-%{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));\n-  effect(KILL cr);\n-\n-  format %{ \"cmpxchgq $mem_ptr,$newval\\t# \"\n-            \"If rax == $mem_ptr then store $newval into $mem_ptr\\n\\t\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct xaddB_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddB mem add));\n-  effect(KILL cr);\n-  format %{ \"addb_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addb($mem$$Address, $add$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddB_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddB mem add));\n-  effect(KILL cr);\n-  format %{ \"addb_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addb($mem$$Address, $add$$constant);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddB(memory mem, rRegI newval, rFlagsReg cr) %{\n-  predicate(!n->as_LoadStore()->result_not_used());\n-  match(Set newval (GetAndAddB mem newval));\n-  effect(KILL cr);\n-  format %{ \"xaddb_lock  $mem, $newval\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ xaddb($mem$$Address, $newval$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddS_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddS mem add));\n-  effect(KILL cr);\n-  format %{ \"addw_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addw($mem$$Address, $add$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddS_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n-  predicate(UseStoreImmI16 && n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddS mem add));\n-  effect(KILL cr);\n-  format %{ \"addw_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addw($mem$$Address, $add$$constant);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddS(memory mem, rRegI newval, rFlagsReg cr) %{\n-  predicate(!n->as_LoadStore()->result_not_used());\n-  match(Set newval (GetAndAddS mem newval));\n-  effect(KILL cr);\n-  format %{ \"xaddw_lock  $mem, $newval\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ xaddw($mem$$Address, $newval$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddI_reg_no_res(memory mem, Universe dummy, rRegI add, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddI mem add));\n-  effect(KILL cr);\n-  format %{ \"addl_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addl($mem$$Address, $add$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddI_imm_no_res(memory mem, Universe dummy, immI add, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddI mem add));\n-  effect(KILL cr);\n-  format %{ \"addl_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addl($mem$$Address, $add$$constant);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddI(memory mem, rRegI newval, rFlagsReg cr) %{\n-  predicate(!n->as_LoadStore()->result_not_used());\n-  match(Set newval (GetAndAddI mem newval));\n-  effect(KILL cr);\n-  format %{ \"xaddl_lock  $mem, $newval\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ xaddl($mem$$Address, $newval$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddL_reg_no_res(memory mem, Universe dummy, rRegL add, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddL mem add));\n-  effect(KILL cr);\n-  format %{ \"addq_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addq($mem$$Address, $add$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddL_imm_no_res(memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{\n-  predicate(n->as_LoadStore()->result_not_used());\n-  match(Set dummy (GetAndAddL mem add));\n-  effect(KILL cr);\n-  format %{ \"addq_lock   $mem, $add\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ addq($mem$$Address, $add$$constant);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xaddL(memory mem, rRegL newval, rFlagsReg cr) %{\n-  predicate(!n->as_LoadStore()->result_not_used());\n-  match(Set newval (GetAndAddL mem newval));\n-  effect(KILL cr);\n-  format %{ \"xaddq_lock  $mem, $newval\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ xaddq($mem$$Address, $newval$$Register);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-instruct xchgB( memory mem, rRegI newval) %{\n-  match(Set newval (GetAndSetB mem newval));\n-  format %{ \"XCHGB  $newval,[$mem]\" %}\n-  ins_encode %{\n-    __ xchgb($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct xchgS( memory mem, rRegI newval) %{\n-  match(Set newval (GetAndSetS mem newval));\n-  format %{ \"XCHGW  $newval,[$mem]\" %}\n-  ins_encode %{\n-    __ xchgw($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct xchgI( memory mem, rRegI newval) %{\n-  match(Set newval (GetAndSetI mem newval));\n-  format %{ \"XCHGL  $newval,[$mem]\" %}\n-  ins_encode %{\n-    __ xchgl($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct xchgL( memory mem, rRegL newval) %{\n-  match(Set newval (GetAndSetL mem newval));\n-  format %{ \"XCHGL  $newval,[$mem]\" %}\n-  ins_encode %{\n-    __ xchgq($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct xchgP( memory mem, rRegP newval) %{\n-  match(Set newval (GetAndSetP mem newval));\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  format %{ \"XCHGQ  $newval,[$mem]\" %}\n-  ins_encode %{\n-    __ xchgq($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-instruct xchgN( memory mem, rRegN newval) %{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set newval (GetAndSetN mem newval));\n-  format %{ \"XCHGL  $newval,$mem]\" %}\n-  ins_encode %{\n-    __ xchgl($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-\/\/----------Abs Instructions-------------------------------------------\n-\n-\/\/ Integer Absolute Instructions\n-instruct absI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (AbsI src));\n-  effect(TEMP dst, KILL cr);\n-  format %{ \"xorl    $dst, $dst\\t# abs int\\n\\t\"\n-            \"subl    $dst, $src\\n\\t\"\n-            \"cmovll  $dst, $src\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $dst$$Register);\n-    __ subl($dst$$Register, $src$$Register);\n-    __ cmovl(Assembler::less, $dst$$Register, $src$$Register);\n-  %}\n-\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Long Absolute Instructions\n-instruct absL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  match(Set dst (AbsL src));\n-  effect(TEMP dst, KILL cr);\n-  format %{ \"xorl    $dst, $dst\\t# abs long\\n\\t\"\n-            \"subq    $dst, $src\\n\\t\"\n-            \"cmovlq  $dst, $src\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $dst$$Register);\n-    __ subq($dst$$Register, $src$$Register);\n-    __ cmovq(Assembler::less, $dst$$Register, $src$$Register);\n-  %}\n-\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/----------Subtraction Instructions-------------------------------------------\n-\n-\/\/ Integer Subtraction Instructions\n-instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (SubI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"subl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ subl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ esubl($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ esubl($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ esubl($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (SubI dst (LoadI src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"subl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ subl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct subI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubI src1 (LoadI src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ esubl($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct subI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ esubl($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (SubI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"subl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ subl($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (SubL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"subq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ subq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ esubq($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ esubq($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ esubq($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (SubL dst (LoadL src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"subq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ subq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct subL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubL src1 (LoadL src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ esubq($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct subL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ esubq($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (SubL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"subq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ subq($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Subtract from a pointer\n-\/\/ XXX hmpf???\n-instruct subP_rReg(rRegP dst, rRegI src, immI_0 zero, rFlagsReg cr)\n-%{\n-  match(Set dst (AddP dst (SubI zero src)));\n-  effect(KILL cr);\n-\n-  format %{ \"subq    $dst, $src\\t# ptr - int\" %}\n-  ins_encode %{\n-    __ subq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct negI_rReg(rRegI dst, immI_0 zero, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (SubI zero dst));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"negl    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ negl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negI_rReg_ndd(rRegI dst, rRegI src, immI_0 zero, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubI zero src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n-  ins_encode %{\n-    __ enegl($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negI_rReg_2(rRegI dst, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (NegI dst));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"negl    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ negl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negI_rReg_2_ndd(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (NegI src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n-  ins_encode %{\n-    __ enegl($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negI_mem(memory dst, immI_0 zero, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (SubI zero (LoadI dst))));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"negl    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ negl($dst$$Address);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (SubL zero dst));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"negq    $dst\\t# long\" %}\n-  ins_encode %{\n-    __ negq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negL_rReg_ndd(rRegL dst, rRegL src, immL0 zero, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (SubL zero src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n-  ins_encode %{\n-    __ enegq($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negL_rReg_2(rRegL dst, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (NegL dst));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"negq    $dst\\t# int\" %}\n-  ins_encode %{\n-    __ negq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negL_rReg_2_ndd(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (NegL src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n-  ins_encode %{\n-    __ enegq($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (SubL zero (LoadL dst))));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n-\n-  format %{ \"negq    $dst\\t# long\" %}\n-  ins_encode %{\n-    __ negq($dst$$Address);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/----------Multiplication\/Division Instructions-------------------------------\n-\/\/ Integer Multiplication Instructions\n-\/\/ Multiply Register\n-\n-instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (MulI dst src));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"imull   $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ imull($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct mulI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulI src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eimull($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)\n-%{\n-  match(Set dst (MulI src imm));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"imull   $dst, $src, $imm\\t# int\" %}\n-  ins_encode %{\n-    __ imull($dst$$Register, $src$$Register, $imm$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (MulI dst (LoadI src)));\n-  effect(KILL cr);\n-\n-  ins_cost(350);\n-  format %{ \"imull   $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ imull($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n-instruct mulI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulI src1 (LoadI src2)));\n-  effect(KILL cr);\n-\n-  ins_cost(350);\n-  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eimull($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n-instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)\n-%{\n-  match(Set dst (MulI (LoadI src) imm));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"imull   $dst, $src, $imm\\t# int\" %}\n-  ins_encode %{\n-    __ imull($dst$$Register, $src$$Address, $imm$$constant);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n-instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)\n-%{\n-  match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));\n-  effect(KILL cr, KILL src2);\n-\n-  expand %{ mulI_rReg(dst, src1, cr);\n-           mulI_rReg(src2, src3, cr);\n-           addI_rReg(dst, src2, cr); %}\n-%}\n-\n-instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (MulL dst src));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"imulq   $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ imulq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct mulL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulL src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eimulq($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)\n-%{\n-  match(Set dst (MulL src imm));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n-  ins_encode %{\n-    __ imulq($dst$$Register, $src$$Register, $imm$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (MulL dst (LoadL src)));\n-  effect(KILL cr);\n-\n-  ins_cost(350);\n-  format %{ \"imulq   $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ imulq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n-instruct mulL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulL src1 (LoadL src2)));\n-  effect(KILL cr);\n-\n-  ins_cost(350);\n-  format %{ \"eimulq   $dst, $src1, $src2 \\t# long\" %}\n-  ins_encode %{\n-    __ eimulq($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n-instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)\n-%{\n-  match(Set dst (MulL (LoadL src) imm));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n-  ins_encode %{\n-    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n-instruct mulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n-%{\n-  match(Set dst (MulHiL src rax));\n-  effect(USE_KILL rax, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"imulq   RDX:RAX, RAX, $src\\t# mulhi\" %}\n-  ins_encode %{\n-    __ imulq($src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct umulHiL_rReg(rdx_RegL dst, rRegL src, rax_RegL rax, rFlagsReg cr)\n-%{\n-  match(Set dst (UMulHiL src rax));\n-  effect(USE_KILL rax, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"mulq   RDX:RAX, RAX, $src\\t# umulhi\" %}\n-  ins_encode %{\n-    __ mulq($src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,\n-                   rFlagsReg cr)\n-%{\n-  match(Set rax (DivI rax div));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpl    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdql\\n\\t\"\n-            \"idivl   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdql_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,\n-                   rFlagsReg cr)\n-%{\n-  match(Set rax (DivL rax div));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n-            \"cmpq    rax, rdx\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpq    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdqq\\n\\t\"\n-            \"idivq   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdqq_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct udivI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div, rFlagsReg cr)\n-%{\n-  match(Set rax (UDivI rax div));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"udivl $rax,$rax,$div\\t# UDivI\\n\" %}\n-  ins_encode %{\n-    __ udivI($rax$$Register, $div$$Register, $rdx$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct udivL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div, rFlagsReg cr)\n-%{\n-  match(Set rax (UDivL rax div));\n-  effect(KILL rdx, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"udivq $rax,$rax,$div\\t# UDivL\\n\" %}\n-  ins_encode %{\n-     __ udivL($rax$$Register, $div$$Register, $rdx$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-\/\/ Integer DIVMOD with Register, both quotient and mod results\n-instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,\n-                             rFlagsReg cr)\n-%{\n-  match(DivModI rax div);\n-  effect(KILL cr);\n-\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"cmpl    rax, 0x80000000\\t# idiv\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpl    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdql\\n\\t\"\n-            \"idivl   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdql_enc(div));\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Long DIVMOD with Register, both quotient and mod results\n-instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,\n-                             rFlagsReg cr)\n-%{\n-  match(DivModL rax div);\n-  effect(KILL cr);\n-\n-  ins_cost(30*100+10*100); \/\/ XXX\n-  format %{ \"movq    rdx, 0x8000000000000000\\t# ldiv\\n\\t\"\n-            \"cmpq    rax, rdx\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpq    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdqq\\n\\t\"\n-            \"idivq   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdqq_enc(div));\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Unsigned integer DIVMOD with Register, both quotient and mod results\n-instruct udivModI_rReg_divmod(rax_RegI rax, no_rax_rdx_RegI tmp, rdx_RegI rdx,\n-                              no_rax_rdx_RegI div, rFlagsReg cr)\n-%{\n-  match(UDivModI rax div);\n-  effect(TEMP tmp, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"udivl $rax,$rax,$div\\t# begin UDivModI\\n\\t\"\n-            \"umodl $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModI\\n\"\n-          %}\n-  ins_encode %{\n-    __ udivmodI($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Unsigned long DIVMOD with Register, both quotient and mod results\n-instruct udivModL_rReg_divmod(rax_RegL rax, no_rax_rdx_RegL tmp, rdx_RegL rdx,\n-                              no_rax_rdx_RegL div, rFlagsReg cr)\n-%{\n-  match(UDivModL rax div);\n-  effect(TEMP tmp, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"udivq $rax,$rax,$div\\t# begin UDivModL\\n\\t\"\n-            \"umodq $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModL\\n\"\n-          %}\n-  ins_encode %{\n-    __ udivmodL($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,\n-                   rFlagsReg cr)\n-%{\n-  match(Set rdx (ModI rax div));\n-  effect(KILL rax, KILL cr);\n-\n-  ins_cost(300); \/\/ XXX\n-  format %{ \"cmpl    rax, 0x80000000\\t# irem\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpl    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdql\\n\\t\"\n-            \"idivl   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdql_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,\n-                   rFlagsReg cr)\n-%{\n-  match(Set rdx (ModL rax div));\n-  effect(KILL rax, KILL cr);\n-\n-  ins_cost(300); \/\/ XXX\n-  format %{ \"movq    rdx, 0x8000000000000000\\t# lrem\\n\\t\"\n-            \"cmpq    rax, rdx\\n\\t\"\n-            \"jne,s   normal\\n\\t\"\n-            \"xorl    rdx, rdx\\n\\t\"\n-            \"cmpq    $div, -1\\n\\t\"\n-            \"je,s    done\\n\"\n-    \"normal: cdqq\\n\\t\"\n-            \"idivq   $div\\n\"\n-    \"done:\"        %}\n-  ins_encode(cdqq_enc(div));\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct umodI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div, rFlagsReg cr)\n-%{\n-  match(Set rdx (UModI rax div));\n-  effect(KILL rax, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"umodl $rdx,$rax,$div\\t# UModI\\n\" %}\n-  ins_encode %{\n-    __ umodI($rax$$Register, $div$$Register, $rdx$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct umodL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div, rFlagsReg cr)\n-%{\n-  match(Set rdx (UModL rax div));\n-  effect(KILL rax, KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"umodq $rdx,$rax,$div\\t# UModL\\n\" %}\n-  ins_encode %{\n-    __ umodL($rax$$Register, $div$$Register, $rdx$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-\/\/ Integer Shift Instructions\n-\/\/ Shift Left by one, two, three\n-instruct salI_rReg_immI2(rRegI dst, immI2 shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (LShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sall($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by one, two, three\n-instruct salI_rReg_immI2_ndd(rRegI dst, rRegI src, immI2 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (LShiftI src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esall    $dst, $src, $shift\\t# int(ndd)\" %}\n-  ins_encode %{\n-    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by 8-bit immediate\n-instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (LShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sall($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by 8-bit immediate\n-instruct salI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (LShiftI src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n-  ins_encode %{\n-    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct salI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (LShiftI (LoadI src) shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n-  ins_encode %{\n-    __ esall($dst$$Register, $src$$Address, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by 8-bit immediate\n-instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sall($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Shift Left by variable\n-instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (LShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sall($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Shift Left by variable\n-instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sall    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sall($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct salI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (LShiftI src shift));\n-\n-  format %{ \"shlxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shlxl($dst$$Register, $src$$Register, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct salI_mem_rReg(rRegI dst, memory src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (LShiftI (LoadI src) shift));\n-  ins_cost(175);\n-  format %{ \"shlxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shlxl($dst$$Register, $src$$Address, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Arithmetic Shift Right by 8-bit immediate\n-instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (RShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Arithmetic Shift Right by 8-bit immediate\n-instruct sarI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (RShiftI src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n-  ins_encode %{\n-    __ esarl($dst$$Register, $src$$Register, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct sarI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (RShiftI (LoadI src) shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n-  ins_encode %{\n-    __ esarl($dst$$Register, $src$$Address, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Arithmetic Shift Right by 8-bit immediate\n-instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Arithmetic Shift Right by variable\n-instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (RShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Arithmetic Shift Right by variable\n-instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct sarI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (RShiftI src shift));\n-\n-  format %{ \"sarxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ sarxl($dst$$Register, $src$$Register, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct sarI_mem_rReg(rRegI dst, memory src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (RShiftI (LoadI src) shift));\n-  ins_cost(175);\n-  format %{ \"sarxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ sarxl($dst$$Register, $src$$Address, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Logical Shift Right by 8-bit immediate\n-instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (URShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical Shift Right by 8-bit immediate\n-instruct shrI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (URShiftI src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n-  ins_encode %{\n-    __ eshrl($dst$$Register, $src$$Register, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct shrI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (URShiftI (LoadI src) shift));\n-  effect(KILL cr);\n-\n-  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n-  ins_encode %{\n-    __ eshrl($dst$$Register, $src$$Address, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical Shift Right by 8-bit immediate\n-instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Logical Shift Right by variable\n-instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (URShiftI dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Logical Shift Right by variable\n-instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrl($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct shrI_rReg_rReg(rRegI dst, rRegI src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (URShiftI src shift));\n-\n-  format %{ \"shrxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shrxl($dst$$Register, $src$$Register, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct shrI_mem_rReg(rRegI dst, memory src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (URShiftI (LoadI src) shift));\n-  ins_cost(175);\n-  format %{ \"shrxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shrxl($dst$$Register, $src$$Address, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Long Shift Instructions\n-\/\/ Shift Left by one, two, three\n-instruct salL_rReg_immI2(rRegL dst, immI2 shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (LShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by one, two, three\n-instruct salL_rReg_immI2_ndd(rRegL dst, rRegL src, immI2 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (LShiftL src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n-  ins_encode %{\n-    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by 8-bit immediate\n-instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (LShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by 8-bit immediate\n-instruct salL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (LShiftL src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n-  ins_encode %{\n-    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct salL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (LShiftL (LoadL src) shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n-  ins_encode %{\n-    __ esalq($dst$$Register, $src$$Address, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Shift Left by 8-bit immediate\n-instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Shift Left by variable\n-instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (LShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Shift Left by variable\n-instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"salq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ salq($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct salL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (LShiftL src shift));\n-\n-  format %{ \"shlxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shlxq($dst$$Register, $src$$Register, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct salL_mem_rReg(rRegL dst, memory src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (LShiftL (LoadL src) shift));\n-  ins_cost(175);\n-  format %{ \"shlxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shlxq($dst$$Register, $src$$Address, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Arithmetic Shift Right by 8-bit immediate\n-instruct sarL_rReg_imm(rRegL dst, immI shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (RShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register, (unsigned char)($shift$$constant & 0x3F));\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Arithmetic Shift Right by 8-bit immediate\n-instruct sarL_rReg_imm_ndd(rRegL dst, rRegL src, immI shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (RShiftL src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n-  ins_encode %{\n-    __ esarq($dst$$Register, $src$$Register, (unsigned char)($shift$$constant & 0x3F), false);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct sarL_rReg_mem_imm_ndd(rRegL dst, memory src, immI shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (RShiftL (LoadL src) shift));\n-  effect(KILL cr);\n-\n-  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n-  ins_encode %{\n-    __ esarq($dst$$Register, $src$$Address, (unsigned char)($shift$$constant & 0x3F), false);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Arithmetic Shift Right by 8-bit immediate\n-instruct sarL_mem_imm(memory dst, immI shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Address, (unsigned char)($shift$$constant & 0x3F));\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Arithmetic Shift Right by variable\n-instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (RShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Arithmetic Shift Right by variable\n-instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"sarq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ sarq($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct sarL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (RShiftL src shift));\n-\n-  format %{ \"sarxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ sarxq($dst$$Register, $src$$Register, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct sarL_mem_rReg(rRegL dst, memory src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (RShiftL (LoadL src) shift));\n-  ins_cost(175);\n-  format %{ \"sarxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ sarxq($dst$$Register, $src$$Address, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Logical Shift Right by 8-bit immediate\n-instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (URShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical Shift Right by 8-bit immediate\n-instruct shrL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (URShiftL src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n-  ins_encode %{\n-    __ eshrq($dst$$Register, $src$$Register, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct shrL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (URShiftL (LoadL src) shift));\n-  effect(KILL cr);\n-\n-  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n-  ins_encode %{\n-    __ eshrq($dst$$Register, $src$$Address, $shift$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Logical Shift Right by 8-bit immediate\n-instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Logical Shift Right by variable\n-instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (URShiftL dst shift));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Logical Shift Right by variable\n-instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2());\n-  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));\n-  effect(KILL cr);\n-\n-  format %{ \"shrq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ shrq($dst$$Address);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct shrL_rReg_rReg(rRegL dst, rRegL src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (URShiftL src shift));\n-\n-  format %{ \"shrxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shrxq($dst$$Register, $src$$Register, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct shrL_mem_rReg(rRegL dst, memory src, rRegI shift)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  match(Set dst (URShiftL (LoadL src) shift));\n-  ins_cost(175);\n-  format %{ \"shrxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ shrxq($dst$$Register, $src$$Address, $shift$$Register);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.\n-\/\/ This idiom is used by the compiler for the i2b bytecode.\n-instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)\n-%{\n-  match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));\n-\n-  format %{ \"movsbl  $dst, $src\\t# i2b\" %}\n-  ins_encode %{\n-    __ movsbl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.\n-\/\/ This idiom is used by the compiler the i2s bytecode.\n-instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)\n-%{\n-  match(Set dst (RShiftI (LShiftI src sixteen) sixteen));\n-\n-  format %{ \"movswl  $dst, $src\\t# i2s\" %}\n-  ins_encode %{\n-    __ movswl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ ROL\/ROR instructions\n-\n-\/\/ Rotate left by constant.\n-instruct rolI_immI8_legacy(rRegI dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateLeft dst shift));\n-  effect(KILL cr);\n-  format %{ \"roll    $dst, $shift\" %}\n-  ins_encode %{\n-    __ roll($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rolI_immI8(rRegI dst, rRegI src, immI8 shift)\n-%{\n-  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateLeft src shift));\n-  format %{ \"rolxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    int shift = 32 - ($shift$$constant & 31);\n-    __ rorxl($dst$$Register, $src$$Register, shift);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct rolI_mem_immI8(rRegI dst, memory src, immI8 shift)\n-%{\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateLeft (LoadI src) shift));\n-  ins_cost(175);\n-  format %{ \"rolxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    int shift = 32 - ($shift$$constant & 31);\n-    __ rorxl($dst$$Register, $src$$Address, shift);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Rotate Left by variable\n-instruct rolI_rReg_Var(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateLeft dst shift));\n-  effect(KILL cr);\n-  format %{ \"roll    $dst, $shift\" %}\n-  ins_encode %{\n-    __ roll($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Rotate Left by variable\n-instruct rolI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateLeft src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"eroll    $dst, $src, $shift\\t# rotate left (int ndd)\" %}\n-  ins_encode %{\n-    __ eroll($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Rotate Right by constant.\n-instruct rorI_immI8_legacy(rRegI dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateRight dst shift));\n-  effect(KILL cr);\n-  format %{ \"rorl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ rorl($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Rotate Right by constant.\n-instruct rorI_immI8(rRegI dst, rRegI src, immI8 shift)\n-%{\n-  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateRight src shift));\n-  format %{ \"rorxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ rorxl($dst$$Register, $src$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct rorI_mem_immI8(rRegI dst, memory src, immI8 shift)\n-%{\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateRight (LoadI src) shift));\n-  ins_cost(175);\n-  format %{ \"rorxl   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ rorxl($dst$$Register, $src$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Rotate Right by variable\n-instruct rorI_rReg_Var(rRegI dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateRight dst shift));\n-  effect(KILL cr);\n-  format %{ \"rorl    $dst, $shift\" %}\n-  ins_encode %{\n-    __ rorl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Rotate Right by variable\n-instruct rorI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n-  match(Set dst (RotateRight src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"erorl    $dst, $src, $shift\\t# rotate right(int ndd)\" %}\n-  ins_encode %{\n-    __ erorl($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Rotate Left by constant.\n-instruct rolL_immI8_legacy(rRegL dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateLeft dst shift));\n-  effect(KILL cr);\n-  format %{ \"rolq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ rolq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct rolL_immI8(rRegL dst, rRegL src, immI8 shift)\n-%{\n-  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateLeft src shift));\n-  format %{ \"rolxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    int shift = 64 - ($shift$$constant & 63);\n-    __ rorxq($dst$$Register, $src$$Register, shift);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct rolL_mem_immI8(rRegL dst, memory src, immI8 shift)\n-%{\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateLeft (LoadL src) shift));\n-  ins_cost(175);\n-  format %{ \"rolxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    int shift = 64 - ($shift$$constant & 63);\n-    __ rorxq($dst$$Register, $src$$Address, shift);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Rotate Left by variable\n-instruct rolL_rReg_Var(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateLeft dst shift));\n-  effect(KILL cr);\n-  format %{ \"rolq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ rolq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Rotate Left by variable\n-instruct rolL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateLeft src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"erolq    $dst, $src, $shift\\t# rotate left(long ndd)\" %}\n-  ins_encode %{\n-    __ erolq($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Rotate Right by constant.\n-instruct rorL_immI8_legacy(rRegL dst, immI8 shift, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateRight dst shift));\n-  effect(KILL cr);\n-  format %{ \"rorq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ rorq($dst$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Rotate Right by constant\n-instruct rorL_immI8(rRegL dst, rRegL src, immI8 shift)\n-%{\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateRight src shift));\n-  format %{ \"rorxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ rorxq($dst$$Register, $src$$Register, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct rorL_mem_immI8(rRegL dst, memory src, immI8 shift)\n-%{\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateRight (LoadL src) shift));\n-  ins_cost(175);\n-  format %{ \"rorxq   $dst, $src, $shift\" %}\n-  ins_encode %{\n-    __ rorxq($dst$$Register, $src$$Address, $shift$$constant);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Rotate Right by variable\n-instruct rorL_rReg_Var(rRegL dst, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateRight dst shift));\n-  effect(KILL cr);\n-  format %{ \"rorq    $dst, $shift\" %}\n-  ins_encode %{\n-    __ rorq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Rotate Right by variable\n-instruct rorL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n-%{\n-  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n-  match(Set dst (RotateRight src shift));\n-  effect(KILL cr);\n-\n-  format %{ \"erorq    $dst, $src, $shift\\t# rotate right(long ndd)\" %}\n-  ins_encode %{\n-    __ erorq($dst$$Register, $src$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/----------------------------- CompressBits\/ExpandBits ------------------------\n-\n-instruct compressBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (CompressBits src mask));\n-  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n-  ins_encode %{\n-    __ pextq($dst$$Register, $src$$Register, $mask$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct expandBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (ExpandBits src mask));\n-  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n-  ins_encode %{\n-    __ pdepq($dst$$Register, $src$$Register, $mask$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct compressBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (CompressBits src (LoadL mask)));\n-  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n-  ins_encode %{\n-    __ pextq($dst$$Register, $src$$Register, $mask$$Address);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct expandBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n-  predicate(n->bottom_type()->isa_long());\n-  match(Set dst (ExpandBits src (LoadL mask)));\n-  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n-  ins_encode %{\n-    __ pdepq($dst$$Register, $src$$Register, $mask$$Address);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-\/\/ Logical Instructions\n-\n-\/\/ Integer Logical Instructions\n-\n-\/\/ And Instructions\n-\/\/ And Register with Register\n-instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AndI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"andl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ andl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ And Register with Register using New Data Destination (NDD)\n-instruct andI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eandl     $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eandl($dst$$Register, $src1$$Register, $src2$$Register, false);\n-\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ And Register with Immediate 255\n-instruct andI_rReg_imm255(rRegI dst, rRegI src, immI_255 mask)\n-%{\n-  match(Set dst (AndI src mask));\n-\n-  format %{ \"movzbl  $dst, $src\\t# int & 0xFF\" %}\n-  ins_encode %{\n-    __ movzbl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ And Register with Immediate 255 and promote to long\n-instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)\n-%{\n-  match(Set dst (ConvI2L (AndI src mask)));\n-\n-  format %{ \"movzbl  $dst, $src\\t# int & 0xFF -> long\" %}\n-  ins_encode %{\n-    __ movzbl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ And Register with Immediate 65535\n-instruct andI_rReg_imm65535(rRegI dst, rRegI src, immI_65535 mask)\n-%{\n-  match(Set dst (AndI src mask));\n-\n-  format %{ \"movzwl  $dst, $src\\t# int & 0xFFFF\" %}\n-  ins_encode %{\n-    __ movzwl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ And Register with Immediate 65535 and promote to long\n-instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)\n-%{\n-  match(Set dst (ConvI2L (AndI src mask)));\n-\n-  format %{ \"movzwl  $dst, $src\\t# int & 0xFFFF -> long\" %}\n-  ins_encode %{\n-    __ movzwl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Can skip int2long conversions after AND with small bitmask\n-instruct convI2LAndI_reg_immIbitmask(rRegL dst, rRegI src,  immI_Pow2M1 mask, rRegI tmp, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_bmi2());\n-  ins_cost(125);\n-  effect(TEMP tmp, KILL cr);\n-  match(Set dst (ConvI2L (AndI src mask)));\n-  format %{ \"bzhiq $dst, $src, $mask \\t# using $tmp as TEMP, int &  immI_Pow2M1 -> long\" %}\n-  ins_encode %{\n-    __ movl($tmp$$Register, exact_log2($mask$$constant + 1));\n-    __ bzhiq($dst$$Register, $src$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ And Register with Immediate\n-instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AndI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"andl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ andl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct andI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eandl($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct andI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eandl($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ And Register with Memory\n-instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AndI dst (LoadI src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"andl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ andl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct andI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndI src1 (LoadI src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eandl($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ And Memory with Register\n-instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreB dst (AndI (LoadB dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"andb    $dst, $src\\t# byte\" %}\n-  ins_encode %{\n-    __ andb($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (AndI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"andl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ andl($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ And Memory with Immediate\n-instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (AndI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"andl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ andl($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ BMI1 instructions\n-instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{\n-  match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"andnl  $dst, $src1, $src2\" %}\n-\n-  ins_encode %{\n-    __ andnl($dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{\n-  match(Set dst (AndI (XorI src1 minus_1) src2));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"andnl  $dst, $src1, $src2\" %}\n-\n-  ins_encode %{\n-    __ andnl($dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI_0 imm_zero, rFlagsReg cr) %{\n-  match(Set dst (AndI (SubI imm_zero src) src));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  format %{ \"blsil  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsil($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct blsiI_rReg_mem(rRegI dst, memory src, immI_0 imm_zero, rFlagsReg cr) %{\n-  match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  ins_cost(125);\n-  format %{ \"blsil  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsil($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  ins_cost(125);\n-  format %{ \"blsmskl $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsmskl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (XorI (AddI src minus_1) src));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  format %{ \"blsmskl $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsmskl($dst$$Register, $src$$Register);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (AndI (AddI src minus_1) src) );\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  format %{ \"blsrl  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsrl($dst$$Register, $src$$Register);\n-  %}\n-\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  ins_cost(125);\n-  format %{ \"blsrl  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsrl($dst$$Register, $src$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Or Instructions\n-\/\/ Or Register with Register\n-instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (OrI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"orl     $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ orl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Or Register with Register using New Data Destination (NDD)\n-instruct orI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Or Register with Immediate\n-instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (OrI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"orl     $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ orl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct orI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct orI_rReg_imm_rReg_ndd(rRegI dst, immI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorl     $dst, $src2, $src1\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eorl($dst$$Register, $src2$$Register, $src1$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct orI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Or Register with Memory\n-instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (OrI dst (LoadI src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"orl     $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ orl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct orI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrI src1 (LoadI src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Or Memory with Register\n-instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreB dst (OrI (LoadB dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"orb    $dst, $src\\t# byte\" %}\n-  ins_encode %{\n-    __ orb($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (OrI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"orl     $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ orl($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Or Memory with Immediate\n-instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (OrI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"orl     $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ orl($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Xor Instructions\n-\/\/ Xor Register with Register\n-instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (XorI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"xorl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Xor Register with Register using New Data Destination (NDD)\n-instruct xorI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ exorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Xor Register with Immediate -1\n-instruct xorI_rReg_im1(rRegI dst, immI_M1 imm)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (XorI dst imm));\n-\n-  format %{ \"notl    $dst\" %}\n-  ins_encode %{\n-     __ notl($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct xorI_rReg_im1_ndd(rRegI dst, rRegI src, immI_M1 imm)\n-%{\n-  match(Set dst (XorI src imm));\n-  predicate(UseAPX);\n-\n-  format %{ \"enotl    $dst, $src\" %}\n-  ins_encode %{\n-     __ enotl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Xor Register with Immediate\n-instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)\n-%{\n-  \/\/ Strict predicate check to make selection of xorI_rReg_im1 cost agnostic if immI src is -1.\n-  predicate(!UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n-  match(Set dst (XorI dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"xorl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct xorI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  \/\/ Strict predicate check to make selection of xorI_rReg_im1_ndd cost agnostic if immI src2 is -1.\n-  predicate(UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n-  match(Set dst (XorI src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ exorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Xor Memory with Immediate\n-instruct xorI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorI (LoadI src1) src2));\n-  effect(KILL cr);\n-  ins_cost(150);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ exorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Xor Register with Memory\n-instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (XorI dst (LoadI src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"xorl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct xorI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorI src1 (LoadI src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ exorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Xor Memory with Register\n-instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreB dst (XorI (LoadB dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"xorb    $dst, $src\\t# byte\" %}\n-  ins_encode %{\n-    __ xorb($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (XorI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"xorl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Xor Memory with Immediate\n-instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreI dst (XorI (LoadI dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"xorl    $dst, $src\\t# int\" %}\n-  ins_encode %{\n-    __ xorl($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\n-\/\/ Long Logical Instructions\n-\n-\/\/ And Instructions\n-\/\/ And Register with Register\n-instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AndL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"andq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ andq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ And Register with Register using New Data Destination (NDD)\n-instruct andL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eandq     $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eandq($dst$$Register, $src1$$Register, $src2$$Register, false);\n-\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ And Register with Immediate 255\n-instruct andL_rReg_imm255(rRegL dst, rRegL src, immL_255 mask)\n-%{\n-  match(Set dst (AndL src mask));\n-\n-  format %{ \"movzbl  $dst, $src\\t# long & 0xFF\" %}\n-  ins_encode %{\n-    \/\/ movzbl zeroes out the upper 32-bit and does not need REX.W\n-    __ movzbl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ And Register with Immediate 65535\n-instruct andL_rReg_imm65535(rRegL dst, rRegL src, immL_65535 mask)\n-%{\n-  match(Set dst (AndL src mask));\n-\n-  format %{ \"movzwl  $dst, $src\\t# long & 0xFFFF\" %}\n-  ins_encode %{\n-    \/\/ movzwl zeroes out the upper 32-bit and does not need REX.W\n-    __ movzwl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ And Register with Immediate\n-instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AndL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"andq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ andq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct andL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eandq($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct andL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eandq($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ And Register with Memory\n-instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (AndL dst (LoadL src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"andq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ andq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct andL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndL src1 (LoadL src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eandq($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ And Memory with Register\n-instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (AndL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"andq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ andq($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ And Memory with Immediate\n-instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (AndL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"andq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ andq($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)\n-%{\n-  \/\/ con should be a pure 64-bit immediate given that not(con) is a power of 2\n-  \/\/ because AND\/OR works well enough for 8\/32-bit values.\n-  predicate(log2i_graceful(~n->in(3)->in(2)->get_long()) > 30);\n-\n-  match(Set dst (StoreL dst (AndL (LoadL dst) con)));\n-  effect(KILL cr);\n-\n-  ins_cost(125);\n-  format %{ \"btrq    $dst, log2(not($con))\\t# long\" %}\n-  ins_encode %{\n-    __ btrq($dst$$Address, log2i_exact((julong)~$con$$constant));\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ BMI1 instructions\n-instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{\n-  match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"andnq  $dst, $src1, $src2\" %}\n-\n-  ins_encode %{\n-    __ andnq($dst$$Register, $src1$$Register, $src2$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{\n-  match(Set dst (AndL (XorL src1 minus_1) src2));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"andnq  $dst, $src1, $src2\" %}\n-\n-  ins_encode %{\n-  __ andnq($dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{\n-  match(Set dst (AndL (SubL imm_zero src) src));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  format %{ \"blsiq  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsiq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{\n-  match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  ins_cost(125);\n-  format %{ \"blsiq  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsiq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  ins_cost(125);\n-  format %{ \"blsmskq $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsmskq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (XorL (AddL src minus_1) src));\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  format %{ \"blsmskq $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsmskq($dst$$Register, $src$$Register);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (AndL (AddL src minus_1) src) );\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  format %{ \"blsrq  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsrq($dst$$Register, $src$$Register);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)\n-%{\n-  match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );\n-  predicate(UseBMI1Instructions);\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n-\n-  ins_cost(125);\n-  format %{ \"blsrq  $dst, $src\" %}\n-\n-  ins_encode %{\n-    __ blsrq($dst$$Register, $src$$Address);\n-  %}\n-\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Or Instructions\n-\/\/ Or Register with Register\n-instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (OrL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"orq     $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ orq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Or Register with Register using New Data Destination (NDD)\n-instruct orL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n-\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Use any_RegP to match R15 (TLS register) without spilling.\n-instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{\n-  match(Set dst (OrL dst (CastP2X src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"orq     $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ orq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct orL_rReg_castP2X_ndd(rRegL dst, any_RegP src1, any_RegP src2, rFlagsReg cr) %{\n-  match(Set dst (OrL src1 (CastP2X src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Or Register with Immediate\n-instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (OrL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"orq     $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ orq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct orL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct orL_rReg_imm_rReg_ndd(rRegL dst, immL32 src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorq     $dst, $src2, $src1\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eorq($dst$$Register, $src2$$Register, $src1$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Or Memory with Immediate\n-instruct orL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Or Register with Memory\n-instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (OrL dst (LoadL src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"orq     $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ orq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct orL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (OrL src1 (LoadL src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Or Memory with Register\n-instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (OrL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"orq     $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ orq($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Or Memory with Immediate\n-instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (OrL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"orq     $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ orq($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)\n-%{\n-  \/\/ con should be a pure 64-bit power of 2 immediate\n-  \/\/ because AND\/OR works well enough for 8\/32-bit values.\n-  predicate(log2i_graceful(n->in(3)->in(2)->get_long()) > 31);\n-\n-  match(Set dst (StoreL dst (OrL (LoadL dst) con)));\n-  effect(KILL cr);\n-\n-  ins_cost(125);\n-  format %{ \"btsq    $dst, log2($con)\\t# long\" %}\n-  ins_encode %{\n-    __ btsq($dst$$Address, log2i_exact((julong)$con$$constant));\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-\/\/ Xor Instructions\n-\/\/ Xor Register with Register\n-instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (XorL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"xorq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ xorq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Xor Register with Register using New Data Destination (NDD)\n-instruct xorL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ exorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Xor Register with Immediate -1\n-instruct xorL_rReg_im1(rRegL dst, immL_M1 imm)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (XorL dst imm));\n-\n-  format %{ \"notq   $dst\" %}\n-  ins_encode %{\n-     __ notq($dst$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct xorL_rReg_im1_ndd(rRegL dst,rRegL src, immL_M1 imm)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorL src imm));\n-\n-  format %{ \"enotq   $dst, $src\" %}\n-  ins_encode %{\n-    __ enotq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Xor Register with Immediate\n-instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)\n-%{\n-  \/\/ Strict predicate check to make selection of xorL_rReg_im1 cost agnostic if immL32 src is -1.\n-  predicate(!UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n-  match(Set dst (XorL dst src));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"xorq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ xorq($dst$$Register, $src$$constant);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-instruct xorL_rReg_rReg_imm(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n-%{\n-  \/\/ Strict predicate check to make selection of xorL_rReg_im1_ndd cost agnostic if immL32 src2 is -1.\n-  predicate(UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n-  match(Set dst (XorL src1 src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ exorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Xor Memory with Immediate\n-instruct xorL_rReg_mem_imm(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-  ins_cost(150);\n-\n-  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ exorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/\/ Xor Register with Memory\n-instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (XorL dst (LoadL src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"xorq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ xorq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct xorL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorL src1 (LoadL src2)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ exorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-\/\/ Xor Memory with Register\n-instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (XorL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"xorq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ xorq($dst$$Address, $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-\/\/ Xor Memory with Immediate\n-instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)\n-%{\n-  match(Set dst (StoreL dst (XorL (LoadL dst) src)));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(125);\n-  format %{ \"xorq    $dst, $src\\t# long\" %}\n-  ins_encode %{\n-    __ xorq($dst$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n-instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)\n-%{\n-  match(Set dst (CmpLTMask p q));\n-  effect(KILL cr);\n-\n-  ins_cost(400);\n-  format %{ \"cmpl    $p, $q\\t# cmpLTMask\\n\\t\"\n-            \"setcc   $dst \\t# emits setlt + movzbl or setzul for APX\"\n-            \"negl    $dst\" %}\n-  ins_encode %{\n-    __ cmpl($p$$Register, $q$$Register);\n-    __ setcc(Assembler::less, $dst$$Register);\n-    __ negl($dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpLTMask0(rRegI dst, immI_0 zero, rFlagsReg cr)\n-%{\n-  match(Set dst (CmpLTMask dst zero));\n-  effect(KILL cr);\n-\n-  ins_cost(100);\n-  format %{ \"sarl    $dst, #31\\t# cmpLTMask0\" %}\n-  ins_encode %{\n-    __ sarl($dst$$Register, 31);\n-  %}\n-  ins_pipe(ialu_reg);\n-%}\n-\n-\/* Better to save a register than avoid a branch *\/\n-instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)\n-%{\n-  match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));\n-  effect(KILL cr);\n-  ins_cost(300);\n-  format %{ \"subl    $p,$q\\t# cadd_cmpLTMask\\n\\t\"\n-            \"jge     done\\n\\t\"\n-            \"addl    $p,$y\\n\"\n-            \"done:   \" %}\n-  ins_encode %{\n-    Register Rp = $p$$Register;\n-    Register Rq = $q$$Register;\n-    Register Ry = $y$$Register;\n-    Label done;\n-    __ subl(Rp, Rq);\n-    __ jccb(Assembler::greaterEqual, done);\n-    __ addl(Rp, Ry);\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_cmplt);\n-%}\n-\n-\/* Better to save a register than avoid a branch *\/\n-instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)\n-%{\n-  match(Set y (AndI (CmpLTMask p q) y));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-\n-  format %{ \"cmpl    $p, $q\\t# and_cmpLTMask\\n\\t\"\n-            \"jlt     done\\n\\t\"\n-            \"xorl    $y, $y\\n\"\n-            \"done:   \" %}\n-  ins_encode %{\n-    Register Rp = $p$$Register;\n-    Register Rq = $q$$Register;\n-    Register Ry = $y$$Register;\n-    Label done;\n-    __ cmpl(Rp, Rq);\n-    __ jccb(Assembler::less, done);\n-    __ xorl(Ry, Ry);\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_cmplt);\n-%}\n-\n-\n-\/\/---------- FP Instructions------------------------------------------------\n-\n-\/\/ Really expensive, avoid\n-instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)\n-%{\n-  match(Set cr (CmpF src1 src2));\n-\n-  ins_cost(500);\n-  format %{ \"ucomiss $src1, $src2\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);\n-    emit_cmpfp_fixup(masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{\n-  match(Set cr (CmpF src1 src2));\n-\n-  ins_cost(100);\n-  format %{ \"ucomiss $src1, $src2\" %}\n-  ins_encode %{\n-    __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{\n-  match(Set cr (CmpF src1 (LoadF src2)));\n-\n-  ins_cost(100);\n-  format %{ \"ucomiss $src1, $src2\" %}\n-  ins_encode %{\n-    __ ucomiss($src1$$XMMRegister, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{\n-  match(Set cr (CmpF src con));\n-  ins_cost(100);\n-  format %{ \"ucomiss $src, [$constantaddress]\\t# load from constant table: float=$con\" %}\n-  ins_encode %{\n-    __ ucomiss($src$$XMMRegister, $constantaddress($con));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Really expensive, avoid\n-instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)\n-%{\n-  match(Set cr (CmpD src1 src2));\n-\n-  ins_cost(500);\n-  format %{ \"ucomisd $src1, $src2\\n\\t\"\n-            \"jnp,s   exit\\n\\t\"\n-            \"pushfq\\t# saw NaN, set CF\\n\\t\"\n-            \"andq    [rsp], #0xffffff2b\\n\\t\"\n-            \"popfq\\n\"\n-    \"exit:\" %}\n-  ins_encode %{\n-    __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);\n-    emit_cmpfp_fixup(masm);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{\n-  match(Set cr (CmpD src1 src2));\n-\n-  ins_cost(100);\n-  format %{ \"ucomisd $src1, $src2 test\" %}\n-  ins_encode %{\n-    __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{\n-  match(Set cr (CmpD src1 (LoadD src2)));\n-\n-  ins_cost(100);\n-  format %{ \"ucomisd $src1, $src2\" %}\n-  ins_encode %{\n-    __ ucomisd($src1$$XMMRegister, $src2$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{\n-  match(Set cr (CmpD src con));\n-  ins_cost(100);\n-  format %{ \"ucomisd $src, [$constantaddress]\\t# load from constant table: double=$con\" %}\n-  ins_encode %{\n-    __ ucomisd($src$$XMMRegister, $constantaddress($con));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Compare into -1,0,1\n-instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)\n-%{\n-  match(Set dst (CmpF3 src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(275);\n-  format %{ \"ucomiss $src1, $src2\\n\\t\"\n-            \"movl    $dst, #-1\\n\\t\"\n-            \"jp,s    done\\n\\t\"\n-            \"jb,s    done\\n\\t\"\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\"\n-    \"done:\" %}\n-  ins_encode %{\n-    __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);\n-    emit_cmpfp3(masm, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Compare into -1,0,1\n-instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)\n-%{\n-  match(Set dst (CmpF3 src1 (LoadF src2)));\n-  effect(KILL cr);\n-\n-  ins_cost(275);\n-  format %{ \"ucomiss $src1, $src2\\n\\t\"\n-            \"movl    $dst, #-1\\n\\t\"\n-            \"jp,s    done\\n\\t\"\n-            \"jb,s    done\\n\\t\"\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\"\n-    \"done:\" %}\n-  ins_encode %{\n-    __ ucomiss($src1$$XMMRegister, $src2$$Address);\n-    emit_cmpfp3(masm, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Compare into -1,0,1\n-instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{\n-  match(Set dst (CmpF3 src con));\n-  effect(KILL cr);\n-\n-  ins_cost(275);\n-  format %{ \"ucomiss $src, [$constantaddress]\\t# load from constant table: float=$con\\n\\t\"\n-            \"movl    $dst, #-1\\n\\t\"\n-            \"jp,s    done\\n\\t\"\n-            \"jb,s    done\\n\\t\"\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\"\n-    \"done:\" %}\n-  ins_encode %{\n-    __ ucomiss($src$$XMMRegister, $constantaddress($con));\n-    emit_cmpfp3(masm, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Compare into -1,0,1\n-instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)\n-%{\n-  match(Set dst (CmpD3 src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(275);\n-  format %{ \"ucomisd $src1, $src2\\n\\t\"\n-            \"movl    $dst, #-1\\n\\t\"\n-            \"jp,s    done\\n\\t\"\n-            \"jb,s    done\\n\\t\"\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\"\n-    \"done:\" %}\n-  ins_encode %{\n-    __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);\n-    emit_cmpfp3(masm, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Compare into -1,0,1\n-instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)\n-%{\n-  match(Set dst (CmpD3 src1 (LoadD src2)));\n-  effect(KILL cr);\n-\n-  ins_cost(275);\n-  format %{ \"ucomisd $src1, $src2\\n\\t\"\n-            \"movl    $dst, #-1\\n\\t\"\n-            \"jp,s    done\\n\\t\"\n-            \"jb,s    done\\n\\t\"\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\"\n-    \"done:\" %}\n-  ins_encode %{\n-    __ ucomisd($src1$$XMMRegister, $src2$$Address);\n-    emit_cmpfp3(masm, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Compare into -1,0,1\n-instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{\n-  match(Set dst (CmpD3 src con));\n-  effect(KILL cr);\n-\n-  ins_cost(275);\n-  format %{ \"ucomisd $src, [$constantaddress]\\t# load from constant table: double=$con\\n\\t\"\n-            \"movl    $dst, #-1\\n\\t\"\n-            \"jp,s    done\\n\\t\"\n-            \"jb,s    done\\n\\t\"\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\"\n-    \"done:\" %}\n-  ins_encode %{\n-    __ ucomisd($src$$XMMRegister, $constantaddress($con));\n-    emit_cmpfp3(masm, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/----------Arithmetic Conversion Instructions---------------------------------\n-\n-instruct convF2D_reg_reg(regD dst, regF src)\n-%{\n-  match(Set dst (ConvF2D src));\n-\n-  format %{ \"cvtss2sd $dst, $src\" %}\n-  ins_encode %{\n-    __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convF2D_reg_mem(regD dst, memory src)\n-%{\n-  predicate(UseAVX == 0);\n-  match(Set dst (ConvF2D (LoadF src)));\n-\n-  format %{ \"cvtss2sd $dst, $src\" %}\n-  ins_encode %{\n-    __ cvtss2sd ($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convD2F_reg_reg(regF dst, regD src)\n-%{\n-  match(Set dst (ConvD2F src));\n-\n-  format %{ \"cvtsd2ss $dst, $src\" %}\n-  ins_encode %{\n-    __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convD2F_reg_mem(regF dst, memory src)\n-%{\n-  predicate(UseAVX == 0);\n-  match(Set dst (ConvD2F (LoadD src)));\n-\n-  format %{ \"cvtsd2ss $dst, $src\" %}\n-  ins_encode %{\n-    __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-\/\/ XXX do mem variants\n-instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx10_2());\n-  match(Set dst (ConvF2I src));\n-  effect(KILL cr);\n-  format %{ \"convert_f2i $dst, $src\" %}\n-  ins_encode %{\n-    __ convertF2I(T_INT, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convF2I_reg_reg_avx10(rRegI dst, regF src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvF2I src));\n-  format %{ \"evcvttss2sisl $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttss2sisl($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convF2I_reg_mem_avx10(rRegI dst, memory src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvF2I (LoadF src)));\n-  format %{ \"evcvttss2sisl $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttss2sisl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx10_2());\n-  match(Set dst (ConvF2L src));\n-  effect(KILL cr);\n-  format %{ \"convert_f2l $dst, $src\"%}\n-  ins_encode %{\n-    __ convertF2I(T_LONG, T_FLOAT, $dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convF2L_reg_reg_avx10(rRegL dst, regF src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvF2L src));\n-  format %{ \"evcvttss2sisq $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttss2sisq($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convF2L_reg_mem_avx10(rRegL dst, memory src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvF2L (LoadF src)));\n-  format %{ \"evcvttss2sisq $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttss2sisq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx10_2());\n-  match(Set dst (ConvD2I src));\n-  effect(KILL cr);\n-  format %{ \"convert_d2i $dst, $src\"%}\n-  ins_encode %{\n-    __ convertF2I(T_INT, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convD2I_reg_reg_avx10(rRegI dst, regD src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvD2I src));\n-  format %{ \"evcvttsd2sisl $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttsd2sisl($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convD2I_reg_mem_avx10(rRegI dst, memory src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvD2I (LoadD src)));\n-  format %{ \"evcvttsd2sisl $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttsd2sisl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx10_2());\n-  match(Set dst (ConvD2L src));\n-  effect(KILL cr);\n-  format %{ \"convert_d2l $dst, $src\"%}\n-  ins_encode %{\n-    __ convertF2I(T_LONG, T_DOUBLE, $dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convD2L_reg_reg_avx10(rRegL dst, regD src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvD2L src));\n-  format %{ \"evcvttsd2sisq $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttsd2sisq($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convD2L_reg_mem_avx10(rRegL dst, memory src)\n-%{\n-  predicate(VM_Version::supports_avx10_2());\n-  match(Set dst (ConvD2L (LoadD src)));\n-  format %{ \"evcvttsd2sisq $dst, $src\" %}\n-  ins_encode %{\n-    __ evcvttsd2sisq($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct round_double_reg(rRegL dst, regD src, rRegL rtmp, rcx_RegL rcx, rFlagsReg cr)\n-%{\n-  match(Set dst (RoundD src));\n-  effect(TEMP dst, TEMP rtmp, TEMP rcx, KILL cr);\n-  format %{ \"round_double $dst,$src \\t! using $rtmp and $rcx as TEMP\"%}\n-  ins_encode %{\n-    __ round_double($dst$$Register, $src$$XMMRegister, $rtmp$$Register, $rcx$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct round_float_reg(rRegI dst, regF src, rRegL rtmp, rcx_RegL rcx, rFlagsReg cr)\n-%{\n-  match(Set dst (RoundF src));\n-  effect(TEMP dst, TEMP rtmp, TEMP rcx, KILL cr);\n-  format %{ \"round_float $dst,$src\" %}\n-  ins_encode %{\n-    __ round_float($dst$$Register, $src$$XMMRegister, $rtmp$$Register, $rcx$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct convI2F_reg_reg(vlRegF dst, rRegI src)\n-%{\n-  predicate(!UseXmmI2F);\n-  match(Set dst (ConvI2F src));\n-\n-  format %{ \"cvtsi2ssl $dst, $src\\t# i2f\" %}\n-  ins_encode %{\n-    if (UseAVX > 0) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-    __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convI2F_reg_mem(regF dst, memory src)\n-%{\n-  predicate(UseAVX == 0);\n-  match(Set dst (ConvI2F (LoadI src)));\n-\n-  format %{ \"cvtsi2ssl $dst, $src\\t# i2f\" %}\n-  ins_encode %{\n-    __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convI2D_reg_reg(vlRegD dst, rRegI src)\n-%{\n-  predicate(!UseXmmI2D);\n-  match(Set dst (ConvI2D src));\n-\n-  format %{ \"cvtsi2sdl $dst, $src\\t# i2d\" %}\n-  ins_encode %{\n-    if (UseAVX > 0) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-    __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convI2D_reg_mem(regD dst, memory src)\n-%{\n-  predicate(UseAVX == 0);\n-  match(Set dst (ConvI2D (LoadI src)));\n-\n-  format %{ \"cvtsi2sdl $dst, $src\\t# i2d\" %}\n-  ins_encode %{\n-    __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convXI2F_reg(regF dst, rRegI src)\n-%{\n-  predicate(UseXmmI2F);\n-  match(Set dst (ConvI2F src));\n-\n-  format %{ \"movdl $dst, $src\\n\\t\"\n-            \"cvtdq2psl $dst, $dst\\t# i2f\" %}\n-  ins_encode %{\n-    __ movdl($dst$$XMMRegister, $src$$Register);\n-    __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convXI2D_reg(regD dst, rRegI src)\n-%{\n-  predicate(UseXmmI2D);\n-  match(Set dst (ConvI2D src));\n-\n-  format %{ \"movdl $dst, $src\\n\\t\"\n-            \"cvtdq2pdl $dst, $dst\\t# i2d\" %}\n-  ins_encode %{\n-    __ movdl($dst$$XMMRegister, $src$$Register);\n-    __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convL2F_reg_reg(vlRegF dst, rRegL src)\n-%{\n-  match(Set dst (ConvL2F src));\n-\n-  format %{ \"cvtsi2ssq $dst, $src\\t# l2f\" %}\n-  ins_encode %{\n-    if (UseAVX > 0) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-    __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convL2F_reg_mem(regF dst, memory src)\n-%{\n-  predicate(UseAVX == 0);\n-  match(Set dst (ConvL2F (LoadL src)));\n-\n-  format %{ \"cvtsi2ssq $dst, $src\\t# l2f\" %}\n-  ins_encode %{\n-    __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convL2D_reg_reg(vlRegD dst, rRegL src)\n-%{\n-  match(Set dst (ConvL2D src));\n-\n-  format %{ \"cvtsi2sdq $dst, $src\\t# l2d\" %}\n-  ins_encode %{\n-    if (UseAVX > 0) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    }\n-    __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convL2D_reg_mem(regD dst, memory src)\n-%{\n-  predicate(UseAVX == 0);\n-  match(Set dst (ConvL2D (LoadL src)));\n-\n-  format %{ \"cvtsi2sdq $dst, $src\\t# l2d\" %}\n-  ins_encode %{\n-    __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow); \/\/ XXX\n-%}\n-\n-instruct convI2L_reg_reg(rRegL dst, rRegI src)\n-%{\n-  match(Set dst (ConvI2L src));\n-\n-  ins_cost(125);\n-  format %{ \"movslq  $dst, $src\\t# i2l\" %}\n-  ins_encode %{\n-    __ movslq($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Zero-extend convert int to long\n-instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)\n-%{\n-  match(Set dst (AndL (ConvI2L src) mask));\n-\n-  format %{ \"movl    $dst, $src\\t# i2l zero-extend\\n\\t\" %}\n-  ins_encode %{\n-    if ($dst$$reg != $src$$reg) {\n-      __ movl($dst$$Register, $src$$Register);\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ Zero-extend convert int to long\n-instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)\n-%{\n-  match(Set dst (AndL (ConvI2L (LoadI src)) mask));\n-\n-  format %{ \"movl    $dst, $src\\t# i2l zero-extend\\n\\t\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)\n-%{\n-  match(Set dst (AndL src mask));\n-\n-  format %{ \"movl    $dst, $src\\t# zero-extend long\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct convL2I_reg_reg(rRegI dst, rRegL src)\n-%{\n-  match(Set dst (ConvL2I src));\n-\n-  format %{ \"movl    $dst, $src\\t# l2i\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\n-instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{\n-  match(Set dst (MoveF2I src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(125);\n-  format %{ \"movl    $dst, $src\\t# MoveF2I_stack_reg\" %}\n-  ins_encode %{\n-    __ movl($dst$$Register, Address(rsp, $src$$disp));\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{\n-  match(Set dst (MoveI2F src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(125);\n-  format %{ \"movss   $dst, $src\\t# MoveI2F_stack_reg\" %}\n-  ins_encode %{\n-    __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{\n-  match(Set dst (MoveD2L src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(125);\n-  format %{ \"movq    $dst, $src\\t# MoveD2L_stack_reg\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, Address(rsp, $src$$disp));\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{\n-  predicate(!UseXmmLoadAndClearUpper);\n-  match(Set dst (MoveL2D src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(125);\n-  format %{ \"movlpd  $dst, $src\\t# MoveL2D_stack_reg\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{\n-  predicate(UseXmmLoadAndClearUpper);\n-  match(Set dst (MoveL2D src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(125);\n-  format %{ \"movsd   $dst, $src\\t# MoveL2D_stack_reg\" %}\n-  ins_encode %{\n-    __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\n-instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{\n-  match(Set dst (MoveF2I src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(95); \/\/ XXX\n-  format %{ \"movss   $dst, $src\\t# MoveF2I_reg_stack\" %}\n-  ins_encode %{\n-    __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{\n-  match(Set dst (MoveI2F src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(100);\n-  format %{ \"movl    $dst, $src\\t# MoveI2F_reg_stack\" %}\n-  ins_encode %{\n-    __ movl(Address(rsp, $dst$$disp), $src$$Register);\n-  %}\n-  ins_pipe( ialu_mem_reg );\n-%}\n-\n-instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{\n-  match(Set dst (MoveD2L src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(95); \/\/ XXX\n-  format %{ \"movsd   $dst, $src\\t# MoveL2D_reg_stack\" %}\n-  ins_encode %{\n-    __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{\n-  match(Set dst (MoveL2D src));\n-  effect(DEF dst, USE src);\n-\n-  ins_cost(100);\n-  format %{ \"movq    $dst, $src\\t# MoveL2D_reg_stack\" %}\n-  ins_encode %{\n-    __ movq(Address(rsp, $dst$$disp), $src$$Register);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct MoveF2I_reg_reg(rRegI dst, regF src) %{\n-  match(Set dst (MoveF2I src));\n-  effect(DEF dst, USE src);\n-  ins_cost(85);\n-  format %{ \"movd    $dst,$src\\t# MoveF2I\" %}\n-  ins_encode %{\n-    __ movdl($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct MoveD2L_reg_reg(rRegL dst, regD src) %{\n-  match(Set dst (MoveD2L src));\n-  effect(DEF dst, USE src);\n-  ins_cost(85);\n-  format %{ \"movd    $dst,$src\\t# MoveD2L\" %}\n-  ins_encode %{\n-    __ movdq($dst$$Register, $src$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct MoveI2F_reg_reg(regF dst, rRegI src) %{\n-  match(Set dst (MoveI2F src));\n-  effect(DEF dst, USE src);\n-  ins_cost(100);\n-  format %{ \"movd    $dst,$src\\t# MoveI2F\" %}\n-  ins_encode %{\n-    __ movdl($dst$$XMMRegister, $src$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct MoveL2D_reg_reg(regD dst, rRegL src) %{\n-  match(Set dst (MoveL2D src));\n-  effect(DEF dst, USE src);\n-  ins_cost(100);\n-  format %{ \"movd    $dst,$src\\t# MoveL2D\" %}\n-  ins_encode %{\n-     __ movdq($dst$$XMMRegister, $src$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\n-\/\/ Fast clearing of an array\n-\/\/ Small non-constant lenght ClearArray for non-AVX512 targets.\n-instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n-                  Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n-    $$emit$$\"jg      LARGE\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n-    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"jge     LOOP\\n\\t\"\n-    $$emit$$\"jmp     DONE\\n\\t\"\n-    $$emit$$\"# LARGE:\\n\\t\"\n-    if (UseFastStosb) {\n-       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n-       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n-    } else if (UseXMMForObjInit) {\n-       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n-       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n-       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n-    }\n-    $$emit$$\"# DONE\"\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, false, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n-                            Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n-    $$emit$$\"jg      LARGE\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n-    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"jge     LOOP\\n\\t\"\n-    $$emit$$\"jmp     DONE\\n\\t\"\n-    $$emit$$\"# LARGE:\\n\\t\"\n-    if (UseXMMForObjInit) {\n-       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n-       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n-       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n-    }\n-    $$emit$$\"# DONE\"\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, false, true);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Small non-constant length ClearArray for AVX512 targets.\n-instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n-                       Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  ins_cost(125);\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n-    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n-    $$emit$$\"jg      LARGE\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n-    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"jge     LOOP\\n\\t\"\n-    $$emit$$\"jmp     DONE\\n\\t\"\n-    $$emit$$\"# LARGE:\\n\\t\"\n-    if (UseFastStosb) {\n-       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n-       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n-    } else if (UseXMMForObjInit) {\n-       $$emit$$\"mov     rdi,rax\\n\\t\"\n-       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n-    }\n-    $$emit$$\"# DONE\"\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, false, false, $ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rep_stos_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n-                                 Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  ins_cost(125);\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n-    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n-    $$emit$$\"jg      LARGE\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n-    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n-    $$emit$$\"dec     rcx\\n\\t\"\n-    $$emit$$\"jge     LOOP\\n\\t\"\n-    $$emit$$\"jmp     DONE\\n\\t\"\n-    $$emit$$\"# LARGE:\\n\\t\"\n-    if (UseFastStosb) {\n-       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n-       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n-    } else if (UseXMMForObjInit) {\n-       $$emit$$\"mov     rdi,rax\\n\\t\"\n-       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n-    }\n-    $$emit$$\"# DONE\"\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, false, true, $ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Large non-constant length ClearArray for non-AVX512 targets.\n-instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n-                        Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    if (UseFastStosb) {\n-       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n-       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n-    } else if (UseXMMForObjInit) {\n-       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n-       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n-       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n-    }\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, true, false);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n-                                  Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    if (UseXMMForObjInit) {\n-       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n-       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n-       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n-    }\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, true, true);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Large non-constant length ClearArray for AVX512 targets.\n-instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n-                             Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    if (UseFastStosb) {\n-       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n-       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n-       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n-    } else if (UseXMMForObjInit) {\n-       $$emit$$\"mov     rdi,rax\\t# ClearArray:\\n\\t\"\n-       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n-    }\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, true, false, $ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rep_stos_large_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n-                                       Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n-\n-  format %{ $$template\n-    if (UseFastStosb) {\n-       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n-       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n-       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n-    } else if (UseXMMForObjInit) {\n-       $$emit$$\"mov     rdi,rax\\t# ClearArray:\\n\\t\"\n-       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n-       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n-       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n-       $$emit$$\"add     0x40,rax\\n\\t\"\n-       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n-       $$emit$$\"sub     0x8,rcx\\n\\t\"\n-       $$emit$$\"jge     L_loop\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jl      L_tail\\n\\t\"\n-       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x20,rax\\n\\t\"\n-       $$emit$$\"sub     0x4,rcx\\n\\t\"\n-       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n-       $$emit$$\"add     0x4,rcx\\n\\t\"\n-       $$emit$$\"jle     L_end\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n-       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n-       $$emit$$\"add     0x8,rax\\n\\t\"\n-       $$emit$$\"dec     rcx\\n\\t\"\n-       $$emit$$\"jge     L_sloop\\n\\t\"\n-       $$emit$$\"# L_end:\\n\\t\"\n-    } else {\n-       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n-       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n-    }\n-  %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n-                 $tmp$$XMMRegister, true, true, $ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Small constant length ClearArray for AVX512 targets.\n-instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rax_RegL val, kReg ktmp, Universe dummy, rFlagsReg cr)\n-%{\n-  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() &&\n-            ((MaxVectorSize >= 32) && VM_Version::supports_avx512vl()));\n-  match(Set dummy (ClearArray (Binary cnt base) val));\n-  ins_cost(100);\n-  effect(TEMP tmp, USE_KILL val, TEMP ktmp, KILL cr);\n-  format %{ \"clear_mem_imm $base , $cnt  \\n\\t\" %}\n-  ins_encode %{\n-    __ clear_mem($base$$Register, $cnt$$constant, $val$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n-                         rax_RegI result, legRegD tmp1, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compareL_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n-                              rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n-                         rax_RegI result, legRegD tmp1, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compareU_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n-                              rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n-                          rax_RegI result, legRegD tmp1, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compareLU_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n-                               rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,\n-                          rax_RegI result, legRegD tmp1, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str2$$Register, $str1$$Register,\n-                      $cnt2$$Register, $cnt1$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compareUL_evex(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,\n-                               rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n-  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n-\n-  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n-  ins_encode %{\n-    __ string_compare($str2$$Register, $str1$$Register,\n-                      $cnt2$$Register, $cnt1$$Register, $result$$Register,\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ fast search of substring with known size.\n-instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,\n-                             rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::LL));\n-  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));\n-  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);\n-\n-  format %{ \"String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -> $result   \/\/ KILL $tmp_vec, $cnt1, $cnt2, $tmp\" %}\n-  ins_encode %{\n-    int icnt2 = (int)$int_cnt2$$constant;\n-    if (icnt2 >= 16) {\n-      \/\/ IndexOf for constant substrings with size >= 16 elements\n-      \/\/ which don't need to be loaded through stack.\n-      __ string_indexofC8($str1$$Register, $str2$$Register,\n-                          $cnt1$$Register, $cnt2$$Register,\n-                          icnt2, $result$$Register,\n-                          $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);\n-    } else {\n-      \/\/ Small strings are loaded through stack if they cross page boundary.\n-      __ string_indexof($str1$$Register, $str2$$Register,\n-                        $cnt1$$Register, $cnt2$$Register,\n-                        icnt2, $result$$Register,\n-                        $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ fast search of substring with known size.\n-instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,\n-                             rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UU));\n-  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));\n-  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);\n-\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -> $result   \/\/ KILL $tmp_vec, $cnt1, $cnt2, $tmp\" %}\n-  ins_encode %{\n-    int icnt2 = (int)$int_cnt2$$constant;\n-    if (icnt2 >= 8) {\n-      \/\/ IndexOf for constant substrings with size >= 8 elements\n-      \/\/ which don't need to be loaded through stack.\n-      __ string_indexofC8($str1$$Register, $str2$$Register,\n-                          $cnt1$$Register, $cnt2$$Register,\n-                          icnt2, $result$$Register,\n-                          $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);\n-    } else {\n-      \/\/ Small strings are loaded through stack if they cross page boundary.\n-      __ string_indexof($str1$$Register, $str2$$Register,\n-                        $cnt1$$Register, $cnt2$$Register,\n-                        icnt2, $result$$Register,\n-                        $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ fast search of substring with known size.\n-instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,\n-                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UL));\n-  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));\n-  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);\n-\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -> $result   \/\/ KILL $tmp_vec, $cnt1, $cnt2, $tmp\" %}\n-  ins_encode %{\n-    int icnt2 = (int)$int_cnt2$$constant;\n-    if (icnt2 >= 8) {\n-      \/\/ IndexOf for constant substrings with size >= 8 elements\n-      \/\/ which don't need to be loaded through stack.\n-      __ string_indexofC8($str1$$Register, $str2$$Register,\n-                          $cnt1$$Register, $cnt2$$Register,\n-                          icnt2, $result$$Register,\n-                          $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);\n-    } else {\n-      \/\/ Small strings are loaded through stack if they cross page boundary.\n-      __ string_indexof($str1$$Register, $str2$$Register,\n-                        $cnt1$$Register, $cnt2$$Register,\n-                        icnt2, $result$$Register,\n-                        $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,\n-                         rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::LL));\n-  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);\n-\n-  format %{ \"String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL all\" %}\n-  ins_encode %{\n-    __ string_indexof($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register,\n-                      (-1), $result$$Register,\n-                      $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,\n-                         rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UU));\n-  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);\n-\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL all\" %}\n-  ins_encode %{\n-    __ string_indexof($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register,\n-                      (-1), $result$$Register,\n-                      $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,\n-                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UL));\n-  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));\n-  effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);\n-\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL all\" %}\n-  ins_encode %{\n-    __ string_indexof($str1$$Register, $str2$$Register,\n-                      $cnt1$$Register, $cnt2$$Register,\n-                      (-1), $result$$Register,\n-                      $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n-                              rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n-  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n-  ins_encode %{\n-    __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                           $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct stringL_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n-                              rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)\n-%{\n-  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n-  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n-  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n-  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n-  ins_encode %{\n-    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n-                           $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ fast string equals\n-instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,\n-                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw());\n-  match(Set result (StrEquals (Binary str1 str2) cnt));\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);\n-\n-  format %{ \"String Equals $str1,$str2,$cnt -> $result    \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n-  ins_encode %{\n-    __ arrays_equals(false, $str1$$Register, $str2$$Register,\n-                     $cnt$$Register, $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_equals_evex(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,\n-                           legRegD tmp1, legRegD tmp2, kReg ktmp, rbx_RegI tmp3, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw());\n-  match(Set result (StrEquals (Binary str1 str2) cnt));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);\n-\n-  format %{ \"String Equals $str1,$str2,$cnt -> $result    \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n-  ins_encode %{\n-    __ arrays_equals(false, $str1$$Register, $str2$$Register,\n-                     $cnt$$Register, $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ fast array equals\n-instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n-                       legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n-  match(Set result (AryEq ary1 ary2));\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n-\n-  format %{ \"Array Equals byte[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n-  ins_encode %{\n-    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n-                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct array_equalsB_evex(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n-                            legRegD tmp1, legRegD tmp2, kReg ktmp, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n-  match(Set result (AryEq ary1 ary2));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n-\n-  format %{ \"Array Equals byte[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n-  ins_encode %{\n-    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n-                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n-                       legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n-  match(Set result (AryEq ary1 ary2));\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n-\n-  format %{ \"Array Equals char[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n-  ins_encode %{\n-    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n-                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct array_equalsC_evex(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n-                            legRegD tmp1, legRegD tmp2, kReg ktmp, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n-  match(Set result (AryEq ary1 ary2));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n-\n-  format %{ \"Array Equals char[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n-  ins_encode %{\n-    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n-                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result, immU8 basic_type,\n-                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n-                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n-                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n-                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n-%{\n-  predicate(UseAVX >= 2);\n-  match(Set result (VectorizedHashCode (Binary ary1 cnt1) (Binary result basic_type)));\n-  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n-         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n-         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL ary1, USE_KILL cnt1,\n-         USE basic_type, KILL cr);\n-\n-  format %{ \"Array HashCode array[] $ary1,$cnt1,$result,$basic_type -> $result   \/\/ KILL all\" %}\n-  ins_encode %{\n-    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n-                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n-                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n-                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n-                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n-                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n-                       $tmp_vec13$$XMMRegister, (BasicType)$basic_type$$constant);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct count_positives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                         legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n-%{\n-  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n-  match(Set result (CountPositives ary1 len));\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);\n-\n-  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n-  ins_encode %{\n-    __ count_positives($ary1$$Register, $len$$Register,\n-                       $result$$Register, $tmp3$$Register,\n-                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct count_positives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                              legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n-%{\n-  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n-  match(Set result (CountPositives ary1 len));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp1, TEMP ktmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);\n-\n-  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n-  ins_encode %{\n-    __ count_positives($ary1$$Register, $len$$Register,\n-                       $result$$Register, $tmp3$$Register,\n-                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ fast char[] to byte[] compression\n-instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3,\n-                         legRegD tmp4, rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n-  match(Set result (StrCompressedCopy src (Binary dst len)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst,\n-         USE_KILL len, KILL tmp5, KILL cr);\n-\n-  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL RAX, RCX, RDX\" %}\n-  ins_encode %{\n-    __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,\n-                           $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n-                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n-                           knoreg, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_compress_evex(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3,\n-                              legRegD tmp4, kReg ktmp1, kReg ktmp2, rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n-  match(Set result (StrCompressedCopy src (Binary dst len)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ktmp1, TEMP ktmp2, USE_KILL src, USE_KILL dst,\n-         USE_KILL len, KILL tmp5, KILL cr);\n-\n-  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL RAX, RCX, RDX\" %}\n-  ins_encode %{\n-    __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,\n-                           $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n-                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n-                           $ktmp1$$KRegister, $ktmp2$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\/\/ fast byte[] to char[] inflation\n-instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n-                        legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{\n-  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n-  match(Set dummy (StrInflatedCopy src (Binary dst len)));\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n-\n-  format %{ \"String Inflate $src,$dst    \/\/ KILL $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,\n-                          $tmp1$$XMMRegister, $tmp2$$Register, knoreg);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct string_inflate_evex(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n-                             legRegD tmp1, kReg ktmp, rcx_RegI tmp2, rFlagsReg cr) %{\n-  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n-  match(Set dummy (StrInflatedCopy src (Binary dst len)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n-\n-  format %{ \"String Inflate $src,$dst    \/\/ KILL $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,\n-                          $tmp1$$XMMRegister, $tmp2$$Register, $ktmp$$KRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ encode char[] to byte[] in ISO_8859_1\n-instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n-                          legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,\n-                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n-  predicate(!((EncodeISOArrayNode*)n)->is_ascii());\n-  match(Set result (EncodeISOArray src (Binary dst len)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n-\n-  format %{ \"Encode iso array $src,$dst,$len -> $result    \/\/ KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI \" %}\n-  ins_encode %{\n-    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n-                        $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n-                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, false);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ encode char[] to byte[] in ASCII\n-instruct encode_ascii_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n-                            legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,\n-                            rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n-  predicate(((EncodeISOArrayNode*)n)->is_ascii());\n-  match(Set result (EncodeISOArray src (Binary dst len)));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n-\n-  format %{ \"Encode ascii array $src,$dst,$len -> $result    \/\/ KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI \" %}\n-  ins_encode %{\n-    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,\n-                        $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n-                        $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register, true);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/----------Overflow Math Instructions-----------------------------------------\n-\n-instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)\n-%{\n-  match(Set cr (OverflowAddI op1 op2));\n-  effect(DEF cr, USE_KILL op1, USE op2);\n-\n-  format %{ \"addl    $op1, $op2\\t# overflow check int\" %}\n-\n-  ins_encode %{\n-    __ addl($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)\n-%{\n-  match(Set cr (OverflowAddI op1 op2));\n-  effect(DEF cr, USE_KILL op1, USE op2);\n-\n-  format %{ \"addl    $op1, $op2\\t# overflow check int\" %}\n-\n-  ins_encode %{\n-    __ addl($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)\n-%{\n-  match(Set cr (OverflowAddL op1 op2));\n-  effect(DEF cr, USE_KILL op1, USE op2);\n-\n-  format %{ \"addq    $op1, $op2\\t# overflow check long\" %}\n-  ins_encode %{\n-    __ addq($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)\n-%{\n-  match(Set cr (OverflowAddL op1 op2));\n-  effect(DEF cr, USE_KILL op1, USE op2);\n-\n-  format %{ \"addq    $op1, $op2\\t# overflow check long\" %}\n-  ins_encode %{\n-    __ addq($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)\n-%{\n-  match(Set cr (OverflowSubI op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\\t# overflow check int\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)\n-%{\n-  match(Set cr (OverflowSubI op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\\t# overflow check int\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)\n-%{\n-  match(Set cr (OverflowSubL op1 op2));\n-\n-  format %{ \"cmpq    $op1, $op2\\t# overflow check long\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)\n-%{\n-  match(Set cr (OverflowSubL op1 op2));\n-\n-  format %{ \"cmpq    $op1, $op2\\t# overflow check long\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowNegI_rReg(rFlagsReg cr, immI_0 zero, rax_RegI op2)\n-%{\n-  match(Set cr (OverflowSubI zero op2));\n-  effect(DEF cr, USE_KILL op2);\n-\n-  format %{ \"negl    $op2\\t# overflow check int\" %}\n-  ins_encode %{\n-    __ negl($op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)\n-%{\n-  match(Set cr (OverflowSubL zero op2));\n-  effect(DEF cr, USE_KILL op2);\n-\n-  format %{ \"negq    $op2\\t# overflow check long\" %}\n-  ins_encode %{\n-    __ negq($op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)\n-%{\n-  match(Set cr (OverflowMulI op1 op2));\n-  effect(DEF cr, USE_KILL op1, USE op2);\n-\n-  format %{ \"imull    $op1, $op2\\t# overflow check int\" %}\n-  ins_encode %{\n-    __ imull($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)\n-%{\n-  match(Set cr (OverflowMulI op1 op2));\n-  effect(DEF cr, TEMP tmp, USE op1, USE op2);\n-\n-  format %{ \"imull    $tmp, $op1, $op2\\t# overflow check int\" %}\n-  ins_encode %{\n-    __ imull($tmp$$Register, $op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)\n-%{\n-  match(Set cr (OverflowMulL op1 op2));\n-  effect(DEF cr, USE_KILL op1, USE op2);\n-\n-  format %{ \"imulq    $op1, $op2\\t# overflow check long\" %}\n-  ins_encode %{\n-    __ imulq($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)\n-%{\n-  match(Set cr (OverflowMulL op1 op2));\n-  effect(DEF cr, TEMP tmp, USE op1, USE op2);\n-\n-  format %{ \"imulq    $tmp, $op1, $op2\\t# overflow check long\" %}\n-  ins_encode %{\n-    __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n-\n-\/\/----------Control Flow Instructions------------------------------------------\n-\/\/ Signed compare Instructions\n-\n-\/\/ XXX more variants!!\n-instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)\n-%{\n-  match(Set cr (CmpI op1 op2));\n-  effect(DEF cr, USE op1, USE op2);\n-\n-  format %{ \"cmpl    $op1, $op2\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_reg);\n-%}\n-\n-instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)\n-%{\n-  match(Set cr (CmpI op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)\n-%{\n-  match(Set cr (CmpI op1 (LoadI op2)));\n-\n-  ins_cost(500); \/\/ XXX\n-  format %{ \"cmpl    $op1, $op2\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testI_reg(rFlagsReg cr, rRegI src, immI_0 zero)\n-%{\n-  match(Set cr (CmpI src zero));\n-\n-  format %{ \"testl   $src, $src\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI_0 zero)\n-%{\n-  match(Set cr (CmpI (AndI src con) zero));\n-\n-  format %{ \"testl   $src, $con\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $con$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testI_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2, immI_0 zero)\n-%{\n-  match(Set cr (CmpI (AndI src1 src2) zero));\n-\n-  format %{ \"testl   $src1, $src2\" %}\n-  ins_encode %{\n-    __ testl($src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI_0 zero)\n-%{\n-  match(Set cr (CmpI (AndI src (LoadI mem)) zero));\n-\n-  format %{ \"testl   $src, $mem\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-\/\/ Unsigned compare Instructions; really, same as signed except they\n-\/\/ produce an rFlagsRegU instead of rFlagsReg.\n-instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)\n-%{\n-  match(Set cr (CmpU op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\\t# unsigned\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_reg);\n-%}\n-\n-instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)\n-%{\n-  match(Set cr (CmpU op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\\t# unsigned\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)\n-%{\n-  match(Set cr (CmpU op1 (LoadI op2)));\n-\n-  ins_cost(500); \/\/ XXX\n-  format %{ \"cmpl    $op1, $op2\\t# unsigned\" %}\n-  ins_encode %{\n-    __ cmpl($op1$$Register, $op2$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testU_reg(rFlagsRegU cr, rRegI src, immI_0 zero)\n-%{\n-  match(Set cr (CmpU src zero));\n-\n-  format %{ \"testl   $src, $src\\t# unsigned\" %}\n-  ins_encode %{\n-    __ testl($src$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)\n-%{\n-  match(Set cr (CmpP op1 op2));\n-\n-  format %{ \"cmpq    $op1, $op2\\t# ptr\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_reg);\n-%}\n-\n-instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)\n-%{\n-  match(Set cr (CmpP op1 (LoadP op2)));\n-  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n-\n-  ins_cost(500); \/\/ XXX\n-  format %{ \"cmpq    $op1, $op2\\t# ptr\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-\/\/ XXX this is generalized by compP_rReg_mem???\n-\/\/ Compare raw pointer (used in out-of-heap check).\n-\/\/ Only works because non-oop pointers must be raw pointers\n-\/\/ and raw pointers have no anti-dependencies.\n-instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)\n-%{\n-  predicate(n->in(2)->in(2)->bottom_type()->reloc() == relocInfo::none &&\n-            n->in(2)->as_Load()->barrier_data() == 0);\n-  match(Set cr (CmpP op1 (LoadP op2)));\n-\n-  format %{ \"cmpq    $op1, $op2\\t# raw ptr\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-\/\/ This will generate a signed flags result. This should be OK since\n-\/\/ any compare to a zero should be eq\/neq.\n-instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)\n-%{\n-  match(Set cr (CmpP src zero));\n-\n-  format %{ \"testq   $src, $src\\t# ptr\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-\/\/ This will generate a signed flags result. This should be OK since\n-\/\/ any compare to a zero should be eq\/neq.\n-instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)\n-%{\n-  predicate((!UseCompressedOops || (CompressedOops::base() != nullptr)) &&\n-            n->in(1)->as_Load()->barrier_data() == 0);\n-  match(Set cr (CmpP (LoadP op) zero));\n-\n-  ins_cost(500); \/\/ XXX\n-  format %{ \"testq   $op, 0xffffffffffffffff\\t# ptr\" %}\n-  ins_encode %{\n-    __ testq($op$$Address, 0xFFFFFFFF);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr) &&\n-            n->in(1)->as_Load()->barrier_data() == 0);\n-  match(Set cr (CmpP (LoadP mem) zero));\n-\n-  format %{ \"cmpq    R12, $mem\\t# ptr (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ cmpq(r12, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)\n-%{\n-  match(Set cr (CmpN op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\\t# compressed ptr\" %}\n-  ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}\n-  ins_pipe(ialu_cr_reg_reg);\n-%}\n-\n-instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)\n-%{\n-  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n-  match(Set cr (CmpN src (LoadN mem)));\n-\n-  format %{ \"cmpl    $src, $mem\\t# compressed ptr\" %}\n-  ins_encode %{\n-    __ cmpl($src$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{\n-  match(Set cr (CmpN op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\\t# compressed ptr\" %}\n-  ins_encode %{\n-    __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)\n-%{\n-  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n-  match(Set cr (CmpN src (LoadN mem)));\n-\n-  format %{ \"cmpl    $mem, $src\\t# compressed ptr\" %}\n-  ins_encode %{\n-    __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{\n-  match(Set cr (CmpN op1 op2));\n-\n-  format %{ \"cmpl    $op1, $op2\\t# compressed klass ptr\" %}\n-  ins_encode %{\n-    __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)\n-%{\n-  predicate(!UseCompactObjectHeaders);\n-  match(Set cr (CmpN src (LoadNKlass mem)));\n-\n-  format %{ \"cmpl    $mem, $src\\t# compressed klass ptr\" %}\n-  ins_encode %{\n-    __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{\n-  match(Set cr (CmpN src zero));\n-\n-  format %{ \"testl   $src, $src\\t# compressed ptr\" %}\n-  ins_encode %{ __ testl($src$$Register, $src$$Register); %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)\n-%{\n-  predicate(CompressedOops::base() != nullptr &&\n-            n->in(1)->as_Load()->barrier_data() == 0);\n-  match(Set cr (CmpN (LoadN mem) zero));\n-\n-  ins_cost(500); \/\/ XXX\n-  format %{ \"testl   $mem, 0xffffffff\\t# compressed ptr\" %}\n-  ins_encode %{\n-    __ cmpl($mem$$Address, (int)0xFFFFFFFF);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)\n-%{\n-  predicate(CompressedOops::base() == nullptr &&\n-            n->in(1)->as_Load()->barrier_data() == 0);\n-  match(Set cr (CmpN (LoadN mem) zero));\n-\n-  format %{ \"cmpl    R12, $mem\\t# compressed ptr (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ cmpl(r12, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-\/\/ Yanked all unsigned pointer compare operations.\n-\/\/ Pointer compares are done with CmpP which is already unsigned.\n-\n-instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)\n-%{\n-  match(Set cr (CmpL op1 op2));\n-\n-  format %{ \"cmpq    $op1, $op2\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_reg);\n-%}\n-\n-instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)\n-%{\n-  match(Set cr (CmpL op1 op2));\n-\n-  format %{ \"cmpq    $op1, $op2\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)\n-%{\n-  match(Set cr (CmpL op1 (LoadL op2)));\n-\n-  format %{ \"cmpq    $op1, $op2\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)\n-%{\n-  match(Set cr (CmpL src zero));\n-\n-  format %{ \"testq   $src, $src\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)\n-%{\n-  match(Set cr (CmpL (AndL src con) zero));\n-\n-  format %{ \"testq   $src, $con\\t# long\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $con$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testL_reg_reg(rFlagsReg cr, rRegL src1, rRegL src2, immL0 zero)\n-%{\n-  match(Set cr (CmpL (AndL src1 src2) zero));\n-\n-  format %{ \"testq   $src1, $src2\\t# long\" %}\n-  ins_encode %{\n-    __ testq($src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)\n-%{\n-  match(Set cr (CmpL (AndL src (LoadL mem)) zero));\n-\n-  format %{ \"testq   $src, $mem\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)\n-%{\n-  match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));\n-\n-  format %{ \"testq   $src, $mem\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-\/\/ Manifest a CmpU result in an integer register.  Very painful.\n-\/\/ This is the test to avoid.\n-instruct cmpU3_reg_reg(rRegI dst, rRegI src1, rRegI src2, rFlagsReg flags)\n-%{\n-  match(Set dst (CmpU3 src1 src2));\n-  effect(KILL flags);\n-\n-  ins_cost(275); \/\/ XXX\n-  format %{ \"cmpl    $src1, $src2\\t# CmpL3\\n\\t\"\n-            \"movl    $dst, -1\\n\\t\"\n-            \"jb,u    done\\n\\t\"\n-            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n-    \"done:\" %}\n-  ins_encode %{\n-    Label done;\n-    __ cmpl($src1$$Register, $src2$$Register);\n-    __ movl($dst$$Register, -1);\n-    __ jccb(Assembler::below, done);\n-    __ setcc(Assembler::notZero, $dst$$Register);\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Manifest a CmpL result in an integer register.  Very painful.\n-\/\/ This is the test to avoid.\n-instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)\n-%{\n-  match(Set dst (CmpL3 src1 src2));\n-  effect(KILL flags);\n-\n-  ins_cost(275); \/\/ XXX\n-  format %{ \"cmpq    $src1, $src2\\t# CmpL3\\n\\t\"\n-            \"movl    $dst, -1\\n\\t\"\n-            \"jl,s    done\\n\\t\"\n-            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n-    \"done:\" %}\n-  ins_encode %{\n-    Label done;\n-    __ cmpq($src1$$Register, $src2$$Register);\n-    __ movl($dst$$Register, -1);\n-    __ jccb(Assembler::less, done);\n-    __ setcc(Assembler::notZero, $dst$$Register);\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Manifest a CmpUL result in an integer register.  Very painful.\n-\/\/ This is the test to avoid.\n-instruct cmpUL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)\n-%{\n-  match(Set dst (CmpUL3 src1 src2));\n-  effect(KILL flags);\n-\n-  ins_cost(275); \/\/ XXX\n-  format %{ \"cmpq    $src1, $src2\\t# CmpL3\\n\\t\"\n-            \"movl    $dst, -1\\n\\t\"\n-            \"jb,u    done\\n\\t\"\n-            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n-    \"done:\" %}\n-  ins_encode %{\n-    Label done;\n-    __ cmpq($src1$$Register, $src2$$Register);\n-    __ movl($dst$$Register, -1);\n-    __ jccb(Assembler::below, done);\n-    __ setcc(Assembler::notZero, $dst$$Register);\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Unsigned long compare Instructions; really, same as signed long except they\n-\/\/ produce an rFlagsRegU instead of rFlagsReg.\n-instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)\n-%{\n-  match(Set cr (CmpUL op1 op2));\n-\n-  format %{ \"cmpq    $op1, $op2\\t# unsigned\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_reg);\n-%}\n-\n-instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)\n-%{\n-  match(Set cr (CmpUL op1 op2));\n-\n-  format %{ \"cmpq    $op1, $op2\\t# unsigned\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$constant);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)\n-%{\n-  match(Set cr (CmpUL op1 (LoadL op2)));\n-\n-  format %{ \"cmpq    $op1, $op2\\t# unsigned\" %}\n-  ins_encode %{\n-    __ cmpq($op1$$Register, $op2$$Address);\n-  %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)\n-%{\n-  match(Set cr (CmpUL src zero));\n-\n-  format %{ \"testq   $src, $src\\t# unsigned\" %}\n-  ins_encode %{\n-    __ testq($src$$Register, $src$$Register);\n-  %}\n-  ins_pipe(ialu_cr_reg_imm);\n-%}\n-\n-instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)\n-%{\n-  match(Set cr (CmpI (LoadB mem) imm));\n-\n-  ins_cost(125);\n-  format %{ \"cmpb    $mem, $imm\" %}\n-  ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU7 imm, immI_0 zero)\n-%{\n-  match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));\n-\n-  ins_cost(125);\n-  format %{ \"testb   $mem, $imm\\t# ubyte\" %}\n-  ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI_0 zero)\n-%{\n-  match(Set cr (CmpI (AndI (LoadB mem) imm) zero));\n-\n-  ins_cost(125);\n-  format %{ \"testb   $mem, $imm\\t# byte\" %}\n-  ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}\n-  ins_pipe(ialu_cr_reg_mem);\n-%}\n-\n-\/\/----------Max and Min--------------------------------------------------------\n-\/\/ Min Instructions\n-\n-instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  effect(USE_DEF dst, USE src, USE cr);\n-\n-  format %{ \"cmovlgt $dst, $src\\t# min\" %}\n-  ins_encode %{\n-    __ cmovl(Assembler::greater, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_reg_g_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  effect(DEF dst, USE src1, USE src2, USE cr);\n-\n-  format %{ \"ecmovlgt $dst, $src1, $src2\\t# min ndd\" %}\n-  ins_encode %{\n-    __ ecmovl(Assembler::greater, $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct minI_rReg(rRegI dst, rRegI src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (MinI dst src));\n-\n-  ins_cost(200);\n-  expand %{\n-    rFlagsReg cr;\n-    compI_rReg(cr, dst, src);\n-    cmovI_reg_g(dst, src, cr);\n-  %}\n-%}\n-\n-instruct minI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MinI src1 src2));\n-  effect(DEF dst, USE src1, USE src2);\n-\n-  ins_cost(200);\n-  expand %{\n-    rFlagsReg cr;\n-    compI_rReg(cr, src1, src2);\n-    cmovI_reg_g_ndd(dst, src1, src2, cr);\n-  %}\n-%}\n-\n-instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)\n-%{\n-  predicate(!UseAPX);\n-  effect(USE_DEF dst, USE src, USE cr);\n-\n-  format %{ \"cmovllt $dst, $src\\t# max\" %}\n-  ins_encode %{\n-    __ cmovl(Assembler::less, $dst$$Register, $src$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct cmovI_reg_l_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  effect(DEF dst, USE src1, USE src2, USE cr);\n-\n-  format %{ \"ecmovllt $dst, $src1, $src2\\t# max ndd\" %}\n-  ins_encode %{\n-    __ ecmovl(Assembler::less, $dst$$Register, $src1$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n-instruct maxI_rReg(rRegI dst, rRegI src)\n-%{\n-  predicate(!UseAPX);\n-  match(Set dst (MaxI dst src));\n-\n-  ins_cost(200);\n-  expand %{\n-    rFlagsReg cr;\n-    compI_rReg(cr, dst, src);\n-    cmovI_reg_l(dst, src, cr);\n-  %}\n-%}\n-\n-instruct maxI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MaxI src1 src2));\n-  effect(DEF dst, USE src1, USE src2);\n-\n-  ins_cost(200);\n-  expand %{\n-    rFlagsReg cr;\n-    compI_rReg(cr, src1, src2);\n-    cmovI_reg_l_ndd(dst, src1, src2, cr);\n-  %}\n-%}\n-\n-\/\/ ============================================================================\n-\/\/ Branch Instructions\n-\n-\/\/ Jump Direct - Label defines a relative address from JMP+1\n-instruct jmpDir(label labl)\n-%{\n-  match(Goto);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"jmp     $labl\" %}\n-  size(5);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jmp(*L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)\n-%{\n-  match(If cop cr);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop     $labl\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)\n-%{\n-  match(CountedLoopEnd cop cr);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop     $labl\\t# loop end\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-\/\/ Jump Direct Conditional - using unsigned comparison\n-instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{\n-  match(If cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,u   $labl\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{\n-  match(If cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(200);\n-  format %{ \"j$cop,u   $labl\" %}\n-  size(6);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{\n-  match(If cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(200);\n-  format %{ $$template\n-    if ($cop$$cmpcode == Assembler::notEqual) {\n-      $$emit$$\"jp,u    $labl\\n\\t\"\n-      $$emit$$\"j$cop,u   $labl\"\n-    } else {\n-      $$emit$$\"jp,u    done\\n\\t\"\n-      $$emit$$\"j$cop,u   $labl\\n\\t\"\n-      $$emit$$\"done:\"\n-    }\n-  %}\n-  ins_encode %{\n-    Label* l = $labl$$label;\n-    if ($cop$$cmpcode == Assembler::notEqual) {\n-      __ jcc(Assembler::parity, *l, false);\n-      __ jcc(Assembler::notEqual, *l, false);\n-    } else if ($cop$$cmpcode == Assembler::equal) {\n-      Label done;\n-      __ jccb(Assembler::parity, done);\n-      __ jcc(Assembler::equal, *l, false);\n-      __ bind(done);\n-    } else {\n-       ShouldNotReachHere();\n-    }\n-  %}\n-  ins_pipe(pipe_jcc);\n-%}\n-\n-\/\/ ============================================================================\n-\/\/ The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary\n-\/\/ superklass array for an instance of the superklass.  Set a hidden\n-\/\/ internal cache on a hit (cache is checked with exposed code in\n-\/\/ gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The\n-\/\/ encoding ALSO sets flags.\n-\n-instruct partialSubtypeCheck(rdi_RegP result,\n-                             rsi_RegP sub, rax_RegP super, rcx_RegI rcx,\n-                             rFlagsReg cr)\n-%{\n-  match(Set result (PartialSubtypeCheck sub super));\n-  predicate(!UseSecondarySupersTable);\n-  effect(KILL rcx, KILL cr);\n-\n-  ins_cost(1100);  \/\/ slightly larger than the next version\n-  format %{ \"movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\\n\\t\"\n-            \"movl    rcx, [rdi + Array<Klass*>::length_offset_in_bytes()]\\t# length to scan\\n\\t\"\n-            \"addq    rdi, Array<Klass*>::base_offset_in_bytes()\\t# Skip to start of data; set NZ in case count is zero\\n\\t\"\n-            \"repne   scasq\\t# Scan *rdi++ for a match with rax while rcx--\\n\\t\"\n-            \"jne,s   miss\\t\\t# Missed: rdi not-zero\\n\\t\"\n-            \"movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\\t# Hit: update cache\\n\\t\"\n-            \"xorq    $result, $result\\t\\t Hit: rdi zero\\n\\t\"\n-    \"miss:\\t\" %}\n-\n-  ins_encode %{\n-    Label miss;\n-    \/\/ NB: Callers may assume that, when $result is a valid register,\n-    \/\/ check_klass_subtype_slow_path_linear sets it to a nonzero\n-    \/\/ value.\n-    __ check_klass_subtype_slow_path_linear($sub$$Register, $super$$Register,\n-                                            $rcx$$Register, $result$$Register,\n-                                            nullptr, &miss,\n-                                            \/*set_cond_codes:*\/ true);\n-    __ xorptr($result$$Register, $result$$Register);\n-    __ bind(miss);\n-  %}\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ============================================================================\n-\/\/ Two versions of hashtable-based partialSubtypeCheck, both used when\n-\/\/ we need to search for a super class in the secondary supers array.\n-\/\/ The first is used when we don't know _a priori_ the class being\n-\/\/ searched for. The second, far more common, is used when we do know:\n-\/\/ this is used for instanceof, checkcast, and any case where C2 can\n-\/\/ determine it by constant propagation.\n-\n-instruct partialSubtypeCheckVarSuper(rsi_RegP sub, rax_RegP super, rdi_RegP result,\n-                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n-                                       rFlagsReg cr)\n-%{\n-  match(Set result (PartialSubtypeCheck sub super));\n-  predicate(UseSecondarySupersTable);\n-  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n-\n-  ins_cost(1000);\n-  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n-\n-  ins_encode %{\n-    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register, $temp1$$Register, $temp2$$Register,\n-\t\t\t\t\t $temp3$$Register, $temp4$$Register, $result$$Register);\n-  %}\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct partialSubtypeCheckConstSuper(rsi_RegP sub, rax_RegP super_reg, immP super_con, rdi_RegP result,\n-                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n-                                       rFlagsReg cr)\n-%{\n-  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n-  predicate(UseSecondarySupersTable);\n-  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n-\n-  ins_cost(700);  \/\/ smaller than the next version\n-  format %{ \"partialSubtypeCheck $result, $sub, $super_reg, $super_con\" %}\n-\n-  ins_encode %{\n-    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n-    if (InlineSecondarySupersTest) {\n-      __ lookup_secondary_supers_table_const($sub$$Register, $super_reg$$Register, $temp1$$Register, $temp2$$Register,\n-                                       $temp3$$Register, $temp4$$Register, $result$$Register,\n-                                       super_klass_slot);\n-    } else {\n-      __ call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n-    }\n-  %}\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ============================================================================\n-\/\/ Branch Instructions -- short offset versions\n-\/\/\n-\/\/ These instructions are used to replace jumps of a long offset (the default\n-\/\/ match) with jumps of a shorter offset.  These instructions are all tagged\n-\/\/ with the ins_short_branch attribute, which causes the ADLC to suppress the\n-\/\/ match rules in general matching.  Instead, the ADLC generates a conversion\n-\/\/ method in the MachNode which can be used to do in-place replacement of the\n-\/\/ long variant with the shorter variant.  The compiler will determine if a\n-\/\/ branch can be taken by the is_short_branch_offset() predicate in the machine\n-\/\/ specific code section of the file.\n-\n-\/\/ Jump Direct - Label defines a relative address from JMP+1\n-instruct jmpDir_short(label labl) %{\n-  match(Goto);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"jmp,s   $labl\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jmpb(*L);\n-  %}\n-  ins_pipe(pipe_jmp);\n-  ins_short_branch(1);\n-%}\n-\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{\n-  match(If cop cr);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,s   $labl\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe(pipe_jcc);\n-  ins_short_branch(1);\n-%}\n-\n-\/\/ Jump Direct Conditional - Label defines a relative address from Jcc+1\n-instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{\n-  match(CountedLoopEnd cop cr);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,s   $labl\\t# loop end\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe(pipe_jcc);\n-  ins_short_branch(1);\n-%}\n-\n-\/\/ Jump Direct Conditional - using unsigned comparison\n-instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{\n-  match(If cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,us  $labl\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe(pipe_jcc);\n-  ins_short_branch(1);\n-%}\n-\n-instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{\n-  match(If cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ \"j$cop,us  $labl\" %}\n-  size(2);\n-  ins_encode %{\n-    Label* L = $labl$$label;\n-    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n-  %}\n-  ins_pipe(pipe_jcc);\n-  ins_short_branch(1);\n-%}\n-\n-instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{\n-  match(If cop cmp);\n-  effect(USE labl);\n-\n-  ins_cost(300);\n-  format %{ $$template\n-    if ($cop$$cmpcode == Assembler::notEqual) {\n-      $$emit$$\"jp,u,s  $labl\\n\\t\"\n-      $$emit$$\"j$cop,u,s  $labl\"\n-    } else {\n-      $$emit$$\"jp,u,s  done\\n\\t\"\n-      $$emit$$\"j$cop,u,s  $labl\\n\\t\"\n-      $$emit$$\"done:\"\n-    }\n-  %}\n-  size(4);\n-  ins_encode %{\n-    Label* l = $labl$$label;\n-    if ($cop$$cmpcode == Assembler::notEqual) {\n-      __ jccb(Assembler::parity, *l);\n-      __ jccb(Assembler::notEqual, *l);\n-    } else if ($cop$$cmpcode == Assembler::equal) {\n-      Label done;\n-      __ jccb(Assembler::parity, done);\n-      __ jccb(Assembler::equal, *l);\n-      __ bind(done);\n-    } else {\n-       ShouldNotReachHere();\n-    }\n-  %}\n-  ins_pipe(pipe_jcc);\n-  ins_short_branch(1);\n-%}\n-\n-\/\/ ============================================================================\n-\/\/ inlined locking and unlocking\n-\n-instruct cmpFastLockLightweight(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI rax_reg, rRegP tmp) %{\n-  match(Set cr (FastLock object box));\n-  effect(TEMP rax_reg, TEMP tmp, USE_KILL box);\n-  ins_cost(300);\n-  format %{ \"fastlock $object,$box\\t! kills $box,$rax_reg,$tmp\" %}\n-  ins_encode %{\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, rRegP object, rax_RegP rax_reg, rRegP tmp) %{\n-  match(Set cr (FastUnlock object rax_reg));\n-  effect(TEMP tmp, USE_KILL rax_reg);\n-  ins_cost(300);\n-  format %{ \"fastunlock $object,$rax_reg\\t! kills $rax_reg,$tmp\" %}\n-  ins_encode %{\n-    __ fast_unlock_lightweight($object$$Register, $rax_reg$$Register, $tmp$$Register, r15_thread);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\n-\/\/ ============================================================================\n-\/\/ Safepoint Instructions\n-instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)\n-%{\n-  match(SafePoint poll);\n-  effect(KILL cr, USE poll);\n-\n-  format %{ \"testl   rax, [$poll]\\t\"\n-            \"# Safepoint: poll for GC\" %}\n-  ins_cost(125);\n-  ins_encode %{\n-    __ relocate(relocInfo::poll_type);\n-    address pre_pc = __ pc();\n-    __ testl(rax, Address($poll$$Register, 0));\n-    assert(nativeInstruction_at(pre_pc)->is_safepoint_poll(), \"must emit test %%eax [reg]\");\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n-instruct mask_all_evexL(kReg dst, rRegL src) %{\n-  match(Set dst (MaskAll src));\n-  format %{ \"mask_all_evexL $dst, $src \\t! mask all operation\" %}\n-  ins_encode %{\n-    int mask_len = Matcher::vector_length(this);\n-    __ vector_maskall_operation($dst$$KRegister, $src$$Register, mask_len);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct mask_all_evexI_GT32(kReg dst, rRegI src, rRegL tmp) %{\n-  predicate(Matcher::vector_length(n) > 32);\n-  match(Set dst (MaskAll src));\n-  effect(TEMP tmp);\n-  format %{ \"mask_all_evexI_GT32 $dst, $src \\t! using $tmp as TEMP\" %}\n-  ins_encode %{\n-    int mask_len = Matcher::vector_length(this);\n-    __ movslq($tmp$$Register, $src$$Register);\n-    __ vector_maskall_operation($dst$$KRegister, $tmp$$Register, mask_len);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-\/\/ ============================================================================\n-\/\/ Procedure Call\/Return Instructions\n-\/\/ Call Java Static Instruction\n-\/\/ Note: If this code changes, the corresponding ret_addr_offset() and\n-\/\/       compute_padding() functions will have to be adjusted.\n-instruct CallStaticJavaDirect(method meth) %{\n-  match(CallStaticJava);\n-  effect(USE meth);\n-\n-  ins_cost(300);\n-  format %{ \"call,static \" %}\n-  opcode(0xE8); \/* E8 cd *\/\n-  ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);\n-  ins_pipe(pipe_slow);\n-  ins_alignment(4);\n-%}\n-\n-\/\/ Call Java Dynamic Instruction\n-\/\/ Note: If this code changes, the corresponding ret_addr_offset() and\n-\/\/       compute_padding() functions will have to be adjusted.\n-instruct CallDynamicJavaDirect(method meth)\n-%{\n-  match(CallDynamicJava);\n-  effect(USE meth);\n-\n-  ins_cost(300);\n-  format %{ \"movq    rax, #Universe::non_oop_word()\\n\\t\"\n-            \"call,dynamic \" %}\n-  ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);\n-  ins_pipe(pipe_slow);\n-  ins_alignment(4);\n-%}\n-\n-\/\/ Call Runtime Instruction\n-instruct CallRuntimeDirect(method meth)\n-%{\n-  match(CallRuntime);\n-  effect(USE meth);\n-\n-  ins_cost(300);\n-  format %{ \"call,runtime \" %}\n-  ins_encode(clear_avx, Java_To_Runtime(meth));\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Call runtime without safepoint\n-instruct CallLeafDirect(method meth)\n-%{\n-  match(CallLeaf);\n-  effect(USE meth);\n-\n-  ins_cost(300);\n-  format %{ \"call_leaf,runtime \" %}\n-  ins_encode(clear_avx, Java_To_Runtime(meth));\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Call runtime without safepoint and with vector arguments\n-instruct CallLeafDirectVector(method meth)\n-%{\n-  match(CallLeafVector);\n-  effect(USE meth);\n-\n-  ins_cost(300);\n-  format %{ \"call_leaf,vector \" %}\n-  ins_encode(Java_To_Runtime(meth));\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Call runtime without safepoint\n-\/\/ entry point is null, target holds the address to call\n-instruct CallLeafNoFPInDirect(rRegP target)\n-%{\n-  predicate(n->as_Call()->entry_point() == nullptr);\n-  match(CallLeafNoFP target);\n-\n-  ins_cost(300);\n-  format %{ \"call_leaf_nofp,runtime indirect \" %}\n-  ins_encode %{\n-     __ call($target$$Register);\n-  %}\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct CallLeafNoFPDirect(method meth)\n-%{\n-  predicate(n->as_Call()->entry_point() != nullptr);\n-  match(CallLeafNoFP);\n-  effect(USE meth);\n-\n-  ins_cost(300);\n-  format %{ \"call_leaf_nofp,runtime \" %}\n-  ins_encode(clear_avx, Java_To_Runtime(meth));\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ Return Instruction\n-\/\/ Remove the return address & jump to it.\n-\/\/ Notice: We always emit a nop after a ret to make sure there is room\n-\/\/ for safepoint patching\n-instruct Ret()\n-%{\n-  match(Return);\n-\n-  format %{ \"ret\" %}\n-  ins_encode %{\n-    __ ret(0);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-\/\/ Tail Call; Jump from runtime stub to Java code.\n-\/\/ Also known as an 'interprocedural jump'.\n-\/\/ Target of jump will eventually return to caller.\n-\/\/ TailJump below removes the return address.\n-\/\/ Don't use rbp for 'jump_target' because a MachEpilogNode has already been\n-\/\/ emitted just above the TailCall which has reset rbp to the caller state.\n-instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_ptr)\n-%{\n-  match(TailCall jump_target method_ptr);\n-\n-  ins_cost(300);\n-  format %{ \"jmp     $jump_target\\t# rbx holds method\" %}\n-  ins_encode %{\n-    __ jmp($jump_target$$Register);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-\/\/ Tail Jump; remove the return address; jump to target.\n-\/\/ TailCall above leaves the return address around.\n-instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)\n-%{\n-  match(TailJump jump_target ex_oop);\n-\n-  ins_cost(300);\n-  format %{ \"popq    rdx\\t# pop return address\\n\\t\"\n-            \"jmp     $jump_target\" %}\n-  ins_encode %{\n-    __ popq(as_Register(RDX_enc));\n-    __ jmp($jump_target$$Register);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-\/\/ Forward exception.\n-instruct ForwardExceptionjmp()\n-%{\n-  match(ForwardException);\n-\n-  format %{ \"jmp     forward_exception_stub\" %}\n-  ins_encode %{\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()), noreg);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-\/\/ Create exception oop: created by stack-crawling runtime code.\n-\/\/ Created exception is now available to this handler, and is setup\n-\/\/ just prior to jumping to this handler.  No code emitted.\n-instruct CreateException(rax_RegP ex_oop)\n-%{\n-  match(Set ex_oop (CreateEx));\n-\n-  size(0);\n-  \/\/ use the following format syntax\n-  format %{ \"# exception oop is in rax; no code emitted\" %}\n-  ins_encode();\n-  ins_pipe(empty);\n-%}\n-\n-\/\/ Rethrow exception:\n-\/\/ The exception oop will come in the first argument position.\n-\/\/ Then JUMP (not call) to the rethrow stub code.\n-instruct RethrowException()\n-%{\n-  match(Rethrow);\n-\n-  \/\/ use the following format syntax\n-  format %{ \"jmp     rethrow_stub\" %}\n-  ins_encode %{\n-    __ jump(RuntimeAddress(OptoRuntime::rethrow_stub()), noreg);\n-  %}\n-  ins_pipe(pipe_jmp);\n-%}\n-\n-\/\/ ============================================================================\n-\/\/ This name is KNOWN by the ADLC and cannot be changed.\n-\/\/ The ADLC forces a 'TypeRawPtr::BOTTOM' output type\n-\/\/ for this guy.\n-instruct tlsLoadP(r15_RegP dst) %{\n-  match(Set dst (ThreadLocal));\n-  effect(DEF dst);\n-\n-  size(0);\n-  format %{ \"# TLS is in R15\" %}\n-  ins_encode( \/*empty encoding*\/ );\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\n-\/\/----------PEEPHOLE RULES-----------------------------------------------------\n-\/\/ These must follow all instruction definitions as they use the names\n-\/\/ defined in the instructions definitions.\n-\/\/\n-\/\/ peeppredicate ( rule_predicate );\n-\/\/ \/\/ the predicate unless which the peephole rule will be ignored\n-\/\/\n-\/\/ peepmatch ( root_instr_name [preceding_instruction]* );\n-\/\/\n-\/\/ peepprocedure ( procedure_name );\n-\/\/ \/\/ provide a procedure name to perform the optimization, the procedure should\n-\/\/ \/\/ reside in the architecture dependent peephole file, the method has the\n-\/\/ \/\/ signature of MachNode* (Block*, int, PhaseRegAlloc*, (MachNode*)(*)(), int...)\n-\/\/ \/\/ with the arguments being the basic block, the current node index inside the\n-\/\/ \/\/ block, the register allocator, the functions upon invoked return a new node\n-\/\/ \/\/ defined in peepreplace, and the rules of the nodes appearing in the\n-\/\/ \/\/ corresponding peepmatch, the function return true if successful, else\n-\/\/ \/\/ return false\n-\/\/\n-\/\/ peepconstraint %{\n-\/\/ (instruction_number.operand_name relational_op instruction_number.operand_name\n-\/\/  [, ...] );\n-\/\/ \/\/ instruction numbers are zero-based using left to right order in peepmatch\n-\/\/\n-\/\/ peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );\n-\/\/ \/\/ provide an instruction_number.operand_name for each operand that appears\n-\/\/ \/\/ in the replacement instruction's match rule\n-\/\/\n-\/\/ ---------VM FLAGS---------------------------------------------------------\n-\/\/\n-\/\/ All peephole optimizations can be turned off using -XX:-OptoPeephole\n-\/\/\n-\/\/ Each peephole rule is given an identifying number starting with zero and\n-\/\/ increasing by one in the order seen by the parser.  An individual peephole\n-\/\/ can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#\n-\/\/ on the command-line.\n-\/\/\n-\/\/ ---------CURRENT LIMITATIONS----------------------------------------------\n-\/\/\n-\/\/ Only transformations inside a basic block (do we need more for peephole)\n-\/\/\n-\/\/ ---------EXAMPLE----------------------------------------------------------\n-\/\/\n-\/\/ \/\/ pertinent parts of existing instructions in architecture description\n-\/\/ instruct movI(rRegI dst, rRegI src)\n-\/\/ %{\n-\/\/   match(Set dst (CopyI src));\n-\/\/ %}\n-\/\/\n-\/\/ instruct incI_rReg(rRegI dst, immI_1 src, rFlagsReg cr)\n-\/\/ %{\n-\/\/   match(Set dst (AddI dst src));\n-\/\/   effect(KILL cr);\n-\/\/ %}\n-\/\/\n-\/\/ instruct leaI_rReg_immI(rRegI dst, immI_1 src)\n-\/\/ %{\n-\/\/   match(Set dst (AddI dst src));\n-\/\/ %}\n-\/\/\n-\/\/ 1. Simple replacement\n-\/\/ - Only match adjacent instructions in same basic block\n-\/\/ - Only equality constraints\n-\/\/ - Only constraints between operands, not (0.dest_reg == RAX_enc)\n-\/\/ - Only one replacement instruction\n-\/\/\n-\/\/ \/\/ Change (inc mov) to lea\n-\/\/ peephole %{\n-\/\/   \/\/ lea should only be emitted when beneficial\n-\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n-\/\/   \/\/ increment preceded by register-register move\n-\/\/   peepmatch ( incI_rReg movI );\n-\/\/   \/\/ require that the destination register of the increment\n-\/\/   \/\/ match the destination register of the move\n-\/\/   peepconstraint ( 0.dst == 1.dst );\n-\/\/   \/\/ construct a replacement instruction that sets\n-\/\/   \/\/ the destination to ( move's source register + one )\n-\/\/   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );\n-\/\/ %}\n-\/\/\n-\/\/ 2. Procedural replacement\n-\/\/ - More flexible finding relevent nodes\n-\/\/ - More flexible constraints\n-\/\/ - More flexible transformations\n-\/\/ - May utilise architecture-dependent API more effectively\n-\/\/ - Currently only one replacement instruction due to adlc parsing capabilities\n-\/\/\n-\/\/ \/\/ Change (inc mov) to lea\n-\/\/ peephole %{\n-\/\/   \/\/ lea should only be emitted when beneficial\n-\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n-\/\/   \/\/ the rule numbers of these nodes inside are passed into the function below\n-\/\/   peepmatch ( incI_rReg movI );\n-\/\/   \/\/ the method that takes the responsibility of transformation\n-\/\/   peepprocedure ( inc_mov_to_lea );\n-\/\/   \/\/ the replacement is a leaI_rReg_immI, a lambda upon invoked creating this\n-\/\/   \/\/ node is passed into the function above\n-\/\/   peepreplace ( leaI_rReg_immI() );\n-\/\/ %}\n-\n-\/\/ These instructions is not matched by the matcher but used by the peephole\n-instruct leaI_rReg_rReg_peep(rRegI dst, rRegI src1, rRegI src2)\n-%{\n-  predicate(false);\n-  match(Set dst (AddI src1 src2));\n-  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n-  ins_encode %{\n-    Register dst = $dst$$Register;\n-    Register src1 = $src1$$Register;\n-    Register src2 = $src2$$Register;\n-    if (src1 != rbp && src1 != r13) {\n-      __ leal(dst, Address(src1, src2, Address::times_1));\n-    } else {\n-      assert(src2 != rbp && src2 != r13, \"\");\n-      __ leal(dst, Address(src2, src1, Address::times_1));\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaI_rReg_immI_peep(rRegI dst, rRegI src1, immI src2)\n-%{\n-  predicate(false);\n-  match(Set dst (AddI src1 src2));\n-  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n-  ins_encode %{\n-    __ leal($dst$$Register, Address($src1$$Register, $src2$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaI_rReg_immI2_peep(rRegI dst, rRegI src, immI2 shift)\n-%{\n-  predicate(false);\n-  match(Set dst (LShiftI src shift));\n-  format %{ \"leal    $dst, [$src << $shift]\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n-    Register src = $src$$Register;\n-    if (scale == Address::times_2 && src != rbp && src != r13) {\n-      __ leal($dst$$Register, Address(src, src, Address::times_1));\n-    } else {\n-      __ leal($dst$$Register, Address(noreg, src, scale));\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaL_rReg_rReg_peep(rRegL dst, rRegL src1, rRegL src2)\n-%{\n-  predicate(false);\n-  match(Set dst (AddL src1 src2));\n-  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n-  ins_encode %{\n-    Register dst = $dst$$Register;\n-    Register src1 = $src1$$Register;\n-    Register src2 = $src2$$Register;\n-    if (src1 != rbp && src1 != r13) {\n-      __ leaq(dst, Address(src1, src2, Address::times_1));\n-    } else {\n-      assert(src2 != rbp && src2 != r13, \"\");\n-      __ leaq(dst, Address(src2, src1, Address::times_1));\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaL_rReg_immL32_peep(rRegL dst, rRegL src1, immL32 src2)\n-%{\n-  predicate(false);\n-  match(Set dst (AddL src1 src2));\n-  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, Address($src1$$Register, $src2$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-instruct leaL_rReg_immI2_peep(rRegL dst, rRegL src, immI2 shift)\n-%{\n-  predicate(false);\n-  match(Set dst (LShiftL src shift));\n-  format %{ \"leaq    $dst, [$src << $shift]\" %}\n-  ins_encode %{\n-    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n-    Register src = $src$$Register;\n-    if (scale == Address::times_2 && src != rbp && src != r13) {\n-      __ leaq($dst$$Register, Address(src, src, Address::times_1));\n-    } else {\n-      __ leaq($dst$$Register, Address(noreg, src, scale));\n-    }\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n-\/\/ These peephole rules replace mov + I pairs (where I is one of {add, inc, dec,\n-\/\/ sal}) with lea instructions. The {add, sal} rules are beneficial in\n-\/\/ processors with at least partial ALU support for lea\n-\/\/ (supports_fast_2op_lea()), whereas the {inc, dec} rules are only generally\n-\/\/ beneficial for processors with full ALU support\n-\/\/ (VM_Version::supports_fast_3op_lea()) and Intel Cascade Lake.\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n-  peepmatch (addI_rReg);\n-  peepprocedure (lea_coalesce_reg);\n-  peepreplace (leaI_rReg_rReg_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n-  peepmatch (addI_rReg_imm);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaI_rReg_immI_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n-                VM_Version::is_intel_cascade_lake());\n-  peepmatch (incI_rReg);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaI_rReg_immI_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n-                VM_Version::is_intel_cascade_lake());\n-  peepmatch (decI_rReg);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaI_rReg_immI_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n-  peepmatch (salI_rReg_immI2);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaI_rReg_immI2_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n-  peepmatch (addL_rReg);\n-  peepprocedure (lea_coalesce_reg);\n-  peepreplace (leaL_rReg_rReg_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n-  peepmatch (addL_rReg_imm);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaL_rReg_immL32_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n-                VM_Version::is_intel_cascade_lake());\n-  peepmatch (incL_rReg);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaL_rReg_immL32_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n-                VM_Version::is_intel_cascade_lake());\n-  peepmatch (decL_rReg);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaL_rReg_immL32_peep());\n-%}\n-\n-peephole\n-%{\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n-  peepmatch (salL_rReg_immI2);\n-  peepprocedure (lea_coalesce_imm);\n-  peepreplace (leaL_rReg_immI2_peep());\n-%}\n-\n-peephole\n-%{\n-  peepmatch (leaPCompressedOopOffset);\n-  peepprocedure (lea_remove_redundant);\n-%}\n-\n-peephole\n-%{\n-  peepmatch (leaP8Narrow);\n-  peepprocedure (lea_remove_redundant);\n-%}\n-\n-peephole\n-%{\n-  peepmatch (leaP32Narrow);\n-  peepprocedure (lea_remove_redundant);\n-%}\n-\n-\/\/ These peephole rules matches instructions which set flags and are followed by a testI\/L_reg\n-\/\/ The test instruction is redudanent in case the downstream instuctions (like JCC or CMOV) only use flags that are already set by the previous instruction\n-\n-\/\/int variant\n-peephole\n-%{\n-  peepmatch (testI_reg);\n-  peepprocedure (test_may_remove);\n-%}\n-\n-\/\/long variant\n-peephole\n-%{\n-  peepmatch (testL_reg);\n-  peepprocedure (test_may_remove);\n-%}\n-\n-\n-\/\/----------SMARTSPILL RULES---------------------------------------------------\n-\/\/ These must follow all instruction definitions as they use the names\n-\/\/ defined in the instructions definitions.\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":15015,"binary":false,"changes":15015,"status":"deleted"},{"patch":"@@ -71,0 +71,9 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  Unimplemented();\n+}\n+\n@@ -103,0 +112,5 @@\n+inline intptr_t* ThawBase::push_preempt_adapter() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ZERO_GC_SHARED_MODREFBARRIERSETASSEMBLER_ZERO_HPP\n-#define CPU_ZERO_GC_SHARED_MODREFBARRIERSETASSEMBLER_ZERO_HPP\n-\n-class ModRefBarrierSetAssembler;\n-\n-#endif \/\/ CPU_ZERO_GC_SHARED_MODREFBARRIERSETASSEMBLER_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/gc\/shared\/modRefBarrierSetAssembler_zero.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -31,0 +31,2 @@\n+class SmallRegisterMap;\n+\n@@ -32,4 +34,7 @@\n-class SmallRegisterMap {\n-  constexpr SmallRegisterMap() = default;\n-  ~SmallRegisterMap() = default;\n-  NONCOPYABLE(SmallRegisterMap);\n+template <bool IncludeArgs>\n+class SmallRegisterMapType {\n+  friend SmallRegisterMap;\n+\n+  constexpr SmallRegisterMapType() = default;\n+  ~SmallRegisterMapType() = default;\n+  NONCOPYABLE(SmallRegisterMapType);\n@@ -37,6 +42,0 @@\n-public:\n-  static const SmallRegisterMap* instance() {\n-    static constexpr SmallRegisterMap the_instance{};\n-    return &the_instance;\n-  }\n-private:\n@@ -72,1 +71,1 @@\n-  bool include_argument_oops() const { return false; }\n+  bool include_argument_oops() const { return IncludeArgs; }\n","filename":"src\/hotspot\/cpu\/zero\/smallRegisterMap_zero.inline.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops(RegisterMapT* map) const {\n","filename":"src\/hotspot\/cpu\/zero\/stackChunkFrameStream_zero.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,0 +105,11 @@\n+#define CONTAINER_READ_NUMERICAL_KEY_VALUE_CHECKED(controller, filename, key, log_string, retval) \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_numerical_key_value(filename, key, &retval);               \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -127,0 +127,6 @@\n+jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n+  julong use_hierarchy;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  return (jlong)use_hierarchy;\n+}\n+\n@@ -163,6 +169,4 @@\n-  if (memlimit >= upper_bound) {\n-    verbose_log(memlimit, upper_bound);\n-    return (jlong)-1;\n-  } else {\n-    verbose_log(memlimit, upper_bound);\n-    return (jlong)memlimit;\n+  if (memlimit >= upper_bound && uses_mem_hierarchy()) {\n+    CONTAINER_READ_NUMERICAL_KEY_VALUE_CHECKED(reader(), \"\/memory.stat\",\n+                                               \"hierarchical_memory_limit\", \"Hierarchical Memory Limit\",\n+                                               memlimit);\n@@ -170,0 +174,2 @@\n+  verbose_log(memlimit, upper_bound);\n+  return (jlong)((memlimit < upper_bound) ? memlimit : -1);\n@@ -187,5 +193,4 @@\n-  if (memswlimit >= upper_memsw_bound) {\n-    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memswlimit;\n+  if (memswlimit >= upper_memsw_bound && uses_mem_hierarchy()) {\n+      CONTAINER_READ_NUMERICAL_KEY_VALUE_CHECKED(reader(), \"\/memory.stat\",\n+                                                 \"hierarchical_memsw_limit\", \"Hierarchical Memory and Swap Limit\",\n+                                                 memswlimit);\n@@ -193,0 +198,2 @@\n+  verbose_log(memswlimit, upper_memsw_bound);\n+  return (jlong)((memswlimit < upper_memsw_bound) ? memswlimit : -1);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+    jlong uses_mem_hierarchy();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -849,4 +849,0 @@\n-  if (UseNUMA) {\n-    thread->update_lgrp_id();\n-  }\n-\n@@ -1178,4 +1174,0 @@\n-  if (UseNUMA) {\n-    thread->update_lgrp_id();\n-  }\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#define JVM_MAXPATHLEN MAXPATHLEN + 1\n+#define JVM_MAXPATHLEN (MAXPATHLEN + 1)\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-        address deopt = nm->deopt_handler_begin();\n+        address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2798,1 +2798,1 @@\n-          address deopt = nm->deopt_handler_begin();\n+          address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-#ifdef AMD64\n@@ -138,45 +137,0 @@\n-#else \/\/ !AMD64\n-\n-extern \"C\" {\n-  \/\/ defined in bsd_x86.s\n-  int64_t _Atomic_cmpxchg_long(int64_t, volatile int64_t*, int64_t);\n-  void _Atomic_move_long(const volatile int64_t* src, volatile int64_t* dst);\n-}\n-\n-template<>\n-template<typename T>\n-inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                      T compare_value,\n-                                                      T exchange_value,\n-                                                      atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  return cmpxchg_using_helper<int64_t>(_Atomic_cmpxchg_long, dest, compare_value, exchange_value);\n-}\n-\n-\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n-template<>\n-struct AtomicAccess::PlatformXchg<8> : AtomicAccess::XchgUsingCmpxchg<8> {};\n-\n-\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n-template<>\n-struct AtomicAccess::PlatformAdd<8> : AtomicAccess::AddUsingCmpxchg<8> {};\n-\n-template<>\n-template<typename T>\n-inline T AtomicAccess::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  volatile int64_t dest;\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(src), reinterpret_cast<volatile int64_t*>(&dest));\n-  return PrimitiveConversions::cast<T>(dest);\n-}\n-\n-template<>\n-template<typename T>\n-inline void AtomicAccess::PlatformStore<8>::operator()(T volatile* dest,\n-                                                       T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(&store_value), reinterpret_cast<volatile int64_t*>(dest));\n-}\n-\n-#endif \/\/ AMD64\n-\n@@ -219,1 +173,0 @@\n-#ifdef AMD64\n@@ -231,1 +184,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomicAccess_bsd_x86.hpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#ifdef AMD64\n@@ -36,9 +35,0 @@\n-#else\n-define_pd_global(intx, CompilerThreadStackSize,  512);\n-\/\/ ThreadStackSize 320 allows a couple of test cases to run while\n-\/\/ keeping the number of threads that can be created high.  System\n-\/\/ default ThreadStackSize appears to be 512 which is too big.\n-define_pd_global(intx, ThreadStackSize,          320);\n-define_pd_global(intx, VMThreadStackSize,        512);\n-#endif \/\/ AMD64\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/globals_bsd_x86.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-#ifdef AMD64\n@@ -56,3 +55,0 @@\n-#else\n-  __asm__ volatile (\"lock; addl $0,0(%%esp)\" : : : \"cc\", \"memory\");\n-#endif\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/orderAccess_bsd_x86.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-#ifdef AMD64\n@@ -93,4 +92,0 @@\n-#else\n-#define SPELL_REG_SP \"esp\"\n-#define SPELL_REG_FP \"ebp\"\n-#endif \/\/ AMD64\n@@ -100,39 +95,22 @@\n-# ifdef AMD64\n-#  define context_pc uc_mcontext.mc_rip\n-#  define context_sp uc_mcontext.mc_rsp\n-#  define context_fp uc_mcontext.mc_rbp\n-#  define context_rip uc_mcontext.mc_rip\n-#  define context_rsp uc_mcontext.mc_rsp\n-#  define context_rbp uc_mcontext.mc_rbp\n-#  define context_rax uc_mcontext.mc_rax\n-#  define context_rbx uc_mcontext.mc_rbx\n-#  define context_rcx uc_mcontext.mc_rcx\n-#  define context_rdx uc_mcontext.mc_rdx\n-#  define context_rsi uc_mcontext.mc_rsi\n-#  define context_rdi uc_mcontext.mc_rdi\n-#  define context_r8  uc_mcontext.mc_r8\n-#  define context_r9  uc_mcontext.mc_r9\n-#  define context_r10 uc_mcontext.mc_r10\n-#  define context_r11 uc_mcontext.mc_r11\n-#  define context_r12 uc_mcontext.mc_r12\n-#  define context_r13 uc_mcontext.mc_r13\n-#  define context_r14 uc_mcontext.mc_r14\n-#  define context_r15 uc_mcontext.mc_r15\n-#  define context_flags uc_mcontext.mc_flags\n-#  define context_err uc_mcontext.mc_err\n-# else\n-#  define context_pc uc_mcontext.mc_eip\n-#  define context_sp uc_mcontext.mc_esp\n-#  define context_fp uc_mcontext.mc_ebp\n-#  define context_eip uc_mcontext.mc_eip\n-#  define context_esp uc_mcontext.mc_esp\n-#  define context_eax uc_mcontext.mc_eax\n-#  define context_ebx uc_mcontext.mc_ebx\n-#  define context_ecx uc_mcontext.mc_ecx\n-#  define context_edx uc_mcontext.mc_edx\n-#  define context_ebp uc_mcontext.mc_ebp\n-#  define context_esi uc_mcontext.mc_esi\n-#  define context_edi uc_mcontext.mc_edi\n-#  define context_eflags uc_mcontext.mc_eflags\n-#  define context_trapno uc_mcontext.mc_trapno\n-# endif\n+# define context_pc uc_mcontext.mc_rip\n+# define context_sp uc_mcontext.mc_rsp\n+# define context_fp uc_mcontext.mc_rbp\n+# define context_rip uc_mcontext.mc_rip\n+# define context_rsp uc_mcontext.mc_rsp\n+# define context_rbp uc_mcontext.mc_rbp\n+# define context_rax uc_mcontext.mc_rax\n+# define context_rbx uc_mcontext.mc_rbx\n+# define context_rcx uc_mcontext.mc_rcx\n+# define context_rdx uc_mcontext.mc_rdx\n+# define context_rsi uc_mcontext.mc_rsi\n+# define context_rdi uc_mcontext.mc_rdi\n+# define context_r8  uc_mcontext.mc_r8\n+# define context_r9  uc_mcontext.mc_r9\n+# define context_r10 uc_mcontext.mc_r10\n+# define context_r11 uc_mcontext.mc_r11\n+# define context_r12 uc_mcontext.mc_r12\n+# define context_r13 uc_mcontext.mc_r13\n+# define context_r14 uc_mcontext.mc_r14\n+# define context_r15 uc_mcontext.mc_r15\n+# define context_flags uc_mcontext.mc_flags\n+# define context_err uc_mcontext.mc_err\n@@ -149,40 +127,23 @@\n-# ifdef AMD64\n-#  define context_pc context_rip\n-#  define context_sp context_rsp\n-#  define context_fp context_rbp\n-#  define context_rip uc_mcontext->DU3_PREFIX(ss,rip)\n-#  define context_rsp uc_mcontext->DU3_PREFIX(ss,rsp)\n-#  define context_rax uc_mcontext->DU3_PREFIX(ss,rax)\n-#  define context_rbx uc_mcontext->DU3_PREFIX(ss,rbx)\n-#  define context_rcx uc_mcontext->DU3_PREFIX(ss,rcx)\n-#  define context_rdx uc_mcontext->DU3_PREFIX(ss,rdx)\n-#  define context_rbp uc_mcontext->DU3_PREFIX(ss,rbp)\n-#  define context_rsi uc_mcontext->DU3_PREFIX(ss,rsi)\n-#  define context_rdi uc_mcontext->DU3_PREFIX(ss,rdi)\n-#  define context_r8  uc_mcontext->DU3_PREFIX(ss,r8)\n-#  define context_r9  uc_mcontext->DU3_PREFIX(ss,r9)\n-#  define context_r10 uc_mcontext->DU3_PREFIX(ss,r10)\n-#  define context_r11 uc_mcontext->DU3_PREFIX(ss,r11)\n-#  define context_r12 uc_mcontext->DU3_PREFIX(ss,r12)\n-#  define context_r13 uc_mcontext->DU3_PREFIX(ss,r13)\n-#  define context_r14 uc_mcontext->DU3_PREFIX(ss,r14)\n-#  define context_r15 uc_mcontext->DU3_PREFIX(ss,r15)\n-#  define context_flags uc_mcontext->DU3_PREFIX(ss,rflags)\n-#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)\n-#  define context_err uc_mcontext->DU3_PREFIX(es,err)\n-# else\n-#  define context_pc context_eip\n-#  define context_sp context_esp\n-#  define context_fp context_ebp\n-#  define context_eip uc_mcontext->DU3_PREFIX(ss,eip)\n-#  define context_esp uc_mcontext->DU3_PREFIX(ss,esp)\n-#  define context_eax uc_mcontext->DU3_PREFIX(ss,eax)\n-#  define context_ebx uc_mcontext->DU3_PREFIX(ss,ebx)\n-#  define context_ecx uc_mcontext->DU3_PREFIX(ss,ecx)\n-#  define context_edx uc_mcontext->DU3_PREFIX(ss,edx)\n-#  define context_ebp uc_mcontext->DU3_PREFIX(ss,ebp)\n-#  define context_esi uc_mcontext->DU3_PREFIX(ss,esi)\n-#  define context_edi uc_mcontext->DU3_PREFIX(ss,edi)\n-#  define context_eflags uc_mcontext->DU3_PREFIX(ss,eflags)\n-#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)\n-# endif\n+# define context_pc context_rip\n+# define context_sp context_rsp\n+# define context_fp context_rbp\n+# define context_rip uc_mcontext->DU3_PREFIX(ss,rip)\n+# define context_rsp uc_mcontext->DU3_PREFIX(ss,rsp)\n+# define context_rax uc_mcontext->DU3_PREFIX(ss,rax)\n+# define context_rbx uc_mcontext->DU3_PREFIX(ss,rbx)\n+# define context_rcx uc_mcontext->DU3_PREFIX(ss,rcx)\n+# define context_rdx uc_mcontext->DU3_PREFIX(ss,rdx)\n+# define context_rbp uc_mcontext->DU3_PREFIX(ss,rbp)\n+# define context_rsi uc_mcontext->DU3_PREFIX(ss,rsi)\n+# define context_rdi uc_mcontext->DU3_PREFIX(ss,rdi)\n+# define context_r8  uc_mcontext->DU3_PREFIX(ss,r8)\n+# define context_r9  uc_mcontext->DU3_PREFIX(ss,r9)\n+# define context_r10 uc_mcontext->DU3_PREFIX(ss,r10)\n+# define context_r11 uc_mcontext->DU3_PREFIX(ss,r11)\n+# define context_r12 uc_mcontext->DU3_PREFIX(ss,r12)\n+# define context_r13 uc_mcontext->DU3_PREFIX(ss,r13)\n+# define context_r14 uc_mcontext->DU3_PREFIX(ss,r14)\n+# define context_r15 uc_mcontext->DU3_PREFIX(ss,r15)\n+# define context_flags uc_mcontext->DU3_PREFIX(ss,rflags)\n+# define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)\n+# define context_err uc_mcontext->DU3_PREFIX(es,err)\n@@ -193,39 +154,22 @@\n-# ifdef AMD64\n-#  define context_pc sc_rip\n-#  define context_sp sc_rsp\n-#  define context_fp sc_rbp\n-#  define context_rip sc_rip\n-#  define context_rsp sc_rsp\n-#  define context_rbp sc_rbp\n-#  define context_rax sc_rax\n-#  define context_rbx sc_rbx\n-#  define context_rcx sc_rcx\n-#  define context_rdx sc_rdx\n-#  define context_rsi sc_rsi\n-#  define context_rdi sc_rdi\n-#  define context_r8  sc_r8\n-#  define context_r9  sc_r9\n-#  define context_r10 sc_r10\n-#  define context_r11 sc_r11\n-#  define context_r12 sc_r12\n-#  define context_r13 sc_r13\n-#  define context_r14 sc_r14\n-#  define context_r15 sc_r15\n-#  define context_flags sc_rflags\n-#  define context_err sc_err\n-# else\n-#  define context_pc sc_eip\n-#  define context_sp sc_esp\n-#  define context_fp sc_ebp\n-#  define context_eip sc_eip\n-#  define context_esp sc_esp\n-#  define context_eax sc_eax\n-#  define context_ebx sc_ebx\n-#  define context_ecx sc_ecx\n-#  define context_edx sc_edx\n-#  define context_ebp sc_ebp\n-#  define context_esi sc_esi\n-#  define context_edi sc_edi\n-#  define context_eflags sc_eflags\n-#  define context_trapno sc_trapno\n-# endif\n+# define context_pc sc_rip\n+# define context_sp sc_rsp\n+# define context_fp sc_rbp\n+# define context_rip sc_rip\n+# define context_rsp sc_rsp\n+# define context_rbp sc_rbp\n+# define context_rax sc_rax\n+# define context_rbx sc_rbx\n+# define context_rcx sc_rcx\n+# define context_rdx sc_rdx\n+# define context_rsi sc_rsi\n+# define context_rdi sc_rdi\n+# define context_r8  sc_r8\n+# define context_r9  sc_r9\n+# define context_r10 sc_r10\n+# define context_r11 sc_r11\n+# define context_r12 sc_r12\n+# define context_r13 sc_r13\n+# define context_r14 sc_r14\n+# define context_r15 sc_r15\n+# define context_flags sc_rflags\n+# define context_err sc_err\n@@ -236,40 +180,23 @@\n-# ifdef AMD64\n-#  define __register_t __greg_t\n-#  define context_pc uc_mcontext.__gregs[_REG_RIP]\n-#  define context_sp uc_mcontext.__gregs[_REG_URSP]\n-#  define context_fp uc_mcontext.__gregs[_REG_RBP]\n-#  define context_rip uc_mcontext.__gregs[_REG_RIP]\n-#  define context_rsp uc_mcontext.__gregs[_REG_URSP]\n-#  define context_rax uc_mcontext.__gregs[_REG_RAX]\n-#  define context_rbx uc_mcontext.__gregs[_REG_RBX]\n-#  define context_rcx uc_mcontext.__gregs[_REG_RCX]\n-#  define context_rdx uc_mcontext.__gregs[_REG_RDX]\n-#  define context_rbp uc_mcontext.__gregs[_REG_RBP]\n-#  define context_rsi uc_mcontext.__gregs[_REG_RSI]\n-#  define context_rdi uc_mcontext.__gregs[_REG_RDI]\n-#  define context_r8  uc_mcontext.__gregs[_REG_R8]\n-#  define context_r9  uc_mcontext.__gregs[_REG_R9]\n-#  define context_r10 uc_mcontext.__gregs[_REG_R10]\n-#  define context_r11 uc_mcontext.__gregs[_REG_R11]\n-#  define context_r12 uc_mcontext.__gregs[_REG_R12]\n-#  define context_r13 uc_mcontext.__gregs[_REG_R13]\n-#  define context_r14 uc_mcontext.__gregs[_REG_R14]\n-#  define context_r15 uc_mcontext.__gregs[_REG_R15]\n-#  define context_flags uc_mcontext.__gregs[_REG_RFL]\n-#  define context_err uc_mcontext.__gregs[_REG_ERR]\n-# else\n-#  define context_pc uc_mcontext.__gregs[_REG_EIP]\n-#  define context_sp uc_mcontext.__gregs[_REG_UESP]\n-#  define context_fp uc_mcontext.__gregs[_REG_EBP]\n-#  define context_eip uc_mcontext.__gregs[_REG_EIP]\n-#  define context_esp uc_mcontext.__gregs[_REG_UESP]\n-#  define context_eax uc_mcontext.__gregs[_REG_EAX]\n-#  define context_ebx uc_mcontext.__gregs[_REG_EBX]\n-#  define context_ecx uc_mcontext.__gregs[_REG_ECX]\n-#  define context_edx uc_mcontext.__gregs[_REG_EDX]\n-#  define context_ebp uc_mcontext.__gregs[_REG_EBP]\n-#  define context_esi uc_mcontext.__gregs[_REG_ESI]\n-#  define context_edi uc_mcontext.__gregs[_REG_EDI]\n-#  define context_eflags uc_mcontext.__gregs[_REG_EFL]\n-#  define context_trapno uc_mcontext.__gregs[_REG_TRAPNO]\n-# endif\n+# define __register_t __greg_t\n+# define context_pc uc_mcontext.__gregs[_REG_RIP]\n+# define context_sp uc_mcontext.__gregs[_REG_URSP]\n+# define context_fp uc_mcontext.__gregs[_REG_RBP]\n+# define context_rip uc_mcontext.__gregs[_REG_RIP]\n+# define context_rsp uc_mcontext.__gregs[_REG_URSP]\n+# define context_rax uc_mcontext.__gregs[_REG_RAX]\n+# define context_rbx uc_mcontext.__gregs[_REG_RBX]\n+# define context_rcx uc_mcontext.__gregs[_REG_RCX]\n+# define context_rdx uc_mcontext.__gregs[_REG_RDX]\n+# define context_rbp uc_mcontext.__gregs[_REG_RBP]\n+# define context_rsi uc_mcontext.__gregs[_REG_RSI]\n+# define context_rdi uc_mcontext.__gregs[_REG_RDI]\n+# define context_r8  uc_mcontext.__gregs[_REG_R8]\n+# define context_r9  uc_mcontext.__gregs[_REG_R9]\n+# define context_r10 uc_mcontext.__gregs[_REG_R10]\n+# define context_r11 uc_mcontext.__gregs[_REG_R11]\n+# define context_r12 uc_mcontext.__gregs[_REG_R12]\n+# define context_r13 uc_mcontext.__gregs[_REG_R13]\n+# define context_r14 uc_mcontext.__gregs[_REG_R14]\n+# define context_r15 uc_mcontext.__gregs[_REG_R15]\n+# define context_flags uc_mcontext.__gregs[_REG_RFL]\n+# define context_err uc_mcontext.__gregs[_REG_ERR]\n@@ -471,7 +398,5 @@\n-      } else\n-#ifdef AMD64\n-      if (sig == SIGFPE &&\n-          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV\n-           \/\/ Workaround for macOS ARM incorrectly reporting FPE_FLTINV for \"div by 0\"\n-           \/\/ instead of the expected FPE_FLTDIV when running x86_64 binary under Rosetta emulation\n-           MACOS_ONLY(|| (VM_Version::is_cpu_emulated() && info->si_code == FPE_FLTINV)))) {\n+      } else if (sig == SIGFPE &&\n+                 (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV\n+                 \/\/ Workaround for macOS ARM incorrectly reporting FPE_FLTINV for \"div by 0\"\n+                 \/\/ instead of the expected FPE_FLTDIV when running x86_64 binary under Rosetta emulation\n+                 MACOS_ONLY(|| (VM_Version::is_cpu_emulated() && info->si_code == FPE_FLTINV)))) {\n@@ -505,28 +430,0 @@\n-\n-#else\n-      if (sig == SIGFPE \/* && info->si_code == FPE_INTDIV *\/) {\n-        \/\/ HACK: si_code does not work on bsd 2.2.12-20!!!\n-        int op = pc[0];\n-        if (op == 0xDB) {\n-          \/\/ FIST\n-          \/\/ TODO: The encoding of D2I in x86_32.ad can cause an exception\n-          \/\/ prior to the fist instruction if there was an invalid operation\n-          \/\/ pending. We want to dismiss that exception. From the win_32\n-          \/\/ side it also seems that if it really was the fist causing\n-          \/\/ the exception that we do the d2i by hand with different\n-          \/\/ rounding. Seems kind of weird.\n-          \/\/ NOTE: that we take the exception at the NEXT floating point instruction.\n-          assert(pc[0] == 0xDB, \"not a FIST opcode\");\n-          assert(pc[1] == 0x14, \"not a FIST opcode\");\n-          assert(pc[2] == 0x24, \"not a FIST opcode\");\n-          return true;\n-        } else if (op == 0xF7) {\n-          \/\/ IDIV\n-          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);\n-        } else {\n-          \/\/ TODO: handle more cases if we are using other x86 instructions\n-          \/\/   that can generate SIGFPE signal on bsd.\n-          tty->print_cr(\"unknown opcode 0x%X with SIGFPE.\", op);\n-          fatal(\"please update this code.\");\n-        }\n-#endif \/\/ AMD64\n@@ -559,75 +456,0 @@\n-#ifndef AMD64\n-  \/\/ Execution protection violation\n-  \/\/\n-  \/\/ This should be kept as the last step in the triage.  We don't\n-  \/\/ have a dedicated trap number for a no-execute fault, so be\n-  \/\/ conservative and allow other handlers the first shot.\n-  \/\/\n-  \/\/ Note: We don't test that info->si_code == SEGV_ACCERR here.\n-  \/\/ this si_code is so generic that it is almost meaningless; and\n-  \/\/ the si_code for this condition may change in the future.\n-  \/\/ Furthermore, a false-positive should be harmless.\n-  if (UnguardOnExecutionViolation > 0 &&\n-      stub == nullptr &&\n-      (sig == SIGSEGV || sig == SIGBUS) &&\n-      uc->context_trapno == trap_page_fault) {\n-    size_t page_size = os::vm_page_size();\n-    address addr = (address) info->si_addr;\n-    address pc = os::Posix::ucontext_get_pc(uc);\n-    \/\/ Make sure the pc and the faulting address are sane.\n-    \/\/\n-    \/\/ If an instruction spans a page boundary, and the page containing\n-    \/\/ the beginning of the instruction is executable but the following\n-    \/\/ page is not, the pc and the faulting address might be slightly\n-    \/\/ different - we still want to unguard the 2nd page in this case.\n-    \/\/\n-    \/\/ 15 bytes seems to be a (very) safe value for max instruction size.\n-    bool pc_is_near_addr =\n-      (pointer_delta((void*) addr, (void*) pc, sizeof(char)) < 15);\n-    bool instr_spans_page_boundary =\n-      (align_down((intptr_t) pc ^ (intptr_t) addr,\n-                       (intptr_t) page_size) > 0);\n-\n-    if (pc == addr || (pc_is_near_addr && instr_spans_page_boundary)) {\n-      static volatile address last_addr =\n-        (address) os::non_memory_address_word();\n-\n-      \/\/ In conservative mode, don't unguard unless the address is in the VM\n-      if (addr != last_addr &&\n-          (UnguardOnExecutionViolation > 1 || os::address_is_in_vm(addr))) {\n-\n-        \/\/ Set memory to RWX and retry\n-        address page_start = align_down(addr, page_size);\n-        bool res = os::protect_memory((char*) page_start, page_size,\n-                                      os::MEM_PROT_RWX);\n-\n-        log_debug(os)(\"Execution protection violation \"\n-                      \"at \" INTPTR_FORMAT\n-                      \", unguarding \" INTPTR_FORMAT \": %s, errno=%d\", p2i(addr),\n-                      p2i(page_start), (res ? \"success\" : \"failed\"), errno);\n-        stub = pc;\n-\n-        \/\/ Set last_addr so if we fault again at the same address, we don't end\n-        \/\/ up in an endless loop.\n-        \/\/\n-        \/\/ There are two potential complications here.  Two threads trapping at\n-        \/\/ the same address at the same time could cause one of the threads to\n-        \/\/ think it already unguarded, and abort the VM.  Likely very rare.\n-        \/\/\n-        \/\/ The other race involves two threads alternately trapping at\n-        \/\/ different addresses and failing to unguard the page, resulting in\n-        \/\/ an endless loop.  This condition is probably even more unlikely than\n-        \/\/ the first.\n-        \/\/\n-        \/\/ Although both cases could be avoided by using locks or thread local\n-        \/\/ last_addr, these solutions are unnecessary complication: this\n-        \/\/ handler is a best-effort safety net, not a complete solution.  It is\n-        \/\/ disabled by default and should only be used as a workaround in case\n-        \/\/ we missed any no-execute-unsafe VM code.\n-\n-        last_addr = addr;\n-      }\n-    }\n-  }\n-#endif \/\/ !AMD64\n-\n@@ -649,4 +471,0 @@\n-#ifndef AMD64\n-  \/\/ Set fpu to 53 bit precision. This happens too early to use a stub.\n-  fixcw();\n-#endif \/\/ !AMD64\n@@ -674,1 +492,0 @@\n-#ifdef _LP64\n@@ -676,9 +493,0 @@\n-#else\n-size_t os::_vm_internal_thread_min_stack_allowed = (48 DEBUG_ONLY(+ 4)) * K;\n-#endif \/\/ _LP64\n-\n-#ifndef AMD64\n-#ifdef __GNUC__\n-#define GET_GS() ({int gs; __asm__ volatile(\"movw %%gs, %w0\":\"=q\"(gs)); gs&0xffff;})\n-#endif\n-#endif \/\/ AMD64\n@@ -689,1 +497,0 @@\n-#ifdef AMD64\n@@ -691,3 +498,0 @@\n-#else\n-  size_t s = (thr_type == os::compiler_thread ? 2 * M : 512 * K);\n-#endif \/\/ AMD64\n@@ -806,1 +610,0 @@\n-#ifdef AMD64\n@@ -832,14 +635,0 @@\n-#else\n-  st->print(  \"EAX=\" INTPTR_FORMAT, (intptr_t)uc->context_eax);\n-  st->print(\", EBX=\" INTPTR_FORMAT, (intptr_t)uc->context_ebx);\n-  st->print(\", ECX=\" INTPTR_FORMAT, (intptr_t)uc->context_ecx);\n-  st->print(\", EDX=\" INTPTR_FORMAT, (intptr_t)uc->context_edx);\n-  st->cr();\n-  st->print(  \"ESP=\" INTPTR_FORMAT, (intptr_t)uc->context_esp);\n-  st->print(\", EBP=\" INTPTR_FORMAT, (intptr_t)uc->context_ebp);\n-  st->print(\", ESI=\" INTPTR_FORMAT, (intptr_t)uc->context_esi);\n-  st->print(\", EDI=\" INTPTR_FORMAT, (intptr_t)uc->context_edi);\n-  st->cr();\n-  st->print(  \"EIP=\" INTPTR_FORMAT, (intptr_t)uc->context_eip);\n-  st->print(\", EFLAGS=\" INTPTR_FORMAT, (intptr_t)uc->context_eflags);\n-#endif \/\/ AMD64\n@@ -851,1 +640,1 @@\n-  const int register_count = AMD64_ONLY(16) NOT_AMD64(8);\n+  const int register_count = 16;\n@@ -864,1 +653,0 @@\n-#ifdef AMD64\n@@ -881,11 +669,1 @@\n-#else\n-    CASE_PRINT_REG(0, \"EAX=\", eax); break;\n-    CASE_PRINT_REG(1, \"EBX=\", ebx); break;\n-    CASE_PRINT_REG(2, \"ECX=\", ecx); break;\n-    CASE_PRINT_REG(3, \"EDX=\", edx); break;\n-    CASE_PRINT_REG(4, \"ESP=\", esp); break;\n-    CASE_PRINT_REG(5, \"EBP=\", ebp); break;\n-    CASE_PRINT_REG(6, \"ESI=\", esi); break;\n-    CASE_PRINT_REG(7, \"EDI=\", edi); break;\n-#endif \/\/ AMD64\n-    }\n+  }\n@@ -898,5 +676,0 @@\n-#ifndef AMD64\n-  address fpu_cntrl = StubRoutines::addr_fpu_cntrl_wrd_std();\n-  __asm__ volatile (  \"fldcw (%0)\" :\n-                      : \"r\" (fpu_cntrl) : \"memory\");\n-#endif \/\/ !AMD64\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":97,"deletions":324,"binary":false,"changes":421,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,6 +42,0 @@\n-#ifndef AMD64\n-  \/\/ 64 bit result in edx:eax\n-  uint64_t res;\n-  __asm__ __volatile__ (\"rdtsc\" : \"=A\" (res));\n-  return (jlong)res;\n-#else\n@@ -53,1 +47,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.inline.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#ifdef AMD64\n@@ -34,1 +33,0 @@\n-#endif \/\/ AMD64\n@@ -38,2 +36,0 @@\n-#ifdef AMD64\n-\n@@ -43,2 +39,0 @@\n-\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/prefetch_bsd_x86.inline.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-#ifdef AMD64\n-\n@@ -138,45 +136,0 @@\n-#else \/\/ !AMD64\n-\n-extern \"C\" {\n-  \/\/ defined in linux_x86.s\n-  int64_t _Atomic_cmpxchg_long(int64_t, volatile int64_t*, int64_t);\n-  void _Atomic_move_long(const volatile int64_t* src, volatile int64_t* dst);\n-}\n-\n-template<>\n-template<typename T>\n-inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                      T compare_value,\n-                                                      T exchange_value,\n-                                                      atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  return cmpxchg_using_helper<int64_t>(_Atomic_cmpxchg_long, dest, compare_value, exchange_value);\n-}\n-\n-\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n-template<>\n-struct AtomicAccess::PlatformXchg<8> : AtomicAccess::XchgUsingCmpxchg<8> {};\n-\n-\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n-template<>\n-struct AtomicAccess::PlatformAdd<8> : AtomicAccess::AddUsingCmpxchg<8> {};\n-\n-template<>\n-template<typename T>\n-inline T AtomicAccess::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  volatile int64_t dest;\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(src), reinterpret_cast<volatile int64_t*>(&dest));\n-  return PrimitiveConversions::cast<T>(dest);\n-}\n-\n-template<>\n-template<typename T>\n-inline void AtomicAccess::PlatformStore<8>::operator()(T volatile* dest,\n-                                                       T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(&store_value), reinterpret_cast<volatile int64_t*>(dest));\n-}\n-\n-#endif \/\/ AMD64\n-\n@@ -219,1 +172,0 @@\n-#ifdef AMD64\n@@ -231,1 +183,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomicAccess_linux_x86.hpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#ifdef AMD64\n@@ -35,14 +34,0 @@\n-#else\n-\/\/ Some tests in debug VM mode run out of compile thread stack.\n-\/\/ Observed on some x86_32 VarHandles tests during escape analysis.\n-#ifdef ASSERT\n-define_pd_global(intx, CompilerThreadStackSize,   768);\n-#else\n-define_pd_global(intx, CompilerThreadStackSize,   512);\n-#endif\n-\/\/ ThreadStackSize 320 allows a couple of test cases to run while\n-\/\/ keeping the number of threads that can be created high.  System\n-\/\/ default ThreadStackSize appears to be 512 which is too big.\n-define_pd_global(intx, ThreadStackSize,          320);\n-define_pd_global(intx, VMThreadStackSize,        512);\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/globals_linux_x86.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,1 @@\n-   \/\/ always use locked addl since mfence is sometimes expensive\n-#ifdef AMD64\n+  \/\/ always use locked addl since mfence is sometimes expensive\n@@ -52,3 +51,0 @@\n-#else\n-  __asm__ volatile (\"lock; addl $0,0(%%esp)\" : : : \"cc\", \"memory\");\n-#endif\n@@ -63,1 +59,0 @@\n-#ifdef AMD64\n@@ -65,5 +60,0 @@\n-#else\n-    \/\/ On some x86 systems EBX is a reserved register that cannot be\n-    \/\/ clobbered, so we must protect it around the CPUID.\n-    __asm__ volatile (\"xchg %%esi, %%ebx; cpuid; xchg %%esi, %%ebx \" : \"+a\" (idx) : : \"esi\", \"ecx\", \"edx\", \"memory\");\n-#endif\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/orderAccess_linux_x86.hpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,3 +75,0 @@\n-#ifndef AMD64\n-# include <fpu_control.h>\n-#endif\n@@ -79,1 +76,0 @@\n-#ifdef AMD64\n@@ -86,7 +82,0 @@\n-#else\n-#define REG_SP REG_UESP\n-#define REG_PC REG_EIP\n-#define REG_FP REG_EBP\n-#define SPELL_REG_SP \"esp\"\n-#define SPELL_REG_FP \"ebp\"\n-#endif \/\/ AMD64\n@@ -284,4 +273,2 @@\n-      } else\n-#ifdef AMD64\n-      if (sig == SIGFPE &&\n-          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n+      } else if (sig == SIGFPE &&\n+                 (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n@@ -294,27 +281,0 @@\n-#else\n-      if (sig == SIGFPE \/* && info->si_code == FPE_INTDIV *\/) {\n-        \/\/ HACK: si_code does not work on linux 2.2.12-20!!!\n-        int op = pc[0];\n-        if (op == 0xDB) {\n-          \/\/ FIST\n-          \/\/ TODO: The encoding of D2I in x86_32.ad can cause an exception\n-          \/\/ prior to the fist instruction if there was an invalid operation\n-          \/\/ pending. We want to dismiss that exception. From the win_32\n-          \/\/ side it also seems that if it really was the fist causing\n-          \/\/ the exception that we do the d2i by hand with different\n-          \/\/ rounding. Seems kind of weird.\n-          \/\/ NOTE: that we take the exception at the NEXT floating point instruction.\n-          assert(pc[0] == 0xDB, \"not a FIST opcode\");\n-          assert(pc[1] == 0x14, \"not a FIST opcode\");\n-          assert(pc[2] == 0x24, \"not a FIST opcode\");\n-          return true;\n-        } else if (op == 0xF7) {\n-          \/\/ IDIV\n-          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);\n-        } else {\n-          \/\/ TODO: handle more cases if we are using other x86 instructions\n-          \/\/   that can generate SIGFPE signal on linux.\n-          tty->print_cr(\"unknown opcode 0x%X with SIGFPE.\", op);\n-          fatal(\"please update this code.\");\n-        }\n-#endif \/\/ AMD64\n@@ -347,75 +307,0 @@\n-#ifndef AMD64\n-  \/\/ Execution protection violation\n-  \/\/\n-  \/\/ This should be kept as the last step in the triage.  We don't\n-  \/\/ have a dedicated trap number for a no-execute fault, so be\n-  \/\/ conservative and allow other handlers the first shot.\n-  \/\/\n-  \/\/ Note: We don't test that info->si_code == SEGV_ACCERR here.\n-  \/\/ this si_code is so generic that it is almost meaningless; and\n-  \/\/ the si_code for this condition may change in the future.\n-  \/\/ Furthermore, a false-positive should be harmless.\n-  if (UnguardOnExecutionViolation > 0 &&\n-      stub == nullptr &&\n-      (sig == SIGSEGV || sig == SIGBUS) &&\n-      uc->uc_mcontext.gregs[REG_TRAPNO] == trap_page_fault) {\n-    size_t page_size = os::vm_page_size();\n-    address addr = (address) info->si_addr;\n-    address pc = os::Posix::ucontext_get_pc(uc);\n-    \/\/ Make sure the pc and the faulting address are sane.\n-    \/\/\n-    \/\/ If an instruction spans a page boundary, and the page containing\n-    \/\/ the beginning of the instruction is executable but the following\n-    \/\/ page is not, the pc and the faulting address might be slightly\n-    \/\/ different - we still want to unguard the 2nd page in this case.\n-    \/\/\n-    \/\/ 15 bytes seems to be a (very) safe value for max instruction size.\n-    bool pc_is_near_addr =\n-      (pointer_delta((void*) addr, (void*) pc, sizeof(char)) < 15);\n-    bool instr_spans_page_boundary =\n-      (align_down((intptr_t) pc ^ (intptr_t) addr,\n-                       (intptr_t) page_size) > 0);\n-\n-    if (pc == addr || (pc_is_near_addr && instr_spans_page_boundary)) {\n-      static volatile address last_addr =\n-        (address) os::non_memory_address_word();\n-\n-      \/\/ In conservative mode, don't unguard unless the address is in the VM\n-      if (addr != last_addr &&\n-          (UnguardOnExecutionViolation > 1 || os::address_is_in_vm(addr))) {\n-\n-        \/\/ Set memory to RWX and retry\n-        address page_start = align_down(addr, page_size);\n-        bool res = os::protect_memory((char*) page_start, page_size,\n-                                      os::MEM_PROT_RWX);\n-\n-        log_debug(os)(\"Execution protection violation \"\n-                      \"at \" INTPTR_FORMAT\n-                      \", unguarding \" INTPTR_FORMAT \": %s, errno=%d\", p2i(addr),\n-                      p2i(page_start), (res ? \"success\" : \"failed\"), errno);\n-        stub = pc;\n-\n-        \/\/ Set last_addr so if we fault again at the same address, we don't end\n-        \/\/ up in an endless loop.\n-        \/\/\n-        \/\/ There are two potential complications here.  Two threads trapping at\n-        \/\/ the same address at the same time could cause one of the threads to\n-        \/\/ think it already unguarded, and abort the VM.  Likely very rare.\n-        \/\/\n-        \/\/ The other race involves two threads alternately trapping at\n-        \/\/ different addresses and failing to unguard the page, resulting in\n-        \/\/ an endless loop.  This condition is probably even more unlikely than\n-        \/\/ the first.\n-        \/\/\n-        \/\/ Although both cases could be avoided by using locks or thread local\n-        \/\/ last_addr, these solutions are unnecessary complication: this\n-        \/\/ handler is a best-effort safety net, not a complete solution.  It is\n-        \/\/ disabled by default and should only be used as a workaround in case\n-        \/\/ we missed any no-execute-unsafe VM code.\n-\n-        last_addr = addr;\n-      }\n-    }\n-  }\n-#endif \/\/ !AMD64\n-\n@@ -434,4 +319,0 @@\n-#ifndef AMD64\n-  \/\/ set fpu to 53 bit precision\n-  set_fpu_control_word(0x27f);\n-#endif \/\/ !AMD64\n@@ -441,1 +322,0 @@\n-#ifdef AMD64\n@@ -443,5 +323,0 @@\n-#else\n-  int fpu_control;\n-  _FPU_GETCW(fpu_control);\n-  return fpu_control & 0xffff;\n-#endif \/\/ AMD64\n@@ -451,3 +326,0 @@\n-#ifndef AMD64\n-  _FPU_SETCW(fpu_control);\n-#endif \/\/ !AMD64\n@@ -499,1 +371,0 @@\n-#ifdef _LP64\n@@ -501,3 +372,0 @@\n-#else\n-size_t os::_vm_internal_thread_min_stack_allowed = (48 DEBUG_ONLY(+ 4)) * K;\n-#endif \/\/ _LP64\n@@ -508,1 +376,0 @@\n-#ifdef AMD64\n@@ -510,3 +377,0 @@\n-#else\n-  size_t s = (thr_type == os::compiler_thread ? 2 * M : 512 * K);\n-#endif \/\/ AMD64\n@@ -525,1 +389,0 @@\n-#ifdef AMD64\n@@ -567,15 +430,0 @@\n-#else\n-  st->print(  \"EAX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EAX]);\n-  st->print(\", EBX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBX]);\n-  st->print(\", ECX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ECX]);\n-  st->print(\", EDX=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDX]);\n-  st->cr();\n-  st->print(  \"ESP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_UESP]);\n-  st->print(\", EBP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBP]);\n-  st->print(\", ESI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ESI]);\n-  st->print(\", EDI=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDI]);\n-  st->cr();\n-  st->print(  \"EIP=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EIP]);\n-  st->print(\", EFLAGS=\" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);\n-  st->print(\", CR2=\" UINT64_FORMAT_X_0, (uint64_t)uc->uc_mcontext.cr2);\n-#endif \/\/ AMD64\n@@ -587,1 +435,1 @@\n-  const int register_count = AMD64_ONLY(16) NOT_AMD64(8);\n+  const int register_count = 16;\n@@ -600,1 +448,0 @@\n-#ifdef AMD64\n@@ -617,10 +464,0 @@\n-#else\n-    CASE_PRINT_REG(0, \"EAX=\", EAX); break;\n-    CASE_PRINT_REG(1, \"EBX=\", EBX); break;\n-    CASE_PRINT_REG(2, \"ECX=\", ECX); break;\n-    CASE_PRINT_REG(3, \"EDX=\", EDX); break;\n-    CASE_PRINT_REG(4, \"ESP=\", ESP); break;\n-    CASE_PRINT_REG(5, \"EBP=\", EBP); break;\n-    CASE_PRINT_REG(6, \"ESI=\", ESI); break;\n-    CASE_PRINT_REG(7, \"EDI=\", EDI); break;\n-#endif \/\/ AMD64\n@@ -634,5 +471,0 @@\n-#ifndef AMD64\n-  address fpu_cntrl = StubRoutines::x86::addr_fpu_cntrl_wrd_std();\n-  __asm__ volatile (  \"fldcw (%0)\" :\n-                      : \"r\" (fpu_cntrl) : \"memory\");\n-#endif \/\/ !AMD64\n@@ -643,1 +475,0 @@\n-#ifdef AMD64\n@@ -645,1 +476,0 @@\n-#endif\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":3,"deletions":173,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,6 +32,0 @@\n-#ifndef AMD64\n-  \/\/ 64 bit result in edx:eax\n-  uint64_t res;\n-  __asm__ __volatile__ (\"rdtsc\" : \"=A\" (res));\n-  return (jlong)res;\n-#else\n@@ -43,1 +37,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.inline.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#ifdef AMD64\n@@ -34,1 +33,0 @@\n-#endif \/\/ AMD64\n@@ -38,2 +36,0 @@\n-#ifdef AMD64\n-\n@@ -43,2 +39,0 @@\n-\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/prefetch_linux_x86.inline.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-#if defined(_M_AMD64)\n@@ -200,1 +199,0 @@\n-#endif\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n+    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, ClassInitMode::dont_init, CHECK);\n@@ -327,1 +327,1 @@\n-    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n+    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, ClassInitMode::dont_init, CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -87,0 +88,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -524,1 +526,13 @@\n-static void rewrite_nofast_bytecode(const methodHandle& method) {\n+\/\/ In AOTCache workflow, when dumping preimage, the constant pool entries are stored in unresolved state.\n+\/\/ So the fast version of getfield\/putfield needs to be converted to nofast version.\n+\/\/ When dumping the final image in the assembly phase, these nofast versions are converted back to fast versions\n+\/\/ if the constant pool entry refered by these bytecodes is stored in resolved state.\n+\/\/ Same principle applies to static and dynamic archives. If the constant pool entry is in resolved state, then\n+\/\/ the fast version of the bytecodes can be preserved, else use the nofast version.\n+\/\/\n+\/\/ The fast versions of aload_0 (i.e. _fast_Xaccess_0) merges the bytecode pair (aload_0, fast_Xgetfield).\n+\/\/ If the fast version of aload_0 is preserved in AOTCache, then the JVMTI notifications for field access and\n+\/\/ breakpoint events will be skipped for the second bytecode (fast_Xgetfield) in the pair.\n+\/\/ Same holds for fast versions of iload_0. So for these bytecodes, nofast version is used.\n+static void rewrite_bytecodes(const methodHandle& method) {\n+  ConstantPool* cp = method->constants();\n@@ -526,0 +540,9 @@\n+  Bytecodes::Code new_code;\n+\n+  LogStreamHandle(Trace, aot, resolve) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Rewriting bytecodes for \");\n+    method()->print_external_name(&lsh);\n+    lsh.print(\"\\n\");\n+  }\n+\n@@ -528,5 +551,59 @@\n-    switch (opcode) {\n-    case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;\n-    case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;\n-    case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;\n-    case Bytecodes::_iload: {\n+    \/\/ Use current opcode as the default value of new_code\n+    new_code = opcode;\n+    switch(opcode) {\n+    case Bytecodes::_getfield: {\n+      uint rfe_index = bcs.get_index_u2();\n+      bool is_resolved = cp->is_resolved(rfe_index, opcode);\n+      if (is_resolved) {\n+        assert(!CDSConfig::is_dumping_preimage_static_archive(), \"preimage should not have resolved field references\");\n+        ResolvedFieldEntry* rfe = cp->resolved_field_entry_at(bcs.get_index_u2());\n+        switch(rfe->tos_state()) {\n+        case btos:\n+          \/\/ fallthrough\n+        case ztos: new_code = Bytecodes::_fast_bgetfield; break;\n+        case atos: new_code = Bytecodes::_fast_agetfield; break;\n+        case itos: new_code = Bytecodes::_fast_igetfield; break;\n+        case ctos: new_code = Bytecodes::_fast_cgetfield; break;\n+        case stos: new_code = Bytecodes::_fast_sgetfield; break;\n+        case ltos: new_code = Bytecodes::_fast_lgetfield; break;\n+        case ftos: new_code = Bytecodes::_fast_fgetfield; break;\n+        case dtos: new_code = Bytecodes::_fast_dgetfield; break;\n+        default:\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      } else {\n+        new_code = Bytecodes::_nofast_getfield;\n+      }\n+      break;\n+    }\n+    case Bytecodes::_putfield: {\n+      uint rfe_index = bcs.get_index_u2();\n+      bool is_resolved = cp->is_resolved(rfe_index, opcode);\n+      if (is_resolved) {\n+        assert(!CDSConfig::is_dumping_preimage_static_archive(), \"preimage should not have resolved field references\");\n+        ResolvedFieldEntry* rfe = cp->resolved_field_entry_at(bcs.get_index_u2());\n+        switch(rfe->tos_state()) {\n+        case btos: new_code = Bytecodes::_fast_bputfield; break;\n+        case ztos: new_code = Bytecodes::_fast_zputfield; break;\n+        case atos: new_code = Bytecodes::_fast_aputfield; break;\n+        case itos: new_code = Bytecodes::_fast_iputfield; break;\n+        case ctos: new_code = Bytecodes::_fast_cputfield; break;\n+        case stos: new_code = Bytecodes::_fast_sputfield; break;\n+        case ltos: new_code = Bytecodes::_fast_lputfield; break;\n+        case ftos: new_code = Bytecodes::_fast_fputfield; break;\n+        case dtos: new_code = Bytecodes::_fast_dputfield; break;\n+        default:\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      } else {\n+        new_code = Bytecodes::_nofast_putfield;\n+      }\n+      break;\n+    }\n+    case Bytecodes::_aload_0:\n+      \/\/ Revert _fast_Xaccess_0 or _aload_0 to _nofast_aload_0\n+      new_code = Bytecodes::_nofast_aload_0;\n+      break;\n+    case Bytecodes::_iload:\n@@ -534,1 +611,1 @@\n-        *bcs.bcp() = Bytecodes::_nofast_iload;\n+        new_code = Bytecodes::_nofast_iload;\n@@ -537,0 +614,2 @@\n+    default:\n+      break;\n@@ -538,1 +617,5 @@\n-    default: break;\n+    if (opcode != new_code) {\n+      *bcs.bcp() = new_code;\n+      if (lsh.is_enabled()) {\n+        lsh.print_cr(\"%d:%s -> %s\", bcs.bci(), Bytecodes::name(opcode), Bytecodes::name(new_code));\n+      }\n@@ -546,1 +629,1 @@\n-void AOTMetaspace::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {\n+void AOTMetaspace::rewrite_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {\n@@ -550,1 +633,1 @@\n-      rewrite_nofast_bytecode(m);\n+      rewrite_bytecodes(m);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":93,"deletions":10,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik);\n+  static void rewrite_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -961,1 +961,1 @@\n-      AOTMetaspace::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n+      AOTMetaspace::rewrite_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1817,1 +1817,2 @@\n-          name != vmSymbols::java_lang_NullPointerException()) {\n+          name != vmSymbols::java_lang_NullPointerException() &&\n+          name != vmSymbols::jdk_internal_vm_PreemptedException()) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1066,1 +1066,3 @@\n-    assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n+\n+    assert(compiler->type() == compiler_c2 ||\n+           offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -480,1 +480,1 @@\n-  LinkResolver::resolve_field(result, link_info, bc, false, CHECK_AND_CLEAR_(false));\n+  LinkResolver::resolve_field(result, link_info, bc, ClassInitMode::dont_init, CHECK_AND_CLEAR_(false));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5869,0 +5869,1 @@\n+    guarantee_property((u4)cp_size < 0xffff, \"Overflow in constant pool size for hidden class %s\", CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2153,0 +2153,1 @@\n+int java_lang_VirtualThread::_interruptible_wait_offset;\n@@ -2164,0 +2165,1 @@\n+  macro(_interruptible_wait_offset,        k, \"interruptibleWait\",  bool_signature,              false); \\\n@@ -2233,0 +2235,4 @@\n+void java_lang_VirtualThread::set_interruptible_wait(oop vthread, jboolean value) {\n+  vthread->bool_field_put_volatile(_interruptible_wait_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -571,0 +571,1 @@\n+  static int _interruptible_wait_offset;\n@@ -623,0 +624,1 @@\n+  static void set_interruptible_wait(oop vthread, jboolean value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  do_klass(PreemptedException_klass,                    jdk_internal_vm_PreemptedException                    ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+  template(jdk_internal_vm_PreemptedException,        \"jdk\/internal\/vm\/PreemptedException\")       \\\n@@ -545,0 +546,2 @@\n+  template(atKlassInit_name,                          \"atKlassInit\")                              \\\n+  template(hasArgsAtTop_name,                         \"hasArgsAtTop\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -56,2 +57,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1161,2 +1161,1 @@\n-    + align_up(debug_info->data_size()           , oopSize)\n-    + ImmutableDataReferencesCounterSize;\n+    + align_up(debug_info->data_size()           , oopSize);\n@@ -1167,0 +1166,1 @@\n+    immutable_data_size += ImmutableDataRefCountSize;\n@@ -1320,1 +1320,1 @@\n-    _deopt_handler_offset    = 0;\n+    _deopt_handler_entry_offset    = 0;\n@@ -1341,1 +1341,1 @@\n-    _immutable_data_reference_counter_offset = 0;\n+    _immutable_data_ref_count_offset = 0;\n@@ -1460,1 +1460,1 @@\n-  _deopt_handler_offset         = nm._deopt_handler_offset;\n+  _deopt_handler_entry_offset   = nm._deopt_handler_entry_offset;\n@@ -1474,1 +1474,1 @@\n-  _immutable_data_reference_counter_offset = nm._immutable_data_reference_counter_offset;\n+  _immutable_data_ref_count_offset = nm._immutable_data_ref_count_offset;\n@@ -1479,1 +1479,1 @@\n-    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n+    inc_immutable_data_ref_count();\n@@ -1722,1 +1722,1 @@\n-        _deopt_handler_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n+        _deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -1724,1 +1724,1 @@\n-        _deopt_handler_offset    = -1;\n+        _deopt_handler_entry_offset    = -1;\n@@ -1730,1 +1730,0 @@\n-      assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must be set\");\n@@ -1733,2 +1732,10 @@\n-      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n-      _deopt_handler_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      bool has_exception_handler = (offsets->value(CodeOffsets::Exceptions) != -1);\n+      assert(has_exception_handler == (compiler->type() != compiler_c2),\n+             \"C2 compiler doesn't provide exception handler stub code.\");\n+      if (has_exception_handler) {\n+        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      } else {\n+        _exception_offset = -1;\n+      }\n+\n+      _deopt_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -1776,2 +1783,1 @@\n-    _immutable_data_reference_counter_offset = _speculations_offset + align_up(speculations_len, oopSize);\n-    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n+    _immutable_data_ref_count_offset = _speculations_offset + align_up(speculations_len, oopSize);\n@@ -1779,2 +1785,1 @@\n-    _immutable_data_reference_counter_offset =  _scopes_data_offset + align_up(debug_info->data_size(), oopSize);\n-    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_reference_counter_offset + ImmutableDataReferencesCounterSize; )\n+    _immutable_data_ref_count_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize);\n@@ -1782,0 +1787,1 @@\n+    DEBUG_ONLY( int immutable_data_end_offset = _immutable_data_ref_count_offset + ImmutableDataRefCountSize; )\n@@ -1813,1 +1819,1 @@\n-    set_immutable_data_references_counter(1);\n+    init_immutable_data_ref_count();\n@@ -2446,6 +2452,2 @@\n-    int reference_count = get_immutable_data_references_counter();\n-    assert(reference_count > 0, \"immutable data has no references\");\n-\n-    set_immutable_data_references_counter(reference_count - 1);\n-    \/\/ Free memory if this is the last nmethod referencing immutable data\n-    if (reference_count == 0) {\n+    \/\/ Free memory if this was the last nmethod referencing immutable data\n+    if (dec_immutable_data_ref_count() == 0) {\n@@ -4054,1 +4056,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_offset != -1 &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -172,1 +173,1 @@\n-  #define ImmutableDataReferencesCounterSize ((int)sizeof(int))\n+  #define ImmutableDataRefCountSize ((int)sizeof(int))\n@@ -236,1 +237,1 @@\n-  int _deopt_handler_offset;\n+  int _deopt_handler_entry_offset;\n@@ -258,1 +259,1 @@\n-  int      _immutable_data_reference_counter_offset;\n+  int      _immutable_data_ref_count_offset;\n@@ -624,1 +625,1 @@\n-  address deopt_handler_begin   () const { return           header_begin() + _deopt_handler_offset    ; }\n+  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n@@ -655,1 +656,1 @@\n-  address speculations_end      () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n+  address speculations_end      () const { return           _immutable_data + _immutable_data_ref_count_offset ; }\n@@ -657,1 +658,1 @@\n-  address scopes_data_end       () const { return           _immutable_data + _immutable_data_reference_counter_offset ; }\n+  address scopes_data_end       () const { return           _immutable_data + _immutable_data_ref_count_offset ; }\n@@ -659,1 +660,1 @@\n-  address immutable_data_references_counter_begin () const { return _immutable_data + _immutable_data_reference_counter_offset ; }\n+  address immutable_data_ref_count_begin () const { return  _immutable_data + _immutable_data_ref_count_offset ; }\n@@ -983,2 +984,18 @@\n-  inline int  get_immutable_data_references_counter()           { return *((int*)immutable_data_references_counter_begin());  }\n-  inline void set_immutable_data_references_counter(int count)  { *((int*)immutable_data_references_counter_begin()) = count; }\n+  inline void init_immutable_data_ref_count() {\n+    assert(is_not_installed(), \"should be called in nmethod constructor\");\n+    *((int*)immutable_data_ref_count_begin()) = 1;\n+  }\n+\n+  inline int inc_immutable_data_ref_count() {\n+    assert_lock_strong(CodeCache_lock);\n+    int* ref_count = (int*)immutable_data_ref_count_begin();\n+    assert(*ref_count > 0, \"Must be positive\");\n+    return ++(*ref_count);\n+  }\n+\n+  inline int dec_immutable_data_ref_count() {\n+    assert_lock_strong(CodeCache_lock);\n+    int* ref_count = (int*)immutable_data_ref_count_begin();\n+    assert(*ref_count > 0, \"Must be positive\");\n+    return --(*ref_count);\n+  }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return pc == deopt_handler_begin();\n+  return pc == deopt_handler_entry();\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -40,1 +41,0 @@\n-#include <type_traits>\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CPPSTDLIB_CSTDDEF_HPP\n+#define SHARE_CPPSTDLIB_CSTDDEF_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+\n+\/\/ HotSpot usage for <cstddef>:\n+\/\/ permitted:\n+\/\/ * std::max_align_t, std::nullptr_t\n+\/\/ * size_t (preferred) and std::size_t\n+\/\/ * ptrdiff_t (preferred) and std::ptrdiff_t\n+\/\/ * offsetof\n+\/\/\n+\/\/ forbidden:\n+\/\/ * <upcase>null<\/> macro - use nullptr instead.\n+\/\/ * std::byte\n+\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+\n+#include <cstddef>\n+\n+#include \"utilities\/vmassert_reinstall.hpp\" \/\/ don't reorder\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+#endif \/\/ SHARE_CPPSTDLIB_CSTDDEF_HPP\n","filename":"src\/hotspot\/share\/cppstdlib\/cstddef.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CPPSTDLIB_LIMITS_HPP\n+#define SHARE_CPPSTDLIB_LIMITS_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+\n+\/\/ HotSpot usage for <limits>:\n+\/\/ No restrictions on the facilities in this header.\n+\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+\n+#include <limits>\n+\n+#include \"utilities\/vmassert_reinstall.hpp\" \/\/ don't reorder\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+#endif \/\/ SHARE_CPPSTDLIB_LIMITS_HPP\n","filename":"src\/hotspot\/share\/cppstdlib\/limits.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CPPSTDLIB_TYPE_TRAITS_HPP\n+#define SHARE_CPPSTDLIB_TYPE_TRAITS_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+\n+\/\/ HotSpot usage for <type_traits>:\n+\/\/ * Use the `alignof` operator instead of `std::alignment_of<>`.\n+\/\/ * Do not use `std::aligned_storage<>` or `std::aligned_union<>`. These are\n+\/\/   deprecated in C++23, with the rationale that the `alignas` operator\n+\/\/   provides a better mechanism for accomplishing the same task.\n+\/\/\n+\/\/ Other than the above, no restrictions on the facilities in this header.\n+\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+\n+#include <type_traits>\n+\n+#include \"utilities\/vmassert_reinstall.hpp\" \/\/ don't reorder\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+#endif \/\/ SHARE_CPPSTDLIB_TYPE_TRAITS_HPP\n","filename":"src\/hotspot\/share\/cppstdlib\/type_traits.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -94,1 +94,1 @@\n-size_t EpsilonHeap::unsafe_max_tlab_alloc(Thread* thr) const {\n+size_t EpsilonHeap::unsafe_max_tlab_alloc() const {\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,4 +93,4 @@\n-  size_t tlab_capacity(Thread* thr)         const override { return capacity();     }\n-  size_t tlab_used(Thread* thr)             const override { return used();         }\n-  size_t max_tlab_size()                    const override { return _max_tlab_size; }\n-  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  size_t tlab_capacity()         const override { return capacity();     }\n+  size_t tlab_used()             const override { return used();         }\n+  size_t max_tlab_size()         const override { return _max_tlab_size; }\n+  size_t unsafe_max_tlab_alloc() const override;\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/c1\/modRefBarrierSetC1.hpp\"\n+#include \"gc\/shared\/c1\/cardTableBarrierSetC1.hpp\"\n@@ -96,1 +96,1 @@\n-class G1BarrierSetC1 : public ModRefBarrierSetC1 {\n+class G1BarrierSetC1 : public CardTableBarrierSetC1 {\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  class AccessBarrier: public ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT> {\n-    typedef ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT> ModRef;\n+  class AccessBarrier: public CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT> {\n+    typedef CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT> CardTableBS;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  oop value = ModRef::oop_load_not_in_heap(addr);\n+  oop value = CardTableBS::oop_load_not_in_heap(addr);\n@@ -106,1 +106,1 @@\n-  oop value = ModRef::oop_load_in_heap(addr);\n+  oop value = CardTableBS::oop_load_in_heap(addr);\n@@ -114,1 +114,1 @@\n-  oop value = ModRef::oop_load_in_heap_at(base, offset);\n+  oop value = CardTableBS::oop_load_in_heap_at(base, offset);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -654,0 +654,6 @@\n+\/\/ Helper for [try_]collect().\n+static G1GCCounters collection_counters(G1CollectedHeap* g1h) {\n+  MutexLocker ml(Heap_lock);\n+  return G1GCCounters(g1h);\n+}\n+\n@@ -679,1 +685,1 @@\n-    collect(GCCause::_g1_humongous_allocation);\n+    try_collect(word_size, GCCause::_g1_humongous_allocation, collection_counters(this));\n@@ -689,0 +695,2 @@\n+    \/\/ The amount of bytes the humongous object will actually take.\n+    size_t humongous_byte_size = G1HeapRegion::align_up_to_region_byte_size(word_size * HeapWordSize);\n@@ -693,1 +701,0 @@\n-      size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n@@ -700,1 +707,1 @@\n-          add_allocated_humongous_bytes_since_last_gc(size_in_regions * G1HeapRegion::GrainBytes);\n+          add_allocated_humongous_bytes_since_last_gc(humongous_byte_size);\n@@ -714,1 +721,0 @@\n-        size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n@@ -716,1 +722,1 @@\n-          record_collection_pause_humongous_allocation(size_in_regions * G1HeapRegion::GrainBytes);\n+          record_collection_pause_humongous_allocation(humongous_byte_size);\n@@ -766,1 +772,3 @@\n-    if (result != nullptr && policy()->need_to_start_conc_mark(\"STW humongous allocation\")) {\n+    if (result != nullptr &&\n+        \/\/ We just allocated the humongous object, so the given allocation size is 0.\n+        policy()->need_to_start_conc_mark(\"STW humongous allocation\", 0 \/* allocation_word_size *\/)) {\n@@ -905,3 +913,3 @@\n-void G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n-                                         bool do_maximal_compaction,\n-                                         size_t allocation_word_size) {\n+void G1CollectedHeap::do_full_collection(size_t allocation_word_size,\n+                                         bool clear_all_soft_refs,\n+                                         bool do_maximal_compaction) {\n@@ -924,3 +932,3 @@\n-  do_full_collection(clear_all_soft_refs,\n-                     false \/* do_maximal_compaction *\/,\n-                     size_t(0) \/* allocation_word_size *\/);\n+  do_full_collection(size_t(0) \/* allocation_word_size *\/,\n+                     clear_all_soft_refs,\n+                     false \/* do_maximal_compaction *\/);\n@@ -932,3 +940,3 @@\n-  do_full_collection(true  \/* clear_all_soft_refs *\/,\n-                     false \/* do_maximal_compaction *\/,\n-                     size_t(0) \/* allocation_word_size *\/);\n+  do_full_collection(size_t(0) \/* allocation_word_size *\/,\n+                     true  \/* clear_all_soft_refs *\/,\n+                     false \/* do_maximal_compaction *\/);\n@@ -1040,3 +1048,3 @@\n-    do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n-                       maximal_compaction \/* do_maximal_compaction *\/,\n-                       word_size \/* allocation_word_size *\/);\n+    do_full_collection(word_size \/* allocation_word_size *\/,\n+                       maximal_compaction \/* clear_all_soft_refs *\/,\n+                       maximal_compaction \/* do_maximal_compaction *\/);\n@@ -1840,6 +1848,0 @@\n-\/\/ Helper for collect().\n-static G1GCCounters collection_counters(G1CollectedHeap* g1h) {\n-  MutexLocker ml(Heap_lock);\n-  return G1GCCounters(g1h);\n-}\n-\n@@ -1847,1 +1849,1 @@\n-  try_collect(cause, collection_counters(this));\n+  try_collect(0 \/* allocation_word_size *\/, cause, collection_counters(this));\n@@ -1933,1 +1935,2 @@\n-bool G1CollectedHeap::try_collect_concurrently(GCCause::Cause cause,\n+bool G1CollectedHeap::try_collect_concurrently(size_t allocation_word_size,\n+                                               GCCause::Cause cause,\n@@ -1944,1 +1947,1 @@\n-    VM_G1TryInitiateConcMark op(gc_counter, cause);\n+    VM_G1TryInitiateConcMark op(allocation_word_size, gc_counter, cause);\n@@ -1994,0 +1997,1 @@\n+      assert(allocation_word_size == 0, \"must be\");\n@@ -2091,1 +2095,2 @@\n-bool G1CollectedHeap::try_collect(GCCause::Cause cause,\n+bool G1CollectedHeap::try_collect(size_t allocation_word_size,\n+                                  GCCause::Cause cause,\n@@ -2094,1 +2099,2 @@\n-    return try_collect_concurrently(cause,\n+    return try_collect_concurrently(allocation_word_size,\n+                                    cause,\n@@ -2100,0 +2106,1 @@\n+    assert(allocation_word_size == 0, \"must be\");\n@@ -2108,0 +2115,3 @@\n+    \/\/ The only path to get here is because of a periodic collection using a Full GC\n+    \/\/ or WhiteBox full gc.\n+    assert(allocation_word_size == 0, \"must be\");\n@@ -2124,1 +2134,1 @@\n-    do_collection_pause_at_safepoint();\n+    do_collection_pause_at_safepoint(0 \/* allocation_word_size *\/);\n@@ -2261,1 +2271,1 @@\n-size_t G1CollectedHeap::tlab_capacity(Thread* ignored) const {\n+size_t G1CollectedHeap::tlab_capacity() const {\n@@ -2265,1 +2275,1 @@\n-size_t G1CollectedHeap::tlab_used(Thread* ignored) const {\n+size_t G1CollectedHeap::tlab_used() const {\n@@ -2275,1 +2285,1 @@\n-size_t G1CollectedHeap::unsafe_max_tlab_alloc(Thread* ignored) const {\n+size_t G1CollectedHeap::unsafe_max_tlab_alloc() const {\n@@ -2551,1 +2561,1 @@\n-void G1CollectedHeap::verify_region_attr_remset_is_tracked() {\n+void G1CollectedHeap::verify_region_attr_is_remset_tracked() {\n@@ -2556,4 +2566,6 @@\n-      bool const remset_is_tracked = g1h->region_attr(r->bottom()).remset_is_tracked();\n-      assert(r->rem_set()->is_tracked() == remset_is_tracked,\n-             \"Region %u remset tracking status (%s) different to region attribute (%s)\",\n-             r->hrm_index(), BOOL_TO_STR(r->rem_set()->is_tracked()), BOOL_TO_STR(remset_is_tracked));\n+      G1HeapRegionAttr attr = g1h->region_attr(r->bottom());\n+      bool const is_remset_tracked = attr.is_remset_tracked();\n+      assert((r->rem_set()->is_tracked() == is_remset_tracked) ||\n+             (attr.is_new_survivor() && is_remset_tracked),\n+             \"Region %u (%s) remset tracking status (%s) different to region attribute (%s)\",\n+             r->hrm_index(), r->get_type_str(), BOOL_TO_STR(r->rem_set()->is_tracked()), BOOL_TO_STR(is_remset_tracked));\n@@ -3098,3 +3110,2 @@\n-      _policy->remset_tracker()->update_at_allocate(new_alloc_region);\n-      \/\/ Install the group cardset.\n-      young_regions_cset_group()->add(new_alloc_region);\n+\n+      collection_set()->add_eden_region(new_alloc_region);\n@@ -3113,1 +3124,0 @@\n-  collection_set()->add_eden_region(alloc_region);\n@@ -3157,0 +3167,6 @@\n+      \/\/ The remembered set\/group cardset for this region will be installed at the\n+      \/\/ end of GC. Cannot do that right now because we still need the current young\n+      \/\/ gen cardset group.\n+      \/\/ However, register with the attribute table to collect remembered set entries\n+      \/\/ immediately as it is the only source for determining the need for remembered\n+      \/\/ set tracking during GC.\n@@ -3158,2 +3174,0 @@\n-      \/\/ Install the group cardset.\n-      young_regions_cset_group()->add(new_alloc_region);\n@@ -3162,0 +3176,3 @@\n+      \/\/ Update remembered set\/cardset.\n+      _policy->remset_tracker()->update_at_allocate(new_alloc_region);\n+      \/\/ Synchronize with region attribute table.\n@@ -3164,1 +3181,0 @@\n-    _policy->remset_tracker()->update_at_allocate(new_alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":61,"deletions":45,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -310,1 +310,2 @@\n-  \/\/ Attempt to start a concurrent cycle with the indicated cause.\n+  \/\/ Attempt to start a concurrent cycle with the indicated cause, for potentially\n+  \/\/ allocating allocation_word_size words.\n@@ -312,1 +313,2 @@\n-  bool try_collect_concurrently(GCCause::Cause cause,\n+  bool try_collect_concurrently(size_t allocation_word_size,\n+                                GCCause::Cause cause,\n@@ -515,3 +517,3 @@\n-  void do_full_collection(bool clear_all_soft_refs,\n-                          bool do_maximal_compaction,\n-                          size_t allocation_word_size);\n+  void do_full_collection(size_t allocation_word_size,\n+                          bool clear_all_soft_refs,\n+                          bool do_maximal_compaction);\n@@ -669,1 +671,1 @@\n-  void verify_region_attr_remset_is_tracked() PRODUCT_RETURN;\n+  void verify_region_attr_is_remset_tracked() PRODUCT_RETURN;\n@@ -770,3 +772,3 @@\n-  HeapWord* do_collection_pause(size_t         word_size,\n-                                uint           gc_count_before,\n-                                bool*          succeeded,\n+  HeapWord* do_collection_pause(size_t word_size,\n+                                uint gc_count_before,\n+                                bool* succeeded,\n@@ -775,2 +777,3 @@\n-  \/\/ Perform an incremental collection at a safepoint, possibly\n-  \/\/ followed by a by-policy upgrade to a full collection.\n+  \/\/ Perform an incremental collection at a safepoint, possibly followed by a\n+  \/\/ by-policy upgrade to a full collection.\n+  \/\/ The collection should expect to be followed by an allocation of allocation_word_size.\n@@ -779,1 +782,1 @@\n-  void do_collection_pause_at_safepoint(size_t allocation_word_size = 0);\n+  void do_collection_pause_at_safepoint(size_t allocation_word_size);\n@@ -1045,1 +1048,2 @@\n-  \/\/ Perform a collection of the heap with the given cause.\n+  \/\/ Try to perform a collection of the heap with the given cause to allocate allocation_word_size\n+  \/\/ words.\n@@ -1047,1 +1051,1 @@\n-  bool try_collect(GCCause::Cause cause, const G1GCCounters& counters_before);\n+  bool try_collect(size_t allocation_word_size, GCCause::Cause cause, const G1GCCounters& counters_before);\n@@ -1201,2 +1205,2 @@\n-  size_t tlab_capacity(Thread* ignored) const override;\n-  size_t tlab_used(Thread* ignored) const override;\n+  size_t tlab_capacity() const override;\n+  size_t tlab_used() const override;\n@@ -1204,1 +1208,1 @@\n-  size_t unsafe_max_tlab_alloc(Thread* ignored) const override;\n+  size_t unsafe_max_tlab_alloc() const override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-  _region_attr.set_remset_is_tracked(r->hrm_index(), r->rem_set()->is_tracked());\n+  _region_attr.set_is_remset_tracked(r->hrm_index(), r->rem_set()->is_tracked());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+  assert(_optional_groups.length() == 0, \"must be\");\n@@ -219,1 +220,5 @@\n-  assert(!hr->in_collection_set(), \"invariant\");\n+  \/\/ Add to remembered set\/cardset group.\n+  _g1h->policy()->remset_tracker()->update_at_allocate(hr);\n+  _g1h->young_regions_cset_group()->add(hr);\n+\n+  \/\/ Synchronize with the region attribute table.\n@@ -236,0 +241,1 @@\n+  assert_at_safepoint_on_vm_thread();\n@@ -241,0 +247,1 @@\n+  assert_heap_locked_or_at_safepoint(true \/* should_be_vm_thread *\/);\n@@ -726,1 +733,1 @@\n-  _g1h->verify_region_attr_remset_is_tracked();\n+  _g1h->verify_region_attr_is_remset_tracked();\n@@ -747,1 +754,1 @@\n-  _g1h->verify_region_attr_remset_is_tracked();\n+  _g1h->verify_region_attr_is_remset_tracked();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  uint add(G1HeapRegion* hr) {\n+  void add(G1HeapRegion* hr) {\n@@ -47,1 +47,1 @@\n-    return _regions_on_node.add(hr);\n+    _regions_on_node.add(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EdenRegions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  _heap->policy()->record_full_collection_end();\n+  _heap->policy()->record_full_collection_end(allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+  assert(hr->is_humongous() || !hr->rem_set()->has_cset_group(),\n+         \"Non-humongous regions must not have cset group\");\n@@ -39,5 +41,0 @@\n-  if (!hr->is_humongous()) {\n-    hr->uninstall_cset_group();\n-  }\n-\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  \/\/ remset_is_tracked_t is essentially bool, but we need precise control\n+  \/\/ is_remset_tracked_t is essentially bool, but we need precise control\n@@ -38,1 +38,1 @@\n-  typedef uint8_t remset_is_tracked_t;\n+  typedef uint8_t is_remset_tracked_t;\n@@ -44,1 +44,1 @@\n-  remset_is_tracked_t _remset_is_tracked;\n+  is_remset_tracked_t _is_remset_tracked;\n@@ -66,2 +66,2 @@\n-  G1HeapRegionAttr(region_type_t type = NotInCSet, bool remset_is_tracked = false, bool is_pinned = false) :\n-    _remset_is_tracked(remset_is_tracked ? 1 : 0), _type(type), _is_pinned(is_pinned ? 1 : 0) {\n+  G1HeapRegionAttr(region_type_t type = NotInCSet, bool is_remset_tracked = false, bool is_pinned = false) :\n+    _is_remset_tracked(is_remset_tracked ? 1 : 0), _type(type), _is_pinned(is_pinned ? 1 : 0) {\n@@ -85,1 +85,1 @@\n-  bool remset_is_tracked() const     { return _remset_is_tracked != 0; }\n+  bool is_remset_tracked() const     { return _is_remset_tracked != 0; }\n@@ -95,1 +95,1 @@\n-  void set_remset_is_tracked(bool value)      { _remset_is_tracked = value ? 1 : 0; }\n+  void set_is_remset_tracked(bool value)      { _is_remset_tracked = value ? 1 : 0; }\n@@ -128,1 +128,1 @@\n-  void set_optional(uintptr_t index, bool remset_is_tracked) {\n+  void set_optional(uintptr_t index, bool is_remset_tracked) {\n@@ -131,1 +131,1 @@\n-    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Optional, remset_is_tracked));\n+    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Optional, is_remset_tracked));\n@@ -144,1 +144,1 @@\n-    const bool remset_is_tracked = true;\n+    const bool is_remset_tracked = true;\n@@ -147,1 +147,1 @@\n-    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::HumongousCandidate, remset_is_tracked, region_is_pinned));\n+    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::HumongousCandidate, is_remset_tracked, region_is_pinned));\n@@ -158,2 +158,2 @@\n-  void set_remset_is_tracked(uintptr_t index, bool remset_is_tracked) {\n-    get_ref_by_index(index)->set_remset_is_tracked(remset_is_tracked);\n+  void set_is_remset_tracked(uintptr_t index, bool is_remset_tracked) {\n+    get_ref_by_index(index)->set_is_remset_tracked(is_remset_tracked);\n@@ -172,1 +172,1 @@\n-  void set_in_old(uintptr_t index, bool remset_is_tracked, bool is_pinned) {\n+  void set_in_old(uintptr_t index, bool is_remset_tracked, bool is_pinned) {\n@@ -175,1 +175,1 @@\n-    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Old, remset_is_tracked, is_pinned));\n+    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Old, is_remset_tracked, is_pinned));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -154,3 +154,4 @@\n-  assert(region_attr.remset_is_tracked() == hr_obj->rem_set()->is_tracked(),\n-         \"State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u\",\n-         BOOL_TO_STR(region_attr.remset_is_tracked()),\n+  assert((region_attr.is_remset_tracked() == hr_obj->rem_set()->is_tracked()) ||\n+         (region_attr.is_new_survivor() && region_attr.is_remset_tracked()),\n+         \"State flag indicating remset tracking disagrees (%s) with actual remembered set (%s) for region %u (%s)\",\n+         BOOL_TO_STR(region_attr.is_remset_tracked()),\n@@ -158,1 +159,2 @@\n-         hr_obj->hrm_index());\n+         hr_obj->hrm_index(),\n+         hr_obj->get_type_str());\n@@ -160,1 +162,1 @@\n-  if (!region_attr.remset_is_tracked()) {\n+  if (!region_attr.is_remset_tracked()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    if (!g1h->try_collect(GCCause::_g1_periodic_collection, counters)) {\n+    if (!g1h->try_collect(0 \/* allocation_word_size *\/, GCCause::_g1_periodic_collection, counters)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-void G1Policy::record_full_collection_end() {\n+void G1Policy::record_full_collection_end(size_t allocation_word_size) {\n@@ -580,1 +580,1 @@\n-  collector_state()->set_initiate_conc_mark_if_possible(need_to_start_conc_mark(\"end of Full GC\"));\n+  collector_state()->set_initiate_conc_mark_if_possible(need_to_start_conc_mark(\"end of Full GC\", allocation_word_size));\n@@ -746,1 +746,1 @@\n-bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {\n+bool G1Policy::need_to_start_conc_mark(const char* source, size_t allocation_word_size) {\n@@ -754,2 +754,7 @@\n-  size_t alloc_byte_size = alloc_word_size * HeapWordSize;\n-  size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;\n+  size_t allocation_byte_size = allocation_word_size * HeapWordSize;\n+  \/\/ For humongous allocations, we need to consider that we actually use full regions\n+  \/\/ for allocations. So compare the threshold to this size.\n+  if (_g1h->is_humongous(allocation_word_size)) {\n+    allocation_byte_size = G1HeapRegion::align_up_to_region_byte_size(allocation_byte_size);\n+  }\n+  size_t marking_request_bytes = cur_used_bytes + allocation_byte_size;\n@@ -762,1 +767,1 @@\n-                              cur_used_bytes, alloc_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n+                              cur_used_bytes, allocation_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n@@ -767,1 +772,1 @@\n-bool G1Policy::concurrent_operation_is_full_mark(const char* msg) {\n+bool G1Policy::concurrent_operation_is_full_mark(const char* msg, size_t allocation_word_size) {\n@@ -769,1 +774,1 @@\n-    ((_g1h->gc_cause() != GCCause::_g1_humongous_allocation) || need_to_start_conc_mark(msg));\n+    ((_g1h->gc_cause() != GCCause::_g1_humongous_allocation) || need_to_start_conc_mark(msg, allocation_word_size));\n@@ -798,1 +803,3 @@\n-void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark, bool allocation_failure) {\n+void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark,\n+                                           bool allocation_failure,\n+                                           size_t allocation_word_size) {\n@@ -811,1 +818,1 @@\n-    maybe_start_marking();\n+    maybe_start_marking(allocation_word_size);\n@@ -968,1 +975,1 @@\n-      maybe_start_marking();\n+      maybe_start_marking(allocation_word_size);\n@@ -1371,2 +1378,2 @@\n-void G1Policy::maybe_start_marking() {\n-  if (need_to_start_conc_mark(\"end of GC\")) {\n+void G1Policy::maybe_start_marking(size_t allocation_word_size) {\n+  if (need_to_start_conc_mark(\"end of GC\", allocation_word_size)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  void maybe_start_marking();\n+  void maybe_start_marking(size_t allocation_word_size);\n@@ -310,1 +310,1 @@\n-  bool need_to_start_conc_mark(const char* source, size_t alloc_word_size = 0);\n+  bool need_to_start_conc_mark(const char* source, size_t allocation_word_size);\n@@ -312,1 +312,1 @@\n-  bool concurrent_operation_is_full_mark(const char* msg = nullptr);\n+  bool concurrent_operation_is_full_mark(const char* msg, size_t allocation_word_size);\n@@ -319,1 +319,3 @@\n-  void record_young_collection_end(bool concurrent_operation_is_full_mark, bool allocation_failure);\n+  void record_young_collection_end(bool concurrent_operation_is_full_mark,\n+                                   bool allocation_failure,\n+                                   size_t allocation_word_size);\n@@ -323,1 +325,1 @@\n-  void record_full_collection_end();\n+  void record_full_collection_end(size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-uint G1RegionsOnNodes::add(G1HeapRegion* hr) {\n+void G1RegionsOnNodes::add(G1HeapRegion* hr) {\n@@ -44,1 +44,0 @@\n-    return node_index;\n@@ -46,2 +45,0 @@\n-\n-  return G1NUMA::UnknownNodeIndex;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionsOnNodes.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-  \/\/ Increase _count_per_node for the node of given heap region and returns node index.\n-  uint add(G1HeapRegion* hr);\n+  \/\/ Increase _count_per_node for the node of given heap region.\n+  void add(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionsOnNodes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-uint G1SurvivorRegions::add(G1HeapRegion* hr) {\n+void G1SurvivorRegions::add(G1HeapRegion* hr) {\n@@ -38,1 +38,1 @@\n-  return _regions_on_node.add(hr);\n+  _regions_on_node.add(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  uint add(G1HeapRegion* hr);\n+  void add(G1HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-  g1h->do_full_collection(clear_all_soft_refs \/* clear_all_soft_refs *\/,\n-                          false \/* do_maximal_compaction *\/,\n-                          size_t(0) \/* allocation_word_size *\/);\n+  g1h->do_full_collection(size_t(0) \/* allocation_word_size *\/,\n+                          clear_all_soft_refs,\n+                          false \/* do_maximal_compaction *\/);\n@@ -60,1 +60,2 @@\n-VM_G1TryInitiateConcMark::VM_G1TryInitiateConcMark(uint gc_count_before,\n+VM_G1TryInitiateConcMark::VM_G1TryInitiateConcMark(size_t allocation_word_size,\n+                                                   uint gc_count_before,\n@@ -63,0 +64,1 @@\n+  _word_size(allocation_word_size),\n@@ -100,1 +102,1 @@\n-    g1h->do_collection_pause_at_safepoint();\n+    g1h->do_collection_pause_at_safepoint(_word_size);\n@@ -105,2 +107,2 @@\n-VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t         word_size,\n-                                                     uint           gc_count_before,\n+VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t word_size,\n+                                                     uint gc_count_before,\n@@ -114,1 +116,1 @@\n-  g1h->do_collection_pause_at_safepoint();\n+  g1h->do_collection_pause_at_safepoint(_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  size_t _word_size;\n@@ -56,1 +57,2 @@\n-  VM_G1TryInitiateConcMark(uint gc_count_before,\n+  VM_G1TryInitiateConcMark(size_t word_size,\n+                           uint gc_count_before,\n@@ -71,2 +73,2 @@\n-  VM_G1CollectForAllocation(size_t         word_size,\n-                            uint           gc_count_before,\n+  VM_G1CollectForAllocation(size_t word_size,\n+                            uint gc_count_before,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -293,9 +293,1 @@\n-    G1MonotonicArenaMemoryStats _card_set_stats;\n-\n-    void sample_card_set_size(G1HeapRegion* hr) {\n-      \/\/ Sample card set sizes for humongous before GC: this makes the policy to give\n-      \/\/ back memory to the OS keep the most recent amount of memory for these regions.\n-      if (hr->is_starts_humongous()) {\n-        _card_set_stats.add(hr->rem_set()->card_set_memory_stats());\n-      }\n-    }\n+    G1MonotonicArenaMemoryStats _humongous_card_set_stats;\n@@ -414,1 +406,2 @@\n-      _worker_humongous_candidates(0) { }\n+      _worker_humongous_candidates(0),\n+      _humongous_card_set_stats() { }\n@@ -425,2 +418,0 @@\n-      sample_card_set_size(hr);\n-\n@@ -441,0 +432,5 @@\n+\n+      \/\/ Sample card set sizes for humongous regions before GC: this makes the policy\n+      \/\/ to give back memory to the OS keep the most recent amount of memory for these regions.\n+      _humongous_card_set_stats.add(hr->rem_set()->card_set_memory_stats());\n+\n@@ -459,2 +455,2 @@\n-    G1MonotonicArenaMemoryStats card_set_stats() const {\n-      return _card_set_stats;\n+    G1MonotonicArenaMemoryStats humongous_card_set_stats() const {\n+      return _humongous_card_set_stats;\n@@ -484,1 +480,1 @@\n-    _all_card_set_stats.add(cl.card_set_stats());\n+    _all_card_set_stats.add(cl.humongous_card_set_stats());\n@@ -1186,1 +1182,1 @@\n-    _concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\");\n+    _concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\", _allocation_word_size);\n@@ -1192,1 +1188,1 @@\n-    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_alloc_failed());\n+    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_alloc_failed(), _allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -98,2 +99,2 @@\n-  for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-    s += lgrp_spaces()->at(i)->space()->used_in_words();\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->used_in_words();\n@@ -106,2 +107,2 @@\n-  for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-    s += lgrp_spaces()->at(i)->space()->free_in_words();\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->free_in_words();\n@@ -112,13 +113,4 @@\n-MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_thread(Thread* thr) const {\n-  guarantee(thr != nullptr, \"No thread\");\n-\n-  int lgrp_id = thr->lgrp_id();\n-  assert(lgrp_id != -1, \"lgrp_id must be set during thread creation\");\n-\n-  int lgrp_spaces_index = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == (uint)lgrp_id;\n-  });\n-\n-  if (lgrp_spaces_index == -1) {\n-    \/\/ Running on a CPU with no memory; pick another CPU based on %.\n-    lgrp_spaces_index = lgrp_id % lgrp_spaces()->length();\n+size_t MutableNUMASpace::tlab_capacity() const {\n+  size_t s = 0;\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->capacity_in_bytes();\n@@ -126,1 +118,1 @@\n-  return lgrp_spaces()->at(lgrp_spaces_index);\n+  return s \/ (size_t)lgrp_spaces()->length();\n@@ -129,2 +121,6 @@\n-size_t MutableNUMASpace::tlab_capacity(Thread *thr) const {\n-  return lgrp_space_for_thread(thr)->space()->capacity_in_bytes();\n+size_t MutableNUMASpace::tlab_used() const {\n+  size_t s = 0;\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->used_in_bytes();\n+  }\n+  return s \/ (size_t)lgrp_spaces()->length();\n@@ -133,3 +129,13 @@\n-size_t MutableNUMASpace::tlab_used(Thread *thr) const {\n-  return lgrp_space_for_thread(thr)->space()->used_in_bytes();\n-}\n+size_t MutableNUMASpace::unsafe_max_tlab_alloc() const {\n+  size_t s = 0;\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->free_in_bytes();\n+  }\n+\n+  size_t average_free_in_bytes = s \/ (size_t)lgrp_spaces()->length();\n+\n+  \/\/ free_in_bytes() is aligned to MinObjAlignmentInBytes, but averaging across\n+  \/\/ all LGRPs can produce a non-aligned result. We align the value here because\n+  \/\/ it may be used directly for TLAB allocation, which requires the allocation\n+  \/\/ size to be properly aligned.\n+  size_t aligned_average = align_down(average_free_in_bytes, MinObjAlignmentInBytes);\n@@ -137,2 +143,1 @@\n-size_t MutableNUMASpace::unsafe_max_tlab_alloc(Thread *thr) const {\n-  return lgrp_space_for_thread(thr)->space()->free_in_bytes();\n+  return aligned_average;\n@@ -454,2 +459,5 @@\n-HeapWord* MutableNUMASpace::cas_allocate(size_t size) {\n-  Thread *thr = Thread::current();\n+MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_current_thread() const {\n+  const int lgrp_id = os::numa_get_group_id();\n+  int lgrp_spaces_index = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n+    return space->lgrp_id() == (uint)lgrp_id;\n+  });\n@@ -457,2 +465,4 @@\n-  \/\/ Update the locality group to match where the thread actually is.\n-  thr->update_lgrp_id();\n+  if (lgrp_spaces_index == -1) {\n+    \/\/ Running on a CPU with no memory; pick another CPU based on %.\n+    lgrp_spaces_index = lgrp_id % lgrp_spaces()->length();\n+  }\n@@ -460,1 +470,5 @@\n-  LGRPSpace *ls = lgrp_space_for_thread(thr);\n+  return lgrp_spaces()->at(lgrp_spaces_index);\n+}\n+\n+HeapWord* MutableNUMASpace::cas_allocate(size_t size) {\n+  LGRPSpace *ls = lgrp_space_for_current_thread();\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":44,"deletions":30,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  LGRPSpace *lgrp_space_for_thread(Thread *thr) const;\n+  LGRPSpace *lgrp_space_for_current_thread() const;\n@@ -169,3 +169,3 @@\n-  virtual size_t tlab_capacity(Thread* thr) const;\n-  virtual size_t tlab_used(Thread* thr) const;\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  virtual size_t tlab_capacity() const;\n+  virtual size_t tlab_used() const;\n+  virtual size_t unsafe_max_tlab_alloc() const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -120,5 +120,5 @@\n-  virtual size_t used_in_words() const                    { return pointer_delta(top(), bottom()); }\n-  virtual size_t free_in_words() const                    { return pointer_delta(end(),    top()); }\n-  virtual size_t tlab_capacity(Thread* thr) const         { return capacity_in_bytes();            }\n-  virtual size_t tlab_used(Thread* thr) const             { return used_in_bytes();                }\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const { return free_in_bytes();                }\n+  virtual size_t used_in_words() const         { return pointer_delta(top(), bottom()); }\n+  virtual size_t free_in_words() const         { return pointer_delta(end(),    top()); }\n+  virtual size_t tlab_capacity() const         { return capacity_in_bytes();            }\n+  virtual size_t tlab_used() const             { return used_in_bytes();                }\n+  virtual size_t unsafe_max_tlab_alloc() const { return free_in_bytes();                }\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/init.hpp\"\n@@ -327,0 +328,8 @@\n+      if (!is_init_completed()) {\n+        \/\/ Can't do GC; try heap expansion to satisfy the request.\n+        result = expand_heap_and_allocate(size, is_tlab);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+\n@@ -397,2 +406,2 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  \/\/ We just finished a young\/full gc, try everything to satisfy this allocation request.\n+  assert(Heap_lock->is_locked(), \"precondition\");\n+\n@@ -450,2 +459,2 @@\n-size_t ParallelScavengeHeap::tlab_capacity(Thread* thr) const {\n-  return young_gen()->eden_space()->tlab_capacity(thr);\n+size_t ParallelScavengeHeap::tlab_capacity() const {\n+  return young_gen()->eden_space()->tlab_capacity();\n@@ -454,2 +463,2 @@\n-size_t ParallelScavengeHeap::tlab_used(Thread* thr) const {\n-  return young_gen()->eden_space()->tlab_used(thr);\n+size_t ParallelScavengeHeap::tlab_used() const {\n+  return young_gen()->eden_space()->tlab_used();\n@@ -458,2 +467,2 @@\n-size_t ParallelScavengeHeap::unsafe_max_tlab_alloc(Thread* thr) const {\n-  return young_gen()->eden_space()->unsafe_max_tlab_alloc(thr);\n+size_t ParallelScavengeHeap::unsafe_max_tlab_alloc() const {\n+  return young_gen()->eden_space()->unsafe_max_tlab_alloc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -217,3 +217,3 @@\n-  size_t tlab_capacity(Thread* thr) const override;\n-  size_t tlab_used(Thread* thr) const override;\n-  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  size_t tlab_capacity() const override;\n+  size_t tlab_used() const override;\n+  size_t unsafe_max_tlab_alloc() const override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1367,1 +1367,0 @@\n-  SubTasksDone                               _sub_tasks;\n@@ -1371,0 +1370,1 @@\n+  volatile bool                              _code_cache_claimed;\n@@ -1373,5 +1373,4 @@\n-  enum PSAdjustSubTask {\n-    PSAdjustSubTask_code_cache,\n-\n-    PSAdjustSubTask_num_elements\n-  };\n+  bool try_claim_code_cache_task() {\n+    return AtomicAccess::load(&_code_cache_claimed) == false\n+        && AtomicAccess::cmpxchg(&_code_cache_claimed, false, true) == false;\n+  }\n@@ -1383,1 +1382,0 @@\n-    _sub_tasks(PSAdjustSubTask_num_elements),\n@@ -1385,1 +1383,3 @@\n-    _nworkers(nworkers) {\n+    _oop_storage_iter(),\n+    _nworkers(nworkers),\n+    _code_cache_claimed(false) {\n@@ -1391,2 +1391,0 @@\n-    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n-    cm->preserved_marks()->adjust_during_full_gc();\n@@ -1394,1 +1392,4 @@\n-      \/\/ adjust pointers in all spaces\n+      \/\/ Pointers in heap.\n+      ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+      cm->preserved_marks()->adjust_during_full_gc();\n+\n@@ -1397,0 +1398,1 @@\n+\n@@ -1398,5 +1400,1 @@\n-      ResourceMark rm;\n-      Threads::possibly_parallel_oops_do(_nworkers > 1, &pc_adjust_pointer_closure, nullptr);\n-    }\n-    _oop_storage_iter.oops_do(&pc_adjust_pointer_closure);\n-    {\n+      \/\/ All (strong and weak) CLDs.\n@@ -1406,0 +1404,1 @@\n+\n@@ -1407,0 +1406,13 @@\n+      \/\/ Threads stack frames. No need to visit on-stack nmethods, because all\n+      \/\/ nmethods are visited in one go via CodeCache::nmethods_do.\n+      ResourceMark rm;\n+      Threads::possibly_parallel_oops_do(_nworkers > 1, &pc_adjust_pointer_closure, nullptr);\n+      if (try_claim_code_cache_task()) {\n+        NMethodToOopClosure adjust_code(&pc_adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n+        CodeCache::nmethods_do(&adjust_code);\n+      }\n+    }\n+\n+    {\n+      \/\/ VM internal strong and weak roots.\n+      _oop_storage_iter.oops_do(&pc_adjust_pointer_closure);\n@@ -1410,5 +1422,0 @@\n-    if (_sub_tasks.try_claim_task(PSAdjustSubTask_code_cache)) {\n-      NMethodToOopClosure adjust_code(&pc_adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n-      CodeCache::nmethods_do(&adjust_code);\n-    }\n-    _sub_tasks.all_tasks_claimed();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -304,2 +304,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  assert(Thread::current()->is_VM_thread(), \"precondition\");\n+  assert(Heap_lock->is_locked(), \"precondition\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -847,2 +847,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n-  assert(Thread::current()->is_VM_thread(), \"precondition\");\n+  assert(Heap_lock->is_locked(), \"precondition\");\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"runtime\/init.hpp\"\n@@ -271,0 +272,2 @@\n+  assert(Heap_lock->is_locked(), \"precondition\");\n+\n@@ -319,0 +322,8 @@\n+      if (!is_init_completed()) {\n+        \/\/ Can't do GC; try heap expansion to satisfy the request.\n+        result = expand_heap_and_allocate(size, is_tlab);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+\n@@ -652,1 +663,1 @@\n-size_t SerialHeap::tlab_capacity(Thread* thr) const {\n+size_t SerialHeap::tlab_capacity() const {\n@@ -657,1 +668,1 @@\n-size_t SerialHeap::tlab_used(Thread* thr) const {\n+size_t SerialHeap::tlab_used() const {\n@@ -661,1 +672,1 @@\n-size_t SerialHeap::unsafe_max_tlab_alloc(Thread* thr) const {\n+size_t SerialHeap::unsafe_max_tlab_alloc() const {\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -192,3 +192,3 @@\n-  size_t tlab_capacity(Thread* thr) const override;\n-  size_t tlab_used(Thread* thr) const override;\n-  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  size_t tlab_capacity() const override;\n+  size_t tlab_used() const override;\n+  size_t unsafe_max_tlab_alloc() const override;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-\/\/ Do something for each concrete barrier set part of the build.\n-#define FOR_EACH_CONCRETE_BARRIER_SET_DO(f)          \\\n+\/\/ Do something for each barrier set part of the build.\n+#define FOR_EACH_BARRIER_SET_DO(f)                   \\\n@@ -38,8 +38,0 @@\n-#define FOR_EACH_ABSTRACT_BARRIER_SET_DO(f)          \\\n-  f(ModRef)\n-\n-\/\/ Do something for each known barrier set.\n-#define FOR_EACH_BARRIER_SET_DO(f)    \\\n-  FOR_EACH_ABSTRACT_BARRIER_SET_DO(f) \\\n-  FOR_EACH_CONCRETE_BARRIER_SET_DO(f)\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetConfig.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/shared\/modRefBarrierSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetConfig.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -34,2 +35,0 @@\n-#include <limits>\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/bufferNode.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -37,0 +38,102 @@\n+void CardTableBarrierSetC1::store_at_resolved(LIRAccess& access, LIR_Opr value) {\n+  DecoratorSet decorators = access.decorators();\n+  bool is_array = (decorators & IS_ARRAY) != 0;\n+  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+\n+  \/\/ Is this a flat, atomic access that might require gc barriers on oop fields?\n+  ciInlineKlass* vk = access.vk();\n+  if (vk != nullptr && vk->has_object_fields()) {\n+    \/\/ Add pre-barriers for oop fields\n+    for (int i = 0; i < vk->nof_nonstatic_fields(); i++) {\n+      ciField* field = vk->nonstatic_field_at(i);\n+      if (!field->type()->is_primitive_type()) {\n+        int off = access.offset().opr().as_jint() + field->offset_in_bytes() - vk->payload_offset();\n+        LIRAccess inner_access(access.gen(), decorators, access.base(), LIR_OprFact::intConst(off), field->type()->basic_type(), access.patch_emit_info(), access.access_emit_info());\n+        pre_barrier(inner_access, resolve_address(inner_access, false),\n+                    LIR_OprFact::illegalOpr \/* pre_val *\/, inner_access.patch_emit_info());\n+      }\n+    }\n+  }\n+\n+  if (access.is_oop()) {\n+    pre_barrier(access, access.resolved_addr(),\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, access.patch_emit_info());\n+  }\n+\n+  BarrierSetC1::store_at_resolved(access, value);\n+\n+  if (access.is_oop()) {\n+    bool precise = is_array || on_anonymous;\n+    LIR_Opr post_addr = precise ? access.resolved_addr() : access.base().opr();\n+    post_barrier(access, post_addr, value);\n+  }\n+\n+  if (vk != nullptr && vk->has_object_fields()) {\n+    \/\/ Add post-barriers for oop fields\n+    for (int i = 0; i < vk->nof_nonstatic_fields(); i++) {\n+      ciField* field = vk->nonstatic_field_at(i);\n+      if (!field->type()->is_primitive_type()) {\n+        int inner_off = field->offset_in_bytes() - vk->payload_offset();\n+        int off = access.offset().opr().as_jint() + inner_off;\n+        LIRAccess inner_access(access.gen(), decorators, access.base(), LIR_OprFact::intConst(off), field->type()->basic_type(), access.patch_emit_info(), access.access_emit_info());\n+\n+        \/\/ Shift long value to extract the narrow oop field value and zero-extend\n+        LIR_Opr field_val = access.gen()->new_register(T_LONG);\n+        access.gen()->lir()->unsigned_shift_right(value,\n+                                                  LIR_OprFact::intConst(inner_off << LogBitsPerByte),\n+                                                  field_val, LIR_Opr::illegalOpr());\n+        LIR_Opr mask = access.gen()->load_immediate((julong) max_juint, T_LONG);\n+        access.gen()->lir()->logical_and(field_val, mask, field_val);\n+        LIR_Opr oop_val = access.gen()->new_register(T_OBJECT);\n+        access.gen()->lir()->move(field_val, oop_val);\n+\n+        assert(!is_array && !on_anonymous, \"not suppported\");\n+        post_barrier(inner_access, access.base().opr(), oop_val);\n+      }\n+    }\n+  }\n+}\n+\n+LIR_Opr CardTableBarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value) {\n+  if (access.is_oop()) {\n+    pre_barrier(access, access.resolved_addr(),\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n+  }\n+\n+  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+\n+  if (access.is_oop()) {\n+    post_barrier(access, access.resolved_addr(), new_value.result());\n+  }\n+\n+  return result;\n+}\n+\n+LIR_Opr CardTableBarrierSetC1::atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value) {\n+  if (access.is_oop()) {\n+    pre_barrier(access, access.resolved_addr(),\n+                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n+  }\n+\n+  LIR_Opr result = BarrierSetC1::atomic_xchg_at_resolved(access, value);\n+\n+  if (access.is_oop()) {\n+    post_barrier(access, access.resolved_addr(), value.result());\n+  }\n+\n+  return result;\n+}\n+\n+\/\/ This overrides the default to resolve the address into a register,\n+\/\/ assuming it will be used by a write barrier anyway.\n+LIR_Opr CardTableBarrierSetC1::resolve_address(LIRAccess& access, bool resolve_in_register) {\n+  DecoratorSet decorators = access.decorators();\n+  bool needs_patching = (decorators & C1_NEEDS_PATCHING) != 0;\n+  bool is_write = (decorators & ACCESS_WRITE) != 0;\n+  bool is_array = (decorators & IS_ARRAY) != 0;\n+  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+  bool precise = is_array || on_anonymous;\n+  resolve_in_register |= !needs_patching && is_write && access.is_oop() && precise;\n+  return BarrierSetC1::resolve_address(access, resolve_in_register);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/c1\/modRefBarrierSetC1.hpp\"\n+#include \"gc\/shared\/c1\/barrierSetC1.hpp\"\n@@ -30,1 +30,1 @@\n-class CardTableBarrierSetC1 : public ModRefBarrierSetC1 {\n+class CardTableBarrierSetC1 : public BarrierSetC1 {\n@@ -32,0 +32,3 @@\n+  virtual void pre_barrier(LIRAccess& access, LIR_Opr addr_opr,\n+                         LIR_Opr pre_val, CodeEmitInfo* info) {}\n+\n@@ -33,0 +36,8 @@\n+\n+  virtual LIR_Opr resolve_address(LIRAccess& access, bool resolve_in_register);\n+\n+  virtual void store_at_resolved(LIRAccess& access, LIR_Opr value);\n+\n+  virtual LIR_Opr atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value);\n+\n+  virtual LIR_Opr atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value);\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/cardTableBarrierSetC1.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"ci\/ciInlineKlass.hpp\"\n-#include \"gc\/shared\/c1\/modRefBarrierSetC1.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#ifdef ASSERT\n-#define __ gen->lir(__FILE__, __LINE__)->\n-#else\n-#define __ gen->lir()->\n-#endif\n-\n-void ModRefBarrierSetC1::store_at_resolved(LIRAccess& access, LIR_Opr value) {\n-  DecoratorSet decorators = access.decorators();\n-  bool is_array = (decorators & IS_ARRAY) != 0;\n-  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-\n-  \/\/ Is this a flat, atomic access that might require gc barriers on oop fields?\n-  ciInlineKlass* vk = access.vk();\n-  if (vk != nullptr && vk->has_object_fields()) {\n-    \/\/ Add pre-barriers for oop fields\n-    for (int i = 0; i < vk->nof_nonstatic_fields(); i++) {\n-      ciField* field = vk->nonstatic_field_at(i);\n-      if (!field->type()->is_primitive_type()) {\n-        int off = access.offset().opr().as_jint() + field->offset_in_bytes() - vk->payload_offset();\n-        LIRAccess inner_access(access.gen(), decorators, access.base(), LIR_OprFact::intConst(off), field->type()->basic_type(), access.patch_emit_info(), access.access_emit_info());\n-        pre_barrier(inner_access, resolve_address(inner_access, false),\n-                    LIR_OprFact::illegalOpr \/* pre_val *\/, inner_access.patch_emit_info());\n-      }\n-    }\n-  }\n-\n-  if (access.is_oop()) {\n-    pre_barrier(access, access.resolved_addr(),\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, access.patch_emit_info());\n-  }\n-\n-  BarrierSetC1::store_at_resolved(access, value);\n-\n-  if (access.is_oop()) {\n-    bool precise = is_array || on_anonymous;\n-    LIR_Opr post_addr = precise ? access.resolved_addr() : access.base().opr();\n-    post_barrier(access, post_addr, value);\n-  }\n-\n-  if (vk != nullptr && vk->has_object_fields()) {\n-    \/\/ Add post-barriers for oop fields\n-    for (int i = 0; i < vk->nof_nonstatic_fields(); i++) {\n-      ciField* field = vk->nonstatic_field_at(i);\n-      if (!field->type()->is_primitive_type()) {\n-        int inner_off = field->offset_in_bytes() - vk->payload_offset();\n-        int off = access.offset().opr().as_jint() + inner_off;\n-        LIRAccess inner_access(access.gen(), decorators, access.base(), LIR_OprFact::intConst(off), field->type()->basic_type(), access.patch_emit_info(), access.access_emit_info());\n-\n-        \/\/ Shift long value to extract the narrow oop field value and zero-extend\n-        LIR_Opr field_val = access.gen()->new_register(T_LONG);\n-        access.gen()->lir()->unsigned_shift_right(value,\n-                                                  LIR_OprFact::intConst(inner_off << LogBitsPerByte),\n-                                                  field_val, LIR_Opr::illegalOpr());\n-        LIR_Opr mask = access.gen()->load_immediate((julong) max_juint, T_LONG);\n-        access.gen()->lir()->logical_and(field_val, mask, field_val);\n-        LIR_Opr oop_val = access.gen()->new_register(T_OBJECT);\n-        access.gen()->lir()->move(field_val, oop_val);\n-\n-        assert(!is_array && !on_anonymous, \"not suppported\");\n-        post_barrier(inner_access, access.base().opr(), oop_val);\n-      }\n-    }\n-  }\n-}\n-\n-LIR_Opr ModRefBarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value) {\n-  if (access.is_oop()) {\n-    pre_barrier(access, access.resolved_addr(),\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n-  }\n-\n-  LIR_Opr result = BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n-\n-  if (access.is_oop()) {\n-    post_barrier(access, access.resolved_addr(), new_value.result());\n-  }\n-\n-  return result;\n-}\n-\n-LIR_Opr ModRefBarrierSetC1::atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value) {\n-  if (access.is_oop()) {\n-    pre_barrier(access, access.resolved_addr(),\n-                LIR_OprFact::illegalOpr \/* pre_val *\/, nullptr);\n-  }\n-\n-  LIR_Opr result = BarrierSetC1::atomic_xchg_at_resolved(access, value);\n-\n-  if (access.is_oop()) {\n-    post_barrier(access, access.resolved_addr(), value.result());\n-  }\n-\n-  return result;\n-}\n-\n-\/\/ This overrides the default to resolve the address into a register,\n-\/\/ assuming it will be used by a write barrier anyway.\n-LIR_Opr ModRefBarrierSetC1::resolve_address(LIRAccess& access, bool resolve_in_register) {\n-  DecoratorSet decorators = access.decorators();\n-  bool needs_patching = (decorators & C1_NEEDS_PATCHING) != 0;\n-  bool is_write = (decorators & ACCESS_WRITE) != 0;\n-  bool is_array = (decorators & IS_ARRAY) != 0;\n-  bool on_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-  bool precise = is_array || on_anonymous;\n-  resolve_in_register |= !needs_patching && is_write && access.is_oop() && precise;\n-  return BarrierSetC1::resolve_address(access, resolve_in_register);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/modRefBarrierSetC1.cpp","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_C1_MODREFBARRIERSETC1_HPP\n-#define SHARE_GC_SHARED_C1_MODREFBARRIERSETC1_HPP\n-\n-#include \"gc\/shared\/c1\/barrierSetC1.hpp\"\n-\n-\/\/ The ModRefBarrierSetC1 filters away accesses on BasicTypes other\n-\/\/ than T_OBJECT\/T_ARRAY (oops). The oop accesses call one of the protected\n-\/\/ accesses, which are overridden in the concrete BarrierSetAssembler.\n-\n-class ModRefBarrierSetC1 : public BarrierSetC1 {\n-protected:\n-  virtual void pre_barrier(LIRAccess& access, LIR_Opr addr_opr,\n-                           LIR_Opr pre_val, CodeEmitInfo* info) {}\n-  virtual void post_barrier(LIRAccess& access, LIR_Opr addr,\n-                            LIR_Opr new_val) {}\n-\n-  virtual LIR_Opr resolve_address(LIRAccess& access, bool resolve_in_register);\n-\n-  virtual void store_at_resolved(LIRAccess& access, LIR_Opr value);\n-\n-  virtual LIR_Opr atomic_cmpxchg_at_resolved(LIRAccess& access, LIRItem& cmp_value, LIRItem& new_value);\n-\n-  virtual LIR_Opr atomic_xchg_at_resolved(LIRAccess& access, LIRItem& value);\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_C1_MODREFBARRIERSETC1_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/modRefBarrierSetC1.hpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -38,0 +38,101 @@\n+Node* CardTableBarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n+  DecoratorSet decorators = access.decorators();\n+\n+  Node* adr = access.addr().node();\n+\n+  bool is_array = (decorators & IS_ARRAY) != 0;\n+  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  bool use_precise = is_array || anonymous;\n+  bool tightly_coupled_alloc = (decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0;\n+\n+  const InlineTypeNode* vt = nullptr;\n+  if (access.is_parse_access() && static_cast<C2ParseAccess&>(access).vt() != nullptr) {\n+    vt = static_cast<C2ParseAccess&>(access).vt();\n+  }\n+\n+  if (vt == nullptr && (!access.is_oop() || tightly_coupled_alloc || (!in_heap && !anonymous))) {\n+    return BarrierSetC2::store_at_resolved(access, val);\n+  }\n+\n+  assert(access.is_parse_access(), \"entry not supported at optimization time\");\n+  C2ParseAccess& parse_access = static_cast<C2ParseAccess&>(access);\n+\n+  Node* store = BarrierSetC2::store_at_resolved(access, val);\n+  \/\/ TODO 8350865\n+  \/\/ - We actually only need the post barrier once for non-arrays (same for C1, right)?\n+  \/\/ - Value is only needed to determine if we are storing null. Maybe we can go with a simple boolean?\n+  GraphKit* kit = parse_access.kit();\n+  if (vt != nullptr) {\n+    for (uint i = 0; i < vt->field_count(); ++i) {\n+      ciType* type = vt->field_type(i);\n+      if (!type->is_primitive_type()) {\n+        ciInlineKlass* vk = vt->bottom_type()->inline_klass();\n+        int field_offset = vt->field_offset(i) - vk->payload_offset();\n+        Node* value = vt->field_value(i);\n+        Node* field_adr = kit->basic_plus_adr(access.base(), adr, field_offset);\n+        post_barrier(kit, access.base(), field_adr, value, use_precise);\n+      }\n+    }\n+  } else {\n+    post_barrier(kit, access.base(), adr, val.node(), use_precise);\n+  }\n+\n+  return store;\n+}\n+\n+Node* CardTableBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                            Node* new_val, const Type* value_type) const {\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n+  }\n+\n+  Node* result = BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n+\n+  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n+\n+  return result;\n+}\n+\n+Node* CardTableBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                             Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+  }\n+\n+  Node* load_store = BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+\n+  \/\/ Emit the post barrier only when the actual store happened. This makes sense\n+  \/\/ to check only for LS_cmp_* that can fail to set the value.\n+  \/\/ LS_cmp_exchange does not produce any branches by default, so there is no\n+  \/\/ boolean result to piggyback on. TODO: When we merge CompareAndSwap with\n+  \/\/ CompareAndExchange and move branches here, it would make sense to conditionalize\n+  \/\/ post_barriers for LS_cmp_exchange as well.\n+  \/\/\n+  \/\/ CAS success path is marked more likely since we anticipate this is a performance\n+  \/\/ critical path, while CAS failure path can use the penalty for going through unlikely\n+  \/\/ path as backoff. Which is still better than doing a store barrier there.\n+  IdealKit ideal(kit);\n+  ideal.if_then(load_store, BoolTest::ne, ideal.ConI(0), PROB_STATIC_FREQUENT); {\n+    kit->sync_kit(ideal);\n+    post_barrier(kit, access.base(), access.addr().node(), new_val, true);\n+    ideal.sync_kit(kit);\n+  } ideal.end_if();\n+  kit->final_sync(ideal);\n+\n+  return load_store;\n+}\n+\n+Node* CardTableBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const {\n+  Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n+  if (!access.is_oop()) {\n+    return result;\n+  }\n+\n+  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/c2\/modRefBarrierSetC2.hpp\"\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n@@ -30,1 +30,1 @@\n-class CardTableBarrierSetC2: public ModRefBarrierSetC2 {\n+class CardTableBarrierSetC2: public BarrierSetC2 {\n@@ -38,0 +38,8 @@\n+  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n+\n+  virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                               Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/c2\/modRefBarrierSetC2.hpp\"\n-#include \"opto\/arraycopynode.hpp\"\n-#include \"opto\/graphKit.hpp\"\n-#include \"opto\/idealKit.hpp\"\n-\n-Node* ModRefBarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n-  DecoratorSet decorators = access.decorators();\n-\n-  Node* adr = access.addr().node();\n-\n-  bool is_array = (decorators & IS_ARRAY) != 0;\n-  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n-  bool in_heap = (decorators & IN_HEAP) != 0;\n-  bool use_precise = is_array || anonymous;\n-  bool tightly_coupled_alloc = (decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0;\n-\n-  const InlineTypeNode* vt = nullptr;\n-  if (access.is_parse_access() && static_cast<C2ParseAccess&>(access).vt() != nullptr) {\n-    vt = static_cast<C2ParseAccess&>(access).vt();\n-  }\n-\n-  if (vt == nullptr && (!access.is_oop() || tightly_coupled_alloc || (!in_heap && !anonymous))) {\n-    return BarrierSetC2::store_at_resolved(access, val);\n-  }\n-\n-  assert(access.is_parse_access(), \"entry not supported at optimization time\");\n-  C2ParseAccess& parse_access = static_cast<C2ParseAccess&>(access);\n-\n-  Node* store = BarrierSetC2::store_at_resolved(access, val);\n-\n-  \/\/ TODO 8350865\n-  \/\/ - We actually only need the post barrier once for non-arrays (same for C1, right)?\n-  \/\/ - Value is only needed to determine if we are storing null. Maybe we can go with a simple boolean?\n-  GraphKit* kit = parse_access.kit();\n-  if (vt != nullptr) {\n-    for (uint i = 0; i < vt->field_count(); ++i) {\n-      ciType* type = vt->field_type(i);\n-      if (!type->is_primitive_type()) {\n-        ciInlineKlass* vk = vt->bottom_type()->inline_klass();\n-        int field_offset = vt->field_offset(i) - vk->payload_offset();\n-        Node* value = vt->field_value(i);\n-        Node* field_adr = kit->basic_plus_adr(access.base(), adr, field_offset);\n-        post_barrier(kit, access.base(), field_adr, value, use_precise);\n-      }\n-    }\n-  } else {\n-    post_barrier(kit, access.base(), adr, val.node(), use_precise);\n-  }\n-\n-  return store;\n-}\n-\n-Node* ModRefBarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                                         Node* new_val, const Type* value_type) const {\n-  if (!access.is_oop()) {\n-    return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n-  }\n-\n-  Node* result = BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n-\n-  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n-\n-  return result;\n-}\n-\n-Node* ModRefBarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                                          Node* new_val, const Type* value_type) const {\n-  GraphKit* kit = access.kit();\n-\n-  if (!access.is_oop()) {\n-    return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n-  }\n-\n-  Node* load_store = BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n-\n-  \/\/ Emit the post barrier only when the actual store happened. This makes sense\n-  \/\/ to check only for LS_cmp_* that can fail to set the value.\n-  \/\/ LS_cmp_exchange does not produce any branches by default, so there is no\n-  \/\/ boolean result to piggyback on. TODO: When we merge CompareAndSwap with\n-  \/\/ CompareAndExchange and move branches here, it would make sense to conditionalize\n-  \/\/ post_barriers for LS_cmp_exchange as well.\n-  \/\/\n-  \/\/ CAS success path is marked more likely since we anticipate this is a performance\n-  \/\/ critical path, while CAS failure path can use the penalty for going through unlikely\n-  \/\/ path as backoff. Which is still better than doing a store barrier there.\n-  IdealKit ideal(kit);\n-  ideal.if_then(load_store, BoolTest::ne, ideal.ConI(0), PROB_STATIC_FREQUENT); {\n-    kit->sync_kit(ideal);\n-    post_barrier(kit, access.base(), access.addr().node(), new_val, true);\n-    ideal.sync_kit(kit);\n-  } ideal.end_if();\n-  kit->final_sync(ideal);\n-\n-  return load_store;\n-}\n-\n-Node* ModRefBarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const {\n-  Node* result = BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n-  if (!access.is_oop()) {\n-    return result;\n-  }\n-\n-  post_barrier(access.kit(), access.base(), access.addr().node(), new_val, true);\n-\n-  return result;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/modRefBarrierSetC2.cpp","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_C2_MODREFBARRIERSETC2_HPP\n-#define SHARE_GC_SHARED_C2_MODREFBARRIERSETC2_HPP\n-\n-#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n-\n-class TypeOopPtr;\n-\n-class ModRefBarrierSetC2: public BarrierSetC2 {\n-protected:\n-  virtual void post_barrier(GraphKit* kit,\n-                            Node* obj,\n-                            Node* adr,\n-                            Node* val,\n-                            bool use_precise) const {}\n-\n-  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n-\n-  virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                               Node* new_val, const Type* value_type) const;\n-  virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n-                                                Node* new_val, const Type* value_type) const;\n-  virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_C2_MODREFBARRIERSETC2_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/modRefBarrierSetC2.hpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -56,4 +56,6 @@\n-  ModRefBarrierSet(barrier_set_assembler,\n-                   barrier_set_c1,\n-                   barrier_set_c2,\n-                   fake_rtti.add_tag(BarrierSet::CardTableBarrierSet)),\n+  BarrierSet(barrier_set_assembler,\n+             barrier_set_c1,\n+             barrier_set_c2,\n+             nullptr \/* barrier_set_nmethod *\/,\n+             nullptr \/* barrier_set_stack_chunk *\/,\n+             fake_rtti.add_tag(BarrierSet::CardTableBarrierSet)),\n@@ -64,4 +66,6 @@\n-  ModRefBarrierSet(make_barrier_set_assembler<CardTableBarrierSetAssembler>(),\n-                   make_barrier_set_c1<CardTableBarrierSetC1>(),\n-                   make_barrier_set_c2<CardTableBarrierSetC2>(),\n-                   BarrierSet::FakeRtti(BarrierSet::CardTableBarrierSet)),\n+  BarrierSet(make_barrier_set_assembler<CardTableBarrierSetAssembler>(),\n+             make_barrier_set_c1<CardTableBarrierSetC1>(),\n+             make_barrier_set_c2<CardTableBarrierSetC2>(),\n+             nullptr \/* barrier_set_nmethod *\/,\n+             nullptr \/* barrier_set_stack_chunk *\/,\n+             BarrierSet::FakeRtti(BarrierSet::CardTableBarrierSet)),\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -29,1 +30,1 @@\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n+#include \"memory\/memRegion.hpp\"\n@@ -44,1 +45,1 @@\n-class CardTableBarrierSet: public ModRefBarrierSet {\n+class CardTableBarrierSet: public BarrierSet {\n@@ -62,1 +63,2 @@\n-  CardTable* card_table() const { return _card_table; }\n+  template <DecoratorSet decorators, typename T>\n+  inline void write_ref_field_pre(T* addr) {}\n@@ -69,1 +71,1 @@\n-  void write_ref_field_post(T* field);\n+  inline void write_ref_field_post(T *addr);\n@@ -71,0 +73,1 @@\n+  \/\/ Causes all refs in \"mr\" to be assumed to be modified (by this JavaThread).\n@@ -73,0 +76,14 @@\n+  \/\/ Operations on arrays, or general regions (e.g., for \"clone\") may be\n+  \/\/ optimized by some barriers.\n+\n+  \/\/ Below length is the # array elements being written\n+  virtual void write_ref_array_pre(oop* dst, size_t length,\n+                                   bool dest_uninitialized) {}\n+  virtual void write_ref_array_pre(narrowOop* dst, size_t length,\n+                                   bool dest_uninitialized) {}\n+  \/\/ Below count is the # array elements being written, starting\n+  \/\/ at the address \"start\", which may not necessarily be HeapWord-aligned\n+  inline void write_ref_array(HeapWord* start, size_t count);\n+\n+  CardTable* card_table() const { return _card_table; }\n+\n@@ -78,1 +95,37 @@\n-  class AccessBarrier: public ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT> {};\n+  class AccessBarrier: public BarrierSet::AccessBarrier<decorators, BarrierSetT> {\n+    typedef BarrierSet::AccessBarrier<decorators, BarrierSetT> Raw;\n+\n+  public:\n+    template <typename T>\n+    static void oop_store_in_heap(T* addr, oop value);\n+    template <typename T>\n+    static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value);\n+    template <typename T>\n+    static oop oop_atomic_xchg_in_heap(T* addr, oop new_value);\n+\n+    template <typename T>\n+    static void oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n+                                      size_t length);\n+  private:\n+    \/\/ Failing checkcast or check null during copy, still needs barrier\n+    template <typename T>\n+    static inline void oop_arraycopy_partial_barrier(BarrierSetT *bs, T* dst_raw, T* p);\n+  public:\n+\n+    static void clone_in_heap(oop src, oop dst, size_t size);\n+\n+    static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {\n+      oop_store_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), value);\n+    }\n+\n+    static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {\n+      return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n+    }\n+\n+    static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {\n+      return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n+    }\n+\n+    static void value_copy_in_heap(void* src, void* dst, InlineKlass* md, LayoutKind lk);\n+  };\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -31,1 +32,4 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n+#include \"oops\/objArrayOop.hpp\"\n+#include \"oops\/oop.hpp\"\n@@ -39,0 +43,160 @@\n+class Klass;\n+\n+\/\/ count is number of array elements being written\n+void CardTableBarrierSet::write_ref_array(HeapWord* start, size_t count) {\n+  HeapWord* end = (HeapWord*)((char*)start + (count*heapOopSize));\n+  \/\/ In the case of compressed oops, start and end may potentially be misaligned;\n+  \/\/ so we need to conservatively align the first downward (this is not\n+  \/\/ strictly necessary for current uses, but a case of good hygiene and,\n+  \/\/ if you will, aesthetics) and the second upward (this is essential for\n+  \/\/ current uses) to a HeapWord boundary, so we mark all cards overlapping\n+  \/\/ this write. If this evolves in the future to calling a\n+  \/\/ logging barrier of narrow oop granularity, like the pre-barrier for G1\n+  \/\/ (mentioned here merely by way of example), we will need to change this\n+  \/\/ interface, so it is \"exactly precise\" (if i may be allowed the adverbial\n+  \/\/ redundancy for emphasis) and does not include narrow oop slots not\n+  \/\/ included in the original write interval.\n+  HeapWord* aligned_start = align_down(start, HeapWordSize);\n+  HeapWord* aligned_end   = align_up  (end,   HeapWordSize);\n+  \/\/ If compressed oops were not being used, these should already be aligned\n+  assert(UseCompressedOops || (aligned_start == start && aligned_end == end),\n+         \"Expected heap word alignment of start and end\");\n+  write_region(MemRegion(aligned_start, aligned_end));\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline void CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_store_in_heap(T* addr, oop value) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->template write_ref_field_pre<decorators>(addr);\n+  Raw::oop_store(addr, value);\n+  bs->template write_ref_field_post<decorators>(addr);\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline oop CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->template write_ref_field_pre<decorators>(addr);\n+  oop result = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n+  if (result == compare_value) {\n+    bs->template write_ref_field_post<decorators>(addr);\n+  }\n+  return result;\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline oop CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_atomic_xchg_in_heap(T* addr, oop new_value) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->template write_ref_field_pre<decorators>(addr);\n+  oop result = Raw::oop_atomic_xchg(addr, new_value);\n+  bs->template write_ref_field_post<decorators>(addr);\n+  return result;\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline void CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_arraycopy_partial_barrier(BarrierSetT *bs, T* dst_raw, T* p) {\n+  const size_t pd = pointer_delta(p, dst_raw, (size_t)heapOopSize);\n+  \/\/ pointer delta is scaled to number of elements (length field in\n+  \/\/ objArrayOop) which we assume is 32 bit.\n+  assert(pd == (size_t)(int)pd, \"length field overflow\");\n+  bs->write_ref_array((HeapWord*)dst_raw, pd);\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline void CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n+                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n+                      size_t length) {\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+\n+  src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);\n+  dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);\n+\n+  if ((!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) &&\n+      (!HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value)) {\n+    \/\/ Optimized covariant case\n+    bs->write_ref_array_pre(dst_raw, length,\n+                            HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value);\n+    Raw::oop_arraycopy(nullptr, 0, src_raw, nullptr, 0, dst_raw, length);\n+    bs->write_ref_array((HeapWord*)dst_raw, length);\n+  } else {\n+    assert(dst_obj != nullptr, \"better have an actual oop\");\n+    Klass* bound = objArrayOop(dst_obj)->element_klass();\n+    T* from = const_cast<T*>(src_raw);\n+    T* end = from + length;\n+    for (T* p = dst_raw; from < end; from++, p++) {\n+      T element = *from;\n+      \/\/ Apply any required checks\n+      if (HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value && CompressedOops::is_null(element)) {\n+        oop_arraycopy_partial_barrier(bs, dst_raw, p);\n+        throw_array_null_pointer_store_exception(src_obj, dst_obj, JavaThread::current());\n+        return;\n+      }\n+      if (HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value &&\n+          (!oopDesc::is_instanceof_or_null(CompressedOops::decode(element), bound))) {\n+        oop_arraycopy_partial_barrier(bs, dst_raw, p);\n+        throw_array_store_exception(src_obj, dst_obj, JavaThread::current());\n+        return;\n+      }\n+      \/\/ write\n+      bs->template write_ref_field_pre<decorators>(p);\n+      *p = element;\n+    }\n+    bs->write_ref_array((HeapWord*)dst_raw, length);\n+  }\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+inline void CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+clone_in_heap(oop src, oop dst, size_t size) {\n+  Raw::clone(src, dst, size);\n+  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n+  bs->write_region(MemRegion((HeapWord*)(void*)dst, size));\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+inline void CardTableBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+value_copy_in_heap(void* src, void* dst, InlineKlass* md, LayoutKind lk) {\n+  if (!md->contains_oops()) {\n+    \/\/ If we do not have oops in the flat array, we can just do a raw copy.\n+    Raw::value_copy(src, dst, md, lk);\n+  } else {\n+    BarrierSetT* bs = barrier_set_cast<BarrierSetT>(BarrierSet::barrier_set());\n+    \/\/ src\/dst aren't oops, need offset to adjust oop map offset\n+    const address dst_oop_addr_offset = ((address) dst) - md->payload_offset();\n+    typedef typename ValueOopType<decorators>::type OopType;\n+\n+    \/\/ Pre-barriers...\n+    OopMapBlock* map = md->start_of_nonstatic_oop_maps();\n+    OopMapBlock* const end = map + md->nonstatic_oop_map_count();\n+    bool is_uninitialized = HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value;\n+    while (map != end) {\n+      address doop_address = dst_oop_addr_offset + map->offset();\n+      \/\/ The pre-barrier only impacts G1, which will emit a barrier if the destination is\n+      \/\/ initialized. Note that we should not emit a barrier if the destination is uninitialized,\n+      \/\/ as doing so will fill the SATB queue with garbage data.\n+      bs->write_ref_array_pre((OopType*) doop_address, map->count(), is_uninitialized);\n+      map++;\n+    }\n+\n+    Raw::value_copy(src, dst, md, lk);\n+\n+    \/\/ Post-barriers...\n+    map = md->start_of_nonstatic_oop_maps();\n+    while (map != end) {\n+      address doop_address = dst_oop_addr_offset + map->offset();\n+      \/\/ The post-barrier needs to be called for initialized and uninitialized destinations.\n+      bs->write_ref_array((HeapWord*) doop_address, map->count());\n+      map++;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.inline.hpp","additions":165,"deletions":1,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -452,6 +452,0 @@\n-void CollectedHeap::fill_args_check(HeapWord* start, size_t words)\n-{\n-  assert(words >= min_fill_size(), \"too small to fill\");\n-  assert(is_object_aligned(words), \"unaligned size\");\n-}\n-\n@@ -503,1 +497,2 @@\n-  DEBUG_ONLY(fill_args_check(start, words);)\n+  assert(words >= min_fill_size(), \"too small to fill\");\n+  assert(is_object_aligned(words), \"unaligned size\");\n@@ -510,1 +505,2 @@\n-  DEBUG_ONLY(fill_args_check(start, words);)\n+  assert(words >= min_fill_size(), \"too small to fill\");\n+  assert(is_object_aligned(words), \"unaligned size\");\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-  DEBUG_ONLY(static void fill_args_check(HeapWord* start, size_t words);)\n@@ -314,3 +313,0 @@\n-  static void fill_with_object(MemRegion region, bool zap = true) {\n-    fill_with_object(region.start(), region.word_size(), zap);\n-  }\n@@ -349,1 +345,1 @@\n-  virtual size_t tlab_capacity(Thread *thr) const = 0;\n+  virtual size_t tlab_capacity() const = 0;\n@@ -351,2 +347,2 @@\n-  \/\/ The amount of used space for thread-local allocation buffers for the given thread.\n-  virtual size_t tlab_used(Thread *thr) const = 0;\n+  \/\/ The amount of space used for thread-local allocation buffers.\n+  virtual size_t tlab_used() const = 0;\n@@ -359,1 +355,1 @@\n-  virtual size_t unsafe_max_tlab_alloc(Thread *thr) const = 0;\n+  virtual size_t unsafe_max_tlab_alloc() const = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_MODREFBARRIERSET_HPP\n-#define SHARE_GC_SHARED_MODREFBARRIERSET_HPP\n-\n-#include \"gc\/shared\/barrierSet.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-\n-class Klass;\n-\n-class ModRefBarrierSet: public BarrierSet {\n-protected:\n-  ModRefBarrierSet(BarrierSetAssembler* barrier_set_assembler,\n-                   BarrierSetC1* barrier_set_c1,\n-                   BarrierSetC2* barrier_set_c2,\n-                   const BarrierSet::FakeRtti& fake_rtti)\n-    : BarrierSet(barrier_set_assembler,\n-                 barrier_set_c1,\n-                 barrier_set_c2,\n-                 nullptr \/* barrier_set_nmethod *\/,\n-                 nullptr \/* barrier_set_stack_chunk *\/,\n-                 fake_rtti.add_tag(BarrierSet::ModRef)) { }\n-  ~ModRefBarrierSet() { }\n-\n-public:\n-  template <DecoratorSet decorators, typename T>\n-  inline void write_ref_field_pre(T* addr) {}\n-\n-  template <DecoratorSet decorators, typename T>\n-  inline void write_ref_field_post(T *addr) {}\n-\n-  \/\/ Causes all refs in \"mr\" to be assumed to be modified (by this JavaThread).\n-  virtual void write_region(MemRegion mr) = 0;\n-\n-  \/\/ Operations on arrays, or general regions (e.g., for \"clone\") may be\n-  \/\/ optimized by some barriers.\n-\n-  \/\/ Below length is the # array elements being written\n-  virtual void write_ref_array_pre(oop* dst, size_t length,\n-                                   bool dest_uninitialized) {}\n-  virtual void write_ref_array_pre(narrowOop* dst, size_t length,\n-                                   bool dest_uninitialized) {}\n-  \/\/ Below count is the # array elements being written, starting\n-  \/\/ at the address \"start\", which may not necessarily be HeapWord-aligned\n-  inline void write_ref_array(HeapWord* start, size_t count);\n-\n-  \/\/ The ModRef abstraction introduces pre and post barriers\n-  template <DecoratorSet decorators, typename BarrierSetT>\n-  class AccessBarrier: public BarrierSet::AccessBarrier<decorators, BarrierSetT> {\n-    typedef BarrierSet::AccessBarrier<decorators, BarrierSetT> Raw;\n-\n-  public:\n-    template <typename T>\n-    static void oop_store_in_heap(T* addr, oop value);\n-    template <typename T>\n-    static oop oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value);\n-    template <typename T>\n-    static oop oop_atomic_xchg_in_heap(T* addr, oop new_value);\n-\n-    template <typename T>\n-    static void oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n-                                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n-                                      size_t length);\n-  private:\n-    \/\/ Failing checkcast or check null during copy, still needs barrier\n-    template <typename T>\n-    static inline void oop_arraycopy_partial_barrier(BarrierSetT *bs, T* dst_raw, T* p);\n-  public:\n-    static void clone_in_heap(oop src, oop dst, size_t size);\n-\n-    static void oop_store_in_heap_at(oop base, ptrdiff_t offset, oop value) {\n-      oop_store_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), value);\n-    }\n-\n-    static oop oop_atomic_xchg_in_heap_at(oop base, ptrdiff_t offset, oop new_value) {\n-      return oop_atomic_xchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), new_value);\n-    }\n-\n-    static oop oop_atomic_cmpxchg_in_heap_at(oop base, ptrdiff_t offset, oop compare_value, oop new_value) {\n-      return oop_atomic_cmpxchg_in_heap(AccessInternal::oop_field_addr<decorators>(base, offset), compare_value, new_value);\n-    }\n-\n-    static void value_copy_in_heap(void* src, void* dst, InlineKlass* md, LayoutKind lk);\n-  };\n-};\n-\n-template<>\n-struct BarrierSet::GetName<ModRefBarrierSet> {\n-  static const BarrierSet::Name value = BarrierSet::ModRef;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_MODREFBARRIERSET_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,197 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_MODREFBARRIERSET_INLINE_HPP\n-#define SHARE_GC_SHARED_MODREFBARRIERSET_INLINE_HPP\n-\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n-\n-#include \"gc\/shared\/barrierSet.hpp\"\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/inlineKlass.inline.hpp\"\n-#include \"oops\/objArrayOop.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"runtime\/thread.hpp\"\n-\n-class Klass;\n-\n-\/\/ count is number of array elements being written\n-void ModRefBarrierSet::write_ref_array(HeapWord* start, size_t count) {\n-  HeapWord* end = (HeapWord*)((char*)start + (count*heapOopSize));\n-  \/\/ In the case of compressed oops, start and end may potentially be misaligned;\n-  \/\/ so we need to conservatively align the first downward (this is not\n-  \/\/ strictly necessary for current uses, but a case of good hygiene and,\n-  \/\/ if you will, aesthetics) and the second upward (this is essential for\n-  \/\/ current uses) to a HeapWord boundary, so we mark all cards overlapping\n-  \/\/ this write. If this evolves in the future to calling a\n-  \/\/ logging barrier of narrow oop granularity, like the pre-barrier for G1\n-  \/\/ (mentioned here merely by way of example), we will need to change this\n-  \/\/ interface, so it is \"exactly precise\" (if i may be allowed the adverbial\n-  \/\/ redundancy for emphasis) and does not include narrow oop slots not\n-  \/\/ included in the original write interval.\n-  HeapWord* aligned_start = align_down(start, HeapWordSize);\n-  HeapWord* aligned_end   = align_up  (end,   HeapWordSize);\n-  \/\/ If compressed oops were not being used, these should already be aligned\n-  assert(UseCompressedOops || (aligned_start == start && aligned_end == end),\n-         \"Expected heap word alignment of start and end\");\n-  write_region(MemRegion(aligned_start, aligned_end));\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_store_in_heap(T* addr, oop value) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->template write_ref_field_pre<decorators>(addr);\n-  Raw::oop_store(addr, value);\n-  bs->template write_ref_field_post<decorators>(addr);\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline oop ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_atomic_cmpxchg_in_heap(T* addr, oop compare_value, oop new_value) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->template write_ref_field_pre<decorators>(addr);\n-  oop result = Raw::oop_atomic_cmpxchg(addr, compare_value, new_value);\n-  if (result == compare_value) {\n-    bs->template write_ref_field_post<decorators>(addr);\n-  }\n-  return result;\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline oop ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_atomic_xchg_in_heap(T* addr, oop new_value) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->template write_ref_field_pre<decorators>(addr);\n-  oop result = Raw::oop_atomic_xchg(addr, new_value);\n-  bs->template write_ref_field_post<decorators>(addr);\n-  return result;\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_arraycopy_partial_barrier(BarrierSetT *bs, T* dst_raw, T* p) {\n-  const size_t pd = pointer_delta(p, dst_raw, (size_t)heapOopSize);\n-  \/\/ pointer delta is scaled to number of elements (length field in\n-  \/\/ objArrayOop) which we assume is 32 bit.\n-  assert(pd == (size_t)(int)pd, \"length field overflow\");\n-  bs->write_ref_array((HeapWord*)dst_raw, pd);\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-template <typename T>\n-inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, T* src_raw,\n-                      arrayOop dst_obj, size_t dst_offset_in_bytes, T* dst_raw,\n-                      size_t length) {\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-\n-  src_raw = arrayOopDesc::obj_offset_to_raw(src_obj, src_offset_in_bytes, src_raw);\n-  dst_raw = arrayOopDesc::obj_offset_to_raw(dst_obj, dst_offset_in_bytes, dst_raw);\n-\n-  if ((!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) &&\n-      (!HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value)) {\n-    \/\/ Optimized covariant case\n-    bs->write_ref_array_pre(dst_raw, length,\n-                            HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value);\n-    Raw::oop_arraycopy(nullptr, 0, src_raw, nullptr, 0, dst_raw, length);\n-    bs->write_ref_array((HeapWord*)dst_raw, length);\n-  } else {\n-    assert(dst_obj != nullptr, \"better have an actual oop\");\n-    Klass* bound = objArrayOop(dst_obj)->element_klass();\n-    T* from = const_cast<T*>(src_raw);\n-    T* end = from + length;\n-    for (T* p = dst_raw; from < end; from++, p++) {\n-      T element = *from;\n-      \/\/ Apply any required checks\n-      if (HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value && CompressedOops::is_null(element)) {\n-        oop_arraycopy_partial_barrier(bs, dst_raw, p);\n-        throw_array_null_pointer_store_exception(src_obj, dst_obj, JavaThread::current());\n-        return;\n-      }\n-      if (HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value &&\n-          (!oopDesc::is_instanceof_or_null(CompressedOops::decode(element), bound))) {\n-        oop_arraycopy_partial_barrier(bs, dst_raw, p);\n-        throw_array_store_exception(src_obj, dst_obj, JavaThread::current());\n-        return;\n-      }\n-      \/\/ write\n-      bs->template write_ref_field_pre<decorators>(p);\n-      *p = element;\n-    }\n-    bs->write_ref_array((HeapWord*)dst_raw, length);\n-  }\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-clone_in_heap(oop src, oop dst, size_t size) {\n-  Raw::clone(src, dst, size);\n-  BarrierSetT *bs = barrier_set_cast<BarrierSetT>(barrier_set());\n-  bs->write_region(MemRegion((HeapWord*)(void*)dst, size));\n-}\n-\n-template <DecoratorSet decorators, typename BarrierSetT>\n-inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n-value_copy_in_heap(void* src, void* dst, InlineKlass* md, LayoutKind lk) {\n-  if (!md->contains_oops()) {\n-    \/\/ If we do not have oops in the flat array, we can just do a raw copy.\n-    Raw::value_copy(src, dst, md, lk);\n-  } else {\n-    BarrierSetT* bs = barrier_set_cast<BarrierSetT>(BarrierSet::barrier_set());\n-    \/\/ src\/dst aren't oops, need offset to adjust oop map offset\n-    const address dst_oop_addr_offset = ((address) dst) - md->payload_offset();\n-    typedef typename ValueOopType<decorators>::type OopType;\n-\n-    \/\/ Pre-barriers...\n-    OopMapBlock* map = md->start_of_nonstatic_oop_maps();\n-    OopMapBlock* const end = map + md->nonstatic_oop_map_count();\n-    bool is_uninitialized = HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value;\n-    while (map != end) {\n-      address doop_address = dst_oop_addr_offset + map->offset();\n-      \/\/ The pre-barrier only impacts G1, which will emit a barrier if the destination is\n-      \/\/ initialized. Note that we should not emit a barrier if the destination is uninitialized,\n-      \/\/ as doing so will fill the SATB queue with garbage data.\n-      bs->write_ref_array_pre((OopType*) doop_address, map->count(), is_uninitialized);\n-      map++;\n-    }\n-\n-    Raw::value_copy(src, dst, md, lk);\n-\n-    \/\/ Post-barriers...\n-    map = md->start_of_nonstatic_oop_maps();\n-    while (map != end) {\n-      address doop_address = dst_oop_addr_offset + map->offset();\n-      \/\/ The post-barrier needs to be called for initialized and uninitialized destinations.\n-      bs->write_ref_array((HeapWord*) doop_address, map->count());\n-      map++;\n-    }\n-  }\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_MODREFBARRIERSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":0,"deletions":197,"binary":false,"changes":197,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_MODREFBARRIERSETASSEMBLER_HPP\n-#define SHARE_GC_SHARED_MODREFBARRIERSETASSEMBLER_HPP\n-\n-#include \"utilities\/macros.hpp\"\n-\n-#include CPU_HEADER(gc\/shared\/modRefBarrierSetAssembler)\n-\n-#endif \/\/ SHARE_GC_SHARED_MODREFBARRIERSETASSEMBLER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSetAssembler.hpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -38,2 +39,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageParState.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageParState.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,3 +75,2 @@\n-  Thread* thr     = thread();\n-  size_t capacity = Universe::heap()->tlab_capacity(thr);\n-  size_t used     = Universe::heap()->tlab_used(thr);\n+  size_t capacity = Universe::heap()->tlab_capacity();\n+  size_t used = Universe::heap()->tlab_used();\n@@ -80,1 +79,1 @@\n-  size_t total_allocated = thr->allocated_bytes();\n+  size_t total_allocated = (size_t)thread()->allocated_bytes();\n@@ -151,1 +150,1 @@\n-                          (Universe::heap()->tlab_capacity(thread()) \/ HeapWordSize));\n+                          (Universe::heap()->tlab_capacity() \/ HeapWordSize));\n@@ -207,1 +206,1 @@\n-  size_t capacity = Universe::heap()->tlab_capacity(thread()) \/ HeapWordSize;\n+  size_t capacity = Universe::heap()->tlab_capacity() \/ HeapWordSize;\n@@ -271,1 +270,1 @@\n-    init_sz  = (Universe::heap()->tlab_capacity(thread()) \/ HeapWordSize) \/\n+    init_sz  = (Universe::heap()->tlab_capacity() \/ HeapWordSize) \/\n@@ -292,1 +291,1 @@\n-  size_t tlab_used  = Universe::heap()->tlab_used(thrd);\n+  size_t tlab_used  = Universe::heap()->tlab_used();\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-  \/\/ unsafe_max_tlab_alloc is just a hint.\n-  const size_t available_size = Universe::heap()->unsafe_max_tlab_alloc(thread()) \/ HeapWordSize;\n+  const size_t available_size = Universe::heap()->unsafe_max_tlab_alloc() \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,2 +135,1 @@\n-           declare_type(ModRefBarrierSet,             BarrierSet)         \\\n-           declare_type(CardTableBarrierSet,          ModRefBarrierSet)   \\\n+           declare_type(CardTableBarrierSet,             BarrierSet)      \\\n@@ -186,1 +185,0 @@\n-  declare_constant(BarrierSet::ModRef)                                      \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -34,2 +35,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/workerUtils.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  heap->assert_pinned_region_status();\n+  heap->assert_pinned_region_status(_generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                     \"%s, Max Old Evacuation: %zu%s, Actual Free: %zu%s.\",\n+                     \"%s, Max Old Evacuation: %zu%s, Max Either Evacuation: %zu%s, Actual Free: %zu%s.\",\n@@ -94,0 +94,1 @@\n+                     byte_size_in_proper_unit(unaffiliated_young_memory), proper_unit_for_byte_size(unaffiliated_young_memory),\n@@ -136,1 +137,0 @@\n-\n@@ -138,1 +138,1 @@\n-    heap->generation_sizer()->force_transfer_to_old(regions_transferred_to_old);\n+    assert(young_evac_reserve > regions_transferred_to_old * region_size_bytes, \"young reserve cannot be negative\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    size_t live_data_for_evacuation = r->get_live_data_bytes();\n+    const size_t live_data_for_evacuation = r->get_live_data_bytes();\n@@ -172,1 +172,3 @@\n-        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        \/\/ There is no room to evacuate this region or any that come after it in within the candidates array.\n+        log_debug(gc, cset)(\"Not enough unfragmented memory (%zu) to hold evacuees (%zu) from region: (%zu)\",\n+                            unfragmented_available, live_data_for_evacuation, r->index());\n@@ -190,1 +192,3 @@\n-        \/\/ There is not room to evacuate this region or any that come after it in within the candidates array.\n+        \/\/ There is no room to evacuate this region or any that come after it in within the candidates array.\n+        log_debug(gc, cset)(\"Not enough unfragmented memory (%zu) to hold evacuees (%zu) from region: (%zu)\",\n+                            unfragmented_available, live_data_for_evacuation, r->index());\n@@ -605,1 +609,2 @@\n-  size_t old_used = _old_generation->used() + _old_generation->get_humongous_waste();\n+  \/\/ used() includes humongous waste\n+  size_t old_used = _old_generation->used();\n@@ -609,2 +614,1 @@\n-         \"Old used (%zu, %zu) must not be more than heap capacity (%zu)\",\n-         _old_generation->used(), _old_generation->get_humongous_waste(), _heap->capacity());\n+         \"Old used (%zu) must not be more than heap capacity (%zu)\", _old_generation->used(), _heap->capacity());\n@@ -682,1 +686,2 @@\n-    const size_t current_usage = _old_generation->used() + _old_generation->get_humongous_waste();\n+    \/\/ _old_generation->used() includes humongous waste.\n+    const size_t current_usage = _old_generation->used();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -228,3 +228,3 @@\n-      const size_t young_evac_bytes = get_young_bytes_reserved_for_evacuation();\n-      const size_t promote_evac_bytes = get_young_bytes_to_be_promoted();\n-      const size_t old_evac_bytes = get_old_bytes_reserved_for_evacuation();\n+      const size_t young_evac_bytes = get_live_bytes_in_untenurable_regions();\n+      const size_t promote_evac_bytes = get_live_bytes_in_tenurable_regions();\n+      const size_t old_evac_bytes = get_live_bytes_in_old_regions();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-  \/\/ Returns the amount of live bytes in young regions in the collection set. It is not known how many of these bytes will be promoted.\n-  inline size_t get_young_bytes_reserved_for_evacuation() const;\n+  \/\/ Returns the amount of live bytes in young regions with an age below the tenuring threshold.\n+  inline size_t get_live_bytes_in_untenurable_regions() const;\n@@ -116,1 +116,1 @@\n-  inline size_t get_old_bytes_reserved_for_evacuation() const;\n+  inline size_t get_live_bytes_in_old_regions() const;\n@@ -118,2 +118,2 @@\n-  \/\/ Returns the amount of live bytes in young regions with an age above the tenuring threshold.\n-  inline size_t get_young_bytes_to_be_promoted() const;\n+  \/\/ Returns the amount of live bytes in young regions with an age at or above the tenuring threshold.\n+  inline size_t get_live_bytes_in_tenurable_regions() const;\n@@ -128,1 +128,1 @@\n-    assert(_preselected_regions != nullptr, \"Missing etsablish after abandon\");\n+    assert(_preselected_regions != nullptr, \"Missing establish after abandon\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-size_t ShenandoahCollectionSet::get_old_bytes_reserved_for_evacuation() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_old_regions() const {\n@@ -61,1 +61,1 @@\n-size_t ShenandoahCollectionSet::get_young_bytes_reserved_for_evacuation() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_untenurable_regions() const {\n@@ -65,1 +65,1 @@\n-size_t ShenandoahCollectionSet::get_young_bytes_to_be_promoted() const {\n+size_t ShenandoahCollectionSet::get_live_bytes_in_tenurable_regions() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,2 @@\n-  explicit ShenandoahLeftRightIterator(ShenandoahRegionPartitions* partitions, ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n+  explicit ShenandoahLeftRightIterator(ShenandoahRegionPartitions* partitions,\n+                                       ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n@@ -90,1 +91,2 @@\n-  explicit ShenandoahRightLeftIterator(ShenandoahRegionPartitions* partitions, ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n+  explicit ShenandoahRightLeftIterator(ShenandoahRegionPartitions* partitions,\n+                                       ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n@@ -169,0 +171,1 @@\n+  initialize_old_collector();\n@@ -172,0 +175,51 @@\n+void ShenandoahFreeSet::account_for_pip_regions(size_t mutator_regions, size_t mutator_bytes,\n+                                                size_t collector_regions, size_t collector_bytes) {\n+  shenandoah_assert_heaplocked();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  \/\/ We have removed all of these regions from their respective partition. Each pip region is \"in\" the NotFree partition.\n+  \/\/ We want to account for all pip pad memory as if it had been consumed from within the Mutator partition.\n+  \/\/\n+  \/\/ After we finish promote in place, the pad memory will be deallocated and made available within the OldCollector\n+  \/\/ region.  At that time, we will transfer the used memory from the Mutator partition to the OldCollector parttion,\n+  \/\/ and then we will unallocate the pad memory.\n+\n+\n+  _partitions.decrease_region_counts(ShenandoahFreeSetPartitionId::Mutator, mutator_regions);\n+  _partitions.decrease_region_counts(ShenandoahFreeSetPartitionId::Collector, collector_regions);\n+\n+  \/\/ Increase used by remnant fill objects placed in both Mutator and Collector partitions\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, mutator_bytes);\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::Collector, collector_bytes);\n+\n+  \/\/ Now transfer all of the memory contained within Collector pip regions from the Collector to the Mutator.\n+  \/\/ Each of these regions is treated as fully used, even though some of the region's memory may be artifically used,\n+  \/\/ to be recycled and put into allocatable OldCollector partition after the region has been promoted in place.\n+  _partitions.transfer_used_capacity_from_to(ShenandoahFreeSetPartitionId::Collector, ShenandoahFreeSetPartitionId::Mutator,\n+                                             collector_regions);\n+\n+  \/\/ Conservatively, act as if we've promoted from both Mutator and Collector partitions\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ false, \/* CollectorEmptiesChanged *\/ false,\n+                             \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ true,\n+                             \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ false,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+  recompute_total_young_used<\/* UsedByMutatorChanged *\/ true, \/*UsedByCollectorChanged *\/ true>();\n+  recompute_total_global_used<\/* UsedByMutatorChanged *\/ true, \/* UsedByCollectorChanged *\/ true,\n+                              \/* UsedByOldCollectorChanged *\/ false>();\n+}\n+\n+ShenandoahFreeSetPartitionId ShenandoahFreeSet::prepare_to_promote_in_place(size_t idx, size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  size_t min_remnant_size = PLAB::min_size() * HeapWordSize;\n+  ShenandoahFreeSetPartitionId p =  _partitions.membership(idx);\n+  if (bytes >= min_remnant_size) {\n+    assert((p == ShenandoahFreeSetPartitionId::Mutator) || (p == ShenandoahFreeSetPartitionId::Collector),\n+           \"PIP region must be associated with young\");\n+    _partitions.raw_clear_membership(idx, p);\n+  } else {\n+    assert(p == ShenandoahFreeSetPartitionId::NotFree, \"We did not fill this region and do not need to adjust used\");\n+  }\n+  return p;\n+}\n+\n@@ -199,0 +253,48 @@\n+\/\/ This is used for unit testing.  Do not use in production code.\n+void ShenandoahFreeSet::resize_old_collector_capacity(size_t regions) {\n+  shenandoah_assert_heaplocked();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t original_old_regions = _partitions.get_capacity(ShenandoahFreeSetPartitionId::OldCollector) \/ region_size_bytes;\n+  size_t unaffiliated_mutator_regions = _partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::Mutator);\n+  size_t unaffiliated_collector_regions = _partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::Collector);\n+  size_t unaffiliated_old_collector_regions = _partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::OldCollector);\n+  if (regions > original_old_regions) {\n+    size_t regions_to_transfer = regions - original_old_regions;\n+    if (regions_to_transfer <= unaffiliated_mutator_regions + unaffiliated_collector_regions) {\n+      size_t regions_from_mutator =\n+        (regions_to_transfer > unaffiliated_mutator_regions)? unaffiliated_mutator_regions: regions_to_transfer;\n+      regions_to_transfer -= regions_from_mutator;\n+      size_t regions_from_collector = regions_to_transfer;\n+      if (regions_from_mutator > 0) {\n+        transfer_empty_regions_from_to(ShenandoahFreeSetPartitionId::Mutator, ShenandoahFreeSetPartitionId::OldCollector,\n+                                       regions_from_mutator);\n+      }\n+      if (regions_from_collector > 0) {\n+        transfer_empty_regions_from_to(ShenandoahFreeSetPartitionId::Collector, ShenandoahFreeSetPartitionId::OldCollector,\n+                                       regions_from_mutator);\n+      }\n+    } else {\n+      fatal(\"Could not resize old for unit test\");\n+    }\n+  } else if (regions < original_old_regions) {\n+    size_t regions_to_transfer = original_old_regions - regions;\n+    if (regions_to_transfer <= unaffiliated_old_collector_regions) {\n+      transfer_empty_regions_from_to(ShenandoahFreeSetPartitionId::OldCollector, ShenandoahFreeSetPartitionId::Mutator,\n+                                     regions_to_transfer);\n+    } else {\n+      fatal(\"Could not resize old for unit test\");\n+    }\n+  }\n+  \/\/ else, old generation is already appropriately sized\n+}\n+\n+void ShenandoahFreeSet::reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated) {\n+  shenandoah_assert_heaplocked();\n+  _mutator_bytes_allocated_since_gc_start = initial_bytes_allocated;\n+}\n+\n+void ShenandoahFreeSet::increase_bytes_allocated(size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  _mutator_bytes_allocated_since_gc_start += bytes;\n+}\n+\n@@ -221,0 +323,6 @@\n+void ShenandoahRegionPartitions::initialize_old_collector() {\n+  _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] = 0;\n+  _region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = 0;\n+  _empty_region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = 0;\n+}\n+\n@@ -230,0 +338,2 @@\n+    _region_counts[partition_id] = 0;\n+    _empty_region_counts[partition_id] = 0;\n@@ -231,0 +341,1 @@\n+    _humongous_waste[partition_id] = 0;\n@@ -233,1 +344,0 @@\n-  _region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = _region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -238,1 +348,3 @@\n-                                                             size_t mutator_region_count, size_t mutator_used) {\n+                                                             size_t total_mutator_regions, size_t empty_mutator_regions,\n+                                                             size_t mutator_region_count, size_t mutator_used,\n+                                                             size_t mutator_humongous_waste_bytes) {\n@@ -248,1 +360,2 @@\n-  _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_region_count * _region_size_bytes;\n+  _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] = total_mutator_regions * _region_size_bytes;\n+  _humongous_waste[int(ShenandoahFreeSetPartitionId::Mutator)] = mutator_humongous_waste_bytes;\n@@ -252,0 +365,2 @@\n+  _empty_region_counts[int(ShenandoahFreeSetPartitionId::Mutator)] = empty_mutator_regions;\n+\n@@ -260,0 +375,1 @@\n+  _humongous_waste[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -261,0 +377,2 @@\n+\n+  _empty_region_counts[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -263,1 +381,2 @@\n-void ShenandoahRegionPartitions::establish_old_collector_intervals(idx_t old_collector_leftmost, idx_t old_collector_rightmost,\n+void ShenandoahRegionPartitions::establish_old_collector_intervals(idx_t old_collector_leftmost,\n+                                                                   idx_t old_collector_rightmost,\n@@ -266,1 +385,4 @@\n-                                                                   size_t old_collector_region_count, size_t old_collector_used) {\n+                                                                   size_t total_old_collector_region_count,\n+                                                                   size_t old_collector_empty, size_t old_collector_regions,\n+                                                                   size_t old_collector_used,\n+                                                                   size_t old_collector_humongous_waste_bytes) {\n@@ -274,1 +396,1 @@\n-  _region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_region_count;\n+  _region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_regions;\n@@ -276,1 +398,2 @@\n-  _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_region_count * _region_size_bytes;\n+  _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] = total_old_collector_region_count * _region_size_bytes;\n+  _humongous_waste[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_humongous_waste_bytes;\n@@ -279,0 +402,2 @@\n+\n+  _empty_region_counts[int(ShenandoahFreeSetPartitionId::OldCollector)] = old_collector_empty;\n@@ -292,2 +417,102 @@\n-inline void ShenandoahRegionPartitions::shrink_interval_if_range_modifies_either_boundary(\n-  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx) {\n+void ShenandoahRegionPartitions::decrease_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  assert (_used[int(which_partition)] >= bytes, \"Must not use less than zero after decrease\");\n+  _used[int(which_partition)] -= bytes;\n+  _available[int(which_partition)] += bytes;\n+}\n+\n+void ShenandoahRegionPartitions::increase_humongous_waste(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  _humongous_waste[int(which_partition)] += bytes;\n+}\n+\n+size_t ShenandoahRegionPartitions::get_humongous_waste(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  return _humongous_waste[int(which_partition)];;\n+}\n+\n+void ShenandoahRegionPartitions::set_capacity_of(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n+  shenandoah_assert_heaplocked();\n+  assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+  _capacity[int(which_partition)] = value;\n+  _available[int(which_partition)] = value - _used[int(which_partition)];\n+}\n+\n+\n+void ShenandoahRegionPartitions::increase_capacity(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  _capacity[int(which_partition)] += bytes;\n+  _available[int(which_partition)] += bytes;\n+}\n+\n+void ShenandoahRegionPartitions::transfer_used_capacity_from_to(ShenandoahFreeSetPartitionId from_partition,\n+                                                                ShenandoahFreeSetPartitionId to_partition, size_t regions) {\n+  shenandoah_assert_heaplocked();\n+  size_t bytes = regions * ShenandoahHeapRegion::region_size_bytes();\n+  assert (from_partition < NumPartitions, \"Partition must be valid\");\n+  assert (to_partition < NumPartitions, \"Partition must be valid\");\n+  assert(_capacity[int(from_partition)] >= bytes, \"Cannot remove more capacity bytes than are present\");\n+  assert(_used[int(from_partition)] >= bytes, \"Cannot transfer used bytes that are not used\");\n+\n+  \/\/ available is unaffected by transfer\n+  _capacity[int(from_partition)] -= bytes;\n+  _used[int(from_partition)] -= bytes;\n+  _capacity[int(to_partition)] += bytes;\n+  _used[int(to_partition)] += bytes;\n+}\n+\n+void ShenandoahRegionPartitions::decrease_capacity(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  assert(_capacity[int(which_partition)] >= bytes, \"Cannot remove more capacity bytes than are present\");\n+  assert(_available[int(which_partition)] >= bytes, \"Cannot shrink capacity unless capacity is unused\");\n+  _capacity[int(which_partition)] -= bytes;\n+  _available[int(which_partition)] -= bytes;\n+}\n+\n+void ShenandoahRegionPartitions::increase_available(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  _available[int(which_partition)] += bytes;\n+}\n+\n+void ShenandoahRegionPartitions::decrease_available(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+  shenandoah_assert_heaplocked();\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  assert(_available[int(which_partition)] >= bytes, \"Cannot remove more available bytes than are present\");\n+  _available[int(which_partition)] -= bytes;\n+}\n+\n+size_t ShenandoahRegionPartitions::get_available(ShenandoahFreeSetPartitionId which_partition) {\n+  assert (which_partition < NumPartitions, \"Partition must be valid\");\n+  return _available[int(which_partition)];;\n+}\n+\n+void ShenandoahRegionPartitions::increase_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions) {\n+  _region_counts[int(which_partition)] += regions;\n+}\n+\n+void ShenandoahRegionPartitions::decrease_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions) {\n+  assert(_region_counts[int(which_partition)] >= regions, \"Cannot remove more regions than are present\");\n+  _region_counts[int(which_partition)] -= regions;\n+}\n+\n+void ShenandoahRegionPartitions::increase_empty_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions) {\n+  _empty_region_counts[int(which_partition)] += regions;\n+}\n+\n+void ShenandoahRegionPartitions::decrease_empty_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions) {\n+  assert(_empty_region_counts[int(which_partition)] >= regions, \"Cannot remove more regions than are present\");\n+  _empty_region_counts[int(which_partition)] -= regions;\n+}\n+\n+void ShenandoahRegionPartitions::one_region_is_no_longer_empty(ShenandoahFreeSetPartitionId partition) {\n+  decrease_empty_region_counts(partition, (size_t) 1);\n+}\n+\n+\/\/ All members of partition between low_idx and high_idx inclusive have been removed.\n+void ShenandoahRegionPartitions::shrink_interval_if_range_modifies_either_boundary(\n+  ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx, size_t num_regions) {\n@@ -295,0 +520,2 @@\n+  size_t span = high_idx + 1 - low_idx;\n+  bool regions_are_contiguous = (span == num_regions);\n@@ -298,1 +525,5 @@\n-      _leftmosts[int(partition)] = _max;\n+      if (regions_are_contiguous) {\n+        _leftmosts[int(partition)] = _max;\n+      } else {\n+        _leftmosts[int(partition)] = find_index_of_next_available_region(partition, low_idx + 1);\n+      }\n@@ -300,1 +531,5 @@\n-      _leftmosts[int(partition)] = find_index_of_next_available_region(partition, high_idx + 1);\n+      if (regions_are_contiguous) {\n+        _leftmosts[int(partition)] = find_index_of_next_available_region(partition, high_idx + 1);\n+      } else {\n+        _leftmosts[int(partition)] = find_index_of_next_available_region(partition, low_idx + 1);\n+      }\n@@ -310,1 +545,5 @@\n-      _rightmosts[int(partition)] = -1;\n+      if (regions_are_contiguous) {\n+        _rightmosts[int(partition)] = -1;\n+      } else {\n+        _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, high_idx - 1);\n+      }\n@@ -312,1 +551,5 @@\n-      _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, low_idx - 1);\n+      if (regions_are_contiguous) {\n+        _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, low_idx - 1);\n+      } else {\n+        _rightmosts[int(partition)] = find_index_of_previous_available_region(partition, high_idx - 1);\n+      }\n@@ -327,2 +570,45 @@\n-inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, idx_t idx) {\n-  shrink_interval_if_range_modifies_either_boundary(partition, idx, idx);\n+void ShenandoahRegionPartitions::establish_interval(ShenandoahFreeSetPartitionId partition, idx_t low_idx,\n+                                                    idx_t high_idx, idx_t low_empty_idx, idx_t high_empty_idx) {\n+#ifdef ASSERT\n+  assert (partition < NumPartitions, \"invalid partition\");\n+  if (low_idx != max()) {\n+    assert((low_idx <= high_idx) && (low_idx >= 0) && (high_idx < _max), \"Range must span legal index values\");\n+    assert (in_free_set(partition, low_idx), \"Must be in partition of established interval\");\n+    assert (in_free_set(partition, high_idx), \"Must be in partition of established interval\");\n+  }\n+  if (low_empty_idx != max()) {\n+    ShenandoahHeapRegion* r = ShenandoahHeap::heap()->get_region(low_empty_idx);\n+    assert (in_free_set(partition, low_empty_idx) && (r->is_trash() || r->free() == _region_size_bytes),\n+            \"Must be empty and in partition of established interval\");\n+    r = ShenandoahHeap::heap()->get_region(high_empty_idx);\n+    assert (in_free_set(partition, high_empty_idx), \"Must be in partition of established interval\");\n+  }\n+#endif\n+\n+  _leftmosts[int(partition)] = low_idx;\n+  _rightmosts[int(partition)] = high_idx;\n+  _leftmosts_empty[int(partition)] = low_empty_idx;\n+  _rightmosts_empty[int(partition)] = high_empty_idx;\n+}\n+\n+inline void ShenandoahRegionPartitions::shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n+                                                                             idx_t idx) {\n+  shrink_interval_if_range_modifies_either_boundary(partition, idx, idx, 1);\n+}\n+\n+\/\/ Some members of partition between low_idx and high_idx inclusive have been added.\n+void ShenandoahRegionPartitions::\n+expand_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx,\n+                                                  idx_t low_empty_idx, idx_t high_empty_idx) {\n+  if (_leftmosts[int(partition)] > low_idx) {\n+    _leftmosts[int(partition)] = low_idx;\n+  }\n+  if (_rightmosts[int(partition)] < high_idx) {\n+    _rightmosts[int(partition)] = high_idx;\n+  }\n+  if (_leftmosts_empty[int(partition)] > low_empty_idx) {\n+    _leftmosts_empty[int(partition)] = low_empty_idx;\n+  }\n+  if (_rightmosts_empty[int(partition)] < high_empty_idx) {\n+    _rightmosts_empty[int(partition)] = high_empty_idx;\n+  }\n@@ -331,2 +617,2 @@\n-inline void ShenandoahRegionPartitions::expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n-                                                                             idx_t idx, size_t region_available) {\n+void ShenandoahRegionPartitions::expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition,\n+                                                                      idx_t idx, size_t region_available) {\n@@ -358,0 +644,2 @@\n+#ifdef ASSERT\n+    ShenandoahHeapRegion* r = ShenandoahHeap::heap()->get_region(idx);\n@@ -359,0 +647,2 @@\n+    assert(r->is_empty() || r->is_trash(), \"Region must be empty or trash\");\n+#endif\n@@ -361,2 +651,4 @@\n-  _region_counts[int(partition)] -= high_idx + 1 - low_idx;\n-  shrink_interval_if_range_modifies_either_boundary(partition, low_idx, high_idx);\n+  size_t num_regions = high_idx + 1 - low_idx;\n+  decrease_region_counts(partition, num_regions);\n+  decrease_empty_region_counts(partition, num_regions);\n+  shrink_interval_if_range_modifies_either_boundary(partition, low_idx, high_idx, num_regions);\n@@ -365,1 +657,2 @@\n-void ShenandoahRegionPartitions::retire_from_partition(ShenandoahFreeSetPartitionId partition, idx_t idx, size_t used_bytes) {\n+size_t ShenandoahRegionPartitions::retire_from_partition(ShenandoahFreeSetPartitionId partition,\n+                                                         idx_t idx, size_t used_bytes) {\n@@ -367,0 +660,1 @@\n+  size_t waste_bytes = 0;\n@@ -374,1 +668,3 @@\n-    increase_used(partition, _region_size_bytes - used_bytes);\n+    size_t fill_padding = _region_size_bytes - used_bytes;\n+    waste_bytes = fill_padding;\n+    increase_used(partition, fill_padding);\n@@ -377,0 +673,1 @@\n+  decrease_region_counts(partition, 1);\n@@ -378,1 +675,10 @@\n-  _region_counts[int(partition)]--;\n+\n+  \/\/ This region is fully used, whether or not top() equals end().  It\n+  \/\/ is retired and no more memory will be allocated from within it.\n+\n+  return waste_bytes;\n+}\n+\n+void ShenandoahRegionPartitions::unretire_to_partition(ShenandoahHeapRegion* r, ShenandoahFreeSetPartitionId which_partition) {\n+  shenandoah_assert_heaplocked();\n+  make_free(r->index(), which_partition, r->free());\n@@ -381,0 +687,3 @@\n+\n+\/\/ The caller is responsible for increasing capacity and available and used in which_partition, and decreasing the\n+\/\/ same quantities for the original partition\n@@ -389,3 +698,0 @@\n-  _capacity[int(which_partition)] += _region_size_bytes;\n-  _used[int(which_partition)] += _region_size_bytes - available;\n-  _available[int(which_partition)] += available;\n@@ -393,1 +699,0 @@\n-  _region_counts[int(which_partition)]++;\n@@ -412,3 +717,4 @@\n-\n-void ShenandoahRegionPartitions::move_from_partition_to_partition(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n-                                                                  ShenandoahFreeSetPartitionId new_partition, size_t available) {\n+\/\/ Do not adjust capacities, available, or used.  Return used delta.\n+size_t ShenandoahRegionPartitions::\n+move_from_partition_to_partition_with_deferred_accounting(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                                          ShenandoahFreeSetPartitionId new_partition, size_t available) {\n@@ -452,0 +758,2 @@\n+  return used;\n+}\n@@ -453,0 +761,7 @@\n+void ShenandoahRegionPartitions::move_from_partition_to_partition(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                                                  ShenandoahFreeSetPartitionId new_partition, size_t available) {\n+  size_t used = move_from_partition_to_partition_with_deferred_accounting(idx, orig_partition, new_partition, available);\n+\n+  \/\/ We decreased used, which increases available, but then we decrease available by full region size below\n+  decrease_used(orig_partition, used);\n+  _region_counts[int(orig_partition)]--;\n@@ -454,2 +769,1 @@\n-  _used[int(orig_partition)] -= used;\n-  _available[int(orig_partition)] -= available;\n+  _available[int(orig_partition)] -= _region_size_bytes;\n@@ -458,3 +772,5 @@\n-  _capacity[int(new_partition)] += _region_size_bytes;;\n-  _used[int(new_partition)] += used;\n-  _available[int(new_partition)] += available;\n+  _capacity[int(new_partition)] += _region_size_bytes;\n+  _available[int(new_partition)] += _region_size_bytes;\n+  _region_counts[int(new_partition)]++;\n+  \/\/ We increased availableby full region size above, but decrease it by used within this region now.\n+  increase_used(new_partition, used);\n@@ -463,2 +779,4 @@\n-  _region_counts[int(orig_partition)]--;\n-  _region_counts[int(new_partition)]++;\n+  if (available == _region_size_bytes) {\n+    _empty_region_counts[int(orig_partition)]--;\n+    _empty_region_counts[int(new_partition)]++;\n+  }\n@@ -471,12 +789,0 @@\n-inline ShenandoahFreeSetPartitionId ShenandoahRegionPartitions::membership(idx_t idx) const {\n-  assert (idx < _max, \"index is sane: %zu < %zu\", idx, _max);\n-  ShenandoahFreeSetPartitionId result = ShenandoahFreeSetPartitionId::NotFree;\n-  for (uint partition_id = 0; partition_id < UIntNumPartitions; partition_id++) {\n-    if (_membership[partition_id].is_set(idx)) {\n-      assert(result == ShenandoahFreeSetPartitionId::NotFree, \"Region should reside in only one partition\");\n-      result = (ShenandoahFreeSetPartitionId) partition_id;\n-    }\n-  }\n-  return result;\n-}\n-\n@@ -535,1 +841,2 @@\n-  idx_t result = _membership[int(which_partition)].find_first_consecutive_set_bits(start_index, rightmost_idx + 1, cluster_size);\n+  idx_t result =\n+    _membership[int(which_partition)].find_first_consecutive_set_bits(start_index, rightmost_idx + 1, cluster_size);\n@@ -597,1 +904,13 @@\n-void ShenandoahRegionPartitions::assert_bounds() {\n+void ShenandoahRegionPartitions::assert_bounds(bool validate_totals) {\n+\n+  size_t capacities[UIntNumPartitions];\n+  size_t used[UIntNumPartitions];\n+  size_t regions[UIntNumPartitions];\n+  size_t humongous_waste[UIntNumPartitions];\n+\n+  \/\/ We don't know whether young retired regions belonged to Mutator or Collector before they were retired.\n+  \/\/ We just tally the total, and divide it to make matches work if possible.\n+  size_t young_retired_regions = 0;\n+  size_t young_retired_used = 0;\n+  size_t young_retired_capacity = 0;\n+  size_t young_humongous_waste = 0;\n@@ -609,0 +928,4 @@\n+    capacities[i] = 0;\n+    used[i] = 0;\n+    regions[i] = 0;\n+    humongous_waste[i] = 0;\n@@ -613,0 +936,1 @@\n+    size_t capacity = _free_set->alloc_capacity(i);\n@@ -615,1 +939,36 @@\n-        break;\n+      {\n+        assert(!validate_totals || (capacity != _region_size_bytes), \"Should not be retired if empty\");\n+        ShenandoahHeapRegion* r = ShenandoahHeap::heap()->get_region(i);\n+        if (r->is_humongous()) {\n+          if (r->is_old()) {\n+            regions[int(ShenandoahFreeSetPartitionId::OldCollector)]++;\n+            used[int(ShenandoahFreeSetPartitionId::OldCollector)] += _region_size_bytes;\n+            capacities[int(ShenandoahFreeSetPartitionId::OldCollector)] += _region_size_bytes;\n+            humongous_waste[int(ShenandoahFreeSetPartitionId::OldCollector)] += capacity;\n+          } else {\n+            assert(r->is_young(), \"Must be young if not old\");\n+            young_retired_regions++;\n+            \/\/ Count entire region as used even if there is some waste.\n+            young_retired_used += _region_size_bytes;\n+            young_retired_capacity += _region_size_bytes;\n+            young_humongous_waste += capacity;\n+          }\n+        } else {\n+          assert(r->is_cset() || (capacity < PLAB::min_size() * HeapWordSize),\n+                 \"Expect retired remnant size to be smaller than min plab size\");\n+          \/\/ This region has been retired already or it is in the cset.  In either case, we set capacity to zero\n+          \/\/ so that the entire region will be counted as used.  We count young cset regions as \"retired\".\n+          capacity = 0;\n+          if (r->is_old()) {\n+            regions[int(ShenandoahFreeSetPartitionId::OldCollector)]++;\n+            used[int(ShenandoahFreeSetPartitionId::OldCollector)] += _region_size_bytes - capacity;\n+            capacities[int(ShenandoahFreeSetPartitionId::OldCollector)] += _region_size_bytes;\n+          } else {\n+            assert(r->is_young(), \"Must be young if not old\");\n+            young_retired_regions++;\n+            young_retired_used += _region_size_bytes - capacity;\n+            young_retired_capacity += _region_size_bytes;\n+          }\n+        }\n+      }\n+      break;\n@@ -621,2 +980,0 @@\n-        size_t capacity = _free_set->alloc_capacity(i);\n-        bool is_empty = (capacity == _region_size_bytes);\n@@ -624,0 +981,5 @@\n+        bool is_empty = (capacity == _region_size_bytes);\n+        regions[int(partition)]++;\n+        used[int(partition)] += _region_size_bytes - capacity;\n+        capacities[int(partition)] += _region_size_bytes;\n+\n@@ -662,1 +1024,1 @@\n-          \"free regions before the leftmost: %zd, bound %zd\",\n+          \"Mutator free regions before the leftmost: %zd, bound %zd\",\n@@ -665,1 +1027,1 @@\n-          \"free regions past the rightmost: %zd, bound %zd\",\n+          \"Mutator free regions past the rightmost: %zd, bound %zd\",\n@@ -671,1 +1033,1 @@\n-          \"free empty regions before the leftmost: %zd, bound %zd\",\n+          \"Mutator free empty regions before the leftmost: %zd, bound %zd\",\n@@ -674,1 +1036,1 @@\n-          \"free empty regions past the rightmost: %zd, bound %zd\",\n+          \"Mutator free empty regions past the rightmost: %zd, bound %zd\",\n@@ -685,1 +1047,1 @@\n-          \"leftmost region should be free: %zd\",  leftmost(ShenandoahFreeSetPartitionId::Collector));\n+          \"Collector leftmost region should be free: %zd\",  leftmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -688,1 +1050,1 @@\n-          \"rightmost region should be free: %zd\", rightmost(ShenandoahFreeSetPartitionId::Collector));\n+          \"Collector rightmost region should be free: %zd\", rightmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -695,1 +1057,1 @@\n-          \"free regions before the leftmost: %zd, bound %zd\",\n+          \"Collector free regions before the leftmost: %zd, bound %zd\",\n@@ -698,1 +1060,1 @@\n-          \"free regions past the rightmost: %zd, bound %zd\",\n+          \"Collector free regions past the rightmost: %zd, bound %zd\",\n@@ -704,1 +1066,1 @@\n-          \"free empty regions before the leftmost: %zd, bound %zd\",\n+          \"Collector free empty regions before the leftmost: %zd, bound %zd\",\n@@ -707,1 +1069,1 @@\n-          \"free empty regions past the rightmost: %zd, bound %zd\",\n+          \"Collector free empty regions past the rightmost: %zd, bound %zd\",\n@@ -711,1 +1073,1 @@\n-  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) <= _max, \"leftmost in bounds: %zd < %zd\",\n+  assert (leftmost(ShenandoahFreeSetPartitionId::OldCollector) <= _max, \"OldCollector leftmost in bounds: %zd < %zd\",\n@@ -713,1 +1075,1 @@\n-  assert (rightmost(ShenandoahFreeSetPartitionId::OldCollector) < _max, \"rightmost in bounds: %zd < %zd\",\n+  assert (rightmost(ShenandoahFreeSetPartitionId::OldCollector) < _max, \"OldCollector rightmost in bounds: %zd < %zd\",\n@@ -719,1 +1081,1 @@\n-          \"leftmost region should be free: %zd\",  leftmost(ShenandoahFreeSetPartitionId::OldCollector));\n+          \"OldCollector leftmost region should be free: %zd\",  leftmost(ShenandoahFreeSetPartitionId::OldCollector));\n@@ -723,1 +1085,1 @@\n-          \"rightmost region should be free: %zd\", rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+          \"OldCollector rightmost region should be free: %zd\", rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n@@ -730,1 +1092,1 @@\n-          \"free regions before the leftmost: %zd, bound %zd\",\n+          \"OldCollector free regions before the leftmost: %zd, bound %zd\",\n@@ -733,1 +1095,1 @@\n-          \"free regions past the rightmost: %zd, bound %zd\",\n+          \"OldCollector free regions past the rightmost: %zd, bound %zd\",\n@@ -739,1 +1101,1 @@\n-          \"free empty regions before the leftmost: %zd, bound %zd\",\n+          \"OldCollector free empty regions before the leftmost: %zd, bound %zd\",\n@@ -742,1 +1104,1 @@\n-          \"free empty regions past the rightmost: %zd, bound %zd\",\n+          \"OldCollector free empty regions past the rightmost: %zd, bound %zd\",\n@@ -744,0 +1106,81 @@\n+\n+  if (validate_totals) {\n+    \/\/ young_retired_regions need to be added to either Mutator or Collector partitions, 100% used.\n+    \/\/ Give enough of young_retired_regions, young_retired_capacity, young_retired_user\n+    \/\/  to the Mutator partition to top it off so that it matches the running totals.\n+    \/\/\n+    \/\/ Give any remnants to the Collector partition.  After topping off the Collector partition, its values\n+    \/\/  should also match running totals.\n+\n+    assert(young_retired_regions * _region_size_bytes == young_retired_capacity, \"sanity\");\n+    assert(young_retired_capacity == young_retired_used, \"sanity\");\n+\n+\n+    assert(capacities[int(ShenandoahFreeSetPartitionId::OldCollector)]\n+           == _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)], \"Old collector capacities must match\");\n+    assert(used[int(ShenandoahFreeSetPartitionId::OldCollector)]\n+           == _used[int(ShenandoahFreeSetPartitionId::OldCollector)], \"Old collector used must match\");\n+    assert(regions[int(ShenandoahFreeSetPartitionId::OldCollector)]\n+           == _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] \/ _region_size_bytes, \"Old collector regions must match\");\n+    assert(_capacity[int(ShenandoahFreeSetPartitionId::OldCollector)]\n+           >= _used[int(ShenandoahFreeSetPartitionId::OldCollector)], \"Old Collector capacity must be >= used\");\n+    assert(_available[int(ShenandoahFreeSetPartitionId::OldCollector)] ==\n+           (_capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] - _used[int(ShenandoahFreeSetPartitionId::OldCollector)]),\n+           \"Old Collector available must equal capacity minus used\");\n+    assert(_humongous_waste[int(ShenandoahFreeSetPartitionId::OldCollector)] ==\n+           humongous_waste[int(ShenandoahFreeSetPartitionId::OldCollector)], \"Old Collector humongous waste must match\");\n+\n+    assert(_capacity[int(ShenandoahFreeSetPartitionId::Mutator)] >= capacities[int(ShenandoahFreeSetPartitionId::Mutator)],\n+           \"Capacity total must be >= counted tally\");\n+    size_t mutator_capacity_shortfall =\n+      _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] - capacities[int(ShenandoahFreeSetPartitionId::Mutator)];\n+    assert(mutator_capacity_shortfall <= young_retired_capacity, \"sanity\");\n+    capacities[int(ShenandoahFreeSetPartitionId::Mutator)] += mutator_capacity_shortfall;\n+    young_retired_capacity -= mutator_capacity_shortfall;\n+    capacities[int(ShenandoahFreeSetPartitionId::Collector)] += young_retired_capacity;\n+\n+\n+    assert(_used[int(ShenandoahFreeSetPartitionId::Mutator)] >= used[int(ShenandoahFreeSetPartitionId::Mutator)],\n+           \"Used total must be >= counted tally\");\n+    size_t mutator_used_shortfall =\n+      _used[int(ShenandoahFreeSetPartitionId::Mutator)] - used[int(ShenandoahFreeSetPartitionId::Mutator)];\n+    assert(mutator_used_shortfall <= young_retired_used, \"sanity\");\n+    used[int(ShenandoahFreeSetPartitionId::Mutator)] += mutator_used_shortfall;\n+    young_retired_used -= mutator_used_shortfall;\n+    used[int(ShenandoahFreeSetPartitionId::Collector)] += young_retired_used;\n+\n+    assert(_capacity[int(ShenandoahFreeSetPartitionId::Mutator)] \/ _region_size_bytes\n+           >= regions[int(ShenandoahFreeSetPartitionId::Mutator)], \"Region total must be >= counted tally\");\n+    size_t mutator_regions_shortfall = (_capacity[int(ShenandoahFreeSetPartitionId::Mutator)] \/ _region_size_bytes\n+                                        - regions[int(ShenandoahFreeSetPartitionId::Mutator)]);\n+    assert(mutator_regions_shortfall <= young_retired_regions, \"sanity\");\n+    regions[int(ShenandoahFreeSetPartitionId::Mutator)] += mutator_regions_shortfall;\n+    young_retired_regions -= mutator_regions_shortfall;\n+    regions[int(ShenandoahFreeSetPartitionId::Collector)] += young_retired_regions;\n+\n+    assert(capacities[int(ShenandoahFreeSetPartitionId::Collector)] == _capacity[int(ShenandoahFreeSetPartitionId::Collector)],\n+           \"Collector capacities must match\");\n+    assert(used[int(ShenandoahFreeSetPartitionId::Collector)] == _used[int(ShenandoahFreeSetPartitionId::Collector)],\n+           \"Collector used must match\");\n+    assert(regions[int(ShenandoahFreeSetPartitionId::Collector)]\n+           == _capacity[int(ShenandoahFreeSetPartitionId::Collector)] \/ _region_size_bytes, \"Collector regions must match\");\n+    assert(_capacity[int(ShenandoahFreeSetPartitionId::Collector)] >= _used[int(ShenandoahFreeSetPartitionId::Collector)],\n+           \"Collector Capacity must be >= used\");\n+    assert(_available[int(ShenandoahFreeSetPartitionId::Collector)] ==\n+           (_capacity[int(ShenandoahFreeSetPartitionId::Collector)] - _used[int(ShenandoahFreeSetPartitionId::Collector)]),\n+           \"Collector Available must equal capacity minus used\");\n+\n+    assert(capacities[int(ShenandoahFreeSetPartitionId::Mutator)] == _capacity[int(ShenandoahFreeSetPartitionId::Mutator)],\n+           \"Mutator capacities must match\");\n+    assert(used[int(ShenandoahFreeSetPartitionId::Mutator)] == _used[int(ShenandoahFreeSetPartitionId::Mutator)],\n+           \"Mutator used must match\");\n+    assert(regions[int(ShenandoahFreeSetPartitionId::Mutator)]\n+           == _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] \/ _region_size_bytes, \"Mutator regions must match\");\n+    assert(_capacity[int(ShenandoahFreeSetPartitionId::Mutator)] >= _used[int(ShenandoahFreeSetPartitionId::Mutator)],\n+           \"Mutator capacity must be >= used\");\n+    assert(_available[int(ShenandoahFreeSetPartitionId::Mutator)] ==\n+           (_capacity[int(ShenandoahFreeSetPartitionId::Mutator)] - _used[int(ShenandoahFreeSetPartitionId::Mutator)]),\n+           \"Mutator available must equal capacity minus used\");\n+    assert(_humongous_waste[int(ShenandoahFreeSetPartitionId::Mutator)] == young_humongous_waste,\n+           \"Mutator humongous waste must match\");\n+  }\n@@ -750,1 +1193,13 @@\n-  _alloc_bias_weight(0)\n+  _total_humongous_waste(0),\n+  _alloc_bias_weight(0),\n+  _total_young_used(0),\n+  _total_old_used(0),\n+  _total_global_used(0),\n+  _young_affiliated_regions(0),\n+  _old_affiliated_regions(0),\n+  _global_affiliated_regions(0),\n+  _young_unaffiliated_regions(0),\n+  _global_unaffiliated_regions(0),\n+  _total_young_regions(0),\n+  _total_global_regions(0),\n+  _mutator_bytes_allocated_since_gc_start(0)\n@@ -755,0 +1210,1 @@\n+\/\/ was pip_pad_bytes\n@@ -758,3 +1214,5 @@\n-  size_t idx = region->index();\n-  size_t capacity = alloc_capacity(region);\n-  assert(_partitions.membership(idx) == ShenandoahFreeSetPartitionId::NotFree,\n+  size_t region_size_bytes =  ShenandoahHeapRegion::region_size_bytes();\n+  size_t available_in_region = alloc_capacity(region);\n+  size_t region_index = region->index();\n+  ShenandoahFreeSetPartitionId p = _partitions.membership(region_index);\n+  assert(_partitions.membership(region_index) == ShenandoahFreeSetPartitionId::NotFree,\n@@ -762,4 +1220,46 @@\n-  if (capacity >= plab_min_size_in_bytes) {\n-    _partitions.make_free(idx, ShenandoahFreeSetPartitionId::OldCollector, capacity);\n-    _heap->old_generation()->augment_promoted_reserve(capacity);\n-  }\n+\n+  \/\/ If region had been retired, its end-of-region alignment pad had been counted as used within the Mutator partition\n+  size_t used_while_awaiting_pip = region_size_bytes;\n+  size_t used_after_pip = region_size_bytes;\n+  if (available_in_region >= plab_min_size_in_bytes) {\n+    used_after_pip -= available_in_region;\n+  } else {\n+    if (available_in_region >= ShenandoahHeap::min_fill_size() * HeapWordSize) {\n+      size_t fill_words = available_in_region \/ HeapWordSize;\n+      ShenandoahHeap::heap()->old_generation()->card_scan()->register_object(region->top());\n+      region->allocate_fill(fill_words);\n+    }\n+    available_in_region = 0;\n+  }\n+\n+  assert(p == ShenandoahFreeSetPartitionId::NotFree, \"pip region must be NotFree\");\n+  assert(region->is_young(), \"pip region must be young\");\n+\n+  \/\/ Though this region may have been promoted in place from the Collector region, its usage is now accounted within\n+  \/\/ the Mutator partition.\n+  _partitions.decrease_used(ShenandoahFreeSetPartitionId::Mutator, used_while_awaiting_pip);\n+\n+  \/\/ decrease capacity adjusts available\n+  _partitions.decrease_capacity(ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n+  _partitions.increase_capacity(ShenandoahFreeSetPartitionId::OldCollector, region_size_bytes);\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::OldCollector, used_after_pip);\n+  region->set_affiliation(ShenandoahAffiliation::OLD_GENERATION);\n+  if (available_in_region > 0) {\n+    assert(available_in_region >= plab_min_size_in_bytes, \"enforced above\");\n+    _partitions.increase_region_counts(ShenandoahFreeSetPartitionId::OldCollector, 1);\n+    \/\/ make_free() adjusts bounds for OldCollector partition\n+    _partitions.make_free(region_index, ShenandoahFreeSetPartitionId::OldCollector, available_in_region);\n+    _heap->old_generation()->augment_promoted_reserve(available_in_region);\n+    assert(available_in_region != region_size_bytes, \"Nothing to promote in place\");\n+  }\n+  \/\/ else, leave this region as NotFree\n+\n+  recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                       \/* UsedByCollectorChanged *\/ false, \/* UsedByOldCollectorChanged *\/ true>();\n+  \/\/ Conservatively, assume that pip regions came from both Mutator and Collector\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ false, \/* CollectorEmptiesChanged *\/ false,\n+                             \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ true,\n+                             \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ true,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+  _partitions.assert_bounds(true);\n@@ -1037,1 +1537,0 @@\n-\n@@ -1049,2 +1548,0 @@\n-    _heap->generation_for(r->affiliation())->increment_affiliated_region_count();\n-\n@@ -1123,0 +1620,1 @@\n+      increase_bytes_allocated(req.actual_size() * HeapWordSize);\n@@ -1131,1 +1629,1 @@\n-        _partitions.increase_used(ShenandoahFreeSetPartitionId::OldCollector, req.actual_size() * HeapWordSize);\n+        _partitions.increase_used(ShenandoahFreeSetPartitionId::OldCollector, (req.actual_size() + req.waste()) * HeapWordSize);\n@@ -1135,1 +1633,1 @@\n-        _partitions.increase_used(ShenandoahFreeSetPartitionId::Collector, req.actual_size() * HeapWordSize);\n+        _partitions.increase_used(ShenandoahFreeSetPartitionId::Collector, (req.actual_size() + req.waste()) * HeapWordSize);\n@@ -1140,1 +1638,0 @@\n-  static const size_t min_capacity = (size_t) (ShenandoahHeapRegion::region_size_bytes() * (1.0 - 1.0 \/ ShenandoahEvacWaste));\n@@ -1142,2 +1639,22 @@\n-\n-  if (((result == nullptr) && (ac < min_capacity)) || (alloc_capacity(r) < PLAB::min_size() * HeapWordSize)) {\n+  ShenandoahFreeSetPartitionId orig_partition;\n+  ShenandoahGeneration* request_generation = nullptr;\n+  if (req.is_mutator_alloc()) {\n+    request_generation = _heap->mode()->is_generational()? _heap->young_generation(): _heap->global_generation();\n+    orig_partition = ShenandoahFreeSetPartitionId::Mutator;\n+  } else if (req.type() == ShenandoahAllocRequest::_alloc_gclab) {\n+    request_generation = _heap->mode()->is_generational()? _heap->young_generation(): _heap->global_generation();\n+    orig_partition = ShenandoahFreeSetPartitionId::Collector;\n+  } else if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+    request_generation = _heap->old_generation();\n+    orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n+  } else {\n+    assert(req.type() == ShenandoahAllocRequest::_alloc_shared_gc, \"Unexpected allocation type\");\n+    if (req.is_old()) {\n+      request_generation = _heap->old_generation();\n+      orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n+    } else {\n+      request_generation = _heap->mode()->is_generational()? _heap->young_generation(): _heap->global_generation();\n+      orig_partition = ShenandoahFreeSetPartitionId::Collector;\n+    }\n+  }\n+  if (alloc_capacity(r) < PLAB::min_size() * HeapWordSize) {\n@@ -1151,14 +1668,6 @@\n-    ShenandoahFreeSetPartitionId orig_partition;\n-    if (req.is_mutator_alloc()) {\n-      orig_partition = ShenandoahFreeSetPartitionId::Mutator;\n-    } else if (req.type() == ShenandoahAllocRequest::_alloc_gclab) {\n-      orig_partition = ShenandoahFreeSetPartitionId::Collector;\n-    } else if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n-      orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n-    } else {\n-      assert(req.type() == ShenandoahAllocRequest::_alloc_shared_gc, \"Unexpected allocation type\");\n-      if (req.is_old()) {\n-        orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n-      } else {\n-        orig_partition = ShenandoahFreeSetPartitionId::Collector;\n-      }\n+    if ((result != nullptr) && in_new_region) {\n+      _partitions.one_region_is_no_longer_empty(orig_partition);\n+    }\n+    size_t waste_bytes = _partitions.retire_from_partition(orig_partition, idx, r->used());\n+    if (req.is_mutator_alloc() && (waste_bytes > 0)) {\n+      increase_bytes_allocated(waste_bytes);\n@@ -1166,2 +1675,41 @@\n-    _partitions.retire_from_partition(orig_partition, idx, r->used());\n-    _partitions.assert_bounds();\n+  } else if ((result != nullptr) && in_new_region) {\n+    _partitions.one_region_is_no_longer_empty(orig_partition);\n+  }\n+\n+  switch (orig_partition) {\n+  case ShenandoahFreeSetPartitionId::Mutator:\n+    recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                         \/* UsedByCollectorChanged *\/ false, \/* UsedByOldCollectorChanged *\/ false>();\n+    if (in_new_region) {\n+      recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ false,\n+                                 \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ false,\n+                                 \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ false,\n+                                 \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ false,\n+                                 \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+    }\n+    break;\n+  case ShenandoahFreeSetPartitionId::Collector:\n+    recompute_total_used<\/* UsedByMutatorChanged *\/ false,\n+                         \/* UsedByCollectorChanged *\/ true, \/* UsedByOldCollectorChanged *\/ false>();\n+    if (in_new_region) {\n+      recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ false, \/* CollectorEmptiesChanged *\/ true,\n+                                 \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ false,\n+                                 \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ false,\n+                                 \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ false,\n+                                 \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+    }\n+    break;\n+  case ShenandoahFreeSetPartitionId::OldCollector:\n+    recompute_total_used<\/* UsedByMutatorChanged *\/ false,\n+                         \/* UsedByCollectorChanged *\/ false, \/* UsedByOldCollectorChanged *\/ true>();\n+    if (in_new_region) {\n+      recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ false, \/* CollectorEmptiesChanged *\/ false,\n+                                 \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ false,\n+                                 \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ false,\n+                                 \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ false,\n+                                 \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+    }\n+    break;\n+  case ShenandoahFreeSetPartitionId::NotFree:\n+  default:\n+    assert(false, \"won't happen\");\n@@ -1169,0 +1717,1 @@\n+  _partitions.assert_bounds(true);\n@@ -1238,12 +1787,14 @@\n-  size_t remainder = words_size & ShenandoahHeapRegion::region_size_words_mask();\n-  \/\/ Initialize regions:\n-  for (idx_t i = beg; i <= end; i++) {\n-    ShenandoahHeapRegion* r = _heap->get_region(i);\n-    r->try_recycle_under_lock();\n-\n-    assert(i == beg || _heap->get_region(i - 1)->index() + 1 == r->index(), \"Should be contiguous\");\n-    assert(r->is_empty(), \"Should be empty\");\n-\n-    r->set_affiliation(req.affiliation());\n-\n-    if (is_humongous) {\n+  size_t total_used = 0;\n+  const size_t used_words_in_last_region = words_size & ShenandoahHeapRegion::region_size_words_mask();\n+  size_t waste_bytes;\n+  \/\/ Retire regions from free partition and initialize them.\n+  if (is_humongous) {\n+    \/\/ Humongous allocation retires all regions at once: no allocation is possible anymore.\n+    \/\/ retire_range_from_partition() will adjust bounds on Mutator free set if appropriate and will recompute affiliated.\n+    _partitions.retire_range_from_partition(ShenandoahFreeSetPartitionId::Mutator, beg, end);\n+    for (idx_t i = beg; i <= end; i++) {\n+      ShenandoahHeapRegion* r = _heap->get_region(i);\n+      assert(i == beg || _heap->get_region(i - 1)->index() + 1 == r->index(), \"Should be contiguous\");\n+      r->try_recycle_under_lock();\n+      assert(r->is_empty(), \"Should be empty\");\n+      r->set_affiliation(req.affiliation());\n@@ -1255,10 +1806,7 @@\n-    } else {\n-      r->make_regular_allocation(req.affiliation());\n-    }\n-\n-    \/\/ Trailing region may be non-full, record the remainder there\n-    size_t used_words;\n-    if ((i == end) && (remainder != 0)) {\n-      used_words = remainder;\n-    } else {\n-      used_words = ShenandoahHeapRegion::region_size_words();\n+      if ((i == end) && (used_words_in_last_region > 0)) {\n+        r->set_top(r->bottom() + used_words_in_last_region);\n+      } else {\n+        \/\/ if used_words_in_last_region is zero, then the end region is fully consumed.\n+        r->set_top(r->end());\n+      }\n+      r->set_update_watermark(r->bottom());\n@@ -1266,9 +1814,0 @@\n-    r->set_update_watermark(r->bottom());\n-    r->set_top(r->bottom() + used_words);\n-  }\n-  generation->increase_affiliated_region_count(num);\n-\n-  size_t total_used = 0;\n-  if (is_humongous) {\n-    \/\/ Humongous allocation retires all regions at once: no allocation is possible anymore.\n-    _partitions.retire_range_from_partition(ShenandoahFreeSetPartitionId::Mutator, beg, end);\n@@ -1276,0 +1815,2 @@\n+    waste_bytes =\n+      (used_words_in_last_region == 0)? 0: ShenandoahHeapRegion::region_size_bytes() - used_words_in_last_region * HeapWordSize;\n@@ -1278,0 +1819,1 @@\n+    waste_bytes = 0;\n@@ -1280,2 +1822,10 @@\n-      if (r->free() < PLAB::min_size() * HeapWordSize) {\n-        _partitions.retire_from_partition(ShenandoahFreeSetPartitionId::Mutator, i, r->used());\n+      assert(i == beg || _heap->get_region(i - 1)->index() + 1 == r->index(), \"Should be contiguous\");\n+      assert(r->is_empty(), \"Should be empty\");\n+      r->try_recycle_under_lock();\n+      r->set_affiliation(req.affiliation());\n+      r->make_regular_allocation(req.affiliation());\n+      if ((i == end) && (used_words_in_last_region > 0)) {\n+        r->set_top(r->bottom() + used_words_in_last_region);\n+      } else {\n+        \/\/ if used_words_in_last_region is zero, then the end region is fully consumed.\n+        r->set_top(r->end());\n@@ -1283,0 +1833,1 @@\n+      r->set_update_watermark(r->bottom());\n@@ -1284,0 +1835,12 @@\n+      if  (r->free() < PLAB::min_size() * HeapWordSize) {\n+        \/\/ retire_from_partition() will adjust bounds on Mutator free set if appropriate and will recompute affiliated.\n+        \/\/ It also increases used for the waste bytes, which includes bytes filled at retirement and bytes too small\n+        \/\/ to be filled.  Only the last iteration may have non-zero waste_bytes.\n+        waste_bytes += _partitions.retire_from_partition(ShenandoahFreeSetPartitionId::Mutator, i, r->used());\n+      }\n+    }\n+    _partitions.decrease_empty_region_counts(ShenandoahFreeSetPartitionId::Mutator, num);\n+    if (waste_bytes > 0) {\n+      \/\/ For humongous allocations, waste_bytes are included in total_used.  Since this is not humongous,\n+      \/\/ we need to account separately for the waste_bytes.\n+      increase_bytes_allocated(waste_bytes);\n@@ -1287,2 +1850,1 @@\n-  _partitions.assert_bounds();\n-\n+  increase_bytes_allocated(total_used);\n@@ -1290,2 +1852,7 @@\n-  if (remainder != 0 && is_humongous) {\n-    req.set_waste(ShenandoahHeapRegion::region_size_words() - remainder);\n+  \/\/ If !is_humongous, the \"waste\" is made availabe for new allocation\n+  if (waste_bytes > 0) {\n+    req.set_waste(waste_bytes \/ HeapWordSize);\n+    if (is_humongous) {\n+      _partitions.increase_humongous_waste(ShenandoahFreeSetPartitionId::Mutator, waste_bytes);\n+      _total_humongous_waste += waste_bytes;\n+    }\n@@ -1293,0 +1860,10 @@\n+\n+  recompute_total_young_used<\/* UsedByMutatorChanged *\/ true, \/*UsedByCollectorChanged *\/ false>();\n+  recompute_total_global_used<\/* UsedByMutatorChanged *\/ true, \/*UsedByCollectorChanged *\/ false,\n+                              \/* UsedByOldCollectorChanged *\/ true>();\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ false,\n+                             \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ false,\n+                             \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ false,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ false,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+  _partitions.assert_bounds(true);\n@@ -1297,0 +1874,91 @@\n+private:\n+  static const ssize_t SentinelUsed = -1;\n+  static const ssize_t SentinelIndex = -1;\n+  static const size_t MaxSavedRegions = 128;\n+\n+  ShenandoahRegionPartitions* _partitions;\n+  volatile size_t _recycled_region_count;\n+  ssize_t _region_indices[MaxSavedRegions];\n+  ssize_t _region_used[MaxSavedRegions];\n+\n+  void get_lock_and_flush_buffer(size_t region_count, size_t overflow_region_used, size_t overflow_region_index) {\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    ShenandoahHeapLocker locker(heap->lock());\n+    size_t recycled_regions = AtomicAccess::load(&_recycled_region_count);\n+    size_t region_tallies[int(ShenandoahRegionPartitions::NumPartitions)];\n+    size_t used_byte_tallies[int(ShenandoahRegionPartitions::NumPartitions)];\n+    for (int p = 0; p < int(ShenandoahRegionPartitions::NumPartitions); p++) {\n+      region_tallies[p] = 0;\n+      used_byte_tallies[p] = 0;\n+    }\n+    ShenandoahFreeSetPartitionId p = _partitions->membership(overflow_region_index);\n+    used_byte_tallies[int(p)] += overflow_region_used;\n+    if (region_count <= recycled_regions) {\n+      \/\/ _recycled_region_count has not been decremented after I incremented it to obtain region_count, so I will\n+      \/\/ try to flush the buffer.\n+\n+      \/\/ Multiple worker threads may attempt to flush this buffer.  The first thread to acquire the lock does the work.\n+      \/\/ _recycled_region_count is only decreased while holding the heap lock.\n+      if (region_count > recycled_regions) {\n+        region_count = recycled_regions;\n+      }\n+      for (size_t i = 0; i < region_count; i++) {\n+        ssize_t used;\n+        \/\/ wait for other threads to finish updating their entries within the region buffer before processing entry\n+        do {\n+          used = _region_used[i];\n+        } while (used == SentinelUsed);\n+        ssize_t index;\n+        do {\n+          index = _region_indices[i];\n+        } while (index == SentinelIndex);\n+\n+        ShenandoahFreeSetPartitionId p = _partitions->membership(index);\n+        assert(p != ShenandoahFreeSetPartitionId::NotFree, \"Trashed regions should be in a free partition\");\n+        used_byte_tallies[int(p)] += used;\n+        region_tallies[int(p)]++;\n+      }\n+      if (region_count > 0) {\n+        for (size_t i = 0; i < MaxSavedRegions; i++) {\n+          _region_indices[i] = SentinelIndex;\n+          _region_used[i] = SentinelUsed;\n+        }\n+      }\n+\n+      \/\/ The almost last thing we do before releasing the lock is to set the _recycled_region_count to 0.  What happens next?\n+      \/\/\n+      \/\/  1. Any worker thread that attempted to buffer a new region while we were flushing the buffer will have seen\n+      \/\/     that _recycled_region_count > MaxSavedRegions. All such worker threads will first wait for the lock, then\n+      \/\/     discover that the _recycled_region_count is zero, then, while holding the lock, they will process the\n+      \/\/     region so it doesn't have to be placed into the buffer.  This handles the large majority of cases.\n+      \/\/\n+      \/\/  2. However, there's a race that can happen, which will result in someewhat different behavior.  Suppose\n+      \/\/     this thread resets _recycled_region_count to 0.  Then some other worker thread increments _recycled_region_count\n+      \/\/     in order to stores its region into the buffer and suppose this happens before all of the other worker threads\n+      \/\/     which are waiting to acquire the heap lock have finished their efforts to flush the buffer.  If this happens,\n+      \/\/     then the workers who are waiting to acquire the heap lock and flush the buffer will find that _recycled_region_count\n+      \/\/     has decreased from the value it held when they last tried to increment its value.  In this case, these worker\n+      \/\/     threads will process their overflow region while holding the lock, but they will not attempt to process regions\n+      \/\/     newly placed into the buffer.  Otherwise, confusion could result.\n+      \/\/\n+      \/\/ Assumption: all worker threads who are attempting to acquire lock and flush buffer will finish their efforts before\n+      \/\/             the buffer once again overflows.\n+      \/\/ How could we avoid depending on this assumption?\n+      \/\/   1. Let MaxSavedRegions be as large as number of regions, or at least as large as the collection set.\n+      \/\/   2. Keep a count of how many times the buffer has been flushed per instantation of the\n+      \/\/      ShenandoahRecycleTrashedRegionClosure object, and only consult\/update this value while holding the heap lock.\n+      \/\/      Need to think about how this helps resolve the race.\n+      _recycled_region_count = 0;\n+    } else {\n+      \/\/ Some other thread has already processed the buffer, resetting _recycled_region_count to zero. Its current value\n+      \/\/ may be greater than zero because other workers may have accumulated entries into the buffer. But it is \"extremely\"\n+      \/\/ unlikely that it will overflow again before all waiting workers have had a chance to clear their state. While I've\n+      \/\/ got the heap lock, I'll go ahead and update the global state for my overflow region. I'll let other heap regions\n+      \/\/ accumulate in the buffer to be processed when the buffer is once again full.\n+      region_count = 0;\n+    }\n+    for (size_t p = 0; p < int(ShenandoahRegionPartitions::NumPartitions); p++) {\n+      _partitions->decrease_used(ShenandoahFreeSetPartitionId(p), used_byte_tallies[p]);\n+    }\n+  }\n+\n@@ -1298,1 +1966,8 @@\n-  ShenandoahRecycleTrashedRegionClosure(): ShenandoahHeapRegionClosure() {}\n+  ShenandoahRecycleTrashedRegionClosure(ShenandoahRegionPartitions* p): ShenandoahHeapRegionClosure() {\n+    _partitions = p;\n+    _recycled_region_count = 0;\n+    for (size_t i = 0; i < MaxSavedRegions; i++) {\n+      _region_indices[i] = SentinelIndex;\n+      _region_used[i] = SentinelUsed;\n+    }\n+  }\n@@ -1316,1 +1991,1 @@\n-  ShenandoahRecycleTrashedRegionClosure closure;\n+  ShenandoahRecycleTrashedRegionClosure closure(&_partitions);\n@@ -1320,0 +1995,25 @@\n+bool ShenandoahFreeSet::transfer_one_region_from_mutator_to_old_collector(size_t idx, size_t alloc_capacity) {\n+  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahYoungGeneration* young_gen = gen_heap->young_generation();\n+  ShenandoahOldGeneration* old_gen = gen_heap->old_generation();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  assert(alloc_capacity == region_size_bytes, \"Region must be empty\");\n+  if (young_unaffiliated_regions() > 0) {\n+    _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                 ShenandoahFreeSetPartitionId::OldCollector, alloc_capacity);\n+    gen_heap->old_generation()->augment_evacuation_reserve(alloc_capacity);\n+    recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                         \/* UsedByCollectorChanged *\/ false, \/* UsedByOldCollectorChanged *\/ true>();\n+    \/\/ Transferred region is unaffilliated, empty\n+    recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ false,\n+                               \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                               \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ true,\n+                               \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                               \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+    _partitions.assert_bounds(true);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -1327,1 +2027,1 @@\n-  const size_t region_capacity = alloc_capacity(r);\n+  const size_t region_alloc_capacity = alloc_capacity(r);\n@@ -1329,6 +2029,1 @@\n-  bool transferred = gen_heap->generation_sizer()->transfer_to_old(1);\n-  if (transferred) {\n-    _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n-                                                 ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n-    _partitions.assert_bounds();\n-    _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n+  if (transfer_one_region_from_mutator_to_old_collector(idx, region_alloc_capacity)) {\n@@ -1364,4 +2059,9 @@\n-                                                   ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n-\n-      _partitions.assert_bounds();\n-\n+                                                   ShenandoahFreeSetPartitionId::OldCollector, region_alloc_capacity);\n+      \/\/ Should have no effect on used, since flipped regions are trashed: zero used *\/\n+      \/\/ Transferred regions are not affiliated, because they are empty (trash)\n+      recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ false,\n+                                 \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                                 \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ true,\n+                                 \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                                 \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+      _partitions.assert_bounds(true);\n@@ -1372,1 +2072,1 @@\n-      _heap->old_generation()->set_evacuation_reserve(reserve - unusable_capacity + region_capacity);\n+      _heap->old_generation()->set_evacuation_reserve(reserve - unusable_capacity + region_alloc_capacity);\n@@ -1390,2 +2090,9 @@\n-  _partitions.assert_bounds();\n-\n+  recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                       \/* UsedByCollectorChanged *\/ false, \/* UsedByOldCollectorChanged *\/ true>();\n+  \/\/ Transfer only affects unaffiliated regions, which stay in young\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ true,\n+                             \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ true,\n+                             \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ false,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+  _partitions.assert_bounds(true);\n@@ -1403,1 +2110,7 @@\n-\n+  recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                       \/* UsedByCollectorChanged *\/ true, \/* UsedByOldCollectorChanged *\/ true>();\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ true,\n+                             \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                             \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ true,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n@@ -1410,1 +2123,1 @@\n-void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_cset_regions, size_t &old_cset_regions,\n+void ShenandoahFreeSet::find_regions_with_alloc_capacity(size_t &young_trashed_regions, size_t &old_trashed_regions,\n@@ -1413,0 +2126,1 @@\n+  \/\/ This resets all state information, removing all regions from all sets.\n@@ -1418,2 +2132,5 @@\n-  old_cset_regions = 0;\n-  young_cset_regions = 0;\n+  old_trashed_regions = 0;\n+  young_trashed_regions = 0;\n+\n+  size_t old_cset_regions = 0;\n+  size_t young_cset_regions = 0;\n@@ -1422,1 +2139,1 @@\n-  size_t max_regions = _partitions.max_regions();\n+  size_t max_regions = _partitions.max();\n@@ -1428,2 +2145,0 @@\n-  size_t mutator_regions = 0;\n-  size_t mutator_used = 0;\n@@ -1435,1 +2150,6 @@\n-  size_t old_collector_regions = 0;\n+\n+  size_t mutator_empty = 0;\n+  size_t old_collector_empty = 0;\n+\n+  \/\/ These two variables represent the total used within each partition, including humongous waste and retired regions\n+  size_t mutator_used = 0;\n@@ -1438,0 +2158,17 @@\n+  \/\/ These two variables represent memory that is wasted within humongous regions due to alignment padding\n+  size_t mutator_humongous_waste = 0;\n+  size_t old_collector_humongous_waste = 0;\n+\n+  \/\/ These two variables track regions that have allocatable memory\n+  size_t mutator_regions = 0;\n+  size_t old_collector_regions = 0;\n+\n+  \/\/ These two variables track regions that are not empty within each partition\n+  size_t affiliated_mutator_regions = 0;\n+  size_t affiliated_old_collector_regions = 0;\n+\n+  \/\/ These two variables represent the total capacity of each partition, including retired regions\n+  size_t total_mutator_regions = 0;\n+  size_t total_old_collector_regions = 0;\n+\n+  bool is_generational = _heap->mode()->is_generational();\n@@ -1442,2 +2179,2 @@\n-      \/\/ Trashed regions represent regions that had been in the collection partition but have not yet been \"cleaned up\".\n-      \/\/ The cset regions are not \"trashed\" until we have finished update refs.\n+      \/\/ Trashed regions represent immediate garbage identified by final mark and regions that had been in the collection\n+      \/\/ partition but have not yet been \"cleaned up\" following update refs.\n@@ -1445,1 +2182,1 @@\n-        old_cset_regions++;\n+        old_trashed_regions++;\n@@ -1448,1 +2185,1 @@\n-        young_cset_regions++;\n+        young_trashed_regions++;\n@@ -1463,1 +2200,1 @@\n-      if (ac > PLAB::min_size() * HeapWordSize) {\n+      if (ac >= PLAB::min_size() * HeapWordSize) {\n@@ -1474,0 +2211,1 @@\n+            mutator_empty++;\n@@ -1480,0 +2218,2 @@\n+          } else {\n+            affiliated_mutator_regions++;\n@@ -1482,0 +2222,1 @@\n+          total_mutator_regions++;\n@@ -1492,8 +2233,2 @@\n-          if (ac == region_size_bytes) {\n-            if (idx < old_collector_leftmost_empty) {\n-              old_collector_leftmost_empty = idx;\n-            }\n-            if (idx > old_collector_rightmost_empty) {\n-              old_collector_rightmost_empty = idx;\n-            }\n-          }\n+          assert(ac != region_size_bytes, \"Empty regions should be in mutator partition\");\n+          affiliated_old_collector_regions++;\n@@ -1501,1 +2236,45 @@\n-          old_collector_used += (region_size_bytes - ac);\n+          total_old_collector_regions++;\n+          old_collector_used += region_size_bytes - ac;\n+        }\n+      } else {\n+        \/\/ This region does not have enough free to be part of the free set.  Count all of its memory as used.\n+        assert(_partitions.membership(idx) == ShenandoahFreeSetPartitionId::NotFree, \"Region should have been retired\");\n+        if (region->is_old()) {\n+          old_collector_used += region_size_bytes;\n+          total_old_collector_regions++;\n+          affiliated_old_collector_regions++;\n+        } else {\n+          mutator_used += region_size_bytes;\n+          total_mutator_regions++;\n+          affiliated_mutator_regions++;\n+        }\n+      }\n+    } else {\n+      \/\/ This region does not allow allocation (it is retired or is humongous or is in cset).\n+      \/\/ Retired and humongous regions generally have no alloc capacity, but cset regions may have large alloc capacity.\n+      if (region->is_cset()) {\n+        if (region->is_old()) {\n+          old_cset_regions++;\n+        } else {\n+          young_cset_regions++;\n+        }\n+      } else {\n+        assert(_partitions.membership(idx) == ShenandoahFreeSetPartitionId::NotFree, \"Region should have been retired\");\n+        size_t ac = alloc_capacity(region);\n+        size_t humongous_waste_bytes = 0;\n+        if (region->is_humongous_start()) {\n+          oop obj = cast_to_oop(region->bottom());\n+          size_t byte_size = obj->size() * HeapWordSize;\n+          size_t region_span = ShenandoahHeapRegion::required_regions(byte_size);\n+          humongous_waste_bytes = region_span * ShenandoahHeapRegion::region_size_bytes() - byte_size;\n+        }\n+        if (region->is_old()) {\n+          old_collector_used += region_size_bytes;\n+          total_old_collector_regions++;\n+          old_collector_humongous_waste += humongous_waste_bytes;\n+          affiliated_old_collector_regions++;\n+        } else {\n+          mutator_used += region_size_bytes;\n+          total_mutator_regions++;\n+          mutator_humongous_waste += humongous_waste_bytes;\n+          affiliated_mutator_regions++;\n@@ -1506,0 +2285,9 @@\n+  \/\/ At the start of evacuation, the cset regions are not counted as part of Mutator or OldCollector partitions.\n+\n+  \/\/ At the end of GC, when we rebuild rebuild freeset (which happens before we have recycled the collection set), we treat\n+  \/\/ all cset regions as part of capacity, as fully available, as unaffiliated.  We place trashed regions into the Mutator\n+  \/\/ partition.\n+\n+  \/\/ No need to update generation sizes here.  These are the sizes already recognized by the generations.  These\n+  \/\/ adjustments allow the freeset tallies to match the generation tallies.\n+\n@@ -1514,1 +2302,0 @@\n-\n@@ -1523,1 +2310,3 @@\n-\n+  log_debug(gc, free)(\"  total_mutator_regions: %zu, total_old_collector_regions: %zu\"\n+                      \", mutator_empty: %zu, old_collector_empty: %zu\",\n+                      total_mutator_regions, total_old_collector_regions, mutator_empty, old_collector_empty);\n@@ -1527,0 +2316,1 @@\n+\n@@ -1528,1 +2318,2 @@\n-                                          mutator_regions, mutator_used);\n+                                          total_mutator_regions + young_cset_regions, mutator_empty, mutator_regions,\n+                                          mutator_used + young_cset_regions * region_size_bytes, mutator_humongous_waste);\n@@ -1531,2 +2322,24 @@\n-  _partitions.establish_old_collector_intervals(old_collector_leftmost, rightmost_idx, old_collector_leftmost_empty,\n-                                                rightmost_empty_idx, old_collector_regions, old_collector_used);\n+  _partitions.establish_old_collector_intervals(old_collector_leftmost, rightmost_idx,\n+                                                old_collector_leftmost_empty, rightmost_empty_idx,\n+                                                total_old_collector_regions + old_cset_regions,\n+                                                old_collector_empty, old_collector_regions,\n+                                                old_collector_used + old_cset_regions * region_size_bytes,\n+                                                old_collector_humongous_waste);\n+  _total_humongous_waste = mutator_humongous_waste + old_collector_humongous_waste;\n+  _total_young_regions = total_mutator_regions + young_cset_regions;\n+  _total_global_regions = _total_young_regions + total_old_collector_regions + old_cset_regions;\n+  recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                       \/* UsedByCollectorChanged *\/ true, \/* UsedByOldCollectorChanged *\/ true>();\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ true,\n+                             \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                             \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ true,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ false,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+  _partitions.assert_bounds(true);\n+#ifdef ASSERT\n+  if (_heap->mode()->is_generational()) {\n+    assert(young_affiliated_regions() == _heap->young_generation()->get_affiliated_region_count(), \"sanity\");\n+  } else {\n+    assert(young_affiliated_regions() == _heap->global_generation()->get_affiliated_region_count(), \"sanity\");\n+  }\n+#endif\n@@ -1541,0 +2354,107 @@\n+void ShenandoahFreeSet::transfer_humongous_regions_from_mutator_to_old_collector(size_t xfer_regions,\n+                                                                                 size_t humongous_waste_bytes) {\n+  shenandoah_assert_heaplocked();\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  _partitions.decrease_humongous_waste(ShenandoahFreeSetPartitionId::Mutator, humongous_waste_bytes);\n+  _partitions.decrease_used(ShenandoahFreeSetPartitionId::Mutator, xfer_regions * region_size_bytes);\n+  _partitions.decrease_capacity(ShenandoahFreeSetPartitionId::Mutator, xfer_regions * region_size_bytes);\n+\n+  _partitions.increase_capacity(ShenandoahFreeSetPartitionId::OldCollector, xfer_regions * region_size_bytes);\n+  _partitions.increase_humongous_waste(ShenandoahFreeSetPartitionId::OldCollector, humongous_waste_bytes);\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::OldCollector, xfer_regions * region_size_bytes);\n+\n+  \/\/ _total_humongous_waste, _total_global_regions are unaffected by transfer\n+  _total_young_regions -= xfer_regions;\n+  recompute_total_young_used<\/* UsedByMutatorChanged *\/ true, \/* UsedByCollectorChanged *\/ false>();\n+  recompute_total_old_used<\/* UsedByOldCollectorChanged *\/ true>();\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ false, \/* CollectorEmptiesChanged *\/ false,\n+                             \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ true,\n+                             \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ true,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+  _partitions.assert_bounds(true);\n+  \/\/ global_used is unaffected by this transfer\n+\n+  \/\/ No need to adjust ranges because humongous regions are not allocatable\n+}\n+\n+void ShenandoahFreeSet::transfer_empty_regions_from_to(ShenandoahFreeSetPartitionId source,\n+                                                       ShenandoahFreeSetPartitionId dest,\n+                                                       size_t num_regions) {\n+  assert(dest != source, \"precondition\");\n+  shenandoah_assert_heaplocked();\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t transferred_regions = 0;\n+  size_t used_transfer = 0;\n+  idx_t source_low_idx = _partitions.max();\n+  idx_t source_high_idx = -1;\n+  idx_t dest_low_idx = _partitions.max();\n+  idx_t dest_high_idx = -1;\n+  ShenandoahLeftRightIterator iterator(&_partitions, source, true);\n+  for (idx_t idx = iterator.current(); transferred_regions < num_regions && iterator.has_next(); idx = iterator.next()) {\n+    \/\/ Note: can_allocate_from() denotes that region is entirely empty\n+    if (can_allocate_from(idx)) {\n+      if (idx < source_low_idx) {\n+        source_low_idx = idx;\n+      }\n+      if (idx > source_high_idx) {\n+        source_high_idx = idx;\n+      }\n+      if (idx < dest_low_idx) {\n+        dest_low_idx = idx;\n+      }\n+      if (idx > dest_high_idx) {\n+        dest_high_idx = idx;\n+      }\n+      used_transfer += _partitions.move_from_partition_to_partition_with_deferred_accounting(idx, source, dest, region_size_bytes);\n+      transferred_regions++;\n+    }\n+  }\n+\n+  \/\/ All transferred regions are empty.\n+  assert(used_transfer == 0, \"empty regions should have no used\");\n+  _partitions.expand_interval_if_range_modifies_either_boundary(dest, dest_low_idx,\n+                                                                dest_high_idx, dest_low_idx, dest_high_idx);\n+  _partitions.shrink_interval_if_range_modifies_either_boundary(source, source_low_idx, source_high_idx,\n+                                                                transferred_regions);\n+\n+  _partitions.decrease_region_counts(source, transferred_regions);\n+  _partitions.decrease_empty_region_counts(source, transferred_regions);\n+  _partitions.decrease_capacity(source, transferred_regions * region_size_bytes);\n+\n+  _partitions.increase_capacity(dest, transferred_regions * region_size_bytes);\n+  _partitions.increase_region_counts(dest, transferred_regions);\n+  _partitions.increase_empty_region_counts(dest, transferred_regions);\n+\n+  \/\/ Since only empty regions are transferred, no need to recompute_total_used()\n+  if (source == ShenandoahFreeSetPartitionId::OldCollector) {\n+    assert((dest == ShenandoahFreeSetPartitionId::Collector) || (dest == ShenandoahFreeSetPartitionId::Mutator), \"sanity\");\n+    _total_young_regions += transferred_regions;\n+    recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ true,\n+                               \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                               \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ true,\n+                               \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                               \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+  } else {\n+    assert((source == ShenandoahFreeSetPartitionId::Collector) || (source == ShenandoahFreeSetPartitionId::Mutator), \"sanity\");\n+    if (dest == ShenandoahFreeSetPartitionId::OldCollector) {\n+      _total_young_regions -= transferred_regions;\n+      recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ true,\n+                                 \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                                 \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ true,\n+                                 \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                                 \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+    } else {\n+      assert((dest == ShenandoahFreeSetPartitionId::Collector) || (dest == ShenandoahFreeSetPartitionId::Mutator), \"sanity\");\n+      \/\/ No adjustments to total_young_regions if transferring within young\n+      recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ true,\n+                                 \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ true,\n+                                 \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ false,\n+                                 \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                                 \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+    }\n+  }\n+  _partitions.assert_bounds(true);\n+}\n+\n@@ -1548,0 +2468,5 @@\n+  size_t used_transfer = 0;\n+  idx_t collector_low_idx = _partitions.max();\n+  idx_t collector_high_idx = -1;\n+  idx_t mutator_low_idx = _partitions.max();\n+  idx_t mutator_high_idx = -1;\n@@ -1552,1 +2477,15 @@\n-      _partitions.move_from_partition_to_partition(idx, which_collector, ShenandoahFreeSetPartitionId::Mutator, region_size_bytes);\n+      if (idx < collector_low_idx) {\n+        collector_low_idx = idx;\n+      }\n+      if (idx > collector_high_idx) {\n+        collector_high_idx = idx;\n+      }\n+      if (idx < mutator_low_idx) {\n+        mutator_low_idx = idx;\n+      }\n+      if (idx > mutator_high_idx) {\n+        mutator_high_idx = idx;\n+      }\n+      used_transfer += _partitions.move_from_partition_to_partition_with_deferred_accounting(idx, which_collector,\n+                                                                                             ShenandoahFreeSetPartitionId::Mutator,\n+                                                                                             region_size_bytes);\n@@ -1557,0 +2496,30 @@\n+  \/\/ All transferred regions are empty.\n+  assert(used_transfer == 0, \"empty regions should have no used\");\n+  _partitions.expand_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId::Mutator, mutator_low_idx,\n+                                                                mutator_high_idx, mutator_low_idx, mutator_high_idx);\n+  _partitions.shrink_interval_if_range_modifies_either_boundary(which_collector, collector_low_idx, collector_high_idx,\n+                                                                transferred_regions);\n+\n+  _partitions.decrease_region_counts(which_collector, transferred_regions);\n+  _partitions.decrease_empty_region_counts(which_collector, transferred_regions);\n+  _partitions.decrease_capacity(which_collector, transferred_regions * region_size_bytes);\n+\n+  _partitions.increase_capacity(ShenandoahFreeSetPartitionId::Mutator, transferred_regions * region_size_bytes);\n+  _partitions.increase_region_counts(ShenandoahFreeSetPartitionId::Mutator, transferred_regions);\n+  _partitions.increase_empty_region_counts(ShenandoahFreeSetPartitionId::Mutator, transferred_regions);\n+\n+  if (which_collector == ShenandoahFreeSetPartitionId::OldCollector) {\n+    _total_young_regions += transferred_regions;\n+    recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ false,\n+                               \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                               \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ true,\n+                               \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                               \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+  } else {\n+    recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ true,\n+                               \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ true,\n+                               \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ false,\n+                               \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                               \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+  }\n+  _partitions.assert_bounds(true);\n@@ -1561,3 +2530,3 @@\n-size_t ShenandoahFreeSet::transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n-                                                                                       size_t max_xfer_regions,\n-                                                                                       size_t& bytes_transferred) {\n+size_t ShenandoahFreeSet::\n+transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n+                                                             size_t max_xfer_regions, size_t& bytes_transferred) {\n@@ -1565,0 +2534,1 @@\n+  size_t region_size_bytes = _partitions.region_size_bytes();\n@@ -1566,0 +2536,6 @@\n+  size_t used_transfer = 0;\n+  idx_t collector_low_idx = _partitions.max();\n+  idx_t collector_high_idx = -1;\n+  idx_t mutator_low_idx = _partitions.max();\n+  idx_t mutator_high_idx = -1;\n+\n@@ -1570,1 +2546,16 @@\n-      _partitions.move_from_partition_to_partition(idx, which_collector, ShenandoahFreeSetPartitionId::Mutator, ac);\n+      if (idx < collector_low_idx) {\n+        collector_low_idx = idx;\n+      }\n+      if (idx > collector_high_idx) {\n+        collector_high_idx = idx;\n+      }\n+      if (idx < mutator_low_idx) {\n+        mutator_low_idx = idx;\n+      }\n+      if (idx > mutator_high_idx) {\n+        mutator_high_idx = idx;\n+      }\n+      assert (ac < region_size_bytes, \"Move empty regions with different function\");\n+      used_transfer += _partitions.move_from_partition_to_partition_with_deferred_accounting(idx, which_collector,\n+                                                                                             ShenandoahFreeSetPartitionId::Mutator,\n+                                                                                             ac);\n@@ -1575,0 +2566,35 @@\n+  \/\/ _empty_region_counts is unaffected, because we transfer only non-empty regions here.\n+\n+  _partitions.decrease_used(which_collector, used_transfer);\n+  _partitions.expand_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId::Mutator,\n+                                                                mutator_low_idx, mutator_high_idx, _partitions.max(), -1);\n+  _partitions.shrink_interval_if_range_modifies_either_boundary(which_collector, collector_low_idx, collector_high_idx,\n+                                                                transferred_regions);\n+\n+  _partitions.decrease_region_counts(which_collector, transferred_regions);\n+  _partitions.decrease_capacity(which_collector, transferred_regions * region_size_bytes);\n+  _partitions.increase_capacity(ShenandoahFreeSetPartitionId::Mutator, transferred_regions * region_size_bytes);\n+  _partitions.increase_region_counts(ShenandoahFreeSetPartitionId::Mutator, transferred_regions);\n+  _partitions.increase_used(ShenandoahFreeSetPartitionId::Mutator, used_transfer);\n+\n+  if (which_collector == ShenandoahFreeSetPartitionId::OldCollector) {\n+    _total_young_regions += transferred_regions;\n+  }\n+  \/\/ _total_global_regions unaffected by transfer\n+  recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                       \/* UsedByCollectorChanged *\/ true, \/* UsedByOldCollectorChanged *\/ true>();\n+  \/\/ All transfers are affiliated\n+  if (which_collector == ShenandoahFreeSetPartitionId::OldCollector) {\n+    recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollectorEmptiesChanged *\/ false,\n+                               \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                               \/* CollectorSizeChanged *\/ false, \/* OldCollectorSizeChanged *\/ true,\n+                               \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                               \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+  } else {\n+    recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollecteorEmptiesChanged *\/true,\n+                               \/* OldCollectorEmptiesChanged *\/ false, \/* MutatorSizeChanged *\/ true,\n+                               \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ false,\n+                               \/* AffiliatedChangesAreYoungNeutral *\/ true, \/* AffiliatedChangesAreGlobalNeutral *\/ true,\n+                               \/* UnaffiliatedChangesAreYoungNeutral *\/ true>();\n+  }\n+  _partitions.assert_bounds(true);\n@@ -1601,3 +2627,0 @@\n-    if (old_collector_regions > 0) {\n-      ShenandoahGenerationalHeap::cast(_heap)->generation_sizer()->transfer_to_young(old_collector_regions);\n-    }\n@@ -1623,1 +2646,0 @@\n-\n@@ -1625,1 +2647,1 @@\n-void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_cset_regions, size_t &old_cset_regions,\n+void ShenandoahFreeSet::prepare_to_rebuild(size_t &young_trashed_regions, size_t &old_trashed_regions,\n@@ -1628,2 +2650,0 @@\n-  \/\/ This resets all state information, removing all regions from all sets.\n-  clear();\n@@ -1634,29 +2654,2 @@\n-  find_regions_with_alloc_capacity(young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count);\n-}\n-\n-void ShenandoahFreeSet::establish_generation_sizes(size_t young_region_count, size_t old_region_count) {\n-  assert(young_region_count + old_region_count == ShenandoahHeap::heap()->num_regions(), \"Sanity\");\n-  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n-    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-    ShenandoahOldGeneration* old_gen = heap->old_generation();\n-    ShenandoahYoungGeneration* young_gen = heap->young_generation();\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-\n-    size_t original_old_capacity = old_gen->max_capacity();\n-    size_t new_old_capacity = old_region_count * region_size_bytes;\n-    size_t new_young_capacity = young_region_count * region_size_bytes;\n-    old_gen->set_capacity(new_old_capacity);\n-    young_gen->set_capacity(new_young_capacity);\n-\n-    if (new_old_capacity > original_old_capacity) {\n-      size_t region_count = (new_old_capacity - original_old_capacity) \/ region_size_bytes;\n-      log_info(gc, ergo)(\"Transfer %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                         region_count, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_old_capacity));\n-    } else if (new_old_capacity < original_old_capacity) {\n-      size_t region_count = (original_old_capacity - new_old_capacity) \/ region_size_bytes;\n-      log_info(gc, ergo)(\"Transfer %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                         region_count, old_gen->name(), young_gen->name(), PROPERFMTARGS(new_young_capacity));\n-    }\n-    \/\/ This balances generations, so clear any pending request to balance.\n-    old_gen->set_region_balance(0);\n-  }\n+  find_regions_with_alloc_capacity(young_trashed_regions, old_trashed_regions,\n+                                   first_old_region, last_old_region, old_region_count);\n@@ -1665,1 +2658,1 @@\n-void ShenandoahFreeSet::finish_rebuild(size_t young_cset_regions, size_t old_cset_regions, size_t old_region_count,\n+void ShenandoahFreeSet::finish_rebuild(size_t young_trashed_regions, size_t old_trashed_regions, size_t old_region_count,\n@@ -1671,1 +2664,1 @@\n-    compute_young_and_old_reserves(young_cset_regions, old_cset_regions, have_evacuation_reserves,\n+    compute_young_and_old_reserves(young_trashed_regions, old_trashed_regions, have_evacuation_reserves,\n@@ -1678,1 +2671,1 @@\n-  \/\/ Move some of the mutator regions in the Collector and OldCollector partitions in order to satisfy\n+  \/\/ Move some of the mutator regions into the Collector and OldCollector partitions in order to satisfy\n@@ -1680,3 +2673,5 @@\n-  reserve_regions(young_reserve, old_reserve, old_region_count);\n-  size_t young_region_count = _heap->num_regions() - old_region_count;\n-  establish_generation_sizes(young_region_count, old_region_count);\n+  size_t young_used_regions, old_used_regions, young_used_bytes, old_used_bytes;\n+  reserve_regions(young_reserve, old_reserve, old_region_count, young_used_regions, old_used_regions,\n+                  young_used_bytes, old_used_bytes);\n+  _total_young_regions = _heap->num_regions() - old_region_count;\n+  _total_global_regions = _heap->num_regions();\n@@ -1684,1 +2679,1 @@\n-  _partitions.assert_bounds();\n+  _partitions.assert_bounds(true);\n@@ -1688,1 +2683,14 @@\n-void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions,\n+\/**\n+ * Set young_reserve_result and old_reserve_result to the number of bytes that we desire to set aside to hold the\n+ * results of evacuation to young and old collector spaces respectively during the next evacuation phase.  Overwrite\n+ * old_generation region balance in case the original value is incompatible with the current reality.\n+ *\n+ * These values are determined by how much memory is currently available within each generation, which is\n+ * represented by:\n+ *  1. Memory currently available within old and young\n+ *  2. Trashed regions currently residing in young and old, which will become available momentarily\n+ *  3. The value of old_generation->get_region_balance() which represents the number of regions that we plan\n+ *     to transfer from old generation to young generation.  Prior to each invocation of compute_young_and_old_reserves(),\n+ *     this value should computed by ShenandoahGenerationalHeap::compute_old_generation_balance().\n+ *\/\n+void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_trashed_regions, size_t old_trashed_regions,\n@@ -1692,0 +2700,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -1693,1 +2702,0 @@\n-\n@@ -1702,2 +2710,3 @@\n-  old_unaffiliated_regions += old_cset_regions;\n-  young_unaffiliated_regions += young_cset_regions;\n+  old_unaffiliated_regions += old_trashed_regions;\n+  old_available += old_trashed_regions * region_size_bytes;\n+  young_unaffiliated_regions += young_trashed_regions;\n@@ -1706,2 +2715,3 @@\n-  \/\/ The generation region transfers take place after we rebuild.\n-  const ssize_t old_region_balance = old_generation->get_region_balance();\n+  \/\/ The generation region transfers take place after we rebuild.  old_region_balance represents number of regions\n+  \/\/ to transfer from old to young.\n+  ssize_t old_region_balance = old_generation->get_region_balance();\n@@ -1711,1 +2721,3 @@\n-      assert(old_region_balance <= checked_cast<ssize_t>(old_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+      assert(old_region_balance <= checked_cast<ssize_t>(old_unaffiliated_regions),\n+             \"Cannot transfer %zd regions that are affiliated (old_trashed: %zu, old_unaffiliated: %zu)\",\n+             old_region_balance, old_trashed_regions, old_unaffiliated_regions);\n@@ -1713,1 +2725,2 @@\n-      assert(0 - old_region_balance <= checked_cast<ssize_t>(young_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+      assert(0 - old_region_balance <= checked_cast<ssize_t>(young_unaffiliated_regions),\n+             \"Cannot transfer regions that are affiliated\");\n@@ -1734,3 +2747,12 @@\n-    assert(old_reserve_result <= old_available,\n-           \"Cannot reserve (%zu + %zu) more OLD than is available: %zu\",\n-           promoted_reserve, old_evac_reserve, old_available);\n+    if (old_reserve_result > old_available) {\n+      \/\/ Try to transfer memory from young to old.\n+      size_t old_deficit = old_reserve_result - old_available;\n+      size_t old_region_deficit = (old_deficit + region_size_bytes - 1) \/ region_size_bytes;\n+      if (young_unaffiliated_regions < old_region_deficit) {\n+        old_region_deficit = young_unaffiliated_regions;\n+      }\n+      young_unaffiliated_regions -= old_region_deficit;\n+      old_unaffiliated_regions += old_region_deficit;\n+      old_region_balance -= old_region_deficit;\n+      old_generation->set_region_balance(old_region_balance);\n+    }\n@@ -1766,7 +2788,4 @@\n-void ShenandoahFreeSet::reserve_regions(size_t to_reserve, size_t to_reserve_old, size_t &old_region_count) {\n-  for (size_t i = _heap->num_regions(); i > 0; i--) {\n-    size_t idx = i - 1;\n-    ShenandoahHeapRegion* r = _heap->get_region(idx);\n-    if (!_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n-      continue;\n-    }\n+void ShenandoahFreeSet::reserve_regions(size_t to_reserve, size_t to_reserve_old, size_t &old_region_count,\n+                                        size_t &young_used_regions, size_t &old_used_regions,\n+                                        size_t &young_used_bytes, size_t &old_used_bytes) {\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -1774,3 +2793,4 @@\n-    size_t ac = alloc_capacity(r);\n-    assert (ac > 0, \"Membership in free set implies has capacity\");\n-    assert (!r->is_old() || r->is_trash(), \"Except for trash, mutator_is_free regions should not be affiliated OLD\");\n+  young_used_regions = 0;\n+  old_used_regions = 0;\n+  young_used_bytes = 0;\n+  old_used_bytes = 0;\n@@ -1778,2 +2798,4 @@\n-    bool move_to_old_collector = _partitions.available_in(ShenandoahFreeSetPartitionId::OldCollector) < to_reserve_old;\n-    bool move_to_collector = _partitions.available_in(ShenandoahFreeSetPartitionId::Collector) < to_reserve;\n+  idx_t mutator_low_idx = _partitions.max();\n+  idx_t mutator_high_idx = -1;\n+  idx_t mutator_empty_low_idx = _partitions.max();\n+  idx_t mutator_empty_high_idx = -1;\n@@ -1781,4 +2803,16 @@\n-    if (!move_to_collector && !move_to_old_collector) {\n-      \/\/ We've satisfied both to_reserve and to_reserved_old\n-      break;\n-    }\n+  idx_t collector_low_idx = _partitions.max();\n+  idx_t collector_high_idx = -1;\n+  idx_t collector_empty_low_idx = _partitions.max();\n+  idx_t collector_empty_high_idx = -1;\n+\n+  idx_t old_collector_low_idx = _partitions.max();\n+  idx_t old_collector_high_idx = -1;\n+  idx_t old_collector_empty_low_idx = _partitions.max();\n+  idx_t old_collector_empty_high_idx = -1;\n+\n+  size_t used_to_collector = 0;\n+  size_t used_to_old_collector = 0;\n+  size_t regions_to_collector = 0;\n+  size_t regions_to_old_collector = 0;\n+  size_t empty_regions_to_collector = 0;\n+  size_t empty_regions_to_old_collector = 0;\n@@ -1786,9 +2820,88 @@\n-    if (move_to_old_collector) {\n-      \/\/ We give priority to OldCollector partition because we desire to pack OldCollector regions into higher\n-      \/\/ addresses than Collector regions.  Presumably, OldCollector regions are more \"stable\" and less likely to\n-      \/\/ be collected in the near future.\n-      if (r->is_trash() || !r->is_affiliated()) {\n-        \/\/ OLD regions that have available memory are already in the old_collector free set.\n-        _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n-                                                     ShenandoahFreeSetPartitionId::OldCollector, ac);\n-        log_trace(gc, free)(\"  Shifting region %zu from mutator_free to old_collector_free\", idx);\n+  size_t old_collector_available = _partitions.available_in(ShenandoahFreeSetPartitionId::OldCollector);;\n+  size_t collector_available = _partitions.available_in(ShenandoahFreeSetPartitionId::Collector);\n+\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    idx_t idx = i - 1;\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+    if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx)) {\n+      \/\/ Note: trashed regions have region_size_bytes alloc capacity.\n+      size_t ac = alloc_capacity(r);\n+      assert (ac > 0, \"Membership in free set implies has capacity\");\n+      assert (!r->is_old() || r->is_trash(), \"Except for trash, mutator_is_free regions should not be affiliated OLD\");\n+\n+      bool move_to_old_collector = old_collector_available < to_reserve_old;\n+      bool move_to_collector = collector_available < to_reserve;\n+\n+      if (move_to_old_collector) {\n+        \/\/ We give priority to OldCollector partition because we desire to pack OldCollector regions into higher\n+        \/\/ addresses than Collector regions.  Presumably, OldCollector regions are more \"stable\" and less likely to\n+        \/\/ be collected in the near future.\n+        if (r->is_trash() || !r->is_affiliated()) {\n+          \/\/ OLD regions that have available memory are already in the old_collector free set.\n+          assert(r->is_empty() || r->is_trash(), \"Not affiliated implies region %zu is empty\", r->index());\n+          if (idx < old_collector_low_idx) {\n+            old_collector_low_idx = idx;\n+          }\n+          if (idx > old_collector_high_idx) {\n+            old_collector_high_idx = idx;\n+          }\n+          if (idx < old_collector_empty_low_idx) {\n+            old_collector_empty_low_idx = idx;\n+          }\n+          if (idx > old_collector_empty_high_idx) {\n+            old_collector_empty_high_idx = idx;\n+          }\n+          used_to_old_collector +=\n+            _partitions.move_from_partition_to_partition_with_deferred_accounting(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                                                  ShenandoahFreeSetPartitionId::OldCollector, ac);\n+          old_collector_available += ac;\n+          regions_to_old_collector++;\n+          empty_regions_to_old_collector++;\n+\n+          log_trace(gc, free)(\"  Shifting region %zu from mutator_free to old_collector_free\", idx);\n+          log_trace(gc, free)(\"  Shifted Mutator range [%zd, %zd],\"\n+                              \"  Old Collector range [%zd, %zd]\",\n+                              _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n+                              _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n+                              _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n+                              _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n+          old_region_count++;\n+          continue;\n+        }\n+      }\n+\n+      if (move_to_collector) {\n+        \/\/ Note: In a previous implementation, regions were only placed into the survivor space (collector_is_free) if\n+        \/\/ they were entirely empty.  This has the effect of causing new Mutator allocation to reside next to objects\n+        \/\/ that have already survived at least one GC, mixing ephemeral with longer-lived objects in the same region.\n+        \/\/ Any objects that have survived a GC are less likely to immediately become garbage, so a region that contains\n+        \/\/ survivor objects is less likely to be selected for the collection set.  This alternative implementation allows\n+        \/\/ survivor regions to continue accumulating other survivor objects, and makes it more likely that ephemeral objects\n+        \/\/ occupy regions comprised entirely of ephemeral objects.  These regions are highly likely to be included in the next\n+        \/\/ collection set, and they are easily evacuated because they have low density of live objects.\n+        if (idx < collector_low_idx) {\n+          collector_low_idx = idx;\n+        }\n+        if (idx > collector_high_idx) {\n+          collector_high_idx = idx;\n+        }\n+        if (ac == region_size_bytes) {\n+          if (idx < collector_empty_low_idx) {\n+            collector_empty_low_idx = idx;\n+          }\n+          if (idx > collector_empty_high_idx) {\n+            collector_empty_high_idx = idx;\n+          }\n+          empty_regions_to_collector++;\n+        }\n+        used_to_collector +=\n+          _partitions.move_from_partition_to_partition_with_deferred_accounting(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                                                ShenandoahFreeSetPartitionId::Collector, ac);\n+        collector_available += ac;\n+        regions_to_collector++;\n+        if (ac != region_size_bytes) {\n+          young_used_regions++;\n+          young_used_bytes = region_size_bytes - ac;\n+        }\n+\n+        log_trace(gc, free)(\"  Shifting region %zu from mutator_free to collector_free\", idx);\n@@ -1796,1 +2909,1 @@\n-                            \"  Old Collector range [%zd, %zd]\",\n+                            \"  Collector range [%zd, %zd]\",\n@@ -1799,4 +2912,2 @@\n-                            _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector),\n-                            _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector));\n-\n-        old_region_count++;\n+                            _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector),\n+                            _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -1805,20 +2916,0 @@\n-    }\n-\n-    if (move_to_collector) {\n-      \/\/ Note: In a previous implementation, regions were only placed into the survivor space (collector_is_free) if\n-      \/\/ they were entirely empty.  This has the effect of causing new Mutator allocation to reside next to objects\n-      \/\/ that have already survived at least one GC, mixing ephemeral with longer-lived objects in the same region.\n-      \/\/ Any objects that have survived a GC are less likely to immediately become garbage, so a region that contains\n-      \/\/ survivor objects is less likely to be selected for the collection set.  This alternative implementation allows\n-      \/\/ survivor regions to continue accumulating other survivor objects, and makes it more likely that ephemeral objects\n-      \/\/ occupy regions comprised entirely of ephemeral objects.  These regions are highly likely to be included in the next\n-      \/\/ collection set, and they are easily evacuated because they have low density of live objects.\n-      _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n-                                                   ShenandoahFreeSetPartitionId::Collector, ac);\n-      log_trace(gc, free)(\"  Shifting region %zu from mutator_free to collector_free\", idx);\n-      log_trace(gc, free)(\"  Shifted Mutator range [%zd, %zd],\"\n-                          \"  Collector range [%zd, %zd]\",\n-                          _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator),\n-                          _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator),\n-                          _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector),\n-                          _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector));\n@@ -1826,0 +2917,60 @@\n+      \/\/ Mutator region is not moved to Collector or OldCollector. Still, do the accounting.\n+      if (idx < mutator_low_idx) {\n+        mutator_low_idx = idx;\n+      }\n+      if (idx > mutator_high_idx) {\n+        mutator_high_idx = idx;\n+      }\n+      if ((ac == region_size_bytes) && (idx < mutator_empty_low_idx)) {\n+        mutator_empty_low_idx = idx;\n+      }\n+      if ((ac == region_size_bytes) && (idx > mutator_empty_high_idx)) {\n+        mutator_empty_high_idx = idx;\n+      }\n+      if (ac != region_size_bytes) {\n+        young_used_regions++;\n+        young_used_bytes += region_size_bytes - ac;\n+      }\n+    } else {\n+      \/\/ Region is not in Mutator partition. Do the accounting.\n+      ShenandoahFreeSetPartitionId p = _partitions.membership(idx);\n+      size_t ac = alloc_capacity(r);\n+      assert(ac != region_size_bytes, \"Empty regions should be in Mutator partion at entry to reserve_regions\");\n+      if (p == ShenandoahFreeSetPartitionId::Collector) {\n+        if (ac != region_size_bytes) {\n+          young_used_regions++;\n+          young_used_bytes = region_size_bytes - ac;\n+        }\n+        \/\/ else, unaffiliated region has no used\n+      } else if (p == ShenandoahFreeSetPartitionId::OldCollector) {\n+        if (ac != region_size_bytes) {\n+          old_used_regions++;\n+          old_used_bytes = region_size_bytes - ac;\n+        }\n+        \/\/ else, unaffiliated region has no used\n+      } else if (p == ShenandoahFreeSetPartitionId::NotFree) {\n+        \/\/ This region has been retired\n+        if (r->is_old()) {\n+          old_used_regions++;\n+          old_used_bytes += region_size_bytes - ac;\n+        } else {\n+          assert(r->is_young(), \"Retired region should be old or young\");\n+          young_used_regions++;\n+          young_used_bytes += region_size_bytes - ac;\n+        }\n+      } else {\n+        assert(p == ShenandoahFreeSetPartitionId::OldCollector, \"Not mutator and not NotFree, so must be OldCollector\");\n+        assert(!r->is_empty(), \"Empty regions should be in Mutator partition at entry to reserve_regions\");\n+        if (idx < old_collector_low_idx) {\n+          old_collector_low_idx = idx;\n+        }\n+        if (idx > old_collector_high_idx) {\n+          old_collector_high_idx = idx;\n+        }\n+        if (idx < old_collector_empty_low_idx) {\n+          old_collector_empty_low_idx = idx;\n+        }\n+        if (idx > old_collector_empty_high_idx) {\n+          old_collector_empty_high_idx = idx;\n+        }\n+      }\n@@ -1829,0 +2980,41 @@\n+  _partitions.decrease_used(ShenandoahFreeSetPartitionId::Mutator, used_to_old_collector + used_to_collector);\n+  _partitions.decrease_region_counts(ShenandoahFreeSetPartitionId::Mutator, regions_to_old_collector + regions_to_collector);\n+  _partitions.decrease_empty_region_counts(ShenandoahFreeSetPartitionId::Mutator,\n+                                           empty_regions_to_old_collector + empty_regions_to_collector);\n+  \/\/ decrease_capacity() also decreases available\n+  _partitions.decrease_capacity(ShenandoahFreeSetPartitionId::Mutator,\n+                                (regions_to_old_collector + regions_to_collector) * region_size_bytes);\n+  \/\/ increase_capacity() also increases available\n+  _partitions.increase_capacity(ShenandoahFreeSetPartitionId::Collector, regions_to_collector * region_size_bytes);\n+  _partitions.increase_region_counts(ShenandoahFreeSetPartitionId::Collector, regions_to_collector);\n+  _partitions.increase_empty_region_counts(ShenandoahFreeSetPartitionId::Collector, empty_regions_to_collector);\n+  \/\/ increase_capacity() also increases available\n+  _partitions.increase_capacity(ShenandoahFreeSetPartitionId::OldCollector, regions_to_old_collector * region_size_bytes);\n+  _partitions.increase_region_counts(ShenandoahFreeSetPartitionId::OldCollector, regions_to_old_collector);\n+  _partitions.increase_empty_region_counts(ShenandoahFreeSetPartitionId::OldCollector, empty_regions_to_old_collector);\n+\n+  if (used_to_collector > 0) {\n+    _partitions.increase_used(ShenandoahFreeSetPartitionId::Collector, used_to_collector);\n+  }\n+\n+  if (used_to_old_collector > 0) {\n+    _partitions.increase_used(ShenandoahFreeSetPartitionId::OldCollector, used_to_old_collector);\n+  }\n+\n+  _partitions.expand_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId::Collector,\n+                                                                collector_low_idx, collector_high_idx,\n+                                                                collector_empty_low_idx, collector_empty_high_idx);\n+  _partitions.expand_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId::OldCollector,\n+                                                                old_collector_low_idx, old_collector_high_idx,\n+                                                                old_collector_empty_low_idx, old_collector_empty_high_idx);\n+  _partitions.establish_interval(ShenandoahFreeSetPartitionId::Mutator,\n+                                 mutator_low_idx, mutator_high_idx, mutator_empty_low_idx, mutator_empty_high_idx);\n+\n+  recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                       \/* UsedByCollectorChanged *\/ true, \/* UsedByOldCollectorChanged *\/ true>();\n+  recompute_total_affiliated<\/* MutatorEmptiesChanged *\/ true, \/* CollecteorEmptiesChanged *\/true,\n+                             \/* OldCollectorEmptiesChanged *\/ true, \/* MutatorSizeChanged *\/ true,\n+                             \/* CollectorSizeChanged *\/ true, \/* OldCollectorSizeChanged *\/ true,\n+                             \/* AffiliatedChangesAreYoungNeutral *\/ false, \/* AffiliatedChangesAreGlobalNeutral *\/ false,\n+                             \/* UnaffiliatedChangesAreYoungNeutral *\/ false>();\n+  _partitions.assert_bounds(true);\n@@ -1969,0 +3161,1 @@\n+      size_t total_trashed_free = 0;\n@@ -1976,1 +3169,3 @@\n-          if (r->is_empty()) {\n+          size_t used_in_region = r->used();\n+          if (r->is_empty() || r->is_trash()) {\n+            used_in_region = 0;\n@@ -1986,1 +3181,1 @@\n-          total_used += r->used();\n+          total_used += used_in_region;\n@@ -1994,0 +3189,2 @@\n+      \/\/ capacity() is capacity of mutator\n+      \/\/ used() is used of mutator\n@@ -1995,1 +3192,0 @@\n-\n@@ -1999,1 +3195,1 @@\n-      assert(free == total_free, \"Free memory should match\");\n+      assert(free == total_free, \"Free memory (%zu) should match calculated memory (%zu)\", free, total_free);\n@@ -2072,0 +3268,21 @@\n+void ShenandoahFreeSet::decrease_humongous_waste_for_regular_bypass(ShenandoahHeapRegion*r, size_t waste) {\n+  shenandoah_assert_heaplocked();\n+  assert(_partitions.membership(r->index()) == ShenandoahFreeSetPartitionId::NotFree, \"Humongous regions should be NotFree\");\n+  ShenandoahFreeSetPartitionId p =\n+    r->is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Mutator;\n+  _partitions.decrease_humongous_waste(p, waste);\n+  if (waste >= PLAB::min_size() * HeapWordSize) {\n+    _partitions.decrease_used(p, waste);\n+    _partitions.unretire_to_partition(r, p);\n+    if (r->is_old()) {\n+      recompute_total_used<\/* UsedByMutatorChanged *\/ false,\n+                           \/* UsedByCollectorChanged *\/ false, \/* UsedByOldCollectorChanged *\/ true>();\n+    } else {\n+      recompute_total_used<\/* UsedByMutatorChanged *\/ true,\n+                           \/* UsedByCollectorChanged *\/ false, \/* UsedByOldCollectorChanged *\/ false>();\n+    }\n+  }\n+  _total_humongous_waste -= waste;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1515,"deletions":298,"binary":false,"changes":1813,"status":"modified"},{"patch":"@@ -38,2 +38,6 @@\n-                                \/\/    available memory is reserved for old evacuations and for promotions..\n-  NotFree                       \/\/ Region is in no free set: it has no available memory\n+                                \/\/    available memory is reserved for old evacuations and for promotions.\n+  NotFree                       \/\/ Region is in no free set: it has no available memory.  Consult region affiliation\n+                                \/\/    to determine whether this retired region is young or old.  If young, the region\n+                                \/\/    is considered to be part of the Mutator partition.  (When we retire from the\n+                                \/\/    Collector partition, we decrease total_region_count for Collector and increaese\n+                                \/\/    for Mutator, making similar adjustments to used (net impact on available is neutral).\n@@ -48,1 +52,3 @@\n-private:\n+using idx_t = ShenandoahSimpleBitMap::idx_t;\n+\n+public:\n@@ -55,1 +61,2 @@\n-  const ssize_t _max;           \/\/ The maximum number of heap regions\n+private:\n+  const idx_t _max;           \/\/ The maximum number of heap regions\n@@ -60,1 +67,0 @@\n-\n@@ -65,2 +71,2 @@\n-  ssize_t _leftmosts[UIntNumPartitions];\n-  ssize_t _rightmosts[UIntNumPartitions];\n+  idx_t _leftmosts[UIntNumPartitions];\n+  idx_t _rightmosts[UIntNumPartitions];\n@@ -72,9 +78,26 @@\n-  ssize_t _leftmosts_empty[UIntNumPartitions];\n-  ssize_t _rightmosts_empty[UIntNumPartitions];\n-\n-  \/\/ For each partition p, _capacity[p] represents the total amount of memory within the partition at the time\n-  \/\/ of the most recent rebuild, _used[p] represents the total amount of memory that has been allocated within this\n-  \/\/ partition (either already allocated as of the rebuild, or allocated since the rebuild).  _capacity[p] and _used[p]\n-  \/\/ are denoted in bytes.  Note that some regions that had been assigned to a particular partition at rebuild time\n-  \/\/ may have been retired following the rebuild.  The tallies for these regions are still reflected in _capacity[p]\n-  \/\/ and _used[p], even though the region may have been removed from the free set.\n+  idx_t _leftmosts_empty[UIntNumPartitions];\n+  idx_t _rightmosts_empty[UIntNumPartitions];\n+\n+  \/\/ For each partition p:\n+  \/\/  _capacity[p] represents the total amount of memory within the partition, including retired regions, as adjusted\n+  \/\/                       by transfers of memory between partitions\n+  \/\/  _used[p] represents the total amount of memory that has been allocated within this partition (either already\n+  \/\/                       allocated as of the rebuild, or allocated since the rebuild).\n+  \/\/  _available[p] represents the total amount of memory that can be allocated within partition p, calculated from\n+  \/\/                       _capacity[p] minus _used[p], where the difference is computed and assigned under heap lock\n+  \/\/\n+  \/\/  _region_counts[p] represents the number of regions associated with the partition which currently have available memory.\n+  \/\/                       When a region is retired from partition p, _region_counts[p] is decremented.\n+  \/\/  total_region_counts[p] is _capacity[p] \/ RegionSizeBytes.\n+  \/\/  _empty_region_counts[p] is number of regions associated with p which are entirely empty\n+  \/\/\n+  \/\/ capacity and used values are expressed in bytes.\n+  \/\/\n+  \/\/ When a region is retired, the used[p] is increased to account for alignment waste.  capacity is unaffected.\n+  \/\/\n+  \/\/ When a region is \"flipped\", we adjust capacities and region counts for original and destination partitions.  We also\n+  \/\/ adjust used values when flipping from mutator to collector.  Flip to old collector does not need to adjust used because\n+  \/\/ only empty regions can be flipped to old collector.\n+  \/\/\n+  \/\/ All memory quantities (capacity, available, used) are represented in bytes.\n+\n@@ -82,0 +105,1 @@\n+\n@@ -84,0 +108,11 @@\n+\n+  \/\/ Measured in bytes.\n+  size_t _allocated_since_gc_start[UIntNumPartitions];\n+\n+  \/\/ Some notes:\n+  \/\/  total_region_counts[p] is _capacity[p] \/ region_size_bytes\n+  \/\/  retired_regions[p] is total_region_counts[p] - _region_counts[p]\n+  \/\/  _empty_region_counts[p] <= _region_counts[p] <= total_region_counts[p]\n+  \/\/  affiliated regions is total_region_counts[p] - empty_region_counts[p]\n+  \/\/  used_regions is affilaited_regions * region_size_bytes\n+  \/\/  _available[p] is _capacity[p] - _used[p]\n@@ -85,0 +120,5 @@\n+  size_t _empty_region_counts[UIntNumPartitions];\n+\n+  \/\/ Humongous waste, in bytes, can exist in Mutator partition for recently allocated humongous objects\n+  \/\/ and in OldCollector partition for humongous objects that have been promoted in place.\n+  size_t _humongous_waste[UIntNumPartitions];\n@@ -90,8 +130,0 @@\n-  \/\/ Shrink the intervals associated with partition when region idx is removed from this free set\n-  inline void shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx);\n-\n-  \/\/ Shrink the intervals associated with partition when regions low_idx through high_idx inclusive are removed from this free set\n-  inline void shrink_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId partition,\n-                                                                ssize_t low_idx, ssize_t high_idx);\n-  inline void expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, ssize_t idx, size_t capacity);\n-\n@@ -104,2 +136,2 @@\n-  void dump_bitmap_row(ssize_t region_idx) const;\n-  void dump_bitmap_range(ssize_t start_region_idx, ssize_t end_region_idx) const;\n+  void dump_bitmap_row(idx_t region_idx) const;\n+  void dump_bitmap_range(idx_t start_region_idx, idx_t end_region_idx) const;\n@@ -114,0 +146,5 @@\n+  inline idx_t max() const { return _max; }\n+\n+  \/\/ At initialization, reset OldCollector tallies\n+  void initialize_old_collector();\n+\n@@ -122,0 +159,7 @@\n+  \/\/ Clear the partition id for a particular region without adjusting interval bounds or usage\/capacity tallies\n+  inline void raw_clear_membership(size_t idx, ShenandoahFreeSetPartitionId p) {\n+    _membership[int(p)].clear_bit(idx);\n+  }\n+\n+  inline void one_region_is_no_longer_empty(ShenandoahFreeSetPartitionId partition);\n+\n@@ -125,3 +169,4 @@\n-  void establish_mutator_intervals(ssize_t mutator_leftmost, ssize_t mutator_rightmost,\n-                                   ssize_t mutator_leftmost_empty, ssize_t mutator_rightmost_empty,\n-                                   size_t mutator_region_count, size_t mutator_used);\n+  void establish_mutator_intervals(idx_t mutator_leftmost, idx_t mutator_rightmost,\n+                                   idx_t mutator_leftmost_empty, idx_t mutator_rightmost_empty,\n+                                   size_t total_mutator_regions, size_t empty_mutator_regions,\n+                                   size_t mutator_region_count, size_t mutator_used, size_t mutator_humongous_words_waste);\n@@ -132,3 +177,20 @@\n-  void establish_old_collector_intervals(ssize_t old_collector_leftmost, ssize_t old_collector_rightmost,\n-                                         ssize_t old_collector_leftmost_empty, ssize_t old_collector_rightmost_empty,\n-                                         size_t old_collector_region_count, size_t old_collector_used);\n+  void establish_old_collector_intervals(idx_t old_collector_leftmost, idx_t old_collector_rightmost,\n+                                         idx_t old_collector_leftmost_empty, idx_t old_collector_rightmost_empty,\n+                                         size_t total_old_collector_region_count, size_t old_collector_empty,\n+                                         size_t old_collector_regions, size_t old_collector_used,\n+                                         size_t old_collector_humongous_words_waste);\n+\n+  void establish_interval(ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx,\n+                          idx_t low_empty_idx, idx_t high_empty_idx);\n+\n+  \/\/ Shrink the intervals associated with partition when region idx is removed from this free set\n+  inline void shrink_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, idx_t idx);\n+\n+  \/\/ Shrink the intervals associated with partition when regions low_idx through high_idx inclusive are removed from this free set\n+  void shrink_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId partition,\n+                                                         idx_t low_idx, idx_t high_idx, size_t num_regions);\n+\n+  void expand_interval_if_boundary_modified(ShenandoahFreeSetPartitionId partition, idx_t idx, size_t capacity);\n+  void expand_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId partition,\n+                                                         idx_t low_idx, idx_t high_idx,\n+                                                         idx_t low_empty_idx, idx_t high_empty_idx);\n@@ -139,1 +201,2 @@\n-  void retire_from_partition(ShenandoahFreeSetPartitionId p, ssize_t idx, size_t used_bytes);\n+  \/\/ Return the number of waste bytes (if any).\n+  size_t retire_from_partition(ShenandoahFreeSetPartitionId p, idx_t idx, size_t used_bytes);\n@@ -144,1 +207,3 @@\n-  void retire_range_from_partition(ShenandoahFreeSetPartitionId partition, ssize_t low_idx, ssize_t high_idx);\n+  void retire_range_from_partition(ShenandoahFreeSetPartitionId partition, idx_t low_idx, idx_t high_idx);\n+\n+  void unretire_to_partition(ShenandoahHeapRegion* region, ShenandoahFreeSetPartitionId which_partition);\n@@ -147,1 +212,1 @@\n-  void make_free(ssize_t idx, ShenandoahFreeSetPartitionId which_partition, size_t region_capacity);\n+  void make_free(idx_t idx, ShenandoahFreeSetPartitionId which_partition, size_t region_capacity);\n@@ -149,3 +214,8 @@\n-  \/\/ Place region idx into free partition new_partition, adjusting used and capacity totals for the original and new partition\n-  \/\/ given that available bytes can still be allocated within this region.  Requires that idx is currently not NotFree.\n-  void move_from_partition_to_partition(ssize_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+  \/\/ Place region idx into free partition new_partition, not adjusting used and capacity totals for the original and new partition.\n+  \/\/ available represents bytes that can still be allocated within this region.  Requires that idx is currently not NotFree.\n+  size_t move_from_partition_to_partition_with_deferred_accounting(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n+                                                                   ShenandoahFreeSetPartitionId new_partition, size_t available);\n+\n+  \/\/ Place region idx into free partition new_partition, adjusting used and capacity totals for the original and new partition.\n+  \/\/ available represents bytes that can still be allocated within this region.  Requires that idx is currently not NotFree.\n+  void move_from_partition_to_partition(idx_t idx, ShenandoahFreeSetPartitionId orig_partition,\n@@ -154,1 +224,4 @@\n-  const char* partition_membership_name(ssize_t idx) const;\n+  void transfer_used_capacity_from_to(ShenandoahFreeSetPartitionId from_partition, ShenandoahFreeSetPartitionId to_partition,\n+                                      size_t regions);\n+\n+  const char* partition_membership_name(idx_t idx) const;\n@@ -157,1 +230,2 @@\n-  inline ssize_t find_index_of_next_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t start_index) const;\n+  inline idx_t find_index_of_next_available_region(ShenandoahFreeSetPartitionId which_partition,\n+                                                        idx_t start_index) const;\n@@ -160,1 +234,2 @@\n-  inline ssize_t find_index_of_previous_available_region(ShenandoahFreeSetPartitionId which_partition, ssize_t last_index) const;\n+  inline idx_t find_index_of_previous_available_region(ShenandoahFreeSetPartitionId which_partition,\n+                                                            idx_t last_index) const;\n@@ -163,2 +238,2 @@\n-  inline ssize_t find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n-                                                                 ssize_t start_index, size_t cluster_size) const;\n+  inline idx_t find_index_of_next_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                               idx_t start_index, size_t cluster_size) const;\n@@ -167,2 +242,2 @@\n-  inline ssize_t find_index_of_previous_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n-                                                                     ssize_t last_index, size_t cluster_size) const;\n+  inline idx_t find_index_of_previous_available_cluster_of_regions(ShenandoahFreeSetPartitionId which_partition,\n+                                                                   idx_t last_index, size_t cluster_size) const;\n@@ -170,1 +245,1 @@\n-  inline bool in_free_set(ShenandoahFreeSetPartitionId which_partition, ssize_t idx) const {\n+  inline bool in_free_set(ShenandoahFreeSetPartitionId which_partition, idx_t idx) const {\n@@ -176,1 +251,11 @@\n-  inline ShenandoahFreeSetPartitionId membership(ssize_t idx) const;\n+  inline ShenandoahFreeSetPartitionId membership(idx_t idx) const {\n+    assert (idx < _max, \"index is sane: %zu < %zu\", idx, _max);\n+    ShenandoahFreeSetPartitionId result = ShenandoahFreeSetPartitionId::NotFree;\n+    for (uint partition_id = 0; partition_id < UIntNumPartitions; partition_id++) {\n+      if (_membership[partition_id].is_set(idx)) {\n+        assert(result == ShenandoahFreeSetPartitionId::NotFree, \"Region should reside in only one partition\");\n+        result = (ShenandoahFreeSetPartitionId) partition_id;\n+      }\n+    }\n+    return result;\n+  }\n@@ -181,1 +266,1 @@\n-  inline bool partition_id_matches(ssize_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n+  inline bool partition_id_matches(idx_t idx, ShenandoahFreeSetPartitionId which_partition) const;\n@@ -184,2 +269,0 @@\n-  inline size_t max_regions() const { return _max; }\n-\n@@ -195,4 +278,4 @@\n-  inline ssize_t leftmost(ShenandoahFreeSetPartitionId which_partition) const;\n-  inline ssize_t rightmost(ShenandoahFreeSetPartitionId which_partition) const;\n-  ssize_t leftmost_empty(ShenandoahFreeSetPartitionId which_partition);\n-  ssize_t rightmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+  inline idx_t leftmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  inline idx_t rightmost(ShenandoahFreeSetPartitionId which_partition) const;\n+  idx_t leftmost_empty(ShenandoahFreeSetPartitionId which_partition);\n+  idx_t rightmost_empty(ShenandoahFreeSetPartitionId which_partition);\n@@ -202,0 +285,25 @@\n+  inline void increase_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions);\n+  inline void decrease_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions);\n+  inline size_t get_region_counts(ShenandoahFreeSetPartitionId which_partition) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _region_counts[int(which_partition)];\n+  }\n+\n+  inline void increase_empty_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions);\n+  inline void decrease_empty_region_counts(ShenandoahFreeSetPartitionId which_partition, size_t regions);\n+  inline size_t get_empty_region_counts(ShenandoahFreeSetPartitionId which_partition) {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _empty_region_counts[int(which_partition)];\n+  }\n+\n+  inline void increase_capacity(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n+  inline void decrease_capacity(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n+  inline size_t get_capacity(ShenandoahFreeSetPartitionId which_partition) {\n+    assert (which_partition < NumPartitions, \"Partition must be valid\");\n+    return _capacity[int(which_partition)];\n+  }\n+\n+  inline void increase_available(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n+  inline void decrease_available(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n+  inline size_t get_available(ShenandoahFreeSetPartitionId which_partition);\n+\n@@ -203,0 +311,15 @@\n+  inline void decrease_used(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n+  inline size_t get_used(ShenandoahFreeSetPartitionId which_partition) {\n+    assert (which_partition < NumPartitions, \"Partition must be valid\");\n+    return _used[int(which_partition)];\n+  }\n+\n+  inline void increase_humongous_waste(ShenandoahFreeSetPartitionId which_partition, size_t bytes);\n+  inline void decrease_humongous_waste(ShenandoahFreeSetPartitionId which_partition, size_t bytes) {\n+    shenandoah_assert_heaplocked();\n+    assert (which_partition < NumPartitions, \"Partition must be valid\");\n+    assert(_humongous_waste[int(which_partition)] >= bytes, \"Cannot decrease waste beyond what is there\");\n+    _humongous_waste[int(which_partition)] -= bytes;\n+  }\n+\n+  inline size_t get_humongous_waste(ShenandoahFreeSetPartitionId which_partition);\n@@ -230,1 +353,1 @@\n-           partition_membership_name(ssize_t(which_partition)));\n+           partition_membership_name(idx_t(which_partition)));\n@@ -234,0 +357,7 @@\n+  \/\/ Returns bytes of humongous waste\n+  inline size_t humongous_waste(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    \/\/ This may be called with or without the global heap lock.  Changes to _humongous_waste[] are always made with heap lock.\n+    return _humongous_waste[int(which_partition)];\n+  }\n+\n@@ -246,1 +376,1 @@\n-           partition_membership_name(ssize_t(which_partition)));\n+           partition_membership_name(idx_t(which_partition)));\n@@ -251,6 +381,1 @@\n-  inline void set_capacity_of(ShenandoahFreeSetPartitionId which_partition, size_t value) {\n-    shenandoah_assert_heaplocked();\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    _capacity[int(which_partition)] = value;\n-    _available[int(which_partition)] = value - _used[int(which_partition)];\n-  }\n+  inline void set_capacity_of(ShenandoahFreeSetPartitionId which_partition, size_t value);\n@@ -287,1 +412,1 @@\n-  void assert_bounds() NOT_DEBUG_RETURN;\n+  void assert_bounds(bool validate_totals) NOT_DEBUG_RETURN;\n@@ -315,0 +440,1 @@\n+using idx_t = ShenandoahSimpleBitMap::idx_t;\n@@ -319,0 +445,2 @@\n+  size_t _total_humongous_waste;\n+\n@@ -333,0 +461,99 @@\n+  \/\/ bytes used by young\n+  size_t _total_young_used;\n+  template<bool UsedByMutatorChanged, bool UsedByCollectorChanged>\n+  inline void recompute_total_young_used() {\n+    if (UsedByMutatorChanged || UsedByCollectorChanged) {\n+      shenandoah_assert_heaplocked();\n+      _total_young_used = (_partitions.used_by(ShenandoahFreeSetPartitionId::Mutator) +\n+                           _partitions.used_by(ShenandoahFreeSetPartitionId::Collector));\n+    }\n+  }\n+\n+  \/\/ bytes used by old\n+  size_t _total_old_used;\n+  template<bool UsedByOldCollectorChanged>\n+  inline void recompute_total_old_used() {\n+    if (UsedByOldCollectorChanged) {\n+      shenandoah_assert_heaplocked();\n+      _total_old_used =_partitions.used_by(ShenandoahFreeSetPartitionId::OldCollector);\n+    }\n+  }\n+\n+public:\n+  \/\/ We make this public so that native code can see its value\n+  \/\/ bytes used by global\n+  size_t _total_global_used;\n+private:\n+  \/\/ Prerequisite: _total_young_used and _total_old_used are valid\n+  template<bool UsedByMutatorChanged, bool UsedByCollectorChanged, bool UsedByOldCollectorChanged>\n+  inline void recompute_total_global_used() {\n+    if (UsedByMutatorChanged || UsedByCollectorChanged || UsedByOldCollectorChanged) {\n+      shenandoah_assert_heaplocked();\n+      _total_global_used = _total_young_used + _total_old_used;\n+    }\n+  }\n+\n+  template<bool UsedByMutatorChanged, bool UsedByCollectorChanged, bool UsedByOldCollectorChanged>\n+  inline void recompute_total_used() {\n+    recompute_total_young_used<UsedByMutatorChanged, UsedByCollectorChanged>();\n+    recompute_total_old_used<UsedByOldCollectorChanged>();\n+    recompute_total_global_used<UsedByMutatorChanged, UsedByCollectorChanged, UsedByOldCollectorChanged>();\n+  }\n+\n+  size_t _young_affiliated_regions;\n+  size_t _old_affiliated_regions;\n+  size_t _global_affiliated_regions;\n+\n+  size_t _young_unaffiliated_regions;\n+  size_t _global_unaffiliated_regions;\n+\n+  size_t _total_young_regions;\n+  size_t _total_global_regions;\n+\n+  size_t _mutator_bytes_allocated_since_gc_start;\n+\n+  \/\/ If only affiliation changes are promote-in-place and generation sizes have not changed,\n+  \/\/    we have AffiliatedChangesAreGlobalNeutral\n+  \/\/ If only affiliation changes are non-empty regions moved from Mutator to Collector and young size has not changed,\n+  \/\/    we have AffiliatedChangesAreYoungNeutral\n+  \/\/ If only unaffiliated changes are empty regions from Mutator to\/from Collector, we have UnaffiliatedChangesAreYoungNeutral\n+  template<bool MutatorEmptiesChanged, bool CollectorEmptiesChanged, bool OldCollectorEmptiesChanged,\n+           bool MutatorSizeChanged, bool CollectorSizeChanged, bool OldCollectorSizeChanged,\n+           bool AffiliatedChangesAreYoungNeutral, bool AffiliatedChangesAreGlobalNeutral,\n+           bool UnaffiliatedChangesAreYoungNeutral>\n+  inline void recompute_total_affiliated() {\n+    shenandoah_assert_heaplocked();\n+    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    if (!UnaffiliatedChangesAreYoungNeutral && (MutatorEmptiesChanged || CollectorEmptiesChanged)) {\n+      _young_unaffiliated_regions = (_partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::Mutator) +\n+                                     _partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::Collector));\n+    }\n+    if (!AffiliatedChangesAreYoungNeutral &&\n+        (MutatorSizeChanged || CollectorSizeChanged || MutatorEmptiesChanged || CollectorEmptiesChanged)) {\n+      _young_affiliated_regions = ((_partitions.get_capacity(ShenandoahFreeSetPartitionId::Mutator) +\n+                                    _partitions.get_capacity(ShenandoahFreeSetPartitionId::Collector)) \/ region_size_bytes -\n+                                   _young_unaffiliated_regions);\n+    }\n+    if (OldCollectorSizeChanged || OldCollectorEmptiesChanged) {\n+      _old_affiliated_regions = (_partitions.get_capacity(ShenandoahFreeSetPartitionId::OldCollector) \/ region_size_bytes -\n+                                 _partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::OldCollector));\n+    }\n+    if (!AffiliatedChangesAreGlobalNeutral &&\n+        (MutatorEmptiesChanged || CollectorEmptiesChanged || OldCollectorEmptiesChanged)) {\n+      _global_unaffiliated_regions =\n+        _young_unaffiliated_regions + _partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::OldCollector);\n+    }\n+    if (!AffiliatedChangesAreGlobalNeutral &&\n+        (MutatorSizeChanged || CollectorSizeChanged || MutatorEmptiesChanged || CollectorEmptiesChanged ||\n+         OldCollectorSizeChanged || OldCollectorEmptiesChanged)) {\n+      _global_affiliated_regions = _young_affiliated_regions + _old_affiliated_regions;\n+    }\n+#ifdef ASSERT\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      assert(_young_affiliated_regions * ShenandoahHeapRegion::region_size_bytes() >= _total_young_used, \"sanity\");\n+      assert(_old_affiliated_regions * ShenandoahHeapRegion::region_size_bytes() >= _total_old_used, \"sanity\");\n+    }\n+    assert(_global_affiliated_regions * ShenandoahHeapRegion::region_size_bytes() >= _total_global_used, \"sanity\");\n+#endif\n+  }\n+\n@@ -350,0 +577,2 @@\n+  bool transfer_one_region_from_mutator_to_old_collector(size_t idx, size_t alloc_capacity);\n+\n@@ -377,1 +606,2 @@\n-  HeapWord* allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n+  HeapWord* allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation,\n+                                      ShenandoahAllocRequest& req, bool& in_new_region);\n@@ -395,0 +625,4 @@\n+  void transfer_empty_regions_from_to(ShenandoahFreeSetPartitionId source_partition,\n+                                      ShenandoahFreeSetPartitionId dest_partition,\n+                                      size_t num_regions);\n+\n@@ -402,1 +636,0 @@\n-\n@@ -405,3 +638,0 @@\n-\n-  \/\/ Set max_capacity for young and old generations\n-  void establish_generation_sizes(size_t young_region_count, size_t old_region_count);\n@@ -418,0 +648,15 @@\n+  inline size_t max_regions() const { return _partitions.max(); }\n+  ShenandoahFreeSetPartitionId membership(size_t index) const { return _partitions.membership(index); }\n+  inline void shrink_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId partition,\n+                                                                idx_t low_idx, idx_t high_idx, size_t num_regions) {\n+    return _partitions.shrink_interval_if_range_modifies_either_boundary(partition, low_idx, high_idx, num_regions);\n+  }\n+\n+  void reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated);\n+\n+  void increase_bytes_allocated(size_t bytes);\n+\n+  inline size_t get_bytes_allocated_since_gc_start() const {\n+    return _mutator_bytes_allocated_since_gc_start;\n+  }\n+\n@@ -422,0 +667,57 @@\n+  \/\/ Return bytes used by old\n+  inline size_t old_used() {\n+    return _total_old_used;\n+  }\n+\n+  ShenandoahFreeSetPartitionId prepare_to_promote_in_place(size_t idx, size_t bytes);\n+  void account_for_pip_regions(size_t mutator_regions, size_t mutator_bytes, size_t collector_regions, size_t collector_bytes);\n+\n+  \/\/ This is used for unit testing.  Not for preoduction.  Invokes exit() if old cannot be resized.\n+  void resize_old_collector_capacity(size_t desired_regions);\n+\n+  \/\/ Return bytes used by young\n+  inline size_t young_used() {\n+    return _total_young_used;\n+  }\n+\n+  \/\/ Return bytes used by global\n+  inline size_t global_used() {\n+    return _total_global_used;\n+  }\n+\n+  size_t global_unaffiliated_regions() {\n+    return _global_unaffiliated_regions;\n+  }\n+\n+  size_t young_unaffiliated_regions() {\n+    return _young_unaffiliated_regions;\n+  }\n+\n+  size_t old_unaffiliated_regions() {\n+    return _partitions.get_empty_region_counts(ShenandoahFreeSetPartitionId::OldCollector);\n+  }\n+\n+  size_t young_affiliated_regions() {\n+    return _young_affiliated_regions;\n+  }\n+\n+  size_t old_affiliated_regions() {\n+    return _old_affiliated_regions;\n+  }\n+\n+  size_t global_affiliated_regions() {\n+    return _global_affiliated_regions;\n+  }\n+\n+  size_t total_young_regions() {\n+    return _total_young_regions;\n+  }\n+\n+  size_t total_old_regions() {\n+    return _partitions.get_capacity(ShenandoahFreeSetPartitionId::OldCollector) \/ ShenandoahHeapRegion::region_size_bytes();\n+  }\n+\n+  size_t total_global_regions() {\n+    return _total_global_regions;\n+  }\n+\n@@ -467,0 +769,2 @@\n+  void transfer_humongous_regions_from_mutator_to_old_collector(size_t xfer_regions, size_t humongous_waste_words);\n+\n@@ -485,0 +789,6 @@\n+  inline size_t total_humongous_waste() const      { return _total_humongous_waste; }\n+  inline size_t humongous_waste_in_mutator() const { return _partitions.humongous_waste(ShenandoahFreeSetPartitionId::Mutator); }\n+  inline size_t humongous_waste_in_old() const { return _partitions.humongous_waste(ShenandoahFreeSetPartitionId::OldCollector); }\n+\n+  void decrease_humongous_waste_for_regular_bypass(ShenandoahHeapRegion* r, size_t waste);\n+\n@@ -542,1 +852,2 @@\n-  void reserve_regions(size_t to_reserve, size_t old_reserve, size_t &old_region_count);\n+  void reserve_regions(size_t to_reserve, size_t old_reserve, size_t &old_region_count,\n+                       size_t &young_used_regions, size_t &old_used_regions, size_t &young_used_bytes, size_t &old_used_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":380,"deletions":69,"binary":false,"changes":449,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-  ShenandoahGenerationalHeap::TransferResult result;\n@@ -254,8 +253,1 @@\n-    result = phase5_epilog();\n-  }\n-  if (heap->mode()->is_generational()) {\n-    LogTarget(Info, gc, ergo) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      result.print_on(\"Full GC\", &ls);\n-    }\n+    phase5_epilog();\n@@ -987,17 +979,0 @@\n-\n-  void update_generation_usage() {\n-    if (_is_generational) {\n-      _heap->old_generation()->establish_usage(_old_regions, _old_usage, _old_humongous_waste);\n-      _heap->young_generation()->establish_usage(_young_regions, _young_usage, _young_humongous_waste);\n-    } else {\n-      assert(_old_regions == 0, \"Old regions only expected in generational mode\");\n-      assert(_old_usage == 0, \"Old usage only expected in generational mode\");\n-      assert(_old_humongous_waste == 0, \"Old humongous waste only expected in generational mode\");\n-    }\n-\n-    \/\/ In generational mode, global usage should be the sum of young and old. This is also true\n-    \/\/ for non-generational modes except that there are no old regions.\n-    _heap->global_generation()->establish_usage(_old_regions + _young_regions,\n-                                                _old_usage + _young_usage,\n-                                                _old_humongous_waste + _young_humongous_waste);\n-  }\n@@ -1123,1 +1098,1 @@\n-ShenandoahGenerationalHeap::TransferResult ShenandoahFullGC::phase5_epilog() {\n+void ShenandoahFullGC::phase5_epilog() {\n@@ -1126,1 +1101,0 @@\n-  ShenandoahGenerationalHeap::TransferResult result;\n@@ -1141,6 +1115,0 @@\n-    post_compact.update_generation_usage();\n-\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGenerationalFullGC::balance_generations_after_gc(heap);\n-    }\n-\n@@ -1169,2 +1137,0 @@\n-  \/\/ We defer generation resizing actions until after cset regions have been recycled.  We do this even following an\n-  \/\/ abbreviated cycle.\n@@ -1172,1 +1138,0 @@\n-    result = ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set();\n@@ -1175,1 +1140,0 @@\n-  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":38,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-  ShenandoahGenerationalHeap::TransferResult phase5_epilog();\n-\n+  void phase5_epilog();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+using idx_t = ShenandoahSimpleBitMap::idx_t;\n+\n@@ -150,12 +152,0 @@\n-size_t ShenandoahGeneration::bytes_allocated_since_gc_start() const {\n-  return AtomicAccess::load(&_bytes_allocated_since_gc_start);\n-}\n-\n-void ShenandoahGeneration::reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated) {\n-  AtomicAccess::store(&_bytes_allocated_since_gc_start, initial_bytes_allocated);\n-}\n-\n-void ShenandoahGeneration::increase_allocated(size_t bytes) {\n-  AtomicAccess::add(&_bytes_allocated_since_gc_start, bytes, memory_order_relaxed);\n-}\n-\n@@ -163,0 +153,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -274,1 +265,1 @@\n-  const size_t young_evacuation_reserve = MIN2(maximum_young_evacuation_reserve, young_generation->available_with_reserve());\n+  size_t young_evacuation_reserve = MIN2(maximum_young_evacuation_reserve, young_generation->available_with_reserve());\n@@ -354,0 +345,5 @@\n+  \/\/ If any regions have been selected for promotion in place, this has the effect of decreasing available within mutator\n+  \/\/ and collector partitions, due to padding of remnant memory within each promoted in place region.  This will affect\n+  \/\/ young_evacuation_reserve but not old_evacuation_reserve or consumed_by_advance_promotion.  So recompute.\n+  young_evacuation_reserve = MIN2(young_evacuation_reserve, young_generation->available_with_reserve());\n+\n@@ -385,1 +381,1 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -389,1 +385,1 @@\n-  size_t old_evacuated = collection_set->get_old_bytes_reserved_for_evacuation();\n+  const size_t old_evacuated = collection_set->get_live_bytes_in_old_regions();\n@@ -402,0 +398,1 @@\n+    log_debug(gc, cset)(\"Shrinking old evac reserve to match old_evac_commited: \" PROPERFMT, PROPERFMTARGS(old_evacuated_committed));\n@@ -406,1 +403,1 @@\n-  size_t young_advance_promoted = collection_set->get_young_bytes_to_be_promoted();\n+  size_t young_advance_promoted = collection_set->get_live_bytes_in_tenurable_regions();\n@@ -409,1 +406,1 @@\n-  size_t young_evacuated = collection_set->get_young_bytes_reserved_for_evacuation();\n+  size_t young_evacuated = collection_set->get_live_bytes_in_untenurable_regions();\n@@ -437,1 +434,3 @@\n-  assert(old_available >= unaffiliated_old, \"Unaffiliated old is a subset of old available\");\n+  assert(old_available >= unaffiliated_old,\n+         \"Unaffiliated old (%zu is %zu * %zu) is a subset of old available (%zu)\",\n+         unaffiliated_old, unaffiliated_old_regions, region_size_bytes, old_available);\n@@ -467,1 +466,0 @@\n-\n@@ -469,4 +467,0 @@\n-    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n-    assert(excess_old >= regions_to_xfer * region_size_bytes,\n-           \"Cannot transfer (%zu, %zu) more than excess old (%zu)\",\n-           regions_to_xfer, region_size_bytes, excess_old);\n@@ -474,2 +468,2 @@\n-    log_debug(gc, ergo)(\"%s transferred %zu excess regions to young before start of evacuation\",\n-                       result? \"Successfully\": \"Unsuccessfully\", regions_to_xfer);\n+    log_debug(gc, ergo)(\"Before start of evacuation, total_promotion reserve is young_advance_promoted_reserve: %zu \"\n+                        \"plus excess: old: %zu\", young_advance_promoted_reserve_used, excess_old);\n@@ -527,1 +521,1 @@\n-size_t ShenandoahGeneration::select_aged_regions(size_t old_available) {\n+size_t ShenandoahGeneration::select_aged_regions(const size_t old_promotion_reserve) {\n@@ -533,0 +527,2 @@\n+  ShenandoahYoungGeneration* young_gen = heap->young_generation();\n+  ShenandoahFreeSet* free_set = heap->free_set();\n@@ -540,1 +536,0 @@\n-  size_t old_consumed = 0;\n@@ -550,1 +545,1 @@\n-  const size_t num_regions = heap->num_regions();\n+  const idx_t num_regions = heap->num_regions();\n@@ -555,1 +550,17 @@\n-  for (size_t i = 0; i < num_regions; i++) {\n+  ShenandoahFreeSet* freeset = heap->free_set();\n+\n+  \/\/ Any region that is to be promoted in place needs to be retired from its Collector or Mutator partition.\n+  idx_t pip_low_collector_idx = freeset->max_regions();\n+  idx_t pip_high_collector_idx = -1;\n+  idx_t pip_low_mutator_idx = freeset->max_regions();\n+  idx_t pip_high_mutator_idx = -1;\n+  size_t collector_regions_to_pip = 0;\n+  size_t mutator_regions_to_pip = 0;\n+\n+  size_t pip_mutator_regions = 0;\n+  size_t pip_collector_regions = 0;\n+  size_t pip_mutator_bytes = 0;\n+  size_t pip_collector_bytes = 0;\n+\n+  size_t min_remnant_size = PLAB::min_size() * HeapWordSize;\n+  for (idx_t i = 0; i < num_regions; i++) {\n@@ -563,1 +574,1 @@\n-        \/\/ We prefer to promote this region in place because is has a small amount of garbage and a large usage.\n+        \/\/ We prefer to promote this region in place because it has a small amount of garbage and a large usage.\n@@ -572,4 +583,5 @@\n-\n-          size_t remnant_size = r->free() \/ HeapWordSize;\n-          if (remnant_size > ShenandoahHeap::min_fill_size()) {\n-            ShenandoahHeap::fill_with_object(original_top, remnant_size);\n+          size_t remnant_bytes = r->free();\n+          size_t remnant_words = remnant_bytes \/ HeapWordSize;\n+          assert(ShenandoahHeap::min_fill_size() <= PLAB::min_size(), \"Implementation makes invalid assumptions\");\n+          if (remnant_words >= ShenandoahHeap::min_fill_size()) {\n+            ShenandoahHeap::fill_with_object(original_top, remnant_words);\n@@ -580,1 +592,33 @@\n-            promote_in_place_pad += remnant_size * HeapWordSize;\n+            \/\/ The region r is either in the Mutator or Collector partition if remnant_words > heap()->plab_min_size.\n+            \/\/ Otherwise, the region is in the NotFree partition.\n+            ShenandoahFreeSetPartitionId p = free_set->membership(i);\n+            if (p == ShenandoahFreeSetPartitionId::Mutator) {\n+              mutator_regions_to_pip++;\n+              if (i < pip_low_mutator_idx) {\n+                pip_low_mutator_idx = i;\n+              }\n+              if (i > pip_high_mutator_idx) {\n+                pip_high_mutator_idx = i;\n+              }\n+              pip_mutator_regions++;\n+              pip_mutator_bytes += remnant_bytes;\n+            } else if (p == ShenandoahFreeSetPartitionId::Collector) {\n+              collector_regions_to_pip++;\n+              if (i < pip_low_collector_idx) {\n+                pip_low_collector_idx = i;\n+              }\n+              if (i > pip_high_collector_idx) {\n+                pip_high_collector_idx = i;\n+              }\n+              pip_collector_regions++;\n+              pip_collector_bytes += remnant_bytes;\n+            } else {\n+              assert((p == ShenandoahFreeSetPartitionId::NotFree) && (remnant_words < heap->plab_min_size()),\n+                     \"Should be NotFree if not in Collector or Mutator partitions\");\n+              \/\/ In this case, the memory is already counted as used and the region has already been retired.  There is\n+              \/\/ no need for further adjustments to used.  Further, the remnant memory for this region will not be\n+              \/\/ unallocated or made available to OldCollector after pip.\n+              remnant_bytes = 0;\n+            }\n+            promote_in_place_pad += remnant_bytes;\n+            free_set->prepare_to_promote_in_place(i, remnant_bytes);\n@@ -582,2 +626,5 @@\n-            \/\/ Since the remnant is so small that it cannot be filled, we don't have to worry about any accidental\n-            \/\/ allocations occurring within this region before the region is promoted in place.\n+            \/\/ Since the remnant is so small that this region has already been retired, we don't have to worry about any\n+            \/\/ accidental allocations occurring within this region before the region is promoted in place.\n+\n+            \/\/ This region was already not in the Collector or Mutator set, so no need to remove it.\n+            assert(free_set->membership(i) == ShenandoahFreeSetPartitionId::NotFree, \"sanity\");\n@@ -623,0 +670,17 @@\n+\n+  if (pip_mutator_regions + pip_collector_regions > 0) {\n+    freeset->account_for_pip_regions(pip_mutator_regions, pip_mutator_bytes, pip_collector_regions, pip_collector_bytes);\n+  }\n+\n+  \/\/ Retire any regions that have been selected for promote in place\n+  if (collector_regions_to_pip > 0) {\n+    freeset->shrink_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId::Collector,\n+                                                               pip_low_collector_idx, pip_high_collector_idx,\n+                                                               collector_regions_to_pip);\n+  }\n+  if (mutator_regions_to_pip > 0) {\n+    freeset->shrink_interval_if_range_modifies_either_boundary(ShenandoahFreeSetPartitionId::Mutator,\n+                                                               pip_low_mutator_idx, pip_high_mutator_idx,\n+                                                               mutator_regions_to_pip);\n+  }\n+\n@@ -625,0 +689,1 @@\n+  size_t old_consumed = 0;\n@@ -631,3 +696,3 @@\n-      size_t region_live_data = sorted_regions[i]._live_data;\n-      size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n-      if (old_consumed + promotion_need <= old_available) {\n+      const size_t region_live_data = sorted_regions[i]._live_data;\n+      const size_t promotion_need = (size_t) (region_live_data * ShenandoahPromoEvacWaste);\n+      if (old_consumed + promotion_need <= old_promotion_reserve) {\n@@ -647,3 +712,3 @@\n-    log_debug(gc)(\"Preselected %zu regions containing %zu live bytes,\"\n-                 \" consuming: %zu of budgeted: %zu\",\n-                 selected_regions, selected_live, old_consumed, old_available);\n+    log_debug(gc, ergo)(\"Preselected %zu regions containing \" PROPERFMT \" live data,\"\n+                        \" consuming: \" PROPERFMT \" of budgeted: \" PROPERFMT,\n+                        selected_regions, PROPERFMTARGS(selected_live), PROPERFMTARGS(old_consumed), PROPERFMTARGS(old_promotion_reserve));\n@@ -652,0 +717,2 @@\n+  log_info(gc, ergo)(\"Promotion potential of aged regions with sufficient garbage: \" PROPERFMT, PROPERFMTARGS(promo_potential));\n+\n@@ -753,1 +820,7 @@\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+    _free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+      gen_heap->compute_old_generation_balance(young_cset_regions, old_cset_regions);\n+    }\n+\n@@ -755,1 +828,1 @@\n-    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old, true);\n+    _free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old, true);\n@@ -799,2 +872,1 @@\n-                                           uint max_workers,\n-                                           size_t max_capacity) :\n+                                           uint max_workers) :\n@@ -803,4 +875,3 @@\n-  _ref_processor(new ShenandoahReferenceProcessor(MAX2(max_workers, 1U))),\n-  _affiliated_region_count(0), _humongous_waste(0), _evacuation_reserve(0),\n-  _used(0), _bytes_allocated_since_gc_start(0),\n-  _max_capacity(max_capacity),\n+  _ref_processor(new ShenandoahReferenceProcessor(this, MAX2(max_workers, 1U))),\n+  _evacuation_reserve(0),\n+  _free_set(nullptr),\n@@ -825,0 +896,5 @@\n+void ShenandoahGeneration::post_initialize(ShenandoahHeap* heap) {\n+  _free_set = heap->free_set();\n+  assert(_free_set != nullptr, \"bad initialization order\");\n+}\n+\n@@ -852,90 +928,0 @@\n-size_t ShenandoahGeneration::increment_affiliated_region_count() {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n-  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n-  \/\/ a coherent value.\n-  return AtomicAccess::add(&_affiliated_region_count, (size_t) 1);\n-}\n-\n-size_t ShenandoahGeneration::decrement_affiliated_region_count() {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-  \/\/ During full gc, multiple GC worker threads may change region affiliations without a lock.  No lock is enforced\n-  \/\/ on read and write of _affiliated_region_count.  At the end of full gc, a single thread overwrites the count with\n-  \/\/ a coherent value.\n-  auto affiliated_region_count = AtomicAccess::sub(&_affiliated_region_count, (size_t) 1);\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (used() + _humongous_waste <= affiliated_region_count * ShenandoahHeapRegion::region_size_bytes()),\n-         \"used + humongous cannot exceed regions\");\n-  return affiliated_region_count;\n-}\n-\n-size_t ShenandoahGeneration::decrement_affiliated_region_count_without_lock() {\n-  return AtomicAccess::sub(&_affiliated_region_count, (size_t) 1);\n-}\n-\n-size_t ShenandoahGeneration::increase_affiliated_region_count(size_t delta) {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-  return AtomicAccess::add(&_affiliated_region_count, delta);\n-}\n-\n-size_t ShenandoahGeneration::decrease_affiliated_region_count(size_t delta) {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-  assert(AtomicAccess::load(&_affiliated_region_count) >= delta, \"Affiliated region count cannot be negative\");\n-\n-  auto const affiliated_region_count = AtomicAccess::sub(&_affiliated_region_count, delta);\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (_used + _humongous_waste <= affiliated_region_count * ShenandoahHeapRegion::region_size_bytes()),\n-         \"used + humongous cannot exceed regions\");\n-  return affiliated_region_count;\n-}\n-\n-void ShenandoahGeneration::establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste) {\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"must be at a safepoint\");\n-  AtomicAccess::store(&_affiliated_region_count, num_regions);\n-  AtomicAccess::store(&_used, num_bytes);\n-  _humongous_waste = humongous_waste;\n-}\n-\n-void ShenandoahGeneration::increase_used(size_t bytes) {\n-  AtomicAccess::add(&_used, bytes);\n-}\n-\n-void ShenandoahGeneration::increase_humongous_waste(size_t bytes) {\n-  if (bytes > 0) {\n-    AtomicAccess::add(&_humongous_waste, bytes);\n-  }\n-}\n-\n-void ShenandoahGeneration::decrease_humongous_waste(size_t bytes) {\n-  if (bytes > 0) {\n-    assert(ShenandoahHeap::heap()->is_full_gc_in_progress() || (_humongous_waste >= bytes),\n-           \"Waste (%zu) cannot be negative (after subtracting %zu)\", _humongous_waste, bytes);\n-    AtomicAccess::sub(&_humongous_waste, bytes);\n-  }\n-}\n-\n-void ShenandoahGeneration::decrease_used(size_t bytes) {\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (_used >= bytes), \"cannot reduce bytes used by generation below zero\");\n-  AtomicAccess::sub(&_used, bytes);\n-}\n-\n-size_t ShenandoahGeneration::used_regions() const {\n-  return AtomicAccess::load(&_affiliated_region_count);\n-}\n-\n-size_t ShenandoahGeneration::free_unaffiliated_regions() const {\n-  size_t result = max_capacity() \/ ShenandoahHeapRegion::region_size_bytes();\n-  auto const used_regions = this->used_regions();\n-  if (used_regions > result) {\n-    result = 0;\n-  } else {\n-    result -= used_regions;\n-  }\n-  return result;\n-}\n-\n-size_t ShenandoahGeneration::used_regions_size() const {\n-  return used_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n@@ -943,1 +929,2 @@\n-  return available(max_capacity());\n+  size_t result = available(max_capacity());\n+  return result;\n@@ -948,1 +935,2 @@\n-  return available(max_capacity());\n+  size_t result = available(max_capacity());\n+  return result;\n@@ -952,1 +940,2 @@\n-  return available(ShenandoahHeap::heap()->soft_max_capacity());\n+  size_t result = available(ShenandoahHeap::heap()->soft_max_capacity());\n+  return result;\n@@ -956,49 +945,3 @@\n-  size_t in_use = used() + get_humongous_waste();\n-  return in_use > capacity ? 0 : capacity - in_use;\n-}\n-\n-size_t ShenandoahGeneration::increase_capacity(size_t increment) {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-\n-  \/\/ We do not enforce that new capacity >= heap->max_size_for(this).  The maximum generation size is treated as a rule of thumb\n-  \/\/ which may be violated during certain transitions, such as when we are forcing transfers for the purpose of promoting regions\n-  \/\/ in place.\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (_max_capacity + increment <= ShenandoahHeap::heap()->max_capacity()), \"Generation cannot be larger than heap size\");\n-  assert(increment % ShenandoahHeapRegion::region_size_bytes() == 0, \"Generation capacity must be multiple of region size\");\n-  _max_capacity += increment;\n-\n-  \/\/ This detects arithmetic wraparound on _used\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (used_regions_size() >= used()),\n-         \"Affiliated regions must hold more than what is currently used\");\n-  return _max_capacity;\n-}\n-\n-size_t ShenandoahGeneration::set_capacity(size_t byte_size) {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-  _max_capacity = byte_size;\n-  return _max_capacity;\n-}\n-\n-size_t ShenandoahGeneration::decrease_capacity(size_t decrement) {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-\n-  \/\/ We do not enforce that new capacity >= heap->min_size_for(this).  The minimum generation size is treated as a rule of thumb\n-  \/\/ which may be violated during certain transitions, such as when we are forcing transfers for the purpose of promoting regions\n-  \/\/ in place.\n-  assert(decrement % ShenandoahHeapRegion::region_size_bytes() == 0, \"Generation capacity must be multiple of region size\");\n-  assert(_max_capacity >= decrement, \"Generation capacity cannot be negative\");\n-\n-  _max_capacity -= decrement;\n-\n-  \/\/ This detects arithmetic wraparound on _used\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (used_regions_size() >= used()),\n-         \"Affiliated regions must hold more than what is currently used\");\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (_used <= _max_capacity), \"Cannot use more than capacity\");\n-  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n-         (used_regions_size() <= _max_capacity),\n-         \"Cannot use more than capacity\");\n-  return _max_capacity;\n+  size_t in_use = used();\n+  size_t result = in_use > capacity ? 0 : capacity - in_use;\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":136,"deletions":193,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -43,1 +44,0 @@\n-\n@@ -55,10 +55,0 @@\n-  volatile size_t _affiliated_region_count;\n-\n-  \/\/ How much free memory is left in the last region of humongous objects.\n-  \/\/ This is _not_ included in used, but it _is_ deducted from available,\n-  \/\/ which gives the heuristics a more accurate view of how much memory remains\n-  \/\/ for allocation. This figure is also included the heap status logging.\n-  \/\/ The units are bytes. The value is only changed on a safepoint or under the\n-  \/\/ heap lock.\n-  size_t _humongous_waste;\n-\n@@ -69,6 +59,1 @@\n-  \/\/ Usage\n-\n-  volatile size_t _used;\n-  volatile size_t _bytes_allocated_since_gc_start;\n-  size_t _max_capacity;\n-\n+  ShenandoahFreeSet* _free_set;\n@@ -100,1 +85,1 @@\n-  size_t select_aged_regions(size_t old_available);\n+  size_t select_aged_regions(size_t old_promotion_reserve);\n@@ -102,0 +87,1 @@\n+  \/\/ Return available assuming that we can allocate no more than capacity bytes within this generation.\n@@ -106,2 +92,1 @@\n-                       uint max_workers,\n-                       size_t max_capacity);\n+                       uint max_workers);\n@@ -110,3 +95,4 @@\n-  bool is_young() const  { return _type == YOUNG; }\n-  bool is_old() const    { return _type == OLD; }\n-  bool is_global() const { return _type == GLOBAL || _type == NON_GEN; }\n+  inline bool is_young() const                 { return _type == YOUNG; }\n+  inline bool is_old() const                   { return _type == OLD; }\n+  inline bool is_global() const                { return _type == GLOBAL || _type == NON_GEN; }\n+  inline ShenandoahGenerationType type() const { return _type; }\n@@ -119,2 +105,0 @@\n-  inline ShenandoahGenerationType type() const { return _type; }\n-\n@@ -127,5 +111,11 @@\n-  size_t max_capacity() const override      { return _max_capacity; }\n-  virtual size_t used_regions() const;\n-  virtual size_t used_regions_size() const;\n-  virtual size_t free_unaffiliated_regions() const;\n-  size_t used() const override { return AtomicAccess::load(&_used); }\n+  virtual void post_initialize(ShenandoahHeap* heap);\n+\n+  virtual size_t bytes_allocated_since_gc_start() const override = 0;\n+  virtual size_t used() const override = 0;\n+  virtual size_t used_regions() const = 0;\n+  virtual size_t used_regions_size() const = 0;\n+  virtual size_t get_humongous_waste() const = 0;\n+  virtual size_t free_unaffiliated_regions() const = 0;\n+  virtual size_t get_affiliated_region_count() const = 0;\n+  virtual size_t max_capacity() const override = 0;\n+\n@@ -134,3 +124,0 @@\n-  size_t used_including_humongous_waste() const {\n-    return used() + get_humongous_waste();\n-  }\n@@ -144,17 +131,0 @@\n-  size_t bytes_allocated_since_gc_start() const override;\n-\n-  \/\/ Reset the bytes allocated within this generation since the start of GC.  The argument initial_bytes_allocated\n-  \/\/ is normally zero.  In the case that some memory was allocated following the last allocation rate sample that\n-  \/\/ precedes the start of GC, the number of bytes allocated is supplied as the initial value of bytes_allocated_since_gc_start.\n-  \/\/ We will behave as if these bytes were allocated after the start of GC.\n-  void reset_bytes_allocated_since_gc_start(size_t initial_bytes_allocated);\n-  void increase_allocated(size_t bytes);\n-\n-  \/\/ These methods change the capacity of the generation by adding or subtracting the given number of bytes from the current\n-  \/\/ capacity, returning the capacity of the generation following the change.\n-  size_t increase_capacity(size_t increment);\n-  size_t decrease_capacity(size_t decrement);\n-\n-  \/\/ Set the capacity of the generation, returning the value set\n-  size_t set_capacity(size_t byte_size);\n-\n@@ -220,23 +190,0 @@\n-  \/\/ Return the updated value of affiliated_region_count\n-  size_t increment_affiliated_region_count();\n-\n-  \/\/ Return the updated value of affiliated_region_count\n-  size_t decrement_affiliated_region_count();\n-  \/\/ Same as decrement_affiliated_region_count, but w\/o the need to hold heap lock before being called.\n-  size_t decrement_affiliated_region_count_without_lock();\n-\n-  \/\/ Return the updated value of affiliated_region_count\n-  size_t increase_affiliated_region_count(size_t delta);\n-\n-  \/\/ Return the updated value of affiliated_region_count\n-  size_t decrease_affiliated_region_count(size_t delta);\n-\n-  void establish_usage(size_t num_regions, size_t num_bytes, size_t humongous_waste);\n-\n-  void increase_used(size_t bytes);\n-  void decrease_used(size_t bytes);\n-\n-  void increase_humongous_waste(size_t bytes);\n-  void decrease_humongous_waste(size_t bytes);\n-  size_t get_humongous_waste() const { return _humongous_waste; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":20,"deletions":73,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n-#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-\n-\n-ShenandoahGenerationSizer::ShenandoahGenerationSizer()\n-        : _sizer_kind(SizerDefaults),\n-          _min_desired_young_regions(0),\n-          _max_desired_young_regions(0) {\n-\n-  if (FLAG_IS_CMDLINE(NewRatio)) {\n-    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n-    } else {\n-      _sizer_kind = SizerNewRatio;\n-      return;\n-    }\n-  }\n-\n-  if (NewSize > MaxNewSize) {\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"NewSize (%zuk) is greater than the MaxNewSize (%zuk). \"\n-                            \"A new max generation size of %zuk will be used.\",\n-              NewSize\/K, MaxNewSize\/K, NewSize\/K);\n-    }\n-    FLAG_SET_ERGO(MaxNewSize, NewSize);\n-  }\n-\n-  if (FLAG_IS_CMDLINE(NewSize)) {\n-    _min_desired_young_regions = MAX2(uint(NewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-      _sizer_kind = SizerMaxAndNewSize;\n-    } else {\n-      _sizer_kind = SizerNewSizeOnly;\n-    }\n-  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-    _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    _sizer_kind = SizerMaxNewSizeOnly;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_min_young_regions(size_t heap_region_count) {\n-  size_t min_young_regions = (heap_region_count * ShenandoahMinYoungPercentage) \/ 100;\n-  return MAX2(min_young_regions, (size_t) 1U);\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_max_young_regions(size_t heap_region_count) {\n-  size_t max_young_regions = (heap_region_count * ShenandoahMaxYoungPercentage) \/ 100;\n-  return MAX2(max_young_regions, (size_t) 1U);\n-}\n-\n-void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_region_count) {\n-  assert(heap_region_count > 0, \"Heap must be initialized\");\n-\n-  switch (_sizer_kind) {\n-    case SizerDefaults:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      break;\n-    case SizerNewSizeOnly:\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      _max_desired_young_regions = MAX2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxNewSizeOnly:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _min_desired_young_regions = MIN2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxAndNewSize:\n-      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n-      break;\n-    case SizerNewRatio:\n-      _min_desired_young_regions = MAX2(uint(heap_region_count \/ (NewRatio + 1)), 1U);\n-      _max_desired_young_regions = _min_desired_young_regions;\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  assert(_min_desired_young_regions <= _max_desired_young_regions, \"Invalid min\/max young gen size values\");\n-}\n-\n-void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n-  recalculate_min_max_young_length(heap_size \/ ShenandoahHeapRegion::region_size_bytes());\n-}\n-\n-bool ShenandoahGenerationSizer::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const {\n-  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n-\n-  if (src->free_unaffiliated_regions() < regions) {\n-    \/\/ Source does not have enough free regions for this transfer. The caller should have\n-    \/\/ already capped the transfer based on available unaffiliated regions.\n-    return false;\n-  }\n-\n-  if (dst->max_capacity() + bytes_to_transfer > max_size_for(dst)) {\n-    \/\/ This transfer would cause the destination generation to grow above its configured maximum size.\n-    return false;\n-  }\n-\n-  if (src->max_capacity() - bytes_to_transfer < min_size_for(src)) {\n-    \/\/ This transfer would cause the source generation to shrink below its configured minimum size.\n-    return false;\n-  }\n-\n-  src->decrease_capacity(bytes_to_transfer);\n-  dst->increase_capacity(bytes_to_transfer);\n-  const size_t new_size = dst->max_capacity();\n-  log_info(gc, ergo)(\"Transfer %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                     regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n-  return true;\n-}\n-\n-\n-size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return max_young_size();\n-    case OLD:\n-      \/\/ On the command line, max size of OLD is specified indirectly, by setting a minimum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - min_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return min_young_size();\n-    case OLD:\n-      \/\/ On the command line, min size of OLD is specified indirectly, by setting a maximum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-\n-\/\/ Returns true iff transfer is successful\n-bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n-  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-  return transfer_regions(heap->young_generation(), heap->old_generation(), regions);\n-}\n-\n-\/\/ This is used when promoting humongous or highly utilized regular regions in place.  It is not required in this situation\n-\/\/ that the transferred regions be unaffiliated.\n-void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n-  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n-  ShenandoahGeneration* young_gen = heap->young_generation();\n-  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n-\n-  young_gen->decrease_capacity(bytes_to_transfer);\n-  old_gen->increase_capacity(bytes_to_transfer);\n-  const size_t new_size = old_gen->max_capacity();\n-  log_info(gc, ergo)(\"Forcing transfer of %zu region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                     regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n-}\n-\n-\n-bool ShenandoahGenerationSizer::transfer_to_young(size_t regions) const {\n-  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-  return transfer_regions(heap->old_generation(), heap->young_generation(), regions);\n-}\n-\n-size_t ShenandoahGenerationSizer::min_young_size() const {\n-  return min_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n-size_t ShenandoahGenerationSizer::max_young_size() const {\n-  return max_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.cpp","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class ShenandoahGeneration;\n-class ShenandoahGenerationalHeap;\n-\n-class ShenandoahGenerationSizer {\n-private:\n-  enum SizerKind {\n-    SizerDefaults,\n-    SizerNewSizeOnly,\n-    SizerMaxNewSizeOnly,\n-    SizerMaxAndNewSize,\n-    SizerNewRatio\n-  };\n-  SizerKind _sizer_kind;\n-\n-  size_t _min_desired_young_regions;\n-  size_t _max_desired_young_regions;\n-\n-  static size_t calculate_min_young_regions(size_t heap_region_count);\n-  static size_t calculate_max_young_regions(size_t heap_region_count);\n-\n-  \/\/ Update the given values for minimum and maximum young gen length in regions\n-  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n-  void recalculate_min_max_young_length(size_t heap_region_count);\n-\n-  \/\/ This will attempt to transfer regions from the `src` generation to `dst` generation.\n-  \/\/ If the transfer would violate the configured minimum size for the source or the configured\n-  \/\/ maximum size of the destination, it will not perform the transfer and will return false.\n-  \/\/ Returns true if the transfer is performed.\n-  bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const;\n-\n-  \/\/ Return the configured maximum size in bytes for the given generation.\n-  size_t max_size_for(ShenandoahGeneration* generation) const;\n-\n-  \/\/ Return the configured minimum size in bytes for the given generation.\n-  size_t min_size_for(ShenandoahGeneration* generation) const;\n-\n-public:\n-  ShenandoahGenerationSizer();\n-\n-  \/\/ Calculate the maximum length of the young gen given the number of regions\n-  \/\/ depending on the sizing algorithm.\n-  void heap_size_changed(size_t heap_size);\n-\n-  \/\/ Minimum size of young generation in bytes as multiple of region size.\n-  size_t min_young_size() const;\n-  size_t min_young_regions() const {\n-    return _min_desired_young_regions;\n-  }\n-\n-  \/\/ Maximum size of young generation in bytes as multiple of region size.\n-  size_t max_young_size() const;\n-  size_t max_young_regions() const {\n-    return _max_desired_young_regions;\n-  }\n-\n-  \/\/ True if transfer succeeds, else false. See transfer_regions.\n-  bool transfer_to_young(size_t regions) const;\n-  bool transfer_to_old(size_t regions) const;\n-\n-  \/\/ force transfer is used when we promote humongous objects.  May violate min\/max limits on generation sizes\n-  void force_transfer_to_old(size_t regions) const;\n-};\n-\n-#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.hpp","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -247,1 +247,3 @@\n-  _heap->reset_bytes_allocated_since_gc_start();\n+  if (gc_mode() != servicing_old) {\n+    _heap->reset_bytes_allocated_since_gc_start();\n+  }\n@@ -291,0 +293,3 @@\n+    \/\/ Report current free set state at the end of cycle if normal completion.\n+    \/\/ Do not report if cancelled, since we may not have rebuilt free set and content is unreliable.\n+    _heap->free_set()->log_status_under_lock();\n@@ -293,3 +298,0 @@\n-  \/\/ Report current free set state at the end of cycle, whether\n-  \/\/ it is a normal completion, or the abort.\n-  _heap->free_set()->log_status_under_lock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -179,1 +180,1 @@\n-    const size_t old_garbage_threshold = (ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold) \/ 100;\n+    const size_t old_garbage_threshold = (region_size_bytes * ShenandoahOldGarbageThreshold) \/ 100;\n@@ -181,1 +182,2 @@\n-    assert(region->garbage_before_padded_for_promote() < old_garbage_threshold, \"Region %zu has too much garbage for promotion\", region->index());\n+    assert(region->garbage_before_padded_for_promote() < old_garbage_threshold,\n+           \"Region %zu has too much garbage for promotion\", region->index());\n@@ -228,0 +230,7 @@\n+    \/\/ pip_unpadded is memory too small to be filled above original top\n+    size_t pip_unpadded = (region->end() - region->top()) * HeapWordSize;\n+    assert((region->top() == region->end())\n+           || (pip_unpadded == (size_t) ((region->end() - region->top()) * HeapWordSize)), \"Invariant\");\n+    assert(pip_unpadded < ShenandoahHeap::min_fill_size() * HeapWordSize, \"Sanity\");\n+    size_t pip_pad_bytes = (region->top() - region->get_top_before_promote()) * HeapWordSize;\n+    assert((pip_unpadded == 0) || (pip_pad_bytes == 0), \"Only one of pip_unpadded and pip_pad_bytes is non-zero\");\n@@ -230,1 +239,1 @@\n-    \/\/ is_collector_free range.\n+    \/\/ is_collector_free range.  We'll add it to that range below.\n@@ -232,2 +241,4 @@\n-\n-    size_t region_used = region->used();\n+#ifdef ASSERT\n+    size_t region_to_be_used_in_old = region->used();\n+    assert(region_to_be_used_in_old + pip_pad_bytes + pip_unpadded == region_size_bytes, \"invariant\");\n+#endif\n@@ -239,17 +250,1 @@\n-    \/\/ Unconditionally transfer one region from young to old. This represents the newly promoted region.\n-    \/\/ This expands old and shrinks new by the size of one region.  Strictly, we do not \"need\" to expand old\n-    \/\/ if there are already enough unaffiliated regions in old to account for this newly promoted region.\n-    \/\/ However, if we do not transfer the capacities, we end up reducing the amount of memory that would have\n-    \/\/ otherwise been available to hold old evacuations, because old available is max_capacity - used and now\n-    \/\/ we would be trading a fully empty region for a partially used region.\n-    young_gen->decrease_used(region_used);\n-    young_gen->decrement_affiliated_region_count();\n-\n-    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n-    _heap->generation_sizer()->force_transfer_to_old(1);\n-    region->set_affiliation(OLD_GENERATION);\n-\n-    old_gen->increment_affiliated_region_count();\n-    old_gen->increase_used(region_used);\n-\n-    \/\/ add_old_collector_free_region() increases promoted_reserve() if available space exceeds plab_min_size()\n+    \/\/ Transfer this region from young to old, increasing promoted_reserve if available space exceeds plab_min_size()\n@@ -257,0 +252,1 @@\n+    region->set_affiliation(OLD_GENERATION);\n@@ -271,1 +267,2 @@\n-  const size_t humongous_waste = spanned_regions * ShenandoahHeapRegion::region_size_bytes() - obj->size() * HeapWordSize;\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  const size_t humongous_waste = spanned_regions * region_size_bytes - obj->size() * HeapWordSize;\n@@ -285,7 +282,0 @@\n-    young_gen->decrease_used(used_bytes);\n-    young_gen->decrease_humongous_waste(humongous_waste);\n-    young_gen->decrease_affiliated_region_count(spanned_regions);\n-\n-    \/\/ transfer_to_old() increases capacity of old and decreases capacity of young\n-    _heap->generation_sizer()->force_transfer_to_old(spanned_regions);\n-\n@@ -303,3 +293,2 @@\n-    old_gen->increase_affiliated_region_count(spanned_regions);\n-    old_gen->increase_used(used_bytes);\n-    old_gen->increase_humongous_waste(humongous_waste);\n+    ShenandoahFreeSet* freeset = _heap->free_set();\n+    freeset->transfer_humongous_regions_from_mutator_to_old_collector(spanned_regions, humongous_waste);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":22,"deletions":33,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  assert(generation->used_including_humongous_waste() <= generation->used_regions_size(),\n+  assert(generation->used() <= generation->used_regions_size(),\n@@ -86,1 +86,1 @@\n-  old->set_live_bytes_after_last_mark(old->used_including_humongous_waste());\n+  old->set_live_bytes_after_last_mark(old->used());\n@@ -107,27 +107,0 @@\n-void ShenandoahGenerationalFullGC::balance_generations_after_gc(ShenandoahHeap* heap) {\n-  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::cast(heap);\n-  ShenandoahOldGeneration* const old_gen = gen_heap->old_generation();\n-\n-  size_t old_usage = old_gen->used_regions_size();\n-  size_t old_capacity = old_gen->max_capacity();\n-\n-  assert(old_usage % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old usage must align with region size\");\n-  assert(old_capacity % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old capacity must align with region size\");\n-\n-  if (old_capacity > old_usage) {\n-    size_t excess_old_regions = (old_capacity - old_usage) \/ ShenandoahHeapRegion::region_size_bytes();\n-    gen_heap->generation_sizer()->transfer_to_young(excess_old_regions);\n-  } else if (old_capacity < old_usage) {\n-    size_t old_regions_deficit = (old_usage - old_capacity) \/ ShenandoahHeapRegion::region_size_bytes();\n-    gen_heap->generation_sizer()->force_transfer_to_old(old_regions_deficit);\n-  }\n-\n-  log_info(gc, ergo)(\"FullGC done: young usage: \" PROPERFMT \", old usage: \" PROPERFMT,\n-               PROPERFMTARGS(gen_heap->young_generation()->used()),\n-               PROPERFMTARGS(old_gen->used()));\n-}\n-\n-ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set() {\n-  return ShenandoahGenerationalHeap::heap()->balance_generations();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -48,6 +48,0 @@\n-  \/\/ Full GC may have promoted regions and may have temporarily violated constraints on the usage and\n-  \/\/ capacity of the old generation. This method will balance the accounting of regions between the\n-  \/\/ young and old generations. This is somewhat vestigial, but the outcome of this method is used\n-  \/\/ when rebuilding the free sets.\n-  static void balance_generations_after_gc(ShenandoahHeap* heap);\n-\n@@ -59,8 +53,0 @@\n-  \/\/ Rebuilding the free set may have resulted in regions being pulled in to the old generation\n-  \/\/ evacuation reserve. For this reason, we must update the usage and capacity of the generations\n-  \/\/ again. In the distant past, the free set did not know anything about generations, so we had\n-  \/\/ a layer built above it to represent how much young\/old memory was available. This layer is\n-  \/\/ redundant and adds complexity. We would like to one day remove it. Until then, we must keep it\n-  \/\/ synchronized with the free set's view of things.\n-  static ShenandoahGenerationalHeap::TransferResult balance_generations_after_rebuilding_free_set();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -76,1 +77,1 @@\n-size_t ShenandoahGenerationalHeap::unsafe_max_tlab_alloc(Thread *thread) const {\n+size_t ShenandoahGenerationalHeap::unsafe_max_tlab_alloc() const {\n@@ -110,3 +111,4 @@\n-  _generation_sizer.heap_size_changed(max_capacity());\n-  size_t initial_capacity_young = _generation_sizer.max_young_size();\n-  size_t max_capacity_young = _generation_sizer.max_young_size();\n+  size_t region_count = num_regions();\n+  size_t max_young_regions = MAX2((region_count * ShenandoahMaxYoungPercentage) \/ 100, (size_t) 1U);\n+  size_t initial_capacity_young = max_young_regions * ShenandoahHeapRegion::region_size_bytes();\n+  size_t max_capacity_young = initial_capacity_young;\n@@ -116,2 +118,2 @@\n-  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young);\n-  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old);\n+  _young_generation = new ShenandoahYoungGeneration(max_workers());\n+  _old_generation = new ShenandoahOldGeneration(max_workers());\n@@ -122,0 +124,6 @@\n+void ShenandoahGenerationalHeap::post_initialize_heuristics() {\n+  ShenandoahHeap::post_initialize_heuristics();\n+  _young_generation->post_initialize(this);\n+  _old_generation->post_initialize(this);\n+}\n+\n@@ -270,0 +278,1 @@\n+              \/\/ Shrinking the desired PLAB size may allow us to eke out a small PLAB while staying beneath evacuation reserve.\n@@ -439,2 +448,0 @@\n-  \/\/ New object should fit the PLAB size\n-\n@@ -442,0 +449,1 @@\n+\n@@ -454,1 +462,1 @@\n-  size_t future_size = MIN2(cur_size * 2, plab_max_size());\n+  const size_t future_size = MIN2(cur_size * 2, plab_max_size());\n@@ -458,2 +466,2 @@\n-          \", card_size: %zu, cur_size: %zu, max: %zu\",\n-         future_size, (size_t) CardTable::card_size_in_words(), cur_size, plab_max_size());\n+          \", card_size: %u, cur_size: %zu, max: %zu\",\n+         future_size, CardTable::card_size_in_words(), cur_size, plab_max_size());\n@@ -465,1 +473,1 @@\n-  log_debug(gc, free)(\"Set new PLAB size: %zu\", future_size);\n+  log_debug(gc, plab)(\"Set next PLAB refill size: %zu bytes\", future_size * HeapWordSize);\n@@ -467,0 +475,1 @@\n+\n@@ -470,1 +479,1 @@\n-    log_debug(gc, free)(\"Current PLAB size (%zu) is too small for %zu\", cur_size, size);\n+    log_debug(gc, plab)(\"Current PLAB size (%zu) is too small for %zu\", cur_size * HeapWordSize, size * HeapWordSize);\n@@ -556,0 +565,1 @@\n+    log_debug(gc, plab)(\"Retire PLAB, unexpend unpromoted: %zu\", not_promoted * HeapWordSize);\n@@ -567,2 +577,2 @@\n-    log_debug(gc)(\"retire_plab() is registering remnant of size %zu at \" PTR_FORMAT,\n-                  plab->waste() - original_waste, p2i(top));\n+    log_debug(gc, plab)(\"retire_plab() is registering remnant of size %zu at \" PTR_FORMAT,\n+                        (plab->waste() - original_waste) * HeapWordSize, p2i(top));\n@@ -579,29 +589,0 @@\n-ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalHeap::balance_generations() {\n-  shenandoah_assert_heaplocked_or_safepoint();\n-\n-  ShenandoahOldGeneration* old_gen = old_generation();\n-  const ssize_t old_region_balance = old_gen->get_region_balance();\n-  old_gen->set_region_balance(0);\n-\n-  if (old_region_balance > 0) {\n-    const auto old_region_surplus = checked_cast<size_t>(old_region_balance);\n-    const bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n-    return TransferResult {\n-      success, old_region_surplus, \"young\"\n-    };\n-  }\n-\n-  if (old_region_balance < 0) {\n-    const auto old_region_deficit = checked_cast<size_t>(-old_region_balance);\n-    const bool success = generation_sizer()->transfer_to_old(old_region_deficit);\n-    if (!success) {\n-      old_gen->handle_failed_transfer();\n-    }\n-    return TransferResult {\n-      success, old_region_deficit, \"old\"\n-    };\n-  }\n-\n-  return TransferResult {true, 0, \"none\"};\n-}\n-\n@@ -611,1 +592,4 @@\n-\/\/ xfer_limit is the maximum we're able to transfer from young to old.\n+\/\/\n+\/\/ xfer_limit is the maximum we're able to transfer from young to old based on either:\n+\/\/  1. an assumption that we will be able to replenish memory \"borrowed\" from young at the end of collection, or\n+\/\/  2. there is sufficient excess in the allocation runway during GC idle cycles\n@@ -639,3 +623,3 @@\n-  const double max_old_reserve = (ShenandoahOldEvacRatioPercent == 100)?\n-                                 bound_on_old_reserve: MIN2(double(young_reserve * ShenandoahOldEvacRatioPercent) \/ double(100 - ShenandoahOldEvacRatioPercent),\n-                                                            bound_on_old_reserve);\n+  const double max_old_reserve = ((ShenandoahOldEvacRatioPercent == 100)? bound_on_old_reserve:\n+                                  MIN2(double(young_reserve * ShenandoahOldEvacRatioPercent)\n+                                       \/ double(100 - ShenandoahOldEvacRatioPercent), bound_on_old_reserve));\n@@ -650,1 +634,2 @@\n-    const double max_evac_need = (double(old_generation()->unprocessed_collection_candidates_live_memory()) * ShenandoahOldEvacWaste);\n+    const double max_evac_need =\n+      (double(old_generation()->unprocessed_collection_candidates_live_memory()) * ShenandoahOldEvacWaste);\n@@ -653,1 +638,2 @@\n-    const double old_fragmented_available = double(old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes);\n+    const double old_fragmented_available =\n+      double(old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes);\n@@ -700,0 +686,1 @@\n+  ShenandoahHeapLocker locker(lock());\n@@ -1062,9 +1049,0 @@\n-\n-  \/\/ We defer generation resizing actions until after cset regions have been recycled.\n-  TransferResult result = balance_generations();\n-  LogTarget(Info, gc, ergo) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    result.print_on(\"Degenerated GC\", &ls);\n-  }\n-\n@@ -1092,18 +1070,1 @@\n-\n-  log_info(gc, cset)(\"Concurrent cycle complete, promotions reserved: %zu, promotions expended: %zu, failed count: %zu, failed bytes: %zu\",\n-                     old_generation()->get_promoted_reserve(), old_generation()->get_promoted_expended(),\n-                     old_generation()->get_promotion_failed_count(), old_generation()->get_promotion_failed_words() * HeapWordSize);\n-\n-  TransferResult result;\n-  {\n-    ShenandoahHeapLocker locker(lock());\n-\n-    result = balance_generations();\n-    reset_generation_reserves();\n-  }\n-\n-  LogTarget(Info, gc, ergo) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    result.print_on(\"Concurrent GC\", &ls);\n-  }\n+  reset_generation_reserves();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":38,"deletions":77,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  void post_initialize_heuristics() override;\n@@ -58,1 +59,1 @@\n-  size_t unsafe_max_tlab_alloc(Thread *thread) const override;\n+  size_t unsafe_max_tlab_alloc() const override;\n@@ -141,2 +142,0 @@\n-  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n-\n@@ -166,2 +165,0 @@\n-\n-  ShenandoahGenerationSizer     _generation_sizer;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-  return ShenandoahHeap::heap()->max_capacity();\n+  size_t total_regions = _free_set->total_global_regions();\n+  return total_regions * ShenandoahHeapRegion::region_size_bytes();\n@@ -43,0 +44,21 @@\n+size_t ShenandoahGlobalGeneration::free_unaffiliated_regions() const {\n+  return _free_set->global_unaffiliated_regions();\n+}\n+\n+size_t ShenandoahGlobalGeneration::used() const {\n+  return _free_set->global_used();\n+}\n+\n+size_t ShenandoahGlobalGeneration::bytes_allocated_since_gc_start() const {\n+  return _free_set->get_bytes_allocated_since_gc_start();\n+}\n+\n+size_t ShenandoahGlobalGeneration::get_affiliated_region_count() const {\n+  return _free_set->global_affiliated_regions();\n+}\n+\n+size_t ShenandoahGlobalGeneration::get_humongous_waste() const {\n+  return _free_set->total_humongous_waste();\n+}\n+\n+\n@@ -44,3 +66,1 @@\n-  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-  assert(heap->mode()->is_generational(), \"Region usage accounting is only for generational mode\");\n-  return heap->old_generation()->used_regions() + heap->young_generation()->used_regions();\n+  return _free_set->global_affiliated_regions();\n@@ -50,1 +70,2 @@\n-  return ShenandoahHeap::heap()->capacity();\n+  size_t used_regions = _free_set->global_affiliated_regions();\n+  return used_regions * ShenandoahHeapRegion::region_size_bytes();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -35,2 +35,10 @@\n-  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity)\n-  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity) { }\n+  ShenandoahGlobalGeneration(bool generational, uint max_queues)\n+  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues) {\n+#ifdef ASSERT\n+    ShenandoahHeap* heap = ShenandoahHeap::heap();\n+    bool is_generational = heap->mode()->is_generational();\n+    assert(is_generational == generational, \"sanity\");\n+    assert((is_generational && (type() == ShenandoahGenerationType::GLOBAL)) ||\n+           (!is_generational && (type() == ShenandoahGenerationType::NON_GEN)), \"OO sanity\");\n+#endif\n+  }\n@@ -41,1 +49,2 @@\n-  size_t max_capacity() const override;\n+  size_t bytes_allocated_since_gc_start() const override;\n+  size_t used() const override;\n@@ -44,0 +53,5 @@\n+  size_t get_humongous_waste() const override;\n+  size_t free_unaffiliated_regions() const override;\n+  size_t get_affiliated_region_count() const override;\n+  size_t max_capacity() const override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  _soft_max_size = SoftMaxHeapSize;\n+  _soft_max_size = clamp(SoftMaxHeapSize, min_capacity(), max_capacity());\n@@ -255,1 +255,1 @@\n-    _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity());\n+    _old_generation = new ShenandoahOldGeneration(max_workers());\n@@ -414,1 +414,0 @@\n-    _free_set = new ShenandoahFreeSet(this, _num_regions);\n@@ -429,0 +428,1 @@\n+    _free_set = new ShenandoahFreeSet(this, _num_regions);\n@@ -430,1 +430,0 @@\n-    size_t young_cset_regions, old_cset_regions;\n@@ -432,0 +431,1 @@\n+    post_initialize_heuristics();\n@@ -433,1 +433,1 @@\n-    size_t first_old, last_old, num_old;\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n@@ -435,0 +435,8 @@\n+    if (mode()->is_generational()) {\n+      ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+      \/\/ We cannot call\n+      \/\/  gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions)\n+      \/\/ until after the heap is fully initialized.  So we make up a safe value here.\n+      size_t allocation_runway = InitialHeapSize \/ 2;\n+      gen_heap->compute_old_generation_balance(allocation_runway, old_cset_regions);\n+    }\n@@ -528,1 +536,1 @@\n-  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity());\n+  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers());\n@@ -532,0 +540,4 @@\n+void ShenandoahHeap::post_initialize_heuristics() {\n+  _global_generation->post_initialize(this);\n+}\n+\n@@ -676,0 +688,2 @@\n+  check_soft_max_changed();\n+\n@@ -720,69 +734,0 @@\n-\/\/ For tracking usage based on allocations, it should be the case that:\n-\/\/ * The sum of regions::used == heap::used\n-\/\/ * The sum of a generation's regions::used == generation::used\n-\/\/ * The sum of a generation's humongous regions::free == generation::humongous_waste\n-\/\/ These invariants are checked by the verifier on GC safepoints.\n-\/\/\n-\/\/ Additional notes:\n-\/\/ * When a mutator's allocation request causes a region to be retired, the\n-\/\/   free memory left in that region is considered waste. It does not contribute\n-\/\/   to the usage, but it _does_ contribute to allocation rate.\n-\/\/ * The bottom of a PLAB must be aligned on card size. In some cases this will\n-\/\/   require padding in front of the PLAB (a filler object). Because this padding\n-\/\/   is included in the region's used memory we include the padding in the usage\n-\/\/   accounting as waste.\n-\/\/ * Mutator allocations are used to compute an allocation rate.\n-\/\/ * There are three sources of waste:\n-\/\/  1. The padding used to align a PLAB on card size\n-\/\/  2. Region's free is less than minimum TLAB size and is retired\n-\/\/  3. The unused portion of memory in the last region of a humongous object\n-void ShenandoahHeap::increase_used(const ShenandoahAllocRequest& req) {\n-  size_t actual_bytes = req.actual_size() * HeapWordSize;\n-  size_t wasted_bytes = req.waste() * HeapWordSize;\n-  ShenandoahGeneration* generation = generation_for(req.affiliation());\n-\n-  if (req.is_gc_alloc()) {\n-    assert(wasted_bytes == 0 || req.type() == ShenandoahAllocRequest::_alloc_plab, \"Only PLABs have waste\");\n-    increase_used(generation, actual_bytes + wasted_bytes);\n-  } else {\n-    assert(req.is_mutator_alloc(), \"Expected mutator alloc here\");\n-    \/\/ padding and actual size both count towards allocation counter\n-    generation->increase_allocated(actual_bytes + wasted_bytes);\n-\n-    \/\/ only actual size counts toward usage for mutator allocations\n-    increase_used(generation, actual_bytes);\n-\n-    if (wasted_bytes > 0 && ShenandoahHeapRegion::requires_humongous(req.actual_size())) {\n-      increase_humongous_waste(generation,wasted_bytes);\n-    }\n-  }\n-}\n-\n-void ShenandoahHeap::increase_humongous_waste(ShenandoahGeneration* generation, size_t bytes) {\n-  generation->increase_humongous_waste(bytes);\n-  if (!generation->is_global()) {\n-    global_generation()->increase_humongous_waste(bytes);\n-  }\n-}\n-\n-void ShenandoahHeap::decrease_humongous_waste(ShenandoahGeneration* generation, size_t bytes) {\n-  generation->decrease_humongous_waste(bytes);\n-  if (!generation->is_global()) {\n-    global_generation()->decrease_humongous_waste(bytes);\n-  }\n-}\n-\n-void ShenandoahHeap::increase_used(ShenandoahGeneration* generation, size_t bytes) {\n-  generation->increase_used(bytes);\n-  if (!generation->is_global()) {\n-    global_generation()->increase_used(bytes);\n-  }\n-}\n-\n-void ShenandoahHeap::decrease_used(ShenandoahGeneration* generation, size_t bytes) {\n-  generation->decrease_used(bytes);\n-  if (!generation->is_global()) {\n-    global_generation()->decrease_used(bytes);\n-  }\n-}\n-\n@@ -1037,4 +982,0 @@\n-  \/\/ This is called regardless of the outcome of the allocation to account\n-  \/\/ for any waste created by retiring regions with this request.\n-  increase_used(req);\n-\n@@ -1274,1 +1215,1 @@\n-    \/\/ Java threads take this lock while they are being attached and added to the list of thread.\n+    \/\/ Java threads take this lock while they are being attached and added to the list of threads.\n@@ -1569,1 +1510,1 @@\n-size_t ShenandoahHeap::unsafe_max_tlab_alloc(Thread *thread) const {\n+size_t ShenandoahHeap::unsafe_max_tlab_alloc() const {\n@@ -1711,1 +1652,1 @@\n-size_t ShenandoahHeap::tlab_capacity(Thread *thr) const {\n+size_t ShenandoahHeap::tlab_capacity() const {\n@@ -2187,1 +2128,1 @@\n-size_t ShenandoahHeap::tlab_used(Thread* thread) const {\n+size_t ShenandoahHeap::tlab_used() const {\n@@ -2350,0 +2291,2 @@\n+  ShenandoahFreeSet* _free_set = free_set();\n+  size_t bytes_allocated = _free_set->get_bytes_allocated_since_gc_start();\n@@ -2351,1 +2294,0 @@\n-    size_t bytes_allocated = young_generation()->bytes_allocated_since_gc_start();\n@@ -2353,3 +2295,0 @@\n-    young_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n-    unaccounted_bytes = 0;\n-    old_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n@@ -2357,1 +2296,0 @@\n-    size_t bytes_allocated = global_generation()->bytes_allocated_since_gc_start();\n@@ -2361,1 +2299,2 @@\n-  global_generation()->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n+  ShenandoahHeapLocker locker(lock());\n+  _free_set->reset_bytes_allocated_since_gc_start(unaccounted_bytes);\n@@ -2422,1 +2361,5 @@\n-void ShenandoahHeap::assert_pinned_region_status() {\n+void ShenandoahHeap::assert_pinned_region_status() const {\n+  assert_pinned_region_status(global_generation());\n+}\n+\n+void ShenandoahHeap::assert_pinned_region_status(ShenandoahGeneration* generation) const {\n@@ -2425,2 +2368,4 @@\n-    assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n-           \"Region %zu pinning status is inconsistent\", i);\n+    if (generation->contains(r)) {\n+      assert((r->is_pinned() && r->pin_count() > 0) || (!r->is_pinned() && r->pin_count() == 0),\n+             \"Region %zu pinning status is inconsistent\", i);\n+    }\n@@ -2740,0 +2685,3 @@\n+  assert(_initial_size <= ShenandoahHeap::heap()->max_capacity(), \"sanity\");\n+  assert(used() <= ShenandoahHeap::heap()->max_capacity(), \"sanity\");\n+  assert(committed() <= ShenandoahHeap::heap()->max_capacity(), \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":40,"deletions":92,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n@@ -186,0 +185,1 @@\n+  virtual void post_initialize_heuristics();\n@@ -215,2 +215,0 @@\n-  void increase_used(const ShenandoahAllocRequest& req);\n-\n@@ -218,5 +216,0 @@\n-  void increase_used(ShenandoahGeneration* generation, size_t bytes);\n-  void decrease_used(ShenandoahGeneration* generation, size_t bytes);\n-  void increase_humongous_waste(ShenandoahGeneration* generation, size_t bytes);\n-  void decrease_humongous_waste(ShenandoahGeneration* generation, size_t bytes);\n-\n@@ -672,1 +665,2 @@\n-  void assert_pinned_region_status() NOT_DEBUG_RETURN;\n+  void assert_pinned_region_status() const NOT_DEBUG_RETURN;\n+  void assert_pinned_region_status(ShenandoahGeneration* generation) const NOT_DEBUG_RETURN;\n@@ -700,2 +694,0 @@\n-  void notify_mutator_alloc_words(size_t words, size_t waste);\n-\n@@ -703,2 +695,2 @@\n-  size_t tlab_capacity(Thread *thr) const override;\n-  size_t unsafe_max_tlab_alloc(Thread *thread) const override;\n+  size_t tlab_capacity() const override;\n+  size_t unsafe_max_tlab_alloc() const override;\n@@ -706,1 +698,1 @@\n-  size_t tlab_used(Thread* ignored) const override;\n+  size_t tlab_used() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -581,0 +581,2 @@\n+\/\/ Upon return, this region has been recycled.  We try to recycle it.\n+\/\/ We may fail if some other thread recycled it before we do.\n@@ -585,6 +587,4 @@\n-      ShenandoahHeap* heap = ShenandoahHeap::heap();\n-      ShenandoahGeneration* generation = heap->generation_for(affiliation());\n-\n-      heap->decrease_used(generation, used());\n-      generation->decrement_affiliated_region_count();\n-\n+      \/\/ At freeset rebuild time, which precedes recycling of collection set, we treat all cset regions as\n+      \/\/ part of capacity, as empty, as fully available, and as unaffiliated.  This provides short-lived optimism\n+      \/\/ for triggering heuristics.  It greatly simplifies and reduces the locking overhead required\n+      \/\/ by more time-precise accounting of these details.\n@@ -611,5 +611,4 @@\n-      ShenandoahHeap* heap = ShenandoahHeap::heap();\n-      ShenandoahGeneration* generation = heap->generation_for(affiliation());\n-      heap->decrease_used(generation, used());\n-      generation->decrement_affiliated_region_count_without_lock();\n-\n+      \/\/ At freeset rebuild time, which precedes recycling of collection set, we treat all cset regions as\n+      \/\/ part of capacity, as empty, as fully available, and as unaffiliated.  This provides short-lived optimism\n+      \/\/ for triggering and pacing heuristics.  It greatly simplifies and reduces the locking overhead required\n+      \/\/ by more time-precise accounting of these details.\n@@ -903,1 +902,1 @@\n-void ShenandoahHeapRegion::decrement_humongous_waste() const {\n+void ShenandoahHeapRegion::decrement_humongous_waste() {\n@@ -908,2 +907,1 @@\n-    ShenandoahGeneration* generation = heap->generation_for(affiliation());\n-    heap->decrease_humongous_waste(generation, waste_bytes);\n+    heap->free_set()->decrease_humongous_waste_for_regular_bypass(this, waste_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -369,0 +369,3 @@\n+  \/\/ Allocate fill after top\n+  inline HeapWord* allocate_fill(size_t word_size);\n+\n@@ -495,1 +498,1 @@\n-  void decrement_humongous_waste() const;\n+  void decrement_humongous_waste();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,0 +90,17 @@\n+HeapWord* ShenandoahHeapRegion::allocate_fill(size_t size) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(is_object_aligned(size), \"alloc size breaks alignment: %zu\", size);\n+  assert(size >= ShenandoahHeap::min_fill_size(), \"Cannot fill unless min fill size\");\n+\n+  HeapWord* obj = top();\n+  HeapWord* new_top = obj + size;\n+  ShenandoahHeap::fill_with_object(obj, size);\n+  set_top(new_top);\n+\n+  assert(is_object_aligned(new_top), \"new top breaks alignment: \" PTR_FORMAT, p2i(new_top));\n+  assert(is_object_aligned(obj),     \"obj is not aligned: \"       PTR_FORMAT, p2i(obj));\n+\n+  return obj;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  typedef size_t idx_t;         \/\/ Type used for bit and word indices.\n+  typedef size_t idx_t;        \/\/ Type used for bit and word indices.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,2 +65,4 @@\n-  assert(used <= committed, \"used: %zu, committed: %zu\", used,      committed);\n-\n+  assert(used <= committed, \"used: %zu, committed: %zu\", used, committed);\n+  assert(initial <= _heap->max_capacity(), \"sanity\");\n+  assert(committed <= _heap->max_capacity(), \"sanity\");\n+  assert(max <= _heap->max_capacity(), \"sanity\");\n@@ -89,0 +91,4 @@\n+  assert(initial <= _heap->max_capacity(), \"sanity\");\n+  assert(used <= _heap->max_capacity(), \"sanity\");\n+  assert(committed <= _heap->max_capacity(), \"sanity\");\n+  assert(max <= _heap->max_capacity(), \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,6 +72,0 @@\n-    \/\/ Believe verification following old-gen concurrent mark needs to be different than verification following\n-    \/\/ young-gen concurrent mark, so am commenting this out for now:\n-    \/\/   if (ShenandoahVerify) {\n-    \/\/     heap->verifier()->verify_after_concmark();\n-    \/\/   }\n-\n@@ -147,2 +141,0 @@\n-  \/\/ We do not rebuild_free following increments of old marking because memory has not been reclaimed. However, we may\n-  \/\/ need to transfer memory to OLD in order to efficiently support the mixed evacuations that might immediately follow.\n@@ -151,12 +143,0 @@\n-\n-  ShenandoahGenerationalHeap::TransferResult result;\n-  {\n-    ShenandoahHeapLocker locker(heap->lock());\n-    result = heap->balance_generations();\n-  }\n-\n-  LogTarget(Info, gc, ergo) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    result.print_on(\"Old Mark\", &ls);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -198,2 +199,2 @@\n-ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity)\n-  : ShenandoahGeneration(OLD, max_queues, max_capacity),\n+ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues)\n+  : ShenandoahGeneration(OLD, max_queues),\n@@ -217,0 +218,1 @@\n+  assert(type() == ShenandoahGenerationType::OLD, \"OO sanity\");\n@@ -306,0 +308,2 @@\n+        log_debug(gc, plab)(\"Thread can promote using PLAB of %zu bytes. Expended: %zu, available: %zu\",\n+                            actual_size, get_promoted_expended(), get_promoted_reserve());\n@@ -313,0 +317,2 @@\n+        log_debug(gc, plab)(\"Thread cannot promote using PLAB of %zu bytes. Expended: %zu, available: %zu, mixed evacuations? %s\",\n+                            actual_size, get_promoted_expended(), get_promoted_reserve(), BOOL_TO_STR(ShenandoahHeap::heap()->collection_set()->has_old_regions()));\n@@ -316,0 +322,1 @@\n+      log_debug(gc, plab)(\"Expend shared promotion of %zu bytes\", actual_size);\n@@ -497,1 +504,1 @@\n-    heap->assert_pinned_region_status();\n+    heap->assert_pinned_region_status(this);\n@@ -517,1 +524,1 @@\n-    size_t cset_young_regions, cset_old_regions;\n+    size_t young_trash_regions, old_trash_regions;\n@@ -519,4 +526,12 @@\n-    heap->free_set()->prepare_to_rebuild(cset_young_regions, cset_old_regions, first_old, last_old, num_old);\n-    \/\/ This is just old-gen completion.  No future budgeting required here.  The only reason to rebuild the freeset here\n-    \/\/ is in case there was any immediate old garbage identified.\n-    heap->free_set()->finish_rebuild(cset_young_regions, cset_old_regions, num_old);\n+    heap->free_set()->prepare_to_rebuild(young_trash_regions, old_trash_regions, first_old, last_old, num_old);\n+    \/\/ At the end of old-gen, we may find that we have reclaimed immediate garbage, allowing a longer allocation runway.\n+    \/\/ We may also find that we have accumulated canddiate regions for mixed evacuation.  If so, we will want to expand\n+    \/\/ the OldCollector reserve in order to make room for these mixed evacuations.\n+    assert(ShenandoahHeap::heap()->mode()->is_generational(), \"sanity\");\n+    assert(young_trash_regions == 0, \"sanity\");\n+    ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+    size_t allocation_runway =\n+      gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_trash_regions);\n+    gen_heap->compute_old_generation_balance(allocation_runway, old_trash_regions);\n+\n+    heap->free_set()->finish_rebuild(young_trash_regions, old_trash_regions, num_old);\n@@ -727,5 +742,0 @@\n-\n-  if (promotion) {\n-    \/\/ This evacuation was a promotion, track this as allocation against old gen\n-    increase_allocated(words * HeapWordSize);\n-  }\n@@ -837,0 +847,35 @@\n+\n+size_t ShenandoahOldGeneration::used() const {\n+  return _free_set->old_used();\n+}\n+\n+size_t ShenandoahOldGeneration::bytes_allocated_since_gc_start() const {\n+  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"NON_GEN implies not generational\");\n+  return 0;\n+}\n+\n+size_t ShenandoahOldGeneration::get_affiliated_region_count() const {\n+  return _free_set->old_affiliated_regions();\n+}\n+\n+size_t ShenandoahOldGeneration::get_humongous_waste() const {\n+  return _free_set->humongous_waste_in_old();\n+}\n+\n+size_t ShenandoahOldGeneration::used_regions() const {\n+  return _free_set->old_affiliated_regions();\n+}\n+\n+size_t ShenandoahOldGeneration::used_regions_size() const {\n+  size_t used_regions = _free_set->old_affiliated_regions();\n+  return used_regions * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahOldGeneration::max_capacity() const {\n+  size_t total_regions = _free_set->total_old_regions();\n+  return total_regions * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahOldGeneration::free_unaffiliated_regions() const {\n+  return _free_set->old_unaffiliated_regions();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":58,"deletions":13,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  ShenandoahOldGeneration(uint max_queues, size_t max_capacity);\n+  ShenandoahOldGeneration(uint max_queues);\n@@ -148,1 +148,3 @@\n-  void set_region_balance(ssize_t balance) { _region_balance = balance; }\n+  void set_region_balance(ssize_t balance) {\n+    _region_balance = balance;\n+  }\n@@ -334,0 +336,8 @@\n+  size_t bytes_allocated_since_gc_start() const override;\n+  size_t used() const override;\n+  size_t used_regions() const override;\n+  size_t used_regions_size() const override;\n+  size_t get_humongous_waste() const override;\n+  size_t free_unaffiliated_regions() const override;\n+  size_t get_affiliated_region_count() const override;\n+  size_t max_capacity() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-ShenandoahReferenceProcessor::ShenandoahReferenceProcessor(uint max_workers) :\n+ShenandoahReferenceProcessor::ShenandoahReferenceProcessor(ShenandoahGeneration* generation, uint max_workers) :\n@@ -232,1 +232,1 @@\n-  _stats() {\n+  _generation(generation) {\n@@ -314,1 +314,1 @@\n-  if (!heap->is_in_active_generation(referent)) {\n+  if (!_generation->contains(referent)) {\n@@ -332,2 +332,0 @@\n-  shenandoah_assert_mark_complete(raw_referent);\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -336,1 +334,1 @@\n-    return heap->marking_context()->is_marked(raw_referent);\n+    return _generation->complete_marking_context()->is_marked(raw_referent);\n@@ -338,1 +336,1 @@\n-    return heap->marking_context()->is_marked_strong(raw_referent);\n+    return _generation->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -345,8 +343,0 @@\n-#ifdef ASSERT\n-    auto referent = reference_referent_raw<T>(reference);\n-    auto heap = ShenandoahHeap::heap();\n-    shenandoah_assert_mark_complete(referent);\n-    assert(reference_next<T>(reference) == nullptr, \"Already inactive\");\n-    assert(heap->marking_context()->is_marked(referent), \"only make inactive final refs with alive referents\");\n-#endif\n-\n@@ -357,0 +347,2 @@\n+    assert(reference_next<T>(reference) == nullptr, \"Already inactive\");\n+    assert(_generation->complete_marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -446,6 +438,2 @@\n-  if (raw_referent != nullptr) {\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    ShenandoahHeapRegion* region  = heap->heap_region_containing(raw_referent);\n-    ShenandoahMarkingContext* ctx = heap->generation_for(region->affiliation())->complete_marking_context();\n-    assert(ctx->is_marked(raw_referent), \"only drop references with alive referents\");\n-  }\n+  assert(raw_referent == nullptr || _generation->complete_marking_context()->is_marked(raw_referent),\n+         \"only drop references with alive referents\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -143,0 +143,2 @@\n+  ShenandoahGeneration* _generation;\n+\n@@ -175,1 +177,1 @@\n-  ShenandoahReferenceProcessor(uint max_workers);\n+  ShenandoahReferenceProcessor(ShenandoahGeneration* generation, uint max_workers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-ShenandoahSimpleBitMap::ShenandoahSimpleBitMap(size_t num_bits) :\n+ShenandoahSimpleBitMap::ShenandoahSimpleBitMap(idx_t num_bits) :\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/cstddef.hpp\"\n@@ -30,2 +31,0 @@\n-#include <cstddef>\n-\n@@ -45,1 +44,1 @@\n-\/\/  2. Certain loops are written most naturally if the iterator, which may hold the sentinel -1 value, can be\n+\/\/  2. Certain loops are written most naturally if the induction variable, which may hold the sentinel -1 value, can be\n@@ -48,2 +47,0 @@\n-typedef ssize_t idx_t;\n-\n@@ -55,0 +52,3 @@\n+public:\n+  typedef ssize_t idx_t;\n+private:\n@@ -60,1 +60,1 @@\n-  ShenandoahSimpleBitMap(size_t num_bits);\n+  ShenandoahSimpleBitMap(idx_t num_bits);\n@@ -119,1 +119,0 @@\n-    assert(idx >= 0, \"precondition\");\n@@ -128,1 +127,0 @@\n-    assert(idx >= 0, \"precondition\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+using idx_t = ShenandoahSimpleBitMap::idx_t;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSimpleBitMap.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-    e.set_collectedOld(cset->get_old_bytes_reserved_for_evacuation());\n-    e.set_collectedPromoted(cset->get_young_bytes_to_be_promoted());\n-    e.set_collectedYoung(cset->get_young_bytes_reserved_for_evacuation());\n+    e.set_collectedOld(cset->get_live_bytes_in_old_regions());\n+    e.set_collectedPromoted(cset->get_live_bytes_in_tenurable_regions());\n+    e.set_collectedYoung(cset->get_live_bytes_in_untenurable_regions());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTrace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -368,1 +368,2 @@\n-  size_t _used, _committed, _garbage, _regions, _humongous_waste, _trashed_regions;\n+  size_t _used, _committed, _garbage, _regions, _humongous_waste, _trashed_regions, _trashed_used;\n+  size_t _region_size_bytes, _min_free_size;\n@@ -371,1 +372,6 @@\n-      _used(0), _committed(0), _garbage(0), _regions(0), _humongous_waste(0), _trashed_regions(0) {};\n+     _used(0), _committed(0), _garbage(0), _regions(0), _humongous_waste(0), _trashed_regions(0), _trashed_used(0)\n+  {\n+    _region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+    \/\/ Retired regions are not necessarily filled, thouugh their remnant memory is considered used.\n+    _min_free_size = PLAB::min_size() * HeapWordSize;\n+  };\n@@ -374,8 +380,26 @@\n-    _used += r->used();\n-    _garbage += r->garbage();\n-    _committed += r->is_committed() ? ShenandoahHeapRegion::region_size_bytes() : 0;\n-    if (r->is_humongous()) {\n-      _humongous_waste += r->free();\n-    }\n-    if (r->is_trash()) {\n-      _trashed_regions++;\n+    if (r->is_cset() || r->is_trash()) {\n+      \/\/ Count the entire cset or trashed (formerly cset) region as used\n+      \/\/ Note: Immediate garbage trash regions were never in the cset.\n+      _used += _region_size_bytes;\n+      _garbage += _region_size_bytes - r->get_live_data_bytes();\n+      if (r->is_trash()) {\n+        _trashed_regions++;\n+        _trashed_used += _region_size_bytes;\n+      }\n+    } else {\n+      if (r->is_humongous()) {\n+        _used += _region_size_bytes;\n+        _garbage += _region_size_bytes - r->get_live_data_bytes();\n+        _humongous_waste += r->free();\n+      } else {\n+        size_t alloc_capacity = r->free();\n+        if (alloc_capacity < _min_free_size) {\n+          \/\/ this region has been retired already, count it as entirely consumed\n+          alloc_capacity = 0;\n+        }\n+        size_t bytes_used_in_region = _region_size_bytes - alloc_capacity;\n+        size_t bytes_garbage_in_region = bytes_used_in_region - r->get_live_data_bytes();\n+        size_t waste_bytes = r->free();\n+        _used += bytes_used_in_region;\n+        _garbage += bytes_garbage_in_region;\n+      }\n@@ -383,0 +407,1 @@\n+    _committed += r->is_committed() ? _region_size_bytes : 0;\n@@ -389,0 +414,1 @@\n+  size_t used_after_recycle() const { return _used - _trashed_used; }\n@@ -392,0 +418,1 @@\n+  size_t trashed_regions() const { return _trashed_regions; }\n@@ -401,3 +428,3 @@\n-  ShenandoahCalculateRegionStatsClosure old;\n-  ShenandoahCalculateRegionStatsClosure young;\n-  ShenandoahCalculateRegionStatsClosure global;\n+  ShenandoahCalculateRegionStatsClosure _old;\n+  ShenandoahCalculateRegionStatsClosure _young;\n+  ShenandoahCalculateRegionStatsClosure _global;\n@@ -410,2 +437,2 @@\n-        young.heap_region_do(r);\n-        global.heap_region_do(r);\n+        _young.heap_region_do(r);\n+        _global.heap_region_do(r);\n@@ -414,2 +441,2 @@\n-        old.heap_region_do(r);\n-        global.heap_region_do(r);\n+        _old.heap_region_do(r);\n+        _global.heap_region_do(r);\n@@ -429,1 +456,1 @@\n-  static void validate_usage(const bool adjust_for_padding,\n+  static void validate_usage(const bool adjust_for_padding, const bool adjust_for_trash,\n@@ -434,4 +461,0 @@\n-    if (adjust_for_padding && (generation->is_young() || generation->is_global())) {\n-      size_t pad = heap->old_generation()->get_pad_for_promote_in_place();\n-      generation_used += pad;\n-    }\n@@ -439,1 +462,2 @@\n-    guarantee(stats.used() == generation_used,\n+    size_t stats_used = adjust_for_trash? stats.used_after_recycle(): stats.used();\n+    guarantee(stats_used == generation_used,\n@@ -441,1 +465,1 @@\n-              label, generation->name(), PROPERFMTARGS(generation_used), PROPERFMTARGS(stats.used()));\n+              label, generation->name(), PROPERFMTARGS(generation_used), PROPERFMTARGS(stats_used));\n@@ -443,3 +467,5 @@\n-    guarantee(stats.regions() == generation_used_regions,\n-              \"%s: generation (%s) used regions (%zu) must equal regions that are in use (%zu)\",\n-              label, generation->name(), generation->used_regions(), stats.regions());\n+    size_t stats_regions = adjust_for_trash? stats.regions() - stats.trashed_regions(): stats.regions();\n+    guarantee(stats_regions == generation_used_regions,\n+              \"%s: generation (%s) used regions (%zu) must equal regions that are in use (%zu)%s\",\n+              label, generation->name(), generation->used_regions(), stats_regions,\n+              adjust_for_trash? \" (after adjusting for trash)\": \"\");\n@@ -466,1 +492,1 @@\n-public:\n+  public:\n@@ -468,3 +494,3 @@\n-    _heap(ShenandoahHeap::heap()),\n-    _phase(phase),\n-    _regions(regions) {};\n+      _heap(ShenandoahHeap::heap()),\n+      _phase(phase),\n+      _regions(regions) {};\n@@ -623,1 +649,1 @@\n-public:\n+  public:\n@@ -633,1 +659,1 @@\n-private:\n+  private:\n@@ -763,1 +789,1 @@\n-         char const _expected;\n+  char const _expected;\n@@ -867,1 +893,2 @@\n-      heap_used = _heap->used() + _heap->old_generation()->get_pad_for_promote_in_place();\n+      \/\/ but this padding is already represented in _heap->used()\n+      heap_used = _heap->used();\n@@ -872,1 +899,2 @@\n-      guarantee(cl.used() == heap_used,\n+      size_t cl_size = (sizeness == _verify_size_exact_including_trash)? cl.used(): cl.used_after_recycle();\n+      guarantee(cl_size == heap_used,\n@@ -876,1 +904,1 @@\n-                byte_size_in_proper_unit(cl.used()), proper_unit_for_byte_size(cl.used()));\n+                byte_size_in_proper_unit(cl_size), proper_unit_for_byte_size(cl_size));\n@@ -914,3 +942,3 @@\n-      ShenandoahGenerationStatsClosure::log_usage(_heap->old_generation(),    cl.old);\n-      ShenandoahGenerationStatsClosure::log_usage(_heap->young_generation(),  cl.young);\n-      ShenandoahGenerationStatsClosure::log_usage(_heap->global_generation(), cl.global);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->old_generation(),    cl._old);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->young_generation(),  cl._young);\n+      ShenandoahGenerationStatsClosure::log_usage(_heap->global_generation(), cl._global);\n@@ -919,7 +947,8 @@\n-      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->old_generation(), cl.old);\n-      ShenandoahGenerationStatsClosure::validate_usage(true, label, _heap->young_generation(), cl.young);\n-      ShenandoahGenerationStatsClosure::validate_usage(true, label, _heap->global_generation(), cl.global);\n-    } else if (sizeness == _verify_size_exact) {\n-      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->old_generation(), cl.old);\n-      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->young_generation(), cl.young);\n-      ShenandoahGenerationStatsClosure::validate_usage(false, label, _heap->global_generation(), cl.global);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, true, label, _heap->old_generation(), cl._old);\n+      ShenandoahGenerationStatsClosure::validate_usage(true, true, label, _heap->young_generation(), cl._young);\n+      ShenandoahGenerationStatsClosure::validate_usage(true, true, label, _heap->global_generation(), cl._global);\n+    } else if (sizeness == _verify_size_exact || sizeness == _verify_size_exact_including_trash) {\n+      bool adjust_trash = (sizeness == _verify_size_exact);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, adjust_trash, label, _heap->old_generation(), cl._old);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, adjust_trash, label, _heap->young_generation(), cl._young);\n+      ShenandoahGenerationStatsClosure::validate_usage(false, adjust_trash, label, _heap->global_generation(), cl._global);\n@@ -1142,1 +1171,2 @@\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n+                                       \/\/ expect generation and heap sizes to match exactly, including trash\n+          _verify_size_exact_including_trash,\n@@ -1408,3 +1438,3 @@\n-  ShenandoahGenerationStatsClosure::validate_usage(false, \"Before free set rebuild\", _heap->old_generation(), cl.old);\n-  ShenandoahGenerationStatsClosure::validate_usage(false, \"Before free set rebuild\", _heap->young_generation(), cl.young);\n-  ShenandoahGenerationStatsClosure::validate_usage(false, \"Before free set rebuild\", _heap->global_generation(), cl.global);\n+  ShenandoahGenerationStatsClosure::validate_usage(false, true, \"Before free set rebuild\", _heap->old_generation(), cl._old);\n+  ShenandoahGenerationStatsClosure::validate_usage(false, true, \"Before free set rebuild\", _heap->young_generation(), cl._young);\n+  ShenandoahGenerationStatsClosure::validate_usage(false, true, \"Before free set rebuild\", _heap->global_generation(), cl._global);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":81,"deletions":51,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -158,1 +158,4 @@\n-    _verify_size_adjusted_for_padding\n+    _verify_size_adjusted_for_padding,\n+\n+    \/\/ Expected heap size should not include\n+    _verify_size_exact_including_trash\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity) :\n-  ShenandoahGeneration(YOUNG, max_queues, max_capacity),\n+ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues) :\n+  ShenandoahGeneration(YOUNG, max_queues),\n@@ -36,0 +36,1 @@\n+  assert(type() == ShenandoahGenerationType::YOUNG, \"OO sanity\");\n@@ -98,0 +99,35 @@\n+size_t ShenandoahYoungGeneration::used() const {\n+  return _free_set->young_used();\n+}\n+\n+size_t ShenandoahYoungGeneration::bytes_allocated_since_gc_start() const {\n+  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Young implies generational\");\n+  return _free_set->get_bytes_allocated_since_gc_start();\n+}\n+\n+size_t ShenandoahYoungGeneration::get_affiliated_region_count() const {\n+  return _free_set->young_affiliated_regions();\n+}\n+\n+size_t ShenandoahYoungGeneration::get_humongous_waste() const {\n+  return _free_set->humongous_waste_in_mutator();\n+}\n+\n+size_t ShenandoahYoungGeneration::used_regions() const {\n+  return _free_set->young_affiliated_regions();\n+}\n+\n+size_t ShenandoahYoungGeneration::used_regions_size() const {\n+  size_t used_regions = _free_set->young_affiliated_regions();\n+  return used_regions * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahYoungGeneration::max_capacity() const {\n+  size_t total_regions = _free_set->total_young_regions();\n+  return total_regions * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahYoungGeneration::free_unaffiliated_regions() const {\n+  return _free_set->young_unaffiliated_regions();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity);\n+  ShenandoahYoungGeneration(uint max_queues);\n@@ -76,3 +76,8 @@\n-  size_t available() const override;\n-\n-  \/\/ Do not override available_with_reserve() because that needs to see memory reserved for Collector\n+  size_t bytes_allocated_since_gc_start() const override;\n+  size_t used() const override;\n+  size_t used_regions() const override;\n+  size_t used_regions_size() const override;\n+  size_t get_humongous_waste() const override;\n+  size_t free_unaffiliated_regions() const override;\n+  size_t get_affiliated_region_count() const override;\n+  size_t max_capacity() const override;\n@@ -80,0 +85,1 @@\n+  size_t available() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -390,7 +390,7 @@\n-          \"expressed as a percentage. The default value 75 denotes that no\" \\\n-          \"more than 75% of the collection set evacuation workload may be \" \\\n-          \"towards evacuation of old-gen heap regions. This limits both the\"\\\n-          \"promotion of aged regions and the compaction of existing old \"   \\\n-          \"regions.  A value of 75 denotes that the total evacuation work\"  \\\n-          \"may increase to up to four times the young gen evacuation work.\" \\\n-          \"A larger value allows quicker promotion and allows\"              \\\n+          \"expressed as a percentage. The default value 75 denotes that \"   \\\n+          \"no more than 75% of the collection set evacuation workload may \" \\\n+          \"be towards evacuation of old-gen heap regions. This limits both \"\\\n+          \"the promotion of aged regions and the compaction of existing \"   \\\n+          \"old regions. A value of 75 denotes that the total evacuation \"   \\\n+          \"work may increase to up to four times the young gen evacuation \" \\\n+          \"work. A larger value allows quicker promotion and allows \"       \\\n@@ -404,1 +404,1 @@\n-          \"replenished.  A value of 0 allows a mixed evacuation to\"         \\\n+          \"replenished.  A value of 0 allows a mixed evacuation to \"        \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  nonstatic_field(ShenandoahHeap, _global_generation,              ShenandoahGeneration*)             \\\n+  nonstatic_field(ShenandoahHeap, _free_set,                       ShenandoahFreeSet*)                \\\n@@ -39,1 +39,0 @@\n-  volatile_nonstatic_field(ShenandoahGeneration, _used,            size_t)                            \\\n@@ -47,0 +46,1 @@\n+  nonstatic_field(ShenandoahFreeSet, _total_global_used,           size_t)                            \\\n@@ -69,2 +69,2 @@\n-  declare_toplevel_type(ShenandoahGeneration)                                 \\\n-  declare_toplevel_type(ShenandoahGeneration*)                                \\\n+  declare_toplevel_type(ShenandoahFreeSet)                                    \\\n+  declare_toplevel_type(ShenandoahFreeSet*)                                   \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/vmStructs_shenandoah.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -41,2 +42,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-size_t ZCollectedHeap::tlab_capacity(Thread* ignored) const {\n+size_t ZCollectedHeap::tlab_capacity() const {\n@@ -229,1 +229,1 @@\n-size_t ZCollectedHeap::tlab_used(Thread* ignored) const {\n+size_t ZCollectedHeap::tlab_used() const {\n@@ -237,1 +237,1 @@\n-size_t ZCollectedHeap::unsafe_max_tlab_alloc(Thread* ignored) const {\n+size_t ZCollectedHeap::unsafe_max_tlab_alloc() const {\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-  size_t tlab_capacity(Thread* thr) const override;\n-  size_t tlab_used(Thread* thr) const override;\n+  size_t tlab_capacity() const override;\n+  size_t tlab_used() const override;\n@@ -89,1 +89,1 @@\n-  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  size_t unsafe_max_tlab_alloc() const override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n+\n@@ -31,1 +33,0 @@\n-#include <type_traits>\n","filename":"src\/hotspot\/share\/gc\/z\/zDeferredConstructed.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -35,2 +36,0 @@\n-#include <limits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingEntry.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/cstddef.hpp\"\n@@ -30,2 +31,0 @@\n-#include <cstddef>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zInitialize.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAge.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -35,2 +36,0 @@\n-#include <limits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -29,2 +30,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zSafeDelete.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zSafeDelete.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -49,2 +50,0 @@\n-#include <limits>\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-  klass->initialize(CHECK);\n+  klass->initialize_preemptable(CHECK_AND_CLEAR_PREEMPTED);\n@@ -726,1 +726,2 @@\n-void InterpreterRuntime::resolve_get_put(JavaThread* current, Bytecodes::Code bytecode) {\n+void InterpreterRuntime::resolve_get_put(Bytecodes::Code bytecode, TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -731,1 +732,1 @@\n-  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, true \/*initialize_holder*\/, current);\n+  resolve_get_put(bytecode, last_frame.get_index_u2(bytecode), m, pool, ClassInitMode::init_preemptable, THREAD);\n@@ -737,1 +738,1 @@\n-                                         bool initialize_holder, TRAPS) {\n+                                         ClassInitMode init_mode, TRAPS) {\n@@ -745,2 +746,1 @@\n-    LinkResolver::resolve_field_access(info, pool, field_index,\n-                                       m, bytecode, initialize_holder, CHECK);\n+    LinkResolver::resolve_field_access(info, pool, field_index, m, bytecode, init_mode, CHECK);\n@@ -904,1 +904,2 @@\n-void InterpreterRuntime::resolve_invoke(JavaThread* current, Bytecodes::Code bytecode) {\n+void InterpreterRuntime::resolve_invoke(Bytecodes::Code bytecode, TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -932,1 +933,0 @@\n-    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -935,1 +935,1 @@\n-                                 THREAD);\n+                                 ClassInitMode::init_preemptable, THREAD);\n@@ -1043,1 +1043,2 @@\n-void InterpreterRuntime::resolve_invokehandle(JavaThread* current) {\n+void InterpreterRuntime::resolve_invokehandle(TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -1072,1 +1073,2 @@\n-void InterpreterRuntime::resolve_invokedynamic(JavaThread* current) {\n+void InterpreterRuntime::resolve_invokedynamic(TRAPS) {\n+  JavaThread* current = THREAD;\n@@ -1107,1 +1109,1 @@\n-    resolve_get_put(current, bytecode);\n+    resolve_get_put(bytecode, CHECK_AND_CLEAR_PREEMPTED);\n@@ -1113,1 +1115,1 @@\n-    resolve_invoke(current, bytecode);\n+    resolve_invoke(bytecode, CHECK_AND_CLEAR_PREEMPTED);\n@@ -1116,1 +1118,1 @@\n-    resolve_invokehandle(current);\n+    resolve_invokehandle(THREAD);\n@@ -1119,1 +1121,1 @@\n-    resolve_invokedynamic(current);\n+    resolve_invokedynamic(THREAD);\n@@ -1639,0 +1641,8 @@\n+\n+#ifdef ASSERT\n+bool InterpreterRuntime::is_preemptable_call(address entry_point) {\n+  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter) ||\n+         entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache) ||\n+         entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::_new);\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                              methodHandle& m, constantPoolHandle& pool, bool initialize_holder, TRAPS);\n+                              methodHandle& m, constantPoolHandle& pool, ClassInitMode init_mode, TRAPS);\n@@ -115,1 +115,1 @@\n-  static void resolve_get_put(JavaThread* current, Bytecodes::Code bytecode);\n+  static void resolve_get_put(Bytecodes::Code bytecode, TRAPS);\n@@ -118,3 +118,3 @@\n-  static void resolve_invoke(JavaThread* current, Bytecodes::Code bytecode);\n-  static void resolve_invokehandle (JavaThread* current);\n-  static void resolve_invokedynamic(JavaThread* current);\n+  static void resolve_invoke(Bytecodes::Code bytecode, TRAPS);\n+  static void resolve_invokehandle (TRAPS);\n+  static void resolve_invokedynamic(TRAPS);\n@@ -183,0 +183,3 @@\n+\n+  \/\/ Virtual Thread Preemption\n+  DEBUG_ONLY(static bool is_preemptable_call(address entry_point);)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -989,1 +989,1 @@\n-                                        bool initialize_class, TRAPS) {\n+                                        ClassInitMode init_mode, TRAPS) {\n@@ -991,1 +991,1 @@\n-  resolve_field(fd, link_info, byte, initialize_class, CHECK);\n+  resolve_field(fd, link_info, byte, init_mode, CHECK);\n@@ -996,1 +996,1 @@\n-                                 Bytecodes::Code byte, bool initialize_class,\n+                                 Bytecodes::Code byte, ClassInitMode init_mode,\n@@ -1081,2 +1081,6 @@\n-    if (is_static && initialize_class) {\n-      sel_klass->initialize(CHECK);\n+    if (is_static) {\n+      if (init_mode == ClassInitMode::init) {\n+        sel_klass->initialize(CHECK);\n+      } else if (init_mode == ClassInitMode::init_preemptable) {\n+        sel_klass->initialize_preemptable(CHECK);\n+      }\n@@ -1108,1 +1112,1 @@\n-                                       bool initialize_class, TRAPS) {\n+                                       ClassInitMode init_mode, TRAPS) {\n@@ -1115,2 +1119,6 @@\n-  if (initialize_class && resolved_klass->should_be_initialized()) {\n-    resolved_klass->initialize(CHECK);\n+  if (init_mode != ClassInitMode::dont_init && resolved_klass->should_be_initialized()) {\n+    if (init_mode == ClassInitMode::init) {\n+      resolved_klass->initialize(CHECK);\n+    } else if (init_mode == ClassInitMode::init_preemptable) {\n+      resolved_klass->initialize_preemptable(CHECK);\n+    }\n@@ -1131,1 +1139,1 @@\n-  resolve_static_call(result, link_info, \/*initialize_class*\/false, CHECK);\n+  resolve_static_call(result, link_info, ClassInitMode::dont_init, CHECK);\n@@ -1684,1 +1692,1 @@\n-  resolve_static_call(info, link_info, \/*initialize_class*\/false, THREAD);\n+  resolve_static_call(info, link_info, ClassInitMode::dont_init, THREAD);\n@@ -1708,1 +1716,1 @@\n-void LinkResolver::resolve_invoke(CallInfo& result, Handle recv, const constantPoolHandle& pool, int index, Bytecodes::Code byte, TRAPS) {\n+void LinkResolver::resolve_invoke(CallInfo& result, Handle recv, const constantPoolHandle& pool, int index, Bytecodes::Code byte, ClassInitMode init_mode, TRAPS) {\n@@ -1710,7 +1718,7 @@\n-    case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;\n-    case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;\n-    case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;\n-    case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;\n-    case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;\n-    case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;\n-    default                         :                                                            break;\n+    case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, init_mode, CHECK); break;\n+    case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index,            CHECK); break;\n+    case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index,            CHECK); break;\n+    case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index,            CHECK); break;\n+    case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index,            CHECK); break;\n+    case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index,            CHECK); break;\n+    default                         :                                                                       break;\n@@ -1739,1 +1747,1 @@\n-      resolve_static_call(result, link_info, \/*initialize_class=*\/false, CHECK);\n+      resolve_static_call(result, link_info, ClassInitMode::dont_init, CHECK);\n@@ -1750,1 +1758,1 @@\n-void LinkResolver::resolve_invokestatic(CallInfo& result, const constantPoolHandle& pool, int index, TRAPS) {\n+void LinkResolver::resolve_invokestatic(CallInfo& result, const constantPoolHandle& pool, int index, ClassInitMode init_mode, TRAPS) {\n@@ -1752,1 +1760,1 @@\n-  resolve_static_call(result, link_info, \/*initialize_class*\/true, CHECK);\n+  resolve_static_call(result, link_info, init_mode, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -192,0 +192,6 @@\n+enum class ClassInitMode {\n+  dont_init,\n+  init,\n+  init_preemptable\n+};\n+\n@@ -270,1 +276,1 @@\n-                                      const constantPoolHandle& pool, int index, TRAPS);\n+                                      const constantPoolHandle& pool, int index, ClassInitMode mode, TRAPS);\n@@ -298,1 +304,1 @@\n-                                   bool initialize_class, TRAPS);\n+                                   ClassInitMode mode, TRAPS);\n@@ -304,2 +310,1 @@\n-    resolve_field_access(result, pool, index, method, byte,\n-                         \/* initialize_class*\/true, THREAD);\n+    resolve_field_access(result, pool, index, method, byte, ClassInitMode::init, THREAD);\n@@ -309,1 +314,1 @@\n-                            bool initialize_class, TRAPS);\n+                            ClassInitMode mode, TRAPS);\n@@ -313,1 +318,1 @@\n-                                     bool initialize_klass, TRAPS);\n+                                     ClassInitMode mode, TRAPS);\n@@ -356,1 +361,6 @@\n-                             Bytecodes::Code byte, TRAPS);\n+                             Bytecodes::Code byte, ClassInitMode static_mode, TRAPS);\n+  static void resolve_invoke(CallInfo& result, Handle recv,\n+                             const constantPoolHandle& pool, int index,\n+                             Bytecodes::Code byte, TRAPS) {\n+    resolve_invoke(result, recv, pool, index, byte, ClassInitMode::init, THREAD);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1011,1 +1011,1 @@\n-  LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_NULL);\n+  LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), ClassInitMode::dont_init, CHECK_NULL);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -34,2 +35,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/counters.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -38,2 +39,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -245,0 +245,1 @@\n+static BuiltinException _preempted_exception;\n@@ -265,0 +266,1 @@\n+oop Universe::preempted_exception_instance()      { return _preempted_exception.instance(); }\n@@ -324,0 +326,1 @@\n+  _preempted_exception.store_in_cds();\n@@ -343,0 +346,1 @@\n+    _preempted_exception.load_from_cds();\n@@ -362,0 +366,1 @@\n+  _preempted_exception.serialize(f);\n@@ -1164,0 +1169,1 @@\n+  _preempted_exception.init_if_empty(vmSymbols::jdk_internal_vm_PreemptedException(), CHECK_false);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+  static oop          preempted_exception_instance();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include <type_traits>\n+#include \"cppstdlib\/type_traits.hpp\"\n","filename":"src\/hotspot\/share\/metaprogramming\/enableIf.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -32,2 +33,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/metaprogramming\/primitiveConversions.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -30,2 +31,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -32,2 +33,0 @@\n-#include <limits>\n-\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-        FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n+        FOR_EACH_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n@@ -251,1 +251,1 @@\n-        FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n+        FOR_EACH_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n","filename":"src\/hotspot\/share\/oops\/access.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -38,2 +39,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -38,2 +39,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -32,2 +33,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/accessDecorators.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -869,1 +869,1 @@\n-\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n+\/\/ Set the initialization lock to null so the object can be GC'ed. Any racing\n@@ -872,1 +872,2 @@\n-\/\/ the lock and return.\n+\/\/ the lock and return. For preempted vthreads we keep the oop protected\n+\/\/ in the ObjectMonitor (see ObjectMonitor::set_object_strong()).\n@@ -880,0 +881,25 @@\n+class PreemptableInitCall {\n+  JavaThread* _thread;\n+  bool _previous;\n+  DEBUG_ONLY(InstanceKlass* _previous_klass;)\n+ public:\n+  PreemptableInitCall(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _previous = thread->at_preemptable_init();\n+    _thread->set_at_preemptable_init(true);\n+    DEBUG_ONLY(_previous_klass = _thread->preempt_init_klass();)\n+    DEBUG_ONLY(_thread->set_preempt_init_klass(ik));\n+  }\n+  ~PreemptableInitCall() {\n+    _thread->set_at_preemptable_init(_previous);\n+    DEBUG_ONLY(_thread->set_preempt_init_klass(_previous_klass));\n+  }\n+};\n+\n+void InstanceKlass::initialize_preemptable(TRAPS) {\n+  if (this->should_be_initialized()) {\n+    PreemptableInitCall pic(THREAD, this);\n+    initialize_impl(THREAD);\n+  } else {\n+    assert(is_initialized(), \"sanity check\");\n+  }\n+}\n@@ -1101,1 +1127,6 @@\n-    ObjectLocker ol(h_init_lock, jt);\n+    ObjectLocker ol(h_init_lock, CHECK_PREEMPTABLE_false);\n+    \/\/ Don't allow preemption if we link\/initialize classes below,\n+    \/\/ since that would release this monitor while we are in the\n+    \/\/ middle of linking this class.\n+    NoPreemptMark npm(THREAD);\n+\n@@ -1295,0 +1326,11 @@\n+class ThreadWaitingForClassInit : public StackObj {\n+  JavaThread* _thread;\n+ public:\n+  ThreadWaitingForClassInit(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _thread->set_class_to_be_initialized(ik);\n+  }\n+  ~ThreadWaitingForClassInit() {\n+    _thread->set_class_to_be_initialized(nullptr);\n+  }\n+};\n+\n@@ -1314,1 +1356,1 @@\n-    ObjectLocker ol(h_init_lock, jt);\n+    ObjectLocker ol(h_init_lock, CHECK_PREEMPTABLE);\n@@ -1327,3 +1369,2 @@\n-      jt->set_class_to_be_initialized(this);\n-      ol.wait_uninterruptibly(jt);\n-      jt->set_class_to_be_initialized(nullptr);\n+      ThreadWaitingForClassInit twcl(THREAD, this);\n+      ol.wait_uninterruptibly(CHECK_PREEMPTABLE);\n@@ -1387,0 +1428,4 @@\n+  \/\/ Block preemption once we are the initializer thread. Unmounting now\n+  \/\/ would complicate the reentrant case (identity is platform thread).\n+  NoPreemptMark npm(THREAD);\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":52,"deletions":7,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -640,0 +640,1 @@\n+  void initialize_preemptable(TRAPS);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -30,2 +31,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/instanceOop.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -198,1 +198,2 @@\n-  const RegisterMap* get_map(const SmallRegisterMap* map, intptr_t* sp) { return map->copy_to_RegisterMap(&_map, sp); }\n+  template <typename SmallRegisterMapT>\n+  const RegisterMap* get_map(const SmallRegisterMapT map, intptr_t* sp) { return map->copy_to_RegisterMap(&_map, sp); }\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -255,0 +255,4 @@\n+void Klass::initialize_preemptable(TRAPS) {\n+  ShouldNotReachHere();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -605,0 +605,1 @@\n+  virtual void initialize_preemptable(TRAPS);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"layoutKind.hpp\"\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -35,2 +36,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -39,2 +40,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/oopHandle.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-      _f.oops_interpreted_do(cl, nullptr);\n+      _f.oops_interpreted_do(cl, _map);\n@@ -142,1 +142,1 @@\n-       f.next(SmallRegisterMap::instance())) {\n+       f.next(SmallRegisterMap::instance_no_args())) {\n@@ -418,4 +418,6 @@\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMap* map);\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMap* map);\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMap* map);\n-template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMap* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Load> (const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapWithArgs* map);\n+template void stackChunkOopDesc::do_barriers0<stackChunkOopDesc::BarrierType::Store>(const StackChunkFrameStream<ChunkFrames::Mixed>& f, const SmallRegisterMapWithArgs* map);\n@@ -441,1 +443,2 @@\n-template void stackChunkOopDesc::fix_thawed_frame(const frame& f, const SmallRegisterMap* map);\n+template void stackChunkOopDesc::fix_thawed_frame(const frame& f, const SmallRegisterMapNoArgs* map);\n+template void stackChunkOopDesc::fix_thawed_frame(const frame& f, const SmallRegisterMapWithArgs* map);\n@@ -530,1 +533,1 @@\n-    int num_oops = f.num_oops();\n+    int num_oops = f.num_oops(map);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -140,0 +140,6 @@\n+  inline bool at_klass_init() const;\n+  inline void set_at_klass_init(bool value);\n+\n+  inline bool has_args_at_top() const;\n+  inline void set_has_args_at_top(bool value);\n+\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -171,0 +171,12 @@\n+inline bool stackChunkOopDesc::at_klass_init() const { return jdk_internal_vm_StackChunk::atKlassInit(as_oop()); }\n+inline void stackChunkOopDesc::set_at_klass_init(bool value) {\n+  assert(at_klass_init() != value, \"\");\n+  jdk_internal_vm_StackChunk::set_atKlassInit(this, value);\n+}\n+\n+inline bool stackChunkOopDesc::has_args_at_top() const { return jdk_internal_vm_StackChunk::hasArgsAtTop(as_oop()); }\n+inline void stackChunkOopDesc::set_has_args_at_top(bool value) {\n+  assert(has_args_at_top() != value, \"\");\n+  jdk_internal_vm_StackChunk::set_hasArgsAtTop(this, value);\n+}\n+\n@@ -213,1 +225,1 @@\n-  const SmallRegisterMap* map = SmallRegisterMap::instance();\n+  const auto* map = SmallRegisterMap::instance_no_args();\n@@ -233,0 +245,3 @@\n+  } else if (frame_kind == ChunkFrames::Mixed && f.is_interpreted() && has_args_at_top()) {\n+    should_continue = closure->do_frame(f, SmallRegisterMap::instance_with_args());\n+    f.next(map);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,2 +32,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2411,1 +2411,1 @@\n-        tty->print_cr(\"0xBADB100D   +VerifyStackAtCalls\");\n+        tty->print_cr(\"<Majik cookie>   +VerifyStackAtCalls\");\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+macro(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -328,1 +328,10 @@\n-  int                   _major_progress;        \/\/ Count of something big happening\n+  \/* If major progress is set:\n+   *   Marks that the loop tree information (get_ctrl, idom, get_loop, etc.) could be invalid, and we need to rebuild the loop tree.\n+   *   It also indicates that the graph was changed in a way that is promising to be able to apply more loop optimization.\n+   * If major progress is not set:\n+   *   Loop tree information is valid.\n+   *   If major progress is not set at the end of a loop opts phase, then we can stop loop opts, because we do not expect any further progress if we did more loop opts phases.\n+   *\n+   * This is not 100% accurate, the semantics of major progress has become less clear over time, but this is the general idea.\n+   *\/\n+  bool                  _major_progress;\n@@ -595,1 +604,0 @@\n-  int               major_progress() const      { return _major_progress; }\n@@ -602,3 +610,4 @@\n-  void          set_major_progress()            { _major_progress++; }\n-  void          restore_major_progress(int progress) { _major_progress += progress; }\n-  void        clear_major_progress()            { _major_progress = 0; }\n+  bool              major_progress() const      { return _major_progress; }\n+  void          set_major_progress()            { _major_progress = true; }\n+  void          restore_major_progress(bool progress) { _major_progress = _major_progress || progress; }\n+  void        clear_major_progress()            { _major_progress = false; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -886,1 +886,1 @@\n-void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node*> &alloc_worklist) {\n@@ -1320,1 +1320,1 @@\n-void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node*> &alloc_worklist) {\n@@ -1347,1 +1347,1 @@\n-    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist, memnode_worklist);\n+    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist);\n@@ -4320,0 +4320,8 @@\n+#if 0  \/\/ TODO: Fix 8372259\n+        } else if (C->get_alias_index(result->adr_type()) != alias_idx) {\n+          assert(C->get_general_index(alias_idx) == C->get_alias_index(result->adr_type()), \"should be projection for the same field\/array element\");\n+          result = get_map(result->_idx);\n+          assert(result != nullptr, \"new projection should have been allocated\");\n+          break;\n+        }\n+#else\n@@ -4321,0 +4329,1 @@\n+#endif\n@@ -4616,0 +4625,16 @@\n+        \/\/ Add a new NarrowMem projection for each existing NarrowMem projection with new adr type\n+        InitializeNode* init = alloc->as_Allocate()->initialization();\n+        assert(init != nullptr, \"can't find Initialization node for this Allocate node\");\n+        auto process_narrow_proj = [&](NarrowMemProjNode* proj) {\n+          const TypePtr* adr_type = proj->adr_type();\n+          const TypePtr* new_adr_type = tinst->add_offset(adr_type->offset());\n+          if (adr_type != new_adr_type && !init->already_has_narrow_mem_proj_with_adr_type(new_adr_type)) {\n+            DEBUG_ONLY( uint alias_idx = _compile->get_alias_index(new_adr_type); )\n+            assert(_compile->get_general_index(alias_idx) == _compile->get_alias_index(adr_type), \"new adr type should be narrowed down from existing adr type\");\n+            NarrowMemProjNode* new_proj = new NarrowMemProjNode(init, new_adr_type);\n+            igvn->set_type(new_proj, new_proj->bottom_type());\n+            record_for_optimizer(new_proj);\n+            set_map(proj, new_proj); \/\/ record it so ConnectionGraph::find_inst_mem() can find it\n+          }\n+        };\n+        init->for_each_narrow_mem_proj_with_new_uses(process_narrow_proj);\n@@ -4687,1 +4712,1 @@\n-        reduce_phi(n->as_Phi(), alloc_worklist, memnode_worklist);\n+        reduce_phi(n->as_Phi(), alloc_worklist);\n@@ -4889,5 +4914,7 @@\n-    } else if (n->is_MemBar()) { \/\/ Initialize, MemBar nodes\n-      \/\/ we don't need to do anything, but the users must be pushed\n-      n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n-      if (n == nullptr) {\n-        continue;\n+    } else if (n->is_MemBar()) { \/\/ MemBar nodes\n+      if (!n->is_Initialize()) { \/\/ memory projections for Initialize pushed below (so we get to all their uses)\n+        \/\/ we don't need to do anything, but the users must be pushed\n+        n = n->as_MemBar()->proj_out_or_null(TypeFunc::Memory);\n+        if (n == nullptr) {\n+          continue;\n+        }\n@@ -4913,0 +4940,2 @@\n+    } else if (n->is_Proj()) {\n+      assert(n->in(0)->is_Initialize(), \"we only push memory projections for Initialize\");\n@@ -4956,0 +4985,5 @@\n+      } else if (use->is_Proj()) {\n+        assert(n->is_Initialize(), \"We only push projections of Initialize\");\n+        if (use->as_Proj()->_con == TypeFunc::Memory) { \/\/ Ignore precedent edge\n+          memnode_worklist.append_if_missing(use);\n+        }\n@@ -5011,1 +5045,1 @@\n-        const Type *at = igvn->type(mem->in(MemNode::Address));\n+        const Type* at = igvn->type(mem->in(MemNode::Address));\n@@ -5131,1 +5165,1 @@\n-             n->is_AddP() || n->is_Phi(), \"unknown node used for set_map()\");\n+             n->is_AddP() || n->is_Phi() || n->is_NarrowMemProj(), \"unknown node used for set_map()\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":45,"deletions":11,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-                        \/\/ ChecCastPP    - allocation that this is a cast of\n+                        \/\/ CheckCastPP   - allocation that this is a cast of\n@@ -570,0 +570,2 @@\n+                        \/\/ NarrowMem     - newly created projection (type includes instance_id) from projection created\n+                        \/\/                 before EA\n@@ -614,1 +616,1 @@\n-  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node*> &alloc_worklist);\n@@ -618,1 +620,1 @@\n-  void reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi(PhiNode* ophi, GrowableArray<Node*> &alloc_worklist);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4165,4 +4165,7 @@\n-    \/\/ Add an edge in the MergeMem for the header fields so an access\n-    \/\/ to one of those has correct memory state\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes())));\n-    set_memory(minit_out, C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes())));\n+    int mark_idx = C->get_alias_index(oop_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    \/\/ Add an edge in the MergeMem for the header fields so an access to one of those has correct memory state.\n+    \/\/ Use one NarrowMemProjNode per slice to properly record the adr type of each slice. The Initialize node will have\n+    \/\/ multiple projections as a result.\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(mark_idx))), mark_idx);\n+    int klass_idx = C->get_alias_index(oop_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+    set_memory(_gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(klass_idx))), klass_idx);\n@@ -4196,1 +4199,1 @@\n-        hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+        hook_memory_on_init(*this, elemidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(elemidx))));\n@@ -4207,1 +4210,1 @@\n-        hook_memory_on_init(*this, fieldidx, minit_in, minit_out);\n+        hook_memory_on_init(*this, fieldidx, minit_in, _gvn.transform(new NarrowMemProjNode(init, C->get_adr_type(fieldidx))));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-      MemNode::dump_adr_type(node, node->adr_type(), &s2);\n+      MemNode::dump_adr_type(node->adr_type(), &s2);\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-        hi = (1UL << bitcount) - 1;\n+        hi = right_n_bits_typed<jlong>(bitcount);\n@@ -379,1 +379,1 @@\n-        hi = MIN2((jlong)((1UL << result_bit_width) - 1L), hi);\n+        hi = MIN2(right_n_bits_typed<jlong>(result_bit_width), hi);\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6288,1 +6288,1 @@\n-    C->gvn_replace_by(init->proj_out(TypeFunc::Memory), alloc_mem);\n+    init->replace_mem_projs_by(alloc_mem, C);\n@@ -6339,2 +6339,14 @@\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);\n-    set_memory(init->proj_out_or_null(TypeFunc::Memory), elemidx);\n+    \/\/ Need to properly move every memory projection for the Initialize\n+#ifdef ASSERT\n+    int mark_idx = C->get_alias_index(ary_type->add_offset(oopDesc::mark_offset_in_bytes()));\n+    int klass_idx = C->get_alias_index(ary_type->add_offset(oopDesc::klass_offset_in_bytes()));\n+#endif\n+    auto move_proj = [&](ProjNode* proj) {\n+      int alias_idx = C->get_alias_index(proj->adr_type());\n+      assert(alias_idx == Compile::AliasIdxRaw ||\n+             alias_idx == elemidx ||\n+             alias_idx == mark_idx ||\n+             alias_idx == klass_idx, \"should be raw memory or array element type\");\n+      set_memory(proj, alias_idx);\n+    };\n+    init->for_each_proj(move_proj, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1973,2 +1973,13 @@\n-    \/\/ Zero-trip test uses an 'opaque' node which is not shared.\n-    assert(opaq->outcnt() == 1 && opaq->in(1) == limit, \"\");\n+    \/\/ Zero-trip test uses an 'opaque' node which is not shared, otherwise bail out.\n+    if (opaq->outcnt() != 1 || opaq->in(1) != limit) {\n+#ifdef ASSERT\n+      \/\/ In rare cases, loop cloning (as for peeling, for instance) can break this by replacing\n+      \/\/ limit and the input of opaq by equivalent but distinct phis.\n+      \/\/ Next IGVN should clean it up. Let's try to detect we are in such a case.\n+      Unique_Node_List& worklist = loop->_phase->_igvn._worklist;\n+      assert(C->major_progress(), \"The operation that replaced limit and opaq->in(1) (e.g. peeling) should have set major_progress\");\n+      assert(opaq->in(1)->is_Phi() && limit->is_Phi(), \"Nodes limit and opaq->in(1) should have been replaced by PhiNodes by fix_data_uses from clone_loop.\");\n+      assert(worklist.member(opaq->in(1)) && worklist.member(limit), \"Nodes limit and opaq->in(1) differ and should have been recorded for IGVN.\");\n+#endif\n+      return;\n+    }\n@@ -4034,1 +4045,3 @@\n-  call->init_req(TypeFunc::FramePtr,  C->start()->proj_out_or_null(TypeFunc::FramePtr));\n+  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n+  _igvn.register_new_node_with_optimizer(frame);\n+  call->init_req(TypeFunc::FramePtr,  frame);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4768,0 +4768,18 @@\n+#ifdef ASSERT\n+        \/\/ See PhaseIdealLoop::do_unroll\n+        \/\/ This property is required in do_unroll, but it may not hold after cloning a loop.\n+        \/\/ In such a case, we bail out from unrolling, and rely on IGVN to clean up the graph.\n+        \/\/ We are here before loop cloning (before iteration_split), so if this property\n+        \/\/ does not hold, it must come from the previous round of loop optimizations, meaning\n+        \/\/ that IGVN failed to clean it: we will catch that here.\n+        \/\/ On the other hand, if this assert passes, a bailout in do_unroll means that\n+        \/\/ this property was broken in the current round of loop optimization (between here\n+        \/\/ and do_unroll), so we give a chance to IGVN to make the property true again.\n+        if (head->is_main_loop()) {\n+          assert(opaque->outcnt() == 1, \"opaque node should not be shared\");\n+          assert(opaque->in(1) == head->limit(), \"After IGVN cleanup, input of opaque node must be the limit.\");\n+        }\n+        if (head->is_post_loop()) {\n+          assert(opaque->outcnt() == 1, \"opaque node should not be shared\");\n+        }\n+#endif\n@@ -4937,1 +4955,1 @@\n-  int old_progress = C->major_progress();\n+  bool old_progress = C->major_progress();\n@@ -5318,1 +5336,1 @@\n-  int old_progress = C->major_progress();\n+  bool old_progress = C->major_progress();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1751,0 +1751,3 @@\n+\n+  void split_thru_phi_yank_old_nodes(Node* n, Node* region);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -238,0 +238,3 @@\n+  split_thru_phi_yank_old_nodes(n, region);\n+  _igvn.replace_node(n, phi);\n+\n@@ -248,0 +251,22 @@\n+\/\/ If the region is a Loop, we are removing the old n,\n+\/\/ and need to yank it from the _body. If any phi we\n+\/\/ just split through now has no use any more, it also\n+\/\/ has to be removed.\n+void PhaseIdealLoop::split_thru_phi_yank_old_nodes(Node* n, Node* region) {\n+  IdealLoopTree* region_loop = get_loop(region);\n+  if (region->is_Loop() && region_loop->is_innermost()) {\n+    region_loop->_body.yank(n);\n+    for (uint j = 1; j < n->req(); j++) {\n+      PhiNode* phi = n->in(j)->isa_Phi();\n+      \/\/ Check that phi belongs to the region and only has n as a use.\n+      if (phi != nullptr &&\n+          phi->in(0) == region &&\n+          phi->unique_multiple_edges_out_or_null() == n) {\n+        assert(get_ctrl(phi) == region, \"sanity\");\n+        assert(get_ctrl(n) == region, \"sanity\");\n+        region_loop->_body.yank(phi);\n+      }\n+    }\n+  }\n+}\n+\n@@ -1275,3 +1300,3 @@\n-  \/\/ Split 'n' through the merge point if it is profitable\n-  Node *phi = split_thru_phi( n, n_blk, policy );\n-  if (!phi) return n;\n+  \/\/ Split 'n' through the merge point if it is profitable, replacing it with a new phi.\n+  Node* phi = split_thru_phi(n, n_blk, policy);\n+  if (phi == nullptr) { return n; }\n@@ -1279,3 +1304,0 @@\n-  \/\/ Found a Phi to split thru!\n-  \/\/ Replace 'n' with the new phi\n-  _igvn.replace_node( n, phi );\n@@ -1614,4 +1636,0 @@\n-    \/\/ Found a Phi to split thru!\n-    \/\/ Replace 'n' with the new phi\n-    _igvn.replace_node(n, phi);\n-\n@@ -1619,1 +1637,1 @@\n-    Node *bolphi = split_thru_phi(bol, n_ctrl, -1);\n+    Node* bolphi = split_thru_phi(bol, n_ctrl, -1);\n@@ -1621,2 +1639,0 @@\n-\n-    _igvn.replace_node(bol, bolphi);\n@@ -1631,2 +1647,1 @@\n-      Node *cmovphi = split_thru_phi(iff, n_ctrl, -1);\n-      _igvn.replace_node(iff, cmovphi);\n+      Node* cmovphi = split_thru_phi(iff, n_ctrl, -1);\n@@ -2861,2 +2876,3 @@\n-          Node* cle_out = cle->proj_out_or_null(false);\n-          if (use == cle_out) {\n+          \/\/ is use the projection that exits the loop from the CountedLoopEndNode?\n+          if (use->in(0) == cle) {\n+            IfFalseNode* cle_out = use->as_IfFalse();\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":33,"deletions":17,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -528,0 +528,5 @@\n+    } else if (mem->is_top()) {\n+      \/\/ The slice is on a dead path. Returning nullptr would lead to elimination\n+      \/\/ bailout, but we want to prevent that. Just forwarding the top is also legal,\n+      \/\/ and IGVN can just clean things up, and remove whatever receives top.\n+      return mem;\n@@ -878,0 +883,35 @@\n+#ifdef ASSERT\n+  \/\/ Verify if a value can be written into a field.\n+  void verify_type_compatability(const Type* value_type, const Type* field_type) {\n+    BasicType value_bt = value_type->basic_type();\n+    BasicType field_bt = field_type->basic_type();\n+\n+    \/\/ Primitive types must match.\n+    if (is_java_primitive(value_bt) && value_bt == field_bt) { return; }\n+\n+    \/\/ I have been struggling to make a similar assert for non-primitive\n+    \/\/ types. I we can add one in the future. For now, I just let them\n+    \/\/ pass without checks.\n+    \/\/ In particular, I was struggling with a value that came from a call,\n+    \/\/ and had only a non-null check CastPP. There was also a checkcast\n+    \/\/ in the graph to verify the interface, but the corresponding\n+    \/\/ CheckCastPP result was not updated in the stack slot, and so\n+    \/\/ we ended up using the CastPP. That means that the field knows\n+    \/\/ that it should get an oop from an interface, but the value lost\n+    \/\/ that information, and so it is not a subtype.\n+    \/\/ There may be other issues, feel free to investigate further!\n+    if (!is_java_primitive(value_bt)) { return; }\n+\n+    tty->print_cr(\"value not compatible for field: %s vs %s\",\n+                  type2name(value_bt),\n+                  type2name(field_bt));\n+    tty->print(\"value_type: \");\n+    value_type->dump();\n+    tty->cr();\n+    tty->print(\"field_type: \");\n+    field_type->dump();\n+    tty->cr();\n+    assert(false, \"value_type does not fit field_type\");\n+  }\n+#endif\n+\n@@ -901,0 +941,1 @@\n+  DEBUG_ONLY(verify_type_compatability(field_val->bottom_type(), field_type);)\n@@ -1267,1 +1308,0 @@\n-        assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -1277,3 +1317,1 @@\n-        Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-        if (mem_proj != nullptr) {\n-          Node *mem = init->in(TypeFunc::Memory);\n+        Node* mem = init->in(TypeFunc::Memory);\n@@ -1281,0 +1319,1 @@\n+        if (init->number_of_projs(TypeFunc::Memory) > 0) {\n@@ -1282,1 +1321,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n+            assert(mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw) == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n@@ -1286,2 +1325,0 @@\n-#endif\n-          _igvn.replace_node(mem_proj, mem);\n@@ -1289,0 +1326,3 @@\n+#endif\n+        init->replace_mem_projs_by(mem, &_igvn);\n+        assert(init->outcnt() == 0, \"should only have had a control and some memory projections, and we removed them\");\n@@ -1895,1 +1935,10 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      \/\/ What we want is to prevent the compiler and the CPU from re-ordering the stores that initialize this object\n+      \/\/ with subsequent stores to any slice. As a consequence, this MemBar should capture the entire memory state at\n+      \/\/ this point in the IR and produce a new memory state that should cover all slices. However, the Initialize node\n+      \/\/ only captures\/produces a partial memory state making it complicated to insert such a MemBar. Because\n+      \/\/ re-ordering by the compiler can't happen by construction (a later Store that publishes the just allocated\n+      \/\/ object reference is indirectly control dependent on the Initialize node), preventing reordering by the CPU is\n+      \/\/ sufficient. For that a MemBar on the raw memory slice is good enough.\n+      \/\/ If init is null, this allocation does have an InitializeNode but this logic can't locate it (see comment in\n+      \/\/ PhaseMacroExpand::initialize_object()).\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1911,1 +1960,0 @@\n-      Node* init_mem = init->proj_out_or_null(TypeFunc::Memory);\n@@ -1913,1 +1961,2 @@\n-      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);\n+      \/\/ See comment above that explains why a raw memory MemBar is good enough.\n+      MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxRaw);\n@@ -1918,2 +1967,11 @@\n-      Node* mem = new ProjNode(init, TypeFunc::Memory);\n-      transform_later(mem);\n+      Node* old_raw_mem_proj = nullptr;\n+      auto find_raw_mem = [&](ProjNode* proj) {\n+        if (C->get_alias_index(proj->adr_type()) == Compile::AliasIdxRaw) {\n+          assert(old_raw_mem_proj == nullptr, \"only one expected\");\n+          old_raw_mem_proj = proj;\n+        }\n+      };\n+      init->for_each_proj(find_raw_mem, TypeFunc::Memory);\n+      assert(old_raw_mem_proj != nullptr, \"should have found raw mem Proj\");\n+      Node* raw_mem_proj = new ProjNode(init, TypeFunc::Memory);\n+      transform_later(raw_mem_proj);\n@@ -1923,1 +1981,1 @@\n-      mb->init_req(TypeFunc::Memory, mem);\n+      mb->init_req(TypeFunc::Memory, raw_mem_proj);\n@@ -1928,1 +1986,1 @@\n-      mem = new ProjNode(mb, TypeFunc::Memory);\n+      Node* mem = new ProjNode(mb, TypeFunc::Memory);\n@@ -1937,3 +1995,1 @@\n-      if (init_mem != nullptr) {\n-        _igvn.replace_node(init_mem, mem);\n-      }\n+      _igvn.replace_node(old_raw_mem_proj, mem);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":73,"deletions":17,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+    assert(!n->is_Initialize() || n->as_Initialize()->number_of_projs(TypeFunc::Memory) == 1,\n+           \"after matching, Initialize should have a single memory projection\");\n@@ -1064,1 +1066,1 @@\n-        Node* m;\n+        Node* m = nullptr;\n@@ -1079,4 +1081,18 @@\n-              \/\/ Convert to machine-dependent projection\n-              RegMask* mask = nullptr;\n-              if (n->in(0)->is_Call() && n->in(0)->as_Call()->tf()->returns_inline_type_as_fields()) {\n-                mask = return_values_mask(n->in(0)->as_Call()->tf());\n+              if (n->in(0)->is_Initialize() && n->as_Proj()->_con == TypeFunc::Memory) {\n+                \/\/ Initialize may have multiple NarrowMem projections. They would all match to identical raw mem MachProjs.\n+                \/\/ We don't need multiple MachProjs. Create one if none already exist, otherwise use existing one.\n+                m = n->in(0)->as_Initialize()->mem_mach_proj();\n+                if (m == nullptr && has_new_node(n->in(0))) {\n+                  InitializeNode* new_init = new_node(n->in(0))->as_Initialize();\n+                  m = new_init->mem_mach_proj();\n+                }\n+                assert(m == nullptr || m->is_MachProj(), \"no mem projection yet or a MachProj created during matching\");\n+              }\n+              if (m == nullptr) {\n+                \/\/ Convert to machine-dependent projection\n+                RegMask* mask = nullptr;\n+                if (n->in(0)->is_Call() && n->in(0)->as_Call()->tf()->returns_inline_type_as_fields()) {\n+                  mask = return_values_mask(n->in(0)->as_Call()->tf());\n+                }\n+                m = n->in(0)->as_Multi()->match(n->as_Proj(), this, mask);\n+                NOT_PRODUCT(record_new2old(m, n);)\n@@ -1084,2 +1100,0 @@\n-              m = n->in(0)->as_Multi()->match(n->as_Proj(), this, mask);\n-              NOT_PRODUCT(record_new2old(m, n);)\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  dump_adr_type(this, _adr_type, st);\n+  dump_adr_type(_adr_type, st);\n@@ -116,1 +116,1 @@\n-void MemNode::dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st) {\n+void MemNode::dump_adr_type(const TypePtr* adr_type, outputStream* st) {\n@@ -4467,1 +4467,1 @@\n-  assert(outcnt() > 0 && outcnt() <= 2, \"Only one or two out edges allowed\");\n+  assert(outcnt() > 0 && (outcnt() <= 2 || Opcode() == Op_Initialize), \"Only one or two out edges allowed\");\n@@ -4475,3 +4475,0 @@\n-  if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n-    igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n-  }\n@@ -4481,0 +4478,7 @@\n+  if (is_Initialize()) {\n+    as_Initialize()->replace_mem_projs_by(in(TypeFunc::Memory), igvn);\n+  } else {\n+    if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n+      igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n+    }\n+  }\n@@ -5695,0 +5699,42 @@\n+void InitializeNode::replace_mem_projs_by(Node* mem, Compile* C) {\n+  auto replace_proj = [&](ProjNode* proj) {\n+    C->gvn_replace_by(proj, mem);\n+    return CONTINUE;\n+  };\n+  apply_to_projs(replace_proj, TypeFunc::Memory);\n+}\n+\n+void InitializeNode::replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn) {\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  auto replace_proj = [&](ProjNode* proj) {\n+    igvn->replace_node(proj, mem);\n+    --i; --imax;\n+    return CONTINUE;\n+  };\n+  apply_to_projs(imax, i, replace_proj, TypeFunc::Memory);\n+}\n+\n+bool InitializeNode::already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const {\n+  auto find_proj = [&](ProjNode* proj) {\n+    if (proj->adr_type() == adr_type) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n+    }\n+    return CONTINUE;\n+  };\n+  DUIterator_Fast imax, i = fast_outs(imax);\n+  return apply_to_narrow_mem_projs_any_iterator(UsesIteratorFast(imax, i, this), find_proj) != nullptr;\n+}\n+\n+MachProjNode* InitializeNode::mem_mach_proj() const {\n+  auto find_proj = [](ProjNode* proj) {\n+    if (proj->is_MachProj()) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n+    }\n+    return CONTINUE;\n+  };\n+  ProjNode* proj = apply_to_projs(find_proj, TypeFunc::Memory);\n+  if (proj == nullptr) {\n+    return nullptr;\n+  }\n+  return proj->as_MachProj();\n+}\n@@ -6117,0 +6163,1 @@\n+           || n->is_NarrowMemProj()\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-  static void dump_adr_type(const Node* mem, const TypePtr* adr_type, outputStream *st);\n+  static void dump_adr_type(const TypePtr* adr_type, outputStream* st);\n@@ -1405,1 +1405,14 @@\n- private:\n+  \/\/ An Initialize node has multiple memory projections. Helper methods used when the node is removed.\n+  \/\/ For use at parse time\n+  void replace_mem_projs_by(Node* mem, Compile* C);\n+  \/\/ For use with IGVN\n+  void replace_mem_projs_by(Node* mem, PhaseIterGVN* igvn);\n+\n+  \/\/ Does a NarrowMemProj with this adr_type and this node as input already exist?\n+  bool already_has_narrow_mem_proj_with_adr_type(const TypePtr* adr_type) const;\n+\n+  \/\/ Used during matching: find the MachProj memory projection if there's one. Expectation is that there should be at\n+  \/\/ most one.\n+  MachProjNode* mem_mach_proj() const;\n+\n+private:\n@@ -1422,0 +1435,27 @@\n+\n+  \/\/ Iterate with i over all NarrowMemProj uses calling callback\n+  template <class Callback, class Iterator> NarrowMemProjNode* apply_to_narrow_mem_projs_any_iterator(Iterator i, Callback callback) const {\n+    auto filter = [&](ProjNode* proj) {\n+      if (proj->is_NarrowMemProj() && callback(proj->as_NarrowMemProj()) == BREAK_AND_RETURN_CURRENT_PROJ) {\n+        return BREAK_AND_RETURN_CURRENT_PROJ;\n+      }\n+      return CONTINUE;\n+    };\n+    ProjNode* res = apply_to_projs_any_iterator(i, filter);\n+    if (res == nullptr) {\n+      return nullptr;\n+    }\n+    return res->as_NarrowMemProj();\n+  }\n+\n+public:\n+\n+  \/\/ callback is allowed to add new uses that will then be iterated over\n+  template <class Callback> void for_each_narrow_mem_proj_with_new_uses(Callback callback) const {\n+    auto callback_always_continue = [&](NarrowMemProjNode* proj) {\n+      callback(proj);\n+      return MultiNode::CONTINUE;\n+    };\n+    DUIterator i = outs();\n+    apply_to_narrow_mem_projs_any_iterator(UsesIterator(i, this), callback_always_continue);\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1136,0 +1136,13 @@\n+  \/\/ Check for \"(con0 - X) << con1\"\n+  \/\/ Transform is legal, but check for profit.  Avoid breaking 'i2s'\n+  \/\/ and 'i2b' patterns which typically fold into 'StoreC\/StoreB'.\n+  if (add1_op == Op_Sub(bt) && (bt != T_INT || con < 16)) {    \/\/ Left input is a sub?\n+    \/\/ Left input is a sub from a constant?\n+    const TypeInteger* t11 = phase->type(add1->in(1))->isa_integer(bt);\n+    if (t11 != nullptr && t11->is_con()) {\n+      \/\/ Compute X << con0\n+      Node* lsh = phase->transform(LShiftNode::make(add1->in(2), in(2), bt));\n+      \/\/ Compute (con1<<con0) - (X<<con0)\n+      return SubNode::make(phase->integercon(java_shift_left(t11->get_con_as_long(bt), con, bt), bt), lsh, bt);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,14 +48,5 @@\n-  for( DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++ ) {\n-    Node *p = fast_out(i);\n-    if (p->is_Proj()) {\n-      ProjNode *proj = p->as_Proj();\n-      if (proj->_con == which_proj) {\n-        assert((Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse), \"bad if #2\");\n-        return proj;\n-      }\n-    } else {\n-      assert(p == this && this->is_Start(), \"else must be proj\");\n-      continue;\n-    }\n-  }\n-  return nullptr;\n+  assert(number_of_projs(which_proj) <= 1, \"only when there's a single projection\");\n+  ProjNode* proj = find_first(which_proj);\n+  assert(proj == nullptr || (Opcode() != Op_If && Opcode() != Op_RangeCheck) || proj->Opcode() == (which_proj ? Op_IfTrue : Op_IfFalse),\n+         \"incorrect projection node at If\/RangeCheck: IfTrue on false path or IfFalse on true path\");\n+  return proj;\n@@ -65,4 +56,8 @@\n-  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-    ProjNode* proj = fast_out(i)->isa_Proj();\n-    if (proj != nullptr && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n-      return proj;\n+  assert(number_of_projs(which_proj, is_io_use) <= 1, \"only when there's a single projection\");\n+  return find_first(which_proj, is_io_use);\n+}\n+\n+template<class Callback> ProjNode* MultiNode::apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const {\n+  auto filter = [&](ProjNode* proj) {\n+    if (proj->_is_io_use == is_io_use && callback(proj) == BREAK_AND_RETURN_CURRENT_PROJ) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n@@ -70,2 +65,35 @@\n-  }\n-  return nullptr;\n+    return CONTINUE;\n+  };\n+  return apply_to_projs(filter, which_proj);\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj) const {\n+  uint cnt = 0;\n+  auto count_projs = [&](ProjNode* proj) {\n+    cnt++;\n+  };\n+  for_each_proj(count_projs, which_proj);\n+  return cnt;\n+}\n+\n+uint MultiNode::number_of_projs(uint which_proj, bool is_io_use) const {\n+  uint cnt = 0;\n+  auto count_projs = [&](ProjNode* proj) {\n+    cnt++;\n+  };\n+  for_each_proj(count_projs, which_proj, is_io_use);\n+  return cnt;\n+}\n+\n+ProjNode* MultiNode::find_first(uint which_proj) const {\n+  auto find_proj = [&](ProjNode* proj) {\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n+  };\n+  return apply_to_projs(find_proj, which_proj);\n+}\n+\n+ProjNode* MultiNode::find_first(uint which_proj, bool is_io_use) const {\n+  auto find_proj = [](ProjNode* proj) {\n+    return BREAK_AND_RETURN_CURRENT_PROJ;\n+  };\n+  return apply_to_projs(find_proj, which_proj, is_io_use);\n@@ -242,0 +270,5 @@\n+\n+NarrowMemProjNode::NarrowMemProjNode(InitializeNode* src, const TypePtr* adr_type)\n+  : ProjNode(src, TypeFunc::Memory), _adr_type(adr_type) {\n+  init_class_id(Class_NarrowMemProj);\n+}\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":53,"deletions":20,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -52,0 +52,99 @@\n+  uint number_of_projs(uint which_proj) const;\n+  uint number_of_projs(uint which_proj, bool is_io_use) const;\n+\n+protected:\n+\n+  \/\/ Provide single interface for DUIterator_Fast\/DUIterator for template method below\n+  class UsesIteratorFast {\n+    DUIterator_Fast& _imax;\n+    DUIterator_Fast& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _i < _imax;\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->fast_out(_i);\n+    }\n+    UsesIteratorFast(DUIterator_Fast& imax, DUIterator_Fast& i, const Node* node)\n+      : _imax(imax), _i(i), _node(node) {\n+    }\n+  };\n+\n+  class UsesIterator {\n+    DUIterator& _i;\n+    const Node* _node;\n+\n+  public:\n+    bool cont() {\n+      return _node->has_out(_i);\n+    }\n+    void next() {\n+      _i++;\n+    }\n+    Node* current() {\n+      return _node->out(_i);\n+    }\n+    UsesIterator(DUIterator& i, const Node* node)\n+      : _i(i), _node(node) {\n+    }\n+  };\n+\n+  \/\/ Iterate with i over all Proj uses calling callback\n+  template<class Callback, class Iterator> ProjNode* apply_to_projs_any_iterator(Iterator i, Callback callback) const {\n+    for (; i.cont(); i.next()) {\n+      Node* p = i.current();\n+      if (p->is_Proj()) {\n+        ProjNode* proj = p->as_Proj();\n+        ApplyToProjs result = callback(proj);\n+        if (result == BREAK_AND_RETURN_CURRENT_PROJ) {\n+          return proj;\n+        }\n+        assert(result == CONTINUE, \"should be either break or continue\");\n+      } else {\n+        assert(p == this && is_Start(), \"else must be proj\");\n+      }\n+    }\n+    return nullptr;\n+  }\n+  enum ApplyToProjs {\n+    CONTINUE,\n+    BREAK_AND_RETURN_CURRENT_PROJ\n+  };\n+\n+  \/\/ Run callback on projections with iterator passed as argument\n+  template <class Callback> ProjNode* apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const;\n+\n+  \/\/ Same but with default iterator and for matching _con\n+  template<class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj) const {\n+    DUIterator_Fast imax, i = fast_outs(imax);\n+    return apply_to_projs(imax, i, callback, which_proj);\n+  }\n+\n+  \/\/ Same but for matching _con and _is_io_use\n+  template <class Callback> ProjNode* apply_to_projs(Callback callback, uint which_proj, bool is_io_use) const;\n+\n+public:\n+  template<class Callback> void for_each_proj(Callback callback, uint which_proj) const {\n+    auto callback_always_continue = [&](ProjNode* proj) {\n+      callback(proj);\n+      return MultiNode::CONTINUE;\n+    };\n+    apply_to_projs(callback_always_continue, which_proj);\n+  }\n+\n+  template <class Callback> void for_each_proj(Callback callback, uint which_proj, bool is_io_use) const {\n+    auto callback_always_continue = [&](ProjNode* proj) {\n+      callback(proj);\n+      return MultiNode::CONTINUE;\n+    };\n+    apply_to_projs(callback_always_continue, which_proj, is_io_use);\n+  }\n+\n+\n+  ProjNode* find_first(uint which_proj) const;\n+  ProjNode* find_first(uint which_proj, bool is_io_use) const;\n@@ -109,0 +208,35 @@\n+\/\/ A ProjNode variant that captures an adr_type(). Used as a projection of InitializeNode to have the right adr_type()\n+\/\/ for array elements\/fields.\n+class NarrowMemProjNode : public ProjNode {\n+private:\n+  const TypePtr* const _adr_type;\n+protected:\n+  virtual uint hash() const {\n+    return ProjNode::hash() + _adr_type->hash();\n+  }\n+  virtual bool cmp(const Node& n) const {\n+    return ProjNode::cmp(n) && ((NarrowMemProjNode&)n)._adr_type == _adr_type;\n+  }\n+  virtual uint size_of() const {\n+    return sizeof(*this);\n+  }\n+public:\n+  NarrowMemProjNode(InitializeNode* src, const TypePtr* adr_type);\n+\n+  virtual const TypePtr* adr_type() const {\n+    return _adr_type;\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+template <class Callback> ProjNode* MultiNode::apply_to_projs(DUIterator_Fast& imax, DUIterator_Fast& i, Callback callback, uint which_proj) const {\n+  auto filter = [&](ProjNode* proj) {\n+    if (proj->_con == which_proj && callback(proj) == BREAK_AND_RETURN_CURRENT_PROJ) {\n+      return BREAK_AND_RETURN_CURRENT_PROJ;\n+    }\n+    return CONTINUE;\n+  };\n+  return apply_to_projs_any_iterator(UsesIteratorFast(imax, i, this), filter);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2615,1 +2615,1 @@\n-    MemNode::dump_adr_type(this, adr_type(), st);\n+    MemNode::dump_adr_type(adr_type(), st);\n@@ -2902,0 +2902,14 @@\n+Node* Node::unique_multiple_edges_out_or_null() const {\n+  Node* use = nullptr;\n+  for (DUIterator_Fast kmax, k = fast_outs(kmax); k < kmax; k++) {\n+    Node* u = fast_out(k);\n+    if (use == nullptr) {\n+      use = u; \/\/ first use\n+    } else if (u != use) {\n+      return nullptr; \/\/ not unique\n+    } else {\n+      \/\/ secondary use\n+    }\n+  }\n+  return use;\n+}\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+class NarrowMemProjNode;\n@@ -431,0 +432,7 @@\n+\n+  \/\/ In some cases, a node n is only used by a single use, but the use may use\n+  \/\/ n once or multiple times:\n+  \/\/   use = ConvF2I(this)\n+  \/\/   use = AddI(this, this)\n+  Node* unique_multiple_edges_out_or_null() const;\n+\n@@ -779,0 +787,1 @@\n+      DEFINE_CLASS_ID(NarrowMemProj, Proj, 6)\n@@ -1002,0 +1011,1 @@\n+  DEFINE_CLASS_QUERY(NarrowMemProj)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1443,1 +1443,0 @@\n-  int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; \/\/ add marginal slop for handler\n@@ -1449,1 +1448,1 @@\n-    code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  \/\/ force expansion\n+    code_req = const_req = stub_req = deopt_handler_req = 0x10;  \/\/ force expansion\n@@ -1456,1 +1455,0 @@\n-          exception_handler_req +\n@@ -1886,2 +1884,0 @@\n-    \/\/ Emit the exception handler code.\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2627,0 +2627,3 @@\n+  auto enqueue_init_mem_projs = [&](ProjNode* proj) {\n+    add_users_to_worklist0(proj, worklist);\n+  };\n@@ -2631,2 +2634,1 @@\n-      Node* imem = init->proj_out_or_null(TypeFunc::Memory);\n-      if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+      init->for_each_proj(enqueue_init_mem_projs, TypeFunc::Memory);\n@@ -2646,2 +2648,2 @@\n-    Node* imem = use->as_Initialize()->proj_out_or_null(TypeFunc::Memory);\n-    if (imem != nullptr) add_users_to_worklist0(imem, worklist);\n+    InitializeNode* init = use->as_Initialize();\n+    init->for_each_proj(enqueue_init_mem_projs, TypeFunc::Memory);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -30,2 +31,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/opto\/rangeinference.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -383,1 +383,0 @@\n-  assert(init->outcnt() <= 2, \"only a control and memory projection expected\");\n@@ -389,5 +388,2 @@\n-  Node *mem_proj = init->proj_out_or_null(TypeFunc::Memory);\n-  if (mem_proj != nullptr) {\n-    Node *mem = init->in(TypeFunc::Memory);\n-    C->gvn_replace_by(mem_proj, mem);\n-  }\n+  Node* mem = init->in(TypeFunc::Memory);\n+  init->replace_mem_projs_by(mem, C);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1524,0 +1524,15 @@\n+BoolTest::mask BoolTest::unsigned_mask(BoolTest::mask btm) {\n+  switch(btm) {\n+    case eq:\n+    case ne:\n+      return btm;\n+    case lt:\n+    case le:\n+    case gt:\n+    case ge:\n+      return mask(btm | unsigned_compare);\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-  static mask unsigned_mask(mask btm) { return mask(btm | unsigned_compare); }\n+  static mask unsigned_mask(mask btm);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1340,5 +1340,3 @@\n-void JvmtiExport::expose_single_stepping(JavaThread *thread) {\n-  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n-  if (state != nullptr) {\n-    state->clear_hide_single_stepping();\n-  }\n+void JvmtiExport::expose_single_stepping(JvmtiThreadState* state) {\n+  assert(state != nullptr, \"must be non-null\");\n+  state->clear_hide_single_stepping();\n@@ -1348,1 +1346,1 @@\n-bool JvmtiExport::hide_single_stepping(JavaThread *thread) {\n+JvmtiThreadState* JvmtiExport::hide_single_stepping(JavaThread *thread) {\n@@ -1352,1 +1350,1 @@\n-    return true;\n+    return state;\n@@ -1354,1 +1352,1 @@\n-    return false;\n+    return nullptr;\n@@ -2210,0 +2208,5 @@\n+  \/\/ The last java frame might be compiled in 2 cases:\n+  \/\/ 1) Field events and interp_only mode are not enabled for this thread.\n+  \/\/ This method is called from any thread. The thread filtering is done later.\n+  \/\/ 2) The same JNI call is stll executing after event was enabled.\n+  \/\/ In this case the last frame is only marked for deoptimization but still remains compiled.\n@@ -2232,4 +2235,10 @@\n-  post_field_access(thread,\n-                    thread->last_frame().interpreter_frame_method(),\n-                    thread->last_frame().interpreter_frame_bcp(),\n-                    klass, h_obj, fieldID);\n+\n+  RegisterMap reg_map(thread,\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::skip,\n+                      RegisterMap::WalkContinuation::skip);\n+  javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+  Method* method = jvf->method();\n+  address address = jvf->method()->code_base();\n+\n+  post_field_access(thread, method, address, klass, h_obj, fieldID);\n@@ -2296,0 +2305,5 @@\n+  \/\/ The last java frame might be compiled in 2 cases:\n+  \/\/ 1) Field events and interp_only mode are not enabled for this thread.\n+  \/\/ This method is called from any thread. The thread filtering is done later.\n+  \/\/ 2) The same JNI call is stll executing after event was enabled.\n+  \/\/ In this case the last frame is only marked for deoptimization but still remains compiled.\n@@ -2319,3 +2333,10 @@\n-  post_field_modification(thread,\n-                          thread->last_frame().interpreter_frame_method(),\n-                          thread->last_frame().interpreter_frame_bcp(),\n+\n+  RegisterMap reg_map(thread,\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::skip,\n+                      RegisterMap::WalkContinuation::skip);\n+  javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n+  Method* method = jvf->method();\n+  address address = jvf->method()->code_base();\n+\n+  post_field_modification(thread, method, address,\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -320,2 +320,2 @@\n-  static void expose_single_stepping(JavaThread *thread) NOT_JVMTI_RETURN;\n-  static bool hide_single_stepping(JavaThread *thread) NOT_JVMTI_RETURN_(false);\n+  static void expose_single_stepping(JvmtiThreadState* state) NOT_JVMTI_RETURN;\n+  static JvmtiThreadState* hide_single_stepping(JavaThread *thread) NOT_JVMTI_RETURN_(nullptr);\n@@ -625,2 +625,1 @@\n-  bool         _single_step_hidden;\n-  JavaThread * _thread;\n+  JvmtiThreadState* _state;\n@@ -629,1 +628,1 @@\n-  JvmtiHideSingleStepping(JavaThread * thread) {\n+  JvmtiHideSingleStepping(JavaThread * thread) : _state(nullptr) {\n@@ -632,2 +631,0 @@\n-    _single_step_hidden = false;\n-    _thread = thread;\n@@ -635,1 +632,1 @@\n-      _single_step_hidden = JvmtiExport::hide_single_stepping(_thread);\n+      _state = JvmtiExport::hide_single_stepping(thread);\n@@ -640,2 +637,2 @@\n-    if (_single_step_hidden) {\n-      JvmtiExport::expose_single_stepping(_thread);\n+    if (_state != nullptr) {\n+      JvmtiExport::expose_single_stepping(_state);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -783,1 +783,1 @@\n-                        link_info, false, THREAD);\n+                        link_info, ClassInitMode::dont_init, THREAD);\n@@ -845,1 +845,1 @@\n-        LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, false, THREAD);\n+        LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, ClassInitMode::dont_init, THREAD);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n@@ -39,1 +41,1 @@\n-static bool for_scoped_method(JavaThread* jt, const Func& func) {\n+static void for_scoped_methods(JavaThread* jt, bool agents_loaded, const Func& func) {\n@@ -47,0 +49,2 @@\n+\n+  bool would_have_bailed = false;\n@@ -49,2 +53,0 @@\n-  const int max_critical_stack_depth = 10;\n-  int depth = 0;\n@@ -53,0 +55,14 @@\n+\n+    if (!agents_loaded &&\n+      (m->method_holder()->module()->name() != vmSymbols::java_base())) {\n+      \/\/ Stop walking if we see a frame outside of java.base.\n+\n+      \/\/ If any JVMTI agents are loaded, we also have to keep walking, since\n+      \/\/ agents can add arbitrary Java frames to the stack inside a @Scoped method.\n+#ifndef ASSERT\n+      return;\n+#else\n+      would_have_bailed = true;\n+#endif\n+    }\n+\n@@ -63,10 +79,9 @@\n-      assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-      return func(stream);\n-    }\n-    depth++;\n-\n-#ifndef ASSERT\n-    \/\/ On debug builds, just keep searching the stack\n-    \/\/ in case we missed an @Scoped method further up\n-    if (depth >= max_critical_stack_depth) {\n-      break;\n+      assert(!would_have_bailed, \"would have missed scoped method on release build\");\n+      bool done = func(stream);\n+      if (done || !agents_loaded) {\n+        \/\/ We may also have to keep walking after finding a @Scoped method,\n+        \/\/ since there may be multiple @Scoped methods active on the stack\n+        \/\/ if a JVMTI agent callback runs during a scoped access and calls\n+        \/\/ back into Java code that then itself does a scoped access.\n+        return;\n+      }\n@@ -74,1 +89,0 @@\n-#endif\n@@ -76,1 +90,0 @@\n-  return false;\n@@ -80,1 +93,9 @@\n-  return for_scoped_method(jt, [&](vframeStream& stream){\n+  bool agents_loaded = JvmtiEnv::environments_might_exist();\n+  if (!agents_loaded && jt->is_throwing_unsafe_access_error()) {\n+    \/\/ Ignore this thread. It is in the process of throwing another exception\n+    \/\/ already.\n+    return false;\n+  }\n+\n+  bool is_accessing_session = false;\n+  for_scoped_methods(jt, agents_loaded, [&](vframeStream& stream){\n@@ -87,0 +108,1 @@\n+          is_accessing_session = true;\n@@ -93,0 +115,1 @@\n+  return is_accessing_session;\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -78,1 +79,0 @@\n-#include <limits>\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -37,2 +38,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/runtime\/atomicAccess.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,2 +65,3 @@\n-    freeze_on_monitorenter,\n-    freeze_on_wait\n+    monitorenter,\n+    object_wait,\n+    object_locker\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"interpreter\/interpreterRuntime.hpp\"\n@@ -41,0 +44,1 @@\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -66,0 +70,2 @@\n+#include \"runtime\/vframe.inline.hpp\"\n+#include \"runtime\/vframe_hp.hpp\"\n@@ -76,2 +82,6 @@\n-\n-#include <type_traits>\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -186,1 +196,1 @@\n-static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp, bool preempted);\n+static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp);\n@@ -188,0 +198,1 @@\n+static void verify_frame_kind(frame& top, Continuation::preempt_kind preempt_kind, Method** m_ptr = nullptr, const char** code_name_ptr = nullptr, int* bci_ptr = nullptr, stackChunkOop chunk = nullptr);\n@@ -465,1 +476,1 @@\n-  static inline void prepare_freeze_interpreted_top_frame(frame& f);\n+  inline void prepare_freeze_interpreted_top_frame(frame& f);\n@@ -1093,2 +1104,2 @@\n-    frame f = _thread->last_frame();\n-    if (f.is_interpreted_frame()) {\n+    frame top_frame = _thread->last_frame();\n+    if (top_frame.is_interpreted_frame()) {\n@@ -1099,1 +1110,15 @@\n-      prepare_freeze_interpreted_top_frame(f);\n+      prepare_freeze_interpreted_top_frame(top_frame);\n+    }\n+\n+    \/\/ Do this now so should_process_args_at_top() is set before calling finish_freeze\n+    \/\/ in case we might need to apply GC barriers to frames in this stackChunk.\n+    if (_thread->at_preemptable_init()) {\n+      assert(top_frame.is_interpreted_frame(), \"only InterpreterRuntime::_new\/resolve_from_cache allowed\");\n+      chunk->set_at_klass_init(true);\n+      methodHandle m(_thread, top_frame.interpreter_frame_method());\n+      Bytecode_invoke call = Bytecode_invoke_check(m, top_frame.interpreter_frame_bci());\n+      assert(!call.is_valid() || call.is_invokestatic(), \"only invokestatic allowed\");\n+      if (call.is_invokestatic() && call.size_of_parameters() > 0) {\n+        assert(top_frame.interpreter_frame_expression_stack_size() > 0, \"should have parameters in exp stack\");\n+        chunk->set_has_args_at_top(true);\n+      }\n@@ -1634,0 +1659,19 @@\n+class AnchorMark : public StackObj {\n+  JavaThread* _current;\n+  frame& _top_frame;\n+  intptr_t* _last_sp_from_frame;\n+  bool _is_interpreted;\n+\n+ public:\n+  AnchorMark(JavaThread* current, frame& f) : _current(current), _top_frame(f), _is_interpreted(false) {\n+    intptr_t* sp = anchor_mark_set_pd();\n+    set_anchor(_current, sp);\n+  }\n+  ~AnchorMark() {\n+    clear_anchor(_current);\n+    anchor_mark_clear_pd();\n+  }\n+  inline intptr_t* anchor_mark_set_pd();\n+  inline void anchor_mark_clear_pd();\n+};\n+\n@@ -1652,2 +1696,3 @@\n-  if (!cont.entry()->is_virtual_thread() && JvmtiExport::has_frame_pops(thread)) {\n-    int num_frames = num_java_frames(cont);\n+  if (!cont.entry()->is_virtual_thread()) {\n+    if (JvmtiExport::has_frame_pops(thread)) {\n+      int num_frames = num_java_frames(cont);\n@@ -1655,2 +1700,4 @@\n-    ContinuationWrapper::SafepointOp so(Thread::current(), cont);\n-    JvmtiExport::continuation_yield_cleanup(JavaThread::current(), num_frames);\n+      ContinuationWrapper::SafepointOp so(Thread::current(), cont);\n+      JvmtiExport::continuation_yield_cleanup(thread, num_frames);\n+    }\n+    invalidate_jvmti_stack(thread);\n@@ -1658,1 +1705,0 @@\n-  invalidate_jvmti_stack(thread);\n@@ -1661,1 +1707,1 @@\n-static void jvmti_mount_end(JavaThread* current, ContinuationWrapper& cont, frame top) {\n+static void jvmti_mount_end(JavaThread* current, ContinuationWrapper& cont, frame top, Continuation::preempt_kind pk) {\n@@ -1664,1 +1710,1 @@\n-  HandleMarkCleaner hm(current);\n+  HandleMarkCleaner hm(current);  \/\/ Cleanup all handles (including so._conth) before returning to Java.\n@@ -1666,1 +1712,0 @@\n-\n@@ -1668,3 +1713,1 @@\n-\n-  \/\/ Since we might safepoint set the anchor so that the stack can be walked.\n-  set_anchor(current, top.sp());\n+  AnchorMark am(current, top);  \/\/ Set anchor so that the stack is walkable.\n@@ -1676,1 +1719,4 @@\n-      JvmtiExport::post_monitor_contended_entered(current, current->contended_entered_monitor());\n+      \/\/ No monitor JVMTI events for ObjectLocker case.\n+      if (pk != Continuation::object_locker) {\n+        JvmtiExport::post_monitor_contended_entered(current, current->contended_entered_monitor());\n+      }\n@@ -1680,2 +1726,0 @@\n-\n-  clear_anchor(current);\n@@ -1704,0 +1748,103 @@\n+\n+static void verify_frame_kind(frame& top, Continuation::preempt_kind preempt_kind, Method** m_ptr, const char** code_name_ptr, int* bci_ptr, stackChunkOop chunk) {\n+  Method* m;\n+  const char* code_name;\n+  int bci;\n+  if (preempt_kind == Continuation::monitorenter) {\n+    assert(top.is_interpreted_frame() || top.is_runtime_frame(), \"unexpected %sframe\",\n+      top.is_compiled_frame() ? \"compiled \" : top.is_native_frame() ? \"native \" : \"\");\n+    bool at_sync_method;\n+    if (top.is_interpreted_frame()) {\n+      m = top.interpreter_frame_method();\n+      assert(!m->is_native() || m->is_synchronized(), \"invalid method %s\", m->external_name());\n+      address bcp = top.interpreter_frame_bcp();\n+      assert(bcp != 0 || m->is_native(), \"\");\n+      at_sync_method = m->is_synchronized() && (bcp == 0 || bcp == m->code_base());\n+      \/\/ bcp is advanced on monitorenter before making the VM call, adjust for that.\n+      bool at_sync_bytecode = bcp > m->code_base() && Bytecode(m, bcp - 1).code() == Bytecodes::Code::_monitorenter;\n+      assert(at_sync_method || at_sync_bytecode, \"\");\n+      bci = at_sync_method ? -1 : top.interpreter_frame_bci();\n+    } else {\n+      JavaThread* current = JavaThread::current();\n+      ResourceMark rm(current);\n+      CodeBlob* cb = top.cb();\n+      RegisterMap reg_map(current,\n+                  RegisterMap::UpdateMap::skip,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::include);\n+      if (top.is_heap_frame()) {\n+        assert(chunk != nullptr, \"\");\n+        reg_map.set_stack_chunk(chunk);\n+        top = chunk->relativize(top);\n+        top.set_frame_index(0);\n+      }\n+      frame fr = top.sender(&reg_map);\n+      vframe*  vf  = vframe::new_vframe(&fr, &reg_map, current);\n+      compiledVFrame* cvf = compiledVFrame::cast(vf);\n+      m = cvf->method();\n+      bci = cvf->scope()->bci();\n+      at_sync_method = bci == SynchronizationEntryBCI;\n+      assert(!at_sync_method || m->is_synchronized(), \"bci is %d but method %s is not synchronized\", bci, m->external_name());\n+      bool is_c1_monitorenter = false, is_c2_monitorenter = false;\n+      COMPILER1_PRESENT(is_c1_monitorenter = cb == Runtime1::blob_for(StubId::c1_monitorenter_id) ||\n+                                             cb == Runtime1::blob_for(StubId::c1_monitorenter_nofpu_id);)\n+      COMPILER2_PRESENT(is_c2_monitorenter = cb == CodeCache::find_blob(OptoRuntime::complete_monitor_locking_Java());)\n+      assert(is_c1_monitorenter || is_c2_monitorenter, \"wrong runtime stub frame\");\n+    }\n+    code_name = at_sync_method ? \"synchronized method\" : \"monitorenter\";\n+  } else if (preempt_kind == Continuation::object_wait) {\n+    assert(top.is_interpreted_frame() || top.is_native_frame(), \"\");\n+    m  = top.is_interpreted_frame() ? top.interpreter_frame_method() : top.cb()->as_nmethod()->method();\n+    assert(m->is_object_wait0(), \"\");\n+    bci = 0;\n+    code_name = \"\";\n+  } else {\n+    assert(preempt_kind == Continuation::object_locker, \"invalid preempt kind\");\n+    assert(top.is_interpreted_frame(), \"\");\n+    m = top.interpreter_frame_method();\n+    Bytecode current_bytecode = Bytecode(m, top.interpreter_frame_bcp());\n+    Bytecodes::Code code = current_bytecode.code();\n+    assert(code == Bytecodes::Code::_new || code == Bytecodes::Code::_invokestatic ||\n+           (code == Bytecodes::Code::_getstatic || code == Bytecodes::Code::_putstatic), \"invalid bytecode\");\n+    bci = top.interpreter_frame_bci();\n+    code_name = Bytecodes::name(current_bytecode.code());\n+  }\n+  assert(bci >= 0 || m->is_synchronized(), \"invalid bci:%d at method %s\", bci, m->external_name());\n+\n+  if (m_ptr != nullptr) {\n+    *m_ptr = m;\n+    *code_name_ptr = code_name;\n+    *bci_ptr = bci;\n+  }\n+}\n+\n+static void log_preempt_after_freeze(const ContinuationWrapper& cont) {\n+  JavaThread* current = cont.thread();\n+  int64_t tid = current->monitor_owner_id();\n+\n+  StackChunkFrameStream<ChunkFrames::Mixed> sfs(cont.tail());\n+  frame top_frame = sfs.to_frame();\n+  bool at_init = current->at_preemptable_init();\n+  bool at_enter = current->current_pending_monitor() != nullptr;\n+  bool at_wait = current->current_waiting_monitor() != nullptr;\n+  assert((at_enter && !at_wait) || (!at_enter && at_wait), \"\");\n+  Continuation::preempt_kind pk = at_init ? Continuation::object_locker : at_enter ? Continuation::monitorenter : Continuation::object_wait;\n+\n+  Method* m = nullptr;\n+  const char* code_name = nullptr;\n+  int bci = InvalidFrameStateBci;\n+  verify_frame_kind(top_frame, pk, &m, &code_name, &bci, cont.tail());\n+  assert(m != nullptr && code_name != nullptr && bci != InvalidFrameStateBci, \"should be set\");\n+\n+  ResourceMark rm(current);\n+  if (bci < 0) {\n+    log_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" while synchronizing on %smethod %s\", tid, m->is_native() ? \"native \" : \"\", m->external_name());\n+  } else if (m->is_object_wait0()) {\n+    log_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" at native method %s\", tid, m->external_name());\n+  } else {\n+    Klass* k = current->preempt_init_klass();\n+    assert(k != nullptr || !at_init, \"\");\n+    log_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" at %s(bci:%d) in method %s %s%s\", tid, code_name, bci,\n+            m->external_name(), at_init ? \"trying to initialize klass \" : \"\", at_init ? k->external_name() : \"\");\n+  }\n+}\n@@ -1733,0 +1880,1 @@\n+  \/\/ Set up things so that on return to Java we jump to preempt stub.\n@@ -1735,1 +1883,1 @@\n-\n+  DEBUG_ONLY(log_preempt_after_freeze(cont);)\n@@ -1931,0 +2079,1 @@\n+  bool _process_args_at_top;\n@@ -1935,0 +2084,3 @@\n+  \/\/ Only used for preemption on ObjectLocker\n+  ObjectMonitor* _init_lock;\n+\n@@ -1962,0 +2114,2 @@\n+  inline intptr_t* push_preempt_adapter();\n+  intptr_t* redo_vmcall(JavaThread* current, frame& top);\n@@ -1978,1 +2132,1 @@\n-  NOINLINE void recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames);\n+  NOINLINE void recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames, bool is_top);\n@@ -1983,1 +2137,1 @@\n-  void push_return_frame(frame& f);\n+  void push_return_frame(const frame& f);\n@@ -2066,1 +2220,1 @@\n-    f.next(SmallRegisterMap::instance(), false \/* stop *\/);\n+    f.next(SmallRegisterMap::instance_no_args(), false \/* stop *\/);\n@@ -2092,1 +2246,1 @@\n-    f.next(SmallRegisterMap::instance(), true \/* stop *\/);\n+    f.next(SmallRegisterMap::instance_no_args(), true \/* stop *\/);\n@@ -2114,1 +2268,1 @@\n-  f.next(SmallRegisterMap::instance(), true \/* stop *\/);\n+  f.next(SmallRegisterMap::instance_no_args(), true \/* stop *\/);\n@@ -2246,2 +2400,0 @@\n-  set_anchor(_thread, rs.sp());\n-  log_frames(_thread);\n@@ -2249,0 +2401,3 @@\n+    frame top(rs.sp());\n+    AnchorMark am(_thread, top);\n+    log_frames(_thread);\n@@ -2251,1 +2406,0 @@\n-  clear_anchor(_thread);\n@@ -2274,0 +2428,1 @@\n+  _process_args_at_top = false;\n@@ -2276,0 +2431,1 @@\n+    ObjectMonitor* mon = nullptr;\n@@ -2280,2 +2436,2 @@\n-      ObjectMonitor* mon = waiter->monitor();\n-      preempt_kind = waiter->is_wait() ? Continuation::freeze_on_wait : Continuation::freeze_on_monitorenter;\n+      mon = waiter->monitor();\n+      preempt_kind = waiter->is_wait() ? Continuation::object_wait : Continuation::monitorenter;\n@@ -2287,0 +2443,1 @@\n+        log_develop_trace(continuations, preempt)(\"Failed to acquire monitor, unmounting again\");\n@@ -2290,0 +2447,1 @@\n+      JVMTI_ONLY(assert(_thread->contended_entered_monitor() == nullptr || _thread->contended_entered_monitor() == mon, \"\"));\n@@ -2291,3 +2449,6 @@\n-      \/\/ Preemption cancelled in moniterenter case. We actually acquired\n-      \/\/ the monitor after freezing all frames so nothing to do.\n-      preempt_kind = Continuation::freeze_on_monitorenter;\n+      \/\/ Preemption cancelled on moniterenter or ObjectLocker case. We\n+      \/\/ actually acquired the monitor after freezing all frames so no\n+      \/\/ need to call resume_operation. If this is the ObjectLocker case\n+      \/\/ we released the monitor already at ~ObjectLocker, so _init_lock\n+      \/\/ will be set to nullptr below since there is no monitor to release.\n+      preempt_kind = Continuation::monitorenter;\n@@ -2295,0 +2456,1 @@\n+\n@@ -2297,0 +2459,12 @@\n+\n+    if (chunk->at_klass_init()) {\n+      preempt_kind = Continuation::object_locker;\n+      chunk->set_at_klass_init(false);\n+      _process_args_at_top = chunk->has_args_at_top();\n+      if (_process_args_at_top) {\n+        \/\/ Only needed for the top frame which will be thawed.\n+        chunk->set_has_args_at_top(false);\n+      }\n+      assert(waiter == nullptr || mon != nullptr, \"should have a monitor\");\n+      _init_lock = mon;  \/\/ remember monitor since we will need it on handle_preempted_continuation()\n+    }\n@@ -2357,1 +2531,1 @@\n-  JVMTI_ONLY(invalidate_jvmti_stack(_thread));\n+  JVMTI_ONLY(if (!_cont.entry()->is_virtual_thread()) invalidate_jvmti_stack(_thread));\n@@ -2380,1 +2554,1 @@\n-    recurse_thaw_interpreted_frame(heap_frame, caller, num_frames);\n+    recurse_thaw_interpreted_frame(heap_frame, caller, num_frames, top_on_preempt_case);\n@@ -2393,1 +2567,1 @@\n-  _stream.next(SmallRegisterMap::instance());\n+  _stream.next(SmallRegisterMap::instance_no_args());\n@@ -2503,1 +2677,0 @@\n-  assert(preempt_kind == Continuation::freeze_on_wait || preempt_kind == Continuation::freeze_on_monitorenter, \"\");\n@@ -2506,0 +2679,2 @@\n+  DEBUG_ONLY(verify_frame_kind(top, preempt_kind);)\n+  NOT_PRODUCT(int64_t tid = _thread->monitor_owner_id();)\n@@ -2513,1 +2688,1 @@\n-      jvmti_mount_end(_thread, _cont, top);\n+      jvmti_mount_end(_thread, _cont, top, preempt_kind);\n@@ -2530,1 +2705,1 @@\n-  if (preempt_kind == Continuation::freeze_on_wait) {\n+  if (preempt_kind == Continuation::object_wait) {\n@@ -2532,1 +2707,2 @@\n-    if (_thread->pending_interrupted_exception()) {\n+    bool throw_ie = _thread->pending_interrupted_exception();\n+    if (throw_ie) {\n@@ -2536,5 +2712,68 @@\n-  } else if (top.is_runtime_frame()) {\n-    \/\/ The continuation might now run on a different platform thread than the previous time so\n-    \/\/ we need to adjust the current thread saved in the stub frame before restoring registers.\n-    JavaThread** thread_addr = frame::saved_thread_address(top);\n-    if (thread_addr != nullptr) *thread_addr = _thread;\n+    log_develop_trace(continuations, preempt)(\"Resuming \" INT64_FORMAT\" after preemption on Object.wait%s\", tid, throw_ie ? \"(throwing IE)\" : \"\");\n+  } else if (preempt_kind == Continuation::monitorenter) {\n+    if (top.is_runtime_frame()) {\n+      \/\/ The continuation might now run on a different platform thread than the previous time so\n+      \/\/ we need to adjust the current thread saved in the stub frame before restoring registers.\n+      JavaThread** thread_addr = frame::saved_thread_address(top);\n+      if (thread_addr != nullptr) *thread_addr = _thread;\n+    }\n+    log_develop_trace(continuations, preempt)(\"Resuming \" INT64_FORMAT \" after preemption on monitorenter\", tid);\n+  } else {\n+    \/\/ We need to redo the original call into the VM. First though, we need\n+    \/\/ to exit the monitor we just acquired (except on preemption cancelled\n+    \/\/ case where it was already released).\n+    assert(preempt_kind == Continuation::object_locker, \"\");\n+    if (_init_lock != nullptr) _init_lock->exit(_thread);\n+    sp = redo_vmcall(_thread, top);\n+  }\n+  return sp;\n+}\n+\n+intptr_t* ThawBase::redo_vmcall(JavaThread* current, frame& top) {\n+  assert(!current->preempting(), \"\");\n+  NOT_PRODUCT(int64_t tid = current->monitor_owner_id();)\n+  intptr_t* sp = top.sp();\n+\n+  {\n+    HandleMarkCleaner hmc(current);  \/\/ Cleanup all handles (including so._conth) before returning to Java.\n+    ContinuationWrapper::SafepointOp so(current, _cont);\n+    AnchorMark am(current, top);    \/\/ Set the anchor so that the stack is walkable.\n+\n+    Method* m = top.interpreter_frame_method();\n+    Bytecode current_bytecode = Bytecode(m, top.interpreter_frame_bcp());\n+    Bytecodes::Code code = current_bytecode.code();\n+    log_develop_trace(continuations, preempt)(\"Redoing InterpreterRuntime::%s for \" INT64_FORMAT, code == Bytecodes::Code::_new ? \"_new\" : \"resolve_from_cache\", tid);\n+\n+    \/\/ These InterpreterRuntime entry points use JRT_ENTRY which uses a HandleMarkCleaner.\n+    \/\/ Create a HandeMark to avoid destroying so._conth.\n+    HandleMark hm(current);\n+    DEBUG_ONLY(JavaThread::AtRedoVMCall apvmc(current);)\n+    if (code == Bytecodes::Code::_new) {\n+      InterpreterRuntime::_new(current, m->constants(), current_bytecode.get_index_u2(code));\n+    } else {\n+      InterpreterRuntime::resolve_from_cache(current, code);\n+    }\n+  }\n+\n+  if (current->preempting()) {\n+    \/\/ Preempted again so we just arrange to return to preempt stub to unmount.\n+    sp = push_preempt_adapter();\n+    current->set_preempt_alternate_return(nullptr);\n+    bool cancelled = current->preemption_cancelled();\n+    if (cancelled) {\n+      \/\/ Since preemption was cancelled, the thread will call thaw again from the preempt\n+      \/\/ stub. These retries could happen several times due to contention on the init_lock,\n+      \/\/ so just let the vthread umount to give a chance for other vthreads to run.\n+      current->set_preemption_cancelled(false);\n+      oop vthread = current->vthread();\n+      assert(java_lang_VirtualThread::state(vthread) == java_lang_VirtualThread::RUNNING, \"wrong state for vthread\");\n+      java_lang_VirtualThread::set_state(vthread, java_lang_VirtualThread::YIELDING);\n+#if INCLUDE_JVMTI\n+      if (current->contended_entered_monitor() != nullptr) {\n+        current->set_contended_entered_monitor(nullptr);\n+      }\n+#endif\n+    }\n+    log_develop_trace(continuations, preempt)(\"Preempted \" INT64_FORMAT \" again%s\", tid, cancelled ? \"(preemption cancelled, setting state to YIELDING)\" : \"\");\n+  } else {\n+    log_develop_trace(continuations, preempt)(\"Call succesful, resuming \" INT64_FORMAT, tid);\n@@ -2546,0 +2785,1 @@\n+  HandleMarkCleaner hm(current);  \/\/ Cleanup all handles (including so._conth) before returning to Java.\n@@ -2547,2 +2787,1 @@\n-  \/\/ Since we might safepoint set the anchor so that the stack can be walked.\n-  set_anchor(current, top.sp());\n+  AnchorMark am(current, top);  \/\/ Set the anchor so that the stack is walkable.\n@@ -2552,1 +2791,0 @@\n-  clear_anchor(current);\n@@ -2555,1 +2793,1 @@\n-NOINLINE void ThawBase::recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames) {\n+NOINLINE void ThawBase::recurse_thaw_interpreted_frame(const frame& hf, frame& caller, int num_frames, bool is_top) {\n@@ -2559,1 +2797,5 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n+    if (is_top && _process_args_at_top) {\n+      _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_with_args());\n+    } else {\n+      _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_no_args());\n+    }\n@@ -2604,1 +2846,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance_no_args());\n@@ -2621,1 +2863,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_no_args());\n@@ -2687,1 +2929,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance_no_args());\n@@ -2713,1 +2955,1 @@\n-    _stream.next(SmallRegisterMap::instance());\n+    _stream.next(SmallRegisterMap::instance_no_args());\n@@ -2753,1 +2995,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance_no_args());\n@@ -2791,1 +3033,1 @@\n-  _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n+  _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance_no_args());\n@@ -2818,1 +3060,6 @@\n-  chunk->fix_thawed_frame(f, SmallRegisterMap::instance()); \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n+   \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n+  if (_process_args_at_top) {\n+    chunk->fix_thawed_frame(f, SmallRegisterMap::instance_with_args());\n+  } else {\n+    chunk->fix_thawed_frame(f, SmallRegisterMap::instance_no_args());\n+  }\n@@ -2832,1 +3079,1 @@\n-void ThawBase::push_return_frame(frame& f) { \/\/ see generate_cont_thaw\n+void ThawBase::push_return_frame(const frame& f) { \/\/ see generate_cont_thaw\n@@ -2880,1 +3127,0 @@\n-  DEBUG_ONLY(bool preempted = cont.tail()->preempted();)\n@@ -2884,1 +3130,1 @@\n-  DEBUG_ONLY(log_frames_after_thaw(thread, cont, sp, preempted);)\n+  DEBUG_ONLY(log_frames_after_thaw(thread, cont, sp);)\n@@ -3026,1 +3272,1 @@\n-static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp, bool preempted) {\n+static void log_frames_after_thaw(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp) {\n@@ -3030,1 +3276,3 @@\n-  if (preempted && sp0 == cont.entrySP()) {\n+  bool preempted = false;\n+  stackChunkOop tail = cont.tail();\n+  if (tail != nullptr && tail->preempted()) {\n@@ -3032,1 +3280,0 @@\n-    assert(cont.tail()->preempted(), \"\");\n@@ -3034,0 +3281,1 @@\n+    preempted = true;\n@@ -3042,1 +3290,1 @@\n-  assert(ContinuationEntry::assert_entry_frame_laid_out(thread), \"\");\n+  assert(preempted || ContinuationEntry::assert_entry_frame_laid_out(thread), \"\");\n@@ -3113,1 +3361,1 @@\n-      FOR_EACH_CONCRETE_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n+      FOR_EACH_BARRIER_SET_DO(BARRIER_SET_RESOLVE_BARRIER_CLOSURE)\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":315,"deletions":67,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+int jdk_internal_vm_StackChunk::_atKlassInit_offset;\n+int jdk_internal_vm_StackChunk::_hasArgsAtTop_offset;\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+  macro(jdk_internal_vm_StackChunk, atKlassInit,     bool_signature,         false) \\\n+  macro(jdk_internal_vm_StackChunk, hasArgsAtTop,    bool_signature,         false) \\\n@@ -91,0 +93,2 @@\n+  static int _atKlassInit_offset;\n+  static int _hasArgsAtTop_offset;\n@@ -132,0 +136,6 @@\n+  static inline bool atKlassInit(oop chunk);\n+  static inline void set_atKlassInit(oop chunk, bool value);\n+\n+  static inline bool hasArgsAtTop(oop chunk);\n+  static inline void set_hasArgsAtTop(oop chunk, bool value);\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -197,0 +197,16 @@\n+inline bool jdk_internal_vm_StackChunk::atKlassInit(oop chunk) {\n+  return chunk->bool_field(_atKlassInit_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_atKlassInit(oop chunk, bool value) {\n+  chunk->bool_field_put(_atKlassInit_offset, (jboolean)value);\n+}\n+\n+inline bool jdk_internal_vm_StackChunk::hasArgsAtTop(oop chunk) {\n+  return chunk->bool_field(_hasArgsAtTop_offset);\n+}\n+\n+inline void jdk_internal_vm_StackChunk::set_hasArgsAtTop(oop chunk, bool value) {\n+  chunk->bool_field_put(_hasArgsAtTop_offset, (jboolean)value);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -549,0 +549,3 @@\n+  if (exec_mode == Unpack_deopt) {\n+    assert(deoptee.is_deoptimized_frame(), \"frame is not marked for deoptimization\");\n+  }\n@@ -1455,0 +1458,3 @@\n+#if INCLUDE_JVMCI\n+      \/\/ big_value allows encoding double\/long value as e.g. [int = 0, long], and storing\n+      \/\/ the value in two array elements.\n@@ -1482,0 +1488,3 @@\n+#else \/\/ not INCLUDE_JVMCI\n+      obj->int_at_put(index, value->get_jint());\n+#endif \/\/ INCLUDE_JVMCI\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_entry() - pc_return_offset;\n@@ -362,1 +362,1 @@\n-  address deopt = nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_entry();\n@@ -921,1 +921,2 @@\n-void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) const {\n+template <typename RegisterMapT>\n+void frame::oops_interpreted_do(OopClosure* f, const RegisterMapT* map, bool query_oop_map_cache) const {\n@@ -958,3 +959,0 @@\n-  Symbol* signature = nullptr;\n-  bool has_receiver = false;\n-\n@@ -965,1 +963,1 @@\n-  if (!m->is_native()) {\n+  if (!m->is_native() && map != nullptr && map->include_argument_oops()) {\n@@ -967,18 +965,7 @@\n-    if (map != nullptr && call.is_valid()) {\n-      signature = call.signature();\n-      has_receiver = call.has_receiver();\n-      if (map->include_argument_oops() &&\n-          interpreter_frame_expression_stack_size() > 0) {\n-        ResourceMark rm(thread);  \/\/ is this right ???\n-        \/\/ we are at a call site & the expression stack is not empty\n-        \/\/ => process callee's arguments\n-        \/\/\n-        \/\/ Note: The expression stack can be empty if an exception\n-        \/\/       occurred during method resolution\/execution. In all\n-        \/\/       cases we empty the expression stack completely be-\n-        \/\/       fore handling the exception (the exception handling\n-        \/\/       code in the interpreter calls a blocking runtime\n-        \/\/       routine which can cause this code to be executed).\n-        \/\/       (was bug gri 7\/27\/98)\n-        oops_interpreted_arguments_do(signature, has_receiver, f);\n-      }\n+    if (call.is_valid() && interpreter_frame_expression_stack_size() > 0) {\n+      ResourceMark rm(thread);  \/\/ is this right ???\n+      Symbol* signature = call.signature();\n+      bool has_receiver = call.has_receiver();\n+      \/\/ We are at a call site & the expression stack is not empty\n+      \/\/ so we might have callee arguments we need to process.\n+      oops_interpreted_arguments_do(signature, has_receiver, f);\n@@ -1018,0 +1005,4 @@\n+template void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) const;\n+template void frame::oops_interpreted_do(OopClosure* f, const SmallRegisterMapNoArgs* map, bool query_oop_map_cache) const;\n+template void frame::oops_interpreted_do(OopClosure* f, const SmallRegisterMapWithArgs* map, bool query_oop_map_cache) const;\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -459,1 +459,2 @@\n-  void oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache = true) const;\n+  template <typename RegisterMapT>\n+  void oops_interpreted_do(OopClosure* f, const RegisterMapT* map, bool query_oop_map_cache = true) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -725,0 +725,2 @@\n+  \/\/ Tell code inspecting handshakee's stack what we are doing\n+  ThrowingUnsafeAccessError tuae(_handshakee);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  assert(!thread->preempting(), \"Unexpected Java upcall whilst processing preemption\");\n@@ -247,1 +248,1 @@\n-  LinkResolver::resolve_static_call(callinfo, link_info, true, CHECK);\n+  LinkResolver::resolve_static_call(callinfo, link_info, ClassInitMode::init, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -448,0 +448,1 @@\n+  _throwing_unsafe_access_error(false),\n@@ -497,0 +498,4 @@\n+  _at_preemptable_init(false),\n+  DEBUG_ONLY(_preempt_init_klass(nullptr) COMMA)\n+  DEBUG_ONLY(_interp_at_preemptable_vmcall_cnt(0) COMMA)\n+  DEBUG_ONLY(_interp_redoing_vm_call(false) COMMA)\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -321,0 +321,1 @@\n+  volatile bool         _throwing_unsafe_access_error;   \/\/ Thread has faulted and is throwing an exception\n@@ -488,0 +489,3 @@\n+  \/\/ We allow preemption on some klass initialization calls.\n+  \/\/ We use this boolean to mark such calls.\n+  bool _at_preemptable_init;\n@@ -496,1 +500,1 @@\n-  bool preempting()           { return _preempt_alternate_return != nullptr; }\n+  bool preempting()                              { return _preempt_alternate_return != nullptr; }\n@@ -499,1 +503,35 @@\n-private:\n+  bool at_preemptable_init()           { return _at_preemptable_init; }\n+  void set_at_preemptable_init(bool b) { _at_preemptable_init = b; }\n+\n+#ifdef ASSERT\n+  \/\/ Used for extra logging with -Xlog:continuation+preempt\n+  InstanceKlass* _preempt_init_klass;\n+\n+  InstanceKlass* preempt_init_klass() { return _preempt_init_klass; }\n+  void set_preempt_init_klass(InstanceKlass* ik) { _preempt_init_klass = ik; }\n+\n+  int _interp_at_preemptable_vmcall_cnt;\n+  int interp_at_preemptable_vmcall_cnt() { return _interp_at_preemptable_vmcall_cnt; }\n+\n+  bool _interp_redoing_vm_call;\n+  bool interp_redoing_vm_call() const { return _interp_redoing_vm_call; };\n+\n+  class AtRedoVMCall : public StackObj {\n+    JavaThread* _thread;\n+   public:\n+    AtRedoVMCall(JavaThread* t) : _thread(t) {\n+      assert(!_thread->_interp_redoing_vm_call, \"\");\n+      _thread->_interp_redoing_vm_call = true;\n+      _thread->_interp_at_preemptable_vmcall_cnt++;\n+      assert(_thread->_interp_at_preemptable_vmcall_cnt > 0, \"Unexpected count: %d\",\n+             _thread->_interp_at_preemptable_vmcall_cnt);\n+    }\n+    ~AtRedoVMCall() {\n+      assert(_thread->_interp_redoing_vm_call, \"\");\n+      _thread->_interp_redoing_vm_call = false;\n+      _thread->_interp_at_preemptable_vmcall_cnt--;\n+      assert(_thread->_interp_at_preemptable_vmcall_cnt >= 0, \"Unexpected count: %d\",\n+             _thread->_interp_at_preemptable_vmcall_cnt);\n+    }\n+  };\n+#endif \/\/ ASSERT\n@@ -501,0 +539,1 @@\n+private:\n@@ -626,0 +665,3 @@\n+  bool is_throwing_unsafe_access_error()          { return _throwing_unsafe_access_error; }\n+  void set_throwing_unsafe_access_error(bool val) { _throwing_unsafe_access_error = val; }\n+\n@@ -889,0 +931,1 @@\n+  DEBUG_ONLY(static ByteSize interp_at_preemptable_vmcall_cnt_offset() { return byte_offset_of(JavaThread, _interp_at_preemptable_vmcall_cnt); })\n@@ -1334,2 +1377,2 @@\n-  NoPreemptMark(JavaThread* thread) : _ce(thread->last_continuation()), _unpin(false) {\n-    if (_ce != nullptr) _unpin = _ce->pin();\n+  NoPreemptMark(JavaThread* thread, bool ignore_mark = false) : _ce(thread->last_continuation()), _unpin(false) {\n+    if (_ce != nullptr && !ignore_mark) _unpin = _ce->pin();\n@@ -1362,0 +1405,14 @@\n+class ThrowingUnsafeAccessError : public StackObj {\n+  JavaThread* _thread;\n+  bool _prev;\n+public:\n+  ThrowingUnsafeAccessError(JavaThread* thread) :\n+      _thread(thread),\n+      _prev(thread->is_throwing_unsafe_access_error()) {\n+    _thread->set_throwing_unsafe_access_error(true);\n+  }\n+  ~ThrowingUnsafeAccessError() {\n+    _thread->set_throwing_unsafe_access_error(_prev);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -46,2 +47,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+  _object_strong.release(JavaThread::thread_oop_storage());\n@@ -314,0 +315,14 @@\n+\/\/ Keep object protected during ObjectLocker preemption.\n+void ObjectMonitor::set_object_strong() {\n+  check_object_context();\n+  if (_object_strong.is_empty()) {\n+    if (AtomicAccess::cmpxchg(&_object_strong_lock, 0, 1) == 0) {\n+      if (_object_strong.is_empty()) {\n+        assert(_object.resolve() != nullptr, \"\");\n+        _object_strong = OopHandle(JavaThread::thread_oop_storage(), _object.resolve());\n+      }\n+      AtomicAccess::release_store(&_object_strong_lock, 0);\n+    }\n+  }\n+}\n+\n@@ -1816,1 +1831,1 @@\n-      vthread_wait(current, millis);\n+      vthread_wait(current, millis, interruptible);\n@@ -2170,1 +2185,1 @@\n-void ObjectMonitor::vthread_wait(JavaThread* current, jlong millis) {\n+void ObjectMonitor::vthread_wait(JavaThread* current, jlong millis, bool interruptible) {\n@@ -2174,0 +2189,1 @@\n+  node->_interruptible = interruptible;\n@@ -2176,0 +2192,1 @@\n+  java_lang_VirtualThread::set_interruptible_wait(vthread, interruptible);\n@@ -2220,1 +2237,1 @@\n-  node->_interrupted = !was_notified && current->is_interrupted(false);\n+  node->_interrupted = node->_interruptible && !was_notified && current->is_interrupted(false);\n@@ -2222,1 +2239,2 @@\n-  \/\/ Post JFR and JVMTI events.\n+  \/\/ Post JFR and JVMTI events. If non-interruptible we are in\n+  \/\/ ObjectLocker case so we don't post anything.\n@@ -2224,1 +2242,1 @@\n-  if (wait_event.should_commit() || JvmtiExport::should_post_monitor_waited()) {\n+  if (node->_interruptible && (wait_event.should_commit() || JvmtiExport::should_post_monitor_waited())) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  bool     _interruptible;\n@@ -203,0 +204,1 @@\n+  OopHandle _object_strong;         \/\/ Used to protect object during preemption on class initialization\n@@ -207,0 +209,1 @@\n+  volatile int _object_strong_lock; \/\/ protects setting of _object_strong\n@@ -346,0 +349,1 @@\n+  void      set_object_strong();\n@@ -408,1 +412,1 @@\n-  void      vthread_wait(JavaThread* current, jlong millis);\n+  void      vthread_wait(JavaThread* current, jlong millis, bool interruptible);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -610,0 +613,5 @@\n+#ifdef COMPILER2\n+      if (nm->compiler_type() == compiler_c2) {\n+        return OptoRuntime::exception_blob()->entry_point();\n+      }\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -30,2 +31,0 @@\n-#include <limits>\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntimeTrans.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,15 @@\n+typedef SmallRegisterMapType<false> SmallRegisterMapNoArgs;\n+typedef SmallRegisterMapType<true>  SmallRegisterMapWithArgs;\n+\n+class SmallRegisterMap : AllStatic {\n+public:\n+  static const SmallRegisterMapNoArgs* instance_no_args() {\n+    static constexpr SmallRegisterMapNoArgs the_instance{};\n+    return &the_instance;\n+  }\n+  static const SmallRegisterMapWithArgs* instance_with_args() {\n+    static constexpr SmallRegisterMapWithArgs the_instance_with_args{};\n+    return &the_instance_with_args;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/smallRegisterMap.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -83,1 +84,2 @@\n-  inline int num_oops() const;\n+  template <typename RegisterMapT>\n+  inline int num_oops(RegisterMapT* map) const;\n@@ -105,1 +107,2 @@\n-  inline int interpreter_frame_num_oops() const;\n+  template <typename RegisterMapT>\n+  inline int interpreter_frame_num_oops(RegisterMapT* map) const;\n@@ -127,0 +130,9 @@\n+class InterpreterOopCount : public OopClosure {\n+  int _count;\n+public:\n+  InterpreterOopCount() : _count(0) {}\n+  void do_oop(oop* p) override { _count++; }\n+  void do_oop(narrowOop* p) override { _count++; }\n+  int count() { return _count; }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -202,1 +202,2 @@\n-inline int StackChunkFrameStream<frame_kind>::num_oops() const {\n+template <typename RegisterMapT>\n+inline int StackChunkFrameStream<frame_kind>::num_oops(RegisterMapT* map) const {\n@@ -204,1 +205,1 @@\n-    return interpreter_frame_num_oops();\n+    return interpreter_frame_num_oops(map);\n@@ -386,1 +387,1 @@\n-    f.oops_interpreted_do(closure, nullptr, true);\n+    f.oops_interpreted_do(closure, map, true);\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-template StackValue* StackValue::create_stack_value(const frame* fr, const SmallRegisterMap* reg_map, ScopeValue* sv);\n+template StackValue* StackValue::create_stack_value(const frame* fr, const SmallRegisterMapNoArgs* reg_map, ScopeValue* sv);\n@@ -267,1 +267,1 @@\n-template address StackValue::stack_value_address(const frame* fr, const SmallRegisterMap* reg_map, ScopeValue* sv);\n+template address StackValue::stack_value_address(const frame* fr, const SmallRegisterMapNoArgs* reg_map, ScopeValue* sv);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -508,2 +508,4 @@\n-ObjectLocker::ObjectLocker(Handle obj, JavaThread* thread) : _npm(thread) {\n-  _thread = thread;\n+ObjectLocker::ObjectLocker(Handle obj, TRAPS) : _thread(THREAD), _obj(obj),\n+  _npm(_thread, _thread->at_preemptable_init() \/* ignore_mark *\/), _skip_exit(false) {\n+  assert(!_thread->preempting(), \"\");\n+\n@@ -511,1 +513,0 @@\n-  _obj = obj;\n@@ -515,0 +516,14 @@\n+\n+    if (_thread->preempting()) {\n+      \/\/ If preemption was cancelled we acquired the monitor after freezing\n+      \/\/ the frames. Redoing the vm call later in thaw will require us to\n+      \/\/ release it since the call should look like the original one. We\n+      \/\/ do it in ~ObjectLocker to reduce the window of time we hold the\n+      \/\/ monitor since we can't do anything useful with it now, and would\n+      \/\/ otherwise just force other vthreads to preempt in case they try\n+      \/\/ to acquire this monitor.\n+      _skip_exit = !_thread->preemption_cancelled();\n+      ObjectSynchronizer::read_monitor(_thread, _obj())->set_object_strong();\n+      _thread->set_pending_preempted_exception();\n+\n+    }\n@@ -519,1 +534,1 @@\n-  if (_obj() != nullptr) {\n+  if (_obj() != nullptr && !_skip_exit) {\n@@ -524,0 +539,8 @@\n+void ObjectLocker::wait_uninterruptibly(TRAPS) {\n+  ObjectSynchronizer::waitUninterruptibly(_obj, 0, _thread);\n+  if (_thread->preempting()) {\n+    _skip_exit = true;\n+    ObjectSynchronizer::read_monitor(_thread, _obj())->set_object_strong();\n+    _thread->set_pending_preempted_exception();\n+  }\n+}\n@@ -551,3 +574,1 @@\n-  if (millis < 0) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n-  }\n+  assert(millis >= 0, \"timeout value is negative\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj);\n@@ -227,0 +228,1 @@\n+  bool    _skip_exit;\n@@ -228,1 +230,1 @@\n-  ObjectLocker(Handle obj, JavaThread* current);\n+  ObjectLocker(Handle obj, TRAPS);\n@@ -232,2 +234,1 @@\n-  void wait(TRAPS)  { ObjectSynchronizer::wait(_obj, 0, CHECK); } \/\/ wait forever\n-  void wait_uninterruptibly(TRAPS)  { ObjectSynchronizer::waitUninterruptibly(_obj, 0, CHECK); } \/\/ wait forever\n+  void wait_uninterruptibly(TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj) {\n+  return ObjectSynchronizer::read_monitor(current, obj, obj->mark());\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-  _lgrp_id = -1;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -525,1 +525,0 @@\n-  int              _lgrp_id;\n@@ -540,3 +539,0 @@\n-  int     lgrp_id() const  { return _lgrp_id; }\n-  void    update_lgrp_id() { _lgrp_id = os::numa_get_group_id(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+  initialize_class(vmSymbols::jdk_internal_vm_PreemptedException(), CHECK);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-  nonstatic_field(nmethod,                     _deopt_handler_offset,                         int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_handler_entry_offset,                   int)                                   \\\n@@ -543,0 +543,1 @@\n+  nonstatic_field(nmethod,                     _immutable_data_ref_count_offset,              int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n","filename":"src\/hotspot\/share\/sanitizers\/address.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -35,3 +36,0 @@\n-#include <type_traits>\n-\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -34,2 +35,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/align.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"cppstdlib\/cstddef.hpp\"\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -32,1 +34,0 @@\n-#include <cstddef>\n@@ -34,1 +35,0 @@\n-#include <type_traits>\n","filename":"src\/hotspot\/share\/utilities\/byteswap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -40,2 +41,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,1 +32,0 @@\n-#include <type_traits>\n","filename":"src\/hotspot\/share\/utilities\/deferredStatic.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -34,2 +35,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/devirtualizer.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -687,1 +687,0 @@\n-  DebugAranges debug_aranges(this);\n@@ -689,1 +688,1 @@\n-  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+  if (!_debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n@@ -711,0 +710,64 @@\n+\/\/ Build sorted cache of all address ranges for binary search.\n+DwarfFile::DebugAranges::CacheHint DwarfFile::DebugAranges::ensure_cached() {\n+  if (_cache._failed) {\n+    return CacheHint::FAILED;\n+  }\n+  if (_cache._initialized) {\n+    return CacheHint::VALID;\n+  }\n+\n+  assert(_cache._capacity == 0, \"need fresh cache\");\n+  assert(_cache._count == 0, \"need fresh cache\");\n+  const long pos = _reader.get_position();\n+  if (!read_section_header()) {\n+    _cache.destroy(true);\n+    return CacheHint::FAILED;\n+  }\n+\n+  \/\/ Start with reasonable initial capacity to minimize number of grow\/realloc calls.\n+  \/\/ Assume ~3% of the .debug_aranges is DebugArangesSetHeader and the rest is made up of AddressDescriptors.\n+  const uintptr_t estimated_set_header_size = _size_bytes \/ 32;\n+  const size_t initial_capacity = (_size_bytes - estimated_set_header_size) \/ sizeof(AddressDescriptor);\n+  _cache._entries = NEW_C_HEAP_ARRAY_RETURN_NULL(ArangesEntry, initial_capacity, mtInternal);\n+  if (_cache._entries == nullptr) {\n+    _cache.destroy(true);\n+    _reader.set_position(pos);\n+    return CacheHint::TRY_LINEAR_SCAN;\n+  }\n+  _cache._capacity = initial_capacity;\n+  _cache._count = 0;\n+\n+  \/\/ Read all sets and their descriptors\n+  while (_reader.has_bytes_left()) {\n+    DebugArangesSetHeader set_header;\n+    if (!read_set_header(set_header)) {\n+      break;\n+    }\n+\n+    \/\/ Read all address descriptors for this set into the cache.\n+    AddressDescriptor descriptor;\n+    do {\n+      if (!read_address_descriptor(descriptor)) {\n+        _cache.destroy(true);\n+        return CacheHint::FAILED;\n+      }\n+      if (!is_terminating_entry(set_header, descriptor) && descriptor.range_length > 0 &&\n+          !_cache.add_entry(descriptor, set_header._debug_info_offset)) {\n+        _cache.destroy(true);\n+        _reader.set_position(pos);\n+        return CacheHint::TRY_LINEAR_SCAN;\n+      }\n+    } while (!is_terminating_entry(set_header, descriptor) && _reader.has_bytes_left());\n+  }\n+\n+  if (_cache._count == 0) {\n+    _cache.destroy(false);\n+    \/\/ No entries found, unusual but still valid.\n+    return CacheHint::VALID;\n+  }\n+  _cache.sort();\n+  _cache._initialized = true;\n+  DWARF_LOG_INFO(\"Built .debug_aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), _cache._count);\n+  return CacheHint::VALID;\n+}\n+\n@@ -716,0 +779,12 @@\n+  switch (ensure_cached()) {\n+    case CacheHint::VALID:\n+      return _cache.find_compilation_unit_offset(offset_in_library, compilation_unit_offset);\n+    case CacheHint::TRY_LINEAR_SCAN:\n+      break;\n+    case CacheHint::FAILED:\n+      return false;\n+  }\n+\n+  \/\/ Fall back to linear scan if building of the cache failed, which can happen\n+  \/\/ if there are C heap allocation errors.\n+  DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", _dwarf_file->filepath());\n@@ -753,0 +828,1 @@\n+  _size_bytes = shdr.sh_size;\n@@ -832,0 +908,68 @@\n+\/\/ Sort entries by beginning_address, when same then sort longest range first.\n+int DwarfFile::ArangesCache::compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b) {\n+  if (a.beginning_address < b.beginning_address) {\n+    return -1;\n+  } else if (a.beginning_address > b.beginning_address) {\n+    return 1;\n+  }\n+\n+  uintptr_t len_a = a.end_address - a.beginning_address;\n+  uintptr_t len_b = b.end_address - b.beginning_address;\n+  if (len_a < len_b) {\n+    return 1;\n+  } else if (len_a > len_b) {\n+    return -1;\n+  }\n+  return 0;\n+}\n+\n+void DwarfFile::ArangesCache::sort() {\n+  QuickSort::sort(_entries, _count, compare_aranges_entries);\n+}\n+\n+bool DwarfFile::ArangesCache::add_entry(const AddressDescriptor& descriptor, uint32_t debug_info_offset) {\n+  if (_count >= _capacity && !grow()) {\n+    return false;\n+  }\n+  _entries[_count] = ArangesEntry(\n+    descriptor.beginning_address,\n+    descriptor.beginning_address + descriptor.range_length,\n+    debug_info_offset\n+  );\n+  _count++;\n+  return true;\n+}\n+\n+bool DwarfFile::ArangesCache::grow() {\n+  size_t new_capacity = _capacity == 0 ? 128 : _capacity * 1.5;\n+  ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY_RETURN_NULL(ArangesEntry, _entries, new_capacity, mtInternal);\n+  if (new_entries == nullptr) {\n+    return false;\n+  }\n+  _entries = new_entries;\n+  _capacity = new_capacity;\n+  return true;\n+}\n+\n+bool DwarfFile::ArangesCache::find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const {\n+  if (!_initialized || _entries == nullptr || _count == 0) {\n+    return false;\n+  }\n+\n+  size_t left = 0;\n+  size_t right = _count;\n+  while (left < right) {\n+    size_t mid = left + (right - left) \/ 2;\n+    const ArangesEntry& entry = _entries[mid];\n+    if (offset_in_library < entry.beginning_address) {\n+      right = mid;\n+    } else if (offset_in_library >= entry.end_address) {\n+      left = mid + 1;\n+    } else {\n+      *compilation_unit_offset = entry.debug_info_offset;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":146,"deletions":2,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"utilities\/quickSort.hpp\"\n@@ -97,0 +98,2 @@\n+class DwarfFile;\n+class ElfFuncDescTable;\n@@ -99,2 +102,0 @@\n-class ElfFuncDescTable;\n-class DwarfFile;\n@@ -204,0 +205,1 @@\n+  DEBUG_ONLY(const char* filepath() const { return _filepath; })\n@@ -400,1 +402,0 @@\n-\n@@ -438,0 +439,57 @@\n+  \/\/ Address descriptor defining a range that is covered by a compilation unit. It is defined in section 6.1.2 after\n+  \/\/ the set header in the DWARF 4 spec.\n+  struct AddressDescriptor {\n+    uintptr_t beginning_address = 0;\n+    uintptr_t range_length = 0;\n+  };\n+\n+  \/\/ Entry in ArangesCache, corresponding to an entry in .debug_aranges section.\n+  struct ArangesEntry {\n+    uintptr_t beginning_address;\n+    uintptr_t end_address;\n+    uint32_t debug_info_offset;\n+\n+    ArangesEntry() : beginning_address(0), end_address(0), debug_info_offset(0) {}\n+    ArangesEntry(uintptr_t begin, uintptr_t end, uint32_t offset)\n+    : beginning_address(begin), end_address(end), debug_info_offset(offset) {}\n+  };\n+\n+  \/\/ Cache for .debug_aranges to enable binary search for address lookup.\n+  \/\/ DebugAranges uses this cache to resolve the compilation_unit_offset, rather than doing a linear scan on the files\n+  \/\/ in each invocation of DebugAranges::find_compilation_unit_offset.\n+  struct ArangesCache {\n+    ArangesEntry* _entries;\n+    size_t _count;\n+    size_t _capacity;\n+    bool _initialized;\n+    bool _failed;\n+\n+    ArangesCache() : _entries(nullptr), _count(0), _capacity(0), _initialized(false), _failed(false) {}\n+    ArangesCache(const ArangesCache&) = delete;\n+    ArangesCache& operator=(const ArangesCache&) = delete;\n+    ~ArangesCache() {\n+      this->free();\n+    }\n+\n+    void destroy(bool failed) {\n+      this->free();\n+      _count = 0;\n+      _capacity = 0;\n+      _failed = failed;\n+    }\n+    bool find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const;\n+    bool valid() const { return _initialized && !_failed; }\n+    bool add_entry(const AddressDescriptor& descriptor, uint32_t debug_info_offset);\n+    void sort();\n+\n+   private:\n+    static int compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b);\n+    bool grow();\n+    void free() {\n+      if (_entries != nullptr) {\n+        FREE_C_HEAP_ARRAY(ArangesEntry, _entries);\n+        _entries = nullptr;\n+      }\n+    }\n+  };\n+\n@@ -478,5 +536,9 @@\n-    \/\/ Address descriptor defining a range that is covered by a compilation unit. It is defined in section 6.1.2 after\n-    \/\/ the set header in the DWARF 4 spec.\n-    struct AddressDescriptor {\n-      uintptr_t beginning_address = 0;\n-      uintptr_t range_length = 0;\n+    enum class CacheHint {\n+      \/\/ Do not retry as linear scan won't be able to read this either.\n+      FAILED,\n+\n+      \/\/ Cache is usable, no need to fall back to linear scan.\n+      VALID,\n+\n+      \/\/ Cache is unusable, possible reasons are C heap allocation failures. Fall back to linear scan.\n+      TRY_LINEAR_SCAN,\n@@ -486,0 +548,1 @@\n+    ArangesCache _cache;\n@@ -488,0 +551,1 @@\n+    uintptr_t _size_bytes;\n@@ -502,1 +566,1 @@\n-                                          _section_start_address(0), _entry_end(0) {}\n+                                          _section_start_address(0), _size_bytes(0), _entry_end(0) {}\n@@ -504,1 +568,1 @@\n-\n+    CacheHint ensure_cached();\n@@ -887,1 +951,2 @@\n-  DwarfFile(const char* filepath) : ElfFile(filepath) {}\n+  DwarfFile(const char* filepath) : ElfFile(filepath), _debug_aranges(this) {\n+  }\n@@ -900,0 +965,3 @@\n+\n+ private:\n+  DebugAranges _debug_aranges;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":79,"deletions":11,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"cppstdlib\/limits.hpp\"\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,3 +35,0 @@\n-#include <limits>\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/enumIterator.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+  assert(_pending_exception == nullptr || !_pending_exception->is_a(vmClasses::PreemptedException_klass()),\n+         \"unexpected PreemptedException, missing NoPreemptMark?\");\n@@ -85,0 +87,24 @@\n+void ThreadShadow::set_pending_preempted_exception() {\n+  assert(!has_pending_exception(), \"\");\n+  \/\/ We always install the same pre-allocated exception since we only\n+  \/\/ want to use the TRAPS mechanism to bail out from all methods until\n+  \/\/ reaching the one using the CHECK_AND_CLEAR_PREEMPTED macro.\n+  set_pending_exception(Universe::preempted_exception_instance(), __FILE__, __LINE__);\n+}\n+\n+void ThreadShadow::clear_pending_preempted_exception() {\n+  assert(has_pending_exception(), \"\");\n+  if (pending_exception()->is_a(vmClasses::PreemptedException_klass())) {\n+    _pending_exception = nullptr;\n+    _exception_file    = nullptr;\n+    _exception_line    = 0;\n+  }\n+}\n+\n+#ifdef ASSERT\n+void ThreadShadow::check_preempted_exception() {\n+  assert(has_pending_exception(), \"\");\n+  assert(pending_exception()->is_a(vmClasses::PreemptedException_klass()), \"should only be PreemptedException\");\n+}\n+#endif\n+\n@@ -320,0 +346,5 @@\n+    \/\/ We could get here while linking or initializing a klass\n+    \/\/ from a preemptable call. Don't preempt here since before\n+    \/\/ the PreemptedException is propagated we might make an upcall\n+    \/\/ to Java to initialize the object with the cause of exception.\n+    NoPreemptMark npm(thread);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -97,0 +97,4 @@\n+  void set_pending_preempted_exception();\n+  void clear_pending_preempted_exception();\n+  void check_preempted_exception() NOT_DEBUG_RETURN;\n+\n@@ -233,0 +237,2 @@\n+#define CHECK_PREEMPTABLE                        THREAD); if (HAS_PENDING_EXCEPTION) { THREAD->check_preempted_exception(); return;       } (void)(0\n+#define CHECK_PREEMPTABLE_false                  THREAD); if (HAS_PENDING_EXCEPTION) { THREAD->check_preempted_exception(); return false; } (void)(0\n@@ -252,0 +258,4 @@\n+#define CLEAR_PENDING_PREEMPTED_EXCEPTION       (((ThreadShadow*)THREAD)->clear_pending_preempted_exception())\n+#define CHECK_AND_CLEAR_PREEMPTED               THREAD); if (HAS_PENDING_EXCEPTION) { CLEAR_PENDING_PREEMPTED_EXCEPTION; return; } (void)(0\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"cppstdlib\/cstddef.hpp\"\n+#include \"cppstdlib\/limits.hpp\"\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -37,1 +40,0 @@\n-#include <cstddef>\n@@ -39,2 +41,0 @@\n-#include <limits>\n-#include <type_traits>\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/hashTable.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -30,2 +31,0 @@\n-#include <limits>\n-\n","filename":"src\/hotspot\/share\/utilities\/intn_t.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"cppstdlib\/limits.hpp\"\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -30,3 +32,0 @@\n-#include <limits>\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/intpow.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/limits.hpp\"\n@@ -35,1 +36,0 @@\n-#include <limits>\n","filename":"src\/hotspot\/share\/utilities\/parseInteger.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/population_count.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"cppstdlib\/limits.hpp\"\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -34,3 +36,0 @@\n-#include <limits>\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,2 +34,0 @@\n-#include <type_traits>\n-\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include \"cppstdlib\/cstddef.hpp\"\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -33,1 +35,0 @@\n-#include <cstddef>\n@@ -35,1 +36,0 @@\n-#include <type_traits>\n","filename":"src\/hotspot\/share\/utilities\/reverse_bits.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include <type_traits>\n+#include \"cppstdlib\/type_traits.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/tuple.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import sun.security.util.PBKDF2Parameters;\n@@ -96,1 +97,1 @@\n-            ObjectIdentifier.of(KnownOIDs.PBKDF2WithHmacSHA1);\n+            ObjectIdentifier.of(KnownOIDs.PBKDF2);\n@@ -227,0 +228,4 @@\n+            if (pBES2_params.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"PBE parameter parsing error: \"\n+                    + \"not an ASN.1 SEQUENCE tag\");\n+            }\n@@ -230,14 +235,1 @@\n-        String kdfAlgo = parseKDF(kdf);\n-\n-        if (pBES2_params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"PBE parameter parsing error: \"\n-                + \"not an ASN.1 SEQUENCE tag\");\n-        }\n-        String cipherAlgo = parseES(pBES2_params.data.getDerValue());\n-\n-        this.pbes2AlgorithmName = \"PBEWith\" + kdfAlgo + \"And\" + cipherAlgo;\n-    }\n-\n-    private String parseKDF(DerValue keyDerivationFunc) throws IOException {\n-\n-        if (!pkcs5PBKDF2_OID.equals(keyDerivationFunc.data.getOID())) {\n+        if (!pkcs5PBKDF2_OID.equals(kdf.data.getOID())) {\n@@ -247,1 +239,1 @@\n-        if (keyDerivationFunc.tag != DerValue.tag_Sequence) {\n+        if (kdf.tag != DerValue.tag_Sequence) {\n@@ -251,15 +243,1 @@\n-        DerValue pBKDF2_params = keyDerivationFunc.data.getDerValue();\n-        if (pBKDF2_params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"PBE parameter parsing error: \"\n-                + \"not an ASN.1 SEQUENCE tag\");\n-        }\n-        DerValue specified = pBKDF2_params.data.getDerValue();\n-        \/\/ the 'specified' ASN.1 CHOICE for 'salt' is supported\n-        if (specified.tag == DerValue.tag_OctetString) {\n-            salt = specified.getOctetString();\n-        } else {\n-            \/\/ the 'otherSource' ASN.1 CHOICE for 'salt' is not supported\n-            throw new IOException(\"PBE parameter parsing error: \"\n-                + \"not an ASN.1 OCTET STRING tag\");\n-        }\n-        iCount = pBKDF2_params.data.getInteger();\n+        DerValue pBKDF2_params = kdf.data.getDerValue();\n@@ -267,5 +245,5 @@\n-        \/\/ keyLength INTEGER (1..MAX) OPTIONAL,\n-        var ksDer = pBKDF2_params.data.getOptional(DerValue.tag_Integer);\n-        if (ksDer.isPresent()) {\n-            keysize = ksDer.get().getInteger() * 8; \/\/ keysize (in bits)\n-        }\n+        var kdfParams = new PBKDF2Parameters(pBKDF2_params);\n+        String kdfAlgo = kdfParams.getPrfAlgo();\n+        salt = kdfParams.getSalt();\n+        iCount = kdfParams.getIterationCount();\n+        keysize = kdfParams.getKeyLength();\n@@ -273,25 +251,3 @@\n-        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n-        String kdfAlgo;\n-        var prfDer = pBKDF2_params.data.getOptional(DerValue.tag_Sequence);\n-        if (prfDer.isPresent()) {\n-            DerValue prf = prfDer.get();\n-            kdfAlgo_OID = prf.data.getOID();\n-            KnownOIDs o = KnownOIDs.findMatch(kdfAlgo_OID.toString());\n-            if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n-                    !o.stdName().equals(\"HmacSHA224\") &&\n-                    !o.stdName().equals(\"HmacSHA256\") &&\n-                    !o.stdName().equals(\"HmacSHA384\") &&\n-                    !o.stdName().equals(\"HmacSHA512\") &&\n-                    !o.stdName().equals(\"HmacSHA512\/224\") &&\n-                    !o.stdName().equals(\"HmacSHA512\/256\"))) {\n-                throw new IOException(\"PBE parameter parsing error: \"\n-                        + \"expecting the object identifier for a HmacSHA key \"\n-                        + \"derivation function\");\n-            }\n-            kdfAlgo = o.stdName();\n-            prf.data.getOptional(DerValue.tag_Null);\n-            prf.data.atEnd();\n-        } else {\n-            kdfAlgo = \"HmacSHA1\";\n-        }\n-        return kdfAlgo;\n+        String cipherAlgo = parseES(pBES2_params.data.getDerValue());\n+\n+        this.pbes2AlgorithmName = \"PBEWith\" + kdfAlgo + \"And\" + cipherAlgo;\n@@ -348,20 +304,3 @@\n-        DerOutputStream keyDerivationFunc = new DerOutputStream();\n-        keyDerivationFunc.putOID(pkcs5PBKDF2_OID);\n-\n-        DerOutputStream pBKDF2_params = new DerOutputStream();\n-        pBKDF2_params.putOctetString(salt); \/\/ choice: 'specified OCTET STRING'\n-        pBKDF2_params.putInteger(iCount);\n-\n-        if (keysize > 0) {\n-            pBKDF2_params.putInteger(keysize \/ 8); \/\/ derived key length (in octets)\n-        }\n-\n-        DerOutputStream prf = new DerOutputStream();\n-        \/\/ algorithm is id-hmacWith<MD>\n-        prf.putOID(kdfAlgo_OID);\n-        \/\/ parameters is 'NULL'\n-        prf.putNull();\n-        pBKDF2_params.write(DerValue.tag_Sequence, prf);\n-\n-        keyDerivationFunc.write(DerValue.tag_Sequence, pBKDF2_params);\n-        pBES2_params.write(DerValue.tag_Sequence, keyDerivationFunc);\n+        \/\/ keysize encoded as octets\n+        pBES2_params.writeBytes(PBKDF2Parameters.encode(salt, iCount,\n+                keysize\/8, kdfAlgo_OID));\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":21,"deletions":82,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {\n+public final class PBKDF2KeyImpl implements javax.crypto.interfaces.PBEKey {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2049,36 +2049,0 @@\n-    \/**\n-     * Used by StringConcatHelper via JLA. Adds the current builder count to the\n-     * accumulation of items being concatenated. If the coder for the builder is\n-     * UTF16 then upgrade the whole concatenation to UTF16.\n-     *\n-     * @param lengthCoder running accumulation of length and coder\n-     *\n-     * @return updated accumulation of length and coder\n-     *\/\n-    long mix(long lengthCoder) {\n-        return (lengthCoder + count) | ((long)coder << 32);\n-    }\n-\n-    \/**\n-     * Used by StringConcatHelper via JLA. Adds the characters in the builder value to the\n-     * concatenation buffer and then updates the running accumulation of length.\n-     *\n-     * @param lengthCoder running accumulation of length and coder\n-     * @param buffer      concatenation buffer\n-     *\n-     * @return running accumulation of length and coder minus the number of characters added\n-     *\/\n-    long prepend(long lengthCoder, byte[] buffer) {\n-        lengthCoder -= count;\n-\n-        if (lengthCoder < ((long)UTF16 << 32)) {\n-            System.arraycopy(value, 0, buffer, (int)lengthCoder, count);\n-        } else if (isLatin1(coder)) {\n-            StringUTF16.inflate(value, 0, buffer, (int)lengthCoder, count);\n-        } else {\n-            System.arraycopy(value, 0, buffer, (int)lengthCoder << 1, count << 1);\n-        }\n-\n-        return lengthCoder;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -88,1 +88,23 @@\n- * <p>Subclasses of Process should override the {@link #onExit()} and\n+ * <p>Subclasses of Process should ensure that each overridden method\n+ * invokes the superclass method.\n+ * For example, if {@linkplain #close() close} is overridden, the subclass should\n+ * ensure that {@code Process.close()} is called.\n+ * {@snippet lang = \"java\" :\n+ * public class LoggingProcess extends java.lang.Process {\n+ *     ...\n+ *     @Override\n+ *     public void close() throws IOException  {\n+ *         try {\n+ *             super.close();\n+ *         } catch (IOException ex) {\n+ *             LOGGER.log(ex);\n+*          } finally {\n+ *             LOGGER.log(\"process closed\");\n+ *         }\n+ *     }\n+ *     ...\n+ * }\n+ * }\n+ *\n+ * <p>Subclasses of Process that wrap another Process instance\n+ * should override and delegate the {@link #onExit()} and\n@@ -102,1 +124,3 @@\n- * or readers, or they have been closed.\n+ * or readers, or they have been closed. The Process {@linkplain Process#close close} method closes\n+ * all the streams and terminates the process to release the resources. Using try-with-resources\n+ * will ensure the process is terminated when the try-with-resources block exits.\n@@ -110,1 +134,1 @@\n- * <p>Streams should be {@code closed} when they are no longer needed, to avoid delaying\n+ * <p>Streams should be closed when they are no longer needed, to avoid delaying\n@@ -117,2 +141,2 @@\n- *     Process process = pb.start();\n- *     try (BufferedReader in = process.inputReader()) {\n+ *     try (Process process = pb.start();\n+ *          BufferedReader in = process.inputReader()) {\n@@ -142,1 +166,1 @@\n-public abstract class Process {\n+public abstract class Process implements Closeable {\n@@ -152,0 +176,1 @@\n+    private boolean closed;     \/\/ true if close() has been called\n@@ -158,0 +183,103 @@\n+    \/**\n+     * Closes all reader and writer streams and waits for the process to terminate.\n+     * This method is idempotent, if this {@code Process} has already been closed\n+     * invoking this method has no effect.\n+     * <p>\n+     * If the data from the process input or error streams is needed, it must be read before\n+     * calling this method. The contents of streams that have not been read to end of stream\n+     * are lost, they are discarded or ignored.\n+     * <p>\n+     * If the process exit value is of interest, then the caller must\n+     * {@linkplain #waitFor() wait for} the process to terminate before calling this method.\n+     * <p>\n+     * Streams should be closed when no longer needed.\n+     * Closing an already closed stream usually has no effect but is specific to the stream.\n+     * If an {@code IOException} occurs when closing a stream it is thrown\n+     * after the process has terminated.\n+     * Exceptions thrown by closing the streams, if any, are added to the first\n+     * {@code IOException} as {@linkplain IOException#addSuppressed suppressed exceptions}.\n+     * <p>\n+     * After the streams are closed this method {@linkplain #waitFor() waits for} the\n+     * process to terminate. If {@linkplain Thread#interrupt interrupted} while waiting\n+     * the process is {@linkplain #destroyForcibly() forcibly destroyed} and\n+     * this method continues to wait for the process to terminate.\n+     * The interrupted status is re-asserted before this method returns or\n+     * any {@code IOExceptions} are thrown.\n+     * @apiNote\n+     * Try-with-resources example to write text to a process, read back the\n+     * response, and close the streams and process:\n+     * {@snippet file=\"ProcessExamples.java\" region=example}\n+     *\n+     * @implNote\n+     * Concrete implementations that override this class are strongly encouraged to\n+     * override this method and invoke the superclass {@code close} method.\n+     *\n+     * @implSpec\n+     * This method closes the process I\/O streams and then\n+     * {@linkplain #waitFor() waits for} the process to terminate.\n+     * If {@link #waitFor() waitFor()} is {@linkplain Thread#interrupt() interrupted}\n+     * the process is {@linkplain #destroyForcibly() forcibly destroyed}\n+     * and then {@code close()} waits for the process to terminate.\n+     * @throws IOException if closing any of the streams throws an exception\n+     * @since 26\n+     *\/\n+    @Override\n+    public void close() throws IOException {\n+        synchronized(this) {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+            \/\/ Close each stream\n+            IOException ioe = quietClose(outputWriter != null ? outputWriter : getOutputStream(), null);\n+            ioe = quietClose(inputReader != null ? inputReader : getInputStream(), ioe);\n+            ioe = quietClose(errorReader != null ? errorReader : getErrorStream(), ioe);\n+\n+            \/\/ Wait for the process to terminate\n+            \/\/ If waitFor is interrupted, destroy the process\n+            \/\/ Continue waiting indefinitely for the process to terminate\n+            if (!tryWait()) {\n+                destroyForcibly();\n+                while (!tryWait()) {\n+                    continue;\n+                }\n+                \/\/ Re-assert the interrupted status\n+                Thread.currentThread().interrupt();\n+            }\n+            if (ioe != null) {\n+                throw ioe;\n+            }\n+        }\n+    }\n+\n+    \/\/ Try to wait for the process to terminate.\n+    \/\/ Return true if the process has terminated, false if wait is interrupted.\n+    private boolean tryWait() {\n+        try {\n+            waitFor();\n+            return true;\n+        } catch (InterruptedException ie) {\n+            return false;\n+        }\n+    }\n+\n+    \/\/ Quietly close.\n+    \/\/ If an IOException occurs, and it is the first, return it.\n+    \/\/ If there is no first IOException, a first IOException is created with the Throwable.\n+    \/\/ Otherwise, add the Throwable as a suppressed exception to the first.\n+    private static IOException quietClose(Closeable c, IOException firstIOE) {\n+        try {\n+            c.close();\n+            return firstIOE;\n+        } catch (Throwable th) {\n+            if (firstIOE == null && th instanceof IOException ioe) {\n+                return ioe;\n+            } else if (firstIOE == null) {\n+                firstIOE = new IOException(th);\n+            } else {\n+                firstIOE.addSuppressed(th);\n+            }\n+            return firstIOE;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":134,"deletions":6,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -171,0 +171,3 @@\n+    \/\/ true when waiting in Object.wait, false for VM internal uninterruptible Object.wait\n+    private volatile boolean interruptibleWait;\n+\n@@ -602,0 +605,1 @@\n+            boolean interruptible = interruptibleWait;\n@@ -631,1 +635,1 @@\n-            if (interrupted && compareAndSetState(newState, UNBLOCKED)) {\n+            if (interruptible && interrupted && compareAndSetState(newState, UNBLOCKED)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,4 +57,3 @@\n-     * the interface method invoked on the proxy instance.  The declaring\n-     * class of the {@code Method} object will be the interface that\n-     * the method was declared in, which may be a superinterface of the\n-     * proxy interface that the proxy class inherits the method through.\n+     * the method invoked on the proxy instance; the declaring\n+     * class of the {@code Method} object may be a proxy interface,\n+     * one of their superinterfaces, or the {@code Object} class\n@@ -64,1 +63,1 @@\n-     * or {@code null} if interface method takes no arguments.\n+     * or {@code null} if the invoked method takes no arguments.\n@@ -70,1 +69,1 @@\n-     * proxy instance.  If the declared return type of the interface\n+     * proxy instance.  If the declared return type of the invoked\n@@ -75,1 +74,1 @@\n-     * {@code null} and the interface method's return type is\n+     * {@code null} and the invoked method's return type is\n@@ -79,1 +78,1 @@\n-     * the interface method's declared return type as described above,\n+     * the invoked method's declared return type as described above,\n@@ -86,1 +85,1 @@\n-     * {@code throws} clause of the interface method or to the\n+     * {@code throws} clause of the invoked method or to the\n@@ -91,1 +90,1 @@\n-     * the interface method, then an\n+     * the invoked method, then an\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class ProcessExamples {\n+    \/\/ @start region=example\n+    void main() {\n+        try (Process p = new ProcessBuilder(\"cat\").start();\n+             var writer = p.outputWriter();\n+             var reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(IO::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.out.println(\"Process failed: \" + e);\n+        }\n+    }\n+\n+    static final String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+    \/\/ @end region=example\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/snippet-files\/ProcessExamples.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -325,1 +325,1 @@\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n+        FloatingDecimal.BinaryToASCIIBuffer fdConverter =\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4946,0 +4946,5 @@\n+        @Override\n+        public List<E> reversed() {\n+            return this;\n+        }\n+\n@@ -5313,0 +5318,12 @@\n+        public List<E> reversed() {\n+            return this;\n+        }\n+        @Override\n+        public E getFirst() {\n+            return element;\n+        }\n+        @Override\n+        public E getLast() {\n+            return element;\n+        }\n+        @Override\n@@ -5555,0 +5572,5 @@\n+        @Override\n+        public List<E> reversed() {\n+            return this;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -615,0 +615,11 @@\n+        @Override\n+        public E getFirst() {\n+            return e0;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public E getLast() {\n+            return e1 == EMPTY ? e0 : (E)e1;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,4 +62,3 @@\n- * <p> The version field holds a value that describes the type of this {@code\n- * UUID}.  There are four different basic types of UUIDs: time-based, DCE\n- * security, name-based, and randomly generated UUIDs.  These types have a\n- * version value of 1, 2, 3 and 4, respectively.\n+ * <p> See <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\">\n+ * <i>RFC 9562: Universally Unique Identifiers (UUIDs)<\/i><\/a> for the complete specification,\n+ * including the UUID format, layouts, and algorithms for creating {@code UUID}s.\n@@ -67,4 +66,4 @@\n- * <p> For more information including algorithms used to create {@code UUID}s,\n- * see <a href=\"http:\/\/www.ietf.org\/rfc\/rfc4122.txt\"> <i>RFC&nbsp;4122: A\n- * Universally Unique IDentifier (UUID) URN Namespace<\/i><\/a>, section 4.2\n- * &quot;Algorithms for Creating a Time-Based UUID&quot;.\n+ * <p> There are eight defined types of UUIDs, each identified by a version number:\n+ * time-based (version 1), DCE security (version 2), name-based with MD5 (version 3),\n+ * randomly generated (version 4), name-based with SHA-1 (version 5), reordered time-based (version 6),\n+ * Unix epoch time-based (version 7), and custom-defined layout (version 8).\n@@ -72,2 +71,2 @@\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc4122\n- *      RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9562.html\n+ *      RFC 9562 Universally Unique IDentifiers (UUIDs)\n@@ -77,0 +76,1 @@\n+\n@@ -181,0 +181,56 @@\n+    \/**\n+     * Creates a type 7 UUID (UUIDv7) {@code UUID} from the given Unix Epoch timestamp.\n+     *\n+     * The returned {@code UUID} will have the given {@code timestamp} in\n+     * the first 6 bytes, followed by the version and variant bits representing {@code UUIDv7},\n+     * and the remaining bytes will contain random data from a cryptographically strong\n+     * pseudo-random number generator.\n+     *\n+     * @apiNote {@code UUIDv7} values are created by allocating a Unix timestamp in milliseconds\n+     * in the most significant 48 bits, allocating the required version (4 bits) and variant (2-bits)\n+     * and filling the remaining 74 bits with random bits. As such, this method rejects {@code timestamp}\n+     * values that do not fit into 48 bits.\n+     * <p>\n+     * Monotonicity (each subsequent value being greater than the last) is a primary characteristic\n+     * of {@code UUIDv7} values. This is due to the {@code timestamp} value being part of the {@code UUID}.\n+     * Callers of this method that wish to generate monotonic {@code UUIDv7} values are expected to\n+     * ensure that the given {@code timestamp} value is monotonic.\n+     *\n+     *\n+     * @param timestamp the number of milliseconds since midnight 1 Jan 1970 UTC,\n+     *                 leap seconds excluded.\n+     *\n+     * @return a {@code UUID} constructed using the given {@code timestamp}\n+     *\n+     * @throws IllegalArgumentException if the timestamp is negative or greater than {@code (1L << 48) - 1}\n+     *\n+     * @since 26\n+     *\/\n+    public static UUID ofEpochMillis(long timestamp) {\n+        if ((timestamp >> 48) != 0) {\n+            throw new IllegalArgumentException(\"Supplied timestamp: \" + timestamp + \"does not fit within 48 bits\");\n+        }\n+\n+        SecureRandom ng = Holder.numberGenerator;\n+        byte[] randomBytes = new byte[16];\n+        ng.nextBytes(randomBytes);\n+\n+        \/\/ Embed the timestamp into the first 6 bytes\n+        randomBytes[0] = (byte)(timestamp >>> 40);\n+        randomBytes[1] = (byte)(timestamp >>> 32);\n+        randomBytes[2] = (byte)(timestamp >>> 24);\n+        randomBytes[3] = (byte)(timestamp >>> 16);\n+        randomBytes[4] = (byte)(timestamp >>> 8);\n+        randomBytes[5] = (byte)(timestamp);\n+\n+        \/\/ Set version to 7\n+        randomBytes[6] &= 0x0f;\n+        randomBytes[6] |= 0x70;\n+\n+        \/\/ Set variant to IETF\n+        randomBytes[8] &= 0x3f;\n+        randomBytes[8] |= (byte) 0x80;\n+\n+        return new UUID(randomBytes);\n+    }\n+\n@@ -323,0 +379,1 @@\n+     * <li>7    Unix Epoch time-based UUID\n@@ -339,1 +396,1 @@\n-     * <li>2    <a href=\"http:\/\/www.ietf.org\/rfc\/rfc4122.txt\">IETF&nbsp;RFC&nbsp;4122<\/a>\n+     * <li>2    <a href=\"https:\/\/www.ietf.org\/rfc\/rfc9562.txt\">IETF&nbsp;RFC&nbsp;9562<\/a>\n@@ -346,3 +403,0 @@\n-     *\n-     * @spec https:\/\/www.rfc-editor.org\/info\/rfc4122\n-     *      RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":68,"deletions":14,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-     * Creates a {code Cipher} object. Called internally by {code NullCipher}.\n+     * Creates a {@code Cipher} object. Called internally by {@code NullCipher}.\n@@ -2693,1 +2693,1 @@\n-     * Returns an {code AlgorithmParameterSpec} object which contains\n+     * Returns an {@code AlgorithmParameterSpec} object which contains\n@@ -2701,1 +2701,1 @@\n-     * @return an {code AlgorithmParameterSpec} object which holds the maximum\n+     * @return an {@code AlgorithmParameterSpec} object which holds the maximum\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    private static final long BYTE_REPLICATOR = 0x0101010101010101L;\n@@ -71,1 +72,1 @@\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+            final long longValue = BYTE_REPLICATOR * u;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,2 +70,17 @@\n-        \/\/ while building the interim javac, the ClassReader will produce a warning when loading a class\n-        \/\/ keeping the constant of a feature that has been integrated or dropped, serves the purpose of muting such warnings.\n+        \/\/ The JDK build process involves creating an interim javac which is then\n+        \/\/ used to compile the rest of the JDK. The jdk.internal.javac.PreviewFeature\n+        \/\/ annotation from the current sources is used when compiling interim javac.\n+        \/\/ That's because the javac APIs of the current sources may be annotated with\n+        \/\/ this annotation and they may be using the enum constants of the current sources.\n+        \/\/ Furthermore, when compiling interim javac, the class files from the bootstrap JDK get\n+        \/\/ used and those may also contain the PreviewFeature annotation. However, they may be\n+        \/\/ using the enum constants of the bootstrap JDK's PreviewFeature annotation.\n+        \/\/ If javac sees an annotation with an unknown enum constant, it produces a warning,\n+        \/\/ and that in turn fails the build.\n+        \/\/ So, in the current sources, we need to preserve the PreviewFeature enum constants\n+        \/\/ for as long as the interim javac build needs it. As a result, we retain PreviewFeature\n+        \/\/ enum constants for preview features that are present in the bootstrap JDK.\n+        \/\/ Older constants can be removed.\n+        \/\/\n+        \/\/ For example, Class-File API became final in JDK 24. As soon as JDK 23 was dropped as\n+        \/\/ the bootstrap JDK, the CLASSFILE_API enum constant became eligible for removal.\n@@ -73,2 +88,0 @@\n-        IMPLICIT_CLASSES, \/\/to be removed when boot JDK is 25\n-        SCOPED_VALUES,\n@@ -77,4 +90,0 @@\n-        CLASSFILE_API,\n-        STREAM_GATHERERS,\n-        MODULE_IMPORTS, \/\/remove when the boot JDK is JDK 25\n-        KEY_DERIVATION, \/\/remove when the boot JDK is JDK 25\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -28,0 +29,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -29,1 +31,0 @@\n-import java.math.BigInteger;\n@@ -31,1 +32,0 @@\n-\/\/@ model import org.jmlspecs.models.JMLMath;\n@@ -34,1 +34,1 @@\n- * A simple big integer package specifically for floating point base conversion.\n+ * A simple big integer class specifically for floating point base conversion.\n@@ -36,32 +36,1 @@\n-public \/*@ spec_bigint_math @*\/ class FDBigInteger {\n-\n-    \/\/\n-    \/\/ This class contains many comments that start with \"\/*@\" mark.\n-    \/\/ They are behavourial specification in\n-    \/\/ the Java Modelling Language (JML):\n-    \/\/ http:\/\/www.eecs.ucf.edu\/~leavens\/JML\/\/index.shtml\n-    \/\/\n-\n-    \/*@\n-    @ public pure model static \\bigint UNSIGNED(int v) {\n-    @     return v >= 0 ? v : v + (((\\bigint)1) << 32);\n-    @ }\n-    @\n-    @ public pure model static \\bigint UNSIGNED(long v) {\n-    @     return v >= 0 ? v : v + (((\\bigint)1) << 64);\n-    @ }\n-    @\n-    @ public pure model static \\bigint AP(int[] data, int len) {\n-    @     return (\\sum int i; 0 <= 0 && i < len; UNSIGNED(data[i]) << (i*32));\n-    @ }\n-    @\n-    @ public pure model static \\bigint pow52(int p5, int p2) {\n-    @     ghost \\bigint v = 1;\n-    @     for (int i = 0; i < p5; i++) v *= 5;\n-    @     return v << p2;\n-    @ }\n-    @\n-    @ public pure model static \\bigint pow10(int p10) {\n-    @     return pow52(p10, p10);\n-    @ }\n-    @*\/\n+final class FDBigInteger {\n@@ -69,0 +38,1 @@\n+    @Stable\n@@ -71,0 +41,1 @@\n+    @Stable\n@@ -73,1 +44,1 @@\n-    \/\/ Maximum size of cache of powers of 5 as FDBigIntegers.\n+    \/\/ Size of full cache of powers of 5 as FDBigIntegers.\n@@ -77,4 +48,2 @@\n-    private static final FDBigInteger POW_5_CACHE[];\n-\n-    \/\/ Zero as an FDBigInteger.\n-    public static final FDBigInteger ZERO;\n+    @Stable\n+    private static final FDBigInteger[] POW_5_CACHE;\n@@ -90,45 +59,12 @@\n-            long[] long5pow = {\n-                    1L,\n-                    5L,\n-                    5L * 5,\n-                    5L * 5 * 5,\n-                    5L * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                };\n-            int[] small5pow = {\n-                    1,\n-                    5,\n-                    5 * 5,\n-                    5 * 5 * 5,\n-                    5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,\n-                    5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n-                };\n+            int[] small5pow = new int[13 + 1];  \/\/ 5^13 fits in an int, 5^14 does not\n+            small5pow[0] = 1;\n+            for (int i = 1; i < small5pow.length; ++i) {\n+                small5pow[i] = 5 * small5pow[i - 1];\n+            }\n+\n+            long[] long5pow = new long[27 + 1];  \/\/ 5^27 fits in a long, 5^28 does not\n+            long5pow[0] = 1;\n+            for (int i = 1; i < long5pow.length; ++i) {\n+                long5pow[i] = 5 * long5pow[i - 1];\n+            }\n+\n@@ -137,5 +73,2 @@\n-            while (i < small5pow.length) {\n-                FDBigInteger pow5 = new FDBigInteger(new int[] { small5pow[i] }, 0);\n-                pow5.makeImmutable();\n-                pow5cache[i] = pow5;\n-                i++;\n+            for (; i < long5pow.length; ++i) {\n+                pow5cache[i] = new FDBigInteger(long5pow[i]).makeImmutable();\n@@ -144,4 +77,2 @@\n-            while (i < MAX_FIVE_POW) {\n-                pow5cache[i] = prev = prev.mult(5);\n-                prev.makeImmutable();\n-                i++;\n+            for (; i < MAX_FIVE_POW; ++i) {\n+                pow5cache[i] = prev = prev.mult(5).makeImmutable();\n@@ -149,3 +80,9 @@\n-            FDBigInteger zero = new FDBigInteger(new int[0], 0);\n-            zero.makeImmutable();\n-            archivedCaches = caches = new Object[] {small5pow, long5pow, pow5cache, zero};\n+\n+            \/* Here prev is 5^(MAX_FIVE_POW-1). *\/\n+            FDBigInteger[] largePow5cache =\n+                    new FDBigInteger[(2 - DoubleToDecimal.Q_MIN) - MAX_FIVE_POW + 1];\n+            largePow5cache[2 * (MAX_FIVE_POW - 1) - MAX_FIVE_POW] =\n+                    prev = prev.mult(prev).makeImmutable();\n+            largePow5cache[3 * (MAX_FIVE_POW - 1) - MAX_FIVE_POW] =\n+                    pow5cache[MAX_FIVE_POW - 1].mult(prev).makeImmutable();\n+            archivedCaches = caches = new Object[] {small5pow, long5pow, pow5cache, largePow5cache};\n@@ -153,4 +90,4 @@\n-        SMALL_5_POW = (int[])caches[0];\n-        LONG_5_POW = (long[])caches[1];\n-        POW_5_CACHE = (FDBigInteger[])caches[2];\n-        ZERO = (FDBigInteger)caches[3];\n+        SMALL_5_POW = (int[]) caches[0];\n+        LONG_5_POW = (long[]) caches[1];\n+        POW_5_CACHE = (FDBigInteger[]) caches[2];\n+        LARGE_POW_5_CACHE = (FDBigInteger[]) caches[3];\n@@ -160,1 +97,1 @@\n-    private static final long LONG_MASK = 0xffffffffL;\n+    private static final long LONG_MASK = 0xffff_ffffL;\n@@ -162,3 +99,1 @@\n-    \/\/@ spec_public non_null;\n-    private int data[];  \/\/ value: data[0] is least significant\n-    \/\/@ spec_public;\n+    private int[] data;  \/\/ value: data[0] is least significant\n@@ -166,1 +101,0 @@\n-    \/\/@ spec_public;\n@@ -169,1 +103,0 @@\n-    \/\/@ spec_public;\n@@ -172,10 +105,0 @@\n-    \/*@\n-     @ public invariant 0 <= nWords && nWords <= data.length && offset >= 0;\n-     @ public invariant nWords == 0 ==> offset == 0;\n-     @ public invariant nWords > 0 ==> data[nWords - 1] != 0;\n-     @ public invariant (\\forall int i; nWords <= i && i < data.length; data[i] == 0);\n-     @ public pure model \\bigint value() {\n-     @     return AP(data, nWords) << (offset*32);\n-     @ }\n-     @*\/\n-\n@@ -183,5 +106,5 @@\n-     * Constructs an <code>FDBigInteger<\/code> from data and padding. The\n-     * <code>data<\/code> parameter has the least significant <code>int<\/code> at\n-     * the zeroth index. The <code>offset<\/code> parameter gives the number of\n-     * zero <code>int<\/code>s to be inferred below the least significant element\n-     * of <code>data<\/code>.\n+     * Constructs an {@link FDBigInteger} from data and padding. The\n+     * {@code data} parameter has the least significant {@code int} at\n+     * the zeroth index. The {@code offset} parameter gives the number of\n+     * zero {@code int}s to be inferred below the least significant element\n+     * of {@code data}.\n@@ -189,3 +112,3 @@\n-     * @param data An array containing all non-zero <code>int<\/code>s of the value.\n-     * @param offset An offset indicating the number of zero <code>int<\/code>s to pad\n-     * below the least significant element of <code>data<\/code>.\n+     * @param data An array containing all non-zero {@code int}s of the value.\n+     * @param offset An offset indicating the number of zero {@code int}s to pad\n+     * below the least significant element of {@code data}.\n@@ -193,5 +116,0 @@\n-    \/*@\n-     @ requires data != null && offset >= 0;\n-     @ ensures this.value() == \\old(AP(data, data.length) << (offset*32));\n-     @ ensures this.data == \\old(data);\n-     @*\/\n@@ -206,1 +124,1 @@\n-     * Constructs an <code>FDBigInteger<\/code> from a starting value and some\n+     * Constructs an {@link FDBigInteger} from a starting value and some\n@@ -211,2 +129,2 @@\n-     * @param kDigits The initial index into <code>digits<\/code>.\n-     * @param nDigits The final index into <code>digits<\/code>.\n+     * @param i The initial index into {@code digits}.\n+     * @param nDigits The final index into {@code digits}.\n@@ -214,10 +132,4 @@\n-    \/*@\n-     @ requires digits != null;\n-     @ requires 0 <= kDigits && kDigits <= nDigits && nDigits <= digits.length;\n-     @ requires (\\forall int i; 0 <= i && i < nDigits; '0' <= digits[i] && digits[i] <= '9');\n-     @ ensures this.value() == \\old(lValue * pow10(nDigits - kDigits) + (\\sum int i; kDigits <= i && i < nDigits; (digits[i] - '0') * pow10(nDigits - i - 1)));\n-     @*\/\n-    public FDBigInteger(long lValue, byte[] digits, int kDigits, int nDigits) {\n-        int n = Math.max((nDigits + 8) \/ 9, 2);        \/\/ estimate size needed.\n-        data = new int[n];      \/\/ allocate enough space\n-        data[0] = (int) lValue;    \/\/ starting value\n+    public FDBigInteger(long lValue, byte[] digits, int i, int nDigits) {\n+        int n = (nDigits + 8) \/ 9;  \/\/ estimate size needed: ⌈nDigits \/ 9⌉\n+        data = new int[Math.max(n, 2)];\n+        data[0] = (int) lValue;  \/\/ starting value\n@@ -227,3 +139,1 @@\n-        int i = kDigits;\n-        int limit = nDigits - 5;       \/\/ slurp digits 5 at a time.\n-        int v;\n+        int limit = nDigits - 9;\n@@ -231,2 +141,2 @@\n-            int ilim = i + 5;\n-            v = (int) digits[i++] - (int) '0';\n+            int v = 0;\n+            int ilim = i + 9;\n@@ -234,1 +144,1 @@\n-                v = 10 * v + (int) digits[i++] - (int) '0';\n+                v = 10 * v + digits[i++] - '0';\n@@ -236,1 +146,1 @@\n-            multAddMe(100000, v); \/\/ ... where 100000 is 10^5.\n+            multAdd(1_000_000_000, v);  \/\/ 10^9\n@@ -238,8 +148,7 @@\n-        int factor = 1;\n-        v = 0;\n-        while (i < nDigits) {\n-            v = 10 * v + (int) digits[i++] - (int) '0';\n-            factor *= 10;\n-        }\n-        if (factor != 1) {\n-            multAddMe(factor, v);\n+        if (i < nDigits) {\n+            int factor = (int) MathUtils.pow10(nDigits - i);\n+            int v = 0;\n+            while (i < nDigits) {\n+                v = 10 * v + digits[i++] - '0';\n+            }\n+            multAdd(factor, v);\n@@ -250,0 +159,4 @@\n+    public FDBigInteger(long v) {\n+        this(new int[] {(int) v, (int) (v >>> 32)}, 0);\n+    }\n+\n@@ -251,2 +164,2 @@\n-     * Returns an <code>FDBigInteger<\/code> with the numerical value\n-     * <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>.\n+     * Returns an {@link FDBigInteger} with the numerical value\n+     * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>.\n@@ -254,3 +167,3 @@\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n-     * @return <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>\n+     * @param e5 The exponent of the power-of-five factor.\n+     * @param e2 The exponent of the power-of-two factor.\n+     * @return 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>\n@@ -258,26 +171,9 @@\n-    \/*@\n-     @ requires p5 >= 0 && p2 >= 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(pow52(p5, p2));\n-     @*\/\n-    public static FDBigInteger valueOfPow52(int p5, int p2) {\n-        if (p5 != 0) {\n-            if (p2 == 0) {\n-                return big5pow(p5);\n-            } else if (p5 < SMALL_5_POW.length) {\n-                int pow5 = SMALL_5_POW[p5];\n-                int wordcount = p2 >> 5;\n-                int bitcount = p2 & 0x1f;\n-                if (bitcount == 0) {\n-                    return new FDBigInteger(new int[]{pow5}, wordcount);\n-                } else {\n-                    return new FDBigInteger(new int[]{\n-                            pow5 << bitcount,\n-                            pow5 >>> (32 - bitcount)\n-                    }, wordcount);\n-                }\n-            } else {\n-                return big5pow(p5).leftShift(p2);\n-            }\n-        } else {\n-            return valueOfPow2(p2);\n+    public static FDBigInteger valueOfPow52(int e5, int e2) {\n+        if (e5 == 0) {\n+            return valueOfPow2(e2);\n+        }\n+        if (e2 == 0) {\n+            return pow5(e5);\n+        }\n+        if (e5 >= SMALL_5_POW.length) {\n+            return pow5(e5).leftShift(e2);\n@@ -285,0 +181,10 @@\n+        int pow5 = SMALL_5_POW[e5];\n+        int offset = e2 >> 5;\n+        int bitcount = e2 & 0x1f;\n+        if (bitcount == 0) {\n+            return new FDBigInteger(new int[] {pow5}, offset);\n+        }\n+        return new FDBigInteger(new int[] {\n+                pow5 << bitcount,\n+                pow5 >>> -bitcount\n+            }, offset);\n@@ -288,2 +194,2 @@\n-     * Returns an <code>FDBigInteger<\/code> with the numerical value\n-     * <code>value * 5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>.\n+     * Returns an {@link FDBigInteger} with the numerical value:\n+     * value * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>.\n@@ -292,3 +198,3 @@\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n-     * @return <code>value * 5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>\n+     * @param e5 The exponent of the power-of-five factor.\n+     * @param e2 The exponent of the power-of-two factor.\n+     * @return value * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>\n@@ -296,8 +202,1 @@\n-    \/*@\n-     @ requires p5 >= 0 && p2 >= 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(UNSIGNED(value) * pow52(p5, p2));\n-     @*\/\n-    public static FDBigInteger valueOfMulPow52(long value, int p5, int p2) {\n-        assert p5 >= 0 : p5;\n-        assert p2 >= 0 : p2;\n+    public static FDBigInteger valueOfMulPow52(long value, int e5, int e2) {\n@@ -306,5 +205,5 @@\n-        int wordcount = p2 >> 5;\n-        int bitcount = p2 & 0x1f;\n-        if (p5 != 0) {\n-            if (p5 < SMALL_5_POW.length) {\n-                long pow5 = SMALL_5_POW[p5] & LONG_MASK;\n+        int offset = e2 >> 5;\n+        int bitcount = e2 & 0x1f;\n+        if (e5 != 0) {\n+            if (e5 < SMALL_5_POW.length) {\n+                long pow5 = SMALL_5_POW[e5] & LONG_MASK;\n@@ -317,21 +216,8 @@\n-                if (bitcount == 0) {\n-                    return new FDBigInteger(new int[]{v0, v1, v2}, wordcount);\n-                } else {\n-                    return new FDBigInteger(new int[]{\n-                            v0 << bitcount,\n-                            (v1 << bitcount) | (v0 >>> (32 - bitcount)),\n-                            (v2 << bitcount) | (v1 >>> (32 - bitcount)),\n-                            v2 >>> (32 - bitcount)\n-                    }, wordcount);\n-                }\n-            } else {\n-                FDBigInteger pow5 = big5pow(p5);\n-                int[] r;\n-                if (v1 == 0) {\n-                    r = new int[pow5.nWords + 1 + ((p2 != 0) ? 1 : 0)];\n-                    mult(pow5.data, pow5.nWords, v0, r);\n-                } else {\n-                    r = new int[pow5.nWords + 2 + ((p2 != 0) ? 1 : 0)];\n-                    mult(pow5.data, pow5.nWords, v0, v1, r);\n-                }\n-                return (new FDBigInteger(r, pow5.offset)).leftShift(p2);\n+                return bitcount == 0\n+                        ? new FDBigInteger(new int[] {v0, v1, v2}, offset)\n+                        : new FDBigInteger(new int[] {\n+                                v0 << bitcount,\n+                                (v1 << bitcount) | (v0 >>> -bitcount),\n+                                (v2 << bitcount) | (v1 >>> -bitcount),\n+                                v2 >>> -bitcount\n+                            }, offset);\n@@ -339,3 +225,5 @@\n-        } else if (p2 != 0) {\n-            if (bitcount == 0) {\n-                return new FDBigInteger(new int[]{v0, v1}, wordcount);\n+            FDBigInteger pow5 = pow5(e5);\n+            int[] r;\n+            if (v1 == 0) {\n+                r = new int[pow5.nWords + 1 + ((e2 != 0) ? 1 : 0)];\n+                mult(pow5.data, pow5.nWords, v0, r);\n@@ -343,5 +231,2 @@\n-                return new FDBigInteger(new int[]{\n-                         v0 << bitcount,\n-                        (v1 << bitcount) | (v0 >>> (32 - bitcount)),\n-                        v1 >>> (32 - bitcount)\n-                }, wordcount);\n+                r = new int[pow5.nWords + 2 + ((e2 != 0) ? 1 : 0)];\n+                mult(pow5.data, pow5.nWords, v0, v1, r);\n@@ -349,0 +234,1 @@\n+            return (new FDBigInteger(r, 0)).leftShift(e2);\n@@ -350,1 +236,10 @@\n-        return new FDBigInteger(new int[]{v0, v1}, 0);\n+        if (e2 != 0) {\n+            return bitcount == 0\n+                    ? new FDBigInteger(new int[] {v0, v1}, offset)\n+                    : new FDBigInteger(new int[] {\n+                            v0 << bitcount,\n+                            (v1 << bitcount) | (v0 >>> -bitcount),\n+                            v1 >>> -bitcount\n+                        }, offset);\n+        }\n+        return new FDBigInteger(new int[] {v0, v1}, 0);\n@@ -354,2 +249,2 @@\n-     * Returns an <code>FDBigInteger<\/code> with the numerical value\n-     * <code>2<sup>p2<\/sup><\/code>.\n+     * Returns an {@link FDBigInteger} with the numerical value\n+     * 2<sup>{@code e}<\/sup>.\n@@ -357,2 +252,2 @@\n-     * @param p2 The exponent of 2.\n-     * @return <code>2<sup>p2<\/sup><\/code>\n+     * @param e The exponent of 2.\n+     * @return 2<sup>{@code e}<\/sup>\n@@ -360,9 +255,2 @@\n-    \/*@\n-     @ requires p2 >= 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == pow52(0, p2);\n-     @*\/\n-    private static FDBigInteger valueOfPow2(int p2) {\n-        int wordcount = p2 >> 5;\n-        int bitcount = p2 & 0x1f;\n-        return new FDBigInteger(new int[]{1 << bitcount}, wordcount);\n+    private static FDBigInteger valueOfPow2(int e) {\n+        return new FDBigInteger(new int[] {1 << (e & 0x1f)}, e >> 5);\n@@ -372,1 +260,1 @@\n-     * Removes all leading zeros from this <code>FDBigInteger<\/code> adjusting\n+     * Removes all leading zeros from this {@link FDBigInteger} adjusting\n@@ -375,18 +263,6 @@\n-    \/*@\n-     @ requires data != null;\n-     @ requires 0 <= nWords && nWords <= data.length && offset >= 0;\n-     @ requires nWords == 0 ==> offset == 0;\n-     @ ensures nWords == 0 ==> offset == 0;\n-     @ ensures nWords > 0 ==> data[nWords - 1] != 0;\n-     @*\/\n-    private \/*@ helper @*\/ void trimLeadingZeros() {\n-        int i = nWords;\n-        if (i > 0 && (data[--i] == 0)) {\n-            \/\/for (; i > 0 && data[i - 1] == 0; i--) ;\n-            while(i > 0 && data[i - 1] == 0) {\n-                i--;\n-            }\n-            this.nWords = i;\n-            if (i == 0) { \/\/ all words are zero\n-                this.offset = 0;\n-            }\n+    private void trimLeadingZeros() {\n+        int i = nWords - 1;\n+        for (; i >= 0 && data[i] == 0; --i);  \/\/ empty body\n+        nWords = i + 1;\n+        if (i < 0) {\n+            offset = 0;\n@@ -397,1 +273,1 @@\n-     * Retrieves the normalization bias of the <code>FDBigIntger<\/code>. The\n+     * Retrieves the normalization bias of the {@link FDBigInteger}. The\n@@ -405,4 +281,1 @@\n-    \/*@\n-     @ requires this.value() > 0;\n-     @*\/\n-    public \/*@ pure @*\/ int getNormalizationBias() {\n+    public int getNormalizationBias() {\n@@ -416,1 +289,0 @@\n-    \/\/ TODO: Why is anticount param needed if it is always 32 - bitcount?\n@@ -424,1 +296,0 @@\n-     * @param anticount The left anti-shift, e.g., <code>32-bitcount<\/code>.\n@@ -427,7 +298,1 @@\n-    \/*@\n-     @ requires 0 < bitcount && bitcount < 32 && anticount == 32 - bitcount;\n-     @ requires src.length >= idx && result.length > idx;\n-     @ assignable result[*];\n-     @ ensures AP(result, \\old(idx + 1)) == \\old((AP(src, idx) + UNSIGNED(prev) << (idx*32)) << bitcount);\n-     @*\/\n-    private static void leftShift(int[] src, int idx, int result[], int bitcount, int anticount, int prev){\n+    private static void leftShift(int[] src, int idx, int[] result, int bitcount, int prev) {\n@@ -435,1 +300,1 @@\n-            int v = (prev << bitcount);\n+            int v = prev << bitcount;\n@@ -437,1 +302,1 @@\n-            v |= (prev >>> anticount);\n+            v |= prev >>> -bitcount;\n@@ -445,3 +310,3 @@\n-     * Shifts this <code>FDBigInteger<\/code> to the left. The shift is performed\n-     * in-place unless the <code>FDBigInteger<\/code> is immutable in which case\n-     * a new instance of <code>FDBigInteger<\/code> is returned.\n+     * Shifts this {@link FDBigInteger} to the left. The shift is performed\n+     * in-place unless the {@link FDBigInteger} is immutable in which case\n+     * a new instance of {@link FDBigInteger} is returned.\n@@ -450,1 +315,1 @@\n-     * @return The shifted <code>FDBigInteger<\/code>.\n+     * @return The shifted {@link FDBigInteger}.\n@@ -452,18 +317,0 @@\n-    \/*@\n-     @ requires this.value() == 0 || shift == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && shift > 0 && this.isImmutable;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() << shift);\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && shift > 0 && this.isImmutable;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() << shift);\n-     @*\/\n@@ -476,1 +323,1 @@\n-        if (this.isImmutable) {\n+        if (isImmutable) {\n@@ -479,0 +326,30 @@\n+            }\n+            int idx = nWords - 1;\n+            int prev = data[idx];\n+            int hi = prev >>> -bitcount;\n+            int[] result;\n+            if (hi != 0) {\n+                result = new int[nWords + 1];\n+                result[nWords] = hi;\n+            } else {\n+                result = new int[nWords];\n+            }\n+            leftShift(data, idx, result, bitcount, prev);\n+            return new FDBigInteger(result, offset + wordcount);\n+        }\n+        if (bitcount != 0) {\n+            if (data[0] << bitcount == 0) {\n+                int idx = 0;\n+                int prev = data[idx];\n+                for (; idx < nWords - 1; idx++) {\n+                    int v = prev >>> -bitcount;\n+                    prev = data[idx + 1];\n+                    v |= prev << bitcount;\n+                    data[idx] = v;\n+                }\n+                int v = prev >>> -bitcount;\n+                data[idx] = v;\n+                if (v == 0) {\n+                    nWords--;\n+                }\n+                offset++;\n@@ -480,1 +357,0 @@\n-                int anticount = 32 - bitcount;\n@@ -483,2 +359,3 @@\n-                int hi = prev >>> anticount;\n-                int[] result;\n+                int hi = prev >>> -bitcount;\n+                int[] result = data;\n+                int[] src = data;\n@@ -486,37 +363,2 @@\n-                    result = new int[nWords + 1];\n-                    result[nWords] = hi;\n-                } else {\n-                    result = new int[nWords];\n-                }\n-                leftShift(data,idx,result,bitcount,anticount,prev);\n-                return new FDBigInteger(result, offset + wordcount);\n-            }\n-        } else {\n-            if (bitcount != 0) {\n-                int anticount = 32 - bitcount;\n-                if ((data[0] << bitcount) == 0) {\n-                    int idx = 0;\n-                    int prev = data[idx];\n-                    for (; idx < nWords - 1; idx++) {\n-                        int v = (prev >>> anticount);\n-                        prev = data[idx + 1];\n-                        v |= (prev << bitcount);\n-                        data[idx] = v;\n-                    }\n-                    int v = prev >>> anticount;\n-                    data[idx] = v;\n-                    if(v==0) {\n-                        nWords--;\n-                    }\n-                    offset++;\n-                } else {\n-                    int idx = nWords - 1;\n-                    int prev = data[idx];\n-                    int hi = prev >>> anticount;\n-                    int[] result = data;\n-                    int[] src = data;\n-                    if (hi != 0) {\n-                        if(nWords == data.length) {\n-                            data = result = new int[nWords + 1];\n-                        }\n-                        result[nWords++] = hi;\n+                    if (nWords == data.length) {\n+                        data = result = new int[nWords + 1];\n@@ -524,1 +366,1 @@\n-                    leftShift(src,idx,result,bitcount,anticount,prev);\n+                    result[nWords++] = hi;\n@@ -526,0 +368,1 @@\n+                leftShift(src, idx, result, bitcount, prev);\n@@ -527,2 +370,0 @@\n-            offset += wordcount;\n-            return this;\n@@ -530,0 +371,2 @@\n+        offset += wordcount;\n+        return this;\n@@ -533,1 +376,1 @@\n-     * Returns the number of <code>int<\/code>s this <code>FDBigInteger<\/code> represents.\n+     * Returns the number of {@code int}s this {@link FDBigInteger} represents.\n@@ -535,1 +378,1 @@\n-     * @return Number of <code>int<\/code>s required to represent this <code>FDBigInteger<\/code>.\n+     * @return Number of {@code int}s required to represent this {@link FDBigInteger}.\n@@ -537,10 +380,1 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ ensures \\result == 0;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0;\n-     @ ensures ((\\bigint)1) << (\\result - 1) <= this.value() && this.value() <= ((\\bigint)1) << \\result;\n-     @*\/\n-    private \/*@ pure @*\/ int size() {\n+    private int size() {\n@@ -550,0 +384,8 @@\n+    \/**\n+     * Returns whether this {@link FDBigInteger} is zero.\n+     *\n+     * @return {@code this} is zero.\n+     *\/\n+    public boolean isZero() {\n+        return nWords == 0;\n+    }\n@@ -564,2 +406,2 @@\n-     * @param S The divisor of this <code>FDBigInteger<\/code>.\n-     * @return <code>q = (int)(this \/ S)<\/code>.\n+     * @param S The divisor of this {@link FDBigInteger}.\n+     * @return {@code q = (int)(this \/ S)}.\n@@ -567,9 +409,0 @@\n-    \/*@\n-     @ requires !this.isImmutable;\n-     @ requires this.size() <= S.size();\n-     @ requires this.data.length + this.offset >= S.size();\n-     @ requires S.value() >= ((\\bigint)1) << (S.size()*32 - 4);\n-     @ assignable this.nWords, this.offset, this.data, this.data[*];\n-     @ ensures \\result == \\old(this.value() \/ S.value());\n-     @ ensures this.value() == \\old(10 * (this.value() % S.value()));\n-     @*\/\n@@ -600,1 +433,1 @@\n-        long diff = multDiffMe(q, S);\n+        long diff = multSub(q, S);\n@@ -642,3 +475,3 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by 10. The operation will be\n-     * performed in place unless the <code>FDBigInteger<\/code> is immutable in\n-     * which case a new <code>FDBigInteger<\/code> will be returned.\n+     * Multiplies this {@link FDBigInteger} by 10. The operation will be\n+     * performed in place unless the {@link FDBigInteger} is immutable in\n+     * which case a new {@link FDBigInteger} will be returned.\n@@ -646,1 +479,1 @@\n-     * @return The <code>FDBigInteger<\/code> multiplied by 10.\n+     * @return The {@link FDBigInteger} multiplied by 10.\n@@ -648,18 +481,0 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && this.isImmutable;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * 10);\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && !this.isImmutable;\n-     @ assignable this.nWords, this.data, this.data[*];\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() * 10);\n-     @*\/\n@@ -694,3 +509,3 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by\n-     * <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>. The operation will be\n-     * performed in place if possible, otherwise a new <code>FDBigInteger<\/code>\n+     * Multiplies this {@link FDBigInteger} by\n+     * 5<sup>{@code e5}<\/sup> * 2<sup>{@code e2}<\/sup>. The operation will be\n+     * performed in place if possible, otherwise a new {@link FDBigInteger}\n@@ -699,2 +514,2 @@\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n+     * @param e5 The exponent of the power-of-five factor.\n+     * @param e2 The exponent of the power-of-two factor.\n@@ -703,20 +518,2 @@\n-    \/*@\n-     @ requires this.value() == 0 || p5 == 0 && p2 == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && (p5 > 0 && p2 >= 0 || p5 == 0 && p2 > 0 && this.isImmutable);\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * pow52(p5, p2));\n-     @\n-     @  also\n-     @\n-     @ requires this.value() > 0 && p5 == 0 && p2 > 0 && !this.isImmutable;\n-     @ assignable this.nWords, this.data, this.data[*];\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() * pow52(p5, p2));\n-     @*\/\n-    public FDBigInteger multByPow52(int p5, int p2) {\n-        if (this.nWords == 0) {\n+    public FDBigInteger multByPow52(int e5, int e2) {\n+        if (nWords == 0) {\n@@ -726,1 +523,1 @@\n-        if (p5 != 0) {\n+        if (e5 != 0) {\n@@ -728,5 +525,8 @@\n-            int extraSize = (p2 != 0) ? 1 : 0;\n-            if (p5 < SMALL_5_POW.length) {\n-                r = new int[this.nWords + 1 + extraSize];\n-                mult(this.data, this.nWords, SMALL_5_POW[p5], r);\n-                res = new FDBigInteger(r, this.offset);\n+            int extraSize = e2 != 0 ? 1 : 0;  \/\/ accounts for e2 % 32 shift bits\n+            if (e5 < SMALL_5_POW.length) {\n+                r = new int[nWords + 1 + extraSize];\n+                mult(data, nWords, SMALL_5_POW[e5], r);\n+            } else if (e5 < LONG_5_POW.length) {\n+                long pow5 = LONG_5_POW[e5];\n+                r = new int[nWords + 2 + extraSize];\n+                mult(data, nWords, (int) pow5, (int) (pow5 >>> 32), r);\n@@ -734,4 +534,3 @@\n-                FDBigInteger pow5 = big5pow(p5);\n-                r = new int[this.nWords + pow5.size() + extraSize];\n-                mult(this.data, this.nWords, pow5.data, pow5.nWords, r);\n-                res = new FDBigInteger(r, this.offset + pow5.offset);\n+                FDBigInteger pow5 = pow5(e5);\n+                r = new int[nWords + pow5.nWords + extraSize];\n+                mult(data, nWords, pow5.data, pow5.nWords, r);\n@@ -739,0 +538,1 @@\n+            res = new FDBigInteger(r, offset);\n@@ -740,1 +540,1 @@\n-        return res.leftShift(p2);\n+        return res.leftShift(e2);\n@@ -747,1 +547,1 @@\n-     * @param s1Len The number of elements of <code>s1<\/code> to use.\n+     * @param s1Len The number of elements of {@code s1} to use.\n@@ -749,1 +549,1 @@\n-     * @param s2Len The number of elements of <code>s2<\/code> to use.\n+     * @param s2Len The number of elements of {@code s2} to use.\n@@ -752,6 +552,0 @@\n-    \/*@\n-     @ requires s1 != dst && s2 != dst;\n-     @ requires s1.length >= s1Len && s2.length >= s2Len && dst.length >= s1Len + s2Len;\n-     @ assignable dst[0 .. s1Len + s2Len - 1];\n-     @ ensures AP(dst, s1Len + s2Len) == \\old(AP(s1, s1Len) * AP(s2, s2Len));\n-     @*\/\n@@ -759,0 +553,5 @@\n+        if (s1Len > s2Len) {\n+            \/* Swap ensures that inner loop is longest. *\/\n+            int l = s1Len; s1Len = s2Len; s2Len = l;\n+            int[] s = s1; s1 = s2; s2 = s;\n+        }\n@@ -771,152 +570,0 @@\n-    \/**\n-     * Subtracts the supplied <code>FDBigInteger<\/code> subtrahend from this\n-     * <code>FDBigInteger<\/code>. Assert that the result is positive.\n-     * If the subtrahend is immutable, store the result in this(minuend).\n-     * If this(minuend) is immutable a new <code>FDBigInteger<\/code> is created.\n-     *\n-     * @param subtrahend The <code>FDBigInteger<\/code> to be subtracted.\n-     * @return This <code>FDBigInteger<\/code> less the subtrahend.\n-     *\/\n-    \/*@\n-     @ requires this.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @\n-     @  also\n-     @\n-     @ requires !subtrahend.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable this.nWords, this.offset, this.data, this.data[*];\n-     @ ensures \\result == this;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @*\/\n-    public FDBigInteger leftInplaceSub(FDBigInteger subtrahend) {\n-        assert this.size() >= subtrahend.size() : \"result should be positive\";\n-        FDBigInteger minuend;\n-        if (this.isImmutable) {\n-            minuend = new FDBigInteger(this.data.clone(), this.offset);\n-        } else {\n-            minuend = this;\n-        }\n-        int offsetDiff = subtrahend.offset - minuend.offset;\n-        int[] sData = subtrahend.data;\n-        int[] mData = minuend.data;\n-        int subLen = subtrahend.nWords;\n-        int minLen = minuend.nWords;\n-        if (offsetDiff < 0) {\n-            \/\/ need to expand minuend\n-            int rLen = minLen - offsetDiff;\n-            if (rLen < mData.length) {\n-                System.arraycopy(mData, 0, mData, -offsetDiff, minLen);\n-                Arrays.fill(mData, 0, -offsetDiff, 0);\n-            } else {\n-                int[] r = new int[rLen];\n-                System.arraycopy(mData, 0, r, -offsetDiff, minLen);\n-                minuend.data = mData = r;\n-            }\n-            minuend.offset = subtrahend.offset;\n-            minuend.nWords = minLen = rLen;\n-            offsetDiff = 0;\n-        }\n-        long borrow = 0L;\n-        int mIndex = offsetDiff;\n-        for (int sIndex = 0; sIndex < subLen && mIndex < minLen; sIndex++, mIndex++) {\n-            long diff = (mData[mIndex] & LONG_MASK) - (sData[sIndex] & LONG_MASK) + borrow;\n-            mData[mIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        for (; borrow != 0 && mIndex < minLen; mIndex++) {\n-            long diff = (mData[mIndex] & LONG_MASK) + borrow;\n-            mData[mIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        assert borrow == 0L : borrow; \/\/ borrow out of subtract,\n-        \/\/ result should be positive\n-        minuend.trimLeadingZeros();\n-        return minuend;\n-    }\n-\n-    \/**\n-     * Subtracts the supplied <code>FDBigInteger<\/code> subtrahend from this\n-     * <code>FDBigInteger<\/code>. Assert that the result is positive.\n-     * If the this(minuend) is immutable, store the result in subtrahend.\n-     * If subtrahend is immutable a new <code>FDBigInteger<\/code> is created.\n-     *\n-     * @param subtrahend The <code>FDBigInteger<\/code> to be subtracted.\n-     * @return This <code>FDBigInteger<\/code> less the subtrahend.\n-     *\/\n-    \/*@\n-     @ requires subtrahend.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @\n-     @  also\n-     @\n-     @ requires !subtrahend.isImmutable;\n-     @ requires this.value() >= subtrahend.value();\n-     @ assignable subtrahend.nWords, subtrahend.offset, subtrahend.data, subtrahend.data[*];\n-     @ ensures \\result == subtrahend;\n-     @ ensures \\result.value() == \\old(this.value() - subtrahend.value());\n-     @*\/\n-    public FDBigInteger rightInplaceSub(FDBigInteger subtrahend) {\n-        assert this.size() >= subtrahend.size() : \"result should be positive\";\n-        FDBigInteger minuend = this;\n-        if (subtrahend.isImmutable) {\n-            subtrahend = new FDBigInteger(subtrahend.data.clone(), subtrahend.offset);\n-        }\n-        int offsetDiff = minuend.offset - subtrahend.offset;\n-        int[] sData = subtrahend.data;\n-        int[] mData = minuend.data;\n-        int subLen = subtrahend.nWords;\n-        int minLen = minuend.nWords;\n-        if (offsetDiff < 0) {\n-            int rLen = minLen;\n-            if (rLen < sData.length) {\n-                System.arraycopy(sData, 0, sData, -offsetDiff, subLen);\n-                Arrays.fill(sData, 0, -offsetDiff, 0);\n-            } else {\n-                int[] r = new int[rLen];\n-                System.arraycopy(sData, 0, r, -offsetDiff, subLen);\n-                subtrahend.data = sData = r;\n-            }\n-            subtrahend.offset = minuend.offset;\n-            subLen -= offsetDiff;\n-            offsetDiff = 0;\n-        } else {\n-            int rLen = minLen + offsetDiff;\n-            if (rLen >= sData.length) {\n-                subtrahend.data = sData = Arrays.copyOf(sData, rLen);\n-            }\n-        }\n-        \/\/@ assert minuend == this && minuend.value() == \\old(this.value());\n-        \/\/@ assert mData == minuend.data && minLen == minuend.nWords;\n-        \/\/@ assert subtrahend.offset + subtrahend.data.length >= minuend.size();\n-        \/\/@ assert sData == subtrahend.data;\n-        \/\/@ assert AP(subtrahend.data, subtrahend.data.length) << subtrahend.offset == \\old(subtrahend.value());\n-        \/\/@ assert subtrahend.offset == Math.min(\\old(this.offset), minuend.offset);\n-        \/\/@ assert offsetDiff == minuend.offset - subtrahend.offset;\n-        \/\/@ assert 0 <= offsetDiff && offsetDiff + minLen <= sData.length;\n-        int sIndex = 0;\n-        long borrow = 0L;\n-        for (; sIndex < offsetDiff; sIndex++) {\n-            long diff = 0L - (sData[sIndex] & LONG_MASK) + borrow;\n-            sData[sIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        \/\/@ assert sIndex == offsetDiff;\n-        for (int mIndex = 0; mIndex < minLen; sIndex++, mIndex++) {\n-            \/\/@ assert sIndex == offsetDiff + mIndex;\n-            long diff = (mData[mIndex] & LONG_MASK) - (sData[sIndex] & LONG_MASK) + borrow;\n-            sData[sIndex] = (int) diff;\n-            borrow = diff >> 32; \/\/ signed shift\n-        }\n-        assert borrow == 0L : borrow; \/\/ borrow out of subtract,\n-        \/\/ result should be positive\n-        subtrahend.nWords = sIndex;\n-        subtrahend.trimLeadingZeros();\n-        return subtrahend;\n-\n-    }\n-\n@@ -931,5 +578,1 @@\n-    \/*@\n-     @ requires 0 <= from && from <= a.length;\n-     @ ensures \\result == (AP(a, from) == 0 ? 0 : 1);\n-     @*\/\n-    private \/*@ pure @*\/ static int checkZeroTail(int[] a, int from) {\n+    private static int checkZeroTail(int[] a, int from) {\n@@ -945,1 +588,1 @@\n-     * Compares the parameter with this <code>FDBigInteger<\/code>. Returns an\n+     * Compares the parameter with this {@link FDBigInteger}. Returns an\n@@ -953,1 +596,1 @@\n-     * @param other The <code>FDBigInteger<\/code> to compare.\n+     * @param other The {@link FDBigInteger} to compare.\n@@ -957,4 +600,1 @@\n-    \/*@\n-     @ ensures \\result == (this.value() < other.value() ? -1 : this.value() > other.value() ? +1 : 0);\n-     @*\/\n-    public \/*@ pure @*\/ int cmp(FDBigInteger other) {\n+    public int cmp(FDBigInteger other) {\n@@ -971,4 +611,3 @@\n-            int a = data[--aLen];\n-            int b = other.data[--bLen];\n-            if (a != b) {\n-                return ((a & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;\n+            int cmp = Integer.compareUnsigned(data[--aLen], other.data[--bLen]);\n+            if (cmp != 0) {\n+                return cmp;\n@@ -987,39 +626,1 @@\n-     * Compares this <code>FDBigInteger<\/code> with\n-     * <code>5<sup>p5<\/sup> * 2<sup>p2<\/sup><\/code>.\n-     * Returns an integer accordingly as:\n-     * <pre>{@code\n-     * > 0: this > other\n-     *   0: this == other\n-     * < 0: this < other\n-     * }<\/pre>\n-     * @param p5 The exponent of the power-of-five factor.\n-     * @param p2 The exponent of the power-of-two factor.\n-     * @return A negative value, zero, or a positive value according to the\n-     * result of the comparison.\n-     *\/\n-    \/*@\n-     @ requires p5 >= 0 && p2 >= 0;\n-     @ ensures \\result == (this.value() < pow52(p5, p2) ? -1 : this.value() >  pow52(p5, p2) ? +1 : 0);\n-     @*\/\n-    public \/*@ pure @*\/ int cmpPow52(int p5, int p2) {\n-        if (p5 == 0) {\n-            int wordcount = p2 >> 5;\n-            int bitcount = p2 & 0x1f;\n-            int size = this.nWords + this.offset;\n-            if (size > wordcount + 1) {\n-                return 1;\n-            } else if (size < wordcount + 1) {\n-                return -1;\n-            }\n-            int a = this.data[this.nWords -1];\n-            int b = 1 << bitcount;\n-            if (a != b) {\n-                return ( (a & LONG_MASK) < (b & LONG_MASK)) ? -1 : 1;\n-            }\n-            return checkZeroTail(this.data, this.nWords - 1);\n-        }\n-        return this.cmp(big5pow(p5).leftShift(p2));\n-    }\n-\n-    \/**\n-     * Compares this <code>FDBigInteger<\/code> with <code>x + y<\/code>. Returns a\n+     * Compares this {@link FDBigInteger} with {@code x + y}. Returns a\n@@ -1036,4 +637,1 @@\n-    \/*@\n-     @ ensures \\result == (this.value() < x.value() + y.value() ? -1 : this.value() > x.value() + y.value() ? +1 : 0);\n-     @*\/\n-    public \/*@ pure @*\/ int addAndCmp(FDBigInteger x, FDBigInteger y) {\n+    public int addAndCmp(FDBigInteger x, FDBigInteger y) {\n@@ -1107,1 +705,3 @@\n-     * Makes this <code>FDBigInteger<\/code> immutable.\n+     * Makes this {@link FDBigInteger} immutable.\n+     *\n+     * @return {@code this}\n@@ -1109,6 +709,3 @@\n-    \/*@\n-     @ assignable this.isImmutable;\n-     @ ensures this.isImmutable;\n-     @*\/\n-    public void makeImmutable() {\n-        this.isImmutable = true;\n+    public FDBigInteger makeImmutable() {\n+        isImmutable = true;\n+        return this;\n@@ -1118,1 +715,1 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by an integer.\n+     * Multiplies this {@link FDBigInteger} by an integer.\n@@ -1120,2 +717,2 @@\n-     * @param i The factor by which to multiply this <code>FDBigInteger<\/code>.\n-     * @return This <code>FDBigInteger<\/code> multiplied by an integer.\n+     * @param v The factor by which to multiply this {@link FDBigInteger}.\n+     * @return This {@link FDBigInteger} multiplied by an integer.\n@@ -1123,13 +720,2 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() != 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * UNSIGNED(i));\n-     @*\/\n-    private FDBigInteger mult(int i) {\n-        if (this.nWords == 0) {\n+    public FDBigInteger mult(int v) {\n+        if (nWords == 0 || v == 0) {\n@@ -1139,1 +725,1 @@\n-        mult(data, nWords, i, r);\n+        mult(data, nWords, v, r);\n@@ -1144,1 +730,1 @@\n-     * Multiplies this <code>FDBigInteger<\/code> by another <code>FDBigInteger<\/code>.\n+     * Multiplies this {@link FDBigInteger} by another {@link FDBigInteger}.\n@@ -1146,2 +732,2 @@\n-     * @param other The <code>FDBigInteger<\/code> factor by which to multiply.\n-     * @return The product of this and the parameter <code>FDBigInteger<\/code>s.\n+     * @param other The {@link FDBigInteger} factor by which to multiply.\n+     * @return The product of this and the parameter {@link FDBigInteger}s.\n@@ -1149,17 +735,0 @@\n-    \/*@\n-     @ requires this.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == this;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() != 0 && other.value() == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == other;\n-     @\n-     @  also\n-     @\n-     @ requires this.value() != 0 && other.value() != 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() * other.value());\n-     @*\/\n@@ -1167,12 +736,0 @@\n-        if (this.nWords == 0) {\n-            return this;\n-        }\n-        if (this.size() == 1) {\n-            return other.mult(data[0]);\n-        }\n-        if (other.nWords == 0) {\n-            return other;\n-        }\n-        if (other.size() == 1) {\n-            return this.mult(other.data[0]);\n-        }\n@@ -1180,2 +737,2 @@\n-        mult(this.data, this.nWords, other.data, other.nWords, r);\n-        return new FDBigInteger(r, this.offset + other.offset);\n+        mult(data, nWords, other.data, other.nWords, r);\n+        return new FDBigInteger(r, offset + other.offset);\n@@ -1185,1 +742,1 @@\n-     * Adds another <code>FDBigInteger<\/code> to this <code>FDBigInteger<\/code>.\n+     * Adds another {@link FDBigInteger} to this {@link FDBigInteger}.\n@@ -1187,2 +744,2 @@\n-     * @param other The <code>FDBigInteger<\/code> to add.\n-     * @return The sum of the <code>FDBigInteger<\/code>s.\n+     * @param other The {@link FDBigInteger} to add.\n+     * @return The sum of the {@link FDBigInteger}s.\n@@ -1190,4 +747,0 @@\n-    \/*@\n-     @ assignable \\nothing;\n-     @ ensures \\result.value() == \\old(this.value() + other.value());\n-     @*\/\n@@ -1230,1 +783,1 @@\n-     * Multiplies a <code>FDBigInteger<\/code> by an int and adds another int. The\n+     * Multiplies a {@link FDBigInteger} by an int and adds another int. The\n@@ -1232,4 +785,1 @@\n-     * from\n-     * <code>\n-     * FDBigInteger(long lValue, char[] digits, int kDigits, int nDigits)\n-     * <\/code>.\n+     * from {@link FDBigInteger(long,char[],int,int)}.\n@@ -1237,1 +787,1 @@\n-     * @param iv The factor by which to multiply this <code>FDBigInteger<\/code>.\n+     * @param iv The factor by which to multiply this {@link FDBigInteger}.\n@@ -1239,1 +789,1 @@\n-     * <code>FDBigInteger<\/code> and <code>iv<\/code>.\n+     * {@link FDBigInteger} and {@code iv}.\n@@ -1241,6 +791,1 @@\n-    \/*@\n-     @ requires this.value()*UNSIGNED(iv) + UNSIGNED(addend) < ((\\bigint)1) << ((this.data.length + this.offset)*32);\n-     @ assignable this.data[*];\n-     @ ensures this.value() == \\old(this.value()*UNSIGNED(iv) + UNSIGNED(addend));\n-     @*\/\n-    private \/*@ helper @*\/ void multAddMe(int iv, int addend) {\n+    private void multAdd(int iv, int addend) {\n@@ -1258,1 +803,1 @@\n-            data[nWords++] = (int) p; \/\/ will fail noisily if illegal!\n+            data[nWords++] = (int) p;\n@@ -1262,6 +807,0 @@\n-    \/\/\n-    \/\/ original doc:\n-    \/\/\n-    \/\/ do this -=q*S\n-    \/\/ returns borrow\n-    \/\/\n@@ -1269,2 +808,1 @@\n-     * Multiplies the parameters and subtracts them from this\n-     * <code>FDBigInteger<\/code>.\n+     * Multiplies the parameters and subtracts them from this {@link FDBigInteger}.\n@@ -1273,2 +811,2 @@\n-     * @param S The <code>FDBigInteger<\/code> parameter.\n-     * @return <code>this - q*S<\/code>.\n+     * @param S The {@link FDBigInteger} parameter.\n+     * @return {@code this - q*S}.\n@@ -1276,27 +814,1 @@\n-    \/*@\n-     @ ensures nWords == 0 ==> offset == 0;\n-     @ ensures nWords > 0 ==> data[nWords - 1] != 0;\n-     @*\/\n-    \/*@\n-     @ requires 0 < q && q <= (1L << 31);\n-     @ requires data != null;\n-     @ requires 0 <= nWords && nWords <= data.length && offset >= 0;\n-     @ requires !this.isImmutable;\n-     @ requires this.size() == S.size();\n-     @ requires this != S;\n-     @ assignable this.nWords, this.offset, this.data, this.data[*];\n-     @ ensures -q <= \\result && \\result <= 0;\n-     @ ensures this.size() == \\old(this.size());\n-     @ ensures this.value() + (\\result << (this.size()*32)) == \\old(this.value() - q*S.value());\n-     @ ensures this.offset == \\old(Math.min(this.offset, S.offset));\n-     @ ensures \\old(this.offset <= S.offset) ==> this.nWords == \\old(this.nWords);\n-     @ ensures \\old(this.offset <= S.offset) ==> this.offset == \\old(this.offset);\n-     @ ensures \\old(this.offset <= S.offset) ==> this.data == \\old(this.data);\n-     @\n-     @  also\n-     @\n-     @ requires q == 0;\n-     @ assignable \\nothing;\n-     @ ensures \\result == 0;\n-     @*\/\n-    private \/*@ helper @*\/ long multDiffMe(long q, FDBigInteger S) {\n+    private long multSub(long q, FDBigInteger S) {\n@@ -1340,1 +852,0 @@\n-\n@@ -1346,1 +857,1 @@\n-     * @param srcLen The number of elements of <code>src<\/code> to use.\n+     * @param srcLen The number of elements of {@code src} to use.\n@@ -1350,6 +861,0 @@\n-    \/*@\n-     @ requires src.length >= srcLen && dst.length >= srcLen;\n-     @ assignable dst[0 .. srcLen - 1];\n-     @ ensures 0 <= \\result && \\result < 10;\n-     @ ensures AP(dst, srcLen) + (\\result << (srcLen*32)) == \\old(AP(src, srcLen) * 10);\n-     @*\/\n@@ -1368,1 +873,1 @@\n-     * The constant factor is an <code>int<\/code>.\n+     * The constant factor is an {@code int}.\n@@ -1371,1 +876,1 @@\n-     * @param srcLen The number of elements of <code>src<\/code> to use.\n+     * @param srcLen The number of elements of {@code src} to use.\n@@ -1375,5 +880,0 @@\n-    \/*@\n-     @ requires src.length >= srcLen && dst.length >= srcLen + 1;\n-     @ assignable dst[0 .. srcLen];\n-     @ ensures AP(dst, srcLen + 1) == \\old(AP(src, srcLen) * UNSIGNED(value));\n-     @*\/\n@@ -1381,1 +881,1 @@\n-        long val = value & LONG_MASK;\n+        long v = value & LONG_MASK;\n@@ -1383,2 +883,3 @@\n-        for (int i = 0; i < srcLen; i++) {\n-            long product = (src[i] & LONG_MASK) * val + carry;\n+        int i = 0;\n+        for (; i < srcLen; i++) {\n+            long product = v * (src[i] & LONG_MASK) + carry;\n@@ -1388,1 +889,1 @@\n-        dst[srcLen] = (int) carry;\n+        dst[i] = (int) carry;\n@@ -1393,1 +894,1 @@\n-     * The constant factor is a long represent as two <code>int<\/code>s.\n+     * The constant factor is a long represent as two {@code int}s.\n@@ -1396,1 +897,1 @@\n-     * @param srcLen The number of elements of <code>src<\/code> to use.\n+     * @param srcLen The number of elements of {@code src} to use.\n@@ -1401,6 +902,0 @@\n-    \/*@\n-     @ requires src != dst;\n-     @ requires src.length >= srcLen && dst.length >= srcLen + 2;\n-     @ assignable dst[0 .. srcLen + 1];\n-     @ ensures AP(dst, srcLen + 2) == \\old(AP(src, srcLen) * (UNSIGNED(v0) + (UNSIGNED(v1) << 32)));\n-     @*\/\n@@ -1410,1 +905,2 @@\n-        for (int j = 0; j < srcLen; j++) {\n+        int j = 0;\n+        for (; j < srcLen; j++) {\n@@ -1415,1 +911,2 @@\n-        dst[srcLen] = (int) carry;\n+        dst[j] = (int) carry;\n+\n@@ -1418,3 +915,4 @@\n-        for (int j = 0; j < srcLen; j++) {\n-            long product = (dst[j + 1] & LONG_MASK) + v * (src[j] & LONG_MASK) + carry;\n-            dst[j + 1] = (int) product;\n+        j = 1;\n+        for (; j <= srcLen; j++) {\n+            long product = (dst[j] & LONG_MASK) + v * (src[j - 1] & LONG_MASK) + carry;\n+            dst[j] = (int) product;\n@@ -1423,1 +921,1 @@\n-        dst[srcLen + 1] = (int) carry;\n+        dst[j] = (int) carry;\n@@ -1426,3 +924,5 @@\n-    \/\/ Fails assertion for negative exponent.\n-    \/**\n-     * Computes <code>5<\/code> raised to a given power.\n+    \/*\n+     * Lookup table of powers of 5 starting with 5^MAX_FIVE_POW.\n+     * The size just serves for the conversions.\n+     * It is filled lazily, except for the entries with exponent\n+     * 2 (MAX_FIVE_POW - 1) and 3 (MAX_FIVE_POW - 1).\n@@ -1430,2 +930,2 @@\n-     * @param p The exponent of 5.\n-     * @return <code>5<sup>p<\/sup><\/code>.\n+     * Access needs not be synchronized for thread-safety, since races would\n+     * produce the same non-null value (although not the same instance).\n@@ -1433,7 +933,2 @@\n-    private static FDBigInteger big5pow(int p) {\n-        assert p >= 0 : p; \/\/ negative power of 5\n-        if (p < MAX_FIVE_POW) {\n-            return POW_5_CACHE[p];\n-        }\n-        return big5powRec(p);\n-    }\n+    @Stable\n+    private static final FDBigInteger[] LARGE_POW_5_CACHE;\n@@ -1441,1 +936,0 @@\n-    \/\/ slow path\n@@ -1443,1 +937,1 @@\n-     * Computes <code>5<\/code> raised to a given power.\n+     * Computes 5<sup>{@code e}<\/sup>.\n@@ -1445,2 +939,3 @@\n-     * @param p The exponent of 5.\n-     * @return <code>5<sup>p<\/sup><\/code>.\n+     * @param e The exponent of 5.\n+     * @return 5<sup>{@code e}<\/sup>.\n+     * @throws IllegalArgumentException if e > 2 - DoubleToDecimal.Q_MIN = 1076\n@@ -1448,3 +943,3 @@\n-    private static FDBigInteger big5powRec(int p) {\n-        if (p < MAX_FIVE_POW) {\n-            return POW_5_CACHE[p];\n+    private static FDBigInteger pow5(int e) {\n+        if (e < MAX_FIVE_POW) {\n+            return POW_5_CACHE[e];\n@@ -1452,14 +947,11 @@\n-        \/\/ construct the value.\n-        \/\/ recursively.\n-        int q, r;\n-        \/\/ in order to compute 5^p,\n-        \/\/ compute its square root, 5^(p\/2) and square.\n-        \/\/ or, let q = p \/ 2, r = p -q, then\n-        \/\/ 5^p = 5^(q+r) = 5^q * 5^r\n-        q = p >> 1;\n-        r = p - q;\n-        FDBigInteger bigq = big5powRec(q);\n-        if (r < SMALL_5_POW.length) {\n-            return bigq.mult(SMALL_5_POW[r]);\n-        } else {\n-            return bigq.mult(big5powRec(r));\n+        if (e > 2 - DoubleToDecimal.Q_MIN) {\n+            throw new IllegalArgumentException(\"exponent too large: \" + e);\n+        }\n+        FDBigInteger p5 = LARGE_POW_5_CACHE[e - MAX_FIVE_POW];\n+        if (p5 == null) {\n+            int ep = (e - 1) - (e - 1) % (MAX_FIVE_POW - 1);\n+            p5 = (ep < MAX_FIVE_POW\n+                    ? POW_5_CACHE[ep]\n+                    : LARGE_POW_5_CACHE[ep - MAX_FIVE_POW])\n+                    .mult(POW_5_CACHE[e - ep]);\n+            LARGE_POW_5_CACHE[e - MAX_FIVE_POW] = p5.makeImmutable();\n@@ -1467,0 +959,1 @@\n+        return p5;\n@@ -1471,1 +964,1 @@\n-     * Converts this <code>FDBigInteger<\/code> to a hexadecimal string.\n+     * Converts this {@link FDBigInteger} to a hexadecimal string.\n@@ -1475,2 +968,3 @@\n-    public String toHexString(){\n-        if(nWords ==0) {\n+    @Override\n+    public String toString() {\n+        if (nWords == 0) {\n@@ -1479,10 +973,6 @@\n-        StringBuilder sb = new StringBuilder((nWords +offset)*8);\n-        for(int i= nWords -1; i>=0; i--) {\n-            String subStr = Integer.toHexString(data[i]);\n-            for(int j = subStr.length(); j<8; j++) {\n-                sb.append('0');\n-            }\n-            sb.append(subStr);\n-        }\n-        for(int i=offset; i>0; i--) {\n-            sb.append(\"00000000\");\n+        StringBuilder sb = new StringBuilder(8 * (size()));\n+        int i = nWords - 1;\n+        sb.append(Integer.toHexString(data[i--]));\n+        while (i >= 0) {\n+            String subStr = Integer.toHexString(data[i--]);\n+            sb.repeat('0', 8 - subStr.length()).append(subStr);\n@@ -1490,1 +980,1 @@\n-        return sb.toString();\n+        return sb.repeat('0', 8 * offset).toString();\n@@ -1495,1 +985,2 @@\n-     * Converts this <code>FDBigInteger<\/code> to a <code>BigInteger<\/code>.\n+     * Converts this {@link FDBigInteger} to a {@code byte[]} suitable\n+     * for use with {@link java.math.BigInteger#BigInteger(byte[])}.\n@@ -1497,1 +988,1 @@\n-     * @return The <code>BigInteger<\/code> representation.\n+     * @return The {@code byte[]} representation.\n@@ -1499,3 +990,8 @@\n-    public BigInteger toBigInteger() {\n-        byte[] magnitude = new byte[nWords * 4 + 1];\n-        for (int i = 0; i < nWords; i++) {\n+    \/*\n+     * A toBigInteger() method would be more convenient, but it would introduce\n+     * a dependency on java.math, which is not desirable in such a basic layer\n+     * like this one used in components as java.lang, javac, and others.\n+     *\/\n+    public byte[] toByteArray() {\n+        byte[] magnitude = new byte[4 * size() + 1];  \/\/ +1 for the \"sign\" byte\n+        for (int i = 0, j = magnitude.length - 4 * offset; i < nWords; i += 1, j -= 4) {\n@@ -1503,4 +999,4 @@\n-            magnitude[magnitude.length - 4 * i - 1] = (byte) w;\n-            magnitude[magnitude.length - 4 * i - 2] = (byte) (w >> 8);\n-            magnitude[magnitude.length - 4 * i - 3] = (byte) (w >> 16);\n-            magnitude[magnitude.length - 4 * i - 4] = (byte) (w >> 24);\n+            magnitude[j - 1] = (byte) w;\n+            magnitude[j - 2] = (byte) (w >> 8);\n+            magnitude[j - 3] = (byte) (w >> 16);\n+            magnitude[j - 4] = (byte) (w >> 24);\n@@ -1508,1 +1004,1 @@\n-        return new BigInteger(magnitude).shiftLeft(offset * 32);\n+        return magnitude;\n@@ -1511,10 +1007,0 @@\n-    \/\/ for debugging ...\n-    \/**\n-     * Converts this <code>FDBigInteger<\/code> to a string.\n-     *\n-     * @return The string representation.\n-     *\/\n-    @Override\n-    public String toString(){\n-        return toBigInteger().toString();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FDBigInteger.java","additions":354,"deletions":868,"binary":false,"changes":1222,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import static jdk.internal.math.FDBigInteger.valueOfMulPow52;\n+import static jdk.internal.math.FDBigInteger.valueOfPow52;\n+\n@@ -33,2 +36,2 @@\n- * static convenience methods, although a <code>BinaryToASCIIConverter<\/code>\n- * instance may be obtained and reused.\n+ * static convenience methods, although a {@link BinaryToASCIIBuffer}\n+ * instance may be obtained.\n@@ -36,1 +39,1 @@\n-public class FloatingDecimal{\n+public final class FloatingDecimal {\n@@ -40,1 +43,0 @@\n-    \/\/ (There are more really boring constants at the end.)\n@@ -42,18 +44,7 @@\n-    static final int    EXP_SHIFT = DoubleConsts.SIGNIFICAND_WIDTH - 1;\n-    static final long   FRACT_HOB = ( 1L<<EXP_SHIFT ); \/\/ assumed High-Order bit\n-    static final long   EXP_ONE   = ((long)DoubleConsts.EXP_BIAS)<<EXP_SHIFT; \/\/ exponent of 1.0\n-    static final int    MAX_SMALL_BIN_EXP = 62;\n-    static final int    MIN_SMALL_BIN_EXP = -( 63 \/ 3 );\n-    static final int    MAX_DECIMAL_DIGITS = 15;\n-    static final int    MAX_DECIMAL_EXPONENT = 308;\n-    static final int    MIN_DECIMAL_EXPONENT = -324;\n-    static final int    MAX_NDIGITS = 1100;\n-\n-    static final int    SINGLE_EXP_SHIFT  =   FloatConsts.SIGNIFICAND_WIDTH - 1;\n-    static final int    SINGLE_FRACT_HOB  =   1<<SINGLE_EXP_SHIFT;\n-    static final int    SINGLE_MAX_DECIMAL_DIGITS = 7;\n-    static final int    SINGLE_MAX_DECIMAL_EXPONENT = 38;\n-    static final int    SINGLE_MIN_DECIMAL_EXPONENT = -45;\n-    static final int    SINGLE_MAX_NDIGITS = 200;\n-\n-    static final int    INT_DECIMAL_DIGITS = 9;\n+    private static final int    EXP_SHIFT = DoubleConsts.SIGNIFICAND_WIDTH - 1;\n+    private static final long   FRACT_HOB = 1L << EXP_SHIFT; \/\/ assumed High-Order bit\n+    private static final long   EXP_ONE   = (long) DoubleConsts.EXP_BIAS << EXP_SHIFT; \/\/ exponent of 1.0\n+    private static final int    MAX_SMALL_BIN_EXP = 62;\n+    private static final int    MIN_SMALL_BIN_EXP = -63 \/ 3;\n+    private static final int    MAX_DEC_DIGITS = 15;  \/\/ max{n : 10^n ≤ 2^P}\n+    private static final int    FLOG_10_MAX_LONG = 18;  \/\/ max{i : 10^i ≤ Long.MAX_VALUE}\n@@ -62,1 +53,1 @@\n-     * Converts a <code>String<\/code> to a double precision floating point value.\n+     * Converts a {@link String} to a double precision floating point value.\n@@ -64,1 +55,1 @@\n-     * @param s The <code>String<\/code> to convert.\n+     * @param s The {@link String} to convert.\n@@ -66,1 +57,1 @@\n-     * @throws NumberFormatException If the <code>String<\/code> does not\n+     * @throws NumberFormatException If the {@link String} does not\n@@ -70,1 +61,1 @@\n-        return readJavaFormatString(s, BINARY_64_IX).doubleValue();\n+        return readJavaFormatString(s, BINARY_64_IX);\n@@ -74,1 +65,1 @@\n-     * Converts a <code>String<\/code> to a single precision floating point value.\n+     * Converts a {@link String} to a single precision floating point value.\n@@ -76,1 +67,1 @@\n-     * @param s The <code>String<\/code> to convert.\n+     * @param s The {@link String} to convert.\n@@ -78,1 +69,1 @@\n-     * @throws NumberFormatException If the <code>String<\/code> does not\n+     * @throws NumberFormatException If the {@link String} does not\n@@ -82,1 +73,1 @@\n-        return readJavaFormatString(s, BINARY_32_IX).floatValue();\n+        return (float) readJavaFormatString(s, BINARY_32_IX);\n@@ -90,1 +81,1 @@\n-     * @param digits The digits of the significand.\n+     * @param d The digits of the significand.\n@@ -94,37 +85,2 @@\n-    public static double parseDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n-        return readDoubleSignlessDigits(decExp, digits, length).doubleValue();\n-    }\n-\n-    \/**\n-     * A converter which can process single or double precision floating point\n-     * values into an ASCII <code>String<\/code> representation.\n-     *\/\n-    public interface BinaryToASCIIConverter {\n-\n-        \/**\n-         * Retrieves the decimal exponent most closely corresponding to this value.\n-         * @return The decimal exponent.\n-         *\/\n-        int getDecimalExponent();\n-\n-        \/**\n-         * Retrieves the value as an array of digits.\n-         * @param digits The digit array.\n-         * @return The number of valid digits copied into the array.\n-         *\/\n-        int getDigits(byte[] digits);\n-\n-        \/**\n-         * Indicates whether the value was rounded up during the binary to ASCII\n-         * conversion.\n-         *\n-         * @return <code>true<\/code> if and only if the value was rounded up.\n-         *\/\n-        boolean digitsRoundedUp();\n-\n-        \/**\n-         * Indicates whether the binary to ASCII conversion was exact.\n-         *\n-         * @return <code>true<\/code> if any only if the conversion was exact.\n-         *\/\n-        boolean decimalDigitsExact();\n+    public static double parseDoubleSignlessDigits(int decExp, byte[] d, int length) {\n+        return new ASCIIToBinaryBuffer(false, decExp, d, length).doubleValue();\n@@ -136,2 +92,4 @@\n-    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new byte[]{'0'});\n-    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new byte[]{'0'});\n+    private static final BinaryToASCIIBuffer B2AC_POSITIVE_ZERO =\n+            new BinaryToASCIIBuffer(new byte[] {'0'});\n+    private static final BinaryToASCIIBuffer B2AC_NEGATIVE_ZERO =\n+            new BinaryToASCIIBuffer(new byte[] {'0'});\n@@ -139,5 +97,1 @@\n-    \/**\n-     * A buffered implementation of <code>BinaryToASCIIConverter<\/code>.\n-     *\/\n-    static class BinaryToASCIIBuffer implements BinaryToASCIIConverter {\n-        private boolean isNegative;\n+    public static final class BinaryToASCIIBuffer {\n@@ -164,1 +118,1 @@\n-         * <code>BinaryToASCIIBuffer<\/code> may be thread-local and reused\n+         * {@link BinaryToASCIIBuffer} may be thread-local and reused\n@@ -166,1 +120,1 @@\n-        BinaryToASCIIBuffer(){\n+        private BinaryToASCIIBuffer() {\n@@ -173,2 +127,1 @@\n-        BinaryToASCIIBuffer(boolean isNegative, byte[] digits){\n-            this.isNegative = isNegative;\n+        private BinaryToASCIIBuffer(byte[] digits){\n@@ -181,1 +134,0 @@\n-        @Override\n@@ -186,1 +138,0 @@\n-        @Override\n@@ -192,1 +143,0 @@\n-        @Override\n@@ -197,1 +147,0 @@\n-        @Override\n@@ -202,4 +151,0 @@\n-        private void setSign(boolean isNegative) {\n-            this.isNegative = isNegative;\n-        }\n-\n@@ -215,1 +160,1 @@\n-         *\n+         *<p>\n@@ -221,1 +166,2 @@\n-        private void developLongDigits( int decExponent, long lvalue, int insignificantDigits ){\n+        private void developLongDigits( long lvalue, int insignificantDigits ){\n+            int decExponent = 0;\n@@ -278,1 +224,1 @@\n-        private void dtoa( int binExp, long fractBits, int nSignificantBits, boolean isCompatibleFormat)\n+        private void dtoa( int binExp, long fractBits, int nSignificantBits)\n@@ -330,1 +276,1 @@\n-                        developLongDigits( 0, fractBits, insignificant );\n+                        developLongDigits( fractBits, insignificant );\n@@ -424,1 +370,1 @@\n-            int ndigit = 0;\n+            int ndigit;\n@@ -480,1 +426,1 @@\n-                    if ( !isCompatibleFormat ||decExp < -3 || decExp >= 8 ){\n+                    if (decExp < -3 || decExp >= 8){\n@@ -534,1 +480,1 @@\n-                    if ( !isCompatibleFormat || decExp < -3 || decExp >= 8 ){\n+                    if (decExp < -3 || decExp >= 8){\n@@ -564,1 +510,1 @@\n-                FDBigInteger Sval = FDBigInteger.valueOfPow52(S5, S2);\n+                FDBigInteger Sval = valueOfPow52(S5, S2);\n@@ -568,2 +514,2 @@\n-                FDBigInteger Bval = FDBigInteger.valueOfMulPow52(fractBits, B5, B2 + shiftBias);\n-                FDBigInteger Mval = FDBigInteger.valueOfPow52(M5 + 1, M2 + shiftBias + 1);\n+                FDBigInteger Bval = valueOfMulPow52(fractBits, B5, B2 + shiftBias);\n+                FDBigInteger Mval = valueOfPow52(M5 + 1, M2 + shiftBias + 1);\n@@ -571,1 +517,1 @@\n-                FDBigInteger tenSval = FDBigInteger.valueOfPow52(S5 + 1, S2 + shiftBias + 1); \/\/Sval.mult( 10 );\n+                FDBigInteger tenSval = valueOfPow52(S5 + 1, S2 + shiftBias + 1); \/\/Sval.mult( 10 );\n@@ -595,1 +541,1 @@\n-                if (!isCompatibleFormat || decExp < -3 || decExp >= 8 ){\n+                if (decExp < -3 || decExp >= 8){\n@@ -612,1 +558,1 @@\n-                exactDecimalConversion  = (Bval.cmp( FDBigInteger.ZERO ) == 0);\n+                exactDecimalConversion  = Bval.isZero();\n@@ -665,1 +611,1 @@\n-         *\n+         *<p>\n@@ -673,1 +619,1 @@\n-        static int estimateDecExp(long fractBits, int binExp) {\n+        private static int estimateDecExp(long fractBits, int binExp) {\n@@ -708,0 +654,1 @@\n+        @Stable\n@@ -714,1 +661,1 @@\n-            18, 18, 18, 19\n+            18, 18, 18, 19,\n@@ -718,0 +665,1 @@\n+        @Stable\n@@ -746,0 +694,1 @@\n+                63,\n@@ -751,6 +700,1 @@\n-            new ThreadLocal<BinaryToASCIIBuffer>() {\n-                @Override\n-                protected BinaryToASCIIBuffer initialValue() {\n-                    return new BinaryToASCIIBuffer();\n-                }\n-            };\n+            ThreadLocal.withInitial(BinaryToASCIIBuffer::new);\n@@ -762,15 +706,6 @@\n-    \/**\n-     * A converter which can process an ASCII <code>String<\/code> representation\n-     * of a single or double precision floating point value into a\n-     * <code>float<\/code> or a <code>double<\/code>.\n-     *\/\n-    interface ASCIIToBinaryConverter {\n-\n-        double doubleValue();\n-\n-        float floatValue();\n-\n-    }\n-\n-    \/**\n-     * A <code>ASCIIToBinaryConverter<\/code> container for a <code>double<\/code>.\n+    \/*\n+     * The mathematical value x of an instance is\n+     *      ±<0.d_1...d_n> 10^e\n+     * where d_i = d[i-1] - '0' (0 < i ≤ n) is the i-th digit.\n+     * It is assumed that d_1 > 0.\n+     * isNegative denotes the - sign.\n@@ -778,3 +713,1 @@\n-    static class PreparedASCIIToBinaryBuffer implements ASCIIToBinaryConverter {\n-        private final double doubleVal;\n-        private final float floatVal;\n+    private static final class ASCIIToBinaryBuffer {\n@@ -782,4 +715,4 @@\n-        public PreparedASCIIToBinaryBuffer(double doubleVal, float floatVal) {\n-            this.doubleVal = doubleVal;\n-            this.floatVal = floatVal;\n-        }\n+        private final boolean isNegative;\n+        private final int e;\n+        private final int n;\n+        private final byte[] d;\n@@ -787,3 +720,5 @@\n-        @Override\n-        public double doubleValue() {\n-            return doubleVal;\n+        private ASCIIToBinaryBuffer(boolean isNegative, int e, byte[] d, int n) {\n+            this.isNegative = isNegative;\n+            this.e = e;\n+            this.d = d;\n+            this.n = n;\n@@ -792,3 +727,7 @@\n-        @Override\n-        public float floatValue() {\n-            return floatVal;\n+        \/* Assumes n ≤ 19 and returns a decimal prefix of f as an unsigned long. *\/\n+        private long toLong(int n) {\n+            long f = 0;\n+            for (int i = 0; i < n; ++i) {\n+                f = 10 * f + (d[i] - '0');\n+            }\n+            return f;\n@@ -796,1 +735,0 @@\n-    }\n@@ -798,22 +736,9 @@\n-    static final ASCIIToBinaryConverter A2BC_POSITIVE_INFINITY = new PreparedASCIIToBinaryBuffer(Double.POSITIVE_INFINITY, Float.POSITIVE_INFINITY);\n-    static final ASCIIToBinaryConverter A2BC_NEGATIVE_INFINITY = new PreparedASCIIToBinaryBuffer(Double.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);\n-    static final ASCIIToBinaryConverter A2BC_NOT_A_NUMBER  = new PreparedASCIIToBinaryBuffer(Double.NaN, Float.NaN);\n-    static final ASCIIToBinaryConverter A2BC_POSITIVE_ZERO = new PreparedASCIIToBinaryBuffer(0.0d, 0.0f);\n-    static final ASCIIToBinaryConverter A2BC_NEGATIVE_ZERO = new PreparedASCIIToBinaryBuffer(-0.0d, -0.0f);\n-\n-    \/**\n-     * A buffered implementation of <code>ASCIIToBinaryConverter<\/code>.\n-     *\/\n-    static class ASCIIToBinaryBuffer implements ASCIIToBinaryConverter {\n-        final boolean isNegative;\n-        final int     decExponent;\n-        final byte[]  digits;\n-        int           nDigits;\n-\n-        ASCIIToBinaryBuffer( boolean negSign, int decExponent, byte[] digits, int n)\n-        {\n-            this.isNegative = negSign;\n-            this.decExponent = decExponent;\n-            this.digits = digits;\n-            this.nDigits = n;\n-        }\n+        private double doubleValue() {\n+            \/*\n+             * As described above, the magnitude of the mathematical value is\n+             *      x = <0.d_1...d_n> 10^e = <d_1...d_n> 10^(e-n) = f 10^ep\n+             * where f = <d_1...d_n> and ep = e - n are integers.\n+             *\n+             * Let r_e denote the roundTiesToEven rounding.\n+             * This method returns ±r_e(x).\n+             *\/\n@@ -821,19 +746,4 @@\n-        \/**\n-         * Takes a FloatingDecimal, which we presumably just scanned in,\n-         * and finds out what its value is, as a double.\n-         *\n-         * AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED\n-         * ROUNDING DIRECTION in case the result is really destined\n-         * for a single-precision float.\n-         *\/\n-        @Override\n-        public double doubleValue() {\n-            int kDigits = Math.min(nDigits, MAX_DECIMAL_DIGITS + 1);\n-            \/\/\n-            \/\/ convert the lead kDigits to a long integer.\n-            \/\/\n-            \/\/ (special performance hack: start to do it using int)\n-            int iValue = (int) digits[0] - (int) '0';\n-            int iDigits = Math.min(kDigits, INT_DECIMAL_DIGITS);\n-            for (int i = 1; i < iDigits; i++) {\n-                iValue = iValue * 10 + (int) digits[i] - (int) '0';\n+             \/* Filter out extremely small or extremely large x. *\/\n+            if (e <= DoubleToDecimal.E_THR_Z) {\n+                \/* Test cases: \"0.9e-324\", \"3e-500\" *\/\n+                return signed(0.0);\n@@ -841,3 +751,3 @@\n-            long lValue = (long) iValue;\n-            for (int i = iDigits; i < kDigits; i++) {\n-                lValue = lValue * 10L + (long) ((int) digits[i] - (int) '0');\n+            if (e >= DoubleToDecimal.E_THR_I) {\n+                \/* Test cases: \"0.1e310\", \"4e500\" *\/\n+                return signed(Double.POSITIVE_INFINITY);\n@@ -845,7 +755,0 @@\n-            double dValue = (double) lValue;\n-            int exp = decExponent - kDigits;\n-            \/\/\n-            \/\/ lValue now contains a long integer with the value of\n-            \/\/ the first kDigits digits of the number.\n-            \/\/ dValue contains the (double) of the same.\n-            \/\/\n@@ -853,50 +756,36 @@\n-            if (nDigits <= MAX_DECIMAL_DIGITS) {\n-                \/\/\n-                \/\/ possibly an easy case.\n-                \/\/ We know that the digits can be represented\n-                \/\/ exactly. And if the exponent isn't too outrageous,\n-                \/\/ the whole thing can be done with one operation,\n-                \/\/ thus one rounding error.\n-                \/\/ Note that all our constructors trim all leading and\n-                \/\/ trailing zeros, so simple values (including zero)\n-                \/\/ will always end up here\n-                \/\/\n-                if (exp == 0 || dValue == 0.0) {\n-                    return (isNegative) ? -dValue : dValue; \/\/ small floating integer\n-                }\n-                else if (exp >= 0) {\n-                    if (exp <= MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer with one operation,\n-                        \/\/ thus one roundoff.\n-                        \/\/\n-                        double rValue = dValue * SMALL_10_POW[exp];\n-                        return (isNegative) ? -rValue : rValue;\n-                    }\n-                    int slop = MAX_DECIMAL_DIGITS - kDigits;\n-                    if (exp <= MAX_SMALL_TEN + slop) {\n-                        \/\/\n-                        \/\/ We can multiply dValue by 10^(slop)\n-                        \/\/ and it is still \"small\" and exact.\n-                        \/\/ Then we can multiply by 10^(exp-slop)\n-                        \/\/ with one rounding.\n-                        \/\/\n-                        dValue *= SMALL_10_POW[slop];\n-                        double rValue = dValue * SMALL_10_POW[exp - slop];\n-                        return (isNegative) ? -rValue : rValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a positive exp.\n-                    \/\/\n-                } else {\n-                    if (exp >= -MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer in one division.\n-                        \/\/\n-                        double rValue = dValue \/ SMALL_10_POW[-exp];\n-                        return (isNegative) ? -rValue : rValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a negative exp.\n-                    \/\/\n-                }\n+            \/*\n+             * Attempt some fast paths before resorting to higher precision.\n+             * Here, let P = Double.PRECISION = 53.\n+             *\n+             * Below, fl is an unsigned long, thus we require n ≤ 19 because\n+             * 10^19 < 2^64 < 10^20.\n+             *\/\n+            int n = this.n;\n+            int ep = e - n;\n+            double v;\n+            int m = Math.min(n, MathUtils.N);\n+            long fl = toLong(m);  \/\/ unsigned\n+            if (n <= MathUtils.N && 0 <= ep && e <= MathUtils.N) {\n+                \/*\n+                 * Here, n ≤ 19, hence f = fl < 10^19.\n+                 * Since e = n + ep and 0 ≤ ep ∧ n + ep ≤ 19 we see that\n+                 * x = f 10^ep < 10^n 10^ep = 10^(n+ep) ≤ 10^19.\n+                 * Thus, x = fl 10^ep fits in an unsigned long as well.\n+                 * If its most significant bit is 0, the long is non-negative.\n+                 * Otherwise, fl ≥ 2^63, so there's room for P precision bits,\n+                 * +1 rounding bit, +1 sticky bit.\n+                 * In both cases, correct rounding is achieved as below.\n+                 * All integer x < 10^19 are covered here.\n+                 *\/\n+\n+                \/*\n+                 * Test cases:\n+                 *      for fl < 2^63: \"1\", \"2.34000e2\", \"9.223e18\";\n+                 *      for fl ≥ 2^63: \"9.876e18\", \"9223372036854776833\" (this\n+                 *          is 2^63 + 2^10 + 1, rounding up due to sticky bit),\n+                 *          \"9223372036854776832\" (this is 2^63 + 2^10, halfway\n+                 *          value rounding down to even);\n+                 *\/\n+                fl *= MathUtils.pow10(ep);  \/\/ 0 ≤ ep < 19\n+                v = fl >= 0 ? fl : 2.0 * (fl >>> 1 | fl & 0b1);\n+                return signed(v);\n@@ -905,54 +794,24 @@\n-            \/\/\n-            \/\/ Harder cases:\n-            \/\/ The sum of digits plus exponent is greater than\n-            \/\/ what we think we can do with one error.\n-            \/\/\n-            \/\/ Start by approximating the right answer by,\n-            \/\/ naively, scaling by powers of 10.\n-            \/\/\n-            if (exp > 0) {\n-                if (decExponent > MAX_DECIMAL_EXPONENT + 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ Infinity. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue *= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 1; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= BIG_10_POW[j];\n-                        }\n-                    }\n-                    \/\/\n-                    \/\/ The reason for the weird exp > 1 condition\n-                    \/\/ in the above loop was so that the last multiply\n-                    \/\/ would get unrolled. We handle it here.\n-                    \/\/ It could overflow.\n-                    \/\/\n-                    double t = dValue * BIG_10_POW[j];\n-                    if (Double.isInfinite(t)) {\n-                        \/\/\n-                        \/\/ It did overflow.\n-                        \/\/ Look more closely at the result.\n-                        \/\/ If the exponent is just one too large,\n-                        \/\/ then use the maximum finite as our estimate\n-                        \/\/ value. Else call the result infinity\n-                        \/\/ and punt it.\n-                        \/\/ ( I presume this could happen because\n-                        \/\/ rounding forces the result here to be\n-                        \/\/ an ULP or two larger than\n-                        \/\/ Double.MAX_VALUE ).\n-                        \/\/\n-                        t = dValue \/ 2.0;\n-                        t *= BIG_10_POW[j];\n-                        if (Double.isInfinite(t)) {\n-                            return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n-                        }\n-                        t = Double.MAX_VALUE;\n-                    }\n-                    dValue = t;\n+            if (n <= FLOG_10_MAX_LONG && -MAX_SMALL_TEN <= ep) {\n+                v = fl;\n+                \/*\n+                 * Here, -22 ≤ ep.\n+                 * Further, fl < 10^18, so fl is an exact double iff\n+                 * (long) v == fl holds.\n+                 * If fl is not an exact double, resort to higher precision.\n+                 *\/\n+                boolean isExact = (long) v == fl;\n+                if (isExact && ep <= MAX_SMALL_TEN) {\n+                    \/*\n+                     * Here, -22 ≤ ep ≤ 22, so 10^|ep| is an exact double.\n+                     * The product or quotient below operate on exact doubles,\n+                     * so the result is correctly rounded.\n+                     *\/\n+\n+                    \/*\n+                     * Test cases:\n+                     *      for ep < 0: \"1.23\", \"0.000234\";\n+                     *      for ep > 0: \"3.45e23\", \"576460752303423616e20\" (the\n+                     *          significand is 2^59 + 2^7, an exact double);\n+                     *\/\n+                    v = ep >= 0 ? v * SMALL_10_POW[ep] : v \/ SMALL_10_POW[-ep];\n+                    return signed(v);\n@@ -960,45 +819,33 @@\n-            } else if (exp < 0) {\n-                exp = -exp;\n-                if (decExponent < MIN_DECIMAL_EXPONENT - 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ zero. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? -0.0 : 0.0;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue \/= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 1; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= TINY_10_POW[j];\n-                        }\n-                    }\n-                    \/\/\n-                    \/\/ The reason for the weird exp > 1 condition\n-                    \/\/ in the above loop was so that the last multiply\n-                    \/\/ would get unrolled. We handle it here.\n-                    \/\/ It could underflow.\n-                    \/\/\n-                    double t = dValue * TINY_10_POW[j];\n-                    if (t == 0.0) {\n-                        \/\/\n-                        \/\/ It did underflow.\n-                        \/\/ Look more closely at the result.\n-                        \/\/ If the exponent is just one too small,\n-                        \/\/ then use the minimum finite as our estimate\n-                        \/\/ value. Else call the result 0.0\n-                        \/\/ and punt it.\n-                        \/\/ ( I presume this could happen because\n-                        \/\/ rounding forces the result here to be\n-                        \/\/ an ULP or two less than\n-                        \/\/ Double.MIN_VALUE ).\n-                        \/\/\n-                        t = dValue * 2.0;\n-                        t *= TINY_10_POW[j];\n-                        if (t == 0.0) {\n-                            return (isNegative) ? -0.0 : 0.0;\n-                        }\n-                        t = Double.MIN_VALUE;\n+\n+                \/*\n+                 * Here, fl < 10^18 is not an exact double, or ep > 22.\n+                 * If fl is not an exact double, resort to higher precision.\n+                 *\/\n+                if (isExact) {  \/\/ v and fl are mathematically equal.\n+                    \/*\n+                     * Here, ep > 22.\n+                     * We have f = fl = v.\n+                     * Note that 2^P = 9007199254740992 has 16 digits.\n+                     * If f does not start with 9 let ef = 16 - n, otherwise\n+                     * let ef = 15 - n.\n+                     * If ef < 0 then resort to higher precision.\n+                     * Otherwise, if f does not start with 9 we have n ≤ 16,\n+                     * so f 10^ef < 9 10^(n-1) 10^ef = 9 10^15 < 2^P.\n+                     * If f starts with 9 we have n ≤ 15, hence f 10^ef <\n+                     * 10^n 10^ef = 10^15 < 2^P.\n+                     *\n+                     * Hence, when ef ≥ 0 and ep - ef ≤ 22 we know that\n+                     * fl 10^ep = (fl 10^ef) 10^(ep-ef), with fl, (fl 10^ef),\n+                     * and 10^(ep-ef) all exact doubles.\n+                     *\/\n+                    int ef = (d[0] < '9' ? MAX_DEC_DIGITS + 1 : MAX_DEC_DIGITS) - n;\n+                    if (ef >= 0 && ep - ef <= MAX_SMALL_TEN) {\n+                        \/*\n+                         * Test cases:\n+                         *      f does not start with 9: \"1e37\", \"8999e34\";\n+                         *      f starts with 9: \"0.9999e36\", \"0.9876e37\";\n+                         *\/\n+\n+                        \/* Rely on left-to-right evaluation. *\/\n+                        v = v * SMALL_10_POW[ef] * SMALL_10_POW[ep - ef];\n+                        return signed(v);\n@@ -1006,1 +853,0 @@\n-                    dValue = t;\n@@ -1010,10 +856,11 @@\n-            \/\/\n-            \/\/ dValue is now approximately the result.\n-            \/\/ The hard part is adjusting it, by comparison\n-            \/\/ with FDBigInteger arithmetic.\n-            \/\/ Formulate the EXACT big-number result as\n-            \/\/ bigD0 * 10^exp\n-            \/\/\n-            if (nDigits > MAX_NDIGITS) {\n-                nDigits = MAX_NDIGITS + 1;\n-                digits[MAX_NDIGITS] = '1';\n+            \/*\n+             * Here, the above fast paths have failed to return.\n+             * Force ll, lh in [10^(N-1), 10^N] to have more high order bits.\n+             *\/\n+            long ll = fl;  \/\/ unsigned\n+            long lh;  \/\/ unsigned\n+            if (n <= MathUtils.N) {  \/\/ ll = f\n+                ll *= MathUtils.pow10(MathUtils.N - n);\n+                lh = ll;\n+            } else {  \/\/ ll is an N digits long prefix of f\n+                lh = ll + 1;\n@@ -1021,114 +868,114 @@\n-            FDBigInteger bigD0 = new FDBigInteger(lValue, digits, kDigits, nDigits);\n-            exp = decExponent - nDigits;\n-\n-            long ieeeBits = Double.doubleToRawLongBits(dValue); \/\/ IEEE-754 bits of double candidate\n-            final int B5 = Math.max(0, -exp); \/\/ powers of 5 in bigB, value is not modified inside correctionLoop\n-            final int D5 = Math.max(0, exp); \/\/ powers of 5 in bigD, value is not modified inside correctionLoop\n-            bigD0 = bigD0.multByPow52(D5, 0);\n-            bigD0.makeImmutable();   \/\/ prevent bigD0 modification inside correctionLoop\n-            FDBigInteger bigD = null;\n-            int prevD2 = 0;\n-\n-            correctionLoop:\n-            while (true) {\n-                \/\/ here ieeeBits can't be NaN, Infinity or zero\n-                int binexp = (int) (ieeeBits >>> EXP_SHIFT);\n-                long bigBbits = ieeeBits & DoubleConsts.SIGNIF_BIT_MASK;\n-                if (binexp > 0) {\n-                    bigBbits |= FRACT_HOB;\n-                } else { \/\/ Normalize denormalized numbers.\n-                    assert bigBbits != 0L : bigBbits; \/\/ doubleToBigInt(0.0)\n-                    int leadingZeros = Long.numberOfLeadingZeros(bigBbits);\n-                    int shift = leadingZeros - (63 - EXP_SHIFT);\n-                    bigBbits <<= shift;\n-                    binexp = 1 - shift;\n-                }\n-                binexp -= DoubleConsts.EXP_BIAS;\n-                int lowOrderZeros = Long.numberOfTrailingZeros(bigBbits);\n-                bigBbits >>>= lowOrderZeros;\n-                final int bigIntExp = binexp - EXP_SHIFT + lowOrderZeros;\n-                final int bigIntNBits = EXP_SHIFT + 1 - lowOrderZeros;\n-\n-                \/\/\n-                \/\/ Scale bigD, bigB appropriately for\n-                \/\/ big-integer operations.\n-                \/\/ Naively, we multiply by powers of ten\n-                \/\/ and powers of two. What we actually do\n-                \/\/ is keep track of the powers of 5 and\n-                \/\/ powers of 2 we would use, then factor out\n-                \/\/ common divisors before doing the work.\n-                \/\/\n-                int B2 = B5; \/\/ powers of 2 in bigB\n-                int D2 = D5; \/\/ powers of 2 in bigD\n-                int Ulp2;   \/\/ powers of 2 in halfUlp.\n-                if (bigIntExp >= 0) {\n-                    B2 += bigIntExp;\n-                } else {\n-                    D2 -= bigIntExp;\n-                }\n-                Ulp2 = B2;\n-                \/\/ shift bigB and bigD left by a number s. t.\n-                \/\/ halfUlp is still an integer.\n-                int hulpbias;\n-                if (binexp <= -DoubleConsts.EXP_BIAS) {\n-                    \/\/ This is going to be a denormalized number\n-                    \/\/ (if not actually zero).\n-                    \/\/ half an ULP is at 2^-(DoubleConsts.EXP_BIAS+EXP_SHIFT+1)\n-                    hulpbias = binexp + lowOrderZeros + DoubleConsts.EXP_BIAS;\n-                } else {\n-                    hulpbias = 1 + lowOrderZeros;\n-                }\n-                B2 += hulpbias;\n-                D2 += hulpbias;\n-                \/\/ if there are common factors of 2, we might just as well\n-                \/\/ factor them out, as they add nothing useful.\n-                int common2 = Math.min(B2, Math.min(D2, Ulp2));\n-                B2 -= common2;\n-                D2 -= common2;\n-                Ulp2 -= common2;\n-                \/\/ do multiplications by powers of 5 and 2\n-                FDBigInteger bigB = FDBigInteger.valueOfMulPow52(bigBbits, B5, B2);\n-                if (bigD == null || prevD2 != D2) {\n-                    bigD = bigD0.leftShift(D2);\n-                    prevD2 = D2;\n-                }\n-                \/\/\n-                \/\/ to recap:\n-                \/\/ bigB is the scaled-big-int version of our floating-point\n-                \/\/ candidate.\n-                \/\/ bigD is the scaled-big-int version of the exact value\n-                \/\/ as we understand it.\n-                \/\/ halfUlp is 1\/2 an ulp of bigB, except for special cases\n-                \/\/ of exact powers of 2\n-                \/\/\n-                \/\/ the plan is to compare bigB with bigD, and if the difference\n-                \/\/ is less than halfUlp, then we're satisfied. Otherwise,\n-                \/\/ use the ratio of difference to halfUlp to calculate a fudge\n-                \/\/ factor to add to the floating value, then go 'round again.\n-                \/\/\n-                FDBigInteger diff;\n-                int cmpResult;\n-                boolean overvalue;\n-                if ((cmpResult = bigB.cmp(bigD)) > 0) {\n-                    overvalue = true; \/\/ our candidate is too big.\n-                    diff = bigB.leftInplaceSub(bigD); \/\/ bigB is not user further - reuse\n-                    if ((bigIntNBits == 1) && (bigIntExp > -DoubleConsts.EXP_BIAS + 1)) {\n-                        \/\/ candidate is a normalized exact power of 2 and\n-                        \/\/ is too big (larger than Double.MIN_NORMAL). We will be subtracting.\n-                        \/\/ For our purposes, ulp is the ulp of the\n-                        \/\/ next smaller range.\n-                        Ulp2 -= 1;\n-                        if (Ulp2 < 0) {\n-                            \/\/ rats. Cannot de-scale ulp this far.\n-                            \/\/ must scale diff in other direction.\n-                            Ulp2 = 0;\n-                            diff = diff.leftShift(1);\n-                        }\n-                    }\n-                } else if (cmpResult < 0) {\n-                    overvalue = false; \/\/ our candidate is too small.\n-                    diff = bigD.rightInplaceSub(bigB); \/\/ bigB is not user further - reuse\n-                } else {\n-                    \/\/ the candidate is exactly right!\n-                    \/\/ this happens with surprising frequency\n-                    break correctionLoop;\n+            int el = e - MathUtils.N;\n+            \/*\n+             * We now have\n+             *      x = f 10^ep\n+             *      ll 10^el ≤ x ≤ lh 10^el\n+             *      2^59 < 10^(N-1) ≤ ll ≤ lh ≤ 10^N < 2^64\n+             *\n+             * Rather than rounding x directly, which requires full precision\n+             * arithmetic, approximate x as follows.\n+             * Let integers g and r such that (see comments in MathUtils)\n+             *      (g - 1) 2^r ≤ 10^el < g 2^r\n+             * and split g into the lower 63 bits g0 and the higher bits g1:\n+             *      g = g1 2^63 + g0\n+             * where\n+             *      2^62 < g1 + 1 < 2^63, 0 < g0 < 2^63\n+             * We have\n+             *      g - 1 = g1 2^63 + g0 - 1 ≥ g1 2^63\n+             *      g = g1 2^63 + g0 < g1 2^63 + 2^63 = (g1 + 1) 2^63\n+             * Let\n+             *      nl = ll g1          nh = lh (g1 + 1)\n+             * These lead to\n+             *      nl 2^(r+63) ≤ x < nh 2^(r+63)\n+             * Let\n+             *      v = r_e(nl 2^(r+63))        vh = r_e(nh 2^(r+63))\n+             * If v = vh then r_e(x) = v.\n+             *\n+             * We also have\n+             *      2^121 = 2^59 2^62 < nl < nh < 2^64 2^63 = 2^127\n+             * Therefore, each of nl and nh fits in two longs.\n+             * Split them into the lower 64 bits and the higher bits.\n+             *      nl = nl1 2^64 + nl0     2^57 ≤ nl1 < 2^63\n+             *      nh = nh1 2^64 + nh0     2^57 ≤ nh1 < 2^63\n+             * Let bl and bh be the bitlength of nl1 and nh1, resp.\n+             * Both bl and bh lie in the interval [58, 63], and all of nl1, nh1,\n+             * nl, and nh are in the normal range of double.\n+             * As nl ≤ nh ≤ nl + 2 ll, and as ll < 2^64, then either bh = bl,\n+             * or more rarely bh = bl + 1.\n+             *\n+             * As mentioned above, if v = vh then r_e(x) = v.\n+             * Rather than rounding nl 2^(r+63), nh 2^(r+63) boundaries directly,\n+             * first round nl and nh to obtain doubles wl and wh, resp.\n+             *      wl = r_e(nl)        wh = r_e(nh)\n+             * Note that both wl and wh are normal doubles.\n+             *\n+             * Assume wl = wh.\n+             * There's a good chance that v = scalb(wl, r + 63) holds.\n+             * In fact, if x ≥ MIN_NORMAL then it can be (tediously) shown that\n+             * v = scalb(wl, r + 63) holds, even when v overflows.\n+             * If x < MIN_NORMAL, and since wl is normal and v ≤ MIN_NORMAL,\n+             * the precision might be lowered, so scalb(wl, r + 63) might incur\n+             * two rounding errors and could slightly differ from v.\n+             *\n+             * It is costly to precisely determine whether x ≥ MIN_NORMAL.\n+             * However, bl + r > MIN_EXPONENT - 127 implies x ≥ MIN_NORMAL,\n+             * and bh + r ≤ MIN_EXPONENT - 127 entails x < MIN_NORMAL.\n+             * Finally, when bl + r ≤ MIN_EXPONENT - 127 < bh + r we see that\n+             * bl + r = MIN_EXPONENT - 127 and bh = bl + 1 must hold.\n+             *\n+             * As noted, nh ≤ nl + 2 ll.\n+             * This means\n+             *      nh1 ≤ nh 2^(-64) ≤ (nl + 2 ll) 2^(-64) < (nl1 + 1) + 2\n+             * and thus\n+             *      nh1 ≤ nl1 + 2\n+             *\/\n+            int rp = MathUtils.flog2pow10(el) + 2;  \/\/ r + 127\n+            long g1 = MathUtils.g1(el);\n+            long nl1 = Math.unsignedMultiplyHigh(ll, g1);\n+            long nl0 = ll * g1;\n+            long nh1 = Math.unsignedMultiplyHigh(lh, g1 + 1);\n+            long nh0 = lh * (g1 + 1);\n+            int bl = Long.SIZE - Long.numberOfLeadingZeros(nl1);\n+            if (bl + rp > Double.MIN_EXPONENT) {  \/\/ implies x is normal\n+                \/*\n+                 * To round nl we need its most significant P bits, the rounding\n+                 * bit immediately to the right, and an indication (sticky bit)\n+                 * of whether there are \"1\" bits following the rounding bit.\n+                 * The sticky bit can be placed anywhere after the rounding bit.\n+                 * Since bl ≥ 58, the P = 53 bits, the rounding bit, and space\n+                 * for the sticky bit are all located in nl1.\n+                 *\n+                 * When nl0 = 0, the indication of whether there are \"1\" bits\n+                 * to the right of the rounding bit is already contained in nl1.\n+                 * Rounding nl to wl is the same as rounding nl1 to ul and then\n+                 * multiplying this by 2^64.\n+                 * that is, given wl = r_e(nl), ul = r_e(nl1), we get\n+                 * wl = scalb(ul, 64).\n+                 * The same holds for nh, wh, nh1, and uh.\n+                 * So, if ul = uh then wl = wh, thus v = scalb(ul, r + 127).\n+                 *\n+                 * When nl1 ≠ 0, there are indeed \"1\" bits to the right of the\n+                 * rounding bit.\n+                 * We force the rightmost bit of nl1 to 1, obtaining nl1'.\n+                 * Then, again, rounding nl to wl is the same as rounding nl1'\n+                 * to ul and multiplying this by 2^64.\n+                 * Analogously for nh, wh, nh1, and uh.\n+                 * Again, if ul = uh then wl = wh, thus v = scalb(ul, r + 127).\n+                 *\n+                 * Since nh1 ≤ nl1 + 2, then either uh = ul or uh = nextUp(ul).\n+                 * This means that when ul ≠ uh then\n+                 *      v ≤ r_e(x) ≤ nextUp(v)\n+                 *\/\n+                double ul = nl1 | (nl0 != 0 ? 1 : 0);\n+                double uh = nh1 | (nh0 != 0 ? 1 : 0);\n+                v = Math.scalb(ul, rp);\n+                if (ul == uh || v == Double.POSITIVE_INFINITY) {\n+                    \/*\n+                     * Test cases:\n+                     *      for ll = lh ∧ ul = uh: \"1.2e-200\", \"2.3e100\";\n+                     *      for ll ≠ lh ∧ ul = uh: \"1.2000000000000000003e-200\",\n+                     *          \"2.3000000000000000004e100\";\n+                     *      for ll = lh ∧ v = ∞: \"5.249320425370670463e308\";\n+                     *      for ll ≠ lh ∧ v = ∞: \"5.2493204253706704633e308\";\n+                     *\/\n+                    return signed(v);\n@@ -1136,10 +983,32 @@\n-                cmpResult = diff.cmpPow52(B5, Ulp2);\n-                if ((cmpResult) < 0) {\n-                    \/\/ difference is small.\n-                    \/\/ this is close enough\n-                    break correctionLoop;\n-                } else if (cmpResult == 0) {\n-                    \/\/ difference is exactly half an ULP\n-                    \/\/ round to some other value maybe, then finish\n-                    if ((ieeeBits & 1) != 0) { \/\/ half ties to even\n-                        ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n+            } else {\n+                int bh = Long.SIZE - Long.numberOfLeadingZeros(nh1);\n+                if (bh + rp <= Double.MIN_EXPONENT) {  \/\/ implies x is subnormal\n+                    \/*\n+                     * We need to reduce the precision to avoid double rounding\n+                     * issues.\n+                     * Shifting to the right while keeping room for the rounding\n+                     * and the sticky bit is one way to go.\n+                     * Other than that, the reasoning is similar to the above case.\n+                     *\/\n+                    int sh = DoubleToDecimal.Q_MIN - rp;  \/\/ shift distance\n+                    long sbMask = -1L >>> 1 - sh;\n+\n+                    long nl1p = nl1 >>> sh;\n+                    long rb = nl1 >>> sh - 1;\n+                    long sb = (nl1 & sbMask | nl0) != 0 ? 1 : 0;\n+                    long corr = rb & (sb | nl1p) & 0b1;\n+                    double ul = nl1p + corr;\n+\n+                    long nh1p = nh1 >>> sh;\n+                    rb = nh1 >>> sh - 1;\n+                    sb = (nh1 & sbMask | nh0) != 0 ? 1 : 0;\n+                    corr = rb & (sb | nh1p) & 0b1;\n+                    double uh = nh1p + corr;\n+                    v = Math.scalb(ul, rp + sh);\n+                    if (ul == uh) {\n+                        \/*\n+                         * Test cases:\n+                         *      for ll = lh: \"1.2e-320\";\n+                         *      for ll ≠ lh: \"1.2000000000000000003e-320\";\n+                         *\/\n+                        return signed(v);\n@@ -1147,1 +1016,0 @@\n-                    break correctionLoop;\n@@ -1149,9 +1017,16 @@\n-                    \/\/ difference is non-trivial.\n-                    \/\/ could scale addend by ratio of difference to\n-                    \/\/ halfUlp here, if we bothered to compute that difference.\n-                    \/\/ Most of the time ( I hope ) it is about 1 anyway.\n-                    ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n-                    if (ieeeBits == 0 || ieeeBits == DoubleConsts.EXP_BIT_MASK) { \/\/ 0.0 or Double.POSITIVE_INFINITY\n-                        break correctionLoop; \/\/ oops. Fell off end of range.\n-                    }\n-                    continue; \/\/ try again.\n+                    \/*\n+                     * Here, bl + r ≤ MIN_EXPONENT - 127 < bh + r.\n+                     * As mentioned before, this means bh = bl + 1 and\n+                     * rp = MIN_EXPONENT - bl.\n+                     * As nh1 ≤ nl1 + 2, nl1 ≥ 2^57, bh = bl + 1 happens only if\n+                     * the most significant P + 2 bits in nl1 are all \"1\" bits,\n+                     * so wl = r_e(nl) = r_e(nh) = wh = 2^(bl+64), and\n+                     * thus v = vh = 2^(bl+127) = 2^MIN_EXPONENT = MIN_NORMAL.\n+                     *\/\n+\n+                    \/*\n+                     * Test cases:\n+                     *      for ll = lh: \"2.225073858507201383e-308\"\n+                     *      for ll ≠ lh: \"2.2250738585072013831e-308\"\n+                     *\/\n+                    return signed(Double.MIN_NORMAL);\n@@ -1159,4 +1034,0 @@\n-\n-            }\n-            if (isNegative) {\n-                ieeeBits |= DoubleConsts.SIGN_BIT_MASK;\n@@ -1164,2 +1035,0 @@\n-            return Double.longBitsToDouble(ieeeBits);\n-        }\n@@ -1167,26 +1036,17 @@\n-        \/**\n-         * Takes a FloatingDecimal, which we presumably just scanned in,\n-         * and finds out what its value is, as a float.\n-         * This is distinct from doubleValue() to avoid the extremely\n-         * unlikely case of a double rounding error, wherein the conversion\n-         * to double has one rounding error, and the conversion of that double\n-         * to a float has another rounding error, IN THE WRONG DIRECTION,\n-         * ( because of the preference to a zero low-order bit ).\n-         *\/\n-        @Override\n-        public float floatValue() {\n-            int kDigits = Math.min(nDigits, SINGLE_MAX_DECIMAL_DIGITS + 1);\n-            \/\/\n-            \/\/ convert the lead kDigits to an integer.\n-            \/\/\n-            int iValue = (int) digits[0] - (int) '0';\n-            for (int i = 1; i < kDigits; i++) {\n-                iValue = iValue * 10 + (int) digits[i] - (int) '0';\n-            }\n-            float fValue = (float) iValue;\n-            int exp = decExponent - kDigits;\n-            \/\/\n-            \/\/ iValue now contains an integer with the value of\n-            \/\/ the first kDigits digits of the number.\n-            \/\/ fValue contains the (float) of the same.\n-            \/\/\n+            \/*\n+             * Measurements show that the failure rate of the above fast paths\n+             * on the outcomes of Double.toString() on uniformly distributed\n+             * double bit patterns is around 0.04%.\n+             *\n+             * Here, v ≤ r_e(x) ≤ nextUp(v), with v = c 2^q (c, q are as in\n+             * IEEE-754 2019).\n+             *\n+             * Let vr = v + ulp(v)\/2 = (c + 1\/2) 2^q, the number halfway between\n+             * v and nextUp(v).\n+             * With cr = (2 c + 1), qr = q - 1 we get vr = cr 2^qr.\n+             *\/\n+            long bits = Double.doubleToRawLongBits(v);\n+            int be = (int) ((bits & DoubleConsts.EXP_BIT_MASK) >>> DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+            int qr = be - (DoubleConsts.EXP_BIAS + DoubleConsts.SIGNIFICAND_WIDTH - 1)\n+                    - (be != 0 ? 1 : 0);\n+            long cr = 2 * (bits & DoubleConsts.SIGNIF_BIT_MASK | (be != 0 ? DoubleToDecimal.C_MIN : 0)) + 1;\n@@ -1194,68 +1054,20 @@\n-            if (nDigits <= SINGLE_MAX_DECIMAL_DIGITS) {\n-                \/\/\n-                \/\/ possibly an easy case.\n-                \/\/ We know that the digits can be represented\n-                \/\/ exactly. And if the exponent isn't too outrageous,\n-                \/\/ the whole thing can be done with one operation,\n-                \/\/ thus one rounding error.\n-                \/\/ Note that all our constructors trim all leading and\n-                \/\/ trailing zeros, so simple values (including zero)\n-                \/\/ will always end up here.\n-                \/\/\n-                if (exp == 0 || fValue == 0.0f) {\n-                    return (isNegative) ? -fValue : fValue; \/\/ small floating integer\n-                } else if (exp >= 0) {\n-                    if (exp <= SINGLE_MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer with one operation,\n-                        \/\/ thus one roundoff.\n-                        \/\/\n-                        fValue *= SINGLE_SMALL_10_POW[exp];\n-                        return (isNegative) ? -fValue : fValue;\n-                    }\n-                    int slop = SINGLE_MAX_DECIMAL_DIGITS - kDigits;\n-                    if (exp <= SINGLE_MAX_SMALL_TEN + slop) {\n-                        \/\/\n-                        \/\/ We can multiply fValue by 10^(slop)\n-                        \/\/ and it is still \"small\" and exact.\n-                        \/\/ Then we can multiply by 10^(exp-slop)\n-                        \/\/ with one rounding.\n-                        \/\/\n-                        fValue *= SINGLE_SMALL_10_POW[slop];\n-                        fValue *= SINGLE_SMALL_10_POW[exp - slop];\n-                        return (isNegative) ? -fValue : fValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a positive exp.\n-                    \/\/\n-                } else {\n-                    if (exp >= -SINGLE_MAX_SMALL_TEN) {\n-                        \/\/\n-                        \/\/ Can get the answer in one division.\n-                        \/\/\n-                        fValue \/= SINGLE_SMALL_10_POW[-exp];\n-                        return (isNegative) ? -fValue : fValue;\n-                    }\n-                    \/\/\n-                    \/\/ Else we have a hard case with a negative exp.\n-                    \/\/\n-                }\n-            } else if ((decExponent >= nDigits) && (nDigits + decExponent <= MAX_DECIMAL_DIGITS)) {\n-                \/\/\n-                \/\/ In double-precision, this is an exact floating integer.\n-                \/\/ So we can compute to double, then shorten to float\n-                \/\/ with one round, and get the right answer.\n-                \/\/\n-                \/\/ First, finish accumulating digits.\n-                \/\/ Then convert that integer to a double, multiply\n-                \/\/ by the appropriate power of ten, and convert to float.\n-                \/\/\n-                long lValue = (long) iValue;\n-                for (int i = kDigits; i < nDigits; i++) {\n-                    lValue = lValue * 10L + (long) ((int) digits[i] - (int) '0');\n-                }\n-                double dValue = (double) lValue;\n-                exp = decExponent - nDigits;\n-                dValue *= SMALL_10_POW[exp];\n-                fValue = (float) dValue;\n-                return (isNegative) ? -fValue : fValue;\n+            \/*\n+             * The test vr ⋚ x is equivalent to cr 2^qr ⋚ f 10^ep.\n+             * This is in turn equivalent to one of 4 cases, where all exponents\n+             * are non-negative:\n+             *      ep ≥ 0 ∧ ep ≥ qr:                     cr ⋚ f 5^ep 2^(ep-qr)\n+             *      ep ≥ 0 ∧ ep < qr:           cr 2^(qr-ep) ⋚ f 5^ep\n+             *      ep < 0 ∧ ep ≥ qr:             cr 5^(-ep) ⋚ f 2^(ep-qr)\n+             *      ep < 0 ∧ ep < qr:   cr 5^(-ep) 2^(qr-ep) ⋚ f\n+             *\/\n+            FDBigInteger lhs = valueOfMulPow52(cr, Math.max(-ep, 0), Math.max(qr - ep, 0));\n+            FDBigInteger rhs = new FDBigInteger(fl, d, m, n)\n+                    .multByPow52(Math.max(ep, 0), Math.max(ep - qr, 0));\n+            int cmp = lhs.cmp(rhs);\n+            v = Double.longBitsToDouble(cmp < 0\n+                    ? bits + 1\n+                    : cmp > 0\n+                    ? bits\n+                    : bits + (bits & 0b1));\n+            return signed(v);\n+        }\n@@ -1263,0 +1075,8 @@\n+        private double signed(double v) {\n+            return isNegative ? -v : v;\n+        }\n+\n+        private float floatValue() {\n+            \/* For details not covered here, see comments in doubleValue(). *\/\n+            if (e <= E_THR_Z[BINARY_32_IX]) {\n+                return signed(0.0f);\n@@ -1264,49 +1084,2 @@\n-            \/\/\n-            \/\/ Harder cases:\n-            \/\/ The sum of digits plus exponent is greater than\n-            \/\/ what we think we can do with one error.\n-            \/\/\n-            \/\/ Start by approximating the right answer by,\n-            \/\/ naively, scaling by powers of 10.\n-            \/\/ Scaling uses doubles to avoid overflow\/underflow.\n-            \/\/\n-            double dValue = fValue;\n-            if (exp > 0) {\n-                if (decExponent > SINGLE_MAX_DECIMAL_EXPONENT + 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ Infinity. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue *= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 0; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= BIG_10_POW[j];\n-                        }\n-                    }\n-                }\n-            } else if (exp < 0) {\n-                exp = -exp;\n-                if (decExponent < SINGLE_MIN_DECIMAL_EXPONENT - 1) {\n-                    \/\/\n-                    \/\/ Lets face it. This is going to be\n-                    \/\/ zero. Cut to the chase.\n-                    \/\/\n-                    return (isNegative) ? -0.0f : 0.0f;\n-                }\n-                if ((exp & 15) != 0) {\n-                    dValue \/= SMALL_10_POW[exp & 15];\n-                }\n-                if ((exp >>= 4) != 0) {\n-                    int j;\n-                    for (j = 0; exp > 0; j++, exp >>= 1) {\n-                        if ((exp & 1) != 0) {\n-                            dValue *= TINY_10_POW[j];\n-                        }\n-                    }\n-                }\n+            if (e >= E_THR_I[BINARY_32_IX]) {\n+                return signed(Float.POSITIVE_INFINITY);\n@@ -1314,12 +1087,9 @@\n-            fValue = Math.clamp((float) dValue, Float.MIN_VALUE, Float.MAX_VALUE);\n-\n-            \/\/\n-            \/\/ fValue is now approximately the result.\n-            \/\/ The hard part is adjusting it, by comparison\n-            \/\/ with FDBigInteger arithmetic.\n-            \/\/ Formulate the EXACT big-number result as\n-            \/\/ bigD0 * 10^exp\n-            \/\/\n-            if (nDigits > SINGLE_MAX_NDIGITS) {\n-                nDigits = SINGLE_MAX_NDIGITS + 1;\n-                digits[SINGLE_MAX_NDIGITS] = '1';\n+            int n = this.n;\n+            int ep = e - n;\n+            float v;\n+            int m = Math.min(n, MathUtils.N);\n+            long fl = toLong(m);\n+            if (n <= MathUtils.N && 0 <= ep && e <= MathUtils.N) {\n+                fl *= MathUtils.pow10(ep);  \/\/ 0 ≤ ep < 19\n+                v = fl >= 0 ? fl : 2.0f * (fl >>> 1 | fl & 0b1);\n+                return signed(v);\n@@ -1327,24 +1097,6 @@\n-            FDBigInteger bigD0 = new FDBigInteger(iValue, digits, kDigits, nDigits);\n-            exp = decExponent - nDigits;\n-\n-            int ieeeBits = Float.floatToRawIntBits(fValue); \/\/ IEEE-754 bits of float candidate\n-            final int B5 = Math.max(0, -exp); \/\/ powers of 5 in bigB, value is not modified inside correctionLoop\n-            final int D5 = Math.max(0, exp); \/\/ powers of 5 in bigD, value is not modified inside correctionLoop\n-            bigD0 = bigD0.multByPow52(D5, 0);\n-            bigD0.makeImmutable();   \/\/ prevent bigD0 modification inside correctionLoop\n-            FDBigInteger bigD = null;\n-            int prevD2 = 0;\n-\n-            correctionLoop:\n-            while (true) {\n-                \/\/ here ieeeBits can't be NaN, Infinity or zero\n-                int binexp = ieeeBits >>> SINGLE_EXP_SHIFT;\n-                int bigBbits = ieeeBits & FloatConsts.SIGNIF_BIT_MASK;\n-                if (binexp > 0) {\n-                    bigBbits |= SINGLE_FRACT_HOB;\n-                } else { \/\/ Normalize denormalized numbers.\n-                    assert bigBbits != 0 : bigBbits; \/\/ floatToBigInt(0.0)\n-                    int leadingZeros = Integer.numberOfLeadingZeros(bigBbits);\n-                    int shift = leadingZeros - (31 - SINGLE_EXP_SHIFT);\n-                    bigBbits <<= shift;\n-                    binexp = 1 - shift;\n+            if (n <= FLOG_10_MAX_LONG && -SINGLE_MAX_SMALL_TEN <= ep) {\n+                v = fl;\n+                boolean isExact = (long) v == fl;\n+                if (isExact && ep <= SINGLE_MAX_SMALL_TEN) {\n+                    v = ep >= 0 ? v * SINGLE_SMALL_10_POW[ep] : v \/ SINGLE_SMALL_10_POW[-ep];\n+                    return signed(v);\n@@ -1352,89 +1104,28 @@\n-                binexp -= FloatConsts.EXP_BIAS;\n-                int lowOrderZeros = Integer.numberOfTrailingZeros(bigBbits);\n-                bigBbits >>>= lowOrderZeros;\n-                final int bigIntExp = binexp - SINGLE_EXP_SHIFT + lowOrderZeros;\n-                final int bigIntNBits = SINGLE_EXP_SHIFT + 1 - lowOrderZeros;\n-\n-                \/\/\n-                \/\/ Scale bigD, bigB appropriately for\n-                \/\/ big-integer operations.\n-                \/\/ Naively, we multiply by powers of ten\n-                \/\/ and powers of two. What we actually do\n-                \/\/ is keep track of the powers of 5 and\n-                \/\/ powers of 2 we would use, then factor out\n-                \/\/ common divisors before doing the work.\n-                \/\/\n-                int B2 = B5; \/\/ powers of 2 in bigB\n-                int D2 = D5; \/\/ powers of 2 in bigD\n-                int Ulp2;   \/\/ powers of 2 in halfUlp.\n-                if (bigIntExp >= 0) {\n-                    B2 += bigIntExp;\n-                } else {\n-                    D2 -= bigIntExp;\n-                }\n-                Ulp2 = B2;\n-                \/\/ shift bigB and bigD left by a number s. t.\n-                \/\/ halfUlp is still an integer.\n-                int hulpbias;\n-                if (binexp <= -FloatConsts.EXP_BIAS) {\n-                    \/\/ This is going to be a denormalized number\n-                    \/\/ (if not actually zero).\n-                    \/\/ half an ULP is at 2^-(FloatConsts.EXP_BIAS+SINGLE_EXP_SHIFT+1)\n-                    hulpbias = binexp + lowOrderZeros + FloatConsts.EXP_BIAS;\n-                } else {\n-                    hulpbias = 1 + lowOrderZeros;\n-                }\n-                B2 += hulpbias;\n-                D2 += hulpbias;\n-                \/\/ if there are common factors of 2, we might just as well\n-                \/\/ factor them out, as they add nothing useful.\n-                int common2 = Math.min(B2, Math.min(D2, Ulp2));\n-                B2 -= common2;\n-                D2 -= common2;\n-                Ulp2 -= common2;\n-                \/\/ do multiplications by powers of 5 and 2\n-                FDBigInteger bigB = FDBigInteger.valueOfMulPow52(bigBbits, B5, B2);\n-                if (bigD == null || prevD2 != D2) {\n-                    bigD = bigD0.leftShift(D2);\n-                    prevD2 = D2;\n-                }\n-                \/\/\n-                \/\/ to recap:\n-                \/\/ bigB is the scaled-big-int version of our floating-point\n-                \/\/ candidate.\n-                \/\/ bigD is the scaled-big-int version of the exact value\n-                \/\/ as we understand it.\n-                \/\/ halfUlp is 1\/2 an ulp of bigB, except for special cases\n-                \/\/ of exact powers of 2\n-                \/\/\n-                \/\/ the plan is to compare bigB with bigD, and if the difference\n-                \/\/ is less than halfUlp, then we're satisfied. Otherwise,\n-                \/\/ use the ratio of difference to halfUlp to calculate a fudge\n-                \/\/ factor to add to the floating value, then go 'round again.\n-                \/\/\n-                FDBigInteger diff;\n-                int cmpResult;\n-                boolean overvalue;\n-                if ((cmpResult = bigB.cmp(bigD)) > 0) {\n-                    overvalue = true; \/\/ our candidate is too big.\n-                    diff = bigB.leftInplaceSub(bigD); \/\/ bigB is not user further - reuse\n-                    if ((bigIntNBits == 1) && (bigIntExp > -FloatConsts.EXP_BIAS + 1)) {\n-                        \/\/ candidate is a normalized exact power of 2 and\n-                        \/\/ is too big (larger than Float.MIN_NORMAL). We will be subtracting.\n-                        \/\/ For our purposes, ulp is the ulp of the\n-                        \/\/ next smaller range.\n-                        Ulp2 -= 1;\n-                        if (Ulp2 < 0) {\n-                            \/\/ rats. Cannot de-scale ulp this far.\n-                            \/\/ must scale diff in other direction.\n-                            Ulp2 = 0;\n-                            diff = diff.leftShift(1);\n-                        }\n-                    }\n-                } else if (cmpResult < 0) {\n-                    overvalue = false; \/\/ our candidate is too small.\n-                    diff = bigD.rightInplaceSub(bigB); \/\/ bigB is not user further - reuse\n-                } else {\n-                    \/\/ the candidate is exactly right!\n-                    \/\/ this happens with surprising frequency\n-                    break correctionLoop;\n+                \/*\n+                 * The similar case in doubleValue() where fl is exact and\n+                 * ep is somewhat larger than MAX_SMALL_TEN is already covered\n+                 * above for float.\n+                 *\/\n+            }\n+            long ll = fl;\n+            long lh;\n+            if (n <= MathUtils.N) {\n+                ll *= MathUtils.pow10(MathUtils.N - n);\n+                lh = ll;\n+            } else {\n+                lh = ll + 1;\n+            }\n+            int el = e - MathUtils.N;\n+            int rp = MathUtils.flog2pow10(el) + 2;\n+            long g1 = MathUtils.g1(el);\n+            long nl1 = Math.unsignedMultiplyHigh(ll, g1);\n+            long nl0 = ll * g1;\n+            long nh1 = Math.unsignedMultiplyHigh(lh, g1 + 1);\n+            long nh0 = lh * (g1 + 1);\n+            int bl = Long.SIZE - Long.numberOfLeadingZeros(nl1);\n+            if (bl + rp > Float.MIN_EXPONENT) {\n+                float ul = nl1 | (nl0 != 0 ? 1 : 0);\n+                float uh = nh1 | (nh0 != 0 ? 1 : 0);\n+                v = Math.scalb(ul, rp);\n+                if (ul == uh || v == Float.POSITIVE_INFINITY) {\n+                    return signed(v);\n@@ -1442,10 +1133,20 @@\n-                cmpResult = diff.cmpPow52(B5, Ulp2);\n-                if ((cmpResult) < 0) {\n-                    \/\/ difference is small.\n-                    \/\/ this is close enough\n-                    break correctionLoop;\n-                } else if (cmpResult == 0) {\n-                    \/\/ difference is exactly half an ULP\n-                    \/\/ round to some other value maybe, then finish\n-                    if ((ieeeBits & 1) != 0) { \/\/ half ties to even\n-                        ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n+            } else {\n+                int bh = Long.SIZE - Long.numberOfLeadingZeros(nh1);\n+                if (bh + rp <= Float.MIN_EXPONENT) {\n+                    int sh = FloatToDecimal.Q_MIN - rp;\n+                    long sbMask = -1L >>> 1 - sh;\n+\n+                    long nl1p = nl1 >>> sh;\n+                    long rb = nl1 >>> sh - 1;\n+                    long sb = (nl1 & sbMask | nl0) != 0 ? 1 : 0;\n+                    long corr = rb & (sb | nl1p) & 0b1;\n+                    float ul = nl1p + corr;\n+\n+                    long nh1p = nh1 >>> sh;\n+                    rb = nh1 >>> sh - 1;\n+                    sb = (nh1 & sbMask | nh0) != 0 ? 1 : 0;\n+                    corr = rb & (sb | nh1p) & 0b1;\n+                    float uh = nh1p + corr;\n+                    v = Math.scalb(ul, rp + sh);\n+                    if (ul == uh) {\n+                        return signed(v);\n@@ -1453,1 +1154,0 @@\n-                    break correctionLoop;\n@@ -1455,9 +1155,1 @@\n-                    \/\/ difference is non-trivial.\n-                    \/\/ could scale addend by ratio of difference to\n-                    \/\/ halfUlp here, if we bothered to compute that difference.\n-                    \/\/ Most of the time ( I hope ) it is about 1 anyway.\n-                    ieeeBits += overvalue ? -1 : 1; \/\/ nextDown or nextUp\n-                    if (ieeeBits == 0 || ieeeBits == FloatConsts.EXP_BIT_MASK) { \/\/ 0.0 or Float.POSITIVE_INFINITY\n-                        break correctionLoop; \/\/ oops. Fell off end of range.\n-                    }\n-                    continue; \/\/ try again.\n+                    return signed(Float.MIN_NORMAL);\n@@ -1465,1 +1157,0 @@\n-\n@@ -1467,4 +1158,15 @@\n-            if (isNegative) {\n-                ieeeBits |= FloatConsts.SIGN_BIT_MASK;\n-            }\n-            return Float.intBitsToFloat(ieeeBits);\n+            int bits = Float.floatToRawIntBits(v);\n+            int be = (bits & FloatConsts.EXP_BIT_MASK) >>> FloatConsts.SIGNIFICAND_WIDTH - 1;\n+            int qr = be - (FloatConsts.EXP_BIAS + FloatConsts.SIGNIFICAND_WIDTH - 1)\n+                    - (be != 0 ? 1 : 0);\n+            int cr = 2 * (bits & FloatConsts.SIGNIF_BIT_MASK | (be != 0 ? FloatToDecimal.C_MIN : 0)) + 1;\n+            FDBigInteger lhs = valueOfMulPow52(cr, Math.max(-ep, 0), Math.max(qr - ep, 0));\n+            FDBigInteger rhs = new FDBigInteger(fl, d, m, n)\n+                    .multByPow52(Math.max(ep, 0), Math.max(ep - qr, 0));\n+            int cmp = lhs.cmp(rhs);\n+            v = Float.intBitsToFloat(cmp < 0\n+                    ? bits + 1\n+                    : cmp > 0\n+                    ? bits\n+                    : bits + (bits & 0b1));\n+            return signed(v);\n@@ -1473,0 +1175,3 @@\n+        private float signed(float v) {\n+            return isNegative ? -v : v;\n+        }\n@@ -1474,4 +1179,2 @@\n-        \/**\n-         * All the positive powers of 10 that can be\n-         * represented exactly in double\/float.\n-         *\/\n+        \/* All the powers of 10 that can be represented exactly in double. *\/\n+        @Stable\n@@ -1479,6 +1182,3 @@\n-            1.0e0,\n-            1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5,\n-            1.0e6, 1.0e7, 1.0e8, 1.0e9, 1.0e10,\n-            1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15,\n-            1.0e16, 1.0e17, 1.0e18, 1.0e19, 1.0e20,\n-            1.0e21, 1.0e22\n+                1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,\n+                1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n+                1e20, 1e21, 1e22,\n@@ -1487,0 +1187,2 @@\n+        \/* All the powers of 10 that can be represented exactly in float. *\/\n+        @Stable\n@@ -1488,3 +1190,2 @@\n-            1.0e0f,\n-            1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,\n-            1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f\n+                1e0f, 1e1f, 1e2f, 1e3f, 1e4f, 1e5f, 1e6f, 1e7f, 1e8f, 1e9f,\n+                1e10f,\n@@ -1493,7 +1194,2 @@\n-        private static final double[] BIG_10_POW = {\n-            1e16, 1e32, 1e64, 1e128, 1e256 };\n-        private static final double[] TINY_10_POW = {\n-            1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };\n-\n-        private static final int MAX_SMALL_TEN = SMALL_10_POW.length-1;\n-        private static final int SINGLE_MAX_SMALL_TEN = SINGLE_SMALL_10_POW.length-1;\n+        private static final int MAX_SMALL_TEN = SMALL_10_POW.length - 1;\n+        private static final int SINGLE_MAX_SMALL_TEN = SINGLE_SMALL_10_POW.length - 1;\n@@ -1511,1 +1207,1 @@\n-    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean compat) {\n+    public static BinaryToASCIIBuffer getBinaryToASCIIConverter(double d, boolean compat) {\n@@ -1513,1 +1209,1 @@\n-                ? getCompatBinaryToASCIIConverter(d, true)\n+                ? getCompatBinaryToASCIIConverter(d)\n@@ -1517,1 +1213,1 @@\n-    private static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n+    private static BinaryToASCIIBuffer getBinaryToASCIIConverter(double d) {\n@@ -1544,1 +1240,1 @@\n-    private static BinaryToASCIIConverter getCompatBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n+    private static BinaryToASCIIBuffer getCompatBinaryToASCIIConverter(double d) {\n@@ -1578,1 +1274,0 @@\n-        buf.setSign(isNegative);\n@@ -1580,1 +1275,1 @@\n-        buf.dtoa(binExp, fractBits, nSignificantBits, isCompatibleFormat);\n+        buf.dtoa(binExp, fractBits, nSignificantBits);\n@@ -1584,10 +1279,0 @@\n-    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n-\n-        \/\/ Prevent an extreme negative exponent from causing overflow issues in doubleValue().\n-        \/\/ Large positive values are handled within doubleValue();\n-        if (decExp < MIN_DECIMAL_EXPONENT) {\n-            return A2BC_POSITIVE_ZERO;\n-        }\n-        return new ASCIIToBinaryBuffer(false, decExp, digits, length);\n-    }\n-\n@@ -1600,1 +1285,1 @@\n-     *          is one of 16, 32, 64\n+     *           is one of 16, 32, 64\n@@ -1602,1 +1287,1 @@\n-     * @throws NullPointerException if the input is null\n+     * @throws NullPointerException  if the input is null\n@@ -1605,1 +1290,1 @@\n-    static ASCIIToBinaryConverter readJavaFormatString(String in, int ix) {\n+    private static double readJavaFormatString(String in, int ix) {\n@@ -1627,0 +1312,1 @@\n+         * but is much shorter in common cases.\n@@ -1650,1 +1336,1 @@\n-                return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n+                return ssign != '-' ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n@@ -1654,1 +1340,1 @@\n-                return A2BC_NOT_A_NUMBER;  \/\/ ignore sign\n+                return Double.NaN;  \/\/ ignore sign\n@@ -1733,1 +1419,1 @@\n-            return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+            return ssign != '-' ? 0.0 : -0.0;\n@@ -1788,1 +1474,1 @@\n-            } else if (lz < pt) {  \/\/ lz < pt <= tnz\n+            } else if (lz < pt) {  \/\/ lz < pt ≤ tnz\n@@ -1800,2 +1486,2 @@\n-         * Integer f = <f_1 ... f_n> consists of the n decimal or hexadecimal\n-         * digits found in part [lz, tnz) of the input, and f_1 != 0, f_n != 0.\n+         * Integer f = <d_1 ... d_n> consists of the n decimal or hexadecimal\n+         * digits found in part [lz, tnz) of the input, and d_1 > 0, d_n > 0.\n@@ -1827,1 +1513,1 @@\n-             * Let x = c 2^ep, so 2^(ep+bl-1) <= x < 2^(ep+bl)\n+             * Let x = c 2^ep, so 2^(ep+bl-1) ≤ x < 2^(ep+bl)\n@@ -1832,1 +1518,1 @@\n-                return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+                return ssign != '-' ? 0.0 : -0.0;\n@@ -1834,2 +1520,2 @@\n-            if (ep > QE_MAX[ix] - bl) {\n-                return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n+            if (ep > QP_MAX[ix] - bl) {\n+                return ssign != '-' ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n@@ -1839,1 +1525,1 @@\n-            if (q >= QE_MIN[ix] - bl) {\n+            if (q >= QP_MIN[ix] - bl) {\n@@ -1863,4 +1549,2 @@\n-                case BINARY_32_IX ->\n-                    new PreparedASCIIToBinaryBuffer(Double.NaN, buildFloat(ssign, q, c));\n-                case BINARY_64_IX ->\n-                    new PreparedASCIIToBinaryBuffer(buildDouble(ssign, q, c), Float.NaN);\n+                case BINARY_32_IX -> buildFloat(ssign, q, c);\n+                case BINARY_64_IX -> buildDouble(ssign, q, c);\n@@ -1876,3 +1560,3 @@\n-         *      x = 0.d_1 ... d_n 10^e, 10^(e-1) <= x < 10^e\n-         * If e <= E_THR_Z then x rounds to zero.\n-         * Similarly, if e >= E_THR_I then x rounds to infinity.\n+         *      x = 0.d_1 ... d_n 10^e, 10^(e-1) ≤ x < 10^e\n+         * If e ≤ E_THR_Z then x rounds to zero.\n+         * Similarly, if e ≥ E_THR_I then x rounds to infinity.\n@@ -1883,2 +1567,2 @@\n-        if (e == E_THR_Z[ix]) {  \/\/ true e <= E_THR_Z\n-            return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+        if (e == E_THR_Z[ix]) {  \/\/ the true mathematical e ≤ E_THR_Z\n+            return ssign != '-' ? 0.0 : -0.0;\n@@ -1886,2 +1570,2 @@\n-        if (e == E_THR_I[ix]) {  \/\/ true e >= E_THR_I\n-            return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n+        if (e == E_THR_I[ix]) {  \/\/ the true mathematical e ≥ E_THR_I\n+            return ssign != '-' ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n@@ -1894,1 +1578,1 @@\n-         *      q >= Q_MIN\n+         *      q ≥ Q_MIN\n@@ -1896,1 +1580,1 @@\n-         *      either  2^(P-1) <= beta < 2^P\n+         *      either  2^(P-1) ≤ beta < 2^P\n@@ -1907,1 +1591,1 @@\n-         *      ql <= q <= qh, and qh - ql <= 4\n+         *      ql ≤ q ≤ qh, and qh - ql ≤ 4\n@@ -1912,1 +1596,1 @@\n-         *      c 2^q, c integer, 2^(P-1) <= c < 2^P (normal values)\n+         *      c 2^q, c integer, 2^(P-1) ≤ c < 2^P (normal values)\n@@ -1915,1 +1599,1 @@\n-         *      c 2^q, c integer, 0 <= c < 2^(P-1) (subnormal values and zero)\n+         *      c 2^q, c integer, 0 ≤ c < 2^(P-1) (subnormal values and zero)\n@@ -1930,1 +1614,1 @@\n-         * If n > e we pass the digits d_1...d_e 3 (3 is as good as any other\n+         * If n > e we pass the digits <d_1...d_e 8> (8 is as good as any other\n@@ -1932,1 +1616,1 @@\n-         * If n <= e we pass all the digits d_1...d_n (no sticky digit,\n+         * If n ≤ e we pass all the digits <d_1...d_n> (no sticky digit,\n@@ -1935,1 +1619,1 @@\n-         * Now assume qh <= 0, so q <= 0.\n+         * Now assume qh ≤ 0, so q ≤ 0.\n@@ -1946,2 +1630,2 @@\n-         * digits of f, sticky 3, and e.\n-         * Otherwise, n <= e + 1 - ql.\n+         * digits of f, sticky 8 (the \"most even\" digit), and e.\n+         * Otherwise, n ≤ e + 1 - ql.\n@@ -1950,1 +1634,1 @@\n-         * Otherwise, ql <= 0 < qh, so -4 < q <= 4.\n+         * Otherwise, ql ≤ 0 < qh, so -4 < q ≤ 4.\n@@ -1954,1 +1638,0 @@\n-        \/\/ TODO insert logic for small n: 9 for float, 18 for double\n@@ -1957,1 +1640,1 @@\n-        byte[] digits = new byte[Math.min(n, np)];\n+        byte[] d = new byte[Math.min(n, np)];\n@@ -1959,2 +1642,2 @@\n-            copyDigits(in, digits, np - 1, lz);\n-            digits[np - 1] = '3';  \/\/ append any non-zero sticky digit\n+            copyDigits(in, d, np - 1, lz);\n+            d[np - 1] = '8';  \/\/ append the \"most even\" non-zero sticky digit\n@@ -1962,1 +1645,1 @@\n-            copyDigits(in, digits, n, lz);\n+            copyDigits(in, d, n, lz);\n@@ -1964,1 +1647,8 @@\n-        return new ASCIIToBinaryBuffer(ssign == '-', e, digits, digits.length);\n+        \/* For now throw on BINARY_16_IX, until Float16 is integrated in java.base. *\/\n+        return switch (ix) {\n+            case BINARY_32_IX ->\n+                    new ASCIIToBinaryBuffer(ssign == '-', e, d, d.length).floatValue();\n+            case BINARY_64_IX ->\n+                    new ASCIIToBinaryBuffer(ssign == '-', e, d, d.length).doubleValue();\n+            default -> throw new AssertionError(\"unexpected\");\n+        };\n@@ -1991,1 +1681,1 @@\n-    private static void copyDigits(String in, byte[] digits, int len, int i) {\n+    private static void copyDigits(String in, byte[] d, int len, int i) {\n@@ -1996,1 +1686,1 @@\n-                digits[j++] = (byte) ch;\n+                d[j++] = (byte) ch;\n@@ -2001,1 +1691,1 @@\n-    \/* Arithmetically \"appends the dec digit\" ch to v >= 0, clamping at 10^10. *\/\n+    \/* Arithmetically \"appends the dec digit\" ch to v ≥ 0, clamping at 10^10. *\/\n@@ -2070,2 +1760,2 @@\n-     *      Q_MIN <= q <= Q_MAX\n-     *      either      2^(P-1) <= c < 2^P                  (normal)\n+     *      Q_MIN ≤ q ≤ Q_MAX\n+     *      either      2^(P-1) ≤ c < 2^P                   (normal)\n@@ -2073,1 +1763,1 @@\n-     *      c = b_1...b_P  (b_i in [0, 2))\n+     *      c = <b_1...b_P>  (b_i in [0, 2)),   b_1 > 0 iff normal\n@@ -2076,3 +1766,3 @@\n-     *      m 2^ep\n-     * where integer qe and real f meet\n-     *      qe = q + P\n+     *      m 2^qp\n+     * where integer qp and real m meet\n+     *      qp = q + P\n@@ -2081,2 +1771,2 @@\n-     *      QE_MIN = Q_MIN + P, QE_MAX = Q_MAX + P,\n-     *      2^(-1) <= m < 1     (normal)\n+     *      QP_MIN = Q_MIN + P, QP_MAX = Q_MAX + P,\n+     *      2^(-1) ≤ m < 1      (normal)\n@@ -2084,1 +1774,1 @@\n-     *      m = 0.b_1...b_P\n+     *      m = <0.b_1...b_P>\n@@ -2094,2 +1784,2 @@\n-\/\/    private static final int BINARY_128_IX = 3;\n-\/\/    private static final int BINARY_256_IX = 4;\n+    \/\/ private static final int BINARY_128_IX = 3;\n+    \/\/ private static final int BINARY_256_IX = 4;\n@@ -2099,3 +1789,3 @@\n-            11,\n-            FloatToDecimal.P,\n-            DoubleToDecimal.P,\n+            11,  \/\/ 11\n+            FloatToDecimal.P,  \/\/ 24\n+            DoubleToDecimal.P,  \/\/ 53\n@@ -2106,10 +1796,0 @@\n-    @Stable\n-    private static final int[] W = {\n-            5,\n-            FloatToDecimal.W,\n-            DoubleToDecimal.W,\n-\/\/            (1 << 4 + BINARY_128_IX) - P[BINARY_128_IX],\n-\/\/            (1 << 4 + BINARY_256_IX) - P[BINARY_256_IX],\n-    };\n-\n-    \/* Minimum exponent in the m 2^e representation. *\/\n@@ -2119,5 +1799,5 @@\n-            -24,  \/\/ Float16ToDecimal.Q_MIN,\n-            FloatToDecimal.Q_MIN,\n-            DoubleToDecimal.Q_MIN,\n-\/\/            QE_MIN[BINARY_128_IX] - (P[BINARY_128_IX] - 1),\n-\/\/            QE_MIN[BINARY_256_IX] - (P[BINARY_256_IX] - 1),\n+            -24,  \/\/ Float16ToDecimal.Q_MIN,  \/\/ -24\n+            FloatToDecimal.Q_MIN,  \/\/ -149\n+            DoubleToDecimal.Q_MIN,  \/\/ -1_074\n+            \/\/ -16_494,\n+            \/\/ -262_378,\n@@ -2126,0 +1806,1 @@\n+    \/* Minimum exponent in the m 2^qp representation. *\/\n@@ -2127,6 +1808,6 @@\n-    private static final int[] QE_MIN = {\n-            Q_MIN[BINARY_16_IX] + P[BINARY_16_IX],\n-            FloatToDecimal.Q_MIN + FloatToDecimal.P,\n-            DoubleToDecimal.Q_MIN + DoubleToDecimal.P,\n-\/\/            Q_MIN[BINARY_128_IX] + P[BINARY_128_IX],\n-\/\/            Q_MIN[BINARY_256_IX] + P[BINARY_256_IX],\n+    private static final int[] QP_MIN = {\n+            Q_MIN[BINARY_16_IX] + P[BINARY_16_IX],  \/\/ -13\n+            Q_MIN[BINARY_32_IX] + P[BINARY_32_IX],  \/\/ -125\n+            Q_MIN[BINARY_64_IX] + P[BINARY_64_IX],  \/\/ -1_021\n+            \/\/ Q_MIN[BINARY_128_IX] + P[BINARY_128_IX],  \/\/ -16_381\n+            \/\/ Q_MIN[BINARY_256_IX] + P[BINARY_256_IX],  \/\/ -262_141\n@@ -2135,1 +1816,1 @@\n-    \/* Maximum exponent in the m 2^e representation. *\/\n+    \/* Maximum exponent in the m 2^qp representation. *\/\n@@ -2137,6 +1818,6 @@\n-    private static final int[] QE_MAX = {\n-            3 - QE_MIN[BINARY_16_IX],\n-            FloatToDecimal.Q_MAX + FloatToDecimal.P,\n-            DoubleToDecimal.Q_MAX + DoubleToDecimal.P,\n-\/\/            3 - QE_MIN[BINARY_128_IX],\n-\/\/            3 - QE_MIN[BINARY_256_IX],\n+    private static final int[] QP_MAX = {\n+            3 - QP_MIN[BINARY_16_IX],  \/\/ 16\n+            3 - QP_MIN[BINARY_32_IX],  \/\/ 128\n+            3 - QP_MIN[BINARY_64_IX],  \/\/ 1_024\n+            \/\/ 3 - QP_MIN[BINARY_128_IX],  \/\/ 16_384\n+            \/\/ 3 - QP_MIN[BINARY_256_IX],  \/\/ 262_144\n@@ -2145,0 +1826,8 @@\n+    \/*\n+     * For each binary floating-point format, let\n+     *      THR_Z = ulp(0.0) \/ 2 = MIN_VALUE \/ 2\n+     * THR_Z is the zero threshold.\n+     * Real x rounds to 0 by roundTiesToEven iff |x| ≤ THR_Z.\n+     *\n+     * E_THR_Z = max{e : 10^e ≤ THR_Z}.\n+     *\/\n@@ -2147,3 +1836,3 @@\n-            -8,\n-            FloatToDecimal.E_THR_Z,\n-            DoubleToDecimal.E_THR_Z,\n+            -8,  \/\/ -8\n+            FloatToDecimal.E_THR_Z,  \/\/ -46\n+            DoubleToDecimal.E_THR_Z,  \/\/ -324\n@@ -2154,0 +1843,8 @@\n+    \/*\n+     * For each binary floating-point format, let\n+     *      THR_I = MAX_VALUE + ulp(MAX_VALUE) \/ 2\n+     * THR_I is the infinity threshold.\n+     * Real x rounds to infinity by roundTiesToEven iff |x| ≥ THR_I.\n+     *\n+     * E_THR_I = min{e : THR_I ≤ 10^(e-1)}.\n+     *\/\n@@ -2156,3 +1853,3 @@\n-            6,\n-            FloatToDecimal.E_THR_I,\n-            DoubleToDecimal.E_THR_I,\n+            6,  \/\/ 6\n+            FloatToDecimal.E_THR_I,  \/\/ 40\n+            DoubleToDecimal.E_THR_I,  \/\/ 310\n@@ -2169,5 +1866,5 @@\n-            P[BINARY_16_IX] \/ 4 + 2,\n-            P[BINARY_32_IX] \/ 4 + 2,\n-            P[BINARY_64_IX] \/ 4 + 2,\n-\/\/            P[BINARY_128_IX] \/ 4 + 2,\n-\/\/            P[BINARY_256_IX] \/ 4 + 2,\n+            P[BINARY_16_IX] \/ 4 + 2,  \/\/ 4\n+            P[BINARY_32_IX] \/ 4 + 2,  \/\/ 8\n+            P[BINARY_64_IX] \/ 4 + 2,  \/\/ 15\n+            \/\/ P[BINARY_128_IX] \/ 4 + 2,  \/\/ 30\n+            \/\/ P[BINARY_256_IX] \/ 4 + 2,  \/\/ 61\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":613,"deletions":916,"binary":false,"changes":1529,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-     * N = max{n : 10^n - 1 <= 2^Long.SIZE - 1}\n+     * N = max{n : 10^n - 1 ≤ 2^Long.SIZE - 1}\n@@ -55,1 +55,1 @@\n-     *      2^125 <= beta < 2^126.\n+     *      2^125 ≤ beta < 2^126.\n@@ -60,1 +60,1 @@\n-     *      (g - 1) 2^r <= 10^e < g 2^r\n+     *      (g - 1) 2^r ≤ 10^e < g 2^r\n@@ -64,1 +64,1 @@\n-     * For e with GE_MIN <= e <= GE_MAX, the values g1 and g0 are available\n+     * For e with GE_MIN ≤ e ≤ GE_MAX, the values g1 and g0 are available\n@@ -76,1 +76,1 @@\n-     * Let x = f 10^ep, where integers f and ep meet 10^(n-1) <= f < 10^n\n+     * Let x = f 10^ep, where integers f and ep meet 10^(n-1) ≤ f < 10^n\n@@ -80,2 +80,2 @@\n-     * The decimal->double fast paths assume n <= N.\n-     * Thus, E_THR_Z - (N - 1) <= ep <= E_THR_I - 2, which means that\n+     * The decimal->double fast paths assume n ≤ N.\n+     * Thus, E_THR_Z - (N - 1) ≤ ep ≤ E_THR_I - 2, which means that\n@@ -87,0 +87,10 @@\n+     *\n+     * For the record, while the definition of g allows the case g = 2^126,\n+     * the maximal g1 in the lookup table is 0x7FDD_E7F4_CA72_E30FL (e = -146),\n+     * the minimal g1 is 0x4000_0000_0000_0000L (for e = 0),\n+     * and the minimal g0 is 1.\n+     * Hence, as easily verified, we always have\n+     *      2^62 < g1 + 1 < 2^31 (2^32 - 1) < 2^63\n+     *      2^125 < g = g1 2^63 + g0 < (g1 + 1) 2^63 < 2^94 (2^32 - 1) < 2^126\n+     * We will assume these bounds observed by glancing at the lookup table,\n+     * and use them liberally when so needed.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/MathUtils.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm;\n+\n+\/**\n+ * Internal exception used only by the VM.\n+ *\/\n+public class PreemptedException extends RuntimeException {\n+    @java.io.Serial\n+    private static final long serialVersionUID = 6700691236100628123L;\n+\n+    \/**\n+     * Constructs an {@code PreemptedException} with no detail  message.\n+     *\/\n+    public PreemptedException() {\n+        super();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/PreemptedException.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -149,0 +149,10 @@\n+\n+            ostream.println(\"\\n\" + TWOINDENT + \"Enabled Signature Schemes:\");\n+            String[] schemes = ssls.getSSLParameters().getSignatureSchemes();\n+            if (schemes == null) {\n+                ostream.println(THREEINDENT + \"<none>\");\n+            } else {\n+                for (String s : schemes) {\n+                    ostream.println(THREEINDENT + s);\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/SecuritySettings.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.sdp;\n-\n-import java.io.IOException;\n-import java.io.FileDescriptor;\n-\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-import jdk.internal.util.OperatingSystem;\n-\n-\n-\/**\n- * This class defines methods for creating SDP sockets or \"converting\" existing\n- * file descriptors, referencing (unbound) TCP sockets, to SDP.\n- *\/\n-\n-public final class SdpSupport {\n-    private static final boolean isSupported = OperatingSystem.isLinux();\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-        SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    private SdpSupport() { }\n-\n-    \/**\n-     * Creates a SDP socket, returning file descriptor referencing the socket.\n-     *\/\n-    public static FileDescriptor createSocket() throws IOException {\n-        if (!isSupported)\n-            throw new UnsupportedOperationException(\"SDP not supported on this platform\");\n-        int fdVal = create0();\n-        FileDescriptor fd = new FileDescriptor();\n-        fdAccess.set(fd, fdVal);\n-        return fd;\n-    }\n-\n-    \/**\n-     * Converts an existing file descriptor, that references an unbound TCP socket,\n-     * to SDP.\n-     *\/\n-    public static void convertSocket(FileDescriptor fd) throws IOException {\n-        if (!isSupported)\n-            throw new UnsupportedOperationException(\"SDP not supported on this platform\");\n-        int fdVal = fdAccess.get(fd);\n-        convert0(fdVal);\n-    }\n-\n-    private static native int create0() throws IOException;\n-\n-    private static native void convert0(int fd) throws IOException;\n-\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/sdp\/SdpSupport.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -41,1 +41,0 @@\n-import sun.net.NetHooks;\n@@ -159,1 +158,0 @@\n-                NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import sun.net.NetHooks;\n@@ -450,1 +449,0 @@\n-                NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import sun.net.NetHooks;\n@@ -504,5 +503,0 @@\n-            \/\/ invoke beforeTcpConnect hook if not already bound\n-            if (localport == 0) {\n-                NetHooks.beforeTcpConnect(fd, address, port);\n-            }\n-\n@@ -640,1 +634,0 @@\n-            NetHooks.beforeTcpBind(fd, host, port);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import sun.net.NetHooks;\n@@ -334,1 +333,0 @@\n-        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import sun.net.NetHooks;\n@@ -831,1 +830,0 @@\n-        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n@@ -874,1 +872,0 @@\n-                NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.io.*;\n+import java.io.IOException;\n@@ -30,0 +30,7 @@\n+import java.security.spec.InvalidKeySpecException;\n+import static java.util.Locale.ENGLISH;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n@@ -31,4 +38,0 @@\n-import sun.security.util.DerInputStream;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.x509.AlgorithmId;\n@@ -36,0 +39,2 @@\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n@@ -39,1 +44,20 @@\n- * A MacData type, as defined in PKCS#12.\n+ * The MacData type, as defined in PKCS#12.\n+ *\n+ * The ASN.1 definition is as follows:\n+ *\n+ * <pre>\n+ *\n+ * MacData ::= SEQUENCE {\n+ *     mac        DigestInfo,\n+ *     macSalt    OCTET STRING,\n+ *     iterations INTEGER DEFAULT 1\n+ *      -- Note: The default is for historical reasons and its use is\n+ *      -- deprecated.\n+ * }\n+ *\n+ * DigestInfo ::= SEQUENCE {\n+ *     digestAlgorithm DigestAlgorithmIdentifier,\n+ *     digest OCTET STRING\n+ * }\n+ *\n+ * <\/pre>\n@@ -46,2 +70,2 @@\n-    private final String digestAlgorithmName;\n-    private AlgorithmParameters digestAlgorithmParams;\n+    private static final Debug debug = Debug.getInstance(\"pkcs12\");\n+    private final String macAlgorithm;\n@@ -52,2 +76,4 @@\n-    \/\/ the ASN.1 encoded contents of this class\n-    private byte[] encoded = null;\n+    \/\/ The following three fields are for PBMAC1.\n+    private final int keyLength;\n+    private final String kdfHmac;\n+    private final String hmac;\n@@ -73,2 +99,2 @@\n-        this.digestAlgorithmName = digestAlgorithmId.getName();\n-        this.digestAlgorithmParams = digestAlgorithmId.getParameters();\n+        String digestAlgorithmName = digestAlgorithmId.getName();\n+\n@@ -78,2 +104,10 @@\n-        \/\/ Get the salt.\n-        this.macSalt = macData[1].getOctetString();\n+        if (digestAlgorithmName.equals(\"PBMAC1\")) {\n+            PBMAC1Parameters algParams;\n+\n+            algParams = new PBMAC1Parameters(digestAlgorithmId\n+                    .getEncodedParams());\n+\n+            this.iterations = algParams.getKdfParams().getIterationCount();\n+            this.macSalt = algParams.getKdfParams().getSalt();\n+            this.kdfHmac = algParams.getKdfParams().getPrfAlgo();\n+            this.keyLength = algParams.getKdfParams().getKeyLength();\n@@ -81,3 +115,6 @@\n-        \/\/ Iterations is optional. The default value is 1.\n-        if (macData.length > 2) {\n-            this.iterations = macData[2].getInteger();\n+            \/\/ Implementations MUST NOT accept params that omit keyLength.\n+            if (this.keyLength == -1) {\n+                throw new IOException(\"error: missing keyLength field\");\n+            }\n+            this.hmac = algParams.getHmac();\n+            this.macAlgorithm = \"pbewith\" + this.kdfHmac + \"and\" + this.hmac;\n@@ -85,1 +122,12 @@\n-            this.iterations = 1;\n+            this.kdfHmac = null;\n+            this.hmac = null;\n+            this.keyLength = -1;\n+            this.macSalt = macData[1].getOctetString();\n+            if (macData.length > 2) {\n+                this.iterations = macData[2].getInteger();\n+            } else {\n+                this.iterations = 1;\n+            }\n+            \/\/ Remove \"-\" from digest algorithm names\n+            this.macAlgorithm = \"hmacpbe\"\n+                    + digestAlgorithmName.replace(\"-\", \"\");\n@@ -89,17 +137,48 @@\n-    MacData(String algName, byte[] digest, byte[] salt, int iterations)\n-        throws NoSuchAlgorithmException\n-    {\n-        if (algName == null)\n-           throw new NullPointerException(\"the algName parameter \" +\n-                                               \"must be non-null\");\n-\n-        AlgorithmId algid = AlgorithmId.get(algName);\n-        this.digestAlgorithmName = algid.getName();\n-        this.digestAlgorithmParams = algid.getParameters();\n-\n-        if (digest == null) {\n-            throw new NullPointerException(\"the digest \" +\n-                                           \"parameter must be non-null\");\n-        } else if (digest.length == 0) {\n-            throw new IllegalArgumentException(\"the digest \" +\n-                                                \"parameter must not be empty\");\n+    \/**\n+     * Computes a MAC on the data.\n+     *\n+     * This is a two-step process: first generate a key and then use the\n+     * key to generate the MAC. PBMAC1 and non-PBMAC1 keys use different\n+     * key factories. PBMAC1 uses a pseudorandom function (kdfHmac)\n+     * to generate keys while non-PBMAC1 does not. The MAC is computed\n+     * according to the specified hmac algorithm.\n+     *\n+     * @param macAlgorithm the algorithm used to compute the MAC\n+     * @param password the password used to generate the key\n+     * @param params a PBEParameterSpec object\n+     * @param data the data on which the MAC is computed\n+     * @param kdfHmac the pseudorandom function used to compute the key\n+     * for PBMAC1\n+     * @param hmac the algorithm used to compute the MAC\n+     * @param keyLength the length of the key generated by the pseudorandom\n+     * function\n+     *\n+     * @return the computed MAC as a byte array\n+     *\n+     * @exception NoSuchAlgorithmException if either kdfHmac or hmac is\n+     * unknown to the Mac or SecretKeyFactory\n+     *\/\n+    private static byte[] calculateMac(String macAlgorithm, char[] password,\n+            PBEParameterSpec params, byte[] data,\n+            String kdfHmac, String hmac, int keyLength)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException,\n+            InvalidKeySpecException, NoSuchAlgorithmException {\n+        SecretKeyFactory skf;\n+        SecretKey pbeKey = null;\n+        Mac m;\n+\n+        PBEKeySpec keySpec;\n+\n+        \/*\n+         * The Hmac has to be extracted from the algorithm name for\n+         * PBMAC1 algorithms. For non-PBMAC1 macAlgorithms, the name\n+         * and Hmac are the same.\n+         *\n+         * The prefix used in Algorithm names is guaranteed to be lowercase.\n+         *\/\n+        if (macAlgorithm.startsWith(\"pbewith\")) {\n+            m = Mac.getInstance(hmac);\n+            int len = keyLength == -1 ? m.getMacLength()*8 : keyLength;\n+            skf = SecretKeyFactory.getInstance(\"PBKDF2With\" +kdfHmac);\n+            keySpec = new PBEKeySpec(password, params.getSalt(),\n+                    params.getIterationCount(), len);\n@@ -107,1 +186,3 @@\n-            this.digest = digest.clone();\n+            m = Mac.getInstance(macAlgorithm);\n+            skf = SecretKeyFactory.getInstance(\"PBE\");\n+            keySpec = new PBEKeySpec(password);\n@@ -110,2 +191,14 @@\n-        this.macSalt = salt;\n-        this.iterations = iterations;\n+        try {\n+            pbeKey = skf.generateSecret(keySpec);\n+            if (macAlgorithm.startsWith(\"pbewith\")) {\n+                m.init(pbeKey);\n+            } else {\n+                m.init(pbeKey, params);\n+            }\n+            m.update(data);\n+            return m.doFinal();\n+        } finally {\n+            keySpec.clearPassword();\n+            KeyUtil.destroySecretKeys(pbeKey);\n+        }\n+    }\n@@ -113,3 +206,25 @@\n-        \/\/ delay the generation of ASN.1 encoding until\n-        \/\/ getEncoded() is called\n-        this.encoded = null;\n+    \/**\n+     * Verify Mac on the data.\n+     *\n+     * Calculate Mac on the data and compare with Mac found in input stream.\n+     *\n+     * @param password the password used to generate the key\n+     * @param data the data on which the MAC is computed\n+     *\n+     * @exception UnrecoverableKeyException if calculated Mac and\n+     * Mac found in input stream are different\n+     *\/\n+    void verifyMac(char[] password, byte[] data)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException,\n+            InvalidKeySpecException, NoSuchAlgorithmException,\n+            UnrecoverableKeyException {\n+\n+        byte[] macResult = calculateMac(this.macAlgorithm, password,\n+                new PBEParameterSpec(this.macSalt, this.iterations),\n+                data, this.kdfHmac, this.hmac, this.keyLength);\n+\n+        if (debug != null) {\n+            debug.println(\"Checking keystore integrity \" +\n+                    \"(\" + this.macAlgorithm + \" iterations: \"\n+                    + this.iterations + \")\");\n+        }\n@@ -117,0 +232,4 @@\n+        if (!MessageDigest.isEqual(this.digest, macResult)) {\n+            throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n+                    \" integrity checking\");\n+        }\n@@ -119,3 +238,44 @@\n-    String getDigestAlgName() {\n-        return digestAlgorithmName;\n-    }\n+    \/*\n+     * Gathers parameters and generates a MAC of the data\n+     *\n+     * @param password the password used to generate the key\n+     * @param data the data on which the MAC is computed\n+     * @param macAlgorithm the algorithm used to compute the MAC\n+     * @param macIterationCount the iteration count\n+     * @param salt the salt\n+     *\n+     * @exception IOException if the MAC cannot be calculated\n+     *\n+     * @return the computed MAC as a byte array\n+     *\/\n+    static byte[] generateMac(char[] passwd, byte[] data,\n+            String macAlgorithm, int macIterationCount, byte[] salt)\n+            throws IOException, NoSuchAlgorithmException {\n+        final PBEParameterSpec params;\n+        String algName;\n+        String kdfHmac;\n+        String hmac;\n+\n+        macAlgorithm = macAlgorithm.toLowerCase(ENGLISH);\n+        \/\/ The prefix used in Algorithm names is guaranteed to be lowercase.\n+        if (macAlgorithm.startsWith(\"pbewith\")) {\n+            algName = \"PBMAC1\";\n+            kdfHmac = MacData.parseKdfHmac(macAlgorithm);\n+            hmac = MacData.parseHmac(macAlgorithm);\n+            if (hmac == null) {\n+                hmac = kdfHmac;\n+            }\n+        } else if (macAlgorithm.startsWith(\"hmacpbe\")) {\n+            algName = macAlgorithm.substring(7);\n+            kdfHmac = null;\n+            hmac = macAlgorithm;\n+        } else {\n+            throw new ParsingException(\"unexpected algorithm '\"\n+                    + macAlgorithm + \"'\");\n+        }\n+\n+        params = new PBEParameterSpec(salt, macIterationCount);\n+\n+        try {\n+            byte[] macResult = calculateMac(macAlgorithm, passwd, params, data,\n+                    kdfHmac, hmac, -1);\n@@ -123,2 +283,8 @@\n-    byte[] getSalt() {\n-        return macSalt;\n+            DerOutputStream bytes = new DerOutputStream();\n+            bytes.write(encode(algName, macResult, params, kdfHmac, hmac,\n+                    macResult.length));\n+            return bytes.toByteArray();\n+        } catch (InvalidKeySpecException | InvalidKeyException |\n+                    InvalidAlgorithmParameterException e) {\n+            throw new IOException(\"calculateMac failed: \" + e, e);\n+        }\n@@ -127,2 +293,2 @@\n-    int getIterations() {\n-        return iterations;\n+    String getMacAlgorithm() {\n+        return this.macAlgorithm;\n@@ -131,2 +297,2 @@\n-    byte[] getDigest() {\n-        return digest;\n+    int getIterations() {\n+        return this.iterations;\n@@ -136,3 +302,3 @@\n-     * Returns the ASN.1 encoding of this object.\n-     * @return the ASN.1 encoding.\n-     * @exception IOException if error occurs when constructing its\n+     * Returns the ASN.1 encoding.\n+     * @return the ASN.1 encoding\n+     * @exception NoSuchAlgorithmException if error occurs when constructing its\n@@ -141,4 +307,6 @@\n-    public byte[] getEncoded() throws NoSuchAlgorithmException\n-    {\n-        if (this.encoded != null)\n-            return this.encoded.clone();\n+    static byte[] encode(String algName, byte[] digest, PBEParameterSpec p,\n+            String kdfHmac, String hmac, int keyLength)\n+            throws IOException, NoSuchAlgorithmException {\n+\n+        final int iterations = p.getIterationCount();\n+        final byte[] macSalt = p.getSalt();\n@@ -146,1 +314,0 @@\n-        DerOutputStream out = new DerOutputStream();\n@@ -148,0 +315,1 @@\n+        DerOutputStream out = new DerOutputStream();\n@@ -149,4 +317,3 @@\n-        DerOutputStream tmp2 = new DerOutputStream();\n-        \/\/ encode encryption algorithm\n-        AlgorithmId algid = AlgorithmId.get(digestAlgorithmName);\n-        algid.encode(tmp2);\n+        if (algName.equals(\"PBMAC1\")) {\n+            DerOutputStream tmp1 = new DerOutputStream();\n+            DerOutputStream tmp2 = new DerOutputStream();\n@@ -154,2 +321,4 @@\n-        \/\/ encode digest data\n-        tmp2.putOctetString(digest);\n+            \/\/ id-PBMAC1 OBJECT IDENTIFIER ::= { pkcs-5 14 }\n+            tmp2.putOID(ObjectIdentifier.of(KnownOIDs.PBMAC1));\n+            tmp2.writeBytes(PBMAC1Parameters.encode(macSalt, iterations,\n+                    keyLength, kdfHmac, hmac));\n@@ -157,1 +326,2 @@\n-        tmp.write(DerValue.tag_Sequence, tmp2);\n+            tmp1.write(DerValue.tag_Sequence, tmp2);\n+            tmp1.putOctetString(digest);\n@@ -159,2 +329,8 @@\n-        \/\/ encode salt\n-        tmp.putOctetString(macSalt);\n+            tmp.write(DerValue.tag_Sequence, tmp1);\n+            tmp.putOctetString(\n+                    new byte[]{ 'N', 'O', 'T', ' ', 'U', 'S', 'E', 'D' });\n+            \/\/ Unused, but must have non-zero positive value.\n+            tmp.putInteger(1);\n+        } else {\n+            final AlgorithmId digestAlgorithm = AlgorithmId.get(algName);\n+            DerOutputStream tmp2 = new DerOutputStream();\n@@ -162,2 +338,2 @@\n-        \/\/ encode iterations\n-        tmp.putInteger(iterations);\n+            tmp2.write(digestAlgorithm);\n+            tmp2.putOctetString(digest);\n@@ -165,0 +341,5 @@\n+            \/\/ wrap into a SEQUENCE\n+            tmp.write(DerValue.tag_Sequence, tmp2);\n+            tmp.putOctetString(macSalt);\n+            tmp.putInteger(iterations);\n+        }\n@@ -167,1 +348,2 @@\n-        this.encoded = out.toByteArray();\n+        return out.toByteArray();\n+    }\n@@ -169,1 +351,10 @@\n-        return this.encoded.clone();\n+    private static String parseKdfHmac(String text) {\n+        int index1 = text.indexOf(\"with\") + 4;\n+        int index2 = text.indexOf(\"and\");\n+        if (index1 == 3) { \/\/ -1 + 4\n+            return null;\n+        } else if (index2 == -1) {\n+            return text.substring(index1);\n+        } else {\n+            return text.substring(index1, index2);\n+        }\n@@ -172,0 +363,8 @@\n+    private static String parseHmac(String text) {\n+        int index1 = text.indexOf(\"and\") + 3;\n+        if (index1 == 2) { \/\/ -1 + 3\n+            return null;\n+        } else {\n+            return text.substring(index1);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/MacData.java","additions":271,"deletions":72,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs12;\n+\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n+\n+\/**\n+ * This class implements the parameter set used with password-based\n+ * mac scheme 1 (PBMAC1), which is defined in PKCS#5 as follows:\n+ *\n+ * <pre>\n+ * -- PBMAC1\n+ *\n+ * PBMAC1Algorithms ALGORITHM-IDENTIFIER ::=\n+ *   { {PBMAC1-params IDENTIFIED BY id-PBMAC1}, ...}\n+ *\n+ * id-PBMAC1 OBJECT IDENTIFIER ::= {pkcs-5 14}\n+ *\n+ * PBMAC1-params ::= SEQUENCE {\n+ *   keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}},\n+ *   messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}} }\n+ *\n+ * PBMAC1-KDFs ALGORITHM-IDENTIFIER ::=\n+ *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }\n+ *\n+ * PBMAC1-MACs ALGORITHM-IDENTIFIER ::= { ... }\n+ *\n+ * -- PBKDF2\n+ *\n+ * See sun.security.util.PBKDF2Parameters.\n+ *\n+ * <\/pre>\n+ *\n+ * @since 26\n+ *\/\n+final class PBMAC1Parameters {\n+\n+    static final ObjectIdentifier pkcs5PBKDF2_OID =\n+            ObjectIdentifier.of(KnownOIDs.PBKDF2);\n+\n+    private final String hmacAlgo;\n+    private final PBKDF2Parameters kdfParams;\n+\n+    PBMAC1Parameters(byte[] encoded) throws IOException {\n+        DerValue pBMAC1_params = new DerValue(encoded);\n+        if (pBMAC1_params.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                    + \"not an ASN.1 SEQUENCE tag\");\n+        }\n+        DerValue[] info = new DerInputStream(pBMAC1_params.toByteArray())\n+                .getSequence(2);\n+        if (info.length != 2) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                + \"expected length not 2\");\n+        }\n+        ObjectIdentifier OID = info[1].data.getOID();\n+        KnownOIDs o = KnownOIDs.findMatch(OID.toString());\n+        if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n+                !o.stdName().equals(\"HmacSHA224\") &&\n+                !o.stdName().equals(\"HmacSHA256\") &&\n+                !o.stdName().equals(\"HmacSHA384\") &&\n+                !o.stdName().equals(\"HmacSHA512\") &&\n+                !o.stdName().equals(\"HmacSHA512\/224\") &&\n+                !o.stdName().equals(\"HmacSHA512\/256\"))) {\n+            throw new IOException(\"PBMAC1 parameter parsing error: \"\n+                    + \"expecting the object identifier for a HmacSHA key \"\n+                    + \"derivation function\");\n+        }\n+        \/\/ Hmac function used to compute the MAC\n+        this.hmacAlgo = o.stdName();\n+\n+        \/\/DerValue kdf = pBMAC1_params.data.getDerValue();\n+        DerValue kdf = info[0];\n+\n+        if (!pkcs5PBKDF2_OID.equals(kdf.data.getOID())) {\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"expecting the object identifier for PBKDF2\");\n+        }\n+        if (kdf.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"not an ASN.1 SEQUENCE tag\");\n+        }\n+        DerValue pBKDF2_params = kdf.data.getDerValue();\n+\n+        this.kdfParams = new PBKDF2Parameters(pBKDF2_params);\n+    }\n+\n+    \/*\n+     * Encode PBMAC1 parameters from components.\n+     *\/\n+    static byte[] encode(byte[] salt, int iterationCount, int keyLength,\n+            String kdfHmac, String hmac) throws NoSuchAlgorithmException {\n+\n+        DerOutputStream out = new DerOutputStream();\n+\n+        \/\/ keyDerivationFunc AlgorithmIdentifier {{PBMAC1-KDFs}}\n+        out.writeBytes(PBKDF2Parameters.encode(salt,\n+                iterationCount, keyLength, kdfHmac));\n+\n+        \/\/ messageAuthScheme AlgorithmIdentifier {{PBMAC1-MACs}}\n+        out.write(AlgorithmId.get(hmac));\n+        return new DerOutputStream().write(DerValue.tag_Sequence, out)\n+                .toByteArray();\n+    }\n+\n+    PBKDF2Parameters getKdfParams() {\n+        return this.kdfParams;\n+    }\n+\n+    String getHmac() {\n+        return this.hmacAlgo;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PBMAC1Parameters.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,13 +29,1 @@\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.Key;\n-import java.security.KeyFactory;\n-import java.security.KeyStore;\n-import java.security.KeyStoreSpi;\n-import java.security.KeyStoreException;\n-import java.security.PKCS12Attribute;\n-import java.security.PrivateKey;\n-import java.security.UnrecoverableEntryException;\n-import java.security.UnrecoverableKeyException;\n-import java.security.SecureRandom;\n-import java.security.Security;\n+import java.security.*;\n@@ -43,0 +31,1 @@\n+import java.security.cert.CertificateException;\n@@ -45,1 +34,0 @@\n-import java.security.cert.CertificateException;\n@@ -51,6 +39,3 @@\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-import java.security.AlgorithmParameters;\n-import java.security.InvalidAlgorithmParameterException;\n-import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n@@ -58,0 +43,1 @@\n+import javax.crypto.spec.PBEParameterSpec;\n@@ -59,4 +45,0 @@\n-import javax.crypto.SecretKeyFactory;\n-import javax.crypto.SecretKey;\n-import javax.crypto.Cipher;\n-import javax.crypto.Mac;\n@@ -67,2 +49,0 @@\n-import sun.security.tools.KeyStoreUtil;\n-import sun.security.util.*;\n@@ -70,1 +50,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -73,0 +52,3 @@\n+import sun.security.tools.KeyStoreUtil;\n+import sun.security.util.*;\n+import sun.security.x509.AlgorithmId;\n@@ -75,0 +57,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -369,1 +353,1 @@\n-                    destroyPBEKey(skey);\n+                    KeyUtil.destroySecretKeys(skey);\n@@ -858,11 +842,0 @@\n-    \/*\n-     * Destroy the key obtained from getPBEKey().\n-     *\/\n-    private void destroyPBEKey(SecretKey key) {\n-        try {\n-            key.destroy();\n-        } catch (DestroyFailedException e) {\n-            \/\/ Accept this\n-        }\n-    }\n-\n@@ -918,1 +891,1 @@\n-                destroyPBEKey(skey);\n+                KeyUtil.destroySecretKeys(skey);\n@@ -1268,1 +1241,2 @@\n-            byte[] macData = calculateMac(password, authenticatedSafe);\n+            byte[] macData = MacData.generateMac(password, authenticatedSafe,\n+                    macAlgorithm, macIterationCount, getSalt());\n@@ -1483,42 +1457,0 @@\n-    \/*\n-     * Calculate MAC using HMAC algorithm (required for password integrity)\n-     *\n-     * Hash-based MAC algorithm combines secret key with message digest to\n-     * create a message authentication code (MAC)\n-     *\/\n-    private byte[] calculateMac(char[] passwd, byte[] data)\n-        throws IOException\n-    {\n-        byte[] mData;\n-        String algName = macAlgorithm.substring(7);\n-\n-        try {\n-            \/\/ Generate a random salt.\n-            byte[] salt = getSalt();\n-\n-            \/\/ generate MAC (MAC key is generated within JCE)\n-            Mac m = Mac.getInstance(macAlgorithm);\n-            PBEParameterSpec params =\n-                        new PBEParameterSpec(salt, macIterationCount);\n-            SecretKey key = getPBEKey(passwd);\n-            try {\n-                m.init(key, params);\n-            } finally {\n-                destroyPBEKey(key);\n-            }\n-            m.update(data);\n-            byte[] macResult = m.doFinal();\n-\n-            \/\/ encode as MacData\n-            MacData macData = new MacData(algName, macResult, salt,\n-                    macIterationCount);\n-            DerOutputStream bytes = new DerOutputStream();\n-            bytes.write(macData.getEncoded());\n-            mData = bytes.toByteArray();\n-        } catch (Exception e) {\n-            throw new IOException(\"calculateMac failed: \" + e, e);\n-        }\n-        return mData;\n-    }\n-\n-\n@@ -1893,1 +1825,1 @@\n-                destroyPBEKey(skey);\n+                KeyUtil.destroySecretKeys(skey);\n@@ -2103,1 +2035,1 @@\n-                            destroyPBEKey(skey);\n+                            KeyUtil.destroySecretKeys(skey);\n@@ -2138,7 +2070,2 @@\n-                    String algName =\n-                            macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);\n-\n-                    \/\/ Change SHA-1 to SHA1\n-                    algName = algName.replace(\"-\", \"\");\n-\n-                    macAlgorithm = \"HmacPBE\" + algName;\n+                    \/\/ Store MAC algorithm of keystore that was just loaded.\n+                    macAlgorithm = macData.getMacAlgorithm();\n@@ -2146,6 +2073,0 @@\n-\n-                    \/\/ generate MAC (MAC key is created within JCE)\n-                    Mac m = Mac.getInstance(macAlgorithm);\n-                    PBEParameterSpec params =\n-                            new PBEParameterSpec(macData.getSalt(), ic);\n-\n@@ -2153,18 +2074,1 @@\n-                        SecretKey key = getPBEKey(pass);\n-                        try {\n-                            m.init(key, params);\n-                        } finally {\n-                            destroyPBEKey(key);\n-                        }\n-                        m.update(authSafeData);\n-                        byte[] macResult = m.doFinal();\n-\n-                        if (debug != null) {\n-                            debug.println(\"Checking keystore integrity \" +\n-                                    \"(\" + m.getAlgorithm() + \" iterations: \" + ic + \")\");\n-                        }\n-\n-                        if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {\n-                            throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n-                                    \" integrity checking\");\n-                        }\n+                        macData.verifyMac(pass, authSafeData);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":21,"deletions":117,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import sun.security.ssl.SignatureScheme.SupportedSigSchemes;\n@@ -244,2 +245,6 @@\n-                CustomizedClientSignatureSchemes.signatureSchemes :\n-                CustomizedServerSignatureSchemes.signatureSchemes;\n+                CustomizedClientSignatureSchemes.signatureSchemes != null ?\n+                        CustomizedClientSignatureSchemes.signatureSchemes :\n+                        SupportedSigSchemes.DEFAULT :\n+                CustomizedServerSignatureSchemes.signatureSchemes != null ?\n+                        CustomizedServerSignatureSchemes.signatureSchemes :\n+                        SupportedSigSchemes.DEFAULT;\n@@ -365,1 +370,3 @@\n-        }   \/\/ Otherwise, use the default values\n+        } else {    \/\/ Otherwise, use the default values.\n+            this.signatureSchemes = SupportedSigSchemes.DEFAULT;\n+        }\n@@ -517,1 +524,2 @@\n-        \/\/ Reset the signature schemes, if it was configured with SSLParameters.\n+        \/\/ Reset the signature schemes, if it was configured with a\n+        \/\/ system property.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-    boolean isDefaultProtocolVesions(List<ProtocolVersion> protocols) {\n+    boolean isDefaultProtocolVersions(List<ProtocolVersion> protocols) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-                if (sslContext.isDefaultProtocolVesions(\n+                if (sslContext.isDefaultProtocolVersions(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLServerSocketImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Collections;\n@@ -416,0 +415,1 @@\n+        List<SignatureScheme> schemesToCheck;\n@@ -417,4 +417,15 @@\n-        List<SignatureScheme> schemesToCheck =\n-                config.signatureSchemes == null ?\n-                    Arrays.asList(SignatureScheme.values()) :\n-                    namesOfAvailable(config.signatureSchemes);\n+        \/\/ No need to look up the names of the default signature schemes.\n+        if (config.signatureSchemes == SupportedSigSchemes.DEFAULT) {\n+            schemesToCheck = Arrays.asList(SignatureScheme.values());\n+        } else {\n+            schemesToCheck = new ArrayList<>();\n+            for (String name : config.signatureSchemes) {\n+                var ss = SignatureScheme.nameOf(name);\n+                if (ss != null) {\n+                    schemesToCheck.add(ss);\n+                } else {\n+                    SSLLogger.logWarning(\"ssl,handshake\", \"Unavailable \"\n+                            + \"configured signature scheme: \" + name);\n+                }\n+            }\n+        }\n@@ -473,2 +484,2 @@\n-            } else if ((config.signatureSchemes == null\n-                        || Utilities.contains(config.signatureSchemes, ss.name))\n+            } else if ((config.signatureSchemes == SupportedSigSchemes.DEFAULT\n+                    || Utilities.contains(config.signatureSchemes, ss.name))\n@@ -617,27 +628,0 @@\n-    private static List<SignatureScheme> namesOfAvailable(\n-                String[] signatureSchemes) {\n-\n-        if (signatureSchemes == null || signatureSchemes.length == 0) {\n-            return Collections.emptyList();\n-        }\n-\n-        List<SignatureScheme> sss = new ArrayList<>(signatureSchemes.length);\n-        for (String ss : signatureSchemes) {\n-            SignatureScheme scheme = SignatureScheme.nameOf(ss);\n-            if (scheme == null || !scheme.isAvailable) {\n-                if (SSLLogger.isOn &&\n-                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n-                    SSLLogger.finest(\n-                            \"Ignore the signature algorithm (\" + ss\n-                          + \"), unsupported or unavailable\");\n-                }\n-\n-                continue;\n-            }\n-\n-            sss.add(scheme);\n-        }\n-\n-        return sss;\n-    }\n-\n@@ -689,0 +673,11 @@\n+\n+    \/\/ Default signature schemes for SSLConfiguration.\n+    static final class SupportedSigSchemes {\n+\n+        static final String[] DEFAULT = Arrays.stream(\n+                        SignatureScheme.values())\n+                .filter(ss -> ss.isAvailable\n+                        && ss.isPermitted(\n+                        SSLAlgorithmConstraints.DEFAULT, null))\n+                .map(ss -> ss.name).toArray(String[]::new);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":29,"deletions":34,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -474,1 +474,1 @@\n-            if (sslContext.isDefaultProtocolVesions(\n+            if (sslContext.isDefaultProtocolVersions(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import com.sun.crypto.provider.PBKDF2KeyImpl;\n@@ -472,0 +473,2 @@\n+                } else if (k instanceof PBKDF2KeyImpl p2k) {\n+                    p2k.clear();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-    PBKDF2WithHmacSHA1(\"1.2.840.113549.1.5.12\"),\n+    PBKDF2(\"1.2.840.113549.1.5.12\", \"PBKDF2WithHmacSHA1\"),\n@@ -213,0 +213,1 @@\n+    PBMAC1(\"1.2.840.113549.1.5.14\"),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.io.IOException;\n+\n+import sun.security.util.KnownOIDs;\n+import sun.security.x509.AlgorithmId;\n+\n+\/**\n+ * This class implements the parameter set used with password-based\n+ * key derivation function 2 (PBKDF2), which is defined in PKCS#5 as follows:\n+ *\n+ * <pre>\n+ *\n+ * PBKDF2Algorithms ALGORITHM-IDENTIFIER ::=\n+ *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ...}\n+ *\n+ * id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}\n+ *\n+ * PBKDF2-params ::= SEQUENCE {\n+ *     salt CHOICE {\n+ *       specified OCTET STRING,\n+ *       otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}\n+ *     },\n+ *     iterationCount INTEGER (1..MAX),\n+ *     keyLength INTEGER (1..MAX) OPTIONAL,\n+ *     prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n+ * }\n+ *\n+ * PBKDF2-SaltSources ALGORITHM-IDENTIFIER ::= { ... }\n+ *\n+ * PBKDF2-PRFs ALGORITHM-IDENTIFIER ::= {\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA1} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA224} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA256} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA384} |\n+ *     {NULL IDENTIFIED BY id-hmacWithSHA512}, ... }\n+ *\n+ * algid-hmacWithSHA1 AlgorithmIdentifier {{PBKDF2-PRFs}} ::=\n+ *     {algorithm id-hmacWithSHA1, parameters NULL : NULL}\n+ *\n+ * id-hmacWithSHA1 OBJECT IDENTIFIER ::= {digestAlgorithm 7}\n+ *\n+ * For more information, see\n+ * <a href=\"https:\/\/tools.ietf.org\/html\/rfc8018\">RFC 8018:\n+ * PKCS #5: Password-Based Cryptography Specification<\/a>.\n+ *\n+ * <\/pre>\n+ *\/\n+public final class PBKDF2Parameters {\n+\n+    private final byte[] salt;\n+\n+    private final int iterationCount;\n+\n+    \/\/ keyLength in bits, or -1 if not present\n+    private final int keyLength;\n+\n+    private final String prfAlgo;\n+\n+    \/**\n+     * Initialize PBKDF2Parameters from a DER encoded\n+     * parameter block.\n+     *\n+     * @param pBKDF2_params the DER encoding of the parameter block\n+     *\n+     * @throws IOException for parsing errors in the input stream\n+     *\/\n+    public PBKDF2Parameters(DerValue pBKDF2_params) throws IOException {\n+\n+        if (pBKDF2_params.tag != DerValue.tag_Sequence) {\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"not an ASN.1 SEQUENCE tag\");\n+        }\n+        DerValue specified = pBKDF2_params.data.getDerValue();\n+        \/\/ the 'specified' ASN.1 CHOICE for 'salt' is supported\n+        if (specified.tag == DerValue.tag_OctetString) {\n+            salt = specified.getOctetString();\n+        } else {\n+            \/\/ the 'otherSource' ASN.1 CHOICE for 'salt' is not supported\n+            throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                + \"not an ASN.1 OCTET STRING tag\");\n+        }\n+        iterationCount = pBKDF2_params.data.getInteger();\n+\n+        \/\/ keyLength INTEGER (1..MAX) OPTIONAL,\n+        var ksDer = pBKDF2_params.data.getOptional(DerValue.tag_Integer);\n+        if (ksDer.isPresent()) {\n+            keyLength = ksDer.get().getInteger() * 8; \/\/ keyLength (in bits)\n+        } else {\n+            keyLength = -1;\n+        }\n+\n+        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1\n+        var prfDer = pBKDF2_params.data.getOptional(DerValue.tag_Sequence);\n+        if (prfDer.isPresent()) {\n+            DerValue prf = prfDer.get();\n+            \/\/ the pseudorandom function (default is HmacSHA1)\n+            ObjectIdentifier kdfAlgo_OID = prf.data.getOID();\n+            KnownOIDs o = KnownOIDs.findMatch(kdfAlgo_OID.toString());\n+            if (o == null || (!o.stdName().equals(\"HmacSHA1\") &&\n+                    !o.stdName().equals(\"HmacSHA224\") &&\n+                    !o.stdName().equals(\"HmacSHA256\") &&\n+                    !o.stdName().equals(\"HmacSHA384\") &&\n+                    !o.stdName().equals(\"HmacSHA512\") &&\n+                    !o.stdName().equals(\"HmacSHA512\/224\") &&\n+                    !o.stdName().equals(\"HmacSHA512\/256\"))) {\n+                throw new IOException(\"PBKDF2 parameter parsing error: \"\n+                        + \"expecting the object identifier for a HmacSHA \"\n+                        + \"pseudorandom function\");\n+            }\n+            prfAlgo = o.stdName();\n+            prf.data.getOptional(DerValue.tag_Null);\n+            prf.data.atEnd();\n+        } else {\n+            prfAlgo = \"HmacSHA1\";\n+        }\n+    }\n+\n+    public static byte[] encode(byte[] salt, int iterationCount,\n+            int keyLength, String kdfHmac) {\n+        ObjectIdentifier prf =\n+               ObjectIdentifier.of(KnownOIDs.findMatch(kdfHmac));\n+        return PBKDF2Parameters.encode(salt, iterationCount, keyLength, prf);\n+    }\n+\n+    \/*\n+     * Encode PBKDF2 parameters from components.\n+     * The outer algorithm ID is also encoded in addition to the parameters.\n+     *\/\n+    public static byte[] encode(byte[] salt, int iterationCount,\n+            int keyLength, ObjectIdentifier prf) {\n+        assert keyLength != -1;\n+\n+        DerOutputStream out = new DerOutputStream();\n+        DerOutputStream tmp0 = new DerOutputStream();\n+\n+        tmp0.putOctetString(salt);\n+        tmp0.putInteger(iterationCount);\n+        tmp0.putInteger(keyLength);\n+\n+        \/\/ prf AlgorithmIdentifier {{PBKDF2-PRFs}}\n+        tmp0.write(new AlgorithmId(prf));\n+\n+        \/\/ id-PBKDF2 OBJECT IDENTIFIER ::= {pkcs-5 12}\n+        out.putOID(ObjectIdentifier.of(KnownOIDs.PBKDF2));\n+        out.write(DerValue.tag_Sequence, tmp0);\n+\n+        return new DerOutputStream().write(DerValue.tag_Sequence, out)\n+                .toByteArray();\n+    }\n+\n+    \/**\n+     * Returns the salt.\n+     *\n+     * @return the salt\n+     *\/\n+    public byte[] getSalt() {\n+        return this.salt;\n+    }\n+\n+    \/**\n+     * Returns the iteration count.\n+     *\n+     * @return the iteration count\n+     *\/\n+    public int getIterationCount() {\n+        return this.iterationCount;\n+    }\n+\n+    \/**\n+     * Returns size of key generated by PBKDF2, or -1 if not found\/set.\n+     *\n+     * @return size of key generated by PBKDF2, or -1 if not found\/set\n+     *\/\n+    public int getKeyLength() {\n+        return this.keyLength;\n+    }\n+\n+    \/**\n+     * Returns name of Hmac.\n+     *\n+     * @return name of Hmac\n+     *\/\n+    public String getPrfAlgo() {\n+        return this.prfAlgo;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBKDF2Parameters.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -1344,2 +1344,3 @@\n-# file. This can be any HmacPBE algorithm defined in the Mac section of the\n-# Java Security Standard Algorithm Names Specification. When set to \"NONE\",\n+# file. This can be any HmacPBE<digest> or PBEWith<mac> algorithm defined in\n+# the Mac section of the Java Security Standard Algorithm Names Specification,\n+# for example, HmacPBESHA256 or PBEWithHmacSHA256. When set to \"NONE\",\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef _DEFINES_H\n-#define _DEFINES_H\n-\n-#include \"java.h\"\n-\n-#define STR_HELPER(x) #x\n-#define STR(x) STR_HELPER(x)\n-\n-\/*\n- * This file contains commonly defined constants used only by main.c\n- * and should not be included by another file.\n- *\/\n-#ifndef VERSION_STRING\n-\/* make sure the compilation fails *\/\n-#error \"VERSION_STRING must be defined\"\n-#endif\n-\n-\/* Unused, but retained for JLI_Launch compatibility*\/\n-#define DOT_VERSION \"0.0\"\n-\n-#ifdef JAVA_ARGS\n-#ifdef PROGNAME\n-static const char* const_progname = PROGNAME;\n-#else\n-static char* const_progname = NULL;\n-#endif\n-static const char* const_jargs[] = JAVA_ARGS;\n-#else  \/* !JAVA_ARGS *\/\n-static const char* const_progname = \"java\";\n-static const char** const_jargs = NULL;\n-#endif \/* JAVA_ARGS *\/\n-\n-#ifdef LAUNCHER_NAME\n-static const char* const_launcher = LAUNCHER_NAME;\n-#else  \/* LAUNCHER_NAME *\/\n-static char* const_launcher = NULL;\n-#endif \/* LAUNCHER_NAME *\/\n-\n-#ifdef EXPAND_CLASSPATH_WILDCARDS\n-static const jboolean const_cpwildcard = JNI_TRUE;\n-#else\n-static const jboolean const_cpwildcard = JNI_FALSE;\n-#endif \/* EXPAND_CLASSPATH_WILDCARDS *\/\n-\n-#ifdef ENABLE_ARG_FILES\n-static const jboolean const_disable_argfile = JNI_FALSE;\n-#else\n-static const jboolean const_disable_argfile = JNI_TRUE;\n-#endif\n-#endif \/*_DEFINES_H *\/\n","filename":"src\/java.base\/share\/native\/launcher\/defines.h","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"defines.h\"\n+#include \"java.h\"\n@@ -37,0 +37,50 @@\n+\/\/ Unused, but retained for JLI_Launch compatibility\n+#define DOT_VERSION \"0.0\"\n+\n+\/\/ This is reported when requesting a full version\n+static char* launcher = LAUNCHER_NAME;\n+\n+\/\/ This is used as the name of the executable in the help message\n+static char* progname = PROGNAME;\n+\n+#ifdef JAVA_ARGS\n+static const char* jargs[] = JAVA_ARGS;\n+#else\n+static const char** jargs = NULL;\n+#endif\n+static int jargc;\n+\n+static jboolean cpwildcard = CLASSPATH_WILDCARDS;\n+static jboolean disable_argfile = DISABLE_ARGFILE;\n+\n+#ifdef STATIC_BUILD\n+static void check_relauncher_argument(char* arg) {\n+    if (strcmp(arg, \"-J-DjavaLauncherWildcards=false\") == 0) {\n+        cpwildcard = JNI_FALSE;\n+    }\n+    const char *progname_prefix = \"-J-DjavaLauncherProgname=\";\n+    size_t progname_prefix_len = strlen(progname_prefix);\n+    if (strncmp(arg, progname_prefix, progname_prefix_len) == 0) {\n+        progname = arg + progname_prefix_len;\n+    }\n+    const char *args_prefix = \"-J-DjavaLauncherArgs=\";\n+    size_t args_prefix_len = strlen(args_prefix);\n+    if (strncmp(arg, args_prefix, args_prefix_len) == 0) {\n+        char* java_args_ptr = arg + args_prefix_len;\n+        size_t java_args_len = strlen(arg) - args_prefix_len;\n+\n+        JLI_List java_args = JLI_List_new(java_args_len);\n+        char* next_space;\n+        while ((next_space = strchr(java_args_ptr, ' ')) != NULL) {\n+            size_t next_arg_len = next_space - java_args_ptr;\n+            JLI_List_addSubstring(java_args, java_args_ptr, next_arg_len);\n+            java_args_ptr = next_space + 1;\n+        }\n+        JLI_List_add(java_args, java_args_ptr);\n+\n+        jargc = (int) java_args->size;\n+        jargs = (const char**) java_args->elements;\n+    }\n+}\n+#endif\n+\n@@ -47,1 +97,1 @@\n-    const jboolean const_javaw = JNI_TRUE;\n+    const jboolean javaw = JNI_TRUE;\n@@ -55,1 +105,1 @@\n-    const jboolean const_javaw = JNI_FALSE;\n+    const jboolean javaw = JNI_FALSE;\n@@ -60,2 +110,0 @@\n-    int jargc;\n-    const char** jargv = const_jargs;\n@@ -63,2 +111,2 @@\n-    jargc = (sizeof(const_jargs) \/ sizeof(char *)) > 1\n-        ? sizeof(const_jargs) \/ sizeof(char *)\n+    jargc = (sizeof(jargs) \/ sizeof(char *)) > 1\n+        ? sizeof(jargs) \/ sizeof(char *)\n@@ -67,1 +115,9 @@\n-    JLI_InitArgProcessing(jargc > 0, const_disable_argfile);\n+#ifdef STATIC_BUILD\n+        \/\/ Relaunchers always give -J-DjavaLauncherArgFiles as the first argument, if present\n+        \/\/ We must check disable_argfile before calling JLI_InitArgProcessing.\n+        if (argc > 1 && strcmp(argv[1], \"-J-DjavaLauncherArgFiles=false\") == 0) {\n+            disable_argfile = JNI_TRUE;\n+        }\n+#endif\n+\n+    JLI_InitArgProcessing(jargc > 0, disable_argfile);\n@@ -106,0 +162,3 @@\n+#ifdef STATIC_BUILD\n+            check_relauncher_argument(margv[i]);\n+#endif\n@@ -130,0 +189,3 @@\n+#ifdef STATIC_BUILD\n+            check_relauncher_argument(argv[i]);\n+#endif\n@@ -151,1 +213,1 @@\n-                   jargc, jargv,\n+                   jargc, jargs,\n@@ -155,2 +217,2 @@\n-                   (const_progname != NULL) ? const_progname : *margv,\n-                   (const_launcher != NULL) ? const_launcher : *margv,\n+                   progname,\n+                   launcher,\n@@ -158,1 +220,1 @@\n-                   const_cpwildcard, const_javaw, 0);\n+                   cpwildcard, javaw, 0);\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":75,"deletions":13,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net;\n-\n-import java.net.InetAddress;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/**\n- * Defines static methods to be invoked prior to binding or connecting TCP sockets.\n- *\/\n-\n-public final class NetHooks {\n-\n-    \/**\n-     * A provider with hooks to allow sockets be converted prior to binding or\n-     * connecting a TCP socket.\n-     *\n-     * <p> Concrete implementations of this class should define a zero-argument\n-     * constructor and implement the abstract methods specified below.\n-     *\/\n-    public abstract static class Provider {\n-        \/**\n-         * Initializes a new instance of this class.\n-         *\/\n-        protected Provider() {}\n-\n-        \/**\n-         * Invoked prior to binding a TCP socket.\n-         *\/\n-        public abstract void implBeforeTcpBind(FileDescriptor fdObj,\n-                                               InetAddress address,\n-                                               int port)\n-            throws IOException;\n-\n-        \/**\n-         * Invoked prior to connecting an unbound TCP socket.\n-         *\/\n-        public abstract void implBeforeTcpConnect(FileDescriptor fdObj,\n-                                                 InetAddress address,\n-                                                 int port)\n-            throws IOException;\n-    }\n-\n-    \/**\n-     * For now, we load the SDP provider on Solaris. In the future this may\n-     * be changed to use the ServiceLoader facility to allow the deployment of\n-     * other providers.\n-     *\/\n-    private static final Provider provider = new sun.net.sdp.SdpProvider();\n-\n-    \/**\n-     * Invoke prior to binding a TCP socket.\n-     *\/\n-    public static void beforeTcpBind(FileDescriptor fdObj,\n-                                     InetAddress address,\n-                                     int port)\n-        throws IOException\n-    {\n-        provider.implBeforeTcpBind(fdObj, address, port);\n-    }\n-\n-    \/**\n-     * Invoke prior to connecting an unbound TCP socket.\n-     *\/\n-    public static void beforeTcpConnect(FileDescriptor fdObj,\n-                                        InetAddress address,\n-                                        int port)\n-        throws IOException\n-    {\n-        provider.implBeforeTcpConnect(fdObj, address, port);\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/NetHooks.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,326 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.sdp;\n-\n-import sun.net.NetHooks;\n-import java.net.InetAddress;\n-import java.net.Inet4Address;\n-import java.net.UnknownHostException;\n-import java.util.*;\n-import java.io.File;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-\n-\/**\n- * A NetHooks provider that converts sockets from the TCP to SDP protocol prior\n- * to binding or connecting.\n- *\/\n-\n-public class SdpProvider extends NetHooks.Provider {\n-    \/\/ maximum port\n-    private static final int MAX_PORT = 65535;\n-\n-    \/\/ indicates if SDP is enabled and the rules for when the protocol is used\n-    private final boolean enabled;\n-    private final List<Rule> rules;\n-\n-    \/\/ logging for debug purposes\n-    private PrintStream log;\n-\n-    public SdpProvider() {\n-        Properties props = System.getProperties();\n-        \/\/ if this property is not defined then there is nothing to do.\n-        String file = props.getProperty(\"com.sun.sdp.conf\");\n-        if (file == null) {\n-            this.enabled = false;\n-            this.rules = null;\n-            return;\n-        }\n-\n-        \/\/ load configuration file\n-        List<Rule> list = null;\n-        try {\n-            list = loadRulesFromFile(file);\n-        } catch (IOException e) {\n-            fail(\"Error reading %s: %s\", file, e.getMessage());\n-        }\n-\n-        \/\/ check if debugging is enabled\n-        PrintStream out = null;\n-        String logfile = props.getProperty(\"com.sun.sdp.debug\");\n-        if (logfile != null) {\n-            out = System.out;\n-            if (!logfile.isEmpty()) {\n-                try {\n-                    out = new PrintStream(logfile);\n-                } catch (IOException ignore) { }\n-            }\n-        }\n-\n-        this.enabled = !list.isEmpty();\n-        this.rules = list;\n-        this.log = out;\n-    }\n-\n-    \/\/ supported actions\n-    private static enum Action {\n-        BIND,\n-        CONNECT;\n-    }\n-\n-    \/\/ a rule for matching a bind or connect request\n-    private static interface Rule {\n-        boolean match(Action action, InetAddress address, int port);\n-    }\n-\n-    \/\/ rule to match port[-end]\n-    private static class PortRangeRule implements Rule {\n-        private final Action action;\n-        private final int portStart;\n-        private final int portEnd;\n-        PortRangeRule(Action action, int portStart, int portEnd) {\n-            this.action = action;\n-            this.portStart = portStart;\n-            this.portEnd = portEnd;\n-        }\n-        Action action() {\n-            return action;\n-        }\n-        @Override\n-        public boolean match(Action action, InetAddress address, int port) {\n-            return (action == this.action &&\n-                    port >= this.portStart &&\n-                    port <= this.portEnd);\n-        }\n-    }\n-\n-    \/\/ rule to match address[\/prefix] port[-end]\n-    private static class AddressPortRangeRule extends PortRangeRule {\n-        private final byte[] addressAsBytes;\n-        private final int prefixByteCount;\n-        private final byte mask;\n-        AddressPortRangeRule(Action action, InetAddress address,\n-                             int prefix, int port, int end)\n-        {\n-            super(action, port, end);\n-            this.addressAsBytes = address.getAddress();\n-            this.prefixByteCount = prefix >> 3;\n-            this.mask = (byte)(0xff << (8 - (prefix % 8)));\n-        }\n-        @Override\n-        public boolean match(Action action, InetAddress address, int port) {\n-            if (action != action())\n-                return false;\n-            byte[] candidate = address.getAddress();\n-            \/\/ same address type?\n-            if (candidate.length != addressAsBytes.length)\n-                return false;\n-            \/\/ check bytes\n-            for (int i=0; i<prefixByteCount; i++) {\n-                if (candidate[i] != addressAsBytes[i])\n-                    return false;\n-            }\n-            \/\/ check remaining bits\n-            if ((prefixByteCount < addressAsBytes.length) &&\n-                ((candidate[prefixByteCount] & mask) !=\n-                 (addressAsBytes[prefixByteCount] & mask)))\n-                    return false;\n-            return super.match(action, address, port);\n-        }\n-    }\n-\n-    \/\/ parses port:[-end]\n-    private static int[] parsePortRange(String s) {\n-        int pos = s.indexOf('-');\n-        try {\n-            int[] result = new int[2];\n-            if (pos < 0) {\n-                boolean all = s.equals(\"*\");\n-                result[0] = all ? 0 : Integer.parseInt(s);\n-                result[1] = all ? MAX_PORT : result[0];\n-            } else {\n-                String low = s.substring(0, pos);\n-                if (low.isEmpty()) low = \"*\";\n-                String high = s.substring(pos+1);\n-                if (high.isEmpty()) high = \"*\";\n-                result[0] = low.equals(\"*\") ? 0 : Integer.parseInt(low);\n-                result[1] = high.equals(\"*\") ? MAX_PORT : Integer.parseInt(high);\n-            }\n-            return result;\n-        } catch (NumberFormatException e) {\n-            return new int[0];\n-        }\n-    }\n-\n-    private static void fail(String msg, Object... args) {\n-        Formatter f = new Formatter();\n-        f.format(msg, args);\n-        throw new RuntimeException(f.out().toString());\n-    }\n-\n-    \/\/ loads rules from the given file\n-    \/\/ Each non-blank\/non-comment line must have the format:\n-    \/\/ (\"bind\" | \"connect\") 1*LWSP-char (hostname | ipaddress[\"\/\" prefix])\n-    \/\/     1*LWSP-char (\"*\" | port) [ \"-\" (\"*\" | port) ]\n-    private static List<Rule> loadRulesFromFile(String file)\n-        throws IOException\n-    {\n-        try (Scanner scanner = new Scanner(new File(file))) {\n-            List<Rule> result = new ArrayList<>();\n-            while (scanner.hasNextLine()) {\n-                String line = scanner.nextLine().trim();\n-\n-                \/\/ skip blank lines and comments\n-                if (line.isEmpty() || line.charAt(0) == '#')\n-                    continue;\n-\n-                \/\/ must have 3 fields\n-                String[] s = line.split(\"\\\\s+\");\n-                if (s.length != 3) {\n-                    fail(\"Malformed line '%s'\", line);\n-                    continue;\n-                }\n-\n-                \/\/ first field is the action (\"bind\" or \"connect\")\n-                Action action = null;\n-                for (Action a: Action.values()) {\n-                    if (s[0].equalsIgnoreCase(a.name())) {\n-                        action = a;\n-                        break;\n-                    }\n-                }\n-                if (action == null) {\n-                    fail(\"Action '%s' not recognized\", s[0]);\n-                    continue;\n-                }\n-\n-                \/\/ * port[-end]\n-                int[] ports = parsePortRange(s[2]);\n-                if (ports.length == 0) {\n-                    fail(\"Malformed port range '%s'\", s[2]);\n-                    continue;\n-                }\n-\n-                \/\/ match all addresses\n-                if (s[1].equals(\"*\")) {\n-                    result.add(new PortRangeRule(action, ports[0], ports[1]));\n-                    continue;\n-                }\n-\n-                \/\/ hostname | ipaddress[\/prefix]\n-                int pos = s[1].indexOf('\/');\n-                try {\n-                    if (pos < 0) {\n-                        \/\/ hostname or ipaddress (no prefix)\n-                        InetAddress[] addresses = InetAddress.getAllByName(s[1]);\n-                        for (InetAddress address: addresses) {\n-                            int prefix =\n-                                (address instanceof Inet4Address) ? 32 : 128;\n-                            result.add(new AddressPortRangeRule(action, address,\n-                                prefix, ports[0], ports[1]));\n-                        }\n-                    } else {\n-                        \/\/ ipaddress\/prefix\n-                        InetAddress address = InetAddress\n-                            .getByName(s[1].substring(0, pos));\n-                        int prefix = -1;\n-                        try {\n-                            prefix = Integer.parseInt(s[1], pos + 1,\n-                                s[1].length(), 10);\n-                            if (address instanceof Inet4Address) {\n-                                \/\/ must be 1-31\n-                                if (prefix < 0 || prefix > 32) prefix = -1;\n-                            } else {\n-                                \/\/ must be 1-128\n-                                if (prefix < 0 || prefix > 128) prefix = -1;\n-                            }\n-                        } catch (NumberFormatException e) {\n-                        }\n-\n-                        if (prefix > 0) {\n-                            result.add(new AddressPortRangeRule(action,\n-                                        address, prefix, ports[0], ports[1]));\n-                        } else {\n-                            fail(\"Malformed prefix '%s'\", s[1]);\n-                            continue;\n-                        }\n-                    }\n-                } catch (UnknownHostException uhe) {\n-                    fail(\"Unknown host or malformed IP address '%s'\", s[1]);\n-                    continue;\n-                }\n-            }\n-            return result;\n-        }\n-    }\n-\n-    \/\/ converts unbound TCP socket to a SDP socket if it matches the rules\n-    private void convertTcpToSdpIfMatch(FileDescriptor fdObj,\n-                                               Action action,\n-                                               InetAddress address,\n-                                               int port)\n-        throws IOException\n-    {\n-        boolean matched = false;\n-        for (Rule rule: rules) {\n-            if (rule.match(action, address, port)) {\n-                SdpSupport.convertSocket(fdObj);\n-                matched = true;\n-                break;\n-            }\n-        }\n-        if (log != null) {\n-            String addr = (address instanceof Inet4Address) ?\n-                address.getHostAddress() : \"[\" + address.getHostAddress() + \"]\";\n-            if (matched) {\n-                log.format(\"%s to %s:%d (socket converted to SDP protocol)\\n\", action, addr, port);\n-            } else {\n-                log.format(\"%s to %s:%d (no match)\\n\", action, addr, port);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void implBeforeTcpBind(FileDescriptor fdObj,\n-                              InetAddress address,\n-                              int port)\n-        throws IOException\n-    {\n-        if (enabled)\n-            convertTcpToSdpIfMatch(fdObj, Action.BIND, address, port);\n-    }\n-\n-    @Override\n-    public void implBeforeTcpConnect(FileDescriptor fdObj,\n-                                InetAddress address,\n-                                int port)\n-        throws IOException\n-    {\n-        if (enabled)\n-            convertTcpToSdpIfMatch(fdObj, Action.CONNECT, address, port);\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/sdp\/SdpProvider.java","additions":0,"deletions":326,"binary":false,"changes":326,"status":"deleted"},{"patch":"@@ -38,1 +38,0 @@\n-import sun.net.NetHooks;\n@@ -313,1 +312,0 @@\n-        boolean notifyBeforeTcpConnect;\n@@ -321,1 +319,0 @@\n-            notifyBeforeTcpConnect = (localAddress == null);\n@@ -327,3 +324,0 @@\n-            \/\/ notify hook if unbound\n-            if (notifyBeforeTcpConnect)\n-                NetHooks.beforeTcpConnect(fd, isa.getAddress(), isa.getPort());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixAsynchronousSocketChannelImpl.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-#\n-# Configuration file to enable InfiniBand Sockets Direct Protocol.\n-#\n-# Each line that does not start with a comment (#) is a rule to indicate when\n-# the SDP transport protocol should be used. The format of a rule is as follows:\n-#   (\"bind\"|\"connect\") 1*LWSP-char (hostname|ipaddress[\"\/\"prefix]) 1*LWSP-char (\"*\"|port)[\"-\"(\"*\"|port)]\n-#\n-# A \"bind\" rule indicates that the SDP protocol transport should be used when\n-# a TCP socket binds to an address\/port that matches the rule. A \"connect\" rule\n-# indicates that the SDP protocol transport should be used when an unbound\n-# TCP socket attempts to connect to an address\/port that matches the rule.\n-# Addresses may be specified as hostnames or literal Internet Protocol (IP)\n-# addresses. When a literal IP address is used then a prefix length may be used\n-# to indicate the number of bits for matching (useful when a block of addresses\n-# or subnet is allocated to the InfiniBand fabric). \n-\n-# Use SDP for all sockets that bind to specific local addresses\n-#bind    192.168.1.1    *\n-#bind    fe80::21b:24ff:fe3d:7896    *\n-\n-# Use SDP for all sockets that bind to the wildcard address in a port range\n-#bind    0.0.0.0    5000-5999\n-#bind    ::0        5000-5999\n-\n-# Use SDP when connecting to all application services on 192.168.1.*\n-#connect 192.168.1.0\/24       1024-*\n-\n-# Use SDP when connecting to the http server or MySQL database on hpccluster.\n-#connect hpccluster.foo.com   80\n-#connect hpccluster.foo.com   3306\n","filename":"src\/java.base\/unix\/conf\/sdp\/sdp.conf.template","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <libgen.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#define JAVA_EXECUTABLE_NAME \"java\"\n+\n+#ifndef LAUNCHER_ARGS\n+#error LAUNCHER_ARGS must be defined\n+#endif\n+\n+static char *launcher_args[] = LAUNCHER_ARGS;\n+\n+int main(int argc, char *argv[]) {\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/ Create a fully qualified path to the java executable in the same\n+    \/\/ directory as this file resides in.\n+\n+    char *our_full_path = realpath(argv[0], NULL);\n+    if (our_full_path == NULL) {\n+        perror(\"failed to get the full path of the executable\");\n+        return 1;\n+    }\n+\n+    char *last_slash_pos = strrchr(our_full_path, '\/');\n+    if (last_slash_pos == NULL) {\n+        fprintf(stderr, \"no '\/' found in the full path of the executable\\n\");\n+        return 1;\n+    }\n+\n+    size_t base_length = last_slash_pos - our_full_path + 1;\n+    size_t java_path_length = base_length + strlen(JAVA_EXECUTABLE_NAME) + 1;\n+\n+    char *java_path = malloc(java_path_length);\n+    if (java_path == NULL) {\n+        perror(\"malloc failed\");\n+        return 1;\n+    }\n+\n+    memcpy(java_path, our_full_path, base_length);\n+    strcpy(java_path + base_length, JAVA_EXECUTABLE_NAME);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/ Build the argument list: our executable name + launcher args + users args\n+\n+    int launcher_argsc = sizeof(launcher_args) \/ sizeof(char *);\n+\n+    char **java_args = malloc((launcher_argsc + argc + 1) * sizeof(char *));\n+    if (java_args == NULL) {\n+        perror(\"malloc failed\");\n+        return 1;\n+    }\n+\n+    \/\/ Our executable name\n+    java_args[0] = argv[0];\n+\n+    \/\/ Launcher arguments\n+    for (int i = 0; i < launcher_argsc; i++) {\n+        java_args[i + 1] = launcher_args[i];\n+    }\n+\n+    \/\/ User arguments\n+    for (int i = 1; i < argc; i++) {\n+        java_args[launcher_argsc + i] = argv[i];\n+    }\n+\n+    java_args[launcher_argsc + argc] = NULL;\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/ Finally execute the real java process with the constructed arguments\n+\n+    if (getenv(\"_JAVA_LAUNCHER_DEBUG\")) {\n+        char *program_name = basename(argv[0]);\n+\n+        fprintf(stderr, \"%s: executing: '%s'\", program_name, java_path);\n+        for (int i = 0; java_args[i] != NULL; i++) {\n+            fprintf(stderr, \" '%s' \", java_args[i]);\n+        }\n+        fprintf(stderr, \"\\n\");\n+    }\n+\n+    execv(java_path, java_args);\n+\n+    \/\/ Should not reach here, unless something went wrong\n+    perror(\"execv failed\");\n+    return 1;\n+}\n","filename":"src\/java.base\/unix\/native\/launcher\/relauncher.c","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -279,0 +279,3 @@\n+    \/* Compute\/set the name of the executable *\/\n+    SetExecname(*pargv);\n+\n@@ -300,3 +303,0 @@\n-    \/* Compute\/set the name of the executable *\/\n-    SetExecname(*pargv);\n-\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <errno.h>\n-\n-#if defined(__linux__)\n-  #if !defined(AF_INET_SDP)\n-    #define AF_INET_SDP     27\n-  #endif\n-#endif\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"net_util.h\"\n-\n-\/**\n- * Creates a SDP socket.\n- *\/\n-static int create(JNIEnv* env)\n-{\n-    int s;\n-\n-#if defined(__linux__)\n-    \/**\n-     * IPv6 not supported by SDP on Linux\n-     *\/\n-    if (ipv6_available()) {\n-        JNU_ThrowIOException(env, \"IPv6 not supported\");\n-        return -1;\n-    }\n-    s = socket(AF_INET_SDP, SOCK_STREAM, 0);\n-#else\n-    \/* not supported on other platforms at this time *\/\n-    s = -1;\n-    errno = EPROTONOSUPPORT;\n-#endif\n-\n-    if (s < 0)\n-        JNU_ThrowIOExceptionWithLastError(env, \"socket\");\n-    return s;\n-}\n-\n-\/**\n- * Creates a SDP socket, returning file descriptor referencing the socket.\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_sun_net_sdp_SdpSupport_create0(JNIEnv *env, jclass cls)\n-{\n-    return create(env);\n-}\n-\n-\/**\n- * Converts an existing file descriptor, that references an unbound TCP socket,\n- * to SDP.\n- *\/\n-JNIEXPORT void JNICALL\n-Java_sun_net_sdp_SdpSupport_convert0(JNIEnv *env, jclass cls, int fd)\n-{\n-    int s = create(env);\n-    if (s >= 0) {\n-        socklen_t len;\n-        int arg, res;\n-        struct linger linger;\n-\n-        \/* copy socket options that are relevant to SDP *\/\n-        len = sizeof(arg);\n-        if (getsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&arg, len);\n-#ifdef SO_REUSEPORT\n-        len = sizeof(arg);\n-        if (getsockopt(fd, SOL_SOCKET, SO_REUSEPORT, (char*)&arg, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_REUSEPORT, (char*)&arg, len);\n-#endif\n-        len = sizeof(arg);\n-        if (getsockopt(fd, SOL_SOCKET, SO_OOBINLINE, (char*)&arg, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_OOBINLINE, (char*)&arg, len);\n-        len = sizeof(linger);\n-        if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (void*)&linger, &len) == 0)\n-            setsockopt(s, SOL_SOCKET, SO_LINGER, (char*)&linger, len);\n-\n-        RESTARTABLE(dup2(s, fd), res);\n-        if (res < 0)\n-            JNU_ThrowIOExceptionWithLastError(env, \"dup2\");\n-        res = close(s);\n-        if (res < 0 && !(*env)->ExceptionCheck(env))\n-            JNU_ThrowIOExceptionWithLastError(env, \"close\");\n-    }\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/SdpSupport.c","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.net.InetAddress;\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-\/**\n- * Defines static methods to ensure that any installed net hooks are invoked\n- * prior to binding or connecting TCP sockets.\n- *\/\n-\n-public final class NetHooks {\n-\n-    \/**\n-     * Invoke prior to binding a TCP socket.\n-     *\/\n-    public static void beforeTcpBind(FileDescriptor fdObj,\n-                                     InetAddress address,\n-                                     int port)\n-        throws IOException\n-    {\n-        \/\/ nothing to do\n-    }\n-\n-    \/**\n-     * Invoke prior to connecting an unbound TCP socket.\n-     *\/\n-    public static void beforeTcpConnect(FileDescriptor fdObj,\n-                                        InetAddress address,\n-                                        int port)\n-        throws IOException\n-    {\n-        \/\/ nothing to do\n-    }\n-}\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/NetHooks.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <shlwapi.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <windows.h>\n+\n+#define JAVA_EXECUTABLE_NAME \"java.exe\"\n+\n+#ifndef LAUNCHER_ARGS\n+#error LAUNCHER_ARGS must be defined\n+#endif\n+\n+static char* launcher_args[] = LAUNCHER_ARGS;\n+\n+char* quote_argument(char* arg) {\n+    \/\/ See https:\/\/learn.microsoft.com\/en-us\/archive\/blogs\/twistylittlepassagesallalike\/everyone-quotes-command-line-arguments-the-wrong-way\n+    \/\/ for an explanation of how to properly quote command lines for CreateProcess\n+    size_t arg_length = strlen(arg);\n+\n+    if (strcspn(arg, \" \\t\\n\\v\\\"\") == arg_length) {\n+        \/\/ No quoting is needed\n+        return arg;\n+    }\n+\n+    \/\/ Worst-case buffer size: all characters need a backslash, and starting + end quotes\n+    size_t buffer_size = arg_length * 2 + 3;\n+    char* buffer = malloc(buffer_size);\n+    if (buffer == NULL) {\n+        return NULL;\n+    }\n+\n+    int backslashes = 0;\n+    char* write_pos = buffer;\n+    char* read_pos = arg;\n+\n+    \/\/ Start with a quote character\n+    *write_pos++ = '\"';\n+\n+    while (*read_pos) {\n+        while (*read_pos == '\\\\') {\n+            read_pos++;\n+            backslashes++;\n+        }\n+\n+        if (*read_pos == '\"') {\n+            \/\/ Any potential backslashes before a quote needs to be doubled,\n+            \/\/ and the quote needs to be escaped with an additional backslash\n+            for (int i = 0; i < backslashes * 2 + 1; i++) {\n+                *write_pos++ = '\\\\';\n+            }\n+            *write_pos++ = *read_pos++;\n+            backslashes = 0;\n+        } else {\n+            \/\/ Backslashes not preceeding a quote are copied without escaping\n+            for (int i = 0; i < backslashes; i++) {\n+                *write_pos++ = '\\\\';\n+            }\n+            if (*read_pos) {\n+                *write_pos++ = *read_pos++;\n+                backslashes = 0;\n+            }\n+        }\n+    }\n+\n+    \/\/ If the string ended with backslashes, they need to be doubled before\n+    \/\/ the final quote character\n+    for (int i = 0; i < backslashes; i++) {\n+        *write_pos++ = '\\\\';\n+    }\n+    *write_pos++ = '\"';\n+    *write_pos = '\\0';\n+\n+    return buffer;\n+}\n+\n+int main(int argc, char* argv[]) {\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/ Create a fully qualified path to the java executable in the same\n+    \/\/ directory as this file resides in.\n+\n+    \/\/ Calculate path length first\n+    DWORD our_full_path_len = GetFullPathName(argv[0], 0, NULL, NULL);\n+    if (our_full_path_len == 0) {\n+        fprintf(stderr, \"failed to get the full path of the executable: %lu\\n\", GetLastError());\n+        return 1;\n+    }\n+\n+    char* our_full_path = malloc(our_full_path_len + 1);\n+    if (our_full_path == NULL) {\n+        perror(\"malloc failed\");\n+        return 1;\n+    }\n+\n+    if (GetFullPathName(argv[0], our_full_path_len + 1, our_full_path, NULL) == 0) {\n+        fprintf(stderr, \"failed to get the full path of the executable: %lu\\n\", GetLastError());\n+        return 1;\n+    }\n+\n+    char *last_slash_pos = strrchr(our_full_path, '\\\\');\n+    if (last_slash_pos == NULL) {\n+        fprintf(stderr, \"no '\\\\' found in the full path of the executable\\n\");\n+        return 1;\n+    }\n+\n+    size_t base_length = last_slash_pos - our_full_path + 1;\n+    size_t java_path_length = base_length + strlen(JAVA_EXECUTABLE_NAME) + 1;\n+\n+    char *java_path = malloc(java_path_length);\n+    if (java_path == NULL) {\n+        perror(\"malloc failed\");\n+        return 1;\n+    }\n+\n+    memcpy(java_path, our_full_path, base_length);\n+    strcpy(java_path + base_length, JAVA_EXECUTABLE_NAME);\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/ Build the argument list: our executable name + launcher args + users args\n+\n+    int launcher_argsc = sizeof(launcher_args) \/ sizeof(char *);\n+\n+    char **java_args = malloc((launcher_argsc + argc + 1) * sizeof(char *));\n+    if (java_args == NULL) {\n+        perror(\"malloc failed\");\n+        return 1;\n+    }\n+\n+    \/\/ Our executable name\n+    java_args[0] = quote_argument(argv[0]);\n+    if (java_args[0] == NULL) {\n+        perror(\"malloc failed\");\n+        return 1;\n+    }\n+\n+    \/\/ Launcher arguments\n+    for (int i = 0; i < launcher_argsc; i++) {\n+        char* quoted = quote_argument(launcher_args[i]);\n+        if (quoted == NULL) {\n+            perror(\"malloc failed\");\n+            return 1;\n+        }\n+        java_args[i + 1] = quoted;\n+    }\n+\n+    \/\/ User arguments\n+    for (int i = 1; i < argc; i++) {\n+        char* quoted = quote_argument(argv[i]);\n+        if (quoted == NULL) {\n+            perror(\"malloc failed\");\n+            return 1;\n+        }\n+        java_args[launcher_argsc + i] = quoted;\n+    }\n+\n+    java_args[launcher_argsc + argc] = NULL;\n+\n+    \/\/ Windows needs the command line as a single string, not as an array of char*\n+    size_t total_length = 0;\n+    for (int i = 0; java_args[i] != NULL; i++) {\n+        char* arg = java_args[i];\n+        total_length += strlen(java_args[i]) + 1;\n+    }\n+\n+    char* command_line = malloc(total_length);\n+    if (command_line == NULL) {\n+        perror(\"malloc failed\");\n+        return 1;\n+    }\n+\n+    \/\/ Concatenate the quoted arguments with a space between them\n+    char* write_pos = command_line;\n+    for (int i = 0; java_args[i] != NULL; i++) {\n+        size_t arg_len = strlen(java_args[i]);\n+        memcpy(write_pos, java_args[i], arg_len);\n+        write_pos += arg_len;\n+\n+        \/\/ Append a space\n+        *write_pos++ = ' ';\n+    }\n+\n+    \/\/ Replace the last space with a null terminator\n+    write_pos--;\n+    *write_pos = '\\0';\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/ Finally execute the real java process with the constructed arguments\n+\n+    if (GetEnvironmentVariable(\"_JAVA_LAUNCHER_DEBUG\", NULL, 0)) {\n+        char *program_name = PathFindFileName(argv[0]);\n+\n+        fprintf(stderr, \"%s: executing: '%s' '%s'\\n\", program_name, java_path, command_line);\n+    }\n+\n+    STARTUPINFO si;\n+    PROCESS_INFORMATION pi;\n+\n+    memset(&si, 0, sizeof(si));\n+    memset(&pi, 0, sizeof(pi));\n+\n+    \/\/ Windows has no equivalent of exec, so start the process and wait for it\n+    \/\/ to finish, to be able to return the same exit code\n+    if (!CreateProcess(java_path, command_line, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n+        fprintf(stderr, \"CreateProcess failed: %lu\\n\", GetLastError());\n+        return 1;\n+    }\n+\n+    if (WaitForSingleObject(pi.hProcess, INFINITE) == WAIT_FAILED) {\n+        fprintf(stderr, \"WaitForSingleObject failed: %lu\\n\", GetLastError());\n+        return 1;\n+    }\n+\n+    DWORD exit_code;\n+    if (!GetExitCodeProcess(pi.hProcess, &exit_code)) {\n+        fprintf(stderr, \"GetExitCodeProcess failed: %lu\\n\", GetLastError());\n+        return 1;\n+    }\n+    CloseHandle(pi.hProcess);\n+    CloseHandle(pi.hThread);\n+\n+    return exit_code;\n+}\n","filename":"src\/java.base\/windows\/native\/launcher\/relauncher.c","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -422,11 +422,0 @@\n-         * Windows 95                   4               0\n-         * Windows 98                   4               10\n-         * Windows ME                   4               90\n-         * Windows 3.51                 3               51\n-         * Windows NT 4.0               4               0\n-         * Windows 2000                 5               0\n-         * Windows XP 32 bit            5               1\n-         * Windows Server 2003 family   5               2\n-         * Windows XP 64 bit            5               2\n-         *       where ((&ver.wServicePackMinor) + 2) = 1\n-         *       and  si.wProcessorArchitecture = 9\n@@ -455,12 +444,0 @@\n-        case VER_PLATFORM_WIN32_WINDOWS:\n-           if (majorVersion == 4) {\n-                switch (minorVersion) {\n-                case  0: sprops.os_name = \"Windows 95\";           break;\n-                case 10: sprops.os_name = \"Windows 98\";           break;\n-                case 90: sprops.os_name = \"Windows Me\";           break;\n-                default: sprops.os_name = \"Windows 9X (unknown)\"; break;\n-                }\n-            } else {\n-                sprops.os_name = \"Windows 9X (unknown)\";\n-            }\n-            break;\n@@ -468,27 +445,1 @@\n-            if (majorVersion <= 4) {\n-                sprops.os_name = \"Windows NT\";\n-            } else if (majorVersion == 5) {\n-                switch (minorVersion) {\n-                case  0: sprops.os_name = \"Windows 2000\";         break;\n-                case  1: sprops.os_name = \"Windows XP\";           break;\n-                case  2:\n-                   \/*\n-                    * From MSDN OSVERSIONINFOEX and SYSTEM_INFO documentation:\n-                    *\n-                    * \"Because the version numbers for Windows Server 2003\n-                    * and Windows XP 6u4 bit are identical, you must also test\n-                    * whether the wProductType member is VER_NT_WORKSTATION.\n-                    * and si.wProcessorArchitecture is\n-                    * PROCESSOR_ARCHITECTURE_AMD64 (which is 9)\n-                    * If it is, the operating system is Windows XP 64 bit;\n-                    * otherwise, it is Windows Server 2003.\"\n-                    *\/\n-                    if (is_workstation && is_64bit) {\n-                        sprops.os_name = \"Windows XP\"; \/* 64 bit *\/\n-                    } else {\n-                        sprops.os_name = \"Windows 2003\";\n-                    }\n-                    break;\n-                default: sprops.os_name = \"Windows NT (unknown)\"; break;\n-                }\n-            } else if (majorVersion == 6) {\n+            if (majorVersion == 6) {\n@@ -500,2 +451,0 @@\n-                    case  0: sprops.os_name = \"Windows Vista\";        break;\n-                    case  1: sprops.os_name = \"Windows 7\";            break;\n@@ -508,2 +457,0 @@\n-                    case  0: sprops.os_name = \"Windows Server 2008\";    break;\n-                    case  1: sprops.os_name = \"Windows Server 2008 R2\"; break;\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":1,"deletions":54,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+    private static native void nativeInstallOpenURLEventHandler();\n@@ -214,0 +215,1 @@\n+        nativeInstallOpenURLEventHandler();\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eawt\/Application.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,1 +529,1 @@\n-    public BufferedImage copyArea(SunGraphics2D sg2d, int x, int y, int w, int h, BufferedImage dstImage) {\n+    public synchronized BufferedImage copyArea(SunGraphics2D sg2d, int x, int y, int w, int h, BufferedImage dstImage) {\n@@ -544,1 +544,1 @@\n-    public boolean xorSurfacePixels(SunGraphics2D sg2d, BufferedImage srcPixels, int x, int y, int w, int h, int colorXOR) {\n+    public synchronized boolean xorSurfacePixels(SunGraphics2D sg2d, BufferedImage srcPixels, int x, int y, int w, int h, int colorXOR) {\n@@ -556,1 +556,1 @@\n-    public void clearRect(BufferedImage bim, int w, int h) {\n+    public synchronized void clearRect(BufferedImage bim, int w, int h) {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/OSXOffScreenSurfaceData.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -200,5 +200,0 @@\n-    @Override\n-    public void invalidate() {\n-        \/\/ always valid\n-    }\n-\n@@ -991,1 +986,1 @@\n-    public void doLine(CRenderer renderer, SunGraphics2D sg2d, float x1, float y1, float x2, float y2) {\n+    public synchronized void doLine(CRenderer renderer, SunGraphics2D sg2d, float x1, float y1, float x2, float y2) {\n@@ -997,1 +992,1 @@\n-    public void doRect(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, boolean isfill) {\n+    public synchronized void doRect(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, boolean isfill) {\n@@ -1007,1 +1002,1 @@\n-    public void doRoundRect(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, float arcW, float arcH, boolean isfill) {\n+    public synchronized void doRoundRect(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, float arcW, float arcH, boolean isfill) {\n@@ -1017,1 +1012,1 @@\n-    public void doOval(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, boolean isfill) {\n+    public synchronized void doOval(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, boolean isfill) {\n@@ -1027,1 +1022,1 @@\n-    public void doArc(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, float startAngle, float arcAngle, int type, boolean isfill) {\n+    public synchronized void doArc(CRenderer renderer, SunGraphics2D sg2d, float x, float y, float width, float height, float startAngle, float arcAngle, int type, boolean isfill) {\n@@ -1038,1 +1033,1 @@\n-    public void doPolygon(CRenderer renderer, SunGraphics2D sg2d, int[] xpoints, int[] ypoints, int npoints, boolean ispolygon, boolean isfill) {\n+    public synchronized void doPolygon(CRenderer renderer, SunGraphics2D sg2d, int[] xpoints, int[] ypoints, int npoints, boolean ispolygon, boolean isfill) {\n@@ -1071,1 +1066,1 @@\n-    public void drawfillShape(CRenderer renderer, SunGraphics2D sg2d, GeneralPath gp, boolean isfill, boolean shouldApplyOffset) {\n+    public synchronized void drawfillShape(CRenderer renderer, SunGraphics2D sg2d, GeneralPath gp, boolean isfill, boolean shouldApplyOffset) {\n@@ -1096,1 +1091,1 @@\n-    public void blitImage(CRenderer renderer, SunGraphics2D sg2d, SurfaceData img, boolean fliph, boolean flipv, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh, Color bgColor) {\n+    public synchronized void blitImage(CRenderer renderer, SunGraphics2D sg2d, SurfaceData img, boolean fliph, boolean flipv, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh, Color bgColor) {\n@@ -1119,1 +1114,1 @@\n-    public void drawString(CTextPipe renderer, SunGraphics2D sg2d, long nativeStrikePtr, String str, double x, double y) {\n+    public synchronized void drawString(CTextPipe renderer, SunGraphics2D sg2d, long nativeStrikePtr, String str, double x, double y) {\n@@ -1128,1 +1123,1 @@\n-    public void drawGlyphs(CTextPipe renderer, SunGraphics2D sg2d, long nativeStrikePtr, GlyphVector gv, float x, float y) {\n+    public synchronized void drawGlyphs(CTextPipe renderer, SunGraphics2D sg2d, long nativeStrikePtr, GlyphVector gv, float x, float y) {\n@@ -1134,1 +1129,1 @@\n-    public void drawUnicodes(CTextPipe renderer, SunGraphics2D sg2d, long nativeStrikePtr, char[] unicodes, int offset, int length, float x, float y) {\n+    public synchronized void drawUnicodes(CTextPipe renderer, SunGraphics2D sg2d, long nativeStrikePtr, char[] unicodes, int offset, int length, float x, float y) {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/OSXSurfaceData.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-                Graphics2D delegate = new SunGraphics2D(sd, Color.black, Color.white, defaultFont);\n+                SunGraphics2D delegate = new SunGraphics2D(sd, Color.black, Color.white, defaultFont);\n@@ -833,2 +833,5 @@\n-                delegate.dispose();\n-                delegate = null;\n+                synchronized (sd) {\n+                    sd.invalidate();\n+                    delegate.dispose();\n+                    delegate = null;\n+                }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    BOOL fOpenURLHandlerInstalled;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ApplicationDelegate.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,0 +246,1 @@\n+    fOpenURLHandlerInstalled = NO;\n@@ -247,4 +248,1 @@\n-        [[NSAppleEventManager sharedAppleEventManager] setEventHandler:self\n-                                                           andSelector:@selector(_handleOpenURLEvent:withReplyEvent:)\n-                                                         forEventClass:kInternetEventClass\n-                                                            andEventID:kAEGetURL];\n+        [self _installOpenURLHandler];\n@@ -305,2 +303,11 @@\n-- (void)_handleOpenURLEvent:(NSAppleEventDescriptor *)openURLEvent withReplyEvent:(NSAppleEventDescriptor *)replyEvent {\n-    if (!fHandlesURLTypes) return;\n+- (void)_installOpenURLHandler {\n+AWT_ASSERT_APPKIT_THREAD;\n+    if (fOpenURLHandlerInstalled) return;\n+\n+    [[NSAppleEventManager sharedAppleEventManager] setEventHandler:self\n+                                                       andSelector:@selector(_handleOpenURLEvent:withReplyEvent:)\n+                                                     forEventClass:kInternetEventClass\n+                                                        andEventID:kAEGetURL];\n+\n+    fOpenURLHandlerInstalled = YES;\n+}\n@@ -308,0 +315,1 @@\n+- (void)_handleOpenURLEvent:(NSAppleEventDescriptor *)openURLEvent withReplyEvent:(NSAppleEventDescriptor *)replyEvent {\n@@ -629,0 +637,18 @@\n+\/*\n+ * Class:     com_apple_eawt_Application\n+ * Method:    nativeInstallOpenURLEventHandler\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_apple_eawt_Application_nativeInstallOpenURLEventHandler\n+(JNIEnv *env, jclass clz)\n+{\n+JNI_COCOA_ENTER(env);\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n+        ApplicationDelegate *delegate = [ApplicationDelegate sharedDelegate];\n+            if (delegate != nil) {\n+                [delegate _installOpenURLHandler];\n+            }\n+    }];\n+JNI_COCOA_EXIT(env);\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ApplicationDelegate.m","additions":33,"deletions":7,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+     * If {@code PrintJob.end()} has been called, this method will\n+     * return {@code null}.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/PrintJob.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1444,0 +1444,3 @@\n+     * Any bit set in the {@code ranges} bitmask which is not a\n+     * recognised value is discarded. Similarly if two bits are\n+     * specified where one takes precedence, the lesser one is discarded.\n@@ -1463,0 +1466,3 @@\n+     * If two ranges are specified where one takes precedence over the\n+     * other the lesser range is discarded.\n+     *\n@@ -1502,0 +1508,3 @@\n+     * If two ranges are specified where one takes precedence over the\n+     * other the lesser range is discarded.\n+     *\n@@ -1525,1 +1534,1 @@\n-        this.mask = mask;\n+        this.mask = mask & (CONTEXTUAL_MASK | ALL_RANGES);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/NumericShaper.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -811,1 +811,1 @@\n-                    color = srcCM.getNormalizedComponents(pixel, color, 0);\n+                    color = srcCM.getNormalizedComponents(pixel, null, 0);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorConvertOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-                dataOffsets[i] += xOffset*pixelStride+yOffset*scanlineStride;\n+                dataOffsets[i] += dataBuffer.getOffset() + xOffset*pixelStride+yOffset*scanlineStride;\n@@ -230,1 +230,1 @@\n-        this.dbOffsetPacked = dataBuffer.getOffset() -\n+        this.dbOffsetPacked = -\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ByteInterleavedRaster.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+    private boolean isSavedModelReliable = true;\n@@ -399,1 +400,1 @@\n-            if (saved_image != null && model.equals(saved_model)) {\n+            if (saved_image != null && model.equals(saved_model) && isSavedModelReliable) {\n@@ -409,0 +410,2 @@\n+                isSavedModelReliable = false;\n+\n@@ -600,0 +603,1 @@\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/GifImageDecoder.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-         * If so add it as the final fallback component of the composite.\n+         * If so add it as the first fallback component of the composite.\n@@ -117,2 +117,2 @@\n-                for (int i=0; i<numSlots-1; i++) {\n-                    deferredInitialisation[i] = true;\n+                for (int i = 0; i < numSlots; i++) {\n+                    deferredInitialisation[i] = (i != msCnt);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeFont.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -320,25 +320,2 @@\n-            File f;\n-            if ((f = new File(\"\/etc\/lsb-release\")).canRead()) {\n-                    \/* Ubuntu and (perhaps others) use only lsb-release.\n-                     * Syntax and encoding is compatible with java properties.\n-                     * For Ubuntu the ID is \"Ubuntu\".\n-                     *\/\n-                    Properties props = new Properties();\n-                    try (FileInputStream fis = new FileInputStream(f)) {\n-                        props.load(fis);\n-                    }\n-                    osName = extractInfo(props.getProperty(\"DISTRIB_ID\"));\n-                    osVersion = extractInfo(props.getProperty(\"DISTRIB_RELEASE\"));\n-            } else if ((f = new File(\"\/etc\/redhat-release\")).canRead()) {\n-                osName = \"RedHat\";\n-                osVersion = getVersionString(f);\n-            } else if ((f = new File(\"\/etc\/SuSE-release\")).canRead()) {\n-                osName = \"SuSE\";\n-                osVersion = getVersionString(f);\n-            } else if ((f = new File(\"\/etc\/turbolinux-release\")).canRead()) {\n-                osName = \"Turbo\";\n-                osVersion = getVersionString(f);\n-            } else if ((f = new File(\"\/etc\/fedora-release\")).canRead()) {\n-                osName = \"Fedora\";\n-                osVersion = getVersionString(f);\n-            } else if ((f = new File(\"\/etc\/os-release\")).canRead()) {\n+            File f = new File(\"\/etc\/os-release\");\n+            if (f.canRead()) {\n@@ -349,1 +326,1 @@\n-                osName = extractInfo(props.getProperty(\"NAME\"));\n+                osName = extractInfo(props.getProperty(\"ID\"));\n@@ -351,5 +328,0 @@\n-                if (osName.equals(\"SLES\")) {\n-                    osName = \"SuSE\";\n-                } else {\n-                    osName = extractInfo(props.getProperty(\"ID\"));\n-                }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/FcFontConfiguration.java","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -94,18 +94,2 @@\n-                File f;\n-                if ((f = new File(\"\/etc\/fedora-release\")).canRead()) {\n-                    osName = \"Fedora\";\n-                    osVersion = getVersionString(f);\n-                } else if ((f = new File(\"\/etc\/redhat-release\")).canRead()) {\n-                    osName = \"RedHat\";\n-                    osVersion = getVersionString(f);\n-                } else if ((f = new File(\"\/etc\/turbolinux-release\")).canRead()) {\n-                    osName = \"Turbo\";\n-                    osVersion = getVersionString(f);\n-                } else if ((f = new File(\"\/etc\/SuSE-release\")).canRead()) {\n-                    osName = \"SuSE\";\n-                    osVersion = getVersionString(f);\n-                } else if ((f = new File(\"\/etc\/lsb-release\")).canRead()) {\n-                    \/* Ubuntu and (perhaps others) use only lsb-release.\n-                     * Syntax and encoding is compatible with java properties.\n-                     * For Ubuntu the ID is \"Ubuntu\".\n-                     *\/\n+                File f = new File(\"\/etc\/os-release\");\n+                if (f.canRead()) {\n@@ -116,8 +100,1 @@\n-                    osName = extractInfo(props.getProperty(\"DISTRIB_ID\"));\n-                    osVersion = extractInfo(props.getProperty(\"DISTRIB_RELEASE\"));\n-                } else if ((f = new File(\"\/etc\/os-release\")).canRead()) {\n-                    Properties props = new Properties();\n-                    try (FileInputStream fis = new FileInputStream(f)) {\n-                        props.load(fis);\n-                    }\n-                    osName = extractInfo(props.getProperty(\"NAME\"));\n+                    osName = extractInfo(props.getProperty(\"ID\"));\n@@ -125,5 +102,0 @@\n-                    if (osName.equals(\"SLES\")) {\n-                        osName = \"SuSE\";\n-                    } else {\n-                        osName = extractInfo(props.getProperty(\"ID\"));\n-                    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/MFontConfiguration.java","additions":3,"deletions":31,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1041,1 +1041,1 @@\n-        minGlyphs = 20;\n+        minGlyphs = 0;\n@@ -1089,8 +1089,0 @@\n-            \/* We don't want 20 or 30 fonts, so once we hit 10 fonts,\n-             * then require that they really be adding value. Too many\n-             * adversely affects load time for minimal value-add.\n-             * This is still likely far more than we've had in the past.\n-             *\/\n-            if (j==10) {\n-                minGlyphs = 50;\n-            }\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -917,2 +917,9 @@\n-                    icon.paintIcon(c, g, x + VistaMenuItemCheckIconFactory.getIconWidth(),\n-                                   y + OFFSET);\n+                    if (WindowsGraphicsUtils.isLeftToRight(c)) {\n+                        icon.paintIcon(c, g,\n+                                       x + VistaMenuItemCheckIconFactory.getIconWidth(),\n+                                       y + OFFSET);\n+                    } else {\n+                        icon.paintIcon(c, g,\n+                                       x - VistaMenuItemCheckIconFactory.getIconWidth() + 2 * OFFSET,\n+                                       y + OFFSET);\n+                    }\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsIconFactory.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import javax.swing.SwingConstants;\n@@ -204,2 +205,11 @@\n-\n-            rect.x += lh.getAfterCheckIconGap();\n+            if (menuItem.getComponentOrientation().isLeftToRight()) {\n+                if (menuItem.getHorizontalTextPosition() != SwingConstants.LEADING\n+                    && menuItem.getHorizontalTextPosition() != SwingConstants.LEFT) {\n+                    rect.x += lh.getAfterCheckIconGap();\n+                }\n+            } else {\n+                if (menuItem.getHorizontalTextPosition() != SwingConstants.LEADING\n+                    && menuItem.getHorizontalTextPosition() != SwingConstants.RIGHT) {\n+                    rect.x -= lh.getAfterCheckIconGap();\n+                }\n+            }\n@@ -221,1 +231,5 @@\n-            rect.x += lh.getAfterCheckIconGap();\n+            if (menuItem.getComponentOrientation().isLeftToRight()) {\n+                rect.x += lh.getAfterCheckIconGap();\n+            } else {\n+                rect.x -= lh.getAfterCheckIconGap();\n+            }\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -932,1 +932,1 @@\n-    private long getPrintDC() {\n+    private synchronized long getPrintDC() {\n@@ -936,1 +936,1 @@\n-    private void setPrintDC(long mPrintDC) {\n+    private synchronized void setPrintDC(long mPrintDC) {\n@@ -940,1 +940,1 @@\n-    private long getDevMode() {\n+    private synchronized long getDevMode() {\n@@ -944,1 +944,1 @@\n-    private void setDevMode(long mPrintHDevMode) {\n+    private synchronized void setDevMode(long mPrintHDevMode) {\n@@ -948,1 +948,1 @@\n-    private long getDevNames() {\n+    private synchronized long getDevNames() {\n@@ -952,1 +952,1 @@\n-    private void setDevNames(long mPrintHDevNames) {\n+    private synchronized void setDevNames(long mPrintHDevNames) {\n@@ -956,1 +956,1 @@\n-    protected void beginPath() {\n+    protected synchronized void beginPath() {\n@@ -960,1 +960,1 @@\n-    protected void endPath() {\n+    protected synchronized void endPath() {\n@@ -975,1 +975,1 @@\n-    protected void closeFigure() {\n+    protected synchronized void closeFigure() {\n@@ -979,1 +979,1 @@\n-    protected void fillPath() {\n+    protected synchronized void fillPath() {\n@@ -983,1 +983,1 @@\n-    protected void moveTo(float x, float y) {\n+    protected synchronized void moveTo(float x, float y) {\n@@ -987,1 +987,1 @@\n-    protected void lineTo(float x, float y) {\n+    protected synchronized void lineTo(float x, float y) {\n@@ -991,1 +991,1 @@\n-    protected void polyBezierTo(float control1x, float control1y,\n+    protected synchronized void polyBezierTo(float control1x, float control1y,\n@@ -1006,1 +1006,1 @@\n-    protected void setPolyFillMode(int fillRule) {\n+    protected synchronized void setPolyFillMode(int fillRule) {\n@@ -1013,1 +1013,1 @@\n-    private int setAdvancedGraphicsMode() {\n+    private synchronized int setAdvancedGraphicsMode() {\n@@ -1023,1 +1023,1 @@\n-    private void setGraphicsMode(int mode) {\n+    private synchronized void setGraphicsMode(int mode) {\n@@ -1030,1 +1030,1 @@\n-    private void scale(double scaleX, double scaleY) {\n+    private synchronized void scale(double scaleX, double scaleY) {\n@@ -1037,1 +1037,1 @@\n-    private void getWorldTransform(double[] transform) {\n+    private synchronized void getWorldTransform(double[] transform) {\n@@ -1044,1 +1044,1 @@\n-    private void setWorldTransform(double[] transform) {\n+    private synchronized void setWorldTransform(double[] transform) {\n@@ -1054,1 +1054,1 @@\n-    protected void selectSolidBrush(Color color) {\n+    protected synchronized void selectSolidBrush(Color color) {\n@@ -1073,1 +1073,1 @@\n-    protected int getPenX() {\n+    protected synchronized int getPenX() {\n@@ -1083,1 +1083,1 @@\n-    protected int getPenY() {\n+    protected synchronized int getPenY() {\n@@ -1092,1 +1092,1 @@\n-    protected void selectClipPath() {\n+    protected synchronized void selectClipPath() {\n@@ -1097,1 +1097,1 @@\n-    protected void frameRect(float x, float y, float width, float height) {\n+    protected synchronized void frameRect(float x, float y, float width, float height) {\n@@ -1101,1 +1101,1 @@\n-    protected void fillRect(float x, float y, float width, float height,\n+    protected synchronized void fillRect(float x, float y, float width, float height,\n@@ -1112,1 +1112,1 @@\n-    protected void selectPen(float width, Color color) {\n+    protected synchronized void selectPen(float width, Color color) {\n@@ -1123,1 +1123,1 @@\n-    protected boolean selectStylePen(int cap, int join, float width,\n+    protected synchronized boolean selectStylePen(int cap, int join, float width,\n@@ -1155,1 +1155,1 @@\n-    protected boolean setFont(String family, float size, int style,\n+    protected synchronized boolean setFont(String family, float size, int style,\n@@ -1190,1 +1190,1 @@\n-    protected void setTextColor(Color color) {\n+    protected synchronized void setTextColor(Color color) {\n@@ -1209,1 +1209,1 @@\n-    protected void textOut(String str, float x, float y,\n+    protected synchronized void textOut(String str, float x, float y,\n@@ -1229,1 +1229,1 @@\n-    protected void glyphsOut(int []glyphs, float x, float y,\n+    protected synchronized void glyphsOut(int []glyphs, float x, float y,\n@@ -1257,1 +1257,1 @@\n-    protected int getGDIAdvance(String text) {\n+    protected synchronized int getGDIAdvance(String text) {\n@@ -1278,1 +1278,1 @@\n-    protected void drawImage3ByteBGR(byte[] image,\n+    protected synchronized void drawImage3ByteBGR(byte[] image,\n@@ -1309,1 +1309,1 @@\n-    protected void drawDIBImage(byte[] image,\n+    protected synchronized void drawDIBImage(byte[] image,\n@@ -1341,1 +1341,1 @@\n-    protected void startPage(PageFormat format, Printable painter,\n+    protected synchronized void startPage(PageFormat format, Printable painter,\n@@ -1358,1 +1358,1 @@\n-    protected void endPage(PageFormat format, Printable painter,\n+    protected synchronized void endPage(PageFormat format, Printable painter,\n@@ -1405,1 +1405,1 @@\n-    protected native void initPrinter();\n+    protected synchronized native void initPrinter();\n@@ -1418,1 +1418,1 @@\n-    private native boolean _startDoc(String dest, String jobName)\n+    private synchronized native boolean _startDoc(String dest, String jobName)\n@@ -1421,1 +1421,1 @@\n-    protected void startDoc() throws PrinterException {\n+    protected synchronized void startDoc() throws PrinterException {\n@@ -1432,1 +1432,1 @@\n-    protected native void endDoc();\n+    protected synchronized native void endDoc();\n@@ -1439,1 +1439,1 @@\n-    protected native void abortDoc();\n+    protected synchronized native void abortDoc();\n@@ -1444,1 +1444,1 @@\n-    private static native void deleteDC(long dc, long devmode, long devnames);\n+    private static synchronized native void deleteDC(long dc, long devmode, long devnames);\n@@ -1450,1 +1450,1 @@\n-    protected native void deviceStartPage(PageFormat format, Printable painter,\n+    protected synchronized native void deviceStartPage(PageFormat format, Printable painter,\n@@ -1456,1 +1456,1 @@\n-    protected native void deviceEndPage(PageFormat format, Printable painter,\n+    protected synchronized native void deviceEndPage(PageFormat format, Printable painter,\n@@ -1467,1 +1467,1 @@\n-    protected native void printBand(byte[] data, int x, int y,\n+    protected synchronized native void printBand(byte[] data, int x, int y,\n@@ -1474,1 +1474,1 @@\n-    protected native void beginPath(long printDC);\n+    protected synchronized native void beginPath(long printDC);\n@@ -1480,1 +1480,1 @@\n-    protected native void endPath(long printDC);\n+    protected synchronized native void endPath(long printDC);\n@@ -1486,1 +1486,1 @@\n-    protected native void closeFigure(long printDC);\n+    protected synchronized native void closeFigure(long printDC);\n@@ -1492,1 +1492,1 @@\n-    protected native void fillPath(long printDC);\n+    protected synchronized native void fillPath(long printDC);\n@@ -1498,1 +1498,1 @@\n-    protected native void moveTo(long printDC, float x, float y);\n+    protected synchronized native void moveTo(long printDC, float x, float y);\n@@ -1504,1 +1504,1 @@\n-    protected native void lineTo(long printDC, float x, float y);\n+    protected synchronized native void lineTo(long printDC, float x, float y);\n@@ -1506,1 +1506,1 @@\n-    protected native void polyBezierTo(long printDC,\n+    protected synchronized native void polyBezierTo(long printDC,\n@@ -1517,1 +1517,1 @@\n-    protected native void setPolyFillMode(long printDC, int fillRule);\n+    protected synchronized native void setPolyFillMode(long printDC, int fillRule);\n@@ -1523,1 +1523,1 @@\n-    protected native int setAdvancedGraphicsMode(long printDC);\n+    protected synchronized native int setAdvancedGraphicsMode(long printDC);\n@@ -1532,1 +1532,1 @@\n-    protected native void setGraphicsMode(long printDC, int mode);\n+    protected synchronized native void setGraphicsMode(long printDC, int mode);\n@@ -1538,1 +1538,1 @@\n-    protected native void scale(long printDC, double scaleX, double scaleY);\n+    protected synchronized native void scale(long printDC, double scaleX, double scaleY);\n@@ -1544,1 +1544,1 @@\n-    protected native void getWorldTransform(long printDC, double[] transform);\n+    protected synchronized native void getWorldTransform(long printDC, double[] transform);\n@@ -1550,1 +1550,1 @@\n-    protected native void setWorldTransform(long printDC, double[] transform);\n+    protected synchronized native void setWorldTransform(long printDC, double[] transform);\n@@ -1558,1 +1558,1 @@\n-    protected native void selectSolidBrush(long printDC,\n+    protected synchronized native void selectSolidBrush(long printDC,\n@@ -1566,1 +1566,1 @@\n-    protected native int getPenX(long printDC);\n+    protected synchronized native int getPenX(long printDC);\n@@ -1573,1 +1573,1 @@\n-    protected native int getPenY(long printDC);\n+    protected synchronized native int getPenY(long printDC);\n@@ -1579,1 +1579,1 @@\n-    protected native void selectClipPath(long printDC);\n+    protected synchronized native void selectClipPath(long printDC);\n@@ -1584,1 +1584,1 @@\n-    protected native void frameRect(long printDC, float x, float y,\n+    protected synchronized native void frameRect(long printDC, float x, float y,\n@@ -1591,1 +1591,1 @@\n-    protected native void fillRect(long printDC, float x, float y,\n+    protected synchronized native void fillRect(long printDC, float x, float y,\n@@ -1599,1 +1599,1 @@\n-    protected native void selectPen(long printDC, float width,\n+    protected synchronized native void selectPen(long printDC, float width,\n@@ -1606,1 +1606,1 @@\n-    protected native boolean selectStylePen(long printDC, long cap,\n+    protected synchronized native boolean selectStylePen(long printDC, long cap,\n@@ -1614,1 +1614,1 @@\n-    protected native boolean setFont(long printDC, String familyName,\n+    protected synchronized native boolean setFont(long printDC, String familyName,\n@@ -1625,1 +1625,1 @@\n-    protected native void setTextColor(long printDC,\n+    protected synchronized native void setTextColor(long printDC,\n@@ -1634,1 +1634,1 @@\n-    protected native void textOut(long printDC, String text,\n+    protected synchronized native void textOut(long printDC, String text,\n@@ -1639,1 +1639,1 @@\n-    private native int getGDIAdvance(long printDC, String text);\n+    private synchronized native int getGDIAdvance(long printDC, String text);\n@@ -1656,1 +1656,1 @@\n-    private native void drawDIBImage(long printDC, byte[] image,\n+    private synchronized native void drawDIBImage(long printDC, byte[] image,\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":71,"deletions":71,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -1526,0 +1526,1 @@\n+        AwtPrintControl::setPrintDC(env, self, (HDC)NULL);\n@@ -1586,1 +1587,3 @@\n-    DeletePrintDC((HDC)dc);\n+    if ((HDC)dc != NULL) {\n+        DeletePrintDC((HDC)dc);\n+    }\n@@ -1853,0 +1856,3 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n@@ -1865,0 +1871,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1879,0 +1889,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1893,0 +1907,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1907,0 +1925,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1921,0 +1943,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1936,0 +1962,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1954,0 +1984,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1977,0 +2011,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -1991,0 +2029,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return 0;\n+    }\n+\n@@ -2007,0 +2049,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2022,0 +2068,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2046,0 +2096,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2073,0 +2127,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2103,0 +2161,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2120,0 +2182,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return 0;\n+    }\n+\n@@ -2138,0 +2204,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return 0;\n+    }\n+\n@@ -2156,0 +2226,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2173,0 +2247,4 @@\n+  if ((HDC)printDC == NULL) {\n+      return;\n+  }\n+\n@@ -2203,0 +2281,4 @@\n+  if ((HDC)printDC == NULL) {\n+      return;\n+  }\n+\n@@ -2231,0 +2313,4 @@\n+  if ((HDC)printDC == NULL) {\n+       return;\n+  }\n+\n@@ -2257,0 +2343,4 @@\n+  if ((HDC)printDC == NULL) {\n+      return JNI_FALSE;\n+  }\n+\n@@ -2290,0 +2380,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return JNI_FALSE;\n+    }\n+\n@@ -2320,0 +2414,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return JNI_FALSE;\n+    }\n+\n@@ -2481,0 +2579,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2488,0 +2590,5 @@\n+\n+    if ((HDC)printDC == NULL) {\n+        return 0;\n+    }\n+\n@@ -2541,0 +2648,3 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n@@ -2835,0 +2945,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n@@ -2925,0 +3039,4 @@\n+    if ((HDC)printDC == NULL) {\n+         return;\n+    }\n+\n@@ -2969,0 +3087,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return result;\n+    }\n+\n@@ -3710,0 +3832,4 @@\n+    if ((HDC)printDC == NULL) {\n+        return;\n+    }\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":127,"deletions":1,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+ *\n+ *   HttpRequest request = HttpRequest.newBuilder()\n+ *       .uri(URI.create(\"https:\/\/foo.com\/\"))\n+ *       .build();\n@@ -111,1 +115,1 @@\n- *    HttpRequest request = HttpRequest.newBuilder()\n+ *   HttpRequest request = HttpRequest.newBuilder()\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -502,1 +502,0 @@\n-            Optional<Duration> timeout = client().connectTimeout();\n@@ -507,1 +506,2 @@\n-            if (timeout.isPresent()) {\n+            Duration timeout = client().connectTimeout().orElse(null);\n+            if (timeout != null) {\n@@ -509,1 +509,7 @@\n-                debug.log(\"setting up quic connect timeout: \" + timeout.get().toMillis());\n+                debug.log(\"setting up quic connect timeout: \" + timeout);\n+                long timeoutMillis;\n+                try {\n+                    timeoutMillis = timeout.toMillis();\n+                } catch (ArithmeticException _) {\n+                    timeoutMillis = Long.MAX_VALUE;\n+                }\n@@ -512,1 +518,1 @@\n-                        timeout.get().toMillis(), TimeUnit.MILLISECONDS);\n+                        timeoutMillis, TimeUnit.MILLISECONDS);\n@@ -517,1 +523,1 @@\n-            if (timeout.isPresent() || directTimeout.isPresent()) {\n+            if (timeout != null || directTimeout.isPresent()) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpQuicConnection.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,0 @@\n-import java.time.temporal.Temporal;\n-import java.time.temporal.TemporalAccessor;\n-import java.time.temporal.TemporalAmount;\n@@ -38,1 +35,12 @@\n- * A Deadline represents an instant on a {@linkplain TimeLine time line}.\n+ * An instantaneous point on the {@linkplain TimeLine time-line}.\n+ * <p>\n+ * This class is immutable and thread-safe.\n+ * <p id=\"overflow\">\n+ * Operations that add or subtract durations to a {@code Deadline}, whether\n+ * represented as a {@link Duration} or as a {@code long} time increment (such\n+ * as seconds or nanoseconds) do not throw on numeric overflow if the resulting\n+ * {@code Deadline} would exceed {@link #MAX} or be less than {@link #MIN}.\n+ * Instead, {@code MAX} or {@code MIN} is returned, respectively. Similarly,\n+ * methods that return a duration as a {@code long} will either return\n+ * {@link Long#MAX_VALUE} or {@link Long#MIN_VALUE} if the returned quantity\n+ * would exceed the capacity of a {@code long}.\n@@ -52,1 +60,1 @@\n-     * Returns a copy of this deadline with the specified duration in nanoseconds added.\n+     * {@return a deadline with the specified duration in nanoseconds added}\n@@ -55,0 +63,4 @@\n+     * <p>\n+     * On {@linkplain ##overflow numeric overflows}, this method will return\n+     * {@link Deadline#MAX} if the provided duration is positive,\n+     * {@link Deadline#MIN} otherwise.\n@@ -57,3 +69,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified nanoseconds added, not null\n-     * @throws DateTimeException if the result exceeds the maximum or minimum deadline\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -62,1 +71,7 @@\n-        return new Deadline(deadline.plusNanos(nanosToAdd));\n+        if (nanosToAdd == 0) return this;\n+        try {\n+            return new Deadline(deadline.plusNanos(nanosToAdd));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return nanosToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -92,5 +107,1 @@\n-     * Returns a copy of this deadline with the specified amount subtracted.\n-     * <p>\n-     * This returns a {@code Deadline}, based on this one, with the specified amount subtracted.\n-     * The amount is typically {@link Duration} but may be any other type implementing\n-     * the {@link TemporalAmount} interface.\n+     * {@return a deadline with the specified amount subtracted from this deadline}\n@@ -99,0 +110,4 @@\n+     * <p>\n+     * On {@linkplain ##overflow numeric overflows}, this method will return\n+     * {@link Deadline#MIN} if the provided duration is positive,\n+     * {@link Deadline#MAX} otherwise.\n@@ -100,4 +115,1 @@\n-     * @param amountToSubtract  the amount to subtract, not null\n-     * @return a {@code Deadline} based on this deadline with the subtraction made, not null\n-     * @throws DateTimeException if the subtraction cannot be made\n-     * @throws ArithmeticException if numeric overflow occurs\n+     * @param duration the amount to subtract, not null\n@@ -105,2 +117,8 @@\n-    public Deadline minus(TemporalAmount amountToSubtract) {\n-        return Deadline.of(deadline.minus(amountToSubtract));\n+    public Deadline minus(Duration duration) {\n+        if (duration.isZero()) return this;\n+        try {\n+            return Deadline.of(deadline.minus(duration));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return duration.isPositive() ? Deadline.MIN : Deadline.MAX;\n+        }\n@@ -110,1 +128,1 @@\n-     * Returns a copy of this deadline with the specified amount added.\n+     * {@return a deadline with the specified amount added to this deadline}\n@@ -117,0 +135,4 @@\n+     * <p>\n+     * On {@linkplain ##overflow numeric overflows}, this method will return\n+     * {@link Deadline#MAX} if the provided amount is positive,\n+     * {@link Deadline#MIN} otherwise.\n@@ -122,2 +144,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified amount added, not null\n-     * @throws DateTimeException if the addition cannot be made\n@@ -125,1 +145,0 @@\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -129,1 +148,6 @@\n-        return Deadline.of(deadline.plus(amountToAdd, unit));\n+        try {\n+            return Deadline.of(deadline.plus(amountToAdd, unit));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return amountToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -133,1 +157,1 @@\n-     * Returns a copy of this deadline with the specified duration in seconds added.\n+     * {@return a deadline with the specified duration in seconds added to this deadline}\n@@ -136,0 +160,4 @@\n+     * <p>\n+     * On {@linkplain ##overflow numeric overflows}, this method will return\n+     * {@link Deadline#MAX} if the provided duration is positive,\n+     * {@link Deadline#MIN} otherwise.\n@@ -138,3 +166,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified seconds added, not null\n-     * @throws DateTimeException if the result exceeds the maximum or minimum deadline\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -144,1 +169,6 @@\n-        return Deadline.of(deadline.plusSeconds(secondsToAdd));\n+        try {\n+            return Deadline.of(deadline.plusSeconds(secondsToAdd));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return secondsToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -148,1 +178,1 @@\n-     * Returns a copy of this deadline with the specified duration in milliseconds added.\n+     * {@return a deadline with the specified duration in milliseconds added to this deadline}\n@@ -151,0 +181,4 @@\n+     * <p>\n+     * On {@linkplain ##overflow numeric overflows}, this method will return\n+     * {@link Deadline#MAX} if the provided duration is positive,\n+     * {@link Deadline#MIN} otherwise.\n@@ -153,3 +187,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified milliseconds added, not null\n-     * @throws DateTimeException if the result exceeds the maximum or minimum deadline\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -159,1 +190,6 @@\n-        return Deadline.of(deadline.plusMillis(millisToAdd));\n+        try {\n+            return Deadline.of(deadline.plusMillis(millisToAdd));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return millisToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -163,5 +199,1 @@\n-     * Returns a copy of this deadline with the specified amount added.\n-     * <p>\n-     * This returns a {@code Deadline}, based on this one, with the specified amount added.\n-     * The amount is typically {@link Duration} but may be any other type implementing\n-     * the {@link TemporalAmount} interface.\n+     * {@return a deadline with the specified duration added to this deadline}\n@@ -170,0 +202,4 @@\n+     * <p>\n+     * On {@linkplain ##overflow numeric overflows}, this method will return\n+     * {@link Deadline#MAX} if the provided duration is positive,\n+     * {@link Deadline#MIN} otherwise.\n@@ -171,4 +207,1 @@\n-     * @param amountToAdd  the amount to add, not null\n-     * @return a {@code Deadline} based on this deadline with the addition made, not null\n-     * @throws DateTimeException if the addition cannot be made\n-     * @throws ArithmeticException if numeric overflow occurs\n+     * @param duration the duration to add, not null\n@@ -176,2 +209,8 @@\n-    public Deadline plus(TemporalAmount amountToAdd) {\n-        return Deadline.of(deadline.plus(amountToAdd));\n+    public Deadline plus(Duration duration) {\n+        if (duration.isZero()) return this;\n+        try {\n+            return Deadline.of(deadline.plus(duration));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return duration.isPositive() ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -191,0 +230,4 @@\n+     * <p>\n+     * On {@linkplain ##overflow numeric overflows}, this method will return\n+     * {@link Long#MAX_VALUE} if the current deadline is before the provided end\n+     * deadline, {@link Long#MIN_VALUE} otherwise.\n@@ -195,1 +238,0 @@\n-     * @throws DateTimeException if the amount cannot be calculated\n@@ -197,1 +239,0 @@\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -200,1 +241,7 @@\n-        return deadline.until(endExclusive.deadline, unit);\n+        try {\n+            return deadline.until(endExclusive.deadline, unit);\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            int delta = compareTo(endExclusive);\n+            return delta < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n@@ -269,2 +316,0 @@\n-     * @throws DateTimeException if the seconds between the deadline cannot be obtained\n-     * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}\n@@ -273,0 +318,4 @@\n+        if (startInclusive.equals(endExclusive)) return Duration.ZERO;\n+        \/\/ `Deadline` works with `Instant` under the hood.\n+        \/\/ Delta between `Instant.MIN` and `Instant.MAX` fits in a `Duration`.\n+        \/\/ Hence, we should never receive a numeric overflow while calculating the delta between two deadlines.\n@@ -275,0 +324,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Deadline.java","additions":102,"deletions":52,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -1355,1 +1355,1 @@\n-        TypeRelation isSameTypeVisitor = new TypeRelation() {\n+        abstract class TypeEqualityVisitor extends TypeRelation {\n@@ -1394,1 +1394,1 @@\n-                            isSameType(t.type, t2.type);\n+                            sameTypeComparator(t.type, t2.type);\n@@ -1398,0 +1398,2 @@\n+            abstract boolean sameTypeComparator(Type t, Type s);\n+\n@@ -1428,1 +1430,1 @@\n-                    && containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());\n+                    && sameTypeArguments(t.getTypeArguments(), s.getTypeArguments());\n@@ -1431,0 +1433,2 @@\n+            abstract boolean sameTypeArguments(List<Type> ts, List<Type> ss);\n+\n@@ -1486,0 +1490,10 @@\n+        }\n+\n+        TypeEqualityVisitor isSameTypeVisitor = new TypeEqualityVisitor() {\n+            boolean sameTypeComparator(Type t, Type s) {\n+                return isSameType(t, s);\n+            }\n+\n+            boolean sameTypeArguments(List<Type> ts, List<Type> ss) {\n+                return containsTypeEquivalent(ts, ss);\n+            }\n@@ -3879,1 +3893,1 @@\n-            final Type t2;;\n+            final Type t2;\n@@ -3892,2 +3906,2 @@\n-                        && isSameType(t1, typePair.t1)\n-                        && isSameType(t2, typePair.t2);\n+                        && exactTypeVisitor.visit(t1, typePair.t1)\n+                        && exactTypeVisitor.visit(t2, typePair.t2);\n@@ -3896,0 +3910,18 @@\n+\n+        TypeEqualityVisitor exactTypeVisitor = new TypeEqualityVisitor() {\n+            @Override\n+            boolean sameTypeArguments(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()\n+                        && sameTypeComparator(ts.head, ss.head)) {\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n+            }\n+\n+            @Override\n+            boolean sameTypeComparator(Type t, Type s) {\n+                return exactTypeVisitor.visit(t, s);\n+            }\n+        };\n+\n@@ -4107,9 +4139,8 @@\n-    \/\/ where\n-        List<Type> erasedSupertypes(Type t) {\n-            ListBuffer<Type> buf = new ListBuffer<>();\n-            for (Type sup : closure(t)) {\n-                if (sup.hasTag(TYPEVAR)) {\n-                    buf.append(sup);\n-                } else {\n-                    buf.append(erasure(sup));\n-                }\n+\n+    public List<Type> erasedSupertypes(Type t) {\n+        ListBuffer<Type> buf = new ListBuffer<>();\n+        for (Type sup : closure(t)) {\n+            if (sup.hasTag(TYPEVAR)) {\n+                buf.append(sup);\n+            } else {\n+                buf.append(erasure(sup));\n@@ -4117,1 +4148,0 @@\n-            return buf.toList();\n@@ -4119,0 +4149,2 @@\n+        return buf.toList();\n+    }\n@@ -4120,0 +4152,1 @@\n+    \/\/ where\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":49,"deletions":16,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import com.sun.tools.javac.comp.Check.CheckContext;\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -69,0 +71,1 @@\n+    final Check chk;\n@@ -87,0 +90,1 @@\n+        chk = Check.instance(context);\n@@ -195,0 +199,6 @@\n+                CheckContext recoveryCheckContext = new NestedCheckContext(todo.resultInfo.checkContext) {\n+                    @Override\n+                    public void report(JCDiagnostic.DiagnosticPosition pos, JCDiagnostic details) {\n+                        chk.basicHandler.report(pos, details);\n+                    }\n+                };\n@@ -196,1 +206,1 @@\n-                                 attr.new ResultInfo(todo.resultInfo.pkind, todo.resultInfo.pt.getReturnType(), todo.resultInfo.checkContext, todo.resultInfo.checkMode),\n+                                 attr.new ResultInfo(todo.resultInfo.pkind, todo.resultInfo.pt.getReturnType(), recoveryCheckContext, todo.resultInfo.checkMode),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrRecover.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static com.sun.tools.javac.code.TypeTag.ARRAY;\n@@ -40,0 +41,1 @@\n+import static com.sun.tools.javac.code.TypeTag.TYPEVAR;\n@@ -1860,3 +1862,9 @@\n-                Type lub = types.lub(t1, t2);\n-\n-                if (lub.hasTag(BOT)) {\n+                \/* the most semantically correct approach here would be to invoke Types::lub\n+                 * and then erase the result.\n+                 * But this approach can be too slow for some complex cases, see JDK-8369654.\n+                 * This is why the method below leverages the fact that the result\n+                 * will be erased to produce a correct supertype using a simpler approach compared\n+                 * to a full blown lub.\n+                 *\/\n+                Type es = erasedSuper(t1, t2);\n+                if (es == null || es.hasTag(BOT)) {\n@@ -1866,0 +1874,3 @@\n+                return es;\n+            }\n+        }\n@@ -1867,1 +1878,20 @@\n-                return types.erasure(lub);\n+        private Type erasedSuper(Type t1, Type t2) {\n+            if (t1.hasTag(ARRAY) && t2.hasTag(ARRAY)) {\n+                Type elem1 = types.elemtype(t1);\n+                Type elem2 = types.elemtype(t2);\n+                if (elem1.isPrimitive() || elem2.isPrimitive()) {\n+                    return (elem1.tsym == elem2.tsym) ? t1 : syms.serializableType;\n+                } else { \/\/ both are arrays of references\n+                    return new ArrayType(erasedSuper(elem1, elem2), syms.arrayClass);\n+                }\n+            } else {\n+                t1 = types.skipTypeVars(t1, false);\n+                t2 = types.skipTypeVars(t2, false);\n+                List<Type> intersection = types.intersect(\n+                        t1.hasTag(ARRAY) ?\n+                                List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n+                                types.erasedSupertypes(t1),\n+                        t2.hasTag(ARRAY) ?\n+                                List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n+                                types.erasedSupertypes(t2));\n+                return intersection.head;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1557,1 +1557,11 @@\n-                    mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));\n+                    if (TreeInfo.isType(mref.expr, names)) {\n+                        mref.expr = insertAnnotationsToMostInner(mref.expr, typeAnnos, false);\n+                    } else {\n+                        \/\/the selector is not a type, error recovery:\n+                        JCAnnotatedType annotatedType =\n+                                toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));\n+                        int termStart = getStartPos(mref.expr);\n+                        mref.expr = syntaxError(termStart, List.of(annotatedType),\n+                                                Errors.IllegalStartOfType);\n+                    }\n+                    mref.pos = getStartPos(mref.expr);\n@@ -4965,1 +4975,2 @@\n-            if (!isVoid && typarams.isEmpty() && (token.kind == EQ || token.kind == SEMI)) {\n+            if (!isVoid && typarams.isEmpty() &&\n+                (token.kind == EQ || token.kind == SEMI || token.kind == COMMA)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -214,0 +214,5 @@\n+            Tree typeAnno = new TypeAnnotationFinder().scan(tree, null);\n+            if (typeAnno != null) {\n+                int annoPos = ((JCTree) typeAnno).getStartPosition();\n+                throw new ParseException(beginIndex + annoPos, \"dc.ref.annotations.not.allowed\");\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ReferenceParser.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,9 @@\n+# This file was originally used to produce the `proprietary` warning when\n+# accessing non-APIs, and to hide some non-APIs in JDK <= 8. This has been\n+# superseded by the module system and `--release`. But, when compiling with\n+# `--source 8`, it is still used for this purpose by\n+# `com.sun.tools.javac.file.JRTIndex`.\n+#\n+# The build generates `jdk.compiler\/com\/sun\/tools\/javac\/resources\/ct.java` from\n+# this file, which is then used at runtime.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/ct.properties","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -455,0 +455,13 @@\n+        return isTypeSelector(base, names, TreeInfo::isStaticSym);\n+    }\n+    \/\/where\n+        private static boolean isStaticSym(JCTree tree) {\n+            Symbol sym = symbol(tree);\n+            return (sym.kind == TYP || sym.kind == PCK);\n+        }\n+\n+    public static boolean isType(JCTree base, Names names) {\n+        return isTypeSelector(base, names, _ -> true);\n+    }\n+\n+    private static boolean isTypeSelector(JCTree base, Names names, Predicate<JCTree> checkStaticSym) {\n@@ -462,1 +475,1 @@\n-                        isStaticSym(base);\n+                        checkStaticSym.test(base);\n@@ -464,1 +477,1 @@\n-                return isStaticSym(base) &&\n+                return checkStaticSym.test(base) &&\n@@ -475,5 +488,0 @@\n-    \/\/where\n-        private static boolean isStaticSym(JCTree tree) {\n-            Symbol sym = symbol(tree);\n-            return (sym.kind == TYP || sym.kind == PCK);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  private static long          immutableDataReferencesCounterSize;\n+  private static long          immutableDataRefCountSize;\n@@ -51,1 +51,1 @@\n-  private static CIntegerField deoptHandlerOffsetField;\n+  private static CIntegerField deoptHandlerEntryOffsetField;\n@@ -58,0 +58,1 @@\n+  private static CIntegerField immutableDataRefCountOffsetField;\n@@ -88,1 +89,1 @@\n-    deoptHandlerOffsetField            = type.getCIntegerField(\"_deopt_handler_offset\");\n+    deoptHandlerEntryOffsetField       = type.getCIntegerField(\"_deopt_handler_entry_offset\");\n@@ -93,0 +94,1 @@\n+    immutableDataRefCountOffsetField   = type.getCIntegerField(\"_immutable_data_ref_count_offset\");\n@@ -100,1 +102,1 @@\n-    immutableDataReferencesCounterSize = VM.getVM().getIntSize();\n+    immutableDataRefCountSize          = VM.getVM().getIntSize();\n@@ -122,39 +124,40 @@\n-  public Address constantsBegin()       { return contentBegin();                                     }\n-  public Address constantsEnd()         { return codeBegin();                                        }\n-  public Address instsBegin()           { return codeBegin();                                        }\n-  public Address instsEnd()             { return headerBegin().addOffsetTo(getStubOffset());         }\n-  public Address exceptionBegin()       { return headerBegin().addOffsetTo(getExceptionOffset());    }\n-  public Address deoptHandlerBegin()    { return headerBegin().addOffsetTo(getDeoptHandlerOffset());   }\n-  public Address stubBegin()            { return headerBegin().addOffsetTo(getStubOffset());         }\n-  public Address stubEnd()              { return dataBegin();                                        }\n-  public Address oopsBegin()            { return dataBegin();                                        }\n-  public Address oopsEnd()              { return dataEnd();                                          }\n-\n-  public Address immutableDataBegin()   { return immutableDataField.getValue(addr);                         }\n-  public Address immutableDataEnd()     { return immutableDataBegin().addOffsetTo(getImmutableDataSize());  }\n-  public Address dependenciesBegin()    { return immutableDataBegin();                                      }\n-  public Address dependenciesEnd()      { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableBegin()    { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n-  public Address handlerTableEnd()      { return immutableDataBegin().addOffsetTo(getNulChkTableOffset());  }\n-  public Address nulChkTableBegin()     { return immutableDataBegin().addOffsetTo(getNulChkTableOffset());  }\n-  public Address nulChkTableEnd()       { return immutableDataBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataBegin()      { return immutableDataBegin().addOffsetTo(getScopesDataOffset());   }\n-  public Address scopesDataEnd()        { return immutableDataBegin().addOffsetTo(getScopesPCsOffset());    }\n-  public Address scopesPCsBegin()       { return immutableDataBegin().addOffsetTo(getScopesPCsOffset());    }\n-  public Address scopesPCsEnd()         { return immutableDataEnd().addOffsetTo(-immutableDataReferencesCounterSize); }\n-\n-  public Address metadataBegin()        { return mutableDataBegin().addOffsetTo(getRelocationSize());   }\n-  public Address metadataEnd()          { return mutableDataEnd();                                      }\n-\n-  public int getImmutableDataSize()     { return (int) immutableDataSizeField.getValue(addr);        }\n-  public int constantsSize()            { return (int) constantsEnd()   .minus(constantsBegin());    }\n-  public int instsSize()                { return (int) instsEnd()       .minus(instsBegin());        }\n-  public int stubSize()                 { return (int) stubEnd()        .minus(stubBegin());         }\n-  public int oopsSize()                 { return (int) oopsEnd()        .minus(oopsBegin());         }\n-  public int metadataSize()             { return (int) metadataEnd()    .minus(metadataBegin());     }\n-  public int scopesDataSize()           { return (int) scopesDataEnd()  .minus(scopesDataBegin());   }\n-  public int scopesPCsSize()            { return (int) scopesPCsEnd()   .minus(scopesPCsBegin());    }\n-  public int dependenciesSize()         { return (int) dependenciesEnd().minus(dependenciesBegin()); }\n-  public int handlerTableSize()         { return (int) handlerTableEnd().minus(handlerTableBegin()); }\n-  public int nulChkTableSize()          { return (int) nulChkTableEnd() .minus(nulChkTableBegin());  }\n-  public int origPCOffset()             { return (int) origPCOffsetField.getValue(addr);             }\n+  public Address constantsBegin()             { return contentBegin();                                          }\n+  public Address constantsEnd()               { return codeBegin();                                             }\n+  public Address instsBegin()                 { return codeBegin();                                             }\n+  public Address instsEnd()                   { return headerBegin().addOffsetTo(getStubOffset());              }\n+  public Address exceptionBegin()             { return headerBegin().addOffsetTo(getExceptionOffset());         }\n+  public Address deoptHandlerEntry()          { return headerBegin().addOffsetTo(getDeoptHandlerEntryOffset()); }\n+  public Address stubBegin()                  { return headerBegin().addOffsetTo(getStubOffset());              }\n+  public Address stubEnd()                    { return dataBegin();                                             }\n+  public Address oopsBegin()                  { return dataBegin();                                             }\n+  public Address oopsEnd()                    { return dataEnd();                                               }\n+\n+  public Address immutableDataBegin()         { return immutableDataField.getValue(addr);                         }\n+  public Address immutableDataEnd()           { return immutableDataBegin().addOffsetTo(getImmutableDataSize());  }\n+  public Address dependenciesBegin()          { return immutableDataBegin();                                      }\n+  public Address dependenciesEnd()            { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n+  public Address handlerTableBegin()          { return immutableDataBegin().addOffsetTo(getHandlerTableOffset()); }\n+  public Address handlerTableEnd()            { return immutableDataBegin().addOffsetTo(getNulChkTableOffset());  }\n+  public Address nulChkTableBegin()           { return immutableDataBegin().addOffsetTo(getNulChkTableOffset());  }\n+  public Address nulChkTableEnd()             { return immutableDataBegin().addOffsetTo(getScopesDataOffset());   }\n+  public Address scopesDataBegin()            { return immutableDataBegin().addOffsetTo(getScopesDataOffset());   }\n+  public Address scopesDataEnd()              { return immutableDataBegin().addOffsetTo(getScopesPCsOffset());    }\n+  public Address scopesPCsBegin()             { return immutableDataBegin().addOffsetTo(getScopesPCsOffset());    }\n+  public Address scopesPCsEnd()               { return immutableDataBegin().addOffsetTo(getImmutableDataRefCountOffset()); }\n+  public Address immutableDataRefCountBegin() { return immutableDataBegin().addOffsetTo(getImmutableDataRefCountOffset()); }\n+\n+  public Address metadataBegin()              { return mutableDataBegin().addOffsetTo(getRelocationSize());   }\n+  public Address metadataEnd()                { return mutableDataEnd();                                      }\n+\n+  public int getImmutableDataSize()           { return (int) immutableDataSizeField.getValue(addr);        }\n+  public int constantsSize()                  { return (int) constantsEnd()   .minus(constantsBegin());    }\n+  public int instsSize()                      { return (int) instsEnd()       .minus(instsBegin());        }\n+  public int stubSize()                       { return (int) stubEnd()        .minus(stubBegin());         }\n+  public int oopsSize()                       { return (int) oopsEnd()        .minus(oopsBegin());         }\n+  public int metadataSize()                   { return (int) metadataEnd()    .minus(metadataBegin());     }\n+  public int scopesDataSize()                 { return (int) scopesDataEnd()  .minus(scopesDataBegin());   }\n+  public int scopesPCsSize()                  { return (int) scopesPCsEnd()   .minus(scopesPCsBegin());    }\n+  public int dependenciesSize()               { return (int) dependenciesEnd().minus(dependenciesBegin()); }\n+  public int handlerTableSize()               { return (int) handlerTableEnd().minus(handlerTableBegin()); }\n+  public int nulChkTableSize()                { return (int) nulChkTableEnd() .minus(nulChkTableBegin());  }\n+  public int origPCOffset()                   { return (int) origPCOffsetField.getValue(addr);             }\n@@ -168,0 +171,1 @@\n+\n@@ -169,1 +173,1 @@\n-    return\n+    int size =\n@@ -174,2 +178,7 @@\n-      nulChkTableSize()  +\n-      (int) immutableDataReferencesCounterSize;\n+      nulChkTableSize();\n+\n+    if (size > 0) {\n+      size += (int) immutableDataRefCountSize;\n+    }\n+\n+    return size;\n@@ -256,1 +265,1 @@\n-  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }\n+  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerEntry(); }\n@@ -482,9 +491,10 @@\n-  private int getEntryBCI()           { return (int) entryBCIField          .getValue(addr); }\n-  private int getExceptionOffset()    { return (int) exceptionOffsetField   .getValue(addr); }\n-  private int getDeoptHandlerOffset()   { return (int) deoptHandlerOffsetField  .getValue(addr); }\n-  private int getStubOffset()         { return (int) stubOffsetField        .getValue(addr); }\n-  private int getScopesDataOffset()   { return (int) scopesDataOffsetField  .getValue(addr); }\n-  private int getScopesPCsOffset()    { return (int) scopesPCsOffsetField   .getValue(addr); }\n-  private int getHandlerTableOffset() { return (int) handlerTableOffsetField.getValue(addr); }\n-  private int getNulChkTableOffset()  { return (int) nulChkTableOffsetField .getValue(addr); }\n-  private int getCompLevel()          { return (int) compLevelField         .getValue(addr); }\n+  private int getEntryBCI()                     { return (int) entryBCIField                    .getValue(addr); }\n+  private int getExceptionOffset()              { return (int) exceptionOffsetField             .getValue(addr); }\n+  private int getDeoptHandlerEntryOffset()      { return (int) deoptHandlerEntryOffsetField     .getValue(addr); }\n+  private int getStubOffset()                   { return (int) stubOffsetField                  .getValue(addr); }\n+  private int getScopesDataOffset()             { return (int) scopesDataOffsetField            .getValue(addr); }\n+  private int getScopesPCsOffset()              { return (int) scopesPCsOffsetField             .getValue(addr); }\n+  private int getHandlerTableOffset()           { return (int) handlerTableOffsetField          .getValue(addr); }\n+  private int getNulChkTableOffset()            { return (int) nulChkTableOffsetField           .getValue(addr); }\n+  private int getCompLevel()                    { return (int) compLevelField                   .getValue(addr); }\n+  private int getImmutableDataRefCountOffset()  { return (int) immutableDataRefCountOffsetField .getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":66,"deletions":56,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+  \/** Find sender frame with given FP and PC *\/\n+  public default CFrame sender(ThreadProxy th, Address fp, Address pc) {\n+    return sender(th);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/cdbg\/CFrame.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+   @Override\n@@ -57,2 +58,2 @@\n-      AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();\n-      Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+      return sender(thread, null, null);\n+   }\n@@ -60,2 +61,13 @@\n-      if ((fp == null) || fp.lessThan(rsp)) {\n-        return null;\n+   @Override\n+   public CFrame sender(ThreadProxy thread, Address nextFP, Address nextPC) {\n+      \/\/ Check fp\n+      \/\/ Skip if both nextFP and nextPC are given - do not need to load from fp.\n+      if (nextFP == null && nextPC == null) {\n+        if (fp == null) {\n+          return null;\n+        }\n+\n+        \/\/ Check alignment of fp\n+        if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+          return null;\n+        }\n@@ -64,2 +76,4 @@\n-      \/\/ Check alignment of fp\n-      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+      if (nextFP == null) {\n+        nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);\n+      }\n+      if (nextFP == null) {\n@@ -69,3 +83,2 @@\n-      Address nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);\n-      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {\n-        return null;\n+      if (nextPC == null) {\n+        nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);\n@@ -73,1 +86,0 @@\n-      Address nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/aarch64\/LinuxAARCH64CFrame.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -50,5 +50,3 @@\n-        cfa = ((dwarf.getCFARegister() == AMD64ThreadContext.RBP) &&\n-               !dwarf.isBPOffsetAvailable())\n-                  ? context.getRegisterAsAddress(AMD64ThreadContext.RBP)\n-                  : context.getRegisterAsAddress(dwarf.getCFARegister())\n-                           .addOffsetTo(dwarf.getCFAOffset());\n+\n+        cfa = context.getRegisterAsAddress(dwarf.getCFARegister())\n+                     .addOffsetTo(dwarf.getCFAOffset());\n@@ -66,0 +64,4 @@\n+      this(dbg, cfa, rip, dwarf, finalFrame, false);\n+   }\n+\n+   private LinuxAMD64CFrame(LinuxDebugger dbg, Address cfa, Address rip, DwarfParser dwarf, boolean finalFrame, boolean use1ByteBeforeToLookup) {\n@@ -72,0 +74,1 @@\n+      this.use1ByteBeforeToLookup = use1ByteBeforeToLookup;\n@@ -76,0 +79,1 @@\n+      Address symAddr = use1ByteBeforeToLookup ? pc().addOffsetTo(-1) : pc();\n@@ -77,1 +81,1 @@\n-      return dbg.lookup(dbg.getAddressValue(pc()));\n+      return dbg.lookup(dbg.getAddressValue(symAddr));\n@@ -98,3 +102,6 @@\n-   private boolean isValidFrame(Address nextCFA, ThreadContext context) {\n-     return (nextCFA != null) &&\n-             !nextCFA.lessThan(context.getRegisterAsAddress(AMD64ThreadContext.RSP));\n+   private boolean isValidFrame(Address nextCFA, boolean isNative) {\n+     \/\/ CFA should never be null.\n+     \/\/ nextCFA must be greater than current CFA, if frame is native.\n+     \/\/ Java interpreter frames can share the CFA (frame pointer).\n+     return nextCFA != null &&\n+         (!isNative || (isNative && nextCFA.greaterThan(cfa)));\n@@ -103,1 +110,1 @@\n-   private Address getNextCFA(DwarfParser nextDwarf, ThreadContext context) {\n+   private Address getNextCFA(DwarfParser nextDwarf, ThreadContext context, Address senderFP) {\n@@ -105,0 +112,5 @@\n+     boolean isNative = false;\n+\n+     if (senderFP == null) {\n+       senderFP = cfa.getAddressAt(0);  \/\/ RBP by default\n+     }\n@@ -107,1 +119,1 @@\n-       nextCFA = (dwarf == null) ? cfa.getAddressAt(0) \/\/ Current frame is Java (Use RBP)\n+       nextCFA = (dwarf == null) ? senderFP \/\/ Current frame is Java\n@@ -110,2 +122,2 @@\n-       if (dwarf == null) { \/\/ Current frame is Java (Use RBP)\n-         nextCFA = cfa.getAddressAt(0);\n+       if (dwarf == null) { \/\/ Current frame is Java\n+         nextCFA = senderFP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n@@ -113,0 +125,1 @@\n+         isNative = true;\n@@ -114,8 +127,10 @@\n-         if (!dwarf.isBPOffsetAvailable() && \/\/ Use RBP as CFA\n-             (nextCFAReg == AMD64ThreadContext.RBP) &&\n-             (nextCFAReg != dwarf.getCFARegister())) {\n-           nextCFA = context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n-           if (nextCFA == null) {\n-             return null;\n-           }\n-           nextCFA = nextCFA.getAddressAt(0);\n+         if (nextCFAReg == AMD64ThreadContext.RBP) {\n+           Address rbp = dwarf.isBPOffsetAvailable() ? cfa.addOffsetTo(dwarf.getBasePointerOffsetFromCFA())\n+                                                     : context.getRegisterAsAddress(AMD64ThreadContext.RBP);\n+           Address nextRBP = rbp.getAddressAt(0);\n+           nextCFA = nextRBP.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n+         } else if (nextCFAReg == AMD64ThreadContext.RSP) {\n+           \/\/ next RSP should be previous slot of return address.\n+           Address nextRSP = cfa.addOffsetTo(dwarf.getReturnAddressOffsetFromCFA())\n+                                .addOffsetTo(ADDRESS_SIZE);\n+           nextCFA = nextRSP.addOffsetTo(nextDwarf.getCFAOffset());\n@@ -123,1 +138,1 @@\n-           nextCFA = cfa.getAddressAt(dwarf.getBasePointerOffsetFromCFA());\n+           throw new DebuggerException(\"Unsupported CFA register: \" + nextCFAReg);\n@@ -126,3 +141,0 @@\n-       if (nextCFA != null) {\n-         nextCFA = nextCFA.addOffsetTo(-nextDwarf.getBasePointerOffsetFromCFA());\n-       }\n@@ -131,1 +143,14 @@\n-     return isValidFrame(nextCFA, context) ? nextCFA : null;\n+     \/\/ Sanity check for next CFA address\n+     try {\n+       nextCFA.getAddressAt(0);\n+     } catch (Exception e) {\n+       \/\/ return null if next CFA address is invalid\n+       return null;\n+     }\n+\n+     return isValidFrame(nextCFA, isNative) ? nextCFA : null;\n+   }\n+\n+   @Override\n+   public CFrame sender(ThreadProxy th) {\n+     return sender(th, null, null);\n@@ -135,1 +160,1 @@\n-   public CFrame sender(ThreadProxy thread) {\n+   public CFrame sender(ThreadProxy th, Address fp, Address pc) {\n@@ -140,1 +165,1 @@\n-     ThreadContext context = thread.getContext();\n+     ThreadContext context = th.getContext();\n@@ -142,1 +167,1 @@\n-     Address nextPC = getNextPC(dwarf != null);\n+     Address nextPC = pc != null ? pc : getNextPC(dwarf != null);\n@@ -148,1 +173,25 @@\n-     Address libptr = dbg.findLibPtrByAddress(nextPC);\n+     boolean fallback = false;\n+     try {\n+       nextDwarf = createDwarfParser(nextPC);\n+     } catch (DebuggerException _) {\n+       \/\/ Try again with RIP-1 in case RIP is just outside function bounds,\n+       \/\/ due to function ending with a `call` instruction.\n+       try {\n+         nextDwarf = createDwarfParser(nextPC.addOffsetTo(-1));\n+         fallback = true;\n+       } catch (DebuggerException _) {\n+         \/\/ DWARF processing should succeed when the frame is native\n+         \/\/ but it might fail if Common Information Entry (CIE) has language\n+         \/\/ personality routine and\/or Language Specific Data Area (LSDA).\n+         return new LinuxAMD64CFrame(dbg, null, nextPC, nextDwarf, true);\n+       }\n+     }\n+\n+     Address nextCFA = getNextCFA(nextDwarf, context, fp);\n+     return nextCFA == null ? null\n+                            : new LinuxAMD64CFrame(dbg, nextCFA, nextPC, nextDwarf, false, fallback);\n+   }\n+\n+   private DwarfParser createDwarfParser(Address pc) throws DebuggerException {\n+     DwarfParser nextDwarf = null;\n+     Address libptr = dbg.findLibPtrByAddress(pc);\n@@ -152,1 +201,1 @@\n-       } catch (DebuggerException e) {\n+       } catch (DebuggerException _) {\n@@ -158,8 +207,1 @@\n-       try {\n-         nextDwarf.processDwarf(nextPC);\n-       } catch (DebuggerException e) {\n-         \/\/ DWARF processing should succeed when the frame is native\n-         \/\/ but it might fail if Common Information Entry (CIE) has language\n-         \/\/ personality routine and\/or Language Specific Data Area (LSDA).\n-         return new LinuxAMD64CFrame(dbg, null, nextPC, nextDwarf, true);\n-       }\n+       nextDwarf.processDwarf(pc);\n@@ -168,3 +210,1 @@\n-     Address nextCFA = getNextCFA(nextDwarf, context);\n-     return isValidFrame(nextCFA, context) ? new LinuxAMD64CFrame(dbg, nextCFA, nextPC, nextDwarf)\n-                                           : null;\n+     return nextDwarf;\n@@ -180,0 +220,1 @@\n+   private boolean use1ByteBeforeToLookup;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":83,"deletions":42,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+   @Override\n@@ -61,2 +62,2 @@\n-      RISCV64ThreadContext context = (RISCV64ThreadContext) thread.getContext();\n-      Address rsp = context.getRegisterAsAddress(RISCV64ThreadContext.SP);\n+      return sender(thread, null, null);\n+   }\n@@ -64,2 +65,13 @@\n-      if ((fp == null) || fp.lessThan(rsp)) {\n-        return null;\n+   @Override\n+   public CFrame sender(ThreadProxy thread, Address nextFP, Address nextPC) {\n+      \/\/ Check fp\n+      \/\/ Skip if both nextFP and nextPC are given - do not need to load from fp.\n+      if (nextFP == null && nextPC == null) {\n+        if (fp == null) {\n+          return null;\n+        }\n+\n+        \/\/ Check alignment of fp\n+        if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+          return null;\n+        }\n@@ -68,2 +80,4 @@\n-      \/\/ Check alignment of fp\n-      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+      if (nextFP == null) {\n+        nextFP = fp.getAddressAt(C_FRAME_LINK_OFFSET * ADDRESS_SIZE);\n+      }\n+      if (nextFP == null) {\n@@ -73,3 +87,2 @@\n-      Address nextFP = fp.getAddressAt(C_FRAME_LINK_OFFSET * ADDRESS_SIZE);\n-      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {\n-        return null;\n+      if (nextPC == null) {\n+        nextPC = fp.getAddressAt(C_FRAME_RETURN_ADDR_OFFSET * ADDRESS_SIZE);\n@@ -77,1 +90,0 @@\n-      Address nextPC  = fp.getAddressAt(C_FRAME_RETURN_ADDR_OFFSET * ADDRESS_SIZE);\n@@ -81,0 +93,1 @@\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/riscv64\/LinuxRISCV64CFrame.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.gc.shenandoah;\n+\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.runtime.VMObject;\n+import sun.jvm.hotspot.types.CIntegerField;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+\n+public class ShenandoahFreeSet extends VMObject {\n+    private static CIntegerField used;\n+    static {\n+        VM.registerVMInitializedObserver(new Observer() {\n+            public void update(Observable o, Object data) {\n+                initialize(VM.getVM().getTypeDataBase());\n+            }\n+        });\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) {\n+        Type type = db.lookupType(\"ShenandoahFreeSet\");\n+        used = type.getCIntegerField(\"_total_global_used\");\n+    }\n+\n+    public ShenandoahFreeSet(Address addr) {\n+        super(addr);\n+    }\n+\n+    public long used() {\n+        return used.getValue(addr);\n+    }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahFreeSet.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shenandoah;\n-\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-import sun.jvm.hotspot.debugger.Address;\n-import sun.jvm.hotspot.runtime.VM;\n-import sun.jvm.hotspot.runtime.VMObject;\n-import sun.jvm.hotspot.types.CIntegerField;\n-import sun.jvm.hotspot.types.Type;\n-import sun.jvm.hotspot.types.TypeDataBase;\n-\n-public class ShenandoahGeneration extends VMObject {\n-    private static CIntegerField used;\n-    static {\n-        VM.registerVMInitializedObserver(new Observer() {\n-            public void update(Observable o, Object data) {\n-                initialize(VM.getVM().getTypeDataBase());\n-            }\n-        });\n-    }\n-\n-    private static synchronized void initialize(TypeDataBase db) {\n-        Type type = db.lookupType(\"ShenandoahGeneration\");\n-        used = type.getCIntegerField(\"_used\");\n-    }\n-\n-    public ShenandoahGeneration(Address addr) {\n-        super(addr);\n-    }\n-\n-    public long used() {\n-        return used.getValue(addr);\n-    }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahGeneration.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -46,1 +46,1 @@\n-    private static AddressField  globalGeneration;\n+    private static AddressField  globalFreeSet;\n@@ -63,1 +63,1 @@\n-        globalGeneration = type.getAddressField(\"_global_generation\");\n+        globalFreeSet = type.getAddressField(\"_free_set\");\n@@ -92,3 +92,3 @@\n-        Address globalGenerationAddress = globalGeneration.getValue(addr);\n-        ShenandoahGeneration global = VMObjectFactory.newObject(ShenandoahGeneration.class, globalGenerationAddress);\n-        return global.used();\n+        Address globalFreeSetAddress = globalFreeSet.getValue(addr);\n+        ShenandoahFreeSet freeset = VMObjectFactory.newObject(ShenandoahFreeSet.class, globalFreeSetAddress);\n+        return freeset.used();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shenandoah\/ShenandoahHeap.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n+        if (pc.equals(nm.deoptHandlerEntry())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+                  Address senderFP = null;\n+                  Address senderPC = null;\n@@ -128,1 +130,1 @@\n-                      String[] names = null;\n+                      JavaNameInfo nameInfo = null;\n@@ -132,1 +134,1 @@\n-                         names = getJavaNames(th, f.localVariableBase());\n+                         nameInfo = getJavaNames(th, f.localVariableBase());\n@@ -134,1 +136,1 @@\n-                         if (names == null || names.length == 0) {\n+                         if (nameInfo == null || nameInfo.names() == null || nameInfo.names().length == 0) {\n@@ -157,1 +159,1 @@\n-                                  names = getJavaNames(th, f.localVariableBase());\n+                                  nameInfo = getJavaNames(th, f.localVariableBase());\n@@ -159,1 +161,1 @@\n-                                  if (names == null || names.length == 0) {\n+                                  if (nameInfo == null || nameInfo.names() == null || nameInfo.names().length == 0) {\n@@ -171,5 +173,8 @@\n-                      if (names != null && names.length != 0) {\n-                         \/\/ print java frame(s)\n-                         for (int i = 0; i < names.length; i++) {\n-                             if (i > 0) {\n-                                 out.print(fillerForAddress);\n+                      if (nameInfo != null) {\n+                         if (nameInfo.names() != null && nameInfo.names().length != 0) {\n+                             \/\/ print java frame(s)\n+                             for (int i = 0; i < nameInfo.names().length; i++) {\n+                                 if (i > 0) {\n+                                     out.print(fillerForAddress);\n+                                 }\n+                                 out.println(nameInfo.names()[i]);\n@@ -177,1 +182,0 @@\n-                             out.println(names[i]);\n@@ -179,0 +183,2 @@\n+                         senderFP = nameInfo.senderFP();\n+                         senderPC = nameInfo.senderPC();\n@@ -181,1 +187,1 @@\n-                  f = f.sender(th);\n+                  f = f.sender(th, senderFP, senderPC);\n@@ -242,1 +248,3 @@\n-   private String[] getJavaNames(ThreadProxy th, Address fp) {\n+   private static record JavaNameInfo(String[] names, Address senderFP, Address senderPC) {};\n+\n+   private JavaNameInfo getJavaNames(ThreadProxy th, Address fp) {\n@@ -248,0 +256,1 @@\n+\n@@ -249,0 +258,1 @@\n+      JavaVFrame bottomJVFrame = null;\n@@ -253,0 +263,1 @@\n+            bottomJVFrame = vf;\n@@ -283,2 +294,10 @@\n-      String[] res = names.toArray(new String[0]);\n-      return res;\n+\n+      Address senderFP = null;\n+      Address senderPC = null;\n+      if (bottomJVFrame != null) {\n+         Frame senderFrame = bottomJVFrame.getFrame().sender((RegisterMap)bottomJVFrame.getRegisterMap().clone());\n+         senderFP = senderFrame.getFP();\n+         senderPC = senderFrame.getPC();\n+      }\n+\n+      return new JavaNameInfo(names.toArray(new String[0]), senderFP, senderPC);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/PStack.java","additions":34,"deletions":15,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -596,0 +596,44 @@\n+\n+#elif _M_ARM64\n+    #define REG_INDEX(x) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##x\n+\n+    context.ContextFlags = CONTEXT_FULL;\n+    COM_VERIFY_OK_(ptrIDebugAdvanced->GetThreadContext(&context, sizeof(CONTEXT)),\n+                   \"Windbg Error: GetThreadContext failed!\", false);\n+\n+    ptrRegs[REG_INDEX(R0)]  = context.X0;\n+    ptrRegs[REG_INDEX(R1)]  = context.X1;\n+    ptrRegs[REG_INDEX(R2)]  = context.X2;\n+    ptrRegs[REG_INDEX(R3)]  = context.X3;\n+    ptrRegs[REG_INDEX(R4)]  = context.X4;\n+    ptrRegs[REG_INDEX(R5)]  = context.X5;\n+    ptrRegs[REG_INDEX(R6)]  = context.X6;\n+    ptrRegs[REG_INDEX(R7)]  = context.X7;\n+    ptrRegs[REG_INDEX(R8)]  = context.X8;\n+    ptrRegs[REG_INDEX(R9)]  = context.X9;\n+    ptrRegs[REG_INDEX(R10)] = context.X10;\n+    ptrRegs[REG_INDEX(R11)] = context.X11;\n+    ptrRegs[REG_INDEX(R12)] = context.X12;\n+    ptrRegs[REG_INDEX(R13)] = context.X13;\n+    ptrRegs[REG_INDEX(R14)] = context.X14;\n+    ptrRegs[REG_INDEX(R15)] = context.X15;\n+    ptrRegs[REG_INDEX(R16)] = context.X16;\n+    ptrRegs[REG_INDEX(R17)] = context.X17;\n+    ptrRegs[REG_INDEX(R18)] = context.X18;\n+    ptrRegs[REG_INDEX(R19)] = context.X19;\n+    ptrRegs[REG_INDEX(R20)] = context.X20;\n+    ptrRegs[REG_INDEX(R21)] = context.X21;\n+    ptrRegs[REG_INDEX(R22)] = context.X22;\n+    ptrRegs[REG_INDEX(R23)] = context.X23;\n+    ptrRegs[REG_INDEX(R24)] = context.X24;\n+    ptrRegs[REG_INDEX(R25)] = context.X25;\n+    ptrRegs[REG_INDEX(R26)] = context.X26;\n+    ptrRegs[REG_INDEX(R27)] = context.X27;\n+    ptrRegs[REG_INDEX(R28)] = context.X28;\n+\n+    ptrRegs[REG_INDEX(FP)]  = context.Fp;\n+    ptrRegs[REG_INDEX(LR)]  = context.Lr;\n+    ptrRegs[REG_INDEX(SP)]  = context.Sp;\n+    ptrRegs[REG_INDEX(PC)]  = context.Pc;\n+    ptrRegs[REG_INDEX(PSTATE)] = context.Cpsr;\n+\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -130,1 +130,6 @@\n-        }).map(MacApplicationLayout.class::cast).map(MacApplicationLayout::runtimeRootDirectory).ifPresent(codesigners);\n+        }).map(MacApplicationLayout.class::cast)\n+                .map(MacApplicationLayout::runtimeRootDirectory)\n+                .flatMap(MacBundle::fromPath)\n+                .filter(MacBundle::isValid)\n+                .map(MacBundle::root)\n+                .ifPresent(codesigners);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-                        .appImageAction(MacPackagingPipeline::writeRuntimeInfoPlist)\n+                        .noaction()\n@@ -189,1 +189,1 @@\n-                    \/\/ The predefined app image is a macOS bundle.\n+                    \/\/ The input runtime image is a macOS bundle.\n@@ -193,0 +193,4 @@\n+                } else {\n+                    \/\/ The input runtime is not a macOS bundle and doesn't have the plist file. Create one.\n+                    builder.task(MacCopyAppImageTaskID.COPY_RUNTIME_INFO_PLIST)\n+                            .appImageAction(MacPackagingPipeline::writeRuntimeInfoPlist).add();\n@@ -196,1 +200,1 @@\n-                    \/\/ The predefined app image is a signed bundle; explicit signing is not requested for the package.\n+                    \/\/ The input runtime is a signed bundle; explicit signing is not requested for the package.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+        \/\/ Look up for the exact match.\n@@ -121,0 +122,1 @@\n+            \/\/ No exact matches found, look up for substrings.\n@@ -123,1 +125,1 @@\n-                    return filter.startsWith(e.getKey());\n+                    return e.getKey().startsWith(filter);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/SigningIdentityBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+import jdk.jpackage.internal.model.ExternalApplication;\n@@ -119,1 +120,1 @@\n-                    var launcherParams = mapLauncherInfo(launcherInfo);\n+                    var launcherParams = mapLauncherInfo(appImageFile, launcherInfo);\n@@ -223,1 +224,1 @@\n-    private static Map<String, ? super Object> mapLauncherInfo(LauncherInfo launcherInfo) {\n+    private static Map<String, ? super Object> mapLauncherInfo(ExternalApplication appImageFile, LauncherInfo launcherInfo) {\n@@ -226,1 +227,5 @@\n-        launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n+        if (!appImageFile.getLauncherName().equals(launcherInfo.name())) {\n+            \/\/ This is not the main launcher, accept the value\n+            \/\/ of \"launcher-as-service\" from the app image file (.jpackage.xml).\n+            launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -434,0 +434,4 @@\n+\n+        if (TRACE_TASK_GRAPTH) {\n+            taskGraph.dumpToStdout();\n+        }\n@@ -633,1 +637,18 @@\n-            if (config.action.isPresent() && context.test(id)) {\n+\n+            final var withAction = config.action.isPresent();\n+            final var accepted = withAction && context.test(id);\n+\n+            if (TRACE_TASK_ACTION) {\n+                var sb = new StringBuffer();\n+                sb.append(\"Execute task=[\").append(id).append(\"]: \");\n+                if (!withAction) {\n+                    sb.append(\"no action\");\n+                } else if (!accepted) {\n+                    sb.append(\"rejected\");\n+                } else {\n+                    sb.append(\"run\");\n+                }\n+                System.out.println(sb);\n+            }\n+\n+            if (accepted) {\n@@ -636,0 +657,1 @@\n+\n@@ -643,0 +665,3 @@\n+\n+    private static final boolean TRACE_TASK_GRAPTH = false;\n+    private static final boolean TRACE_TASK_ACTION = false;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.xml.transform.dom.DOMSource;\n@@ -163,9 +164,7 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"string\" -> {\n-                return node.getTextContent();\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n-            }\n-        }\n+        return findValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<String> findValue(String keyName) {\n+        return findNode(keyName).filter(node -> {\n+            return \"string\".equals(node.getNodeName());\n+        }).map(Node::getTextContent);\n@@ -185,9 +184,7 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"dict\" -> {\n-                return new PListReader(node);\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n-            }\n-        }\n+        return findDictValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<PListReader> findDictValue(String keyName) {\n+        return findNode(keyName).filter(node -> {\n+            return \"dict\".equals(node.getNodeName());\n+        }).map(PListReader::new);\n@@ -207,10 +204,12 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"true\" -> {\n-                return true;\n-            }\n-            case \"false\" -> {\n-                return false;\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n+        return findBoolValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<Boolean> findBoolValue(String keyName) {\n+        return findNode(keyName).filter(node -> {\n+            switch (node.getNodeName()) {\n+                case \"true\", \"false\" -> {\n+                    return true;\n+                }\n+                default -> {\n+                    return false;\n+                }\n@@ -218,1 +217,1 @@\n-        }\n+        }).map(Node::getNodeName).map(Boolean::parseBoolean);\n@@ -236,4 +235,10 @@\n-        return queryArrayValue(keyName, false).map(v -> {\n-            if (v instanceof Raw r) {\n-                if (r.type() == Raw.Type.STRING) {\n-                    return r.value();\n+        return findStringArrayValue(keyName).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<List<String>> findStringArrayValue(String keyName) {\n+        return findArrayValue(keyName, false).map(stream -> {\n+            return stream.map(v -> {\n+                if (v instanceof Raw r) {\n+                    if (r.type() == Raw.Type.STRING) {\n+                        return r.value();\n+                    }\n@@ -241,3 +246,3 @@\n-            }\n-            return (String)null;\n-        }).filter(Objects::nonNull).toList();\n+                return (String)null;\n+            }).filter(Objects::nonNull).toList();\n+        });\n@@ -269,9 +274,15 @@\n-        final var node = getNode(keyName);\n-        switch (node.getNodeName()) {\n-            case \"array\" -> {\n-                return readArray(node, fetchDictionaries);\n-            }\n-            default -> {\n-                throw new NoSuchElementException();\n-            }\n-        }\n+        return findArrayValue(keyName, fetchDictionaries).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    public Optional<Stream<Object>> findArrayValue(String keyName, boolean fetchDictionaries) {\n+        return findNode(keyName).filter(node -> {\n+            return \"array\".equals(node.getNodeName());\n+        }).map(node -> {\n+            return readArray(node, fetchDictionaries);\n+        });\n+    }\n+\n+    public XmlConsumer toXmlConsumer() {\n+        return xml -> {\n+            XmlUtils.concatXml(xml, new DOMSource(root));\n+        };\n@@ -336,1 +347,1 @@\n-    private Node getNode(String keyName) {\n+    private Optional<Node> findNode(String keyName) {\n@@ -341,1 +352,1 @@\n-        }).get()).orElseThrow(NoSuchElementException::new);\n+        }).get());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PListReader.java","additions":58,"deletions":47,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/**\n+ * A mutable container object for a value.\n+ * <p>\n+ * An alternative for cases where {@link AtomicReference} would be an overkill.\n+ * Sample usage:\n+ * {@snippet :\n+ * void foo(MessageNotifier messageNotifier) {\n+ *     var lastMessage = Slot.createEmpty();\n+ *\n+ *     messageNotifier.setListener(msg -> {\n+ *         lastMessage.set(msg);\n+ *     }).run();\n+ *\n+ *     lastMessage.find().ifPresentOrElse(msg -> {\n+ *         System.out.println(String.format(\"The last message: [%s]\", msg));\n+ *     }, () -> {\n+ *         System.out.println(\"No messages received\");\n+ *     });\n+ * }\n+ *\n+ * abstract class MessageNotifier {\n+ *     MessageNotifier setListener(Consumer<String> messageConsumer) {\n+ *         callback = messageConsumer;\n+ *         return this;\n+ *     }\n+ *\n+ *     void run() {\n+ *         for (;;) {\n+ *             var msg = fetchNextMessage();\n+ *             msg.ifPresent(callback);\n+ *             if (msg.isEmpty()) {\n+ *                 break;\n+ *             }\n+ *         }\n+ *     }\n+ *\n+ *     abstract Optional<String> fetchNextMessage();\n+ *\n+ *     private Consumer<String> callback;\n+ * }\n+ * }\n+ *\n+ * An alternative to the {@code Slot} would be either {@code\n+ * AtomicReference} or a single-element {@code String[]} or any other\n+ * suitable container type. {@code AtomicReference} would be an overkill if\n+ * thread-safety is not a concern and the use of other options would be\n+ * confusing.\n+ *\n+ * @param <T> value type\n+ *\/\n+public final class Slot<T> {\n+\n+    public static <T> Slot<T> createEmpty() {\n+\n+        return new Slot<>();\n+    }\n+\n+    public T get() {\n+        return find().orElseThrow();\n+    }\n+\n+    public Optional<T> find() {\n+        return Optional.ofNullable(value);\n+    }\n+\n+    public void set(T v) {\n+        value = Objects.requireNonNull(v);\n+    }\n+\n+    private T value;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Slot.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-import java.util.Collection;\n+import java.util.List;\n@@ -108,1 +108,5 @@\n-    public static void mergeXmls(XMLStreamWriter xml, Collection<Source> sources)\n+    public static void concatXml(XMLStreamWriter xml, Source... sources) throws XMLStreamException, IOException {\n+        concatXml(xml, List.of(sources));\n+    }\n+\n+    public static void concatXml(XMLStreamWriter xml, Iterable<? extends Source> sources)\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/XmlUtils.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-            XmlUtils.mergeXmls(xml, sources);\n+            XmlUtils.concatXml(xml, sources);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixLauncherAsService.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n@@ -338,1 +341,6 @@\n-        throw asRunException(cause);\n+        \/\/ Guard against recursive cause chains by\n+        \/\/ using a Set with identity equality semantics.\n+        Set<Throwable> dejaVu = Collections.newSetFromMap(new IdentityHashMap<>());\n+        dejaVu.add(cause);\n+\n+        throw asRunException(cause, dejaVu);\n@@ -341,1 +349,1 @@\n-    private RunException asRunException(Throwable ex) {\n+    private RunException asRunException(Throwable ex, Set<Throwable> dejaVu) {\n@@ -350,1 +358,8 @@\n-            ue.initCause(cause == null ? null : asRunException(cause));\n+            if (cause != null) {\n+                Throwable throwable = dejaVu.add(cause)\n+                        ? asRunException(cause, dejaVu)\n+                        : new UserException(\"CIRCULAR REFERENCE!\",\n+                            cause.getClass().getName(),\n+                            cause.getStackTrace());\n+                ue.initCause(throwable);\n+            }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/DirectExecutionControl.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -678,1 +678,3 @@\n-        return hasName(n, \"Proj\") || hasName(n, \"MachProj\");\n+        return hasName(n, \"Proj\") ||\n+               hasName(n, \"MachProj\") ||\n+               hasName(n, \"NarrowMemProj\");\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+combine(anyNode, matches(\"name\", \"NarrowMemProj\"), [\"N\"]);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/condenseGraph.filter","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+jdk\/javadoc\/doccheck\/checks\/jdkCheckHtml.java 8370970 generic-all\n+jdk\/javadoc\/doccheck\/checks\/jdkDoctypeBadcharsCheck.java 8370970 generic-all\n","filename":"test\/docs\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    old = new ShenandoahOldGeneration(8, 1024 * 1024);\n+    old = new ShenandoahOldGeneration(8);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-    _heap->old_generation()->set_capacity(ShenandoahHeapRegion::region_size_bytes() * 10);\n+    \/\/ _heap->old_generation()->set_capacity(ShenandoahHeapRegion::region_size_bytes() * 10)\n+    _heap->free_set()->resize_old_collector_capacity(10);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-    ol.wait(THREAD);\n+    ol.wait_uninterruptibly(THREAD);\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-# Require javac\n-runtime\/HiddenClasses\/DefineHiddenClass.java            8346719 generic-all\n-\n-# Require jstack\n-runtime\/Thread\/TestThreadDumpClassInitMonitor.java      8346719 generic-all\n-runtime\/Thread\/TestThreadDumpSMRInfo.java               8346719 generic-all\n-serviceability\/tmtools\/jstack\/DaemonThreadTest.java     8346719 generic-all\n-serviceability\/tmtools\/jstack\/JstackThreadTest.java     8346719 generic-all\n-serviceability\/tmtools\/jstack\/SpreadLockTest.java       8346719 generic-all\n-serviceability\/tmtools\/jstack\/ThreadNamesTest.java      8346719 generic-all\n-serviceability\/tmtools\/jstack\/TraveledLockTest.java     8346719 generic-all\n-serviceability\/tmtools\/jstack\/WaitNotifyThreadTest.java 8346719 generic-all\n-serviceability\/tmtools\/jstat\/GcCapacityTest.java        8346719 generic-all\n-serviceability\/tmtools\/jstat\/GcCauseTest01.java         8346719 generic-all\n-serviceability\/tmtools\/jstat\/GcCauseTest02.java         8346719 generic-all\n-serviceability\/tmtools\/jstat\/GcCauseTest03.java         8346719 generic-all\n-serviceability\/tmtools\/jstat\/GcNewTest.java             8346719 generic-all\n-serviceability\/tmtools\/jstat\/GcTest01.java              8346719 generic-all\n-serviceability\/tmtools\/jstat\/GcTest02.java              8346719 generic-all\n-\n-# Require jcmd\n-serviceability\/HeapDump\/DuplicateArrayClassesTest.java  8346719 generic-all\n-serviceability\/HeapDump\/FieldsInInstanceTest.java       8346719 generic-all\n-serviceability\/attach\/ConcAttachTest.java               8346719 generic-all\n-serviceability\/attach\/RemovingUnixDomainSocketTest.java 8346719 generic-all\n-serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java#default            8346719 generic-all\n-serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java#no-vmcontinuations 8346719 generic-all\n-\n-# Require jhsdb\n-serviceability\/sa\/ClhsdbCDSCore.java                    8346719 generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core       8346719 generic-all\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core          8346719 generic-all\n-serviceability\/sa\/ClhsdbPmap.java#core                  8346719 generic-all\n-serviceability\/sa\/ClhsdbPstack.java#core                8346719 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-StaticJdk.txt","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-\n-compiler\/macronodes\/TestTopInMacroElimination.java      8362832 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-jvmti-stress-agent.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+gc\/shenandoah\/TestRetainObjects.java#no-tlab 8361099 generic-all\n+gc\/shenandoah\/TestSieveObjects.java#no-tlab 8361099 generic-all\n+gc\/shenandoah\/TestSieveObjects.java#no-tlab-genshen 8361099 generic-all\n@@ -161,1 +164,2 @@\n-\n+runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveRelocationTest.java             8372265 generic-all\n+runtime\/cds\/appcds\/dynamicArchive\/HelloDynamicInlineClass.java                  8372265 generic-all\n@@ -184,0 +188,1 @@\n+serviceability\/sa\/TestJhsdbJstackMixedWithXComp.java 8371194 linux-x64\n@@ -267,0 +272,1 @@\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t006\/TestDescription.java 8371103 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+\/*\n+ * @test\n+ * @bug 8370405\n+ * @summary Test case where we had escape analysis tell us that we can possibly eliminate\n+ *          the array allocation, then MergeStores introduces a mismatched store, which\n+ *          the actual elimination does not verify for. That led to wrong results.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresAndAllocationElimination::test\n+ *                   -XX:CompileCommand=exclude,compiler.c2.TestMergeStoresAndAllocationElimination::dontinline\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-CICompileOSR\n+ *                   compiler.c2.TestMergeStoresAndAllocationElimination\n+ * @run main compiler.c2.TestMergeStoresAndAllocationElimination\n+ *\/\n+\n+public class TestMergeStoresAndAllocationElimination {\n+    static void dontinline() {}\n+\n+    static int test(boolean flag) {\n+        int[] arr = new int[4];\n+        \/\/ The values below will be caputured as \"raw stores\" in the Initialize\n+        \/\/ of the array allocation above.\n+        \/\/ These stores are for cosmetics only, we set the \"1\" bits so that it is\n+        \/\/ simple to track where values are coming from.\n+        arr[0] = 0x0001_0000;\n+        arr[1] = 0x0010_0000;\n+        arr[2] = 0x0000_0100;\n+        arr[3] = 0x0100_0000;\n+        \/\/ So far, the result should be:\n+        \/\/ 0x421_0300\n+\n+        \/\/ The call below prevents further assignments from being captured into\n+        \/\/ the Initialize above.\n+        dontinline();\n+        \/\/ The follwoing stores are eventually optimized by MergeStores, and create\n+        \/\/ a mismatched StoreL.\n+        arr[0] = 0x0000_0001;\n+        arr[1] = 0x0000_0010;\n+        \/\/ Now, the result should be:\n+        \/\/ 0x400_0321\n+\n+        \/\/ We create an uncommon trap because of an \"unstable if\".\n+        \/\/ If Escape Analysis were to work, it would try to capture the values\n+        \/\/ from the StoreL above. But because it is mismatched, it should fail.\n+        \/\/ What happened before that verification: we would take the ConL, and\n+        \/\/ insert it in a list of ConI. That meant that we eventually applied\n+        \/\/ that value wrong if the deopt was taken (flag = true).\n+        \/\/\n+        \/\/ What happened when the deopt got the wrong values: It got these values:\n+        \/\/ [0]=68719476737 = 0x10_0000_0001 -> long value, not correct\n+        \/\/ [1]=1048576     =      0x10_0000 -> this entry is not updated!\n+        \/\/ [2]=256         =          0x100\n+        \/\/ [3]=16777216    =     0x100_0000\n+        \/\/\n+        \/\/ This is serialized as a long and 3 ints, and that looks like 5 ints.\n+        \/\/ This creates an array of 5 elements (and not 4):\n+        \/\/ [0]             =            0x1\n+        \/\/ [1]             =           0x10\n+        \/\/ [2]             =      0x10_0000 -> this entry is \"inserted\"\n+        \/\/ [3]             =          0x100\n+        \/\/ [4]             =     0x100_0000\n+        \/\/\n+        \/\/ This creates the wrong state:\n+        \/\/ 0x30_0421\n+        \/\/ And we can actually read that the arr.length is 5, below.\n+        if (flag) { System.out.println(\"unstable if: \" + arr.length); }\n+\n+        \/\/ Delay the allocation elimination until after loop opts, so that it\n+        \/\/ happens after MergeStores. Without this, we would immediately\n+        \/\/ eliminate the allocation during Escape Analysis, and then MergeStores\n+        \/\/ would not find the stores that would be removed with the allocation.\n+        for (int i = 0; i < 10_000; i++) {\n+            arr[3] = 0x0000_1000;\n+        }\n+        \/\/ Coming from the correct value, we should have transition of state:\n+        \/\/ 0x400_0321 -> 0x4321\n+        \/\/ But coming from the bad (rematerialized) state, we transition:\n+        \/\/ 0x30_0421 -> 0x30_4021\n+\n+        \/\/ Tag each entry with an index number\n+        \/\/ We expect: 0x4321\n+        return 1 * arr[0] + 2 * arr[1] + 3 * arr[2] + 4 * arr[3];\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Capture interpreter result.\n+        int gold = test(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test(false);\n+        int res1 = test(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" + Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresAndAllocationElimination.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8350896\n+ * @bug 8350896 8370459\n@@ -65,2 +65,4 @@\n-    public final int BOUND_LO_I = GEN_I.next();\n-    public final int BOUND_HI_I = GEN_I.next();\n+    public final int BOUND1_LO_I = GEN_I.next();\n+    public final int BOUND2_LO_I = GEN_I.next();\n+    public final int BOUND1_HI_I = GEN_I.next();\n+    public final int BOUND2_HI_I = GEN_I.next();\n@@ -68,2 +70,4 @@\n-    public final long BOUND_LO_L = GEN_L.next();\n-    public final long BOUND_HI_L = GEN_L.next();\n+    public final long BOUND1_LO_L = GEN_L.next();\n+    public final long BOUND2_LO_L = GEN_L.next();\n+    public final long BOUND1_HI_L = GEN_L.next();\n+    public final long BOUND2_HI_L = GEN_L.next();\n@@ -330,1 +334,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -363,1 +368,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -414,1 +420,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -447,1 +454,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -498,1 +506,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -531,1 +540,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -582,1 +592,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -615,1 +626,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -664,0 +676,84 @@\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public static long test20(int x) {\n+        \/\/ Analysis of when this is used to produce wrong results on Windows:\n+        \/\/\n+        \/\/ src  = -2683206580L = ffff_ffff_6011_844c\n+        \/\/ mask = 0..maxuint, at runtime: 4294950911 = 0xffff_bfff\n+        \/\/\n+        \/\/ Hence we go to the B) case of CompressBits in bitshuffle_value\n+        \/\/\n+        \/\/ mask_bit_width = 64\n+        \/\/ clz = 32\n+        \/\/ result_bit_width = 32\n+        \/\/\n+        \/\/ So we have result_bit_width < mask_bit_width\n+        \/\/\n+        \/\/ And we do:\n+        \/\/ lo = result_bit_width == mask_bit_width ? lo : 0L;\n+        \/\/ -> lo = 0\n+        \/\/\n+        \/\/ And we do:\n+        \/\/ hi = MIN2((jlong)((1UL << result_bit_width) - 1L), hi);\n+        \/\/\n+        \/\/ But watch out: on windows 1UL is only a 32 bit value. Intended was probably 1ULL.\n+        \/\/ So when we calculate \"1UL << 32\", we just get 1. And so then hi would be 0 now.\n+        \/\/ If we instead did \"1ULL << 32\", we would get 0x1_0000_0000, and hi = 0xffff_ffff.\n+        \/\/\n+        \/\/ We create type [lo, hi]:\n+        \/\/ Windows: [0, 0]           -> constant zero\n+        \/\/ correct:  [0, 0xffff_ffff] -> does not constant fold. At runtime: 0x3008_c44c\n+        return Long.compress(-2683206580L, Integer.toUnsignedLong(x));\n+    }\n+\n+    @DontCompile\n+    public static long test20_interpreted(int x) {\n+        return Long.compress(-2683206580L, Integer.toUnsignedLong(x));\n+    }\n+\n+    @Run (test = \"test20\")\n+    public void run20() {\n+        for (int i = 0; i < 100; i++) {\n+            int arg = GEN_I.next();\n+\n+            long actual = test20(arg);\n+            long expected = test20_interpreted(arg);\n+            Asserts.assertEQ(actual, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public static long test21(long x) {\n+        \/\/ Analysis of when this is used to produce wrong results on Windows:\n+        \/\/\n+        \/\/ Very similar to case in test20, but this time we go into the A) case.\n+        \/\/\n+        \/\/ maskcon = 0xffff_ffff\n+        \/\/ bitcount = 32\n+        \/\/\n+        \/\/ And now the problematic part:\n+        \/\/ hi = (1UL << bitcount) - 1;\n+        \/\/\n+        \/\/ On Windows, this becomes 0 (but it should be 0xffff_ffff).\n+        \/\/ Hence, the range wrongly collapses to [0, 0], and the CompressBits node\n+        \/\/ is wrongly replaced with a zero constant.\n+        return Long.compress(x, 0xffff_ffffL);\n+    }\n+\n+    @DontCompile\n+    public static long test21_interpreted(long x) {\n+        return Long.compress(x, 0xffff_ffffL);\n+    }\n+\n+    @Run (test = \"test21\")\n+    public void run21() {\n+        for (int i = 0; i < 100; i++) {\n+            int arg = GEN_I.next();\n+\n+            long actual = test21(arg);\n+            long expected = test21_interpreted(arg);\n+            Asserts.assertEQ(actual, expected);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":109,"deletions":13,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+            \"testShiftOfSubConstant\",\n@@ -125,0 +126,1 @@\n+        Asserts.assertEQ(((1 - a) << 1) + 1, testShiftOfSubConstant(a));\n@@ -362,1 +364,1 @@\n-    public void testStoreShort(int x) {\n+    public void testStoreShort1(int x) {\n@@ -369,1 +371,1 @@\n-    public void testStoreByte(int x) {\n+    public void testStoreByte1(int x) {\n@@ -373,0 +375,28 @@\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreShort2(int x) {\n+        shortField = (short)(x + 1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreByte2(int x) {\n+        byteField = (byte)(x + 1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreShort3(int x) {\n+        shortField = (short)(1 - x);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_I, \"1\"} , failOn = { IRNode.LSHIFT_I, IRNode.RSHIFT_I } )\n+    @Arguments( values = { Argument.NUMBER_42 })\n+    public void testStoreByte3(int x) {\n+        byteField = (byte)(1 - x);\n+    }\n+\n@@ -412,0 +442,6 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\",  IRNode.SUB_I, \"1\" }, failOn =  { IRNode.ADD_I })\n+    public int testShiftOfSubConstant(int x) {\n+        return ((1 - x) << 1) + 1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+            \"testShiftOfSubConstant\",\n@@ -121,0 +122,1 @@\n+        Asserts.assertEQ(((1L - a) << 1) + 1, testShiftOfSubConstant(a));\n@@ -361,0 +363,6 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\",  IRNode.SUB_L, \"1\" }, failOn =  { IRNode.ADD_L })\n+    public long testShiftOfSubConstant(long x) {\n+        return ((1 - x) << 1) + 1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -149,0 +149,9 @@\n+    \/\/    I for I\n+    private int cmoveIEQforI(int a, int b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveINEforI(int a, int b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -153,0 +162,21 @@\n+    private int cmoveIGEforI(int a, int b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveILTforI(int a, int b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveILEforI(int a, int b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for L\n+    private long cmoveIEQforL(int a, int b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveINEforL(int a, int b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -157,0 +187,21 @@\n+    private long cmoveIGEforL(int a, int b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveILTforL(int a, int b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveILEforL(int a, int b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for F\n+    private float cmoveIEQforF(int a, int b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveINEforF(int a, int b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -161,0 +212,21 @@\n+    private float cmoveIGEforF(int a, int b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveILTforF(int a, int b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveILEforF(int a, int b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    I for D\n+    private double cmoveIEQforD(int a, int b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveINEforD(int a, int b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -165,0 +237,21 @@\n+    private double cmoveIGEforD(int a, int b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveILTforD(int a, int b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveILEforD(int a, int b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for I\n+    private int cmoveLEQforI(long a, long b, int c, int d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private int cmoveLNEforI(long a, long b, int c, int d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -169,0 +262,21 @@\n+    private int cmoveLGEforI(long a, long b, int c, int d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private int cmoveLLTforI(long a, long b, int c, int d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private int cmoveLLEforI(long a, long b, int c, int d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for L\n+    private long cmoveLEQforL(long a, long b, long c, long d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private long cmoveLNEforL(long a, long b, long c, long d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -173,0 +287,21 @@\n+    private long cmoveLGEforL(long a, long b, long c, long d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private long cmoveLLTforL(long a, long b, long c, long d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private long cmoveLLEforL(long a, long b, long c, long d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for F\n+    private float cmoveLEQforF(long a, long b, float c, float d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private float cmoveLNEforF(long a, long b, float c, float d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -177,0 +312,21 @@\n+    private float cmoveLGEforF(long a, long b, float c, float d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private float cmoveLLTforF(long a, long b, float c, float d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private float cmoveLLEforF(long a, long b, float c, float d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n+    \/\/    L for D\n+    private double cmoveLEQforD(long a, long b, double c, double d) {\n+        return (a == b) ? c : d;\n+    }\n+\n+    private double cmoveLNEforD(long a, long b, double c, double d) {\n+        return (a != b) ? c : d;\n+    }\n+\n@@ -181,0 +337,12 @@\n+    private double cmoveLGEforD(long a, long b, double c, double d) {\n+        return (a >= b) ? c : d;\n+    }\n+\n+    private double cmoveLLTforD(long a, long b, double c, double d) {\n+        return (a < b) ? c : d;\n+    }\n+\n+    private double cmoveLLEforD(long a, long b, double c, double d) {\n+        return (a <= b) ? c : d;\n+    }\n+\n@@ -183,0 +351,8 @@\n+    private int cmoveUIEQforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveUINEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -200,0 +376,8 @@\n+    private long cmoveUIEQforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveUINEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -217,0 +401,8 @@\n+    private float cmoveUIEQforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveUINEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -234,0 +426,8 @@\n+    private double cmoveUIEQforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveUINEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -251,0 +451,8 @@\n+    private int cmoveULEQforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private int cmoveULNEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -268,0 +476,8 @@\n+    private long cmoveULEQforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private long cmoveULNEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -285,0 +501,8 @@\n+    private float cmoveULEQforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private float cmoveULNEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -302,0 +526,8 @@\n+    private double cmoveULEQforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) == 0 ? c : d;\n+    }\n+\n+    private double cmoveULNEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) != 0 ? c : d;\n+    }\n+\n@@ -738,0 +970,1 @@\n+    \/\/     I fo I\n@@ -740,1 +973,1 @@\n-    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -745,1 +978,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n@@ -751,17 +984,1 @@\n-    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            long cc = c[i];\n-            long dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -769,2 +986,2 @@\n-            float cc = c[i];\n-            float dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -772,1 +989,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n@@ -778,1 +995,1 @@\n-    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+    private static void testCMoveIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -780,2 +997,2 @@\n-            double cc = c[i];\n-            double dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -789,1 +1006,1 @@\n-    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -794,1 +1011,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n@@ -800,1 +1017,1 @@\n-    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    private static void testCMoveILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -802,2 +1019,2 @@\n-            long cc = c[i];\n-            long dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -805,1 +1022,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n@@ -811,1 +1028,1 @@\n-    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n@@ -813,19 +1030,2 @@\n-            float cc = c[i];\n-            float dd = d[i];\n-            r2[i] = cc + dd;\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n-                  IRNode.STORE_VECTOR, \">0\"},\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n-    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n-        for (int i = 0; i < a.length; i++) {\n-            double cc = c[i];\n-            double dd = d[i];\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -833,1 +1033,1 @@\n-            r[i] = (a[i] > b[i]) ? cc : dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n@@ -837,2 +1037,1 @@\n-    \/\/ Unsigned comparison: I\/L\n-    \/\/     I fo I\n+    \/\/     I fo L\n@@ -841,1 +1040,1 @@\n-    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -843,2 +1042,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -846,1 +1045,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n@@ -852,1 +1051,1 @@\n-    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -854,2 +1053,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -857,1 +1056,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n@@ -863,1 +1062,1 @@\n-    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -865,2 +1064,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -868,1 +1067,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n@@ -874,1 +1073,1 @@\n-    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+    private static void testCMoveIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -876,2 +1075,2 @@\n-            int cc = c[i];\n-            int dd = d[i];\n+            long cc = c[i];\n+            long dd = d[i];\n@@ -879,1 +1078,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n@@ -883,1 +1082,0 @@\n-    \/\/     I fo L\n@@ -886,1 +1084,1 @@\n-    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    private static void testCMoveILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -891,1 +1089,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n@@ -897,1 +1095,1 @@\n-    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    private static void testCMoveILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n@@ -902,1 +1100,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n@@ -906,0 +1104,1 @@\n+    \/\/     I fo F\n@@ -907,2 +1106,7 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -910,2 +1114,2 @@\n-            long cc = c[i];\n-            long dd = d[i];\n+            float cc = c[i];\n+            float dd = d[i];\n@@ -913,1 +1117,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n@@ -918,2 +1122,7 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n-    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -921,2 +1130,2 @@\n-            long cc = c[i];\n-            long dd = d[i];\n+            float cc = c[i];\n+            float dd = d[i];\n@@ -924,1 +1133,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n@@ -928,1 +1137,0 @@\n-    \/\/     I fo F\n@@ -936,1 +1144,1 @@\n-    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -941,1 +1149,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n@@ -952,1 +1160,1 @@\n-    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -957,1 +1165,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n@@ -968,1 +1176,1 @@\n-    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -973,1 +1181,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n@@ -984,1 +1192,1 @@\n-    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+    private static void testCMoveILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n@@ -989,1 +1197,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n@@ -996,1 +1204,1 @@\n-    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+    private static void testCMoveIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n@@ -1001,1 +1209,626 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo F\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveLLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo D\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] == b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] != b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] >= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] < b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveLLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] <= b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/     I fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIEQforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUINEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIEQforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUINEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo F\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIEQforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUINEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo D\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIEQforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUINEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n@@ -1031,2 +1864,25 @@\n-            double cc = c[i];\n-            double dd = d[i];\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULEQforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULNEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n@@ -1034,1 +1890,1 @@\n-            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n@@ -1038,1 +1894,0 @@\n-    \/\/     L fo I\n@@ -1084,0 +1939,22 @@\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULEQforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULNEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -1129,0 +2006,22 @@\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULEQforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULNEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -1174,0 +2073,34 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULEQforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) == 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULNEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) != 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -1526,0 +2459,3 @@\n+                 \/\/     I for I\n+                 \"testCMoveIEQforI\",\n+                 \"testCMoveINEforI\",\n@@ -1527,0 +2463,6 @@\n+                 \"testCMoveIGEforI\",\n+                 \"testCMoveILTforI\",\n+                 \"testCMoveILEforI\",\n+                 \/\/     I for L\n+                 \"testCMoveIEQforL\",\n+                 \"testCMoveINEforL\",\n@@ -1528,0 +2470,6 @@\n+                 \"testCMoveIGEforL\",\n+                 \"testCMoveILTforL\",\n+                 \"testCMoveILEforL\",\n+                 \/\/     I for F\n+                 \"testCMoveIEQforF\",\n+                 \"testCMoveINEforF\",\n@@ -1529,0 +2477,6 @@\n+                 \"testCMoveIGEforF\",\n+                 \"testCMoveILTforF\",\n+                 \"testCMoveILEforF\",\n+                 \/\/     I for D\n+                 \"testCMoveIEQforD\",\n+                 \"testCMoveINEforD\",\n@@ -1530,0 +2484,6 @@\n+                 \"testCMoveIGEforD\",\n+                 \"testCMoveILTforD\",\n+                 \"testCMoveILEforD\",\n+                 \/\/     L for I\n+                 \"testCMoveLEQforI\",\n+                 \"testCMoveLNEforI\",\n@@ -1531,0 +2491,6 @@\n+                 \"testCMoveLGEforI\",\n+                 \"testCMoveLLTforI\",\n+                 \"testCMoveLLEforI\",\n+                 \/\/     L for L\n+                 \"testCMoveLEQforL\",\n+                 \"testCMoveLNEforL\",\n@@ -1532,0 +2498,6 @@\n+                 \"testCMoveLGEforL\",\n+                 \"testCMoveLLTforL\",\n+                 \"testCMoveLLEforL\",\n+                 \/\/     L for F\n+                 \"testCMoveLEQforF\",\n+                 \"testCMoveLNEforF\",\n@@ -1533,0 +2505,6 @@\n+                 \"testCMoveLGEforF\",\n+                 \"testCMoveLLTforF\",\n+                 \"testCMoveLLEforF\",\n+                 \/\/     L for D\n+                 \"testCMoveLEQforD\",\n+                 \"testCMoveLNEforD\",\n@@ -1534,0 +2512,3 @@\n+                 \"testCMoveLGEforD\",\n+                 \"testCMoveLLTforD\",\n+                 \"testCMoveLLEforD\",\n@@ -1536,0 +2517,2 @@\n+                 \"testCMoveUIEQforI\",\n+                 \"testCMoveUINEforI\",\n@@ -1541,0 +2524,2 @@\n+                 \"testCMoveUIEQforL\",\n+                 \"testCMoveUINEforL\",\n@@ -1546,0 +2531,2 @@\n+                 \"testCMoveUIEQforF\",\n+                 \"testCMoveUINEforF\",\n@@ -1551,0 +2538,2 @@\n+                 \"testCMoveUIEQforD\",\n+                 \"testCMoveUINEforD\",\n@@ -1556,0 +2545,2 @@\n+                 \"testCMoveULEQforI\",\n+                 \"testCMoveULNEforI\",\n@@ -1561,0 +2552,2 @@\n+                 \"testCMoveULEQforL\",\n+                 \"testCMoveULNEforL\",\n@@ -1566,0 +2559,2 @@\n+                 \"testCMoveULEQforF\",\n+                 \"testCMoveULNEforF\",\n@@ -1571,0 +2566,2 @@\n+                 \"testCMoveULEQforD\",\n+                 \"testCMoveULNEforD\",\n@@ -1626,0 +2623,11 @@\n+        \/\/     I for I\n+        testCMoveIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n@@ -1631,0 +2639,26 @@\n+        testCMoveIGEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveIGEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveILEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveILEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     I for L\n+        testCMoveIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n@@ -1636,0 +2670,26 @@\n+        testCMoveIGEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveIGEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveILEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveILEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     I for F\n+        testCMoveIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n@@ -1641,0 +2701,26 @@\n+        testCMoveIGEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveIGEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveILEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveILEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     I for D\n+        testCMoveIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n@@ -1646,0 +2732,26 @@\n+        testCMoveIGEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveIGEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveILEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveILEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/     L for I\n+        testCMoveLEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n@@ -1651,0 +2763,26 @@\n+        testCMoveLGEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLGEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveLLEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveLLEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     L for L\n+        testCMoveLEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n@@ -1656,0 +2794,26 @@\n+        testCMoveLGEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLGEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveLLEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveLLEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     L for F\n+        testCMoveLEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n@@ -1661,0 +2825,26 @@\n+        testCMoveLGEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLGEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveLLEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveLLEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     L for D\n+        testCMoveLEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n@@ -1666,0 +2856,15 @@\n+        testCMoveLGEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLGEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveLLEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveLLEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n@@ -1668,0 +2873,10 @@\n+        testCMoveUIEQforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIEQforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUINEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUINEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n@@ -1689,0 +2904,10 @@\n+        testCMoveUIEQforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIEQforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUINEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUINEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n@@ -1710,0 +2935,10 @@\n+        testCMoveUIEQforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIEQforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUINEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUINEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n@@ -1731,0 +2966,10 @@\n+        testCMoveUIEQforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIEQforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUINEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUINEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n@@ -1752,0 +2997,10 @@\n+        testCMoveULEQforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULEQforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULNEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULNEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n@@ -1773,0 +3028,10 @@\n+        testCMoveULEQforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULEQforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULNEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULNEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n@@ -1794,0 +3059,10 @@\n+        testCMoveULEQforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULEQforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULNEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULNEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n@@ -1815,0 +3090,10 @@\n+        testCMoveULEQforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULEQforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULNEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULNEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":1385,"deletions":100,"binary":false,"changes":1485,"status":"modified"},{"patch":"@@ -51,3 +51,7 @@\n-    analyzer.shouldContain(\"++++ Eliminated: 26 Allocate\");\n-    analyzer.shouldContain(\"++++ Eliminated: 48 Allocate\");\n-    analyzer.shouldContain(\"++++ Eliminated: 78 Allocate\");\n+    analyzer.shouldMatch(\n+            \"(?s)\" + \/\/ Let .* also match line terminators.\n+            \"Eliminated: \\\\d+ Allocate\" +\n+            \".*\" +\n+            \"Eliminated: \\\\d+ Allocate\" +\n+            \".*\" +\n+            \"Eliminated: \\\\d+ Allocate\");\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestIterativeEA.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=yEA\n+ * @bug 8370405\n+ * @summary Test elimination of array allocation, and the rematerialization.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.escapeAnalysis.TestRematerializeObjects yEA\n+ *\/\n+\n+\/*\n+ * @test id=nEA\n+ * @library \/test\/lib \/\n+ * @run driver compiler.escapeAnalysis.TestRematerializeObjects nEA\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+\n+public class TestRematerializeObjects {\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestRematerializeObjects.class);\n+        switch (args[0]) {\n+            case \"yEA\" -> { framework.addFlags(\"-XX:+EliminateAllocations\"); }\n+            case \"nEA\" -> { framework.addFlags(\"-XX:-EliminateAllocations\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n+    }\n+\n+    @DontInline\n+    static void dontinline() {}\n+\n+    @Run(test = \"test1\", mode = RunMode.STANDALONE)\n+    public void runTest1() {\n+        \/\/ Capture interpreter result.\n+        int gold = test1(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test1(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test1(false);\n+        int res1 = test1(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\[int:4\\\\]\", \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\[int:4\\\\]\", \"0\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test1(boolean flag) {\n+        int[] arr = new int[4];\n+        arr[0] = 0x0001_0000; \/\/ these slip into Initialize\n+        arr[1] = 0x0010_0000;\n+        arr[2] = 0x0000_0100;\n+        arr[3] = 0x0100_0000;\n+        dontinline();\n+        arr[0] = 0x0000_0001; \/\/ MergeStores -> StoreL\n+        arr[1] = 0x0000_0010;\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 0x0000_1000;\n+        return 1 * arr[0] + 2 * arr[1] + 3 * arr[2] + 4 * arr[3];\n+    }\n+\n+    @Run(test = \"test2\", mode = RunMode.STANDALONE)\n+    public void runTest2() {\n+        \/\/ Capture interpreter result.\n+        int gold = test2(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test2(false);\n+        int res1 = test2(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\[int:4\\\\]\", \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\[int:4\\\\]\", \"0\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test2(boolean flag) {\n+        short[] arr = new short[4];\n+        arr[0] = 1;\n+        arr[1] = 2;\n+        arr[2] = 4;\n+        arr[3] = 8;\n+        dontinline();\n+        \/\/ Seems we detect that this is a short value passed into the short field.\n+        arr[0] = 16;\n+        arr[1] = 32;\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 64;\n+        return 0x1 * arr[0] + 0x100 * arr[1] + 0x1_0000 * arr[2] + 0x100_0000 * arr[3];\n+    }\n+\n+    @Run(test = \"test3\", mode = RunMode.STANDALONE)\n+    public void runTest3() {\n+        \/\/ Capture interpreter result.\n+        int gold = test3(false, 42);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test3(false, 42);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test3(false, 42);\n+        int res1 = test3(true, 42);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test3(boolean flag, int x) {\n+        short[] arr = new short[4];\n+        arr[0] = 1;\n+        arr[1] = 2;\n+        arr[2] = 4;\n+        arr[3] = 8;\n+        dontinline();\n+        \/\/ Here, we don't get ConI, but instead AddI, which means we are\n+        \/\/ serializing an int value, for a short slot.\n+        arr[0] = (short)(x + 1);\n+        arr[1] = (short)(x + 2);\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 64;\n+        return 0x1 * arr[0] + 0x100 * arr[1] + 0x1_0000 * arr[2] + 0x100_0000 * arr[3];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestRematerializeObjects.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -1959,0 +1959,5 @@\n+    public static final String SAFEPOINT_SCALAROBJECT_OF = COMPOSITE_PREFIX + \"SAFEPOINT_SCALAROBJECT_OF\" + POSTFIX;\n+    static {\n+        safepointScalarobjectOfNodes(SAFEPOINT_SCALAROBJECT_OF, \"SafePointScalarObject\");\n+    }\n+\n@@ -3274,0 +3279,5 @@\n+    private static void safepointScalarobjectOfNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + \".*\" + IS_REPLACED + \".*\" + END;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=with-flags\n+ * @bug 8370332\n+ * @summary This test shows a case where split_if split a node through a phi, but left the\n+ *          dead node and a dead phi in the loop _body. Subsequently, SuperWord was run, and\n+ *          found the dead nodes in the _body, which is not expected.\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,*TestSplitThruPhiRemoveDeadNodesFromLoopBody::test\n+ *      -Xbatch\n+ *      compiler.loopopts.superword.TestSplitThruPhiRemoveDeadNodesFromLoopBody\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8370332\n+ * @run main compiler.loopopts.superword.TestSplitThruPhiRemoveDeadNodesFromLoopBody\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestSplitThruPhiRemoveDeadNodesFromLoopBody {\n+    static int N = 400;\n+    static float floatZero = 0;\n+    static boolean falseFlag = false;;\n+\n+    static int fieldStore = 0;\n+    static int fieldIncr = 0;\n+    static int arrayI[] = new int[N];\n+\n+    static void inlined() {\n+        int x = 0;\n+        for (int i = 0; i < 100; i++) {\n+            fieldStore = 42;\n+            if (falseFlag) {\n+                for (int k = 0; k < 20; k++) {\n+                    x += i;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test() {\n+        inlined();\n+        for (int k = 0; k < 10; k++) {\n+            for (int j = 0; j < 100; j++) {\n+                fieldIncr += floatZero;\n+                arrayI[j] = 42; \/\/ SuperWord happens here -> SIGSEGV\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 1_000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSplitThruPhiRemoveDeadNodesFromLoopBody.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361608\n+ * @summary crash during unrolling in some rare cases where loop cloning\n+ *          (typically from peeling) breaks an invariant in do_unroll\n+ *\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+StressLoopPeeling\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test1\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test2\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::foo2\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main\/othervm -XX:CompileOnly=compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::test3\n+ *                   -XX:-TieredCompilation\n+ *                   -Xbatch\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=inline,compiler.loopopts.TooStrictAssertForUnrollAfterPeeling::foo3\n+ *                   -XX:-RangeCheckElimination\n+ *                   compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\n+ * @run main compiler.loopopts.TooStrictAssertForUnrollAfterPeeling\n+ *\/\n+package compiler.loopopts;\n+\n+\n+\/* Cases 2 and 3 can use the additional flags\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:-LoopMultiversioning\n+ *   -XX:-RangeCheckElimination\n+ *   -XX:-SplitIfBlocks\n+ *   -XX:-UseOnStackReplacement\n+ *   -XX:LoopMaxUnroll=2\n+ * to disable more optimizations and give a simpler graph, while still reproducing. It can be useful to debug, investigate...\n+ *\/\n+public class TooStrictAssertForUnrollAfterPeeling {\n+    static int iArr[] = new int[400];\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        run1();\n+        run2();\n+        run3();\n+    }\n+\n+    \/\/ Case 1\n+\n+    public static void run1() {\n+        for (int i = 1; i < 1000; i++) {\n+            test1();\n+        }\n+    }\n+\n+    static long test1() {\n+        int s = 0;\n+        int iArr[] = new int[400];\n+        for (int i = 0; i < 70; i++) {}\n+\n+        for (int i = 0; i < 36; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                s += iArr[0] = 7;\n+                if (s != 0) {\n+                    return s + foo1(iArr);\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    public static long foo1(int[] a) {\n+        long sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Case 2\n+\n+    public static void run2() {\n+        for (int i = 1; i < 10000; i++) {\n+            test2();\n+        }\n+    }\n+\n+    \/\/ Lx: Optimized in loop opts round x.\n+\n+    static int test2() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {\n+                } \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo2(iArr);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo2(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {\n+            } \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    public static void run3() {\n+        for (int i = 1; i < 10000; i++) {\n+            test3();\n+        }\n+    }\n+\n+    \/\/ Case 3\n+\n+    static int test3() {\n+        int x = 5;\n+        for (int i = 1; i < 37; i++) { \/\/ L3: Peeled\n+            for (int a = 0; a < 2; a++) { \/\/ L2: Max unrolled\n+                for (int b = 0; b < 300; b++) {\n+                } \/\/ L1: Empty -> removed\n+            }\n+            int j = 1;\n+            x *= 12;\n+            while (++j < 5) { \/\/ L1: Max unrolled: peel + unroll\n+                iArr[0] += 2;\n+                if (iArr[0] > 0) {\n+                    \/\/ foo(): everything outside loop.\n+                    return foo3(iArr, x);\n+                }\n+            }\n+        }\n+        return 3;\n+    }\n+\n+    public static int foo3(int[] a, int limit) {\n+        int sum = 0;\n+        for (int i = 0; i < limit; i++) { \/\/ L2: Pre\/main\/post, L3: Unrolled -> hit assert!\n+            for (int j = 0; j < 34; j++) {\n+            } \/\/ L1: Empty -> removed\n+            if (flag) {\n+                \/\/ Ensure not directly unrolled in L2 but only in L3.\n+                return 3;\n+            }\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TooStrictAssertForUnrollAfterPeeling.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.loopopts.superword;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n-\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @bug 8324751\n- * @summary Reported issue: JDK-8359688: C2 SuperWord: missing RCE with MemorySegment\n- *          The examples are generated from TestAliasingFuzzer.java\n- *          So if you see something change here, you may want to investigate if we\n- *          can also tighten up the IR rules there.\n- * @library \/test\/lib \/\n- * @run driver compiler.loopopts.superword.TestMemorySegment_8359688\n- *\/\n-\n-\n-public class TestMemorySegment_8359688 {\n-\n-    public static MemorySegment b = MemorySegment.ofArray(new long[4 * 30_000]);\n-\n-    public static void main(String[] args) {\n-        TestFramework f = new TestFramework();\n-        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n-        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n-                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n-        f.start();\n-    }\n-\n-    @Setup\n-    static Object[] setup() {\n-        return new Object[] { b, 0, 5_000, 0 };\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n-                  IRNode.REPLICATE_L,  \"= 0\",\n-                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Does not manage to remove all RangeChecks -> no vectorization\n-    \/\/ If you see this IR rule fail: investigate JDK-8359688, possibly close it and fix this IR rule!\n-    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n-    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n-    public static void test1(MemorySegment b, int ivLo, int ivHi, int invar) {\n-        for (int i = ivLo; i < ivHi; i++) {\n-            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 30_000L - (long)i + (long)invar, 42);\n-            \/\/                                                    ^ subtraction here\n-        }\n-    }\n-\n-    @Test\n-    @Arguments(setup = \"setup\")\n-    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n-                  IRNode.REPLICATE_L,  \"> 0\",\n-                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n-        phase = CompilePhase.PRINT_IDEAL,\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n-        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n-    \/\/ Is fully RFE'd and vectorized\n-    public static void test2(MemorySegment b, int ivLo, int ivHi, int invar) {\n-        for (int i = ivLo; i < ivHi; i++) {\n-            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 1_000L + 1L * i + (long)invar, 42);\n-            \/\/                                                   ^ addition here\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8359688.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751 8369435\n+ * @summary Reported issue: JDK-8359688: C2 SuperWord: missing RCE with MemorySegment\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_SubOfShift\n+ *\/\n+\n+\n+public class TestMemorySegment_SubOfShift {\n+\n+    public static MemorySegment b = MemorySegment.ofArray(new long[4 * 30_000]);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { b, 0, 5_000, 0 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_L,  \"= 1\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test1(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 30_000L - (long)i + (long)invar, 42);\n+            \/\/                                                    ^ subtraction here\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_L,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Is fully RFE'd and vectorized\n+    public static void test2(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 1_000L + 1L * i + (long)invar, 42);\n+            \/\/                                                   ^ addition here\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_SubOfShift.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327963\n+ * @summary C2: fix construction of memory graph around Initialize node to prevent incorrect execution if allocation is removed\n+ * @run main\/othervm -XX:-BackgroundCompilation compiler.macronodes.TestEarlyEliminationOfAllocationWithoutUse\n+ * @run main\/othervm compiler.macronodes.TestEarlyEliminationOfAllocationWithoutUse\n+ *\/\n+\n+package compiler.macronodes;\n+import java.util.Arrays;\n+\n+public class TestEarlyEliminationOfAllocationWithoutUse {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        boolean[] allTrue = new boolean[3];\n+        Arrays.fill(allTrue, true);\n+        A a = new A();\n+        boolean[] allFalse = new boolean[3];\n+        for (int i = 0; i < 20_000; i++) {\n+            a.field1 = 0;\n+            test1(a, allTrue);\n+            test1(a, allFalse);\n+            if (a.field1 != 42) {\n+                throw new RuntimeException(\"Lost Store\");\n+            }\n+        }\n+    }\n+\n+    private static void test1(A otherA, boolean[] flags) {\n+        otherA.field1 = 42;\n+        \/\/ Fully unrolled before EA\n+        for (int i = 0; i < 3; i++) {\n+            A a = new A(); \/\/ removed right after EA\n+            if (flags[i]) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    private static class A {\n+        int field1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEarlyEliminationOfAllocationWithoutUse.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Revealed issue where hook_memory_on_init links some array slice to the rawptr slice.\n+ *          Now that array slice depends on the rawslice. And then when the Initialize MemBar gets\n+ *          removed in expand_allocate_common, the rawslice sees that it has now no effect, looks\n+ *          through the MergeMem and sees the initial state. That way, also the linked array slice\n+ *          goes to the initial state, even if before the allocation there were stores on the array\n+ *          slice. This leads to a messed up memory graph, and missing stores in the generated code.\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.macronodes.TestEliminationOfAllocationWithoutUse::test*\n+ *                   compiler.macronodes.TestEliminationOfAllocationWithoutUse\n+ *\/\n+\n+package compiler.macronodes;\n+\n+public class TestEliminationOfAllocationWithoutUse {\n+\n+    static public void main(String[] args) {\n+        int failures = 0;\n+        failures += run1();\n+        failures += run2();\n+        failures += run3();\n+        failures += run4();\n+        failures += run5();\n+        failures += run6();\n+        failures += run7();\n+        failures += run8();\n+        failures += run9();\n+        if (failures != 0) {\n+            throw new RuntimeException(\"Had test failures: \" + failures);\n+        }\n+    }\n+\n+    static public int run1() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        double[] arr2 = new double[size];\n+        test1(arr1, arr2);\n+\n+        double sum = 0;\n+        for (int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i] - arr2[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test1: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from JDK-8327012 regression test.\n+    public static void test1(double[] arr1, double[] arr2) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            \/\/ stores on double[] slice\n+            arr1[i] = (double)(i + 2);\n+            arr2[i] = (double)(i + 1);\n+            \/\/ Allocation without use: but Initialize MemBar tangles the rawptr and double[] slices\n+            double[] tmp = new double[100];\n+            \/\/ When the Initialize MemBar is removed, the rawptr slice sees that there is no effect\n+            \/\/ and takes the initial state. The double[] slice is hooked on to the rawptr slice, and\n+            \/\/ also thinks it has the initial state, ignoring the double[] stores above.\n+        }\n+    }\n+\n+    static public int run2() {\n+        int size = 10;\n+        double[] arr1 = new double[size];\n+        test2(arr1);\n+\n+        double sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != (double)(size)) {\n+            System.out.println(\"test2: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Simplified from test1\n+    public static void test2(double[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            double[] tmp = new double[100];\n+        }\n+    }\n+\n+    static public int run3() {\n+        int size = 10;\n+        int[] arr1 = new int[size];\n+        test3(arr1);\n+\n+        int sum = 0;\n+        for(int i = 0; i < arr1.length; ++i) {\n+            sum += arr1[i];\n+        }\n+\n+        if (sum != size) {\n+            System.out.println(\"test3: wrong result: \" + sum + \" vs expected: \" + size);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ Modified from test2\n+    public static void test3(int[] arr1) {\n+        for(int i = 0; i < arr1.length; ++i) {\n+            arr1[i] = 1;\n+            int[] tmp = new int[100];\n+        }\n+    }\n+\n+    \/\/ From TestIncorrectResult.java in JDK-8324739\n+    static int test4(int l2) {\n+       int[] tmp = new int[20];\n+\n+       for (int j = 0; j < l2; ++j) {\n+           tmp[j] = 42;\n+           int[] unused_but_necessary = new int[400];\n+       }\n+\n+       return tmp[0];\n+    }\n+\n+    public static int run4() {\n+        for (int i = 0; i < 100; ++i) {\n+            long res = test4(20);\n+\n+            if (res != 42) {\n+                System.out.println(\"test4: wrong result: \" + res + \" vs expected: 42\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336701\n+    static class Test5 {\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[400];\n+    }\n+\n+    static void test5() {\n+        long e;\n+        for (e = 1; e < 9; ++e) {\n+            Test5.staticArray[(int) e] -= e;\n+            synchronized (new Test5()) { }\n+        }\n+        for (int f = 0; f < 10000; ++f) ;\n+    }\n+\n+    static int run5() {\n+        new Test5();\n+        for (int i = 0; i < 1000; ++i) {\n+            test5();\n+        }\n+        if (Test5.staticArray[8] != -8000) {\n+            System.out.println(\"test5: wrong result: \" + Test5.staticArray[8] + \" vs expected: -8000\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8336293\n+    static class Test6 {\n+        static long c;\n+        static int a = 400;\n+        double[] b = new double[400];\n+    }\n+\n+    static void test6() {\n+        long d;\n+        double[] e = new double[Test6.a];\n+        for (int f = 0; f < e.length; f++)\n+            e[f] = 1.116242;\n+        d = 1;\n+        while (++d < 7)\n+            synchronized (new Test6()) { }\n+        long g = 0;\n+        for (int f = 0; f < e.length; f++)\n+            g += e[f];\n+        Test6.c += g;\n+    }\n+\n+    static int run6() {\n+        new Test6();\n+        for (int f = 0; f < 10000; ++f) {\n+            test6();\n+        }\n+        if (Test6.c != 4000000) {\n+            System.out.println(\"test6: wrong result: \" + Test6.c + \" vs expected: 4000000 \");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ From JDK-8327868\n+    static class Test7 {\n+        static int a = 400;\n+        int[] b = new int[400];\n+        static int[] staticArray = new int[a];\n+    }\n+\n+    static int test7() {\n+        int l, d = 3;\n+        for (l = 2; 58 > l; l++) {\n+            for (int e = 2; e < 8; e += 2)\n+                for (int f = 1; f < e; f += 2)\n+                    synchronized (new Test7()) {\n+                    }\n+            do\n+                ; while (d < 2);\n+            int g = 0;\n+            do\n+                g++;\n+            while (g < 20000);\n+            Test7.staticArray[1] -= 3023399;\n+        }\n+        int h = 0;\n+        for (int i = 0; i < Test7.staticArray.length; i++)\n+            h += Test7.staticArray[i];\n+        return h;\n+    }\n+\n+    static int run7() {\n+        new Test7();\n+        int res = test7();\n+        if (res != -169310344) {\n+            System.out.println(\"test7: wrong result: \" + res + \" vs expected: -169310344\");\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8329984\n+    static class Test8 {\n+        static int a = 400;\n+        int[] e = new int[400];\n+    }\n+\n+    static int test8() {\n+        int i = 22738;\n+        int b;\n+        int h;\n+        int[] c = new int[Test8.a];\n+        for (b = 3; b < 273; b++) {\n+            h = 1;\n+            while (++h < 97) switch (b % 6 + 56) {\n+                case 56:\n+                    c[1] = i;\n+                case 57:\n+                    synchronized (new Test8()) {}\n+            }\n+        }\n+        int k = 0;\n+        for (int j = 0; j < c.length; j++) k += c[j];\n+        return k;\n+    }\n+\n+    public static int run8() {\n+        new Test8();\n+        for (int i = 0; i < 20; i++) {\n+            int res = test8();\n+            if (res != 22738) {\n+                System.out.println(\"test8: wrong result: \" + res + \" vs expected: 22738\");\n+                return 1;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    \/\/ from JDK-8341009\n+   static class Test9 {\n+        static int a = 256;\n+        float[] b = new float[256];\n+        static long c;\n+    }\n+\n+  static void test9() {\n+    for (int f = 0; f < 10000; ++f) ;\n+    float[][] g = new float[Test9.a][Test9.a];\n+    for (int d = 7; d < 16; d++) {\n+      long e = 1;\n+      do {\n+        g[d][(int) e] = d;\n+        synchronized (new Test9()) {\n+        }\n+      } while (++e < 5);\n+    }\n+    for (int i = 0; i < Test9.a; ++i) {\n+      for (int j = 0; j < Test9.a ; ++j) {\n+          Test9.c += g[i][j];\n+      }\n+    }\n+  }\n+\n+  static int run9() {\n+    for (int j = 6; 116 > j; ++j) {\n+        test9();\n+    }\n+    if (Test9.c != 43560) {\n+        System.out.println(\"test9: wrong result: \" + Test9.c + \" vs expected: 43560\");\n+        return 1;\n+    }\n+    return 0;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestEliminationOfAllocationWithoutUse.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327012 8327963\n+ * @summary Test that initializing store gets captured, i.e. moved before the InitializeNode\n+ *          and made into a raw-store.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.macronodes.TestInitializingStoreCapturing\n+ *\/\n+\n+package compiler.macronodes;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestInitializingStoreCapturing {\n+\n+    static class A {\n+        float value;\n+        A(float v) { value = v; }\n+    };\n+\n+    static public void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static A testInitializeField() {\n+        return new A(4.2f);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_F, \"= 0\"})\n+    static float[] testInitializeArray() {\n+        return new float[] {4.2f};\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestInitializingStoreCapturing.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8325030\n+ * @bug 8325030 8362832\n","filename":"test\/hotspot\/jtreg\/compiler\/macronodes\/TestTopInMacroElimination.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n@@ -188,1 +189,1 @@\n-        applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n@@ -190,0 +191,6 @@\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_16, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"})\n@@ -203,1 +210,4 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"})\n+        applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">32\"})\n@@ -217,1 +227,4 @@\n-        applyIf = {\"MaxVectorSize\", \">=64\"})\n+        applyIf = {\"MaxVectorSize\", \"64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">64\"})\n@@ -251,1 +264,4 @@\n-        applyIf = {\"MaxVectorSize\", \">=16\"})\n+        applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"})\n@@ -265,1 +281,4 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"})\n+        applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">32\"})\n@@ -279,1 +298,4 @@\n-        applyIf = {\"MaxVectorSize\", \">=64\"})\n+        applyIf = {\"MaxVectorSize\", \"64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">64\"})\n@@ -312,1 +334,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -323,1 +351,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -334,1 +368,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"avx512f\", \"true\"},\n@@ -365,1 +405,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -376,1 +422,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -387,1 +439,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"avx512f\", \"true\"},\n@@ -410,1 +468,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -421,1 +485,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -432,1 +502,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"avx512f\", \"true\"},\n@@ -455,1 +531,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -466,1 +548,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"avx512vl\", \"true\"},\n@@ -477,1 +565,7 @@\n-        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8, \"0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"avx512f\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestSelectFromTwoVectorOp.java","additions":112,"deletions":18,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\n@@ -70,2 +71,9 @@\n-        run(pb);\n-\n+        \/\/ If we attempt to attach to LingeredApp before it has initialized, the heap dump request will fail, so we allow 3 tries\n+        int allowedTries = 3;\n+        int exitValue;\n+        do {\n+            exitValue = run(pb);\n+        } while ((exitValue != 0) && (allowedTries-- > 0));\n+        if (exitValue != 0) {\n+            throw new Exception(\"jmap -heap exited with error code: \" + exitValue);\n+        }\n@@ -79,1 +87,1 @@\n-    private static void run(ProcessBuilder pb) throws Exception {\n+    private static int run(ProcessBuilder pb) throws Exception {\n@@ -81,4 +89,1 @@\n-        int exitValue = output.getExitValue();\n-        if (exitValue != 0) {\n-            throw new Exception(\"jmap -heap exited with error code: \" + exitValue);\n-        }\n+        return output.getExitValue();\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n- * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -153,0 +153,13 @@\n+\/*\n+ * @test id=no-tlab-genshen\n+ * @summary Acceptance tests: collector can deal with retained objects\n+ * @key randomness\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\n+ *      -XX:-UseTLAB -XX:+ShenandoahVerify\n+ *      TestSieveObjects\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -115,2 +115,4 @@\n-    static final long HEAP_MB = 128;                           \/\/ adjust for test configuration above\n-    static final long TARGET_MB = Long.getLong(\"target\", 2_000); \/\/ 2 Gb allocation\n+    static final long HEAP_MB = 128;                                      \/\/ adjust for test configuration above\n+    static final long TARGET_MB = Long.getLong(\"target\", 2_000);          \/\/ 2 Gb allocation\n+    static final long ANTICIPATED_HUMONGOUS_WASTE_PER_ARRAY = 124_272;\n+\n@@ -162,1 +164,1 @@\n-        long mem = count * (16 + 4 * size);\n+        long mem = count * (16 + 4 * size + ANTICIPATED_HUMONGOUS_WASTE_PER_ARRAY);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\/\n+\n+\/*\n+ * @test\n+ * @summary Test that parsing a hidden class with max constant pool entries\n+ *          doesn't crash the VM when adding an entry for the hidden class name.\n+ *          Instead throws ClassFormatError.\n+ * @bug 8364360\n+ * @modules java.base\/jdk.internal.access\n+ *          java.base\/jdk.internal.reflect\n+ * @library \/testlibrary\/asm\n+ * @run main HiddenClassesTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import org.objectweb.asm.ClassWriter;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.V17;\n+\n+public class HiddenClassesTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        var cw = new ClassWriter(0);\n+        cw.visit(V17, ACC_PUBLIC, \"Hidden\", null, \"java\/lang\/Object\", null);\n+        \/\/ This magic number causes a constant pool index overflow with this asm generated class.\n+        int i = 0;\n+        while (i < 65535-1) {\n+            i = cw.newUTF8(Integer.toString(i));\n+        }\n+        try {\n+            MethodHandles.lookup().defineHiddenClass(cw.toByteArray(), false);\n+            throw new RuntimeException(\"Test Failed: ClassFormatError expected.\");\n+        } catch (ClassFormatError cfe) {\n+            String message = cfe.getMessage();\n+            if (message == null || !message.contains(\"Overflow in constant pool size for hidden class\")) {\n+                throw new RuntimeException(\"Test Failed: wrong ClassFormatError \" + message);\n+            }\n+            System.out.println(\"ClassFormatError thrown as expected. Message: \" + cfe.getMessage());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/HiddenClassesTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -33,1 +35,1 @@\n- * @run driver PrintVMInfoAtExitTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PrintVMInfoAtExitTest\n@@ -38,0 +40,2 @@\n+import jdk.test.whitebox.WhiteBox;\n+\n@@ -56,1 +60,8 @@\n-    output_detail.shouldContain(\"Java Heap (reserved=65536KB, committed=65536KB)\");\n+    WhiteBox wb = WhiteBox.getWhiteBox();\n+    if (wb.isAsanEnabled()) {\n+        \/\/ the reserved value can be influenced by asan\n+        output_detail.shouldContain(\"Java Heap (reserved=\");\n+        output_detail.shouldContain(\", committed=65536KB)\");\n+    } else {\n+        output_detail.shouldContain(\"Java Heap (reserved=65536KB, committed=65536KB)\");\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/PrintVMInfoAtExitTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+                                                                                    \"-XX:-CreateCoredumpOnCrash\",\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTPrintMallocSiteOfCorruptedMemory.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires test.thread.factory == null\n@@ -36,0 +37,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ThreadCountLimit.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/classpathtests\/EmptyClassInBootClassPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires os.maxMemory > 15g\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestLargeUTF8Length.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=vthread-deopt-c1\n+ * @summary Deoptimization test for virtual threads (C1)\n+ * @requires vm.continuations\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.opt.TieredStopAtLevel != 0\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   Deoptimization\n+ *\/\n+\n+\/**\n+ * @test id=vthread-deopt-c2\n+ * @summary Deoptimization test for virtual threads (C2)\n+ * @requires vm.continuations\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:-TieredCompilation\n+ *                   Deoptimization\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.Objects;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class Deoptimization {\n+    static final WhiteBox white_box = WhiteBox.getWhiteBox();\n+\n+    static class TestTask implements Runnable {\n+        CyclicBarrier start_barrier = null;\n+        AtomicInteger completed_number = new AtomicInteger(0);\n+\n+        public void reset(int barrier_parties) {\n+            start_barrier = new CyclicBarrier(barrier_parties);\n+            completed_number.set(0);\n+        }\n+\n+        public int getNumberWaiting() {\n+            return start_barrier.getNumberWaiting();\n+        }\n+\n+        public int getNumberCompleted() {\n+            return completed_number.get();\n+        }\n+\n+        public void await() throws BrokenBarrierException, InterruptedException {\n+            start_barrier.await();\n+        }\n+\n+        public void run() {\n+            try {\n+                await();\n+            } catch(BrokenBarrierException e) {\n+                return;\n+            } catch(InterruptedException e) {\n+                return;\n+            }\n+\n+            completed_number.getAndIncrement();\n+        }\n+    }\n+\n+    static void test(TestTask task, Method method, int vthreads_num) throws Exception {\n+        task.reset(vthreads_num + 1 \/* 1 for the main thread *\/);\n+\n+        Thread[] vthreads = new Thread[vthreads_num];\n+        for (int i = 0; i < vthreads_num; i++) {\n+            vthreads[i] = Thread.startVirtualThread(task);\n+        }\n+\n+        while (task.getNumberWaiting() != vthreads_num) {\n+            Thread.onSpinWait();\n+        }\n+\n+        if (method != null) {\n+            if (!white_box.isMethodCompiled(method, false)) {\n+                throw new Error(\"Unexpectedly, it is not compiled.\");\n+            }\n+\n+            white_box.deoptimizeMethod(method);\n+\n+            if (white_box.isMethodCompiled(method, false)) {\n+                throw new Error(\"Unexpectedly, it is compiled.\");\n+            }\n+        }\n+\n+        task.await();\n+\n+        for (int i = 0; i < vthreads_num; i++) {\n+            vthreads[i].join();\n+        }\n+\n+        if (task.getNumberCompleted() != vthreads_num) {\n+            throw new Error(\"Some threads didn't reach completion\");\n+        }\n+    }\n+\n+    static int getIntegerOption(String option_name) {\n+        Object option_object = white_box.getVMFlag(option_name);\n+        String option_string = Objects.toString(option_object);\n+        return Integer.parseInt(option_string);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int tiered_stop_at_level = getIntegerOption(\"TieredStopAtLevel\");\n+\n+        Method method_run = TestTask.class.getMethod(\"run\");\n+        white_box.testSetDontInlineMethod(method_run, true);\n+\n+        Method method_await = TestTask.class.getMethod(\"await\");\n+        white_box.testSetDontInlineMethod(method_await, true);\n+\n+        TestTask task = new TestTask();\n+\n+        \/\/ Warm-up\n+        test(task, null, 2);\n+\n+        white_box.enqueueMethodForCompilation(method_run, tiered_stop_at_level);\n+\n+        \/\/ Deoptimization test\n+        test(task, method_run, 10000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/Deoptimization.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -78,1 +78,0 @@\n-        analyzer.stderrShouldBeEmpty();\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/EarlyDynamicLoad\/EarlyDynamicLoad.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-        out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+        out.stderrShouldBeEmptyIgnoreVMWarnings();\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/RemovingUnixDomainSocketTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,1 +182,2 @@\n-        static final String macprivate_or_shared = \"(pvt|tsh|cow|p\/a)\";\n+        static final String macprivate_or_shared = \"(pvt|shr)\";\n+        static final String macmem = \"(pvt|tsh|cow|p\/a)\";\n@@ -190,2 +191,5 @@\n-            \/\/ we should see the hs-perf data file, and it should appear as shared as well as committed\n-            macOSbase + macprivate + space + someNumber + space + \".*\/.*\/hsperfdata_.*\"\n+            \/*\n+             * We should see the hs-perf data file, and it should appear as shared as well as committed.\n+             * In the jtreg tests this segment appears private.\n+             *\/\n+            macOSbase + macprivate_or_shared + space + someNumber + space + \".*\/.*\/hsperfdata_.*\"\n@@ -201,1 +205,1 @@\n-            macOSbase + macprivate_or_shared + space + someNumber + space + \"JAVAHEAP.*\",\n+            macOSbase + macmem + space + someNumber + space + \"JAVAHEAP.*\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test verifies that field access\/modification events are correctly posted from JNI.\n+ * @bug 8224852\n+ * @run main\/othervm\/native -agentlib:FieldEventsFromJNI FieldEventsFromJNI\n+ *\/\n+public class FieldEventsFromJNI {\n+\n+    private String accessField = \"accessFieldValue\";\n+    private String modifyField = \"modifyFieldValue\";\n+\n+    private native void enableEventsAndAccessField(int numOfEventsExpected, Thread eventThread);\n+    private native void enableEventsAndModifyField(int numOfEventsExpected, Thread eventThread);\n+\n+    void javaMethod(int numOfEventsExpected, Thread eventThread) {\n+        enableEventsAndAccessField(numOfEventsExpected, eventThread);\n+        enableEventsAndModifyField(numOfEventsExpected, eventThread);\n+    }\n+\n+    final static Object lock = new Object();\n+    volatile static boolean isAnotherThreadStarted = false;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"FieldEventsFromJNI\");\n+        \/\/ anotherThread doesn't access fields, it is needed only to\n+        \/\/ enable notification somewhere.\n+        Thread anotherThread = new Thread(() -> {\n+            isAnotherThreadStarted = true;\n+            synchronized(lock) {\n+                lock.notify();\n+            }\n+            while(!Thread.currentThread().isInterrupted()) {\n+                Thread.yield();\n+            }\n+        });\n+        synchronized(lock) {\n+            anotherThread.start();\n+            while (!isAnotherThreadStarted) {\n+                lock.wait();\n+            }\n+        }\n+\n+        FieldEventsFromJNI testObject = new FieldEventsFromJNI();\n+        \/\/ Enable events while the thread is in the same JNI call.\n+        testObject.javaMethod(1, Thread.currentThread());\n+        \/\/ Verify that field access from JNI doesn't fail if events are\n+        \/\/ not enaled on this thread.\n+        testObject.javaMethod(0, anotherThread);\n+        anotherThread.interrupt();\n+        anotherThread.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldEventsFromJNI\/FieldEventsFromJNI.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <inttypes.h>\n+#include <atomic>\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+\n+\/\/ The event counters are used to check events from different threads.\n+static std::atomic<jint> access_cnt{0};\n+static std::atomic<jint> modify_cnt{0};\n+\n+\n+static const char* TEST_CLASS_NAME    = \"LFieldEventsFromJNI;\";\n+\n+static const char* ACCESS_FIELD_NAME  = \"accessField\";\n+static const char* ACCESS_METHOD_NAME = \"enableEventsAndAccessField\";\n+static const char* MODIFY_FIELD_NAME  = \"modifyField\";\n+static const char* MODIFY_METHOD_NAME = \"enableEventsAndModifyField\";\n+\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+              jlocation location, jclass field_klass, jobject object, jfieldID field) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field access triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, ACCESS_METHOD_NAME) != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, ACCESS_FIELD_NAME) != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, TEST_CLASS_NAME) != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  access_cnt++;\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+                    jlocation location, jclass field_klass, jobject object, jfieldID field,\n+                    char signature_type, jvalue new_value) {\n+  char* m_name = get_method_name(jvmti, jni, method);\n+  LOG(\"The field modification triggered from method '%s'\\n\", m_name);\n+  if (strcmp(m_name, MODIFY_METHOD_NAME) != 0) {\n+    fatal(jni, \"The method's name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, m_name);\n+\n+  LOG(\"The location is %\" PRId64 \"\\n\", (int64_t)location);\n+  if (location != 0) {\n+    fatal(jni, \"The method's location should be 0 for jni call.\");\n+  }\n+\n+  char* f_name = get_field_name(jvmti, jni, field_klass, field);\n+  LOG(\"The field name '%s'\\n\", f_name);\n+  if (strcmp(f_name, MODIFY_FIELD_NAME) != 0) {\n+    fatal(jni, \"The access field is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, f_name);\n+\n+  char* obj_class_name = get_object_class_name(jvmti, jni, object);\n+  LOG(\"The object class '%s'\\n\", obj_class_name);\n+  if (strcmp(obj_class_name, TEST_CLASS_NAME) != 0) {\n+    fatal(jni, \"The fields's class name is incorrect.\");\n+  }\n+  deallocate(jvmti,jni, obj_class_name);\n+\n+  modify_cnt++;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **)&jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void)memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_field_access_events = true;\n+  capabilities.can_generate_field_modification_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void)memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int)sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+  return JNI_OK;\n+}\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_FieldEventsFromJNI_enableEventsAndAccessField(\n+    JNIEnv *jni, jobject self, jint numOfEventsExpected, jthread eventThread) {\n+\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToRead = jni->GetFieldID(cls, ACCESS_FIELD_NAME, \"Ljava\/lang\/String;\");\n+  if (fieldToRead == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  \/\/ Set watch and access field without returning to calling java code\n+  access_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+\n+  jstring jvalue = (jstring)jni->GetObjectField(self, fieldToRead);\n+\n+  err = jvmti_env->ClearFieldAccessWatch(cls, fieldToRead);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_ACCESS, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  const char* value_str = jni->GetStringUTFChars(jvalue, nullptr);\n+\n+  if (access_cnt != numOfEventsExpected) {\n+    char buffer[100];\n+    snprintf(buffer, sizeof(buffer),\n+        \"Incorrect field access count: %d. Should be %d.\",\n+        (int)access_cnt, numOfEventsExpected);\n+    fatal(jni, buffer);\n+  }\n+  jni->ReleaseStringUTFChars(jvalue, value_str);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_FieldEventsFromJNI_enableEventsAndModifyField(\n+    JNIEnv *jni, jobject self, jint numOfEventsExpected, jthread eventThread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jclass cls = jni->GetObjectClass(self);\n+  if (cls == nullptr) {\n+    fatal(jni, \"No class found\");\n+  }\n+  jfieldID fieldToModify = jni->GetFieldID(cls, MODIFY_FIELD_NAME, \"Ljava\/lang\/String;\");\n+  if (fieldToModify == nullptr) {\n+    fatal(jni, \"No field found\");\n+  }\n+\n+  modify_cnt = 0;\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  err = jvmti_env->SetFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"SetFieldAccessWatch\");\n+  jstring jvalue = jni->NewStringUTF(\"newValue\");\n+\n+  jni->SetObjectField(self, fieldToModify, jvalue);\n+\n+  err = jvmti_env->ClearFieldModificationWatch(cls, fieldToModify);\n+  check_jvmti_error(err, \"ClearFieldAccessWatch\");\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_MODIFICATION, eventThread);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  if (modify_cnt != numOfEventsExpected) {\n+    char buffer[100];\n+    snprintf(buffer, sizeof(buffer),\n+        \"Incorrect field modification count: %d. Should be %d.\",\n+        (int)modify_cnt, numOfEventsExpected);\n+    fatal(jni, buffer);\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/FieldEventsFromJNI\/libFieldEventsFromJNI.cpp","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @run main\/othervm\/native -agentlib:SingleStepKlassInit -XX:CompileCommand=exclude,SingleStepKlassInit::lambda$main*\n+ *      -XX:CompileCommand=exclude,SingleStepKlassInit$$Lambda*::run SingleStepKlassInit\n+ *\/\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+public class SingleStepKlassInit {\n+    private static final int MAX_VTHREAD_COUNT = 8 * Runtime.getRuntime().availableProcessors();\n+    private static final CountDownLatch finishInvokeStatic = new CountDownLatch(1);\n+\n+    private static native void setSingleSteppingMode(boolean enable);\n+    private static native boolean didSingleStep();\n+\n+    public static void main(String args[]) throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishInvokeStatic.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m() {\n+            }\n+        }\n+\n+        setSingleSteppingMode(true);\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass.m();\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishInvokeStatic.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+        setSingleSteppingMode(false);\n+\n+        if (!didSingleStep()) {\n+            throw new RuntimeException(\"No SingleStep events\");\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private static void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assert state != Thread.State.TERMINATED : \"Thread has terminated\";\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SingleStepKlassInit\/SingleStepKlassInit.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti_common.hpp\"\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = nullptr;\n+static jboolean did_single_step = false;\n+\n+extern \"C\" {\n+\n+static void JNICALL\n+SingleStep(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread,\n+           jmethodID method, jlocation location) {\n+  did_single_step = true;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_SingleStepKlassInit_didSingleStep(JNIEnv* jni, jclass klass) {\n+  return did_single_step;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_SingleStepKlassInit_setSingleSteppingMode(JNIEnv* jni, jclass klass, jboolean enable) {\n+  jvmtiError err = jvmti->SetEventNotificationMode(enable ? JVMTI_ENABLE : JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr);\n+  check_jvmti_status(jni, err, \"setSingleSteppingMode: error in JVMTI SetEventNotificationMode for JVMTI_EVENT_SINGLE_STEP\");\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  LOG(\"Agent_OnLoad: started\\n\");\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"Agent init: Failed in GetEnv\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_single_step_events = 1;\n+  caps.can_support_virtual_threads = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.SingleStep  = &SingleStep;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in SetEventCallbacks: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  LOG(\"Agent_OnLoad: finished\\n\");\n+  return 0;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SingleStepKlassInit\/libSingleStepKlassInit.cpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -78,1 +78,1 @@\n-            out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+            out.stderrShouldBeEmptyIgnoreVMWarnings();\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbJstackXcompStress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-            out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+            out.stderrShouldBeEmptyIgnoreVMWarnings();\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/JhsdbThreadInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-            out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+            out.stderrShouldBeEmptyIgnoreVMWarnings();\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8370176\n+ * @requires vm.hasSA\n+ * @requires os.family == \"linux\"\n+ * @requires os.arch == \"amd64\"\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackMixedWithXComp\n+ *\/\n+public class TestJhsdbJstackMixedWithXComp {\n+\n+    private static void runJstack(LingeredApp app) throws Exception {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n+        launcher.addVMArgs(Utils.getFilteredTestJavaOpts(\"-showversion\"));\n+        launcher.addToolArg(\"jstack\");\n+        launcher.addToolArg(\"--mixed\");\n+        launcher.addToolArg(\"--pid\");\n+        launcher.addToolArg(Long.toString(app.getPid()));\n+\n+        ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+        Process jhsdb = pb.start();\n+        OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+        jhsdb.waitFor();\n+\n+        String stdout = out.getStdout();\n+        System.out.println(stdout);\n+        System.err.println(out.getStderr());\n+\n+        out.stderrShouldBeEmptyIgnoreVMWarnings();\n+\n+        List<String> targetStackTrace = new ArrayList<>();\n+        boolean inStack = false;\n+        for (String line : stdout.split(\"\\n\")) {\n+            if (line.contains(\"<nep_invoker_blob>\")) {\n+                inStack = true;\n+            } else if (inStack && line.contains(\"-----------------\")) {\n+                inStack = false;\n+                break;\n+            }\n+\n+            if (inStack) {\n+                targetStackTrace.add(line);\n+            }\n+        }\n+\n+        boolean found = targetStackTrace.stream()\n+                                        .anyMatch(l -> l.contains(\"thread_native_entry\"));\n+        if (!found) {\n+            throw new RuntimeException(\"Test failed!\");\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        LingeredApp app = null;\n+\n+        try {\n+            app = new LingeredAppWithVirtualThread();\n+            LingeredApp.startApp(app, \"-Xcomp\");\n+            System.out.println(\"Started LingeredApp with pid \" + app.getPid());\n+            runJstack(app);\n+            System.out.println(\"Test Completed\");\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackMixedWithXComp.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n-        out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+        out.stderrShouldBeEmptyIgnoreVMWarnings();\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackWithVirtualThread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach020\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- *         - target application provokes garbage collection (calls System.gc())\n+ *         - target application provokes garbage collection (calls WhiteBox.getWhiteBox().fullGC())\n@@ -51,0 +51,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -55,1 +57,1 @@\n- *      -javaOpts=\"-XX:+UsePerfData ${test.vm.opts} ${test.java.opts}\"\n+ *      -javaOpts=\"-XX:+UsePerfData ${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach020\/TestDescription.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import nsk.share.ClassUnloader;\n@@ -27,0 +26,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -32,1 +32,1 @@\n-        ClassUnloader.eatMemory();\n+        WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach020\/attach020Target.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach021\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -51,1 +53,1 @@\n- *      -javaOpts=\"-XX:+UsePerfData ${test.vm.opts} ${test.java.opts}\"\n+ *      -javaOpts=\"-XX:+UsePerfData ${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach021\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import nsk.share.ClassUnloader;\n@@ -27,0 +26,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -54,1 +54,1 @@\n-                ClassUnloader.eatMemory();\n+                WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach021\/attach021Target.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -54,1 +56,1 @@\n- *      -javaOpts=\"-XX:+UsePerfData ${test.vm.opts} ${test.java.opts}\"\n+ *      -javaOpts=\"-XX:+UsePerfData ${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import nsk.share.ClassUnloader;\n@@ -27,0 +26,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -50,1 +50,1 @@\n-            ClassUnloader.eatMemory();\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/attach022Target.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -66,1 +67,1 @@\n-                ClassUnloader.eatMemory(); \/\/ provoke garbage collecting\n+                WhiteBox.getWhiteBox().fullGC(); \/\/ provoke garbage collecting\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionFinish\/gcfinish001.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionFinish\/gcfinish001\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -45,0 +47,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionFinish\/gcfinish001\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -66,7 +67,1 @@\n-        try {\n-            for (int i=0; i<ITERATIONS; i++)\n-                ClassUnloader.eatMemory(); \/\/ provoke garbage collecting\n-        } catch (OutOfMemoryError e) {\n-            \/\/ ignoring\n-        }\n-\n+        WhiteBox.getWhiteBox().fullGC(); \/\/ provoke garbage collecting\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart001.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart001\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -45,0 +47,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart001\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -64,7 +65,1 @@\n-        try {\n-            for (int i=0; i<ITERATIONS; i++)\n-                ClassUnloader.eatMemory(); \/\/ provoke garbage collecting\n-        } catch (OutOfMemoryError e) {\n-            \/\/ ignoring\n-        }\n-\n+        WhiteBox.getWhiteBox().fullGC(); \/\/ provoke garbage collecting\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart002.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart002\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -45,0 +47,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,0 @@\n-            nsk_jvmti_resumeSync();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass028\/redefclass028.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,0 @@\n-            nsk_jvmti_resumeSync();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass029\/redefclass029.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,0 @@\n-            nsk_jvmti_resumeSync();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass030\/redefclass030.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -33,2 +34,0 @@\n-    \/* number of interations to provoke garbage collecting *\/\n-    final static int GC_TRYS = 1;\n@@ -73,3 +72,2 @@\n-        \/\/ Provoke OutOfMemoryError in order to clear all soft references\n-        for (int i= 0; i < GC_TRYS; i++)\n-            ClassUnloader.eatMemory();\n+        \/\/ Provoke fullgc in order to clear all soft references\n+        WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP12\/ap12t001.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP12\/ap12t001\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -45,0 +47,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP12\/ap12t001\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -64,1 +65,1 @@\n-            ClassUnloader.eatMemory();\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t002.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t002\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -77,0 +79,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -65,1 +66,1 @@\n-            ClassUnloader.eatMemory();\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t006.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t006\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -66,0 +68,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t006\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,3 +1,24 @@\n-# Require jarsigner\n-java\/lang\/System\/LoggerFinder\/SignedLoggerFinderTest\/SignedLoggerFinderTest.java 8346719 generic-all\n-java\/util\/jar\/JarFile\/jarVerification\/MultiProviderTest.java                     8346719 generic-all\n+###########################################################################\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+###########################################################################\n@@ -5,10 +26,1 @@\n-# Require jar\n-java\/lang\/System\/MacEncoding\/TestFileEncoding.java                               8346719 generic-all\n-java\/util\/ResourceBundle\/modules\/basic\/BasicTest.java                            8346719 generic-all\n-\n-# Require javac\n-java\/util\/ResourceBundle\/modules\/layer\/LayerTest.java                            8346719 generic-all\n-java\/util\/ResourceBundle\/modules\/unnamed\/UnNamedTest.java                        8346719 generic-all\n-\n-# Require jps\n-java\/util\/concurrent\/locks\/Lock\/TimedAcquireLeak.java                            8346719 generic-all\n+# Currently empty\n","filename":"test\/jdk\/ProblemList-StaticJdk.txt","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -37,5 +37,0 @@\n-javax\/management\/remote\/mandatory\/connection\/DeadLockTest.java 8309069 windows-x64\n-\n-javax\/management\/remote\/mandatory\/connection\/ConnectionTest.java 8308352 windows-x64\n-\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -648,2 +648,0 @@\n-sun\/security\/ssl\/SSLLogger\/DebugPropertyValuesTest.java         8370852 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n@@ -37,0 +38,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadAllocatedMemory.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -127,0 +127,3 @@\n+        \/\/ taking start time before entering completeExchange to account for possible\n+        \/\/ delays in reaching server.stop().\n+        final long startTime = System.nanoTime();\n@@ -131,1 +134,1 @@\n-        final Duration delayDuration = Duration.ofSeconds(Utils.adjustTimeout(5));\n+        final Duration delayDuration = Duration.ofSeconds(Utils.adjustTimeout(20));\n@@ -133,1 +136,1 @@\n-        final long elapsed = timeShutdown(delayDuration);\n+        final long elapsed = timeShutdown(delayDuration, startTime);\n@@ -154,1 +157,1 @@\n-    public void shouldCompeteAfterDelay() throws InterruptedException {\n+    public void shouldCompleteAfterDelay() throws InterruptedException {\n@@ -161,7 +164,0 @@\n-        \/\/ Complete the exchange 10 second into the future.\n-        \/\/ Runs in parallel, so won't block the server stop\n-        final Duration exchangeDuration = Duration.ofSeconds(Utils.adjustTimeout(10));\n-        completeExchange(exchangeDuration);\n-        log(\"Complete Exchange triggered\");\n-\n-\n@@ -173,6 +169,2 @@\n-\n-\n-        \/\/ The shutdown should not await the exchange to complete\n-        if (elapsed >= exchangeDuration.toNanos()) {\n-            fail(\"HttpServer.stop terminated too late\");\n-        }\n+        complete.countDown();\n+        log(\"Exchange completed\");\n@@ -280,0 +272,2 @@\n+        return timeShutdown(delayDuration, startTime);\n+    }\n@@ -281,0 +275,5 @@\n+    \/**\n+     * This allows passing a custom start time\n+     *\/\n+    private long timeShutdown(Duration delayDuration,\n+                              long startTime) {\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ServerStopTerminationTest.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    static boolean error = false;\n+    static volatile boolean error = false;\n@@ -70,0 +70,2 @@\n+        smallFilePath.toFile().deleteOnExit();\n+        largeFilePath.toFile().deleteOnExit();\n@@ -125,2 +127,0 @@\n-            Files.delete(smallFilePath);\n-            Files.delete(largeFilePath);\n@@ -130,2 +130,0 @@\n-    static int foo = 1;\n-\n@@ -138,1 +136,1 @@\n-    static Object fileLock = new Object();\n+    static final Object fileLock = new Object();\n@@ -206,1 +204,0 @@\n-                temp.delete();\n@@ -208,1 +205,1 @@\n-                e.printStackTrace();\n+                System.err.println(\"Error occurred: \" + e);\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test9.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/test\/lib\n@@ -29,0 +28,2 @@\n+ * @requires test.thread.factory != \"Virtual\"\n+ * @library \/test\/lib\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6431193.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8370141 8370637\n+ * @summary  Test no crash printing to Graphics after job is ended.\n+ * @key headful printer\n+ * @run main PrintJobAfterEndTest\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.JobAttributes;\n+import java.awt.JobAttributes.DialogType;\n+import java.awt.JobAttributes.DestinationType;\n+import java.awt.PageAttributes;\n+import java.awt.PrintJob;\n+import java.awt.Toolkit;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class PrintJobAfterEndTest {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        JobAttributes jobAttributes = new JobAttributes();\n+        jobAttributes.setDialog(DialogType.NONE);\n+        jobAttributes.setDestination(DestinationType.FILE);\n+        jobAttributes.setFileName(\"out.prn\");\n+\n+        PageAttributes pageAttributes = new PageAttributes();\n+\n+        Frame f = new Frame();\n+        Toolkit tk = f.getToolkit();\n+\n+        for (int i = 0; i < 500; i++) {\n+            PrintJob job = tk.getPrintJob(f, \"Print Crash Test\", jobAttributes, pageAttributes);\n+            if (job != null) {\n+                Graphics g = job.getGraphics();\n+                CountDownLatch latch = new CountDownLatch(1);\n+\n+                Thread endThread = new Thread(() -> {\n+                    try {\n+                        latch.await();\n+                        job.end();\n+                    } catch (Throwable t) {\n+                        t.printStackTrace();\n+                    }\n+                });\n+\n+                Thread drawThread = new Thread(() -> {\n+                    try {\n+                        latch.await();\n+                        g.clearRect(10, 10, 100, 100);\n+                        g.drawRect(0, 300, 200, 400);\n+                        g.fillRect(0, 300, 200, 400);\n+                        g.drawLine(0, 100, 200, 100);\n+                        g.drawString(\"Hello\", 200, 200);\n+                        g.drawOval(200, 200, 200, 200);\n+                        int[] pts = new int[] { 10, 200, 100 };\n+                        g.drawPolyline(pts, pts, pts.length);\n+                        g.drawPolygon(pts, pts, pts.length);\n+                        g.fillPolygon(pts, pts, pts.length);\n+                    } catch (Throwable t) {\n+                        t.printStackTrace();\n+                    }\n+                });\n+\n+                if ( i % 2 == 0) {\n+                    drawThread.start();\n+                    endThread.start();\n+                } else {\n+                    endThread.start();\n+                    drawThread.start();\n+                }\n+                latch.countDown();\n+\n+                endThread.join();\n+                drawThread.join();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/PrintJob\/PrintJobAfterEndTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8365077\n+ * @bug 8365077 8370160\n@@ -41,0 +41,6 @@\n+        \/\/ Invalid ranges should be discarded\n+        NumericShaper cs1 =\n+            NumericShaper.getContextualShaper(NumericShaper.ALL_RANGES);\n+        NumericShaper cs2 = NumericShaper.getContextualShaper(-1);\n+        printAndCompare(cs1, cs2);\n+\n","filename":"test\/jdk\/java\/awt\/font\/NumericShaper\/NSEqualsTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+\n+\/*\n+ * @test\n+ * @bug  4954405\n+ * @summary Verify DataBuffer offsets are handled by ByteInterleavedRaster\n+ *\/\n+\n+public class ByteInterleavedRasterOffsetsTest {\n+\n+    public static void main(String[] args) {\n+        byte[] data = { 0, -1, 0, 0 }; \/\/ only set the R sample.\n+        int[] bandOffsets = { 0, 1, 2 };\n+        DataBuffer databuf = new DataBufferByte(data, 3, 1);\n+        WritableRaster raster =\n+            Raster.createInterleavedRaster(databuf, 1, 1, 3, 3, bandOffsets, null);\n+        int[] pixels = raster.getPixels(0, 0, 1, 1, (int[])null);\n+        byte[] elements = (byte[])raster.getDataElements(0, 0, null);\n+        ColorModel colorModel = new ComponentColorModel(\n+                ColorSpace.getInstance(ColorSpace.CS_sRGB), false, false,\n+                ColorModel.OPAQUE, DataBuffer.TYPE_BYTE);\n+        BufferedImage img = new BufferedImage(colorModel, raster, false, null);\n+        int pixel = img.getRGB(0, 0);\n+\n+        System.out.println(\"PIXEL0=\" + Integer.toHexString(pixels[0]));\n+        System.out.println(\"PIXEL1=\" + Integer.toHexString(pixels[1]));\n+        System.out.println(\"PIXEL2=\" + Integer.toHexString(pixels[2]));\n+        System.out.println(\"ELEMENT0=\" + Integer.toHexString(elements[0] & 0xff));\n+        System.out.println(\"ELEMENT1=\" + Integer.toHexString(elements[1] & 0xff));\n+        System.out.println(\"ELEMENT2=\" + Integer.toHexString(elements[2] & 0xff));\n+        System.out.println(\"PIXEL=\" + Integer.toHexString(pixel));\n+\n+        if ((pixels[0] != 0xff) || (pixels[1] != 0) || (pixels[2] != 0)) {\n+            throw new RuntimeException(\"Unexpected pixels\");\n+        }\n+        if (((elements[0] & 0xff) != 0xff) || (elements[1] != 0) || (elements[2] != 0)) {\n+            throw new RuntimeException(\"Unexpected elements\");\n+        }\n+        if (pixel != 0xffff0000) {\n+            throw new RuntimeException(\"Unexpected pixel\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/ByteInterleavedRasterOffsetsTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.File;\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ColorModel;\n+\n+import javax.imageio.ImageIO;\n+\n+\/*\n+ * @test\n+ * @bug 8364583\n+ * @summary Verify CMYK images work with ColorConvertOp\n+ *\/\n+\n+public class ColorConvertOpCMYK {\n+\n+    public static void main(String[] args) throws Exception {\n+        String sep = System.getProperty(\"file.separator\");\n+        String dir = System.getProperty(\"test.src\", \".\");\n+        String prefix = dir + sep;\n+        File file = new File(prefix + \"black_cmyk.jpg\");\n+        BufferedImage source = ImageIO.read(file);\n+        ColorModel sourceModel = source.getColorModel();\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        ColorConvertOp convertOp = new ColorConvertOp(cs, null);\n+        BufferedImage rgb = convertOp.filter(source, null);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/ColorConvertOp\/ColorConvertOpCMYK.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/image\/ColorConvertOp\/black_cmyk.jpg","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/CMYK\/black_cmyk.jpg","status":"copied"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key printer\n+ * @bug 8370141 8370637\n+ * @summary No crash when printing after job completed.\n+ * @run main PrintAfterEndTest\n+ *\/\n+\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.Pageable;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.standard.Destination;\n+import java.io.File;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class PrintAfterEndTest implements Printable {\n+\n+    volatile Graphics peekgraphics;\n+    volatile Graphics pathgraphics;\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        for (int i = 0; i < 500; i++) {\n+            PrintAfterEndTest paet = new PrintAfterEndTest();\n+            paet.print();\n+        }\n+    }\n+\n+    void print() throws Exception {\n+        PrinterJob pjob = PrinterJob.getPrinterJob();\n+        if (pjob == null || pjob.getPrintService() == null) {\n+            System.out.println(\"Unable to create a PrintJob\");\n+            return;\n+        }\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+        HashPrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();\n+        File file = new File(\"out.prn\");\n+        Destination destination = new Destination(file.toURI());\n+        aset.add(destination);\n+        pjob.setPrintable(this);\n+        pjob.print(aset);\n+\n+        DrawRunnable tpeek = new DrawRunnable(peekgraphics, latch);\n+        DrawRunnable tpath = new DrawRunnable(pathgraphics, latch);\n+        tpeek.start();\n+        tpath.start();\n+        latch.countDown();\n+        tpeek.join();\n+        tpath.join();\n+   }\n+\n+    static class DrawRunnable extends Thread {\n+\n+        Graphics g;\n+        CountDownLatch latch;\n+        DrawRunnable(Graphics g, CountDownLatch latch) {\n+            this.g = g;\n+            this.latch = latch;\n+        }\n+\n+        public void run() {\n+            if (g == null) {\n+                return;\n+            }\n+            try {\n+                latch.await();\n+                g.clearRect(10, 10, 100, 100);\n+                g.drawRect(0, 300, 200, 400);\n+                g.fillRect(0, 300, 200, 400);\n+                g.drawLine(0, 100, 200, 100);\n+                g.drawString(\"Hello\", 200, 200);\n+                g.drawOval(200, 200, 200, 200);\n+                int[] pts = new int[] { 10, 200, 100 };\n+                g.drawPolyline(pts, pts, pts.length);\n+                g.drawPolygon(pts, pts, pts.length);\n+                g.fillPolygon(pts, pts, pts.length);\n+                g.dispose();\n+            } catch (Throwable t) {\n+            }\n+        }\n+    }\n+\n+    public int print(Graphics g, PageFormat pf, int pageIndex) {\n+        if (pageIndex > 0) {\n+            return NO_SUCH_PAGE;\n+        }\n+        if (peekgraphics == null) {\n+            peekgraphics = g.create();\n+        } else if (pathgraphics == null) {\n+            pathgraphics = g.create();\n+        }\n+        Graphics2D g2d = (Graphics2D)g;\n+        g2d.translate(pf.getImageableX(),  pf.getImageableY());\n+        g.drawString(\"random string\", 100,20);\n+        return PAGE_EXISTS;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintAfterEndTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8370344\n+ * @requires os.family != \"windows\"\n+ * @requires vm.flavor != \"zero\"\n+ * @requires vm.hasJFR\n+ * @summary Test closing a shared scope during faulting access\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main jdk.test.lib.FileInstaller sharedCloseJfr.jfc sharedCloseJfr.jfc\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *   -XX:StartFlightRecording:filename=recording.jfr,dumponexit=true,settings=sharedCloseJfr.jfc\n+ *   TestSharedCloseJFR\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.io.RandomAccessFile;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\/\/ We are interested in the following scenario:\n+\/\/ When accessing a memory-mapped file that is truncated\n+\/\/ a segmentation fault will occur (see also test\/hotspot\/jtreg\/runtime\/Unsafe\/InternalErrorTest.java)\n+\/\/\n+\/\/ This segmentation fault will be caught in the VM's signal handler\n+\/\/ and get turned into an InternalError by a VM handshake operation.\n+\/\/ This handshake operation calls back into Java to the constructor\n+\/\/ of InternalError. This constructor calls super constructors until\n+\/\/ it ends up in the constructor of Throwable, where JFR starts logging\n+\/\/ the Throwable being created. This logging code adds a bunch\n+\/\/ of extra Java frames to the stack.\n+\/\/\n+\/\/ All of this occurs during the original memory access, i.e.\n+\/\/ while we are inside a @Scoped method call (jdk.internal.misc.ScopedMemoryAccess).\n+\/\/ If at this point a shared arena is closed in another thread,\n+\/\/ the shared scope closure handshake (src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp)\n+\/\/ will see all the extra frames added by JFR and the InternalError constructor,\n+\/\/ while walking the stack of the thread doing the faulting access.\n+\/\/\n+\/\/ This test is here to make sure that the shared scope closure handshake can\n+\/\/ deal with that situation.\n+public class TestSharedCloseJFR {\n+\n+    private static final int PAGE_SIZE = WhiteBox.getWhiteBox().getVMPageSize();\n+\n+    public static void main(String[] args) throws Throwable {\n+        String fileName = \"tmp.txt\";\n+        Path path = Path.of(fileName);\n+        AtomicBoolean stop = new AtomicBoolean();\n+\n+        Files.write(path, \"1\".repeat(PAGE_SIZE + 1000).getBytes());\n+        try (RandomAccessFile file = new RandomAccessFile(fileName, \"rw\")) {\n+            FileChannel fileChannel = file.getChannel();\n+            MemorySegment segment =\n+                    fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size(), Arena.ofAuto());\n+            \/\/ truncate file\n+            \/\/ this will make the access fault\n+            Files.write(path, \"2\".getBytes());\n+\n+            \/\/ start worker thread\n+            CountDownLatch latch = new CountDownLatch(1);\n+            Thread.ofPlatform().start(() -> {\n+                latch.countDown();\n+                while (!stop.get()) {\n+                    Arena.ofShared().close(); \/\/ hammer VM with handshakes\n+                }\n+            });\n+\n+            \/\/ wait util the worker thread has started\n+            latch.await();\n+\n+            \/\/ access (should fault)\n+            \/\/ try it a few times until we get a handshake during JFR reporting\n+            for (int i = 0; i < 50_000; i++) {\n+                try {\n+                    segment.get(ValueLayout.JAVA_INT, PAGE_SIZE);\n+                    throw new RuntimeException(\"InternalError was expected\");\n+                } catch (InternalError e) {\n+                    \/\/ InternalError as expected\n+                    if (!e.getMessage().contains(\"a fault occurred in an unsafe memory access\")) {\n+                        throw new RuntimeException(\"Unexpected exception\", e);\n+                    }\n+                }\n+            }\n+        } finally {\n+            \/\/ stop worker\n+            stop.set(true);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/sharedclosejfr\/TestSharedCloseJFR.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration label=\"Custom\" version=\"2.0\">\n+  <event name=\"jdk.JavaErrorThrow\">\n+    <setting name=\"enabled\" control=\"enable-errors\">true<\/setting>\n+    <setting name=\"stackTrace\">true<\/setting>\n+  <\/event>\n+<\/configuration>\n","filename":"test\/jdk\/java\/foreign\/sharedclosejfr\/sharedCloseJfr.jfc","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8370344\n+ * @library \/test\/lib\n+ * @run junit\/native TestSharedCloseJvmti\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class TestSharedCloseJvmti {\n+\n+    private static final String JVMTI_AGENT_LIB = Path.of(Utils.TEST_NATIVE_PATH, System.mapLibraryName(\"SharedCloseAgent\"))\n+            .toAbsolutePath().toString();\n+\n+    @Test\n+    void eventDuringScopedAccess() throws Throwable {\n+        List<String> command = new ArrayList<>(List.of(\n+                \"-agentpath:\" + JVMTI_AGENT_LIB,\n+                \"-Xcheck:jni\",\n+                EventDuringScopedAccessRunner.class.getName()\n+        ));\n+\n+        try {\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+            Process process = ProcessTools.startProcess(\"fork\", pb, null, null, 1L, TimeUnit.MINUTES);\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            output.shouldHaveExitValue(0);\n+            output.stderrShouldContain(\"Exception in thread \\\"Trigger\\\" jdk.internal.misc.ScopedMemoryAccess$ScopedAccessError: Invalid memory access\");\n+        } catch (TimeoutException e) {\n+            throw new RuntimeException(\"Timeout while waiting for forked process\");\n+        }\n+    }\n+\n+    public static class EventDuringScopedAccessRunner {\n+        static final int ADDED_FRAMES = 10;\n+\n+        static final CountDownLatch MAIN_LATCH = new CountDownLatch(1);\n+        static final CountDownLatch TARGET_LATCH = new CountDownLatch(1);\n+        static final MemorySegment OTHER_SEGMENT = Arena.global().allocate(4);\n+\n+        static volatile int SINK;\n+\n+        public static void main(String[] args) throws Throwable {\n+            try (Arena arena = Arena.ofShared()) {\n+                MemorySegment segment = arena.allocate(4);\n+                \/\/ run in separate thread so that waiting on\n+                \/\/ latch doesn't block main thread\n+                Thread.ofPlatform().name(\"Trigger\").start(() -> {\n+                    SINK = segment.get(ValueLayout.JAVA_INT, 0);\n+                });\n+                \/\/ wait until trigger thread is in JVMTI event callback\n+                MAIN_LATCH.await();\n+            }\n+            \/\/ Notify trigger thread that arena was closed\n+            TARGET_LATCH.countDown();\n+        }\n+\n+        static boolean reentrant = false;\n+\n+        \/\/ called by jvmti agent\n+        \/\/ we get here after checking arena liveness\n+        private static void target() {\n+            String callerName = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).walk(frames ->\n+                    frames.skip(2).findFirst().orElseThrow().getClassName());\n+            if (!callerName.equals(\"jdk.internal.misc.ScopedMemoryAccess\")) {\n+                return;\n+            }\n+\n+            if (reentrant) {\n+                \/\/ put some frames on the stack, so stack walk does not see @Scoped method\n+                addFrames(0);\n+            } else {\n+                reentrant = true;\n+                SINK = OTHER_SEGMENT.get(ValueLayout.JAVA_INT, 0);\n+                reentrant = false;\n+            }\n+        }\n+\n+        private static void addFrames(int depth) {\n+            if (depth >= ADDED_FRAMES) {\n+                \/\/ notify main thread to close the arena\n+                MAIN_LATCH.countDown();\n+                try {\n+                    \/\/ wait here until main thread has closed arena\n+                    TARGET_LATCH.await();\n+                } catch (InterruptedException ex) {\n+                    throw new RuntimeException(\"Unexpected interruption\");\n+                }\n+                return;\n+            }\n+            addFrames(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/sharedclosejvmti\/TestSharedCloseJvmti.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+\n+#include <string.h>\n+\n+static jclass MAIN_CLS;\n+static jmethodID TARGET_ID;\n+\n+static const char* TARGET_CLASS_NAME = \"TestSharedCloseJvmti$EventDuringScopedAccessRunner\";\n+static const char* TARGET_METHOD_NAME = \"target\";\n+static const char* TARGET_METHOD_SIG = \"()V\";\n+\n+static const char* INTERCEPT_CLASS_NAME = \"Ljdk\/internal\/foreign\/MemorySessionImpl;\";\n+static const char* INTERCEPT_METHOD_NAME = \"checkValidStateRaw\";\n+\n+void start(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n+\n+  jclass cls = jni_env->FindClass(TARGET_CLASS_NAME);\n+  if (cls == nullptr) {\n+    jni_env->ExceptionDescribe();\n+    return;\n+  }\n+\n+  MAIN_CLS = (jclass) jni_env->NewGlobalRef(cls);\n+\n+  TARGET_ID = jni_env->GetStaticMethodID(cls, TARGET_METHOD_NAME, TARGET_METHOD_SIG);\n+  if (TARGET_ID == nullptr) {\n+    jni_env->ExceptionDescribe();\n+    return;\n+  }\n+}\n+\n+void method_exit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread, jmethodID method,\n+                 jboolean was_popped_by_exception, jvalue return_value) {\n+  char* method_name = nullptr;\n+  jvmtiError err = jvmti_env->GetMethodName(method, &method_name, nullptr, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return;\n+  }\n+\n+  if (strcmp(method_name, INTERCEPT_METHOD_NAME) != 0) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    return;\n+  }\n+\n+  jclass cls;\n+  err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    return;\n+  }\n+\n+  char* class_sig = nullptr;\n+  err = jvmti_env->GetClassSignature(cls, &class_sig, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    return;\n+  }\n+\n+  if (strcmp(class_sig, INTERCEPT_CLASS_NAME) != 0) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    jvmti_env->Deallocate((unsigned char*) class_sig);\n+    return;\n+  }\n+\n+  jni_env->CallStaticVoidMethod(MAIN_CLS, TARGET_ID);\n+  if (jni_env->ExceptionOccurred()) {\n+    jni_env->ExceptionDescribe();\n+  }\n+\n+  jvmti_env->Deallocate((unsigned char*) method_name);\n+  jvmti_env->Deallocate((unsigned char*) class_sig);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv* env;\n+  jint jni_err = vm->GetEnv((void**) &env, JVMTI_VERSION);\n+  if (jni_err != JNI_OK) {\n+    return jni_err;\n+  }\n+\n+  jvmtiCapabilities capabilities{};\n+  capabilities.can_generate_method_exit_events = 1;\n+\n+  jvmtiError err = env->AddCapabilities(&capabilities);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  jvmtiEventCallbacks callbacks;\n+  callbacks.VMStart = start;\n+  callbacks.MethodExit = method_exit;\n+\n+  err = env->SetEventCallbacks(&callbacks, (jint) sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  err = env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  err = env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  return 0;\n+}\n","filename":"test\/jdk\/java\/foreign\/sharedclosejvmti\/libSharedCloseAgent.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @bug 4160406 4705734 4707389 4826774 4895911 4421494 6358355 7021568 7039369 4396272\n+ * @bug 4160406 4705734 4707389 4826774 4895911 4421494 6358355 7021568\n+ *      7039369 4396272 8366017\n@@ -762,0 +763,33 @@\n+    private static void testFastPaths() {\n+        \/* Exercises the fast paths in jdk.internal.math.FloatingDecimal. *\/\n+        check(\"1\", 0x1.0p0);  \/\/ 1.0\n+        check(\"2.34000e2\", 0x1.d4p7);  \/\/ 234.0\n+        check(\"9.223e18\", 0x1.fffab689adb6p62);  \/\/ 9.223e18\n+        check(\"9.876e18\", 0x1.121d33597384p63);  \/\/ 9.876e18\n+        check(\"9223372036854776833\", 0x1.0000000000001p63);  \/\/ 9.223372036854778E18\n+        check(\"9223372036854776832\", 0x1.0p63);  \/\/ 9.223372036854776E18\n+\n+        check(\"1.23\", 0x1.3ae147ae147aep0);  \/\/ 1.23\n+        check(\"0.000234\", 0x1.eabbcb1cc9646p-13);  \/\/ 2.34E-4\n+        check(\"3.45e23\", 0x1.2439f32cbea41p78);  \/\/ 3.45E23\n+        check(\"576460752303423616e20\", 0x1.5af1d78b58c41p125);  \/\/ 5.764607523034236E37\n+\n+        check(\"1e37\", 0x1.e17b84357691bp122);  \/\/ 1.0E37\n+        check(\"8999e34\", 0x1.0ecdc63717fbdp126);  \/\/ 8.999E37\n+        check(\"0.9999e36\", 0x1.8125c09cb78b7p119);  \/\/ 9.999E35\n+        check(\"0.9876e37\", 0x1.db831933296cep122);  \/\/ 9.876E36\n+\n+        check(\"1.2e-200\", 0x1.d64af4cc52935p-665);  \/\/ 1.2E-200\n+        check(\"2.3e100\", 0x1.507ed84d17a69p333);  \/\/ 2.3E100\n+        check(\"1.2000000000000000003e-200\", 0x1.d64af4cc52935p-665);  \/\/ 1.2E-200\n+        check(\"2.3000000000000000004e100\", 0x1.507ed84d17a69p333);  \/\/ 2.3E100\n+        check(\"5.249320425370670463e308\", Double.POSITIVE_INFINITY);\n+        check(\"5.2493204253706704633e308\", Double.POSITIVE_INFINITY);\n+\n+        check(\"1.2e-320\", 0x0.000000000097dp-1022);  \/\/ 1.2E-320\n+        check(\"1.2000000000000000003e-320\", 0x0.000000000097dp-1022);  \/\/ 1.2E-320\n+\n+        check(\"2.225073858507201383e-308\", Double.MIN_NORMAL);\n+        check(\"2.2250738585072013831e-308\", Double.MIN_NORMAL);\n+    }\n+\n@@ -778,0 +812,2 @@\n+\n+        testFastPaths();\n@@ -779,0 +815,1 @@\n+\n","filename":"test\/jdk\/java\/lang\/Double\/ParseDouble.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n- * @bug 4160406 4705734 4707389 6358355 7032154\n- * @summary Tests for Float.parseFloat method\n+ * @bug 4160406 4705734 4707389 6358355 7032154 8366017\n+ * @summary Tests for Float.parseFloat method (use -DallRoundtrips=true\n+ *      to additionally check all non-negative, non-NaN float->String->float\n+ *      roundtrips)\n@@ -318,0 +320,16 @@\n+    private static final int N = Float.floatToIntBits(Float.POSITIVE_INFINITY);\n+\n+    \/* Tests all non-negative, non-NaN float->String->float roundtrips. *\/\n+    private static void testAllRoundtrips() {\n+        for (int i = 0; i <= N; ++i) {\n+            float v = Float.intBitsToFloat(i);\n+            String s = Float.toString(v);\n+            float v0 = Float.parseFloat(s);\n+            if (v != v0) {\n+                fail(s, v0);\n+            }\n+        }\n+    }\n+\n+    private static final String ALL_ROUNDTRIPS_PROP = \"allRoundtrips\";\n+\n@@ -327,0 +345,4 @@\n+\n+        if (Boolean.getBoolean(ALL_ROUNDTRIPS_PROP)) {\n+            testAllRoundtrips();\n+        }\n","filename":"test\/jdk\/java\/lang\/Float\/ParseFloat.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,760 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.java.lang.Process;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.FilterInputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.lang.reflect.Field;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @bug 8364361\n+ * @summary Tests for Process.close\n+ * @modules java.base\/java.lang:+open java.base\/java.io:+open\n+ * @run junit jdk.java.lang.Process.ProcessCloseTest\n+ *\/\n+public class ProcessCloseTest {\n+\n+    private final static boolean OS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+    private final static String CAT_PROGRAM = \"cat\";\n+    public static final String FORCED_CLOSE_MSG = \"Forced close\";\n+    private static List<String> JAVA_ARGS;\n+\n+    private static List<String> setupJavaEXE() {\n+        String JAVA_HOME = System.getProperty(\"test.jdk\");\n+        if (JAVA_HOME == null)\n+            JAVA_HOME = System.getProperty(\"JAVA_HOME\");\n+        String classPath = System.getProperty(\"test.class.path\");\n+        return  List.of(JAVA_HOME + \"\/bin\/java\", \"-cp\", classPath, ProcessCloseTest.class.getName());\n+    }\n+\n+    private static List<String> javaArgs(ChildCommand... moreArgs) {\n+\n+        List<String> javaArgs = JAVA_ARGS;\n+        if (javaArgs == null) {\n+            JAVA_ARGS = javaArgs = setupJavaEXE();\n+        }\n+        List<String> args = new ArrayList<>(javaArgs);\n+        for (ChildCommand arg : moreArgs) {\n+            args.add(arg.toString());\n+        }\n+        return args;\n+    }\n+\n+    \/**\n+     * {@return A Stream of Arguments}\n+     * Each Argument consists of three lists.\n+     * - A List of command line arguments to start a process.\n+     *   `javaArgs can be used to launch a Java child with ChildCommands\n+     * - A List of ProcessCommand actions to be invoked on that process\n+     * - A List of commands to be invoked on the process after the close or T-W-R exit.\n+     *\/\n+    static Stream<Arguments> singleThreadTestCases() {\n+        return Stream.of(\n+                Arguments.of(List.of(\"echo\", \"xyz0\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY,\n+                                ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.WRITER_WRITE,\n+                                ProcessCommand.WRITER_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ProcessCommand.STDOUT_PRINT_ALL_LINES),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.STDOUT_CLOSE,\n+                                ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(List.of(CAT_PROGRAM, \"NoSuchFile.txt\"),\n+                        List.of(ProcessCommand.STDERR_PRINT_ALL_LINES,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        List.of(ExitStatus.FAIL)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_MARCO),\n+                        List.of(ProcessCommand.STDOUT_EXPECT_POLO,\n+                                ProcessCommand.STDERR_EXPECT_EMPTY),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.STDERR_MARCO),\n+                        List.of(ProcessCommand.STDERR_EXPECT_POLO,\n+                                ProcessCommand.STDOUT_EXPECT_EMPTY),\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(javaArgs(ChildCommand.PROCESS_EXIT1),\n+                        List.of(ExitStatus.FAIL),\n+                        List.of(ExitStatus.FAIL)),       \/\/ Got expected status == 1\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_INTERRUPT, \/\/ schedule an interrupt (in .2 sec)\n+                                ProcessCommand.PROCESS_CLOSE,\n+                                ProcessCommand.PROCESS_CHECK_INTERRUPTED), \/\/ Verify interrupted status\n+                        List.of(ExitStatus.KILLED)), \/\/ And process was destroyed\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_INTERRUPT), \/\/ interrupts the TWR\/close\n+                        List.of(ProcessCommand.PROCESS_CHECK_INTERRUPTED, ExitStatus.KILLED)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ExitStatus.NORMAL), \/\/ waitFor before T-W-R exit\n+                        List.of(ExitStatus.NORMAL)),\n+                Arguments.of(List.of(\"echo\", \"abc\"),\n+                        List.of(ProcessCommand.PROCESS_CLOSE),\n+                        List.of(ExitStatus.RACY)),\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_CLOSE),\n+                        List.of(ExitStatus.PIPE)),\n+                Arguments.of(List.of(\"echo\", \"def\"),\n+                        List.of(ProcessCommand.PROCESS_DESTROY),\n+                        List.of(ExitStatus.RACY)), \/\/ Racy, not deterministic\n+                Arguments.of(javaArgs(ChildCommand.STDOUT_ECHO),\n+                        List.of(ProcessCommand.STDOUT_WRITE,\n+                                ProcessCommand.PROCESS_DESTROY),\n+                        List.of(ExitStatus.RACY)), \/\/ Racy, not deterministic\n+                Arguments.of(List.of(\"echo\"),\n+                        List.of(ExitStatus.NORMAL),\n+                        List.of(ExitStatus.NORMAL))\n+        );\n+    }\n+\n+    \/\/ Utility to process each command on the process\n+    private static void doCommands(Process proc, List<Consumer<Process>> commands) {\n+        commands.forEach(c -> {\n+            Log.printf(\"    %s\\n\", c);\n+            c.accept(proc);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void simple(List<String> args, List<Consumer<Process>> commands,\n+                List<Consumer<Process>> postCommands) throws IOException {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process p = pb.start(); \/\/ Buffer any debug output\n+            Log.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+            doCommands(p, commands);\n+            p.close();\n+            doCommands(p, postCommands);\n+        } catch (Throwable ex) {\n+            System.err.print(log);\n+            throw ex;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseable(List<String> args, List<Consumer<Process>> commands,\n+                       List<Consumer<Process>> postCommands) {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            try (Process p = pb.start()) {\n+                proc = p;\n+                Log.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+            doCommands(proc, postCommands);\n+        } catch (Throwable ex) {\n+            System.err.println(log);\n+            throw ex;\n+        }\n+    }\n+\n+    \/**\n+     * Test AutoCloseable for the process and out, in, and err streams.\n+     * @param args The command line arguments\n+     * @param commands the commands to the process\n+     * @param postCommands The expected final exit status\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"singleThreadTestCases\")\n+    void autoCloseableAll(List<String> args, List<Consumer<Process>> commands,\n+                          List<Consumer<Process>> postCommands) {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            try (Process p = pb.start(); var out = p.getOutputStream();\n+                 var in = p.getInputStream();\n+                 var err = p.getErrorStream()) {\n+                proc = p;\n+                Log.printf(\"Program: %s; pid: %d\\n\", args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+            doCommands(proc, postCommands);\n+        }  catch (Throwable ex) {\n+            System.err.println(log);\n+            throw ex;\n+        }\n+    }\n+\n+    \/**\n+     * ExitStatus named values and assertions\n+     *\/\n+    enum ExitStatus implements Consumer<Process> {\n+        NORMAL(0),\n+            FAIL(1),\n+            PIPE(0, 1, 141),   \/\/ SIGPIPE\n+            KILLED(1, 137), \/\/ SIGKILL\n+            TERMINATED(0, 143), \/\/ SIGTERM\n+            RACY(0, 1, 137, 143),\n+        ;\n+        private final int[] allowedStatus;\n+\n+        ExitStatus(int... status) {\n+            this.allowedStatus = status;\n+        }\n+\n+        \/\/ If used as a process command, checks the exit status\n+        public void accept(Process p) {\n+            try {\n+                Instant begin = Instant.now();\n+                final int exitStatus = p.waitFor();\n+                Duration latency = begin.until(Instant.now());\n+                Log.printf(\"    ExitStatus: %d, sig#: %d, waitFor latency: %s%n\",\n+                        exitStatus, exitStatus & 0x7f, latency);\n+                assertEquals(exitStatus);\n+            } catch (InterruptedException ie) {\n+                Assertions.fail(\"Unexpected InterruptedException checking status: \" + this);\n+            }\n+        }\n+\n+        \/\/ Check a status matches one of the allowed exit status values\n+        void assertEquals(int actual) {\n+            for (int status : allowedStatus) {\n+                if (status == actual) {\n+                    return;     \/\/ status is expected\n+                }\n+            }\n+            if (this == RACY) {\n+                \/\/ Not an error but report the actual status\n+                Log.printf(\"Racy exit status: %d\\n\", actual);\n+            } else {\n+                Assertions.fail(\"Status: \" + actual + \", sig#: \" + (actual & 0x7f) +\n+                        \", expected one of: \" + Arrays.toString(allowedStatus));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Commands on a Process that can be sequenced in the parent.\n+     * See ChildCommands for commands that can be sent to the child process.\n+     *\/\n+    enum ProcessCommand implements Consumer<Process> {\n+        PROCESS_CLOSE(ProcessCommand::processClose),\n+        PROCESS_DESTROY(ProcessCommand::processDestroy),\n+        PROCESS_FORCE_OUT_CLOSE_EXCEPTION(ProcessCommand::processForceOutCloseException),\n+        PROCESS_FORCE_IN_CLOSE_EXCEPTION(ProcessCommand::processForceInCloseException),\n+        PROCESS_FORCE_ERROR_CLOSE_EXCEPTION(ProcessCommand::processForceErrorCloseException),\n+        WRITER_WRITE(ProcessCommand::writerWrite),\n+        WRITER_CLOSE(ProcessCommand::writerClose),\n+        STDOUT_PRINT_ALL_LINES(ProcessCommand::stdoutPrintAllLines),\n+        STDERR_PRINT_ALL_LINES(ProcessCommand::stderrPrintAllLines),\n+        STDOUT_WRITE(ProcessCommand::stdoutWrite),\n+        STDOUT_CLOSE(ProcessCommand::stdoutClose),\n+        STDOUT_EXPECT_POLO(ProcessCommand::stdoutExpectPolo),\n+        STDERR_EXPECT_POLO(ProcessCommand::stderrExpectPolo),\n+        STDOUT_EXPECT_EMPTY(ProcessCommand::stdoutExpectEmpty),\n+        STDERR_EXPECT_EMPTY(ProcessCommand::stderrExpectEmpty),\n+        PROCESS_INTERRUPT(ProcessCommand::processInterruptThread),\n+        PROCESS_CHECK_INTERRUPTED(ProcessCommand::processAssertInterrupted),\n+        ;\n+        private final Consumer<Process> command;\n+\n+        ProcessCommand(Consumer<Process> command) {\n+            this.command = command;\n+        }\n+\n+        public void accept(Process p) {\n+            command.accept(p);\n+        }\n+\n+        private static void stdoutPrintAllLines(Process p) {\n+            try {\n+                var lines = p.inputReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stdout should not be empty\");\n+                Log.printf(\"        %d lines\\n\", lines.size());\n+                Log.printf(\"%s%n\", lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stderrPrintAllLines(Process p) {\n+            try {\n+                var lines = p.errorReader().readAllLines();\n+                Assertions.assertNotEquals(0, lines.size(), \"stderr should not be empty\");\n+                Log.printf(\"        %d lines\\n\", lines.size());\n+                Log.printf(\"%s%n\", lines.toString().indent(8));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerWrite(Process p) {\n+            try {\n+                p.outputWriter().write(\"Now is the time.\");\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void writerClose(Process p) {\n+            try {\n+                p.outputWriter().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutExpectPolo(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stdout Expected Polo\");\n+        }\n+\n+        private static void stderrExpectPolo(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"Polo\", line, \"Stderr Expected Polo\");\n+        }\n+\n+        private static void stdoutExpectEmpty(Process p) {\n+            String line = readLine(p.getInputStream());\n+            Assertions.assertEquals(\"\", line, \"Stdout Expected Empty\");\n+        }\n+\n+        private static void stderrExpectEmpty(Process p) {\n+            String line = readLine(p.getErrorStream());\n+            Assertions.assertEquals(\"\", line, \"Stderr Expected Empty\");\n+        }\n+\n+        private static String readLine(InputStream in) {\n+            StringBuilder sb = new StringBuilder();\n+            try {\n+                int ch;\n+                while ((ch = in.read()) != -1) {\n+                    if (ch == '\\n') {\n+                        \/\/ end of line\n+                        return sb.toString();\n+                    }\n+                    if (ch != '\\r') {       \/\/ ignore cr - Windows defense\n+                        sb.append((char) ch);\n+                    }\n+                }\n+                \/\/ EOF - return string if no LF found\n+                return sb.toString();\n+            } catch (IOException ioe) {\n+                return ioe.getMessage();\n+            }\n+        }\n+\n+        private static void stdoutWrite(Process p) {\n+            try {\n+                var out = p.getOutputStream();\n+                out.write(\"stdout-write\".getBytes(StandardCharsets.UTF_8));\n+                out.flush();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void stdoutClose(Process p) {\n+            try {\n+                p.getOutputStream().close();\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static void processClose(Process p) {\n+            try {\n+                p.close();\n+            } catch (IOException ioe) {\n+                Assertions.fail(ioe);\n+            }\n+        }\n+\n+        private static void processDestroy(Process p) {\n+            p.destroy();\n+        }\n+\n+        \/\/ Interpose an input stream that throws on close()\n+        private static void processForceInCloseException(Process p) {\n+            try {\n+                synchronized (p) {\n+                    Field stdinField = p.getClass().getDeclaredField(OS_WINDOWS ? \"stdin_stream\" : \"stdin\");\n+                    stdinField.setAccessible(true);\n+                    stdinField.set(p, new ThrowingOutputStream((OutputStream) stdinField.get(p)));\n+                }\n+            } catch (Exception ex) {\n+                Assertions.fail(\"Failed to setup InputStream for throwing close\", ex);\n+            }\n+        }\n+\n+        \/\/ Interpose an output stream that throws on close()\n+        private static void processForceOutCloseException(Process p) {\n+            try {\n+                synchronized (p) {\n+                    Field stdoutField = p.getClass().getDeclaredField(OS_WINDOWS ? \"stdout_stream\" : \"stdout\");\n+                    stdoutField.setAccessible(true);\n+                    stdoutField.set(p, new ThrowingInputStream((InputStream) stdoutField.get(p)));\n+                }\n+            } catch (Exception ex) {\n+                Assertions.fail(\"Failed to setup OutputStream throwing close\", ex);\n+            }\n+        }\n+\n+        \/\/ Interpose an error stream that throws on close()\n+        private static void processForceErrorCloseException(Process p) {\n+            try {\n+                synchronized (p) {\n+                    Field stderrField = p.getClass().getDeclaredField(OS_WINDOWS ? \"stderr_stream\" : \"stderr\");\n+                    stderrField.setAccessible(true);\n+                    stderrField.set(p, new ThrowingInputStream((InputStream) stderrField.get(p)));\n+                }\n+            } catch (Exception ex) {\n+                Assertions.fail(\"Failed to setup OutputStream for throwing close\", ex);\n+            }\n+        }\n+\n+        \/\/ Hard coded to interrupt the invoking thread at a fixed rate of .2 second, if process is alive\n+        private static void processInterruptThread(Process p) {\n+            if (p.isAlive()) {\n+                int delay = 200;\n+                final Thread targetThread = Thread.currentThread();\n+                ForkJoinPool common = ForkJoinPool.commonPool();\n+                final ThreadInterruptor interrupter = new ThreadInterruptor(p, targetThread);\n+                common.scheduleAtFixedRate(interrupter, delay, delay, TimeUnit.MILLISECONDS);\n+            }\n+        }\n+\n+        \/\/ Verify that an interrupt is pending and reset it\n+        private static void processAssertInterrupted(Process p) {\n+            Assertions.assertTrue(Thread.interrupted(), \"Expected an interrupt\");\n+        }\n+    }\n+\n+    \/\/ Runnable scheduled at a fixed rate to interrupt a thread if a process is alive.\n+    private static class ThreadInterruptor implements Runnable {\n+        private final Process process;\n+        private final Thread targetThread;\n+        private int count;\n+\n+        ThreadInterruptor(Process process, Thread targetThread) {\n+            this.process = process;\n+            this.targetThread = targetThread;\n+            this.count = 0;\n+        }\n+\n+        public void run() {\n+            if (process.isAlive()) {\n+                count++;\n+                Log.printf(\"Interrupting thread, count: %d%n\", count);\n+                targetThread.interrupt();\n+            } else {\n+                throw new RuntimeException(\"process not alive\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Commands to Java child sent as command line arguments\n+    enum ChildCommand {\n+        STDOUT_ECHO(ChildCommand::stdoutEchoBytes),\n+        STDERR_ECHO(ChildCommand::stderrEchoBytes),\n+        SLEEP(ChildCommand::SLEEP),\n+        STDOUT_MARCO(ChildCommand::stdoutMarco),\n+        STDERR_MARCO(ChildCommand::stderrMarco),\n+        PROCESS_EXIT1(ChildCommand::processExit1),\n+        ;\n+        private final Runnable command;\n+        ChildCommand(Runnable cmd) {\n+            this.command = cmd;\n+        }\n+\n+        \/\/ The child sleeps before continuing with next ChildCommand\n+        private static void SLEEP() {\n+            final int sleepMS = 2_000;\n+            try {\n+                Thread.sleep(sleepMS);\n+            } catch (InterruptedException ie) {\n+                \/\/ Interrupted sleep, re-assert interrupted status\n+                System.err.println(\"Sleep interrupted\");  \/\/ Note the interruption in the log\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+\n+        private static void stdoutEchoBytes() {\n+            echoBytes(System.in, System.out);\n+        }\n+\n+        private static void stderrEchoBytes() {\n+            echoBytes(System.in, System.err);\n+        }\n+\n+        private static void echoBytes(InputStream in, PrintStream out) {\n+            try {\n+                byte[] bytes = in.readAllBytes();\n+                out.write(bytes);\n+            } catch (IOException ioe) {\n+                out.println(ioe);\n+            }\n+        }\n+\n+        private static void stdoutMarco() {\n+            System.out.println(\"Polo\");\n+        }\n+\n+        private static void stderrMarco() {\n+            System.err.println(\"Polo\");\n+        }\n+\n+        private static void processExit1() {\n+            System.exit(1);\n+        }\n+    }\n+\n+    static Stream<Arguments> closeExceptions() {\n+        return Stream.of(\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n+                Arguments.of(javaArgs(ChildCommand.SLEEP),\n+                        List.of(ProcessCommand.PROCESS_FORCE_IN_CLOSE_EXCEPTION,\n+                                ProcessCommand.PROCESS_FORCE_ERROR_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG, FORCED_CLOSE_MSG)),\n+                Arguments.of(List.of(\"echo\", \"xyz1\"),\n+                        List.of(ProcessCommand.PROCESS_FORCE_OUT_CLOSE_EXCEPTION),\n+                        List.of(ExitStatus.RACY), List.of(FORCED_CLOSE_MSG))\n+        );\n+    }\n+    \/**\n+     * Test AutoCloseable for cases that are expected to throw exceptions.\n+     * The list of ProcessCommands controls what is sent to the process and closing of streams.\n+     * The command line arguments control the sequence of actions taken by the child.\n+     * @param args The command line arguments for the child process\n+     * @param commands the commands to this process controlling the child\n+     * @param postCommands The expected final exit status\n+     * @param expectedMessages the list of exception messages expected by close()\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"closeExceptions\")\n+    void testStreamsCloseThrowing(List<String> args, List<Consumer<Process>> commands,\n+                                  List<Consumer<Process>> postCommands, List<String> expectedMessages) {\n+        var log = Log.get();\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(args);\n+            Process proc = null;\n+            IOException expectedIOE = null;\n+            try (Process p = pb.start()) {\n+                proc = p;\n+                Log.printf(\"Program: %s; pid: %d\\n\",args, p.pid());\n+                doCommands(p, commands);\n+            } catch (IOException ioe) {\n+                expectedIOE = ioe;\n+            }\n+            \/\/ Check the exceptions thrown, if any\n+            if (expectedIOE != null) {\n+                \/\/ Check each exception that it is expected\n+                Assertions.assertEquals(expectedMessages.getFirst(), expectedIOE.getMessage(),\n+                        \"Unexpected exception message\");\n+                var suppressedEx = expectedIOE.getSuppressed();\n+                Assertions.assertEquals(expectedMessages.size() - 1, suppressedEx.length,\n+                        \"Number of suppressed exceptions\");\n+                for (int i = 1; i < expectedMessages.size(); i++) {\n+                    Assertions.assertEquals(expectedMessages.get(i),\n+                            suppressedEx[i - 1].getMessage(),\n+                            \"Unexpected suppressed exception message\");\n+                }\n+            }\n+            Assertions.assertNotNull(proc, \"Process is null\");\n+            doCommands(proc, postCommands);\n+        }  catch (Exception ex) {\n+            System.err.println(log);\n+            throw ex;\n+        }\n+    }\n+\n+    \/**\n+     * An OutputStream that delegates to another stream and always throws IOException on close().\n+     *\/\n+    private static class ThrowingOutputStream extends FilterOutputStream {\n+        public ThrowingOutputStream(OutputStream out) {\n+            super(out);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            try {\n+                out.close();\n+            } catch (IOException ioe) {\n+                \/\/ ignore except to log the exception; may be useful to debug\n+                ioe.printStackTrace(System.err);\n+            }\n+            throw new IOException(FORCED_CLOSE_MSG);\n+        }\n+    }\n+\n+    \/**\n+     * An InputStream that delegates to another stream and always throws IOException on close().\n+     *\/\n+    private static class ThrowingInputStream extends FilterInputStream {\n+        public ThrowingInputStream(InputStream in) {\n+            super(in);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            try {\n+                in.close();\n+            } catch (IOException ioe) {\n+                \/\/ ignore except to log the exception; may be useful to debug\n+                ioe.printStackTrace(System.err);\n+            }\n+            throw new IOException(FORCED_CLOSE_MSG);\n+        }\n+    }\n+\n+    \/\/ Copy of ProcessExamples in java\/lang\/snippet-files\/ProcessExamples.java\n+    @Test\n+    void example() {\n+        try (Process p = new ProcessBuilder(CAT_PROGRAM).start();\n+             Writer writer = p.outputWriter();\n+             Reader reader = p.inputReader()) {\n+            writer.write(haiku);\n+            writer.close();\n+            \/\/ Read all lines and print each\n+            reader.readAllLines()\n+                    .forEach(System.out::println);\n+            var status = p.waitFor();\n+            if (status != 0)\n+                throw new RuntimeException(\"unexpected process status: \" + status);\n+        } catch (Exception e) {\n+            System.err.println(\"Process failed: \" + e);\n+        }\n+    }\n+\n+    String haiku = \"\"\"\n+                Oh, the sunrise glow;\n+                Paddling with the river flow;\n+                Chilling still, go slow.\n+                \"\"\";\n+\n+    \/**\n+     * Child program that executes child actions as named by command line args.\n+     * @param childCommands a sequence of ChildCommand names.\n+     *\/\n+    public static void main(String... childCommands)  {\n+        List<String> args = List.of(childCommands);\n+        List<ChildCommand> commands = args.stream().map(ChildCommand::valueOf).toList();\n+        commands.forEach(c -> c.command.run());\n+    }\n+\n+    \/**\n+     * Log of output produced on a thread during a test.\n+     * Normally, the output is buffered and only output to stderr if the test fails.\n+     * Set -DDEBUG=true to send all output to stderr as it occurs.\n+     *\/\n+    private static class Log {\n+\n+        private static final boolean DEBUG = Boolean.getBoolean(\"DEBUG\");\n+        private final static ScopedValue<Appendable> OUT = ScopedValue.newInstance();\n+        private final static ScopedValue.Carrier LOG = setupLog();\n+\n+        private static ScopedValue.Carrier setupLog() {\n+            if (DEBUG) {\n+                return ScopedValue.where(OUT, System.err);\n+            } else {\n+                return ScopedValue.where(OUT, new StringBuffer());\n+            }\n+        }\n+\n+        \/\/ Return the log for this thread and clear the buffer.\n+        private static Appendable get() {\n+            var log = LOG.get(OUT);\n+            if (log instanceof StringBuffer sb)\n+                sb.setLength(0);\n+            return log;\n+        }\n+\n+        \/\/ Printf to the log for this thread.\n+        private static void printf(String format, Object... args) {\n+            try {\n+                var log = LOG.get(OUT);\n+                log.append(format.formatted(args));\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Process\/ProcessCloseTest.java","additions":760,"deletions":0,"binary":false,"changes":760,"status":"added"},{"patch":"@@ -305,1 +305,1 @@\n-     * Test jdk.VirtualThreadPinned event when waiting for a class initializer.\n+     * Test jdk.VirtualThreadPinned event when waiting for a class initializer while pinned.\n@@ -308,1 +308,1 @@\n-    void testWaitingForClassInitializer() throws Exception {\n+    void testWaitingForClassInitializerWhenPinned() throws Exception {\n@@ -331,1 +331,3 @@\n-                TestClass.m();\n+                VThreadPinner.runPinned(() -> {\n+                    TestClass.m();\n+                });\n@@ -344,1 +346,1 @@\n-                \/\/ give time for second virtual thread to wait on the MutexLocker\n+                \/\/ give time for second virtual thread to wait in VM\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,490 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/timeout=480 -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit*\n+ *      -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xint\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/timeout=480 -Xint -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit*\n+ *      -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit*\n+ *      -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-TieredStopAtLevel1\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit*\n+ *      -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-noTieredCompilation\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit*\n+ *      -XX:CompileCommand=exclude,KlassInit$$Lambda*::run -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+\/*\n+ * @test id=gc\n+ * @library \/test\/lib\n+ * @requires vm.debug == true & vm.continuations\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000\n+ *      -XX:CompileCommand=exclude,KlassInit::lambda$testReleaseAtKlassInit* -XX:CompileCommand=exclude,KlassInit$$Lambda*::run\n+ *      -XX:CompileCommand=exclude,KlassInit$1Driver::foo KlassInit\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.stream.Stream;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class KlassInit {\n+    private static final int MAX_VTHREAD_COUNT = 8 * Runtime.getRuntime().availableProcessors();\n+\n+    private static final CountDownLatch finishInvokeStatic1 = new CountDownLatch(1);\n+    private static final CountDownLatch finishInvokeStatic2 = new CountDownLatch(1);\n+    private static final CountDownLatch finishInvokeStatic3 = new CountDownLatch(1);\n+    private static final CountDownLatch finishNew = new CountDownLatch(1);\n+    private static final CountDownLatch finishGetStatic = new CountDownLatch(1);\n+    private static final CountDownLatch finishPutStatic = new CountDownLatch(1);\n+    private static final CountDownLatch finishFailedInit = new CountDownLatch(1);\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on invokestatic bytecode release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitInvokeStatic1() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishInvokeStatic1.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m() {\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass.m();\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishInvokeStatic1.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test with static method that takes arguments.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitInvokeStatic2() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishInvokeStatic2.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m(ArrayList<String> list, int id) {\n+                String str = list.get(0);\n+                if (str != null && str.equals(\"VThread#\" + id)) {\n+                    list.add(\"Success\");\n+                }\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        ArrayList<String>[] lists = new ArrayList[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            lists[i] = new ArrayList<>(List.of(\"VThread#\" + i));\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass.m(lists[id], id);\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        System.gc();\n+        finishInvokeStatic2.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+            assertEquals(lists[i].get(1), \"Success\");\n+        }\n+    }\n+\n+    \/**\n+     * Test invokestatic as first bytecode in method.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitInvokeStatic3() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishInvokeStatic3.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m() {\n+            }\n+        }\n+        class Driver {\n+            static void foo() {\n+                TestClass.m();\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        started[0] = new CountDownLatch(1);\n+        vthreads[0] = Thread.ofVirtual().start(() -> {\n+            started[0].countDown();\n+            TestClass.m();\n+        });\n+        started[0].await();\n+        await(vthreads[0], Thread.State.WAITING);\n+\n+        for (int i = 1; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                Driver.foo();\n+            });\n+        }\n+        for (int i = 1; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishInvokeStatic3.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on new bytecode release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitNew() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishNew.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            void m() {\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass x = new TestClass();\n+                x.m();\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishNew.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on getstatic bytecode release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitGetStatic() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishGetStatic.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            public static int NUMBER = 150;\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        AtomicInteger[] result = new AtomicInteger[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            result[i] = new AtomicInteger();\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                result[id].set(TestClass.NUMBER);\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishGetStatic.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+            assertEquals(result[i].get(), TestClass.NUMBER);\n+        }\n+    }\n+\n+    \/**\n+     * Test that threads blocked waiting for klass to be initialized\n+     * on putstatic release the carrier.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitPutStatic() throws Exception {\n+        class TestClass {\n+            static {\n+                try {\n+                    finishPutStatic.await();\n+                } catch (InterruptedException e) {}\n+            }\n+            public static int NUMBER;\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                TestClass.NUMBER = id;\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishPutStatic.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    \/**\n+     * Test that interruptions during preemption on klass init\n+     * are preserved.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"interruptTestCases\")\n+    void testReleaseAtKlassInitPreserverInterrupt(int timeout, Runnable m, CountDownLatch finish) throws Exception {\n+        \/\/ Start vthread1 and wait until it blocks in TestClassX initializer\n+        var vthread1_started = new CountDownLatch(1);\n+        var vthread1 = Thread.ofVirtual().start(() -> {\n+                vthread1_started.countDown();\n+                m.run();\n+            });\n+        vthread1_started.await();\n+        await(vthread1, Thread.State.WAITING);\n+\n+        \/\/ Start vthread2 and wait until it gets preempted on TestClassX initialization\n+        var lock = new Object();\n+        var interruptedException = new AtomicBoolean();\n+        var vthread2_started = new CountDownLatch(1);\n+        var vthread2 = Thread.ofVirtual().start(() -> {\n+                vthread2_started.countDown();\n+                m.run();\n+                synchronized (lock) {\n+                    try {\n+                        if (timeout > 0) {\n+                            lock.wait(timeout);\n+                        } else {\n+                            lock.wait();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        \/\/ check stack trace has the expected frames\n+                        Set<String> expected = Set.of(\"wait0\", \"wait\", \"run\");\n+                        Set<String> methods = Stream.of(e.getStackTrace())\n+                                .map(StackTraceElement::getMethodName)\n+                                .collect(Collectors.toSet());\n+                        assertTrue(methods.containsAll(expected));\n+                        interruptedException.set(true);\n+                    }\n+                }\n+            });\n+        vthread2_started.await();\n+        await(vthread2, Thread.State.WAITING);\n+\n+        \/\/ Interrupt vthread2 and let initialization of TestClassX finish\n+        vthread2.interrupt();\n+        finish.countDown();\n+        vthread1.join();\n+        vthread2.join();\n+        assertTrue(interruptedException.get());\n+    }\n+\n+    static CountDownLatch finishInterrupt0 = new CountDownLatch(1);\n+    class TestClass0 {\n+        static {\n+            try {\n+                finishInterrupt0.await();\n+            } catch (InterruptedException e) {}\n+        }\n+        static void m() {}\n+    }\n+\n+    static CountDownLatch finishInterrupt30000 = new CountDownLatch(1);\n+    class TestClass30000 {\n+        static {\n+            try {\n+                finishInterrupt30000.await();\n+            } catch (InterruptedException e) {}\n+        }\n+        static void m() {}\n+    }\n+\n+    static CountDownLatch finishInterruptMax = new CountDownLatch(1);\n+    class TestClassMax {\n+        static {\n+            try {\n+                finishInterruptMax.await();\n+            } catch (InterruptedException e) {}\n+        }\n+        static void m() {}\n+    }\n+\n+    static Stream<Arguments> interruptTestCases() {\n+        return Stream.of(\n+            Arguments.of(0, (Runnable) TestClass0::m, finishInterrupt0),\n+            Arguments.of(30000, (Runnable) TestClass30000::m, finishInterrupt30000),\n+            Arguments.of(Integer.MAX_VALUE, (Runnable) TestClassMax::m, finishInterruptMax)\n+        );\n+    }\n+\n+    \/**\n+     * Test case of threads blocked waiting for klass to be initialized\n+     * when the klass initialization fails.\n+     *\/\n+    @Test\n+    void testReleaseAtKlassInitFailedInit() throws Exception {\n+        class TestClass {\n+            static int[] a = {1, 2, 3};\n+            static {\n+                try {\n+                    finishFailedInit.await();\n+                    a[3] = 4;\n+                } catch (InterruptedException e) {}\n+            }\n+            static void m() {\n+            }\n+        }\n+\n+        Thread[] vthreads = new Thread[MAX_VTHREAD_COUNT];\n+        CountDownLatch[] started = new CountDownLatch[MAX_VTHREAD_COUNT];\n+        AtomicInteger failedCount = new AtomicInteger();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            final int id = i;\n+            started[i] = new CountDownLatch(1);\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                started[id].countDown();\n+                try {\n+                    TestClass.m();\n+                } catch (NoClassDefFoundError e) {\n+                    failedCount.getAndIncrement();\n+                } catch (ExceptionInInitializerError e) {\n+                    failedCount.getAndIncrement();\n+                }\n+            });\n+        }\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            started[i].await();\n+            await(vthreads[i], Thread.State.WAITING);\n+        }\n+\n+        finishFailedInit.countDown();\n+        for (int i = 0; i < MAX_VTHREAD_COUNT; i++) {\n+            vthreads[i].join();\n+        }\n+        assertEquals(MAX_VTHREAD_COUNT, failedCount.get());\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/KlassInit.java","additions":490,"deletions":0,"binary":false,"changes":490,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -37,0 +38,1 @@\n+import org.junit.jupiter.api.BeforeAll;\n@@ -41,0 +43,6 @@\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        \/\/ waiting for LockSupport to be initialized can change the scheduling\n+        MethodHandles.lookup().ensureInitialized(LockSupport.class);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/YieldQueuing.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main LotsOfContendedMonitorEnter\n+ * @run main\/timeout=480 LotsOfContendedMonitorEnter\n@@ -31,0 +31,2 @@\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -35,0 +37,1 @@\n+    static int depth;\n@@ -37,1 +40,0 @@\n-        int depth;\n@@ -43,1 +45,11 @@\n-        VThreadRunner.run(() -> testContendedEnter(depth));\n+\n+        var exRef = new AtomicReference<Throwable>();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            try {\n+                testContendedEnter(depth);\n+            } catch (Exception e) {\n+                exRef.set(e);\n+            }\n+        });\n+        thread.join();\n+        assert exRef.get() == null;\n@@ -51,0 +63,1 @@\n+        boolean doLog = depthRemaining % 10 == 0;\n@@ -84,0 +97,3 @@\n+                    if (doLog) {\n+                        System.out.println(Instant.now() + \" => at depth: \" + (depth - depthRemaining));\n+                    }\n@@ -90,0 +106,3 @@\n+        if (doLog) {\n+            System.out.println(Instant.now() + \" => returning from depth: \" + (depth - depthRemaining));\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/LotsOfContendedMonitorEnter.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/lang\/management\/ManagementFactory\/ProxyTypeMapping.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/lang\/management\/ManagementFactory\/ValidateOpenTypes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/LockedMonitorInNative.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/Locks.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- *\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/ResetPeakThreadCount.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/ThreadCpuTime.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/ThreadUserTime.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-        udpNotResponding.close();\n+        safeClose(udpNotResponding);\n@@ -143,0 +143,13 @@\n+    private static void safeClose(final DatagramChannel channel) {\n+        if (channel == null) {\n+            return;\n+        }\n+        try {\n+            System.out.println(\"Closing DatagramChannel \" + channel.getLocalAddress());\n+            channel.close();\n+        } catch (Exception e) {\n+            System.err.println(\"Ignoring exception: \" + e.getMessage() + \" that occurred \" +\n+                    \"during close of DatagramChannel: \" + channel);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/AltServiceUsageTest.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestEchoHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpOption;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static jdk.httpclient.test.lib.common.HttpServerAdapters.createClientBuilderFor;\n+\n+\/*\n+ * @test id=withoutPropertyConfig\n+ * @bug 8368528\n+ * @summary Verifies that `Duration`-accepting programmatic public APIs, either\n+ *          individually, or in combination, work with arbitrarily large values\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ *\n+ * @run junit DurationOverflowTest\n+ *\/\n+\n+\/*\n+ * @test id=withPropertyConfig\n+ * @bug 8368528\n+ * @summary Verifies that `Duration`-accepting programmatic public APIs, either\n+ *          individually, or in combination, work with arbitrarily large values\n+ *          when combined with duration-accepting property-based public APIs.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ *\n+ * @comment 9223372036854775807 is the value of `Long.MAX_VALUE`\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.keepalive.timeout=9223372036854775807\n+ *      DurationOverflowTest\n+ *\n+ * @comment `h3` infra is also enabled for this test since `j.h.k.timeout.h3`\n+ *          defaults to `j.h.k.timeout.h2`\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.keepalive.timeout.h2=9223372036854775807\n+ *      -DallowedInfras=h2,h2s,h3\n+ *      DurationOverflowTest\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.keepalive.timeout.h3=9223372036854775807\n+ *      -DallowedInfras=h3\n+ *      DurationOverflowTest\n+ *\/\n+\n+public class DurationOverflowTest {\n+\n+    private static final String CLASS_NAME = DurationOverflowTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private static final List<Infra> INFRAS = loadInfras();\n+\n+    private static final class Infra implements AutoCloseable {\n+\n+        private static final AtomicInteger SERVER_COUNTER = new AtomicInteger();\n+\n+        private final String serverId;\n+\n+        private final HttpTestServer server;\n+\n+        private final Supplier<HttpClient.Builder> clientBuilderSupplier;\n+\n+        private final Supplier<HttpRequest.Builder> requestBuilderSupplier;\n+\n+        private final boolean secure;\n+\n+        private Infra(\n+                String serverId,\n+                HttpTestServer server,\n+                Supplier<HttpClient.Builder> clientBuilderSupplier,\n+                Supplier<HttpRequest.Builder> requestBuilderSupplier,\n+                boolean secure) {\n+            this.serverId = serverId;\n+            this.server = server;\n+            this.clientBuilderSupplier = clientBuilderSupplier;\n+            this.requestBuilderSupplier = requestBuilderSupplier;\n+            this.secure = secure;\n+        }\n+\n+        private static Infra of(Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            var sslContext = secure ? SSL_CONTEXT : null;\n+            var server = createServer(version, sslContext);\n+            server.getVersion();\n+            var handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            var requestUriScheme = secure ? \"https\" : \"http\";\n+            var requestUri = URI.create(\"%s:\/\/%s%s-\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+\n+            \/\/ Register the request handler\n+            var serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n+            server.addHandler(\n+                    \/\/ Intentionally opting for receiving a body to cover code paths associated with its retrieval\n+                    new HttpTestEchoHandler(false),\n+                    handlerPath);\n+\n+            \/\/ Create client & request builders\n+            Supplier<HttpClient.Builder> clientBuilderSupplier =\n+                    () -> createClientBuilderFor(version)\n+                            .version(version)\n+                            .sslContext(SSL_CONTEXT)\n+                            .proxy(NO_PROXY);\n+            Supplier<HttpRequest.Builder> requestBuilderSupplier =\n+                    () -> createRequestBuilder(requestUri, version);\n+\n+            \/\/ Create the pair\n+            var pair = new Infra(serverId, server, clientBuilderSupplier, requestBuilderSupplier, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", serverId, server.serverAuthority());\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                return switch (version) {\n+                    case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext, null);\n+                    case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext, null);\n+                };\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private static HttpRequest.Builder createRequestBuilder(URI uri, Version version) {\n+            var requestBuilder = HttpRequest.newBuilder(uri).version(version).HEAD();\n+            if (Version.HTTP_3.equals(version)) {\n+                requestBuilder.setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY);\n+            }\n+            return requestBuilder;\n+        }\n+\n+        @Override\n+        public void close() {\n+            LOGGER.log(\"Server[%s] is stopping\", serverId);\n+            server.stop();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var version = server.getVersion();\n+            var versionString = version.toString();\n+            return switch (version) {\n+                case HTTP_1_1, HTTP_2 -> secure ? versionString.replaceFirst(\"_\", \"S_\") : versionString;\n+                case HTTP_3 -> versionString;\n+            };\n+        }\n+\n+    }\n+\n+    private static List<Infra> loadInfras() {\n+        return Stream\n+                .of(System.getProperty(\"allowedInfras\", \"h1,h1s,h2,h2s,h3\").split(\",\"))\n+                .map(infra -> {\n+                    LOGGER.log(\"Loading test infrastructure: `%s`\", infra);\n+                    return switch (infra) {\n+                        case \"h1\" -> Infra.of(Version.HTTP_1_1, false);\n+                        case \"h1s\" -> Infra.of(Version.HTTP_1_1, true);\n+                        case \"h2\" -> Infra.of(Version.HTTP_2, false);\n+                        case \"h2s\" -> Infra.of(Version.HTTP_2, true);\n+                        case \"h3\" -> Infra.of(Version.HTTP_3, true);\n+                        default -> throw new IllegalArgumentException(\"Unknown test infrastructure: \" + infra);\n+                    };\n+                })\n+                .toList();\n+    }\n+\n+    @AfterAll\n+    static void tearDownInfras() {\n+        LOGGER.log(\"Tearing down test infrastructure\");\n+        Exception[] exceptionRef = {null};\n+        infras().forEach(infra -> {\n+            try {\n+                infra.close();\n+            } catch (Exception exception) {\n+                if (exceptionRef[0] == null) {\n+                    exceptionRef[0] = exception;\n+                } else {\n+                    exceptionRef[0].addSuppressed(exception);\n+                }\n+            }\n+        });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"Failed tearing down one or more test infrastructures\", exceptionRef[0]);\n+        }\n+    }\n+\n+    private static Stream<Infra> infras() {\n+        return INFRAS.stream();\n+    }\n+\n+    public static final Set<Duration> EXCESSIVE_DURATIONS = Set.of(\n+            Duration.MAX,\n+            \/\/ This triggers different exceptions than the ones triggered by `Duration.MAX`\n+            Duration.ofMillis(Long.MAX_VALUE));\n+\n+    private static Stream<InfraDurationPair> infraDurationPairs() {\n+        return infras().flatMap(infra -> EXCESSIVE_DURATIONS.stream()\n+                .map(duration -> new InfraDurationPair(infra, duration)));\n+    }\n+\n+    private record InfraDurationPair(Infra infra, Duration duration) {}\n+\n+    @ParameterizedTest\n+    @MethodSource(\"infraDurationPairs\")\n+    void testClientConnectTimeout(InfraDurationPair pair) throws Exception {\n+        testConfig(pair.infra, clientBuilder -> clientBuilder.connectTimeout(pair.duration), null);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"infraDurationPairs\")\n+    void testRequestTimeout(InfraDurationPair pair) throws Exception {\n+        testConfig(pair.infra, null, requestBuilder -> requestBuilder.timeout(pair.duration));\n+    }\n+\n+    private static Stream<InfraDurationDurationTriple> infraDurationDurationTriples() {\n+        return infras().flatMap(infra -> EXCESSIVE_DURATIONS.stream()\n+                .flatMap(duration1 -> EXCESSIVE_DURATIONS.stream()\n+                        .map(duration2 -> new InfraDurationDurationTriple(infra, duration1, duration2))));\n+    }\n+\n+    private record InfraDurationDurationTriple(Infra infra, Duration duration1, Duration duration2) {}\n+\n+    @ParameterizedTest\n+    @MethodSource(\"infraDurationDurationTriples\")\n+    void testClientConnectTimeoutAndRequestTimeout(InfraDurationDurationTriple triple) throws Exception {\n+        testConfig(\n+                triple.infra,\n+                clientBuilder -> clientBuilder.connectTimeout(triple.duration1),\n+                requestBuilder -> requestBuilder.timeout(triple.duration2));\n+    }\n+\n+    private static void testConfig(\n+            Infra infra,\n+            Consumer<HttpClient.Builder> clientBuilderConsumer,\n+            Consumer<HttpRequest.Builder> requestBuilderConsumer)\n+            throws Exception {\n+\n+        \/\/ Create the client\n+        var clientBuilder = infra.clientBuilderSupplier.get();\n+        if (clientBuilderConsumer != null) {\n+            clientBuilderConsumer.accept(clientBuilder);\n+        }\n+        try (var client = clientBuilder.build()) {\n+\n+            \/\/ Create the request\n+            byte[] expectedBytes = \"abc\".repeat(8192).getBytes(US_ASCII);\n+            var requestBuilder = infra.requestBuilderSupplier.get()\n+                    \/\/ Intentionally opting for sending a body to cover code paths associated with its delivery\n+                    .POST(BodyPublishers.ofByteArray(expectedBytes));\n+            if (requestBuilderConsumer != null) {\n+                requestBuilderConsumer.accept(requestBuilder);\n+            }\n+            var request = requestBuilder.build();\n+\n+            \/\/ Execute the request.\n+            \/\/ Doing it twice to touch code paths before & after a protocol upgrade, if present.\n+            for (int requestIndex = 0; requestIndex < 2; requestIndex++) {\n+                LOGGER.log(\"Executing request (attempt=%s)\", requestIndex + 1);\n+                var response = client.send(request, BodyHandlers.ofByteArray());\n+\n+                \/\/ Verify the response status code\n+                if (response.statusCode() != 200) {\n+                    var message = String.format(\n+                            \"Unexpected status code: %s (attempt=%s)\",\n+                            response.statusCode(), requestIndex + 1);\n+                    throw new AssertionError(message);\n+                }\n+\n+                \/\/ Verify the response body\n+                int mismatchIndex = Arrays.mismatch(expectedBytes, response.body());\n+                if (mismatchIndex > 0) {\n+                    var message = String.format(\n+                            \"Body mismatch at index %s (attempt=%s)\",\n+                            mismatchIndex, requestIndex + 1);\n+                    throw new AssertionError(message);\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/DurationOverflowTest.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires os.family != \"aix\"\n@@ -48,0 +49,23 @@\n+\/*\n+ * @test id=with-continuations-aix\n+ * @bug 8087112\n+ * @requires os.family == \"aix\"\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestUtil\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run testng\/othervm\/timeout=480 -XX:+HeapDumpOnOutOfMemoryError -XX:+CrashOnOutOfMemoryError\n+ *                     H3SimpleGet\n+ * @run testng\/othervm\/timeout=480 -XX:+HeapDumpOnOutOfMemoryError -XX:+CrashOnOutOfMemoryError\n+ *                     -Djdk.httpclient.retryOnStreamlimit=20\n+ *                     -Djdk.httpclient.redirects.retrylimit=21\n+ *                     -Dsimpleget.repeat=1 -Dsimpleget.chunks=1 -Dsimpleget.requests=1000\n+ *                     H3SimpleGet\n+ * @run testng\/othervm\/timeout=480 -XX:+HeapDumpOnOutOfMemoryError -XX:+CrashOnOutOfMemoryError\n+ *                     -Dsimpleget.requests=150\n+ *                     -Dsimpleget.chunks=16384\n+ *                     -Djdk.httpclient.retryOnStreamlimit=5\n+ *                     -Djdk.httpclient.redirects.retrylimit=6\n+ *                     -Djdk.httpclient.quic.defaultMTU=8192\n+ *                      H3SimpleGet\n+ *\/\n+\n@@ -78,0 +102,1 @@\n+ * @requires os.family != \"aix\"\n@@ -100,0 +125,26 @@\n+\/*\n+ * @test id=useNioSelector-aix\n+ * @bug 8087112\n+ * @requires os.family == \"aix\"\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestUtil\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run testng\/othervm\/timeout=480 -XX:+HeapDumpOnOutOfMemoryError -XX:+CrashOnOutOfMemoryError\n+ *                     -Djdk.internal.httpclient.quic.useNioSelector=true\n+ *                     H3SimpleGet\n+ * @run testng\/othervm\/timeout=480 -XX:+HeapDumpOnOutOfMemoryError -XX:+CrashOnOutOfMemoryError\n+ *                     -Djdk.internal.httpclient.quic.useNioSelector=true\n+ *                     -Djdk.httpclient.retryOnStreamlimit=20\n+ *                     -Djdk.httpclient.redirects.retrylimit=21\n+ *                     -Dsimpleget.repeat=1 -Dsimpleget.chunks=1 -Dsimpleget.requests=1000\n+ *                     H3SimpleGet\n+ * @run testng\/othervm\/timeout=480 -XX:+HeapDumpOnOutOfMemoryError -XX:+CrashOnOutOfMemoryError\n+ *                     -Djdk.internal.httpclient.quic.useNioSelector=true\n+ *                     -Dsimpleget.requests=150\n+ *                     -Dsimpleget.chunks=16384\n+ *                     -Djdk.httpclient.retryOnStreamlimit=5\n+ *                     -Djdk.httpclient.redirects.retrylimit=6\n+ *                     -Djdk.httpclient.quic.defaultMTU=8192\n+ *                      H3SimpleGet\n+ *\/\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3SimpleGet.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8368528\n+ * @summary Verifies that `Deadline` returns extremums on numeric overflows\n+ * @modules java.net.http\/jdk.internal.net.http.common:+open\n+ * @run junit java.net.http\/jdk.internal.net.http.common.DeadlineOverflowTest\n+ *\/\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/DeadlineOverflowTestDriver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.common;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+\n+import static java.time.temporal.ChronoUnit.NANOS;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class DeadlineOverflowTest {\n+\n+    @Test\n+    void test_DeadlineOf_InstantMin() {\n+        assertEquals(Instant.MIN, Deadline.of(Instant.MIN).asInstant());\n+    }\n+\n+    @Test\n+    void test_DeadlineOf_InstantMax() {\n+        assertEquals(Instant.MAX, Deadline.of(Instant.MAX).asInstant());\n+    }\n+\n+    @Test\n+    void test_plusNanos_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plusNanos(-1));\n+    }\n+\n+    @Test\n+    void test_plusNanos_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plusNanos(1));\n+    }\n+\n+    @Test\n+    void test_minus_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.minus(Duration.ofNanos(1)));\n+    }\n+\n+    @Test\n+    void test_minus_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.minus(Duration.ofNanos(-1)));\n+    }\n+\n+    @Test\n+    void test_plusAmount_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plus(-1, ChronoUnit.NANOS));\n+    }\n+\n+    @Test\n+    void test_plusAmount_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plus(1, ChronoUnit.NANOS));\n+    }\n+\n+    @Test\n+    void test_plusSeconds_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plusSeconds(-1));\n+    }\n+\n+    @Test\n+    void test_plusSeconds_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void test_plusMillis_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plusMillis(-1));\n+    }\n+\n+    @Test\n+    void test_plusMillis_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plusMillis(1));\n+    }\n+\n+    @Test\n+    void test_plusDuration_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plus(Duration.ofNanos(-1)));\n+    }\n+\n+    @Test\n+    void test_plusDuration_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plus(Duration.ofNanos(1)));\n+    }\n+\n+    @Test\n+    void test_until_min() {\n+        assertEquals(Long.MIN_VALUE, Deadline.MAX.until(Deadline.MIN, NANOS));\n+    }\n+\n+    @Test\n+    void test_until_max() {\n+        assertEquals(Long.MAX_VALUE, Deadline.MIN.until(Deadline.MAX, NANOS));\n+    }\n+\n+    @Test\n+    void test_between_min() {\n+        Duration delta = Duration.between(Instant.MAX, Instant.MIN);\n+        assertEquals(delta, Deadline.between(Deadline.MAX, Deadline.MIN));\n+    }\n+\n+    @Test\n+    void test_between_max() {\n+        Duration delta = Duration.between(Instant.MIN, Instant.MAX);\n+        assertEquals(delta, Deadline.between(Deadline.MIN, Deadline.MAX));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/common\/DeadlineOverflowTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/ShortWrite.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,6 +33,1 @@\n-import java.security.Key;\n-import java.security.KeyStore;\n-import java.security.KeyStoreException;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.NoSuchProviderException;\n-import java.security.UnrecoverableKeyException;\n+import java.security.*;\n@@ -53,0 +48,1 @@\n+ * @enablePreview\n@@ -131,8 +127,5 @@\n-    WriteP12Test() throws CertificateException {\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        caCert = cf.generateCertificate(new ByteArrayInputStream(CA_CERT_STR\n-                .getBytes()));\n-        testLeadCert = cf.generateCertificate(new ByteArrayInputStream(\n-                LEAD_CERT.getBytes()));\n-        testerCert = cf.generateCertificate(new ByteArrayInputStream(END_CERT\n-                .getBytes()));\n+    WriteP12Test() {\n+        PEMDecoder pemDecoder = PEMDecoder.of();\n+        caCert = pemDecoder.decode(CA_CERT_STR, X509Certificate.class);\n+        testLeadCert = pemDecoder.decode(LEAD_CERT, X509Certificate.class);\n+        testerCert = pemDecoder.decode(END_CERT, X509Certificate.class);\n@@ -141,3 +134,3 @@\n-    public static void main(String[] args) throws CertificateException,\n-            UnrecoverableKeyException, KeyStoreException,\n-            NoSuchProviderException, NoSuchAlgorithmException, IOException {\n+    public static void main(String[] args) throws UnrecoverableKeyException,\n+            KeyStoreException, NoSuchProviderException,\n+            NoSuchAlgorithmException, IOException, CertificateException {\n","filename":"test\/jdk\/java\/security\/KeyStore\/PKCS12\/WriteP12Test.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import java.io.BufferedInputStream;\n@@ -28,7 +27,1 @@\n-import java.io.InputStream;\n-import java.security.KeyFactory;\n-import java.security.KeyStore;\n-import java.security.KeyStoreException;\n-import java.security.NoSuchProviderException;\n-import java.security.PrivateKey;\n-import java.security.UnrecoverableKeyException;\n+import java.security.*;\n@@ -36,4 +29,1 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.KeySpec;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.util.Base64;\n+import java.security.cert.X509Certificate;\n@@ -44,0 +34,1 @@\n+ * @enablePreview\n@@ -49,23 +40,26 @@\n-    private static final String PRIVATE_KEY_PKCS8_BASE64 = \"\"\n-        + \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCpyz97liuWPDYcLH9TX8BiT78o\"\n-        + \"lCmAfmevvch6ncXUVuCzbdaKuKXwn4EVbDszsVJLoK5zdtP+X3iDhutj+IgKmLhuczF3M9VIcWr+\"\n-        + \"JJUyTH4+3h\/RT8cjCDZOmk9iXkb5ifruVsLqzb9g+Vp140Oz7leikne7KmclHvTfvFd0WDI7Gb9v\"\n-        + \"o4f5rT717BXJ\/n+M6pNk8DLpLiEu6eziYvXRv5x+t5Go3x0eCXdaxEQUf2j876Wfr2qHRJK7lDfF\"\n-        + \"e1DDsMg\/KpKGiILYZ+g2qtVMZSxtp5BZEtfB5qV\/IE5kWO+mCIAGpXSZIdbERR6pZUq8GLEe1T9e\"\n-        + \"+sO6H24w2F19AgMBAAECggEBAId\/12187dO6wUPCjumuJA1QrrBnbKdKONyai36uoc1Od4s5QFj7\"\n-        + \"+hEIeS7rbGNYQuBvnkgusAbzkW0FIpxpHce3EJez\/emux6pEOKoP77BwMt9gy+txyu0+BHi91FQg\"\n-        + \"AGvrnQDO5EYVY4Cz\/WjOsJzKu8zVLg+DS0Toa2qRFwmUe9mVAXPNOCZ3Oae\/Q6tCDsaINNw0fmjj\"\n-        + \"jn6uohPbS+n6xENG3FkQXB36getXy310xTGED2J27cmAQH6gLR6Kl2iROzNPbbpBqbuemI9kbcld\"\n-        + \"EwBS1jRfZWeaPstYA1niVrE9UgUBzemnoh4TDkG076sYthHMr5QFGjPswnwtJ4ECgYEA0sURQ5+v\"\n-        + \"baH4tdaemI3qpnknXTlzSpuZZmAoyvY0Id0mlduwKwmZ3Y5989wHfnnhFfyNO4IkTKjI2Wp97qP5\"\n-        + \"4eqUNpA7FtNU7KUzMcFDTtwtNZuRYMrKlqo2lLbA+gVrAYpYZFL4b7tcwtX4DnYorDsmude6W8sG\"\n-        + \"4Mx2VdFJC9UCgYEAzjsdXCYH5doWUHb0dvn9ID7IikffEMRM720MRjrnnnVbpzx6ACntkPDNZg7p\"\n-        + \"TRE\/mx7iBz81ZaUWE+V0wd0JvCHEdpAz3mksyvDFhU4Bgs6xzf2pSul5muhsx3hHcvvPezz5Bnxs\"\n-        + \"faJlzkxfwotyGmvWN15GA\/pyfsZjsbbTpwkCgYAO6NnbysQCIV8SnegCKqfatt9N\/O5m7LLhRxQb\"\n-        + \"p2bwrlA4cZ34rWkw\/w9x3LK7A6wkfgUPnJkswxPSLXJTG05l6M4rPfCwIKr1Qopojp9QSMr569NQ\"\n-        + \"4YeLOOc7heIIzbFQHpU6I5Rncv2Q2sn9W+ZsqJKIuvX34FjQNiZ406EzMQKBgHSxOGS61D84DuZK\"\n-        + \"2Ps1awhC3kB4eHzJRms3vflDPWoJJ+pSKwpKrzUTPHXiPBqyhtYkPGszVeiE6CAr9sv3YZnFVaBs\"\n-        + \"6hyQUJsob+uE\/w\/gGvXe8VsFDx0bJOodYfhrCbTHBHWqE81nBcocpxayxsayfAzqWB3KKd0YLrMR\"\n-        + \"K2PZAoGAcZa8915R2m0KZ6HVJUt\/JDR85jCbN71kcVDFY2XSFkOJvOdFoHNfRckfLzjq9Y2MSSTV\"\n-        + \"+QDWbDo2doUQCejJUTaN8nP79tfyir24X5uVPvQaeVoGTKYb+LfUqK0F60lStmjuddIGSZH55y3v\"\n-        + \"+9XjmxbVERtd1lqgQg3VlmKlEXY=\";\n+    private static final String PRIVATE_KEY_PKCS8_BASE64 = \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCpyz97liuWPDYcLH9TX8BiT78o\n+        lCmAfmevvch6ncXUVuCzbdaKuKXwn4EVbDszsVJLoK5zdtP+X3iDhutj+IgKmLhuczF3M9VIcWr+\n+        JJUyTH4+3h\/RT8cjCDZOmk9iXkb5ifruVsLqzb9g+Vp140Oz7leikne7KmclHvTfvFd0WDI7Gb9v\n+        o4f5rT717BXJ\/n+M6pNk8DLpLiEu6eziYvXRv5x+t5Go3x0eCXdaxEQUf2j876Wfr2qHRJK7lDfF\n+        e1DDsMg\/KpKGiILYZ+g2qtVMZSxtp5BZEtfB5qV\/IE5kWO+mCIAGpXSZIdbERR6pZUq8GLEe1T9e\n+        +sO6H24w2F19AgMBAAECggEBAId\/12187dO6wUPCjumuJA1QrrBnbKdKONyai36uoc1Od4s5QFj7\n+        +hEIeS7rbGNYQuBvnkgusAbzkW0FIpxpHce3EJez\/emux6pEOKoP77BwMt9gy+txyu0+BHi91FQg\n+        AGvrnQDO5EYVY4Cz\/WjOsJzKu8zVLg+DS0Toa2qRFwmUe9mVAXPNOCZ3Oae\/Q6tCDsaINNw0fmjj\n+        jn6uohPbS+n6xENG3FkQXB36getXy310xTGED2J27cmAQH6gLR6Kl2iROzNPbbpBqbuemI9kbcld\n+        EwBS1jRfZWeaPstYA1niVrE9UgUBzemnoh4TDkG076sYthHMr5QFGjPswnwtJ4ECgYEA0sURQ5+v\n+        baH4tdaemI3qpnknXTlzSpuZZmAoyvY0Id0mlduwKwmZ3Y5989wHfnnhFfyNO4IkTKjI2Wp97qP5\n+        4eqUNpA7FtNU7KUzMcFDTtwtNZuRYMrKlqo2lLbA+gVrAYpYZFL4b7tcwtX4DnYorDsmude6W8sG\n+        4Mx2VdFJC9UCgYEAzjsdXCYH5doWUHb0dvn9ID7IikffEMRM720MRjrnnnVbpzx6ACntkPDNZg7p\n+        TRE\/mx7iBz81ZaUWE+V0wd0JvCHEdpAz3mksyvDFhU4Bgs6xzf2pSul5muhsx3hHcvvPezz5Bnxs\n+        faJlzkxfwotyGmvWN15GA\/pyfsZjsbbTpwkCgYAO6NnbysQCIV8SnegCKqfatt9N\/O5m7LLhRxQb\n+        p2bwrlC4cZ34rWkw\/w9x3LK7A6wkfgUPnJkswxPSLXJTG05l6M4rPfCwIKr1Qopojp9QSMr569NQ\n+        4YeLOOc7heIIzbFQHpU6I5Rncv2Q2sn9W+ZsqJKIuvX34FjQNiZ406EzMQKBgHSxOGS61D84DuZK\n+        2Ps1awhC3kB4eHzJRms3vflDPWoJJ+pSKwpKrzUTPHXiPBqyhtYkPGszVeiE6CAr9sv3YZnFVaBs\n+        6hyQUJsob+uE\/w\/gGvXe8VsFDx0bJOodYfhrCbTHBHWqE81nBcocpxayxsayfAzqWB3KKd0YLrMR\n+        K2PZAoGAcZa8915R2m0KZ6HVJUt\/JDR85jCbN71kcVDFY2XSFkOJvOdFoHNfRckfLzjq9Y2MSSTV\n+        +QDWbDo2doUQCejJUTaN8nP79tfyir24X5uVPvQaeVoGTKYb+LfUqK0F60lStmjuddIGSZH55y3v\n+        +9XjmxbVERtd1lqgQg3VlmKlEXY=\n+        -----END PRIVATE KEY-----\n+        \"\"\";\n@@ -135,14 +129,3 @@\n-        \/\/ load private key\n-        \/\/ all keystore types should support private keys\n-        KeySpec spec = new PKCS8EncodedKeySpec(\n-                Base64.getMimeDecoder().decode(PRIVATE_KEY_PKCS8_BASE64));\n-        PrivateKey privateKey = KeyFactory.getInstance(\"RSA\")\n-                .generatePrivate(spec);\n-\n-        \/\/ load x509 certificate\n-        Certificate cert;\n-        try (InputStream is = new BufferedInputStream(\n-                new ByteArrayInputStream(CERTIFICATE.getBytes()))) {\n-            cert = CertificateFactory.getInstance(\"X.509\")\n-                    .generateCertificate(is);\n-        }\n+        PEMDecoder pemDecoder = PEMDecoder.of();\n+        PrivateKey privateKey = pemDecoder.decode(PRIVATE_KEY_PKCS8_BASE64, PrivateKey.class);\n+        Certificate cert = pemDecoder.decode(CERTIFICATE, X509Certificate.class);\n","filename":"test\/jdk\/java\/security\/KeyStore\/TestKeyStoreBasic.java","additions":33,"deletions":50,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+ * @enablePreview\n@@ -44,0 +45,2 @@\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -146,0 +149,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -149,5 +154,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        X509Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -157,1 +158,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -163,1 +164,1 @@\n-        Collection entries = new HashSet();\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -166,23 +167,5 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n+        entries.add(PEM_DECODER.decode(targetCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(subCaCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(topCrlIssuerCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(subCrlIssuerCertStr, X509Certificate.class));\n@@ -201,0 +184,1 @@\n+        String cert;\n@@ -202,1 +186,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            cert = subCaCertStr;\n@@ -204,1 +188,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            cert = subCrlIssuerCertStr;\n@@ -206,1 +190,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            cert = targetCertStr;\n@@ -209,1 +193,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(cert, X509Certificate.class);\n@@ -225,1 +209,0 @@\n-        X509CertSelector selector = new X509CertSelector();\n@@ -228,2 +211,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = null;\n+        String newCert;\n@@ -231,1 +213,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            newCert = subCaCertStr;\n@@ -233,1 +215,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            newCert = subCrlIssuerCertStr;\n@@ -235,1 +217,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            newCert = targetCertStr;\n@@ -237,1 +219,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(newCert, X509Certificate.class);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/selfIssued\/DisableRevocation.java","additions":24,"deletions":42,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -44,0 +45,2 @@\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -69,0 +72,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -182,2 +187,0 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -185,3 +188,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        \/\/ generate certificate from cert string\n+        X509Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -191,1 +193,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -197,36 +199,12 @@\n-        Collection entries = new HashSet();\n-\n-        \/\/ generate certificate from certificate string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n-        entries.add(cert);\n-\n-        \/\/ generate CRL from CRL string\n-        is = new ByteArrayInputStream(topCrlStr.getBytes());\n-        Collection mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n-\n-        is = new ByteArrayInputStream(subCrlStr.getBytes());\n-        mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n-\n+        Collection<DEREncodable> entries = new HashSet<>();\n+\n+        \/\/ Decode and add certificates\n+        entries.add(PEM_DECODER.decode(targetCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(subCaCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(topCrlIssuerCertStr, X509Certificate.class));\n+        entries.add(PEM_DECODER.decode(subCrlIssuerCertStr, X509Certificate.class));\n+\n+        \/\/ Decode and add CRLs\n+        entries.add(PEM_DECODER.decode(topCrlStr, X509CRL.class));\n+        entries.add(PEM_DECODER.decode(subCrlStr, X509CRL.class));\n@@ -242,2 +220,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = null;\n+        String cert;\n@@ -245,1 +222,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            cert = subCaCertStr;\n@@ -247,1 +224,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            cert = subCrlIssuerCertStr;\n@@ -249,1 +226,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            cert = targetCertStr;\n@@ -252,1 +229,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(cert, X509Certificate.class);\n@@ -266,3 +243,1 @@\n-    private static boolean match(String name, Certificate cert)\n-                throws Exception {\n-        X509CertSelector selector = new X509CertSelector();\n+    private static boolean match(String name, Certificate cert) {\n@@ -271,2 +246,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = null;\n+       String newCert;\n@@ -274,1 +248,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            newCert = subCaCertStr;\n@@ -276,1 +250,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            newCert = subCrlIssuerCertStr;\n@@ -278,1 +252,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            newCert = targetCertStr;\n@@ -280,1 +254,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(newCert, X509Certificate.class);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/selfIssued\/KeyUsageMatters.java","additions":32,"deletions":58,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -139,0 +140,2 @@\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -144,0 +147,1 @@\n+import java.util.Collections;\n@@ -196,0 +200,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -197,1 +203,1 @@\n-            throws CertificateException {\n+            throws CertificateException, IOException {\n@@ -203,1 +209,0 @@\n-        Certificate targetCert = cf.generateCertificate(is);\n@@ -206,1 +211,2 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {targetCert});\n+        List<Certificate> list = Collections.singletonList(PEM_DECODER.decode\n+                (is, X509Certificate.class));\n@@ -211,2 +217,1 @@\n-    private static Set<TrustAnchor> generateTrustAnchors()\n-            throws CertificateException {\n+    private static Set<TrustAnchor> generateTrustAnchors() {\n@@ -214,5 +219,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n+        X509Certificate trustedCert = PEM_DECODER.decode(trusedCertStr, X509Certificate.class);\n@@ -221,1 +222,1 @@\n-        TrustAnchor anchor = new TrustAnchor((X509Certificate)trusedCert, null);\n+        TrustAnchor anchor = new TrustAnchor(trustedCert, null);\n@@ -234,1 +235,4 @@\n-        Collection<? extends CRL> crls = cf.generateCRLs(is);\n+        Collection<DEREncodable> crls = new HashSet<>();\n+\n+        crls.add(PEM_DECODER.decode(crlStr, X509CRL.class));\n+\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/FailoverToCRL.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+ * @enablePreview\n@@ -41,0 +42,2 @@\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -110,0 +113,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -115,4 +120,1 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n+        Certificate targetCert = PEM_DECODER.decode(targetCertStr, X509Certificate.class);\n@@ -120,2 +122,1 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -124,2 +125,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, selfSignedCert);\n@@ -133,5 +133,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        X509Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -141,1 +137,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -147,5 +143,0 @@\n-        \/\/ generate CRL from CRL string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(crlStr.getBytes());\n@@ -154,8 +145,3 @@\n-        Collection crls = cf.generateCRLs(is);\n-\n-        is = new ByteArrayInputStream(crlIssuerCertStr.getBytes());\n-        Collection certs = cf.generateCertificates(is);\n-\n-        Collection entries = new HashSet();\n-        entries.addAll(crls);\n-        entries.addAll(certs);\n+        Collection<DEREncodable> entries = new HashSet<>();\n+        entries.add(PEM_DECODER.decode(crlStr, X509CRL.class));\n+        entries.add(PEM_DECODER.decode(crlIssuerCertStr, X509Certificate.class));\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLOneLevel.java","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+ * @enablePreview\n@@ -41,0 +42,2 @@\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -111,0 +114,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -116,4 +121,1 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n+        Certificate targetCert = PEM_DECODER.decode(targetCertStr, X509Certificate.class);\n@@ -121,2 +123,1 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -125,2 +126,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, selfSignedCert);\n@@ -134,5 +134,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        X509Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -142,1 +138,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -149,14 +145,3 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(crlStr.getBytes());\n-\n-        \/\/ generate a cert store\n-        Collection crls = cf.generateCRLs(is);\n-\n-        is = new ByteArrayInputStream(crlIssuerCertStr.getBytes());\n-        Collection certs = cf.generateCertificates(is);\n-\n-        Collection entries = new HashSet();\n-        entries.addAll(crls);\n-        entries.addAll(certs);\n+        Collection<DEREncodable> entries = new HashSet<>();\n+        entries.add(PEM_DECODER.decode(crlStr, X509CRL.class));\n+        entries.add(PEM_DECODER.decode(crlIssuerCertStr, X509Certificate.class));\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLOneLevelRevoked.java","additions":14,"deletions":29,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @enablePreview\n@@ -34,0 +35,1 @@\n+import java.security.PEMDecoder;\n@@ -93,0 +95,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -98,4 +102,1 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n+        Certificate targetCert = PEM_DECODER.decode(targetCertStr, X509Certificate.class);\n@@ -103,2 +104,1 @@\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        Certificate subCaCert = cf.generateCertificate(is);\n+        Certificate subCaCert = PEM_DECODER.decode(subCaCertStr, X509Certificate.class);\n@@ -106,2 +106,1 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -110,2 +109,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, subCaCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n@@ -119,5 +117,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        X509Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -127,1 +121,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/nameConstraints\/NameConstraintsWithRID.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @enablePreview\n@@ -34,0 +35,1 @@\n+import java.security.PEMDecoder;\n@@ -93,0 +95,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of()\n+            ;\n@@ -94,1 +98,1 @@\n-            throws CertificateException {\n+            throws CertificateException, IOException {\n@@ -101,1 +105,1 @@\n-        Certificate targetCert = cf.generateCertificate(is);\n+        Certificate targetCert = PEM_DECODER.decode(is, X509Certificate.class);\n@@ -104,1 +108,1 @@\n-        Certificate subCaCert = cf.generateCertificate(is);\n+        Certificate subCaCert = PEM_DECODER.decode(is, X509Certificate.class);\n@@ -107,1 +111,1 @@\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate selfSignedCert = PEM_DECODER.decode(is, X509Certificate.class);\n@@ -110,2 +114,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, subCaCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n@@ -117,1 +120,1 @@\n-            throws CertificateException {\n+            throws IOException {\n@@ -119,2 +122,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n@@ -123,1 +124,1 @@\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        X509Certificate selfSignedCert = PEM_DECODER.decode(is, X509Certificate.class);;\n@@ -127,1 +128,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/nameConstraints\/NameConstraintsWithUnexpectedRID.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @enablePreview\n@@ -34,0 +35,1 @@\n+import java.security.PEMDecoder;\n@@ -93,0 +95,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -98,4 +102,1 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n+        Certificate targetCert = PEM_DECODER.decode(targetCertStr, X509Certificate.class);\n@@ -103,2 +104,1 @@\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        Certificate subCaCert = cf.generateCertificate(is);\n+        Certificate subCaCert = PEM_DECODER.decode(subCaCertStr, X509Certificate.class);\n@@ -106,2 +106,1 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -110,2 +109,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, subCaCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n@@ -119,5 +117,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        X509Certificate selfSignedCert = PEM_DECODER.decode(selfSignedCertStr, X509Certificate.class);\n@@ -127,1 +121,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/nameConstraints\/NameConstraintsWithoutRID.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @enablePreview\n@@ -33,0 +34,2 @@\n+import java.io.IOException;\n+import java.security.PEMDecoder;\n@@ -235,3 +238,4 @@\n-        X509Certificate rootCert = generateCertificate(cf, ROOT_CA_CERT);\n-        X509Certificate eeCert = generateCertificate(cf, EE_CERT);\n-        X509Certificate intCaCert = generateCertificate(cf, INT_CA_CERT);\n+        PEMDecoder pemDecoder = PEMDecoder.of();\n+        X509Certificate rootCert = pemDecoder.decode(ROOT_CA_CERT, X509Certificate.class);\n+        X509Certificate eeCert = pemDecoder.decode(EE_CERT, X509Certificate.class);\n+        X509Certificate intCaCert = pemDecoder.decode(INT_CA_CERT, X509Certificate.class);\n@@ -286,6 +290,0 @@\n-\n-    private static X509Certificate generateCertificate(CertificateFactory cf,\n-            String encoded) throws CertificateException {\n-        ByteArrayInputStream is = new ByteArrayInputStream(encoded.getBytes());\n-        return (X509Certificate)cf.generateCertificate(is);\n-    }\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/trustAnchor\/ValWithAnchorByName.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *          4802647 7123424 8024709 8193128 8327858 8346307\n+ *          4802647 7123424 8024709 8193128 8327858 8346307 8368178\n@@ -476,0 +476,1 @@\n+        THROWS(NoSuchElementException.class, c::getFirst, c::getLast);\n@@ -478,0 +479,1 @@\n+        equal2(c, c.reversed());\n@@ -1236,0 +1238,4 @@\n+        if (!l.isEmpty()) {\n+            equal(l.getFirst(), l.get(0));\n+            equal(l.getLast(), l.get(l.size() - 1));\n+        }\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,7 @@\n+    private static void checkReversed() {\n+        List<String> copies = Collections.nCopies(10, \"content\");\n+        check(copies.equals(copies.reversed()));\n+        List<String> empty = Collections.nCopies(0, \"content\");\n+        check(empty.equals(empty.reversed()));\n+    }\n+\n@@ -152,0 +159,2 @@\n+            checkReversed();\n+\n","filename":"test\/jdk\/java\/util\/Collections\/NCopies.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.NoSuchElementException;\n+import java.util.function.Consumer;\n@@ -48,1 +50,1 @@\n-import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.assertThrows;\n@@ -386,0 +388,18 @@\n+\n+    @Test(dataProvider = \"all\")\n+    public void getFirst(List<String> act, List<String> exp) {\n+        if (!act.isEmpty()) {\n+            assertEquals(act.getFirst(), exp.getFirst());\n+        } else {\n+            assertThrows(NoSuchElementException.class, act::getFirst);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"all\")\n+    public void getLast(List<String> act, List<String> exp) {\n+        if (!act.isEmpty()) {\n+            assertEquals(act.getLast(), exp.getLast());\n+        } else {\n+            assertThrows(NoSuchElementException.class, act::getLast);\n+        }\n+    }\n","filename":"test\/jdk\/java\/util\/List\/ListFactories.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+        testOfEpochMillisTimestamp();\n@@ -149,0 +150,38 @@\n+    private static void testOfEpochMillisTimestamp() {\n+        \/\/ Should not throw for valid currentTimeMillis() timestamp\n+        long timestamp = System.currentTimeMillis();\n+        try {\n+            UUID u = UUID.ofEpochMillis(timestamp);\n+            if (u == null) {\n+                throw new AssertionError(\"Generated UUID should not be null for timestamp: \" + timestamp);\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Unexpected exception with timestamp \" + timestamp, e);\n+        }\n+\n+        \/\/ Should not throw for the 48-bit long\n+        long value = 0xFEDCBA987654L;\n+        try {\n+            UUID u = UUID.ofEpochMillis(value);\n+            if (u == null) {\n+                throw new AssertionError(\"Generated UUID should not be null for 48-bit long: \" + value);\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(\"Unexpected exception with 48-bit long \" + value, e);\n+        }\n+\n+        \/\/ Should throw for negative timestamp\n+        value = -0xFEDCBA987654L;\n+        try {\n+            UUID.ofEpochMillis(value);\n+            throw new AssertionError(\"Expected IllegalArgumentException with negative timestamp: \" + value);\n+        } catch (IllegalArgumentException expected) {}\n+\n+        \/\/ Should throw for timestamp > 48 bits\n+        value = 1L << 48;\n+        try {\n+            UUID.ofEpochMillis(value);\n+            throw new AssertionError(\"Expected IllegalArgumentException with timestamp > 48 bits: \" + value);\n+        } catch (IllegalArgumentException expected) {}\n+    }\n+\n@@ -190,0 +229,9 @@\n+        long timestamp = System.currentTimeMillis();\n+        test = UUID.ofEpochMillis(timestamp);\n+        if (test.version() != 7) {\n+            throw new Exception(\"ofEpochMillis not type 7: \" + test);\n+        }\n+        if (test.variant() != 2) {\n+            throw new Exception(\"ofEpochMillis not variant 2: \" + test);\n+        }\n+\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.security.KeyFactory;\n-import java.security.KeyStore;\n-import java.security.PrivateKey;\n-import java.security.Security;\n+import java.security.*;\n@@ -34,0 +31,1 @@\n+import java.security.cert.X509Certificate;\n@@ -52,0 +50,1 @@\n+ * @enablePreview\n@@ -318,2 +317,1 @@\n-        \/\/ Generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -326,1 +324,1 @@\n-        char passphrase[] = \"passphrase\".toCharArray();\n+        char[] passphrase = \"passphrase\".toCharArray();\n@@ -330,2 +328,1 @@\n-                cf.generateCertificate(new ByteArrayInputStream(\n-                        trustedCertStr.getBytes())));\n+                pemDecoder.decode(trustedCertStr, X509Certificate.class));\n@@ -337,5 +334,1 @@\n-            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                    Base64.getMimeDecoder().decode(privateKey));\n-            KeyFactory kf = KeyFactory.getInstance(keyType);\n-            PrivateKey priKey = kf.generatePrivate(priKeySpec);\n-\n+            PrivateKey priKey = pemDecoder.decode(privateKey, PrivateKey.class);\n@@ -343,3 +336,2 @@\n-            Certificate keyCert = cf.generateCertificate(\n-                    new ByteArrayInputStream(keyCertStr.getBytes()));\n-            Certificate[] chain = new Certificate[]{keyCert};\n+            Certificate keyCert =pemDecoder.decode(keyCertStr, X509Certificate.class);\n+                    Certificate[] chain = new Certificate[]{keyCert};\n@@ -425,1 +417,2 @@\n-                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgVHQp1EG3PgASz7Nu\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgVHQp1EG3PgASz7Nu\\n\"\n@@ -427,1 +420,2 @@\n-                + \"jE3qvm5PVrGRgTmcyXBLcq9fPOyQEbq59Lieyd2C1DZTLh2klmfIRMRr\"\n+                + \"jE3qvm5PVrGRgTmcyXBLcq9fPOyQEbq59Lieyd2C1DZTLh2klmfIRMRr\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -452,1 +446,2 @@\n-                \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgyJJNI8eqYVKcCshG\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgyJJNI8eqYVKcCshG\\n\"\n@@ -454,1 +449,2 @@\n-                + \"ktaIGEdCrA8BKk0A30LW8SY5Be29ScYu8d+IjQ3X\/fpblrVh\/64pOgQz\"\n+                + \"ktaIGEdCrA8BKk0A30LW8SY5Be29ScYu8d+IjQ3X\/fpblrVh\/64pOgQz\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -490,1 +486,2 @@\n-                \"MIIEuwIBADALBgkqhkiG9w0BAQoEggSnMIIEowIBAAKCAQEApfK+EK4NuwWFDv9V\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEuwIBADALBgkqhkiG9w0BAQoEggSnMIIEowIBAAKCAQEApfK+EK4NuwWFDv9V\\n\"\n@@ -515,1 +512,2 @@\n-                + \"Q2hO5ZTW6UD9CVA85whf\"\n+                + \"Q2hO5ZTW6UD9CVA85whf\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -582,1 +580,2 @@\n-                \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDD8nVjgSWSwVmP\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDD8nVjgSWSwVmP\\n\"\n@@ -607,1 +606,2 @@\n-                + \"xkWyr\/6XyeGP\/vX8WvfF2eM=\"\n+                + \"xkWyr\/6XyeGP\/vX8WvfF2eM=\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -641,1 +641,2 @@\n-                \"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQClt40e4e\/lW5S1\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQClt40e4e\/lW5S1\\n\"\n@@ -666,1 +667,2 @@\n-                + \"PsRyQCB\/QarxsDNAuioguQ==\"\n+                + \"PsRyQCB\/QarxsDNAuioguQ==\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -700,1 +702,2 @@\n-                \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDaMM8YyiBz12rb\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDaMM8YyiBz12rb\\n\"\n@@ -725,1 +728,2 @@\n-                + \"Pg5M5wrRqs71s2EiIJd0HrU=\"\n+                + \"Pg5M5wrRqs71s2EiIJd0HrU=\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -759,1 +763,2 @@\n-                \"MIIEwAIBADANBgkqhkiG9w0BAQEFAASCBKowggSmAgEAAoIBAQC8iCdCvecakzP9\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEwAIBADANBgkqhkiG9w0BAQEFAASCBKowggSmAgEAAoIBAQC8iCdCvecakzP9\\n\"\n@@ -784,1 +789,2 @@\n-                + \"mzO1FvNUBCMZb\/5PQdiFw3pMEyQ=\"\n+                + \"mzO1FvNUBCMZb\/5PQdiFw3pMEyQ=\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -818,1 +824,2 @@\n-                \"MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDaF4fhwBKMatza\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDaF4fhwBKMatza\\n\"\n@@ -843,1 +850,2 @@\n-                + \"l0uEakWMhPrvr\/N1FT1KXo6S\"\n+                + \"l0uEakWMhPrvr\/N1FT1KXo6S\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -870,1 +878,2 @@\n-                \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDCpxyn85BJ+JFfT5U7U\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDCpxyn85BJ+JFfT5U7U\\n\"\n@@ -873,1 +882,2 @@\n-                + \"haGKuapP5dtU9NYglvbjkt\/0YWJH93pTJRupe42D0amdRGzLlmHHgN8=\"\n+                + \"haGKuapP5dtU9NYglvbjkt\/0YWJH93pTJRupe42D0amdRGzLlmHHgN8=\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -901,1 +911,2 @@\n-                \"MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIAz7qc9msPhSoh0iiT\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIAz7qc9msPhSoh0iiT\\n\"\n@@ -906,1 +917,2 @@\n-                + \"Vg==\"\n+                + \"Vg==\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -973,1 +985,2 @@\n-                \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCe7chGqR+iYpXW\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCe7chGqR+iYpXW\\n\"\n@@ -998,1 +1011,2 @@\n-                + \"T9fE4yY\/E4FyzS7yMeoXIyo=\"\n+                + \"T9fE4yY\/E4FyzS7yMeoXIyo=\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -1065,1 +1079,2 @@\n-                \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDCyeGmgpaHoXnR\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDCyeGmgpaHoXnR\\n\"\n@@ -1090,1 +1105,2 @@\n-                + \"GA3T726uW8XrrTssMkhzixU=\"\n+                + \"GA3T726uW8XrrTssMkhzixU=\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -1126,1 +1142,2 @@\n-                \"MIIEvAIBADALBgkqhkiG9w0BAQoEggSoMIIEpAIBAAKCAQEAz+1\/SVKdaz83Mcs6\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvAIBADALBgkqhkiG9w0BAQoEggSoMIIEpAIBAAKCAQEAz+1\/SVKdaz83Mcs6\\n\"\n@@ -1151,1 +1168,2 @@\n-                + \"LsJldTLzMQSVP\/05BAt6DQ==\"\n+                + \"LsJldTLzMQSVP\/05BAt6DQ==\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n@@ -1187,1 +1205,2 @@\n-                \"MIIEvAIBADALBgkqhkiG9w0BAQoEggSoMIIEpAIBAAKCAQEAxv\/aW7ezE+gXt2lI\\n\"\n+                \"-----BEGIN PRIVATE KEY-----\\n\"\n+                + \"MIIEvAIBADALBgkqhkiG9w0BAQoEggSoMIIEpAIBAAKCAQEAxv\/aW7ezE+gXt2lI\\n\"\n@@ -1212,1 +1231,2 @@\n-                + \"KtqEurWf+mUeJVzLj1x1BA==\"\n+                + \"KtqEurWf+mUeJVzLj1x1BA==\\n\"\n+                + \"-----END PRIVATE KEY-----\"\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/TLSTest.java","additions":65,"deletions":45,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,7 +52,0 @@\n-    \/*\n-     * Deletes log file if exists.\n-     *\/\n-    protected void deleteLog() throws IOException {\n-        Utilities.deleteFile(getLogPath());\n-    }\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/AbstractPeer.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,1 +151,0 @@\n-        deleteLog();\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/JdkProcClient.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,0 @@\n-        deleteLog();\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/JdkProcServer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * @bug 4211052\n+ * @bug 4211052 8370465\n@@ -158,0 +158,10 @@\n+        menuItem = new JMenuItem(\"Text to the left\", new MyMenuItemIcon());\n+        menuItem.setComponentOrientation(o);\n+        menuItem.setHorizontalTextPosition(SwingConstants.LEFT);\n+        menu.add(menuItem);\n+\n+        menuItem = new JMenuItem(\"Text to the right\", new MyMenuItemIcon());\n+        menuItem.setComponentOrientation(o);\n+        menuItem.setHorizontalTextPosition(SwingConstants.RIGHT);\n+        menu.add(menuItem);\n+\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/RightLeftOrientation.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,1 @@\n-import java.math.BigInteger;\n-import java.nio.charset.StandardCharsets;\n-import jdk.internal.math.FDBigInteger;\n+import jdk.internal.math.FDBigIntegerChecker;\n@@ -28,1 +26,1 @@\n-\/**\n+\/*\n@@ -33,1 +31,3 @@\n- * @author Dmitry Nadezhin\n+ * @library java.base\n+ * @build java.base\/jdk.internal.math.*\n+ * @run main TestFDBigInteger\n@@ -37,384 +37,0 @@\n-    private static final int MAX_P5 = 413;\n-    private static final int MAX_P2 = 65;\n-    private static final long LONG_SIGN_MASK = (1L << 63);\n-    private static final BigInteger FIVE = BigInteger.valueOf(5);\n-    private static final FDBigInteger MUTABLE_ZERO = FDBigInteger.valueOfPow52(0, 0).leftInplaceSub(FDBigInteger.valueOfPow52(0, 0));\n-    private static final FDBigInteger IMMUTABLE_ZERO = FDBigInteger.valueOfPow52(0, 0).leftInplaceSub(FDBigInteger.valueOfPow52(0, 0));\n-    private static final FDBigInteger IMMUTABLE_MILLION = genMillion1();\n-    private static final FDBigInteger IMMUTABLE_BILLION = genBillion1();\n-    private static final FDBigInteger IMMUTABLE_TEN18 = genTen18();\n-\n-    static {\n-        IMMUTABLE_ZERO.makeImmutable();\n-        IMMUTABLE_MILLION.makeImmutable();\n-        IMMUTABLE_BILLION.makeImmutable();\n-        IMMUTABLE_TEN18.makeImmutable();\n-    }\n-\n-    private static FDBigInteger mutable(String hex, int offset) {\n-        byte[] chars = new BigInteger(hex, 16).toString().getBytes(StandardCharsets.US_ASCII);\n-        return new FDBigInteger(0, chars, 0, chars.length).multByPow52(0, offset * 32);\n-    }\n-\n-    private static FDBigInteger immutable(String hex, int offset) {\n-        FDBigInteger fd = mutable(hex, offset);\n-        fd.makeImmutable();\n-        return fd;\n-    }\n-\n-    private static BigInteger biPow52(int p5, int p2) {\n-        return FIVE.pow(p5).shiftLeft(p2);\n-    }\n-\n-    \/\/ data.length == 1, nWords == 1, offset == 0\n-    private static FDBigInteger genMillion1() {\n-        return FDBigInteger.valueOfPow52(6, 0).leftShift(6);\n-    }\n-\n-    \/\/ data.length == 2, nWords == 1, offset == 0\n-    private static FDBigInteger genMillion2() {\n-        return FDBigInteger.valueOfMulPow52(1000000L, 0, 0);\n-    }\n-\n-    \/\/ data.length == 1, nWords == 1, offset == 0\n-    private static FDBigInteger genBillion1() {\n-        return FDBigInteger.valueOfPow52(9, 0).leftShift(9);\n-    }\n-\n-    \/\/ data.length == 2, nWords == 2, offset == 0\n-    private static FDBigInteger genTen18() {\n-        return FDBigInteger.valueOfPow52(18, 0).leftShift(18);\n-    }\n-\n-    private static void check(BigInteger expected, FDBigInteger actual, String message) throws Exception {\n-        if (!expected.equals(actual.toBigInteger())) {\n-            throw new Exception(message + \" result \" + actual.toHexString() + \" expected \" + expected.toString(16));\n-        }\n-    }\n-\n-    private static void testValueOfPow52(int p5, int p2) throws Exception {\n-        check(biPow52(p5, p2), FDBigInteger.valueOfPow52(p5, p2),\n-                \"valueOfPow52(\" + p5 + \",\" + p2 + \")\");\n-    }\n-\n-    private static void testValueOfPow52() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-                testValueOfPow52(p5, p2);\n-            }\n-        }\n-    }\n-\n-    private static void testValueOfMulPow52(long value, int p5, int p2) throws Exception {\n-        BigInteger bi = BigInteger.valueOf(value & ~LONG_SIGN_MASK);\n-        if (value < 0) {\n-            bi = bi.setBit(63);\n-        }\n-        check(biPow52(p5, p2).multiply(bi), FDBigInteger.valueOfMulPow52(value, p5, p2),\n-                \"valueOfMulPow52(\" + Long.toHexString(value) + \".\" + p5 + \",\" + p2 + \")\");\n-    }\n-\n-    private static void testValueOfMulPow52(long value, int p5) throws Exception {\n-        testValueOfMulPow52(value, p5, 0);\n-        testValueOfMulPow52(value, p5, 1);\n-        testValueOfMulPow52(value, p5, 30);\n-        testValueOfMulPow52(value, p5, 31);\n-        testValueOfMulPow52(value, p5, 33);\n-        testValueOfMulPow52(value, p5, 63);\n-    }\n-\n-    private static void testValueOfMulPow52() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            testValueOfMulPow52(0xFFFFFFFFL, p5);\n-            testValueOfMulPow52(0x123456789AL, p5);\n-            testValueOfMulPow52(0x7FFFFFFFFFFFFFFFL, p5);\n-            testValueOfMulPow52(0xFFFFFFFFFFF54321L, p5);\n-        }\n-    }\n-\n-    private static void testLeftShift(FDBigInteger t, int shift, boolean isImmutable) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        FDBigInteger r = t.leftShift(shift);\n-        if ((bt.signum() == 0 || shift == 0 || !isImmutable) && r != t) {\n-            throw new Exception(\"leftShift doesn't reuse its argument\");\n-        }\n-        if (isImmutable) {\n-            check(bt, t, \"leftShift corrupts its argument\");\n-        }\n-        check(bt.shiftLeft(shift), r, \"leftShift returns wrong result\");\n-    }\n-\n-    private static void testLeftShift() throws Exception {\n-        testLeftShift(IMMUTABLE_ZERO, 0, true);\n-        testLeftShift(IMMUTABLE_ZERO, 10, true);\n-        testLeftShift(MUTABLE_ZERO, 0, false);\n-        testLeftShift(MUTABLE_ZERO, 10, false);\n-\n-        testLeftShift(IMMUTABLE_MILLION, 0, true);\n-        testLeftShift(IMMUTABLE_MILLION, 1, true);\n-        testLeftShift(IMMUTABLE_MILLION, 12, true);\n-        testLeftShift(IMMUTABLE_MILLION, 13, true);\n-        testLeftShift(IMMUTABLE_MILLION, 32, true);\n-        testLeftShift(IMMUTABLE_MILLION, 33, true);\n-        testLeftShift(IMMUTABLE_MILLION, 44, true);\n-        testLeftShift(IMMUTABLE_MILLION, 45, true);\n-\n-        testLeftShift(genMillion1(), 0, false);\n-        testLeftShift(genMillion1(), 1, false);\n-        testLeftShift(genMillion1(), 12, false);\n-        testLeftShift(genMillion1(), 13, false);\n-        testLeftShift(genMillion1(), 25, false);\n-        testLeftShift(genMillion1(), 26, false);\n-        testLeftShift(genMillion1(), 32, false);\n-        testLeftShift(genMillion1(), 33, false);\n-        testLeftShift(genMillion1(), 44, false);\n-        testLeftShift(genMillion1(), 45, false);\n-\n-        testLeftShift(genMillion2(), 0, false);\n-        testLeftShift(genMillion2(), 1, false);\n-        testLeftShift(genMillion2(), 12, false);\n-        testLeftShift(genMillion2(), 13, false);\n-        testLeftShift(genMillion2(), 25, false);\n-        testLeftShift(genMillion2(), 26, false);\n-        testLeftShift(genMillion2(), 32, false);\n-        testLeftShift(genMillion2(), 33, false);\n-        testLeftShift(genMillion2(), 44, false);\n-        testLeftShift(genMillion2(), 45, false);\n-    }\n-\n-    private static void testQuoRemIteration(FDBigInteger t, FDBigInteger s) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bs = s.toBigInteger();\n-        int q = t.quoRemIteration(s);\n-        BigInteger[] qr = bt.divideAndRemainder(bs);\n-        if (!BigInteger.valueOf(q).equals(qr[0])) {\n-            throw new Exception(\"quoRemIteration returns incorrect quo\");\n-        }\n-        check(qr[1].multiply(BigInteger.TEN), t, \"quoRemIteration returns incorrect rem\");\n-    }\n-\n-    private static void testQuoRemIteration() throws Exception {\n-        \/\/ IMMUTABLE_TEN18 == 0de0b6b3a7640000\n-        \/\/ q = 0\n-        testQuoRemIteration(mutable(\"00000001\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"00000001\", 1), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b2\", 1), IMMUTABLE_TEN18);\n-        \/\/ q = 1 -> q = 0\n-        testQuoRemIteration(mutable(\"0de0b6b3\", 1), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b3a763FFFF\", 0), IMMUTABLE_TEN18);\n-        \/\/ q = 1\n-        testQuoRemIteration(mutable(\"0de0b6b3a7640000\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b3FFFFFFFF\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"8ac72304\", 1), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"0de0b6b400000000\", 0), IMMUTABLE_TEN18);\n-        testQuoRemIteration(mutable(\"8ac72305\", 1), IMMUTABLE_TEN18);\n-        \/\/ q = 18\n-        testQuoRemIteration(mutable(\"FFFFFFFF\", 1), IMMUTABLE_TEN18);\n-    }\n-\n-    private static void testCmp(FDBigInteger t, FDBigInteger o) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bo = o.toBigInteger();\n-        int cmp = t.cmp(o);\n-        int bcmp = bt.compareTo(bo);\n-        if (bcmp != cmp) {\n-            throw new Exception(\"cmp returns \" + cmp + \" expected \" + bcmp);\n-        }\n-        check(bt, t, \"cmp corrupts this\");\n-        check(bo, o, \"cmp corrupts other\");\n-        if (o.cmp(t) != -cmp) {\n-            throw new Exception(\"asymmetrical cmp\");\n-        }\n-        check(bt, t, \"cmp corrupts this\");\n-        check(bo, o, \"cmp corrupts other\");\n-    }\n-\n-    private static void testCmp() throws Exception {\n-        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"100000000\", 0));\n-        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"1\", 1));\n-        testCmp(mutable(\"5\", 0), mutable(\"6\", 0));\n-        testCmp(mutable(\"5\", 0), mutable(\"5\", 0));\n-        testCmp(mutable(\"5000000001\", 0), mutable(\"500000001\", 0));\n-        testCmp(mutable(\"5000000001\", 0), mutable(\"6\", 1));\n-        testCmp(mutable(\"5000000001\", 0), mutable(\"5\", 1));\n-        testCmp(mutable(\"5000000000\", 0), mutable(\"5\", 1));\n-    }\n-\n-    private static void testCmpPow52(FDBigInteger t, int p5, int p2) throws Exception {\n-        FDBigInteger o = FDBigInteger.valueOfPow52(p5, p2);\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bo = biPow52(p5, p2);\n-        int cmp = t.cmp(o);\n-        int bcmp = bt.compareTo(bo);\n-        if (bcmp != cmp) {\n-            throw new Exception(\"cmpPow52 returns \" + cmp + \" expected \" + bcmp);\n-        }\n-        check(bt, t, \"cmpPow52 corrupts this\");\n-        check(bo, o, \"cmpPow5 corrupts other\");\n-    }\n-\n-    private static void testCmpPow52() throws Exception {\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 31);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 32);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 33);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 34);\n-        testCmpPow52(mutable(\"00000002\", 1), 0, 64);\n-        testCmpPow52(mutable(\"00000003\", 1), 0, 32);\n-        testCmpPow52(mutable(\"00000003\", 1), 0, 33);\n-        testCmpPow52(mutable(\"00000003\", 1), 0, 34);\n-    }\n-\n-    private static void testAddAndCmp(FDBigInteger t, FDBigInteger x, FDBigInteger y) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        BigInteger bx = x.toBigInteger();\n-        BigInteger by = y.toBigInteger();\n-        int cmp = t.addAndCmp(x, y);\n-        int bcmp = bt.compareTo(bx.add(by));\n-        if (bcmp != cmp) {\n-            throw new Exception(\"addAndCmp returns \" + cmp + \" expected \" + bcmp);\n-        }\n-        check(bt, t, \"addAndCmp corrupts this\");\n-        check(bx, x, \"addAndCmp corrupts x\");\n-        check(by, y, \"addAndCmp corrupts y\");\n-    }\n-\n-    private static void testAddAndCmp() throws Exception {\n-        testAddAndCmp(MUTABLE_ZERO, MUTABLE_ZERO, MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 0), MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000001\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000002\", 0), MUTABLE_ZERO);\n-        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000002\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"FFFFFFFF\", 0), mutable(\"FFFFFFFF\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 1), mutable(\"00000001\", 0));\n-\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0F80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0E80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n-\n-        testAddAndCmp(mutable(\"00000002\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-        testAddAndCmp(mutable(\"00000003\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-        testAddAndCmp(mutable(\"00000004\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-        testAddAndCmp(mutable(\"00000005\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n-\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n-        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000001\", 0));\n-        testAddAndCmp(mutable(\"00000002\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n-        testAddAndCmp(mutable(\"00000003\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n-    }\n-\n-    private static void testMultBy10(FDBigInteger t, boolean isImmutable) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        FDBigInteger r = t.multBy10();\n-        if ((bt.signum() == 0 || !isImmutable) && r != t) {\n-            throw new Exception(\"multBy10 of doesn't reuse its argument\");\n-        }\n-        if (isImmutable) {\n-            check(bt, t, \"multBy10 corrupts its argument\");\n-        }\n-        check(bt.multiply(BigInteger.TEN), r, \"multBy10 returns wrong result\");\n-    }\n-\n-    private static void testMultBy10() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-                \/\/ This strange way of creating a value ensures that it is mutable.\n-                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                testMultBy10(value, false);\n-                value.makeImmutable();\n-                testMultBy10(value, true);\n-            }\n-        }\n-    }\n-\n-    private static void testMultByPow52(FDBigInteger t, int p5, int p2) throws Exception {\n-        BigInteger bt = t.toBigInteger();\n-        FDBigInteger r = t.multByPow52(p5, p2);\n-        if (bt.signum() == 0 && r != t) {\n-            throw new Exception(\"multByPow52 of doesn't reuse its argument\");\n-        }\n-        check(bt.multiply(biPow52(p5, p2)), r, \"multByPow52 returns wrong result\");\n-    }\n-\n-    private static void testMultByPow52() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-                \/\/ This strange way of creating a value ensures that it is mutable.\n-                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                testMultByPow52(value, p5, p2);\n-            }\n-        }\n-    }\n-\n-    private static void testLeftInplaceSub(FDBigInteger left, FDBigInteger right, boolean isImmutable) throws Exception {\n-        BigInteger biLeft = left.toBigInteger();\n-        BigInteger biRight = right.toBigInteger();\n-        FDBigInteger diff = left.leftInplaceSub(right);\n-        if (!isImmutable && diff != left) {\n-            throw new Exception(\"leftInplaceSub of doesn't reuse its argument\");\n-        }\n-        if (isImmutable) {\n-            check(biLeft, left, \"leftInplaceSub corrupts its left immutable argument\");\n-        }\n-        check(biRight, right, \"leftInplaceSub corrupts its right argument\");\n-        check(biLeft.subtract(biRight), diff, \"leftInplaceSub returns wrong result\");\n-    }\n-\n-    private static void testLeftInplaceSub() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-\/\/                for (int p5r = 0; p5r <= p5; p5r += 10) {\n-\/\/                    for (int p2r = 0; p2r <= p2; p2r += 10) {\n-                for (int p5r = 0; p5r <= p5; p5r++) {\n-                    for (int p2r = 0; p2r <= p2; p2r++) {\n-                        \/\/ This strange way of creating a value ensures that it is mutable.\n-                        FDBigInteger left = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                        FDBigInteger right = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5r, p2r);\n-                        testLeftInplaceSub(left, right, false);\n-                        left = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                        left.makeImmutable();\n-                        testLeftInplaceSub(left, right, true);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void testRightInplaceSub(FDBigInteger left, FDBigInteger right, boolean isImmutable) throws Exception {\n-        BigInteger biLeft = left.toBigInteger();\n-        BigInteger biRight = right.toBigInteger();\n-        FDBigInteger diff = left.rightInplaceSub(right);\n-        if (!isImmutable && diff != right) {\n-            throw new Exception(\"rightInplaceSub of doesn't reuse its argument\");\n-        }\n-        check(biLeft, left, \"leftInplaceSub corrupts its left argument\");\n-        if (isImmutable) {\n-            check(biRight, right, \"leftInplaceSub corrupts its right immutable argument\");\n-        }\n-        try {\n-            check(biLeft.subtract(biRight), diff, \"rightInplaceSub returns wrong result\");\n-        } catch (Exception e) {\n-            System.out.println(biLeft+\" - \"+biRight+\" = \"+biLeft.subtract(biRight));\n-            throw e;\n-        }\n-    }\n-\n-    private static void testRightInplaceSub() throws Exception {\n-        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n-            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n-\/\/                for (int p5r = 0; p5r <= p5; p5r += 10) {\n-\/\/                    for (int p2r = 0; p2r <= p2; p2r += 10) {\n-                for (int p5r = 0; p5r <= p5; p5r++) {\n-                    for (int p2r = 0; p2r <= p2; p2r++) {\n-                        \/\/ This strange way of creating a value ensures that it is mutable.\n-                        FDBigInteger left = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n-                        FDBigInteger right = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5r, p2r);\n-                        testRightInplaceSub(left, right, false);\n-                        right = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5r, p2r);\n-                        right.makeImmutable();\n-                        testRightInplaceSub(left, right, true);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n@@ -422,12 +38,1 @@\n-        testValueOfPow52();\n-        testValueOfMulPow52();\n-        testLeftShift();\n-        testQuoRemIteration();\n-        testCmp();\n-        testCmpPow52();\n-        testAddAndCmp();\n-        \/\/ Uncomment the following for more comprehensize but slow testing.\n-        \/\/ testLeftInplaceSub();\n-        \/\/ testMultBy10();\n-        \/\/ testMultByPow52();\n-        \/\/ testRightInplaceSub();\n+        FDBigIntegerChecker.main(args);\n@@ -435,0 +40,1 @@\n+\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/TestFDBigInteger.java","additions":8,"deletions":402,"binary":false,"changes":410,"status":"modified"},{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.math;\n+\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+\n+public class FDBigIntegerChecker {\n+\n+    private static final int MAX_P5 = 413;\n+    private static final int MAX_P2 = 65;\n+    private static final long LONG_SIGN_MASK = (1L << 63);\n+    private static final BigInteger FIVE = BigInteger.valueOf(5);\n+    private static final FDBigInteger MUTABLE_ZERO = new FDBigInteger(0);\n+    private static final FDBigInteger IMMUTABLE_ZERO = new FDBigInteger(0).makeImmutable();\n+    private static final FDBigInteger IMMUTABLE_MILLION = genMillion1().makeImmutable();\n+    private static final FDBigInteger IMMUTABLE_TEN18 = genTen18().makeImmutable();\n+\n+    private static BigInteger toBigInteger(FDBigInteger v) {\n+        return new BigInteger(v.toByteArray());\n+    }\n+\n+    private static FDBigInteger mutable(String hex, int offset) {\n+        byte[] chars = new BigInteger(hex, 16).toString().getBytes(StandardCharsets.US_ASCII);\n+        return new FDBigInteger(0, chars, 0, chars.length).multByPow52(0, offset * 32);\n+    }\n+\n+    private static BigInteger biPow52(int p5, int p2) {\n+        return FIVE.pow(p5).shiftLeft(p2);\n+    }\n+\n+    \/\/ data.length == 1, nWords == 1, offset == 0\n+    private static FDBigInteger genMillion1() {\n+        return FDBigInteger.valueOfPow52(6, 0).leftShift(6);\n+    }\n+\n+    \/\/ data.length == 2, nWords == 1, offset == 0\n+    private static FDBigInteger genMillion2() {\n+        return FDBigInteger.valueOfMulPow52(1000000L, 0, 0);\n+    }\n+\n+    \/\/ data.length == 2, nWords == 2, offset == 0\n+    private static FDBigInteger genTen18() {\n+        return FDBigInteger.valueOfPow52(18, 0).leftShift(18);\n+    }\n+\n+    private static void check(BigInteger expected, FDBigInteger actual, String message) throws Exception {\n+        if (!expected.equals(toBigInteger(actual))) {\n+            throw new Exception(message + \" result \" + actual + \" expected \" + expected.toString(16));\n+        }\n+    }\n+\n+    private static void testValueOfPow52(int p5, int p2) throws Exception {\n+        check(biPow52(p5, p2), FDBigInteger.valueOfPow52(p5, p2),\n+                \"valueOfPow52(\" + p5 + \",\" + p2 + \")\");\n+    }\n+\n+    private static void testValueOfPow52() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n+                testValueOfPow52(p5, p2);\n+            }\n+        }\n+    }\n+\n+    private static void testValueOfMulPow52(long value, int p5, int p2) throws Exception {\n+        BigInteger bi = BigInteger.valueOf(value & ~LONG_SIGN_MASK);\n+        if (value < 0) {\n+            bi = bi.setBit(63);\n+        }\n+        check(biPow52(p5, p2).multiply(bi), FDBigInteger.valueOfMulPow52(value, p5, p2),\n+                \"valueOfMulPow52(\" + Long.toHexString(value) + \".\" + p5 + \",\" + p2 + \")\");\n+    }\n+\n+    private static void testValueOfMulPow52(long value, int p5) throws Exception {\n+        testValueOfMulPow52(value, p5, 0);\n+        testValueOfMulPow52(value, p5, 1);\n+        testValueOfMulPow52(value, p5, 30);\n+        testValueOfMulPow52(value, p5, 31);\n+        testValueOfMulPow52(value, p5, 33);\n+        testValueOfMulPow52(value, p5, 63);\n+    }\n+\n+    private static void testValueOfMulPow52() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            testValueOfMulPow52(0xFFFFFFFFL, p5);\n+            testValueOfMulPow52(0x123456789AL, p5);\n+            testValueOfMulPow52(0x7FFFFFFFFFFFFFFFL, p5);\n+            testValueOfMulPow52(0xFFFFFFFFFFF54321L, p5);\n+        }\n+    }\n+\n+    private static void testLeftShift(FDBigInteger t, int shift, boolean isImmutable) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        FDBigInteger r = t.leftShift(shift);\n+        if ((bt.signum() == 0 || shift == 0 || !isImmutable) && r != t) {\n+            throw new Exception(\"leftShift doesn't reuse its argument\");\n+        }\n+        if (isImmutable) {\n+            check(bt, t, \"leftShift corrupts its argument\");\n+        }\n+        check(bt.shiftLeft(shift), r, \"leftShift returns wrong result\");\n+    }\n+\n+    private static void testLeftShift() throws Exception {\n+        testLeftShift(IMMUTABLE_ZERO, 0, true);\n+        testLeftShift(IMMUTABLE_ZERO, 10, true);\n+        testLeftShift(MUTABLE_ZERO, 0, false);\n+        testLeftShift(MUTABLE_ZERO, 10, false);\n+\n+        testLeftShift(IMMUTABLE_MILLION, 0, true);\n+        testLeftShift(IMMUTABLE_MILLION, 1, true);\n+        testLeftShift(IMMUTABLE_MILLION, 12, true);\n+        testLeftShift(IMMUTABLE_MILLION, 13, true);\n+        testLeftShift(IMMUTABLE_MILLION, 32, true);\n+        testLeftShift(IMMUTABLE_MILLION, 33, true);\n+        testLeftShift(IMMUTABLE_MILLION, 44, true);\n+        testLeftShift(IMMUTABLE_MILLION, 45, true);\n+\n+        testLeftShift(genMillion1(), 0, false);\n+        testLeftShift(genMillion1(), 1, false);\n+        testLeftShift(genMillion1(), 12, false);\n+        testLeftShift(genMillion1(), 13, false);\n+        testLeftShift(genMillion1(), 25, false);\n+        testLeftShift(genMillion1(), 26, false);\n+        testLeftShift(genMillion1(), 32, false);\n+        testLeftShift(genMillion1(), 33, false);\n+        testLeftShift(genMillion1(), 44, false);\n+        testLeftShift(genMillion1(), 45, false);\n+\n+        testLeftShift(genMillion2(), 0, false);\n+        testLeftShift(genMillion2(), 1, false);\n+        testLeftShift(genMillion2(), 12, false);\n+        testLeftShift(genMillion2(), 13, false);\n+        testLeftShift(genMillion2(), 25, false);\n+        testLeftShift(genMillion2(), 26, false);\n+        testLeftShift(genMillion2(), 32, false);\n+        testLeftShift(genMillion2(), 33, false);\n+        testLeftShift(genMillion2(), 44, false);\n+        testLeftShift(genMillion2(), 45, false);\n+    }\n+\n+    private static void testQuoRemIteration(FDBigInteger t, FDBigInteger s) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bs = toBigInteger(s);\n+        int q = t.quoRemIteration(s);\n+        BigInteger[] qr = bt.divideAndRemainder(bs);\n+        if (!BigInteger.valueOf(q).equals(qr[0])) {\n+            throw new Exception(\"quoRemIteration returns incorrect quo\");\n+        }\n+        check(qr[1].multiply(BigInteger.TEN), t, \"quoRemIteration returns incorrect rem\");\n+    }\n+\n+    private static void testQuoRemIteration() throws Exception {\n+        \/\/ IMMUTABLE_TEN18 == 0de0b6b3a7640000\n+        \/\/ q = 0\n+        testQuoRemIteration(mutable(\"00000001\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"00000001\", 1), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b2\", 1), IMMUTABLE_TEN18);\n+        \/\/ q = 1 -> q = 0\n+        testQuoRemIteration(mutable(\"0de0b6b3\", 1), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b3a763FFFF\", 0), IMMUTABLE_TEN18);\n+        \/\/ q = 1\n+        testQuoRemIteration(mutable(\"0de0b6b3a7640000\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b3FFFFFFFF\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"8ac72304\", 1), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"0de0b6b400000000\", 0), IMMUTABLE_TEN18);\n+        testQuoRemIteration(mutable(\"8ac72305\", 1), IMMUTABLE_TEN18);\n+        \/\/ q = 18\n+        testQuoRemIteration(mutable(\"FFFFFFFF\", 1), IMMUTABLE_TEN18);\n+    }\n+\n+    private static void testCmp(FDBigInteger t, FDBigInteger o) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bo = toBigInteger(o);\n+        int cmp = t.cmp(o);\n+        int bcmp = bt.compareTo(bo);\n+        if (bcmp != cmp) {\n+            throw new Exception(\"cmp returns \" + cmp + \" expected \" + bcmp);\n+        }\n+        check(bt, t, \"cmp corrupts this\");\n+        check(bo, o, \"cmp corrupts other\");\n+        if (o.cmp(t) != -cmp) {\n+            throw new Exception(\"asymmetrical cmp\");\n+        }\n+        check(bt, t, \"cmp corrupts this\");\n+        check(bo, o, \"cmp corrupts other\");\n+    }\n+\n+    private static void testCmp() throws Exception {\n+        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"100000000\", 0));\n+        testCmp(mutable(\"FFFFFFFF\", 0), mutable(\"1\", 1));\n+        testCmp(mutable(\"5\", 0), mutable(\"6\", 0));\n+        testCmp(mutable(\"5\", 0), mutable(\"5\", 0));\n+        testCmp(mutable(\"5000000001\", 0), mutable(\"500000001\", 0));\n+        testCmp(mutable(\"5000000001\", 0), mutable(\"6\", 1));\n+        testCmp(mutable(\"5000000001\", 0), mutable(\"5\", 1));\n+        testCmp(mutable(\"5000000000\", 0), mutable(\"5\", 1));\n+    }\n+\n+    private static void testCmpPow52(FDBigInteger t, int p5, int p2) throws Exception {\n+        FDBigInteger o = FDBigInteger.valueOfPow52(p5, p2);\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bo = biPow52(p5, p2);\n+        int cmp = t.cmp(o);\n+        int bcmp = bt.compareTo(bo);\n+        if (bcmp != cmp) {\n+            throw new Exception(\"cmp returns \" + cmp + \" expected \" + bcmp);\n+        }\n+        check(bt, t, \"cmp corrupts this\");\n+        check(bo, o, \"cmpPow5 corrupts other\");\n+    }\n+\n+    private static void testCmpPow52() throws Exception {\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 31);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 32);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 33);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 34);\n+        testCmpPow52(mutable(\"00000002\", 1), 0, 64);\n+        testCmpPow52(mutable(\"00000003\", 1), 0, 32);\n+        testCmpPow52(mutable(\"00000003\", 1), 0, 33);\n+        testCmpPow52(mutable(\"00000003\", 1), 0, 34);\n+    }\n+\n+    private static void testAddAndCmp(FDBigInteger t, FDBigInteger x, FDBigInteger y) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        BigInteger bx = toBigInteger(x);\n+        BigInteger by = toBigInteger(y);\n+        int cmp = t.addAndCmp(x, y);\n+        int bcmp = bt.compareTo(bx.add(by));\n+        if (bcmp != cmp) {\n+            throw new Exception(\"addAndCmp returns \" + cmp + \" expected \" + bcmp);\n+        }\n+        check(bt, t, \"addAndCmp corrupts this\");\n+        check(bx, x, \"addAndCmp corrupts x\");\n+        check(by, y, \"addAndCmp corrupts y\");\n+    }\n+\n+    private static void testAddAndCmp() throws Exception {\n+        testAddAndCmp(MUTABLE_ZERO, MUTABLE_ZERO, MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 0), MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000001\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000002\", 0), MUTABLE_ZERO);\n+        testAddAndCmp(mutable(\"00000001\", 0), MUTABLE_ZERO, mutable(\"00000002\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"FFFFFFFF\", 0), mutable(\"FFFFFFFF\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 0), mutable(\"00000001\", 1), mutable(\"00000001\", 0));\n+\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0F80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"0F0F0F0E80000000\", 1), mutable(\"F0F0F0F080000000\", 1));\n+\n+        testAddAndCmp(mutable(\"00000002\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+        testAddAndCmp(mutable(\"00000003\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+        testAddAndCmp(mutable(\"00000004\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+        testAddAndCmp(mutable(\"00000005\", 1), mutable(\"0000000180000000\", 1), mutable(\"0000000280000000\", 1));\n+\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n+        testAddAndCmp(mutable(\"00000001\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000001\", 0));\n+        testAddAndCmp(mutable(\"00000002\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n+        testAddAndCmp(mutable(\"00000003\", 2), mutable(\"8000000000000000\", 0), mutable(\"8000000000000000\", 0));\n+    }\n+\n+    private static void testMultBy10(FDBigInteger t, boolean isImmutable) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        FDBigInteger r = t.multBy10();\n+        if ((bt.signum() == 0 || !isImmutable) && r != t) {\n+            throw new Exception(\"multBy10 of doesn't reuse its argument\");\n+        }\n+        if (isImmutable) {\n+            check(bt, t, \"multBy10 corrupts its argument\");\n+        }\n+        check(bt.multiply(BigInteger.TEN), r, \"multBy10 returns wrong result\");\n+    }\n+\n+    private static void testMultBy10() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n+                \/\/ This strange way of creating a value ensures that it is mutable.\n+                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n+                testMultBy10(value, false);\n+                value.makeImmutable();\n+                testMultBy10(value, true);\n+            }\n+        }\n+    }\n+\n+    private static void testMultByPow52(FDBigInteger t, int p5, int p2) throws Exception {\n+        BigInteger bt = toBigInteger(t);\n+        FDBigInteger r = t.multByPow52(p5, p2);\n+        if (bt.signum() == 0 && r != t) {\n+            throw new Exception(\"multByPow52 of doesn't reuse its argument\");\n+        }\n+        check(bt.multiply(biPow52(p5, p2)), r, \"multByPow52 returns wrong result\");\n+    }\n+\n+    private static void testMultByPow52() throws Exception {\n+        for (int p5 = 0; p5 <= MAX_P5; p5++) {\n+            for (int p2 = 0; p2 <= MAX_P2; p2++) {\n+                \/\/ This strange way of creating a value ensures that it is mutable.\n+                FDBigInteger value = FDBigInteger.valueOfPow52(0, 0).multByPow52(p5, p2);\n+                testMultByPow52(value, p5, p2);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testValueOfPow52();\n+        testValueOfMulPow52();\n+        testLeftShift();\n+        testQuoRemIteration();\n+        testCmp();\n+        testCmpPow52();\n+        testAddAndCmp();\n+        \/\/ Uncomment the following for more comprehensize but slow testing.\n+        \/\/ testMultBy10();\n+        \/\/ testMultByPow52();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/java.base\/jdk\/internal\/math\/FDBigIntegerChecker.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-* @run main\/othervm\/timeout=480 jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n+* @run main\/othervm jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n@@ -54,0 +54,1 @@\n+        \"-XX:-CreateCoredumpOnCrash\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4198081\n+ * @bug 4198081 8357252\n","filename":"test\/jdk\/sun\/awt\/font\/TestArabicHebrew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+     *\n+     * @param frameDir an optional directory to write all frames as PNGs to.\n+     *                 See {@link GifComparison#run(URL, File)}\n@@ -69,1 +72,2 @@\n-    public static void test(FrameDescription... frameDescriptions)\n+    public static void test(FrameDescription[] frameDescriptions,\n+                            File frameDir)\n@@ -73,1 +77,1 @@\n-            GifComparison.run(file.toURI().toURL());\n+            GifComparison.run(file.toURI().toURL(), frameDir);\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifBuilder.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.io.File;\n@@ -62,0 +63,7 @@\n+     * @param frameDir an optional directory to write frames to as PNG images.\n+     *                 The frames should render identically whether we use\n+     *                 the ImageIO model or the ToolkitImage model. If they're\n+     *                 identical, then we only output one image, such as\n+     *                 \"frame_0.png\". If they're different then we'll\n+     *                 output two images: \"frame_0_iio.png\" and\n+     *                 \"frame_0_awt.png\".\n@@ -68,1 +76,2 @@\n-    public static BufferedImage run(URL srcURL) throws Throwable {\n+    public static BufferedImage run(URL srcURL, File frameDir)\n+            throws Throwable {\n@@ -76,3 +85,3 @@\n-        int a = ioModel.frames.size() - 1;\n-        BufferedImage ioImg = ioModel.getFrame(a);\n-        BufferedImage awtImage = awtModel.getFrame(a);\n+        \/\/ if frameDir exists: test & export all frames.\n+        \/\/ Otherwise: only test the last frame\n+        int startIndex = frameDir == null ? ioModel.frames.size() - 1 : 0;\n@@ -80,1 +89,3 @@\n-        lastImage = awtImage;\n+        for (int a = startIndex; a < ioModel.frames.size(); a++) {\n+            BufferedImage ioImg = ioModel.getFrame(a);\n+            BufferedImage awtImage = awtModel.getFrame(a);\n@@ -82,5 +93,1 @@\n-        if (!(ioImg.getWidth() == awtImage.getWidth() &&\n-                ioImg.getHeight() == awtImage.getHeight()))\n-            throw new Error(\"These images are not the same size: \" +\n-                    ioImg.getWidth() + \"x\" + ioImg.getHeight() + \" vs \" +\n-                    awtImage.getWidth() + \"x\" + awtImage.getHeight());\n+            lastImage = awtImage;\n@@ -88,4 +95,7 @@\n-        for (int y = 0; y < ioImg.getHeight(); y++) {\n-            for (int x = 0; x < ioImg.getWidth(); x++) {\n-                int argb1 = ioImg.getRGB(x, y);\n-                int argb2 = awtImage.getRGB(x, y);\n+            try {\n+                if (!(ioImg.getWidth() == awtImage.getWidth() &&\n+                        ioImg.getHeight() == awtImage.getHeight()))\n+                    throw new Error(\"These images are not the same size: \" +\n+                            ioImg.getWidth() + \"x\" + ioImg.getHeight() +\n+                            \" vs \" +\n+                            awtImage.getWidth() + \"x\" + awtImage.getHeight());\n@@ -93,9 +103,33 @@\n-                int alpha1 = (argb1 & 0xff000000) >> 24;\n-                int alpha2 = (argb2 & 0xff000000) >> 24;\n-                if (alpha1 == 0 && alpha2 == 0) {\n-                    continue;\n-                } else if (alpha1 == 0 || alpha2 == 0) {\n-                    throw new Error(\"pixels at (\" + x + \", \" + y +\n-                            \") have different opacities: \" +\n-                            Integer.toUnsignedString(argb1, 16) + \" vs \" +\n-                            Integer.toUnsignedString(argb2, 16));\n+                for (int y = 0; y < ioImg.getHeight(); y++) {\n+                    for (int x = 0; x < ioImg.getWidth(); x++) {\n+                        int argb1 = ioImg.getRGB(x, y);\n+                        int argb2 = awtImage.getRGB(x, y);\n+\n+                        int alpha1 = (argb1 & 0xff000000) >> 24;\n+                        int alpha2 = (argb2 & 0xff000000) >> 24;\n+                        if (alpha1 == 0 && alpha2 == 0) {\n+                            continue;\n+                        } else if (alpha1 == 0 || alpha2 == 0) {\n+                            throw new Error(\"pixels at (\" + x + \", \" + y +\n+                                    \") have different opacities: \" +\n+                                    Integer.toUnsignedString(argb1, 16) +\n+                                    \" vs \" +\n+                                    Integer.toUnsignedString(argb2, 16));\n+                        }\n+                        int rgb1 = argb1 & 0xffffff;\n+                        int rgb2 = argb2 & 0xffffff;\n+                        if (rgb1 != rgb2) {\n+                            throw new Error(\"pixels at (\" + x + \", \" + y +\n+                                    \") have different opaque RGB values: \" +\n+                                    Integer.toUnsignedString(rgb1, 16) +\n+                                    \" vs \" +\n+                                    Integer.toUnsignedString(rgb2, 16));\n+                        }\n+                    }\n+                }\n+\n+                if (frameDir != null) {\n+                    \/\/ the two models are identical, so simply write one image:\n+                    File pngFile = new File(frameDir, \"frame_\" + a + \".png\");\n+                    ImageIO.write(ioImg, \"png\", pngFile);\n+                    System.out.println(\"\\tWrote \" + pngFile);\n@@ -103,7 +137,7 @@\n-                int rgb1 = argb1 & 0xffffff;\n-                int rgb2 = argb2 & 0xffffff;\n-                if (rgb1 != rgb2) {\n-                    throw new Error(\"pixels at (\" + x + \", \" + y +\n-                            \") have different opaque RGB values: \" +\n-                            Integer.toUnsignedString(rgb1, 16) + \" vs \" +\n-                            Integer.toUnsignedString(rgb2, 16));\n+            } catch (Throwable t) {\n+                if (frameDir != null) {\n+                    File f1 = new File(frameDir, \"frame_\" + + a + \"_iio.png\");\n+                    File f2 = new File(frameDir, \"frame_\" + + a + \"_awt.png\");\n+                    ImageIO.write(ioImg, \"png\", f1);\n+                    ImageIO.write(awtImage, \"png\", f2);\n+                    System.out.println(\"\\tWrote \" + f1 + \" vs \" + f2);\n@@ -111,0 +145,1 @@\n+                throw t;\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifComparison.java","additions":65,"deletions":30,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.io.File;\n+\n@@ -33,1 +35,2 @@\n-        GifBuilder.test(\n+        GifBuilder.FrameDescription[] frames =\n+            new GifBuilder.FrameDescription[] {\n@@ -39,1 +42,10 @@\n-                        GifBuilder.Disposal.doNotDispose, false) );\n+                        GifBuilder.Disposal.doNotDispose, false)\n+        };\n+\n+        File dir = null;\n+\n+        \/\/ un-comment to visually inspect the frames:\n+\/\/        dir = new File(\"8356137-frames\");\n+\/\/        dir.mkdir();\n+\n+        GifBuilder.test(frames, dir);\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifEmptyBackgroundTest.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357034\n+ * @summary This test verifies that when the transparent pixel index changes\n+ * and we're rendering on top of another frame we respect the new transparency.\n+ *\/\n+\n+import java.io.File;\n+\n+public class GifSavedImageTransparentTest {\n+    public static void main(String[] args) throws Throwable {\n+        GifBuilder.FrameDescription[] frames =\n+                new GifBuilder.FrameDescription[] {\n+                        new GifBuilder.FrameDescription(\n+                                GifBuilder.Disposal.doNotDispose, false),\n+                        new GifBuilder.FrameDescription(\n+                                GifBuilder.Disposal.doNotDispose, true),\n+                        new GifBuilder.FrameDescription(\n+                                GifBuilder.Disposal.doNotDispose, true)\n+                };\n+\n+        File dir = null;\n+\n+        \/\/ un-comment to visually inspect the frames:\n+\/\/        dir = new File(\"8357034-frames\");\n+\/\/        dir.mkdir();\n+\n+        GifBuilder.test(frames, dir);\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifSavedImageTransparentTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8343232\n+ * @summary Verify correctness of the structure of PKCS12 PBMAC1\n+ *          keystores created with various property values.\n+ *          Verify that keystores load correctly from an input stream.\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.DerUtils;\n+import sun.security.util.KnownOIDs;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+public class PBMAC1Test {\n+\n+    static final char[] PASSWORD = \"1234\".toCharArray();\n+\n+    public static void main(String[] args) throws Exception {\n+        create();\n+        migrate();\n+        overflow();\n+    }\n+\n+    \/\/ PBMAC1 inside PKCS12\n+    \/\/0019:008B  [2]     SEQUENCE\n+    \/\/001C:007B  [20]         SEQUENCE\n+    \/\/001E:0057  [200]             SEQUENCE\n+    \/\/0020:000B  [2000]                 OID 1.2.840.113549.1.5.14 (PBMAC1)\n+    \/\/002B:004A  [2001]                 SEQUENCE\n+    \/\/002D:003A  [20010]                     SEQUENCE\n+    \/\/002F:000B  [200100]                         OID 1.2.840.113549.1.5.12 (PBKDF2)\n+    \/\/003A:002D  [200101]                         SEQUENCE\n+    \/\/003C:0016  [2001010]                             OCTET STRING (20 bytes of salt)\n+    \/\/0052:0004  [2001011]                             INTEGER 10000\n+    \/\/0056:0003  [2001012]                             INTEGER 32\n+    \/\/0059:000E  [2001013]                             SEQUENCE\n+    \/\/005B:000A  [20010130]                                 OID 1.2.840.113549.2.9 (HmacSHA256)\n+    \/\/0065:0002  [20010131]                                 NULL\n+    \/\/0067:000E  [20011]                     SEQUENCE\n+    \/\/0069:000A  [200110]                         OID 1.2.840.113549.2.9 (HmacSHA256)\n+    \/\/0073:0002  [200111]                         NULL\n+    \/\/0075:0022  [201]             OCTET STRING (32 bytes of mac)\n+    \/\/0097:000A  [21]         OCTET STRING (8 bytes of useless salt)\n+    \/\/00A1:0003  [22]         INTEGER 1\n+    static void create() throws Exception {\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"pbewithhmacsha256\");\n+        var der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 32);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWITHHMACSHA512\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA512);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 64);\n+\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWiThHmAcSHA512\/224\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 28);\n+\n+        \/\/ As strange as I can...\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\",\n+                \"PBEWithHmacSHA512\/224AndHmacSHA3-384\");\n+        der = emptyP12();\n+        DerUtils.checkAlg(der, \"2000\", KnownOIDs.PBMAC1);\n+        DerUtils.checkAlg(der, \"200100\", KnownOIDs.PBKDF2);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA512$224);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA3_384);\n+        DerUtils.checkInt(der, \"2001011\", 10000);\n+        DerUtils.checkInt(der, \"2001012\", 48);\n+\n+        \/\/ Bad alg names\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"PBEWithHmacSHA456\");\n+        var reason = Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> emptyP12()).getMessage();\n+        Asserts.assertTrue(reason.contains(\"Algorithm hmacsha456 not available\"), reason);\n+    }\n+\n+    static void migrate() throws Exception {\n+        \/\/ A pkcs12 file using PBEWithHmacSHA256 but key length is 8\n+        var sha2p12 = \"\"\"\n+                MIGhAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiDB5MFUGCSqGSIb3DQEFDjBIMDgGCSqGSIb3DQEF\n+                DDArBBSV6e5xI+9AYtGHQlDI0X4pmvWLBQICJxACAQgwDAYIKoZIhvcNAgkFADAMBggqhkiG9w0C\n+                CQUABCAaaSO6JgEh1lDo1pvAC0CF5HqgIFBvzt1+GZlgFy7xFQQITk9UIFVTRUQCAQE=\n+                \"\"\";\n+        var der = Base64.getMimeDecoder().decode(sha2p12);\n+        DerUtils.checkInt(der, \"2001012\", 8); \/\/ key length used to be 8\n+\n+        der = loadAndStore(sha2p12);\n+        DerUtils.checkAlg(der, \"20010130\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkAlg(der, \"200110\", KnownOIDs.HmacSHA256);\n+        DerUtils.checkInt(der, \"2001012\", 32); \/\/ key length changed to 32\n+    }\n+\n+    static void overflow() throws Exception {\n+\n+        \/\/ Cannot create new\n+        System.setProperty(\"keystore.pkcs12.macIterationCount\", \"5000001\");\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", \"pbewithhmacsha256\");\n+        Asserts.assertThrows(IllegalArgumentException.class, PBMAC1Test::emptyP12);\n+        System.clearProperty(\"keystore.pkcs12.macAlgorithm\");\n+        Asserts.assertThrows(IllegalArgumentException.class, PBMAC1Test::emptyP12);\n+\n+        \/\/ IC=5000001 using old algorithm\n+        var bigICt = \"\"\"\n+                MGYCAQMwEQYJKoZIhvcNAQcBoAQEAjAAME4wMTANBglghkgBZQMEAgEFAAQgyLBK5h9\/E\/2o7l2A\n+                eALbI1otiS8kT3C41Ef3T38OMjUEFIic7isrAJNr+3+8fUbnMtmB0qytAgNMS0E=\n+                \"\"\";\n+\n+        \/\/ IC=5000000 using old algorithm\n+        var smallICt = \"\"\"\n+                MGYCAQMwEQYJKoZIhvcNAQcBoAQEAjAAME4wMTANBglghkgBZQMEAgEFAAQgR61YZLW6H81rkGTk\n+                XfuU138mkIugdoQBhuNsnvWuBtQEFJ0wmMlpoUiji8PlvwCrmMbqWW4XAgNMS0A=\n+                \"\"\";\n+\n+        \/\/ IC=5000001 using PBMAC1\n+        var bigICp = \"\"\"\n+                MIGiAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiTB6MFYGCSqGSIb3DQEFDjBJMDkGCSqGSIb3DQEF\n+                DDAsBBQFNf\/gHCO5jNT429D6Q5gxTKHqVAIDTEtBAgEgMAwGCCqGSIb3DQIJBQAwDAYIKoZIhvcN\n+                AgkFAAQgwEVMcyMPQXJSXUIbWqNWjMArtnXDlNUGnKD+19B7QFkECE5PVCBVU0VEAgEB\n+                \"\"\";\n+\n+        \/\/ IC=5000000 using PBMAC1\n+        var smallICp = \"\"\"\n+                MIGiAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBiTB6MFYGCSqGSIb3DQEFDjBJMDkGCSqGSIb3DQEF\n+                DDAsBBS\/ZFfC7swsDHvaCXwyQkuMrZ7dbgIDTEtAAgEgMAwGCCqGSIb3DQIJBQAwDAYIKoZIhvcN\n+                AgkFAAQgCRvE7LDbzkcYOVv\/7iBv0KB3DoUkwnpTI0nsonVfv9UECE5PVCBVU0VEAgEB\"\"\";\n+\n+        loadAndStore(smallICp);\n+        loadAndStore(smallICt);\n+\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(bigICp))\n+                .getMessage().contains(\"MAC iteration count too large: 5000001\"));\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(bigICt))\n+                .getMessage().contains(\"MAC iteration count too large: 5000001\"));\n+\n+        \/\/ Incorrect Salt\n+        var incorrectSalt = \"\"\"\n+                MIGdAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBhDB1MFEGCSqGSIb3DQEFDjBEMDYGCSqGSIb3DQEF\n+                DDApBBSakVhBLltKvqUj6EAxvWqJi+gc7AICJxACASAwCgYIKoZIhvcNAgkwCgYIKoZIhvcNAgkE\n+                IG+euEHE8iN\/2C7txbCjCJ9mU4TgEsHPsC9L3Rxa7malBAhOT1QgVVNFRAIBAQ==\"\"\";\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(incorrectSalt))\n+                .getMessage().contains(\"Integrity check failed\"));\n+\n+        \/\/ Incorrect Iteration Count\n+        var incorrectIC = \"\"\"\n+                MIGdAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBhDB1MFEGCSqGSIb3DQEFDjBEMDYGCSqGSIb3DQEF\n+                DDApBBSZkVhBLltKvqUj6EAxvWqJi+gc7AICKBACASAwCgYIKoZIhvcNAgkwCgYIKoZIhvcNAgkE\n+                IG+euEHE8iN\/2C7txbCjCJ9mU4TgEsHPsC9L3Rxa7malBAhOT1QgVVNFRAIBAQ==\"\"\";\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(incorrectIC))\n+                .getMessage().contains(\"Integrity check failed\"));\n+\n+        \/\/ Missing Key Length\n+        var missingKeyLength = \"\"\"\n+                MIGaAgEDMBEGCSqGSIb3DQEHAaAEBAIwADCBgTByME4GCSqGSIb3DQEFDjBBMDMGCSqGSIb3DQEF\n+                DDAmBBSZkVhBLltKvqUj6EAxvWqJi+gc7AICJxAwCgYIKoZIhvcNAgkwCgYIKoZIhvcNAgkEIG+e\n+                uEHE8iN\/2C7txbCjCJ9mU4TgEsHPsC9L3Rxa7malBAhOT1QgVVNFRAIBAQ==\"\"\";\n+        Asserts.assertTrue(Asserts.assertThrows(IOException.class, () -> loadAndStore(missingKeyLength))\n+                .getMessage().contains(\"missing keyLength field\"));\n+    }\n+\n+    static byte[] emptyP12() throws Exception {\n+        var ks = KeyStore.getInstance(\"pkcs12\");\n+        ks.load(null, null);\n+        var os = new ByteArrayOutputStream();\n+        ks.store(os, PASSWORD);\n+        return os.toByteArray();\n+    }\n+\n+    static byte[] loadAndStore(String data) throws Exception {\n+        var bytes = Base64.getMimeDecoder().decode(data);\n+        var ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(new ByteArrayInputStream(bytes), PASSWORD);\n+        var baos = new ByteArrayOutputStream();\n+        ks.store(baos, PASSWORD);\n+        var newBytes = baos.toByteArray();\n+        var bais = new ByteArrayInputStream(newBytes);\n+        ks.load(bais, PASSWORD);\n+        return newBytes;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs12\/PBMAC1Test.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @bug 8076190 8242151 8153005 8266293\n+ * @bug 8076190 8242151 8153005 8266293 8343232\n@@ -247,1 +247,1 @@\n-                checkAlg(data, \"110c11011100\", PBKDF2WithHmacSHA1);\n+                checkAlg(data, \"110c11011100\", PBKDF2);\n@@ -260,1 +260,1 @@\n-            checkAlg(data, \"110c010c0100100\", PBKDF2WithHmacSHA1);\n+            checkAlg(data, \"110c010c0100100\", PBKDF2);\n","filename":"test\/jdk\/sun\/security\/pkcs12\/ParamsPreferences.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @enablePreview\n@@ -51,2 +52,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -59,0 +60,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -324,2 +327,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n@@ -328,4 +330,3 @@\n-        ByteArrayInputStream is =\n-            new ByteArrayInputStream(trustAnchor_SHA1withRSA_1024.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n-        TrustAnchor anchor = new TrustAnchor((X509Certificate)cert, null);\n+        \/\/ generate certificate from certificate string\n+        X509Certificate cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_1024, X509Certificate.class);\n+        TrustAnchor anchor = new TrustAnchor(cert, null);\n@@ -334,3 +335,2 @@\n-        is = new ByteArrayInputStream(trustAnchor_SHA1withRSA_512.getBytes());\n-        cert = cf.generateCertificate(is);\n-        anchor = new TrustAnchor((X509Certificate)cert, null);\n+        cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_512, X509Certificate.class);\n+        anchor = new TrustAnchor(cert, null);\n@@ -343,4 +343,1 @@\n-        Collection entries = new HashSet();\n-\n-        \/\/ generate certificate from certificate string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -350,3 +347,1 @@\n-            ByteArrayInputStream is =\n-                        new ByteArrayInputStream(certStr.getBytes());\n-            Certificate cert = cf.generateCertificate(is);\n+            DEREncodable cert = PEM_DECODER.decode(certStr, X509Certificate.class);\n@@ -370,3 +365,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = new ByteArrayInputStream(certStr.getBytes());\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(certStr, X509Certificate.class);\n@@ -389,3 +382,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = new ByteArrayInputStream(certStr.getBytes());\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(certStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPBuilder.java","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @enablePreview\n@@ -56,2 +57,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -59,1 +60,0 @@\n-import java.security.Security;\n@@ -64,0 +64,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -329,2 +331,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n@@ -333,3 +334,2 @@\n-        ByteArrayInputStream is =\n-            new ByteArrayInputStream(trustAnchor_SHA1withRSA_1024.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n+        \/\/ generate certificate from certificate string\n+        X509Certificate cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_1024, X509Certificate.class);\n@@ -339,3 +339,2 @@\n-        is = new ByteArrayInputStream(trustAnchor_SHA1withRSA_512.getBytes());\n-        cert = cf.generateCertificate(is);\n-        anchor = new TrustAnchor((X509Certificate)cert, null);\n+        cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_512, X509Certificate.class);\n+        anchor = new TrustAnchor(cert, null);\n@@ -348,1 +347,1 @@\n-        Collection entries = new HashSet();\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -355,3 +354,1 @@\n-            ByteArrayInputStream is =\n-                        new ByteArrayInputStream(certStr.getBytes());\n-            Certificate cert = cf.generateCertificate(is);\n+            DEREncodable cert = PEM_DECODER.decode(certStr, X509Certificate.class);\n@@ -375,3 +372,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = new ByteArrayInputStream(certStr.getBytes());\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(certStr, X509Certificate.class);\n@@ -394,3 +389,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = new ByteArrayInputStream(certStr.getBytes());\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = PEM_DECODER.decode(certStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPBuilderWithMD5.java","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @enablePreview\n@@ -40,0 +41,1 @@\n+import java.security.PEMDecoder;\n@@ -47,0 +49,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -281,9 +285,2 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(castr.getBytes());\n-        Certificate cacert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(eestr.getBytes());\n-        Certificate eecert = cf.generateCertificate(is);\n+        Certificate cacert = PEM_DECODER.decode(castr, X509Certificate.class);\n+        Certificate eecert = PEM_DECODER.decode(eestr, X509Certificate.class);\n@@ -295,0 +292,1 @@\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -300,2 +298,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+\n@@ -304,4 +301,2 @@\n-        ByteArrayInputStream is =\n-            new ByteArrayInputStream(trustAnchor_SHA1withRSA_1024.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n-        TrustAnchor anchor = new TrustAnchor((X509Certificate)cert, null);\n+        X509Certificate cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_1024, X509Certificate.class);\n+        TrustAnchor anchor = new TrustAnchor(cert, null);\n@@ -310,3 +305,2 @@\n-        is = new ByteArrayInputStream(trustAnchor_SHA1withRSA_512.getBytes());\n-        cert = cf.generateCertificate(is);\n-        anchor = new TrustAnchor((X509Certificate)cert, null);\n+        cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_512, X509Certificate.class);\n+        anchor = new TrustAnchor(cert, null);\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPValidatorEndEntity.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @enablePreview\n@@ -38,2 +39,1 @@\n-import java.io.*;\n-import java.net.SocketException;\n+import java.security.PEMDecoder;\n@@ -47,0 +47,2 @@\n+    private static final PEMDecoder PEM_DECODER = PEMDecoder.of();\n+\n@@ -186,4 +188,1 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(certStr.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n+        Certificate cert = PEM_DECODER.decode(certStr, X509Certificate.class);\n@@ -199,3 +198,0 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        HashSet<TrustAnchor> anchors = new HashSet<TrustAnchor>();\n@@ -203,4 +199,4 @@\n-        ByteArrayInputStream is =\n-            new ByteArrayInputStream(trustAnchor_SHA1withRSA_1024.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n-        TrustAnchor anchor = new TrustAnchor((X509Certificate)cert, null);\n+        HashSet<TrustAnchor> anchors = new HashSet<TrustAnchor>();\n+        \/\/ generate certificate from cert string\n+        X509Certificate cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_1024, X509Certificate.class);\n+        TrustAnchor anchor = new TrustAnchor(cert, null);\n@@ -209,3 +205,2 @@\n-        is = new ByteArrayInputStream(trustAnchor_SHA1withRSA_512.getBytes());\n-        cert = cf.generateCertificate(is);\n-        anchor = new TrustAnchor((X509Certificate)cert, null);\n+        cert = PEM_DECODER.decode(trustAnchor_SHA1withRSA_512, X509Certificate.class);\n+        anchor = new TrustAnchor(cert, null);\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPValidatorIntermediate.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8350582 8340312\n+ * @bug 8350582 8340312 8369995\n@@ -53,1 +53,2 @@\n-    private static final HashMap<String, List<String>> debugMessages = new HashMap<>();\n+    private static final HashMap<String, List<String>> debugMessages =\n+            new HashMap<>();\n@@ -57,2 +58,0 @@\n-\n-\n@@ -62,1 +61,1 @@\n-        debugMessages.put(\"keymanager\", List.of(\"choosing key:\"));\n+        debugMessages.put(\"keymanager\", List.of(\"Choosing key:\"));\n@@ -64,1 +63,2 @@\n-        debugMessages.put(\"plaintext\", List.of(\"Plaintext before ENCRYPTION\"));\n+        debugMessages.put(\"plaintext\",\n+                List.of(\"Plaintext before ENCRYPTION\"));\n@@ -67,1 +67,2 @@\n-        debugMessages.put(\"sslctx\", List.of(\"trigger seeding of SecureRandom\"));\n+        debugMessages.put(\"sslctx\",\n+                List.of(\"trigger seeding of SecureRandom\"));\n@@ -69,2 +70,4 @@\n-        debugMessages.put(\"trustmanager\", List.of(\"adding as trusted certificates\"));\n-        debugMessages.put(\"verbose\", List.of(\"Ignore unsupported cipher suite:\"));\n+        debugMessages.put(\"trustmanager\",\n+                List.of(\"adding as trusted certificates\"));\n+        debugMessages.put(\"verbose\",\n+                List.of(\"Ignore unsupported cipher suite:\"));\n@@ -117,4 +120,6 @@\n-                Arguments.of(List.of(\"-Djavax.net.debug=ssl,handshake,expand\"),\n-                        List.of(\"handshake\", \"handshake-expand\", \"keymanager\",\n-                                \"record\", \"session\", \"record-expand\", \"ssl\",\n-                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                Arguments.of(\n+                        List.of(\"-Djavax.net.debug=ssl,handshake,expand\"),\n+                        List.of(\"handshake\", \"handshake-expand\",\n+                                \"keymanager\", \"record\", \"session\",\n+                                \"record-expand\", \"ssl\", \"sslctx\",\n+                                \"trustmanager\", \"verbose\")),\n@@ -123,3 +128,4 @@\n-                        List.of(\"handshake\", \"handshake-expand\", \"keymanager\",\n-                                \"record\", \"record-expand\", \"session\", \"ssl\",\n-                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                        List.of(\"handshake\", \"handshake-expand\",\n+                                \"keymanager\", \"record\", \"record-expand\",\n+                                \"session\", \"ssl\", \"sslctx\", \"trustmanager\",\n+                                \"verbose\")),\n@@ -150,1 +156,2 @@\n-                Arguments.of(List.of(\"-Djavax.net.debug=ssl:record:plaintext\"),\n+                Arguments.of(\n+                        List.of(\"-Djavax.net.debug=ssl:record:plaintext\"),\n@@ -155,2 +162,3 @@\n-                        List.of(\"handshake\", \"keymanager\", \"record\", \"session\",\n-                                \"ssl\", \"sslctx\", \"trustmanager\", \"verbose\")),\n+                        List.of(\"handshake\", \"keymanager\", \"record\",\n+                                \"session\", \"ssl\", \"sslctx\", \"trustmanager\",\n+                                \"verbose\")),\n@@ -158,2 +166,3 @@\n-                        List.of(\"handshake\", \"keymanager\", \"record\", \"session\",\n-                                \"ssl\", \"sslctx\", \"trustmanager\", \"verbose\")),\n+                        List.of(\"handshake\", \"keymanager\", \"record\",\n+                                \"session\", \"ssl\", \"sslctx\", \"trustmanager\",\n+                                \"verbose\")),\n@@ -166,3 +175,3 @@\n-                        List.of(\"handshake\", \"java.security.debug\", \"keymanager\",\n-                                \"record\", \"session\", \"ssl\", \"sslctx\",\n-                                \"trustmanager\", \"verbose\")),\n+                        List.of(\"handshake\", \"java.security.debug\",\n+                                \"keymanager\", \"record\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n@@ -173,1 +182,1 @@\n-                                \"keymanager\", \"packet\",  \"plaintext\",\n+                                \"keymanager\", \"packet\", \"plaintext\",\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLLogger\/DebugPropertyValuesTest.java","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366364\n+ * @summary Return enabled signature schemes with\n+ *          SSLConfiguration#getSSLParameters() call\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @comment *_sha224 signatures schemes are not available on Windows\n+ * @requires os.family != \"windows\"\n+ *\n+ * @run main\/othervm DefaultSSLConfigSignatureSchemes\n+ * @run main\/othervm\n+ *          -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384,ed25519\n+ *          -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ed448\n+ *          DefaultSSLConfigSignatureSchemes\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import javax.net.ssl.SSLEngine;\n+import jdk.test.lib.security.SecurityUtils;\n+\n+public class DefaultSSLConfigSignatureSchemes extends SSLEngineTemplate {\n+\n+    protected static final String DISABLED_SS = \"ecdsa_secp521r1_sha512\";\n+    protected static final String[] CUSTOM_SS = new String[]{\n+            \"ecdsa_secp256r1_sha256\",\n+            \"ecdsa_secp384r1_sha384\"};\n+    protected static final List<String> REFERENCE_SS = Stream.of(\n+                    \"ecdsa_secp256r1_sha256\",\n+                    \"ecdsa_secp384r1_sha384\",\n+                    \"ecdsa_secp521r1_sha512\",\n+                    \"ed25519\",\n+                    \"ed448\",\n+                    \"rsa_pss_rsae_sha256\",\n+                    \"rsa_pss_rsae_sha384\",\n+                    \"rsa_pss_rsae_sha512\",\n+                    \"rsa_pss_pss_sha256\",\n+                    \"rsa_pss_pss_sha384\",\n+                    \"rsa_pss_pss_sha512\",\n+                    \"rsa_pkcs1_sha256\",\n+                    \"rsa_pkcs1_sha384\",\n+                    \"rsa_pkcs1_sha512\",\n+                    \"dsa_sha256\",\n+                    \"ecdsa_sha224\",\n+                    \"rsa_sha224\",\n+                    \"dsa_sha224\",\n+                    \"ecdsa_sha1\",\n+                    \"rsa_pkcs1_sha1\",\n+                    \"dsa_sha1\")\n+            .sorted()\n+            .toList();\n+\n+    protected DefaultSSLConfigSignatureSchemes() throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        SecurityUtils.addToDisabledTlsAlgs(DISABLED_SS);\n+        var test = new DefaultSSLConfigSignatureSchemes();\n+        var propertyClientSS =\n+                System.getProperty(\"jdk.tls.client.SignatureSchemes\");\n+        var propertyServerSS =\n+                System.getProperty(\"jdk.tls.server.SignatureSchemes\");\n+\n+        \/\/ Test jdk.tls.client.SignatureSchemes system property.\n+        if (propertyClientSS != null) {\n+            comparePropertySSWithEngineSS(propertyClientSS, test.clientEngine);\n+        }\n+\n+        \/\/ Test jdk.tls.server.SignatureSchemes system property.\n+        if (propertyServerSS != null) {\n+            comparePropertySSWithEngineSS(propertyServerSS, test.serverEngine);\n+        }\n+\n+        \/\/ Test default signature schemes and custom values if no system\n+        \/\/ properties are present.\n+        if (propertyClientSS == null && propertyServerSS == null) {\n+            for (SSLEngine engine :\n+                    new SSLEngine[]{test.serverEngine, test.clientEngine}) {\n+\n+                \/\/ Test default config signature schemes.\n+                checkEngineDefaultSS(engine);\n+\n+                \/\/ Test custom values.\n+                var sslParams = engine.getSSLParameters();\n+                sslParams.setSignatureSchemes(CUSTOM_SS);\n+                engine.setSSLParameters(sslParams);\n+                assertTrue(Arrays.equals(CUSTOM_SS,\n+                        engine.getSSLParameters().getSignatureSchemes()));\n+\n+                \/\/ Set null custom value, default signature schemes should\n+                \/\/ be returned.\n+                sslParams.setSignatureSchemes(null);\n+                engine.setSSLParameters(sslParams);\n+                checkEngineDefaultSS(engine);\n+            }\n+        }\n+    }\n+\n+    private static void comparePropertySSWithEngineSS(\n+            String property, SSLEngine engine) {\n+        var engineSS = Stream.of(engine\n+                .getSSLParameters().getSignatureSchemes()).sorted().toList();\n+        var propertySS = Stream.of(property.split(\",\")).sorted().toList();\n+        assertTrue(engineSS.equals(propertySS), \"Engine signature scheme: \"\n+                + engineSS + \"; Property signature scheme: \" + propertySS);\n+    }\n+\n+    private static void checkEngineDefaultSS(SSLEngine engine) {\n+        var defaultConfigSS = new ArrayList<>(List.of(\n+                engine.getSSLParameters().getSignatureSchemes()));\n+\n+        assertFalse(defaultConfigSS.contains(DISABLED_SS));\n+        defaultConfigSS.add(DISABLED_SS);\n+        assertTrue(REFERENCE_SS.equals(\n+                        defaultConfigSS.stream().sorted().toList()),\n+                \"Signature schemes returned by engine: \" + defaultConfigSS);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DefaultSSLConfigSignatureSchemes.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -41,0 +42,1 @@\n+import java.security.PEMDecoder;\n@@ -47,0 +49,1 @@\n+import java.security.cert.X509Certificate;\n@@ -907,1 +910,1 @@\n-    static char passphrase[] = \"passphrase\".toCharArray();\n+    static char[] passphrase = \"passphrase\".toCharArray();\n@@ -1002,0 +1005,1 @@\n+        PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -1003,6 +1007,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+        Certificate trusedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n@@ -1027,3 +1026,1 @@\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n+            Certificate keyCert = pemDecoder.decode(keyCertStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/PKIXExtendedTM.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -37,0 +38,2 @@\n+import java.security.PEMDecoder;\n+import java.security.cert.X509Certificate;\n@@ -1000,2 +1003,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -1003,4 +1005,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+        \/\/ generate certificate from cert string\n+        Certificate trusedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n@@ -1025,3 +1025,1 @@\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n+            Certificate keyCert = pemDecoder.decode(keyCertStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/SunX509ExtendedTM.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+# Assign \"jpackagePlatformPackage\" key on jpackage tests that output and\n+# optionally install native packages. Don't use the key with tests that output\n+# native packages but will never install them.\n","filename":"test\/jdk\/tools\/jpackage\/TEST.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -354,1 +354,2 @@\n-                    public void verifyIsOfType(PackageType ... types) {\n+                    public JPackageCommand verifyIsOfType(Set<PackageType> types) {\n+                        return this;\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,0 +104,5 @@\n+    public AdditionalLauncher removeProperty(String name) {\n+        rawProperties.remove(Objects.requireNonNull(name));\n+        return this;\n+    }\n+\n@@ -163,1 +168,1 @@\n-        cmd.addVerifyAction(createVerifierAsConsumer());\n+        cmd.addVerifyAction(createVerifierAsConsumer(), JPackageCommand.ActionRole.LAUNCHER_VERIFIER);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.IOException;\n@@ -37,0 +36,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -119,1 +119,1 @@\n-    public static CfgFile load(Path path) throws IOException {\n+    public static CfgFile load(Path path) {\n@@ -129,1 +129,1 @@\n-        for (String line : Files.readAllLines(path)) {\n+        for (String line : ThrowingFunction.<Path, List<String>>toFunction(Files::readAllLines).apply(path)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CfgFile.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.UncheckedIOException;\n@@ -196,3 +195,1 @@\n-        if (cmd.isRuntime()) {\n-            throw new UnsupportedOperationException();\n-        }\n+        cmd.verifyNotRuntime();\n@@ -217,16 +214,3 @@\n-        boolean[] withServices = new boolean[1];\n-        withServices[0] = cmd.hasArgument(\"--launcher-as-service\");\n-        if (!withServices[0]) {\n-            AdditionalLauncher.forEachAdditionalLauncher(cmd, (launcherName, propertyFilePath) -> {\n-                try {\n-                    final var launcherAsService = new AdditionalLauncher.PropertyFile(propertyFilePath)\n-                            .findBooleanProperty(\"launcher-as-service\").orElse(false);\n-                    if (launcherAsService) {\n-                        withServices[0] = true;\n-                    }\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n-                }\n-            });\n-        }\n-        return withServices[0];\n+        return cmd.launcherNames(true).stream().anyMatch(launcherName -> {\n+            return LauncherAsServiceVerifier.launcherAsService(cmd, launcherName);\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import static java.util.stream.Collectors.toCollection;\n@@ -35,0 +36,1 @@\n+import java.io.UncheckedIOException;\n@@ -38,0 +40,1 @@\n+import java.nio.file.LinkOption;\n@@ -42,0 +45,1 @@\n+import java.util.Collections;\n@@ -50,0 +54,1 @@\n+import java.util.TreeSet;\n@@ -58,0 +63,1 @@\n+import java.util.stream.StreamSupport;\n@@ -87,1 +93,0 @@\n-        dmgInstallDir = cmd.dmgInstallDir;\n@@ -167,5 +172,0 @@\n-    public String getArgumentValue(String argName,\n-            Function<JPackageCommand, String> defaultValueSupplier) {\n-        return getArgumentValue(argName, defaultValueSupplier, v -> v);\n-    }\n-\n@@ -334,0 +334,5 @@\n+    public JPackageCommand usePredefinedAppImage(Path predefinedAppImagePath) {\n+        return setArgumentValue(\"--app-image\", Objects.requireNonNull(predefinedAppImagePath))\n+                .removeArgumentWithValue(\"--input\");\n+    }\n+\n@@ -340,1 +345,11 @@\n-        verifyActions.add(action);\n+        return addVerifyAction(action, ActionRole.DEFAULT);\n+    }\n+\n+    enum ActionRole {\n+        DEFAULT,\n+        LAUNCHER_VERIFIER,\n+        ;\n+    }\n+\n+    JPackageCommand addVerifyAction(ThrowingConsumer<JPackageCommand> action, ActionRole actionRole) {\n+        verifyActions.add(action, actionRole);\n@@ -344,0 +359,4 @@\n+    Stream<ThrowingConsumer<JPackageCommand>> getVerifyActionsWithRole(ActionRole actionRole) {\n+        return verifyActions.actionsWithRole(actionRole);\n+    }\n+\n@@ -378,1 +397,1 @@\n-    public static Path createInputRuntimeImage() throws IOException {\n+    public static Path createInputRuntimeImage() {\n@@ -408,1 +427,1 @@\n-        return addArguments(\"--name\", TKit.getCurrentDefaultAppName());\n+        return setArgumentValue(\"--name\", TKit.getCurrentDefaultAppName());\n@@ -552,5 +571,1 @@\n-            if (packageType() == PackageType.MAC_DMG && dmgInstallDir != null) {\n-                return dmgInstallDir;\n-            } else {\n-                return MacHelper.getInstallationDirectory(this);\n-            }\n+            return MacHelper.getInstallationDirectory(this);\n@@ -576,0 +591,18 @@\n+    \/**\n+     * Returns the name of the main launcher. It will read the name of the main\n+     * launcher from the external app image if such is specified.\n+     *\n+     * @return the name of the main launcher\n+     *\n+     * @throws IllegalArgumentException if the command is configured for packaging\n+     *                                  Java runtime\n+     *\/\n+    public String mainLauncherName() {\n+        verifyNotRuntime();\n+        return name();\n+    }\n+\n+    boolean isMainLauncher(String launcherName) {\n+        return launcherName == null || mainLauncherName().equals(launcherName);\n+    }\n+\n@@ -592,1 +625,1 @@\n-            launcherName = name();\n+            launcherName = mainLauncherName();\n@@ -610,2 +643,10 @@\n-     * Returns names of all additional launchers or empty list if none\n-     * configured.\n+     * Returns names of additional launchers or an empty list if none configured.\n+     * <p>\n+     * If {@code lookupInPrederfinedAppImage} is {@code true} and the command is\n+     * configured with an external app image, it will read names of the additional\n+     * launchers from the external app image.\n+     *\n+     * @param lookupInPrederfinedAppImage if to read names of additional launchers\n+     *                                    from an external app image\n+     *\n+     * @return the names of additional launchers\n@@ -613,1 +654,5 @@\n-    public List<String> addLauncherNames() {\n+    public List<String> addLauncherNames(boolean lookupInPrederfinedAppImage) {\n+        if (isRuntime()) {\n+            return List.of();\n+        }\n+\n@@ -615,0 +660,8 @@\n+        if (lookupInPrederfinedAppImage) {\n+            Optional.ofNullable(getArgumentValue(\"--app-image\"))\n+                    .map(Path::of)\n+                    .map(AppImageFile::load)\n+                    .map(AppImageFile::addLaunchers)\n+                    .map(Map::keySet)\n+                    .ifPresent(names::addAll);\n+        }\n@@ -618,1 +671,1 @@\n-        return names;\n+        return Collections.unmodifiableList(names);\n@@ -621,1 +674,9 @@\n-    private void verifyNotRuntime() {\n+    \/**\n+     * Returns names of all launchers.\n+     * <p>\n+     * If the list is not empty, the first element is {@code null} referencing the\n+     * main launcher. In the case of runtime packaging, the list is empty.\n+     *\n+     * @return the names of all launchers\n+     *\/\n+    public List<String> launcherNames(boolean lookupInPrederfinedAppImage) {\n@@ -623,1 +684,1 @@\n-            throw new IllegalArgumentException(\"Java runtime packaging\");\n+            return List.of();\n@@ -625,0 +686,12 @@\n+\n+        List<String> names = new ArrayList<>();\n+        names.add(null);\n+        names.addAll(addLauncherNames(lookupInPrederfinedAppImage));\n+        return Collections.unmodifiableList(names);\n+    }\n+\n+    JPackageCommand verifyNotRuntime() {\n+        if (isRuntime()) {\n+            throw new UnsupportedOperationException(\"Java runtime packaging\");\n+        }\n+        return this;\n@@ -642,1 +715,1 @@\n-            launcherName = name();\n+            launcherName = mainLauncherName();\n@@ -1157,0 +1230,46 @@\n+        PREDEFINED_APP_IMAGE_COPY(cmd -> {\n+            Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).filter(_ -> {\n+                return !TKit.isOSX() || !MacHelper.signPredefinedAppImage(cmd);\n+            }).map(Path::of).ifPresent(predefinedAppImage -> {\n+\n+                TKit.trace(String.format(\n+                        \"Check contents of the predefined app image [%s] copied verbatim\",\n+                        predefinedAppImage));\n+\n+                var outputAppImageDir = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n+\n+                try (var walk = Files.walk(predefinedAppImage)) {\n+                    var filteredWalk = walk;\n+                    if (!cmd.expectAppImageFile()) {\n+                        var appImageFile = AppImageFile.getPathInAppImage(predefinedAppImage);\n+                        \/\/ Exclude \".jpackage.xml\" as it should no be in the output bundle.\n+                        var pred = Predicate.<Path>isEqual(appImageFile).negate();\n+                        if (TKit.isOSX()) {\n+                            \/\/ On MacOS exclude files that can be signed as their digests change.\n+                            pred = pred.and(path -> {\n+                                return MacHelper.isVerbatimCopyFromPredefinedAppImage(cmd, path);\n+                            });\n+                        }\n+\n+                        filteredWalk = walk.filter(pred);\n+                    }\n+\n+                    var verbatimPaths = filteredWalk.collect(toCollection(TreeSet::new));\n+\n+                    \/\/ Remove nonempty directories from the collection of paths copied verbatim.\n+                    verbatimPaths.removeAll(verbatimPaths.stream().map(Path::getParent).toList());\n+\n+                    verbatimPaths.forEach(ThrowingConsumer.toConsumer(p -> {\n+                        if (Files.isDirectory(p, LinkOption.NOFOLLOW_LINKS)) {\n+                            TKit.assertDirectoryExists(p);\n+                        } else {\n+                            TKit.assertSameFileContent(p, outputAppImageDir.resolve(predefinedAppImage.relativize(p)));\n+                        }\n+                    }));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+\n+                TKit.trace(\"Done\");\n+            });\n+        })\n@@ -1165,1 +1284,0 @@\n-            copy.immutable = false;\n@@ -1167,1 +1285,0 @@\n-            copy.dmgInstallDir = cmd.appInstallationDirectory();\n@@ -1247,1 +1364,1 @@\n-                        addLauncherNames().stream().sorted().toList(),\n+                        addLauncherNames(false).stream().sorted().toList(),\n@@ -1385,2 +1502,2 @@\n-    public void verifyIsOfType(Collection<PackageType> types) {\n-        verifyIsOfType(types.toArray(PackageType[]::new));\n+    public final JPackageCommand verifyIsOfType(PackageType ... types) {\n+        return verifyIsOfType(Set.of(types));\n@@ -1389,2 +1506,6 @@\n-    public void verifyIsOfType(PackageType ... types) {\n-        final var typesSet = Stream.of(types).collect(Collectors.toSet());\n+    public final JPackageCommand verifyIsOfType(Iterable<PackageType> types) {\n+        return verifyIsOfType(StreamSupport.stream(types.spliterator(), false).collect(toSet()));\n+    }\n+\n+    public JPackageCommand verifyIsOfType(Set<PackageType> types) {\n+        Objects.requireNonNull(types);\n@@ -1393,2 +1514,2 @@\n-                if ((TKit.isLinux() && typesSet.equals(PackageType.LINUX)) || (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS))) {\n-                    return;\n+                if ((TKit.isLinux() && types.equals(PackageType.LINUX)) || (TKit.isWindows() && types.equals(PackageType.WINDOWS))) {\n+                    return this;\n@@ -1397,2 +1518,2 @@\n-                if (TKit.isOSX() && typesSet.equals(PackageType.MAC)) {\n-                    return;\n+                if (TKit.isOSX() && types.equals(PackageType.MAC)) {\n+                    return this;\n@@ -1400,2 +1521,2 @@\n-            } else if (typesSet.equals(Set.of(PackageType.IMAGE))) {\n-                return;\n+            } else if (types.equals(Set.of(PackageType.IMAGE))) {\n+                return this;\n@@ -1405,2 +1526,2 @@\n-        if (!typesSet.contains(packageType())) {\n-            throw new IllegalArgumentException(\"Unexpected type\");\n+        if (!types.contains(packageType())) {\n+            throw new UnsupportedOperationException(String.format(\"Unsupported operation for type [%s]\", packageType().getType()));\n@@ -1408,0 +1529,2 @@\n+\n+        return this;\n@@ -1503,1 +1626,4 @@\n-            Objects.requireNonNull(action);\n+            add(action, ActionRole.DEFAULT);\n+        }\n+\n+        void add(ThrowingConsumer<JPackageCommand> action, ActionRole role) {\n@@ -1505,7 +1631,30 @@\n-            actions.add(new Consumer<JPackageCommand>() {\n-                @Override\n-                public void accept(JPackageCommand t) {\n-                    if (!executed) {\n-                        executed = true;\n-                        ThrowingConsumer.toConsumer(action).accept(t);\n-                    }\n+            actions.add(new Action(action, role));\n+        }\n+\n+        Stream<ThrowingConsumer<JPackageCommand>> actionsWithRole(ActionRole role) {\n+            Objects.requireNonNull(role);\n+            return actions.stream().filter(action -> {\n+                return Objects.equals(action.role(), role);\n+            }).map(Action::impl);\n+        }\n+\n+        private static final class Action implements Consumer<JPackageCommand> {\n+\n+            Action(ThrowingConsumer<JPackageCommand> impl, ActionRole role) {\n+                this.impl = Objects.requireNonNull(impl);\n+                this.role = Objects.requireNonNull(role);\n+            }\n+\n+            ActionRole role() {\n+                return role;\n+            }\n+\n+            ThrowingConsumer<JPackageCommand> impl() {\n+                return impl;\n+            }\n+\n+            @Override\n+            public void accept(JPackageCommand cmd) {\n+                if (!executed) {\n+                    executed = true;\n+                    ThrowingConsumer.toConsumer(impl).accept(cmd);\n@@ -1513,2 +1662,5 @@\n-                private boolean executed;\n-            });\n+            }\n+\n+            private final ActionRole role;\n+            private final ThrowingConsumer<JPackageCommand> impl;\n+            private boolean executed;\n@@ -1523,1 +1675,1 @@\n-        private final List<Consumer<JPackageCommand>> actions;\n+        private final List<Action> actions;\n@@ -1534,1 +1686,0 @@\n-    private Path dmgInstallDir;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":200,"deletions":49,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-import static jdk.jpackage.test.AdditionalLauncher.forEachAdditionalLauncher;\n@@ -33,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -39,0 +37,1 @@\n+import java.util.Map;\n@@ -47,0 +46,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -48,1 +48,0 @@\n-import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n@@ -70,0 +69,13 @@\n+        public Builder setAppOutputFileNamePrefix(String v) {\n+            appOutputFileNamePrefix = v;\n+            return this;\n+        }\n+\n+        public Builder appendAppOutputFileNamePrefix(String v) {\n+            return setAppOutputFileNamePrefix(appOutputFileNamePrefix() + Objects.requireNonNull(v));\n+        }\n+\n+        public Builder setAppOutputFileNamePrefixToAppName() {\n+            return setAppOutputFileNamePrefix(TKit.getCurrentDefaultAppName());\n+        }\n+\n@@ -75,0 +87,5 @@\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n@@ -77,1 +94,4 @@\n-            return new LauncherAsServiceVerifier(launcherName, appOutputFileName,\n+            return new LauncherAsServiceVerifier(\n+                    launcherName,\n+                    appOutputFileNamePrefix()\n+                            + Optional.ofNullable(appOutputFileName).orElse(\"launcher-as-service.txt\"),\n@@ -79,1 +99,5 @@\n-                    launcherName != null ? additionalLauncherCallback : null);\n+                    Optional.ofNullable(additionalLauncherCallback));\n+        }\n+\n+        public Builder applyTo(PackageTest test) {\n+            return applyTo(new ConfigurationTarget(test));\n@@ -82,2 +106,2 @@\n-        public Builder applyTo(PackageTest pkg) {\n-            create().applyTo(pkg);\n+        public Builder applyTo(ConfigurationTarget target) {\n+            create().applyTo(target);\n@@ -87,0 +111,4 @@\n+        private String appOutputFileNamePrefix() {\n+            return Optional.ofNullable(appOutputFileNamePrefix).orElse(\"\");\n+        }\n+\n@@ -89,1 +117,2 @@\n-        private String appOutputFileName = \"launcher-as-service.txt\";\n+        private String appOutputFileName;\n+        private String appOutputFileNamePrefix;\n@@ -100,2 +129,7 @@\n-            Consumer<AdditionalLauncher> additionalLauncherCallback) {\n-        this.expectedValue = expectedArgValue;\n+            Optional<Consumer<AdditionalLauncher>> additionalLauncherCallback) {\n+\n+        if (launcherName == null && additionalLauncherCallback.isPresent()) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        this.expectedValue = Objects.requireNonNull(expectedArgValue);\n@@ -107,1 +141,1 @@\n-    public void applyTo(PackageTest pkg) {\n+    public void applyTo(ConfigurationTarget target) {\n@@ -109,5 +143,3 @@\n-            pkg.forTypes(WINDOWS, () -> {\n-                pkg.addInitializer(cmd -> {\n-                    \/\/ Remove parameter added to jpackage command line in HelloApp.addTo()\n-                    cmd.removeArgument(\"--win-console\");\n-                });\n+            target.addInitializer(cmd -> {\n+                \/\/ Remove parameter added to jpackage command line in HelloApp.addTo()\n+                cmd.removeArgument(\"--win-console\");\n@@ -115,1 +147,1 @@\n-            applyToMainLauncher(pkg);\n+            applyToMainLauncher(target);\n@@ -117,1 +149,1 @@\n-            applyToAdditionalLauncher(pkg);\n+            applyToAdditionalLauncher(target);\n@@ -119,1 +151,3 @@\n-        pkg.addInstallVerifier(this::verifyLauncherExecuted);\n+        target.test().ifPresent(pkg -> {\n+            pkg.addInstallVerifier(this::verifyLauncherExecuted);\n+        });\n@@ -125,1 +159,1 @@\n-        var launcherNames = getLaunchersAsServices(cmd);\n+        var partitionedLauncherNames = partitionLaunchers(cmd);\n@@ -127,3 +161,7 @@\n-        launcherNames.forEach(toConsumer(launcherName -> {\n-            verify(cmd, launcherName);\n-        }));\n+        var launcherAsServiceNames = partitionedLauncherNames.get(true);\n+\n+        for (var launcherAsService : List.of(true, false)) {\n+            partitionedLauncherNames.get(launcherAsService).forEach(launcherName -> {\n+                verify(cmd, launcherName, launcherAsService);\n+            });\n+        }\n@@ -134,1 +172,1 @@\n-            if (launcherNames.isEmpty()) {\n+            if (launcherAsServiceNames.isEmpty()) {\n@@ -149,1 +187,1 @@\n-                        cmd, null).getParent());\n+                        cmd, \"foo\").getParent());\n@@ -154,1 +192,1 @@\n-                        cmd, null).getParent());\n+                        cmd, \"foo\").getParent());\n@@ -158,1 +196,1 @@\n-        if (launcherNames.isEmpty() || cmd.isRuntime()) {\n+        if (launcherAsServiceNames.isEmpty() || cmd.isRuntime()) {\n@@ -190,1 +228,2 @@\n-        List<String> launcherNames = new ArrayList<>();\n+        return Objects.requireNonNull(partitionLaunchers(cmd).get(true));\n+    }\n@@ -192,2 +231,7 @@\n-        if (cmd.hasArgument(\"--launcher-as-service\")) {\n-            launcherNames.add(null);\n+    private static Map<Boolean, List<String>> partitionLaunchers(JPackageCommand cmd) {\n+        if (cmd.isRuntime()) {\n+            return Map.of(true, List.of(), false, List.of());\n+        } else {\n+            return cmd.launcherNames(true).stream().collect(Collectors.partitioningBy(launcherName -> {\n+                return launcherAsService(cmd, launcherName);\n+            }));\n@@ -195,0 +239,1 @@\n+    }\n@@ -196,7 +241,22 @@\n-        forEachAdditionalLauncher(cmd, toBiConsumer((launcherName, propFilePath) -> {\n-            if (new PropertyFile(propFilePath).findBooleanProperty(\"launcher-as-service\").orElse(false)) {\n-                launcherNames.add(launcherName);\n-            }\n-        }));\n-\n-        return launcherNames;\n+    static boolean launcherAsService(JPackageCommand cmd, String launcherName) {\n+        if (cmd.isMainLauncher(launcherName)) {\n+            return PropertyFinder.findLauncherProperty(cmd, null,\n+                    PropertyFinder.cmdlineBooleanOption(\"--launcher-as-service\"),\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.nop()\n+            ).map(Boolean::parseBoolean).orElse(false);\n+        } else {\n+            var mainLauncherValue = PropertyFinder.findLauncherProperty(cmd, null,\n+                    PropertyFinder.cmdlineBooleanOption(\"--launcher-as-service\"),\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.nop()\n+            ).map(Boolean::parseBoolean).orElse(false);\n+\n+            var value = PropertyFinder.findLauncherProperty(cmd, launcherName,\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.launcherPropertyFile(\"launcher-as-service\"),\n+                    PropertyFinder.appImageFileLauncher(cmd, launcherName, \"service\").defaultValue(Boolean.FALSE.toString())\n+            ).map(Boolean::parseBoolean);\n+\n+            return value.orElse(mainLauncherValue);\n+        }\n@@ -205,1 +265,3 @@\n-    private boolean canVerifyInstall(JPackageCommand cmd) throws IOException {\n+    private boolean canVerifyInstall(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(SUPPORTED_PACKAGES);\n+\n@@ -224,2 +286,2 @@\n-    private void applyToMainLauncher(PackageTest pkg) {\n-        pkg.addInitializer(cmd -> {\n+    private void applyToMainLauncher(ConfigurationTarget target) {\n+        target.addInitializer(cmd -> {\n@@ -235,1 +297,1 @@\n-    private void applyToAdditionalLauncher(PackageTest pkg) {\n+    private void applyToAdditionalLauncher(ConfigurationTarget target) {\n@@ -243,1 +305,1 @@\n-        Optional.ofNullable(additionalLauncherCallback).ifPresent(v -> v.accept(al));\n+        additionalLauncherCallback.ifPresent(v -> v.accept(al));\n@@ -245,1 +307,1 @@\n-        al.applyTo(pkg);\n+        target.add(al);\n@@ -248,1 +310,1 @@\n-    private void verifyLauncherExecuted(JPackageCommand cmd) throws IOException {\n+    public void verifyLauncherExecuted(JPackageCommand cmd) {\n@@ -252,1 +314,1 @@\n-            HelloApp.assertApp(cmd.appLauncherPath())\n+            HelloApp.assertApp(cmd.appLauncherPath(launcherName))\n@@ -260,1 +322,1 @@\n-    private static void deleteOutputFile(Path file) throws IOException {\n+    private static void deleteOutputFile(Path file) {\n@@ -267,2 +329,1 @@\n-                Executor.of(\"sudo\", \"rm\", \"-f\").addArgument(file.toString()).\n-                        execute();\n+                Executor.of(\"sudo\", \"rm\", \"-f\").addArgument(file.toString()).execute();\n@@ -270,1 +331,1 @@\n-                throw ex;\n+                throw new UncheckedIOException(ex);\n@@ -272,0 +333,2 @@\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -275,1 +338,1 @@\n-    private static void verify(JPackageCommand cmd, String launcherName) throws IOException {\n+    private static void verify(JPackageCommand cmd, String launcherName, boolean launcherAsService) {\n@@ -277,1 +340,6 @@\n-            verifyLinuxUnitFile(cmd, launcherName);\n+            if (launcherAsService) {\n+                verifyLinuxUnitFile(cmd, launcherName);\n+            } else {\n+                var serviceUnitFile = LinuxHelper.getServiceUnitFilePath(cmd, launcherName);\n+                TKit.assertPathExists(serviceUnitFile, false);\n+            }\n@@ -279,1 +347,6 @@\n-            verifyMacDaemonPlistFile(cmd, launcherName);\n+            if (launcherAsService) {\n+                verifyMacDaemonPlistFile(cmd, launcherName);\n+            } else {\n+                var servicePlistFile = MacHelper.getServicePlistFilePath(cmd, launcherName);\n+                TKit.assertPathExists(servicePlistFile, false);\n+            }\n@@ -283,2 +356,1 @@\n-    private static void verifyLinuxUnitFile(JPackageCommand cmd,\n-            String launcherName) throws IOException {\n+    private static void verifyLinuxUnitFile(JPackageCommand cmd, String launcherName) {\n@@ -299,1 +371,1 @@\n-                .apply(Files.readAllLines(serviceUnitFile));\n+                .apply(ThrowingFunction.<Path, List<String>>toFunction(Files::readAllLines).apply(serviceUnitFile));\n@@ -302,2 +374,1 @@\n-    private static void verifyMacDaemonPlistFile(JPackageCommand cmd,\n-            String launcherName) throws IOException {\n+    private static void verifyMacDaemonPlistFile(JPackageCommand cmd, String launcherName) {\n@@ -351,1 +422,1 @@\n-    private final Consumer<AdditionalLauncher> additionalLauncherCallback;\n+    private final Optional<Consumer<AdditionalLauncher>> additionalLauncherCallback;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":130,"deletions":59,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -106,3 +106,1 @@\n-        final var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n-\n-        if (name.equals(cmd.name())) {\n+        if (cmd.isMainLauncher(launcherName)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n@@ -37,0 +38,1 @@\n+import java.util.function.BiFunction;\n@@ -75,0 +77,6 @@\n+    static String launcherDescription(JPackageCommand cmd, String launcherName) {\n+        return launcherDescription(cmd, launcherName, (theCmd, theLauncherName) -> {\n+            return getAdditionalLauncherProperties(theCmd, theLauncherName);\n+        });\n+    }\n+\n@@ -140,2 +148,2 @@\n-        return findProperty(\"description\").orElseGet(() -> {\n-            return cmd.getArgumentValue(\"--description\", cmd::name);\n+        return launcherDescription(cmd, name, (theCmd, theLauncherName) -> {\n+            return properties.orElseThrow();\n@@ -275,1 +283,5 @@\n-        if (TKit.isWindows()) {\n+        if (TKit.isWindows() && !cmd.hasArgument(\"--app-image\")) {\n+            \/\/ On Windows, check the description if the predefined app image is not configured.\n+            \/\/ The description and the icon are encoded in the launcher executable, which should be\n+            \/\/ copied verbatim from the predefined app image into the output bundle.\n+            \/\/ This check is done in the JPackageCommand class, so there is no need to duplicate it here.\n@@ -427,0 +439,18 @@\n+    private static String launcherDescription(\n+            JPackageCommand cmd,\n+            String launcherName,\n+            BiFunction<JPackageCommand, String, PropertyFile> addLauncherPropertyFileGetter) {\n+\n+        return PropertyFinder.findLauncherProperty(cmd, launcherName,\n+                PropertyFinder.cmdlineOptionWithValue(\"--description\"),\n+                PropertyFinder.launcherPropertyFile(\"description\"),\n+                PropertyFinder.nop()\n+        ).orElseGet(() -> {\n+            if (cmd.isMainLauncher(launcherName)) {\n+                return cmd.mainLauncherName();\n+            } else {\n+                return launcherDescription(cmd, null, addLauncherPropertyFileGetter);\n+            }\n+        });\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n@@ -48,1 +47,0 @@\n-import java.util.function.Consumer;\n@@ -104,1 +102,1 @@\n-                        Optional.ofNullable(launcherName).orElseGet(cmd::name))));\n+                        Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName))));\n@@ -374,1 +372,0 @@\n-        final var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n@@ -379,1 +376,1 @@\n-                    launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile),\n+                    launcherNameFromDesktopFile(cmd, desktopFile),\n@@ -441,1 +438,3 @@\n-        verifyAllIconsReferenced(cmd);\n+        if (installed) {\n+            verifyAllIconsReferenced(cmd);\n+        }\n@@ -533,1 +532,1 @@\n-    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, Path desktopFile) {\n+    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Path desktopFile) {\n@@ -535,1 +534,0 @@\n-        Objects.requireNonNull(predefinedAppImage);\n@@ -538,5 +536,1 @@\n-        return predefinedAppImage.map(v -> {\n-            return v.launchers().keySet().stream();\n-        }).orElseGet(() -> {\n-            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n-        }).filter(name-> {\n+        return Stream.concat(Stream.of(cmd.mainLauncherName()), cmd.addLauncherNames(true).stream()).filter(name-> {\n@@ -558,1 +552,1 @@\n-        var launcherName = launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile);\n+        var launcherName = launcherNameFromDesktopFile(cmd, desktopFile);\n@@ -568,8 +562,1 @@\n-        final String launcherDescription;\n-        if (cmd.name().equals(launcherName) || predefinedAppImage.isPresent()) {\n-            launcherDescription = Optional.ofNullable(cmd.getArgumentValue(\"--description\")).orElseGet(cmd::name);\n-        } else {\n-            launcherDescription = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"description\").or(() -> {\n-                return Optional.ofNullable(cmd.getArgumentValue(\"--description\"));\n-            }).orElseGet(cmd::name);\n-        }\n+        final var launcherDescription = LauncherVerifier.launcherDescription(cmd, launcherName);\n@@ -888,2 +875,3 @@\n-    private static String getServiceUnitFileName(String packageName,\n-            String launcherName) {\n+    private static String getServiceUnitFileName(String packageName, String launcherName) {\n+        Objects.requireNonNull(packageName);\n+        Objects.requireNonNull(launcherName);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import static jdk.jpackage.internal.util.XmlUtils.initDocumentBuilder;\n@@ -59,0 +60,1 @@\n+import java.util.function.UnaryOperator;\n@@ -62,0 +64,1 @@\n+import javax.xml.stream.XMLStreamException;\n@@ -73,0 +76,1 @@\n+import org.xml.sax.SAXException;\n@@ -299,7 +303,58 @@\n-            var allProps = Stream.of(cmd.getAllArgumentValues(\"--file-associations\")).map(Path::of).map(propFile -> {\n-                try (var propFileReader = Files.newBufferedReader(propFile)) {\n-                    var props = new Properties();\n-                    props.load(propFileReader);\n-                    return props;\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n+            if (cmd.hasArgument(\"--app-image\")) {\n+                copyFaPListFragmentFromPredefinedAppImage(cmd, xml);\n+            } else {\n+                createFaPListFragmentFromFaProperties(cmd, xml);\n+            }\n+        }).run();\n+    }\n+\n+    private static void createFaPListFragmentFromFaProperties(JPackageCommand cmd, XMLStreamWriter xml)\n+            throws XMLStreamException, IOException {\n+\n+        var allProps = Stream.of(cmd.getAllArgumentValues(\"--file-associations\")).map(Path::of).map(propFile -> {\n+            try (var propFileReader = Files.newBufferedReader(propFile)) {\n+                var props = new Properties();\n+                props.load(propFileReader);\n+                return props;\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }).toList();\n+\n+        if (!allProps.isEmpty()) {\n+            var bundleId = getPackageId(cmd);\n+\n+            Function<Properties, String> contentType = fa -> {\n+                return String.format(\"%s.%s\", bundleId, Objects.requireNonNull(fa.getProperty(\"extension\")));\n+            };\n+\n+            Function<Properties, Optional<String>> icon = fa -> {\n+                return Optional.ofNullable(fa.getProperty(\"icon\")).map(Path::of).map(Path::getFileName).map(Path::toString);\n+            };\n+\n+            BiFunction<Properties, String, Optional<Boolean>> asBoolean = (fa, key) -> {\n+                return Optional.ofNullable(fa.getProperty(key)).map(Boolean::parseBoolean);\n+            };\n+\n+            BiFunction<Properties, String, List<String>> asList = (fa, key) -> {\n+                return Optional.ofNullable(fa.getProperty(key)).map(str -> {\n+                    return List.of(str.split(\"[ ,]+\"));\n+                }).orElseGet(List::of);\n+            };\n+\n+            writeKey(xml, \"CFBundleDocumentTypes\");\n+            writeArray(xml, toXmlConsumer(() -> {\n+                for (var fa : allProps) {\n+                    writeDict(xml, toXmlConsumer(() -> {\n+                        writeStringArray(xml, \"LSItemContentTypes\", List.of(contentType.apply(fa)));\n+                        writeStringOptional(xml, \"CFBundleTypeName\", Optional.ofNullable(fa.getProperty(\"description\")));\n+                        writeString(xml, \"LSHandlerRank\", Optional.ofNullable(fa.getProperty(\"mac.LSHandlerRank\")).orElse(\"Owner\"));\n+                        writeString(xml, \"CFBundleTypeRole\", Optional.ofNullable(fa.getProperty(\"mac.CFBundleTypeRole\")).orElse(\"Editor\"));\n+                        writeStringOptional(xml, \"NSPersistentStoreTypeKey\", Optional.ofNullable(fa.getProperty(\"mac.NSPersistentStoreTypeKey\")));\n+                        writeStringOptional(xml, \"NSDocumentClass\", Optional.ofNullable(fa.getProperty(\"mac.NSDocumentClass\")));\n+                        writeBoolean(xml, \"LSIsAppleDefaultForType\", true);\n+                        writeBooleanOptional(xml, \"LSTypeIsPackage\", asBoolean.apply(fa, \"mac.LSTypeIsPackage\"));\n+                        writeBooleanOptional(xml, \"LSSupportsOpeningDocumentsInPlace\", asBoolean.apply(fa, \"mac.LSSupportsOpeningDocumentsInPlace\"));\n+                        writeBooleanOptional(xml, \"UISupportsDocumentBrowser\", asBoolean.apply(fa, \"mac.UISupportsDocumentBrowser\"));\n+                        writeStringOptional(xml, \"CFBundleTypeIconFile\", icon.apply(fa));\n+                    }));\n@@ -307,1 +362,1 @@\n-            }).toList();\n+            }));\n@@ -309,2 +364,23 @@\n-            if (!allProps.isEmpty()) {\n-                var bundleId = getPackageId(cmd);\n+            writeKey(xml, \"UTExportedTypeDeclarations\");\n+            writeArray(xml, toXmlConsumer(() -> {\n+                for (var fa : allProps) {\n+                    writeDict(xml, toXmlConsumer(() -> {\n+                        writeString(xml, \"UTTypeIdentifier\", contentType.apply(fa));\n+                        writeStringOptional(xml, \"UTTypeDescription\", Optional.ofNullable(fa.getProperty(\"description\")));\n+                        if (fa.containsKey(\"mac.UTTypeConformsTo\")) {\n+                            writeStringArray(xml, \"UTTypeConformsTo\", asList.apply(fa, \"mac.UTTypeConformsTo\"));\n+                        } else {\n+                            writeStringArray(xml, \"UTTypeConformsTo\", List.of(\"public.data\"));\n+                        }\n+                        writeStringOptional(xml, \"UTTypeIconFile\", icon.apply(fa));\n+                        writeKey(xml, \"UTTypeTagSpecification\");\n+                        writeDict(xml, toXmlConsumer(() -> {\n+                            writeStringArray(xml, \"public.filename-extension\", List.of(fa.getProperty(\"extension\")));\n+                            writeStringArray(xml, \"public.mime-type\", List.of(fa.getProperty(\"mime-type\")));\n+                            writeStringArray(xml, \"NSExportableTypes\", asList.apply(fa, \"mac.NSExportableTypes\"));\n+                        }));\n+                    }));\n+                }\n+            }));\n+        }\n+    }\n@@ -312,3 +388,2 @@\n-                Function<Properties, String> contentType = fa -> {\n-                    return String.format(\"%s.%s\", bundleId, Objects.requireNonNull(fa.getProperty(\"extension\")));\n-                };\n+    private static void copyFaPListFragmentFromPredefinedAppImage(JPackageCommand cmd, XMLStreamWriter xml)\n+            throws IOException, SAXException, XMLStreamException {\n@@ -316,3 +391,1 @@\n-                Function<Properties, Optional<String>> icon = fa -> {\n-                    return Optional.ofNullable(fa.getProperty(\"icon\")).map(Path::of).map(Path::getFileName).map(Path::toString);\n-                };\n+        var predefinedAppImage = Path.of(Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).orElseThrow(IllegalArgumentException::new));\n@@ -320,3 +393,1 @@\n-                BiFunction<Properties, String, Optional<Boolean>> asBoolean = (fa, key) -> {\n-                    return Optional.ofNullable(fa.getProperty(key)).map(Boolean::parseBoolean);\n-                };\n+        var plistPath = ApplicationLayout.macAppImage().resolveAt(predefinedAppImage).contentDirectory().resolve(\"Info.plist\");\n@@ -324,5 +395,2 @@\n-                BiFunction<Properties, String, List<String>> asList = (fa, key) -> {\n-                    return Optional.ofNullable(fa.getProperty(key)).map(str -> {\n-                        return List.of(str.split(\"[ ,]+\"));\n-                    }).orElseGet(List::of);\n-                };\n+        try (var plistStream = Files.newInputStream(plistPath)) {\n+            var plist = new PListReader(initDocumentBuilder().parse(plistStream));\n@@ -330,18 +398,7 @@\n-                writeKey(xml, \"CFBundleDocumentTypes\");\n-                writeArray(xml, toXmlConsumer(() -> {\n-                    for (var fa : allProps) {\n-                        writeDict(xml, toXmlConsumer(() -> {\n-                            writeStringArray(xml, \"LSItemContentTypes\", List.of(contentType.apply(fa)));\n-                            writeStringOptional(xml, \"CFBundleTypeName\", Optional.ofNullable(fa.getProperty(\"description\")));\n-                            writeString(xml, \"LSHandlerRank\", Optional.ofNullable(fa.getProperty(\"mac.LSHandlerRank\")).orElse(\"Owner\"));\n-                            writeString(xml, \"CFBundleTypeRole\", Optional.ofNullable(fa.getProperty(\"mac.CFBundleTypeRole\")).orElse(\"Editor\"));\n-                            writeStringOptional(xml, \"NSPersistentStoreTypeKey\", Optional.ofNullable(fa.getProperty(\"mac.NSPersistentStoreTypeKey\")));\n-                            writeStringOptional(xml, \"NSDocumentClass\", Optional.ofNullable(fa.getProperty(\"mac.NSDocumentClass\")));\n-                            writeBoolean(xml, \"LSIsAppleDefaultForType\", true);\n-                            writeBooleanOptional(xml, \"LSTypeIsPackage\", asBoolean.apply(fa, \"mac.LSTypeIsPackage\"));\n-                            writeBooleanOptional(xml, \"LSSupportsOpeningDocumentsInPlace\", asBoolean.apply(fa, \"mac.LSSupportsOpeningDocumentsInPlace\"));\n-                            writeBooleanOptional(xml, \"UISupportsDocumentBrowser\", asBoolean.apply(fa, \"mac.UISupportsDocumentBrowser\"));\n-                            writeStringOptional(xml, \"CFBundleTypeIconFile\", icon.apply(fa));\n-                        }));\n-                    }\n-                }));\n+            var entries = Stream.of(\"CFBundleDocumentTypes\", \"UTExportedTypeDeclarations\").map(key -> {\n+                return plist.findArrayValue(key, false).map(stream -> {\n+                    return stream.map(PListReader.class::cast).toList();\n+                }).map(plistList -> {\n+                    return Map.entry(key, plistList);\n+                });\n+            }).filter(Optional::isPresent).map(Optional::get).toList();\n@@ -349,1 +406,2 @@\n-                writeKey(xml, \"UTExportedTypeDeclarations\");\n+            for (var e : entries) {\n+                writeKey(xml, e.getKey());\n@@ -351,17 +409,2 @@\n-                    for (var fa : allProps) {\n-                        writeDict(xml, toXmlConsumer(() -> {\n-                            writeString(xml, \"UTTypeIdentifier\", contentType.apply(fa));\n-                            writeStringOptional(xml, \"UTTypeDescription\", Optional.ofNullable(fa.getProperty(\"description\")));\n-                            if (fa.containsKey(\"mac.UTTypeConformsTo\")) {\n-                                writeStringArray(xml, \"UTTypeConformsTo\", asList.apply(fa, \"mac.UTTypeConformsTo\"));\n-                            } else {\n-                                writeStringArray(xml, \"UTTypeConformsTo\", List.of(\"public.data\"));\n-                            }\n-                            writeStringOptional(xml, \"UTTypeIconFile\", icon.apply(fa));\n-                            writeKey(xml, \"UTTypeTagSpecification\");\n-                            writeDict(xml, toXmlConsumer(() -> {\n-                                writeStringArray(xml, \"public.filename-extension\", List.of(fa.getProperty(\"extension\")));\n-                                writeStringArray(xml, \"public.mime-type\", List.of(fa.getProperty(\"mime-type\")));\n-                                writeStringArray(xml, \"NSExportableTypes\", asList.apply(fa, \"mac.NSExportableTypes\"));\n-                            }));\n-                        }));\n+                    for (var arrayElement : e.getValue()) {\n+                        arrayElement.toXmlConsumer().accept(xml);\n@@ -371,1 +414,43 @@\n-        }).run();\n+        }\n+    }\n+\n+    public static Path createRuntimeBundle(Consumer<JPackageCommand> mutator) {\n+        return createRuntimeBundle(Optional.of(mutator));\n+    }\n+\n+    public static Path createRuntimeBundle() {\n+        return createRuntimeBundle(Optional.empty());\n+    }\n+\n+    public static Path createRuntimeBundle(Optional<Consumer<JPackageCommand>> mutator) {\n+        Objects.requireNonNull(mutator);\n+\n+        final var runtimeImage = JPackageCommand.createInputRuntimeImage();\n+\n+        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n+\n+        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n+\n+        var cmd = new JPackageCommand()\n+                .useToolProvider(true)\n+                .ignoreDefaultRuntime(true)\n+                .dumpOutput(true)\n+                .setPackageType(PackageType.MAC_DMG)\n+                .setArgumentValue(\"--name\", \"foo\")\n+                .addArguments(\"--runtime-image\", runtimeImage)\n+                .addArguments(\"--dest\", runtimeBundleWorkDir);\n+\n+        mutator.ifPresent(cmd::mutate);\n+\n+        cmd.execute();\n+\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n+                Executor.of(\"cp\", \"-R\")\n+                        .addArgument(dmgImage)\n+                        .addArgument(unpackadeRuntimeBundleDir)\n+                        .execute(0);\n+            }\n+        });\n+\n+        return unpackadeRuntimeBundleDir;\n@@ -463,0 +548,37 @@\n+    static boolean isVerbatimCopyFromPredefinedAppImage(JPackageCommand cmd, Path path) {\n+        cmd.verifyIsOfType(PackageType.MAC);\n+\n+        final var predefinedAppImage = Path.of(cmd.getArgumentValue(\"--app-image\"));\n+\n+        final var appLayout = ApplicationLayout.macAppImage().resolveAt(predefinedAppImage);\n+\n+        if (!path.startsWith(predefinedAppImage)) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Path [%s] is not in directory [%s]\", path, predefinedAppImage));\n+        }\n+\n+        if (path.startsWith(appLayout.contentDirectory().resolve(\"_CodeSignature\"))) {\n+            \/\/ A file in the \"Contents\/_CodeSignature\" directory.\n+            return false;\n+        }\n+\n+        final var outputAppImageDir = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n+\n+        final var outputAppImagePath = outputAppImageDir.resolve(predefinedAppImage.relativize(path));\n+\n+        if (path.startsWith(appLayout.launchersDirectory()) &&\n+                cmd.launcherNames(true).stream().map(cmd::appLauncherPath).collect(toSet()).contains(outputAppImagePath)) {\n+            \/\/ The `path` references a launcher.\n+            \/\/ It can be signed and its digest may change.\n+            return false;\n+        }\n+\n+        if (path.startsWith(appLayout.runtimeHomeDirectory().resolve(\"bin\"))) {\n+            \/\/ The `path` references an executable native command in JDK's \"bin\" subdirectory.\n+            \/\/ It can be signed and its digest may change.\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n@@ -634,6 +756,2 @@\n-        final Path installLocation;\n-        if (cmd.packageType() == PackageType.MAC_DMG) {\n-            installLocation = defaultInstallLocation;\n-        } else {\n-            installLocation = cmd.getArgumentValue(\"--install-dir\", () -> defaultInstallLocation, Path::of);\n-        }\n+        final Path installLocation = Optional.ofNullable(cmd.getArgumentValue(\"--install-dir\"))\n+                .map(Path::of).orElse(defaultInstallLocation);\n@@ -665,10 +783,15 @@\n-        return cmd.getArgumentValue(\"--mac-package-identifier\", () -> {\n-            return cmd.getArgumentValue(\"--main-class\", cmd::name, className -> {\n-                var packageName = ClassDesc.of(className).packageName();\n-                if (packageName.isEmpty()) {\n-                    return className;\n-                } else {\n-                    return packageName;\n-                }\n-            });\n-        });\n+        UnaryOperator<String> getPackageIdFromClassName = className -> {\n+            var packageName = ClassDesc.of(className).packageName();\n+            if (packageName.isEmpty()) {\n+                return className;\n+            } else {\n+                return packageName;\n+            }\n+        };\n+\n+        return PropertyFinder.findAppProperty(cmd,\n+                PropertyFinder.cmdlineOptionWithValue(\"--mac-package-identifier\").or(\n+                        PropertyFinder.cmdlineOptionWithValue(\"--main-class\").map(getPackageIdFromClassName)\n+                ),\n+                PropertyFinder.appImageFile(AppImageFile::mainLauncherClassName).map(getPackageIdFromClassName)\n+        ).orElseGet(cmd::name);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":200,"deletions":77,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -64,5 +64,3 @@\n-        if (!cmd.isRuntime()) {\n-            cmd.addLauncherNames().stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n-                assertSigned(launcherPath, certRequest);\n-            });\n-        }\n+        cmd.addLauncherNames(true).stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n+            assertSigned(launcherPath, certRequest);\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.jpackage.test.JPackageCommand.ActionRole;\n@@ -236,0 +237,9 @@\n+    public PackageTest usePredefinedAppImage(JPackageCommand appImageCmd) {\n+        appImageCmd.verifyIsOfType(PackageType.IMAGE);\n+        addInitializer(cmd -> {\n+            cmd.usePredefinedAppImage(appImageCmd.outputBundle());\n+        });\n+        appImageCmd.getVerifyActionsWithRole(ActionRole.LAUNCHER_VERIFIER).forEach(this::addInstallVerifier);\n+        return this;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+\n+final class PropertyFinder {\n+\n+    @FunctionalInterface\n+    static interface Finder<T> {\n+        Optional<String> find(T target);\n+\n+        default Finder<T> defaultValue(String v) {\n+            return target -> {\n+                return Optional.of(find(target).orElse(v));\n+            };\n+        }\n+\n+        default Finder<T> defaultValue(Supplier<String> v) {\n+            return target -> {\n+                return Optional.of(find(target).orElseGet(v));\n+            };\n+        }\n+\n+        default Finder<T> map(UnaryOperator<String> v) {\n+            Objects.requireNonNull(v);\n+            return target -> {\n+                return find(target).map(v);\n+            };\n+        }\n+\n+        default Finder<T> or(Finder<T> other) {\n+            return target -> {\n+                return find(target).or(() -> {\n+                    return other.find(target);\n+                });\n+            };\n+        }\n+    }\n+\n+    static <T> Finder<T> nop() {\n+        return target -> {\n+            return Optional.empty();\n+        };\n+    }\n+\n+    static Finder<AppImageFile> appImageFileLauncher(JPackageCommand cmd, String launcherName, String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        if (cmd.isMainLauncher(launcherName)) {\n+            return target -> {\n+                return Optional.ofNullable(target.launchers().get(target.mainLauncherName()).get(propertyName));\n+            };\n+        } else {\n+            return target -> {\n+                return Optional.ofNullable(target.addLaunchers().get(launcherName).get(propertyName));\n+            };\n+        }\n+    }\n+\n+    static Finder<AppImageFile> appImageFile(Function<AppImageFile, String> propertyGetter) {\n+        Objects.requireNonNull(propertyGetter);\n+        return target -> {\n+            return Optional.of(propertyGetter.apply(target));\n+        };\n+    }\n+\n+    static Finder<AppImageFile> appImageFileOptional(Function<AppImageFile, Optional<String>> propertyGetter) {\n+        Objects.requireNonNull(propertyGetter);\n+        return target -> {\n+            return propertyGetter.apply(target);\n+        };\n+    }\n+\n+    static Finder<PropertyFile> launcherPropertyFile(String propertyName) {\n+        return target -> {\n+            return target.findProperty(propertyName);\n+        };\n+    }\n+\n+    static Finder<JPackageCommand> cmdlineBooleanOption(String optionName) {\n+        return target -> {\n+            return Optional.of(target.hasArgument(optionName)).map(Boolean::valueOf).map(Object::toString);\n+        };\n+    }\n+\n+    static Finder<JPackageCommand> cmdlineOptionWithValue(String optionName) {\n+        return target -> {\n+            return Optional.ofNullable(target.getArgumentValue(optionName));\n+        };\n+    }\n+\n+    static Optional<String> findAppProperty(\n+            JPackageCommand cmd,\n+            Finder<JPackageCommand> cmdlineFinder,\n+            Finder<AppImageFile> appImageFileFinder) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(cmdlineFinder);\n+        Objects.requireNonNull(appImageFileFinder);\n+\n+        var reply = cmdlineFinder.find(cmd);\n+        if (reply.isPresent()) {\n+            return reply;\n+        } else {\n+            var appImageFilePath = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+            return appImageFilePath.map(AppImageFile::load).flatMap(appImageFileFinder::find);\n+        }\n+    }\n+\n+    static Optional<String> findLauncherProperty(\n+            JPackageCommand cmd,\n+            String launcherName,\n+            Finder<JPackageCommand> cmdlineFinder,\n+            Finder<PropertyFile> addLauncherPropertyFileFinder,\n+            Finder<AppImageFile> appImageFileFinder) {\n+\n+        return findLauncherProperty(\n+                cmd,\n+                launcherName,\n+                (theCmd, theLauncherName) -> {\n+                    return getAdditionalLauncherProperties(theCmd, theLauncherName);\n+                },\n+                cmdlineFinder,\n+                addLauncherPropertyFileFinder,\n+                appImageFileFinder);\n+    }\n+\n+    static Optional<String> findLauncherProperty(\n+            JPackageCommand cmd,\n+            String launcherName,\n+            BiFunction<JPackageCommand, String, PropertyFile> addLauncherPropertyFileGetter,\n+            Finder<JPackageCommand> cmdlineFinder,\n+            Finder<PropertyFile> addLauncherPropertyFileFinder,\n+            Finder<AppImageFile> appImageFileFinder) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(addLauncherPropertyFileGetter);\n+        Objects.requireNonNull(cmdlineFinder);\n+        Objects.requireNonNull(addLauncherPropertyFileFinder);\n+        Objects.requireNonNull(appImageFileFinder);\n+\n+        var mainLauncher = cmd.isMainLauncher(launcherName);\n+\n+        var appImageFilePath = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+\n+        Optional<String> reply;\n+\n+        if (mainLauncher) {\n+            reply = cmdlineFinder.find(cmd);\n+        } else if (appImageFilePath.isEmpty()) {\n+            var props = addLauncherPropertyFileGetter.apply(cmd, launcherName);\n+            reply = addLauncherPropertyFileFinder.find(props);\n+        } else {\n+            reply = Optional.empty();\n+        }\n+\n+        if (reply.isPresent()) {\n+            return reply;\n+        } else {\n+            return appImageFilePath.map(AppImageFile::load).flatMap(appImageFileFinder::find);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PropertyFinder.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -317,2 +317,5 @@\n-        ThrowingRunnable.toRunnable(() -> Files.write(filename,\n-                lines.peek(TKit::trace).collect(Collectors.toList()))).run();\n+        try {\n+            Files.write(filename, lines.peek(TKit::trace).toList());\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -326,3 +329,7 @@\n-        ThrowingRunnable.toRunnable(() -> Files.write(propsFilename,\n-                props.stream().map(e -> String.join(\"=\", e.getKey(),\n-                e.getValue())).peek(TKit::trace).collect(Collectors.toList()))).run();\n+        try {\n+            Files.write(propsFilename, props.stream().map(e -> {\n+                return String.join(\"=\", e.getKey(), e.getValue());\n+            }).peek(TKit::trace).toList());\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -332,1 +339,1 @@\n-    public static void traceFileContents(Path path, String label) throws IOException {\n+    public static void traceFileContents(Path path, String label) {\n@@ -335,1 +342,5 @@\n-        Files.readAllLines(path).forEach(TKit::trace);\n+        try {\n+            Files.readAllLines(path).forEach(TKit::trace);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n@@ -35,1 +36,0 @@\n-import java.util.HashMap;\n@@ -54,1 +54,1 @@\n-        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames().isEmpty()) {\n+        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames(true).isEmpty()) {\n@@ -173,1 +173,1 @@\n-        var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n+        var name = Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName);\n@@ -253,1 +253,0 @@\n-        Map<String, Collection<Shortcut>> expectedShortcuts = new HashMap<>();\n@@ -257,5 +256,3 @@\n-        predefinedAppImage.map(v -> {\n-            return v.launchers().keySet().stream();\n-        }).orElseGet(() -> {\n-            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n-        }).forEach(launcherName -> {\n+        return cmd.launcherNames(true).stream().map(launcherName -> {\n+            return Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName);\n+        }).map(launcherName -> {\n@@ -263,2 +260,4 @@\n-            if (!shortcuts.isEmpty()) {\n-                expectedShortcuts.put(launcherName, shortcuts);\n+            if (shortcuts.isEmpty()) {\n+                return null;\n+            } else {\n+                return Map.entry(launcherName, shortcuts);\n@@ -266,3 +265,1 @@\n-        });\n-\n-        return expectedShortcuts;\n+        }).filter(Objects::nonNull).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinShortcutVerifier.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.util.XmlUtils.initDocumentBuilder;\n@@ -33,0 +34,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -44,0 +47,1 @@\n+import org.junit.jupiter.api.io.TempDir;\n@@ -280,2 +284,39 @@\n-    @Test\n-    public void test_toMap() {\n+    @ParameterizedTest\n+    @MethodSource(\"parsedPLists\")\n+    public void test_toMap(ParsedPList data) {\n+        testSpec().xml(data.xml()).expect(data.xmlAsMap()).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parsedPLists\")\n+    public void test_toConsumer(ParsedPList data, @TempDir Path workDir) throws IOException, SAXException {\n+        var node = createXml(data.xml);\n+\n+        var srcPList = new PListReader(node);\n+\n+        var sink = workDir.resolve(\"sink.xml\");\n+\n+        XmlUtils.createXml(sink, xml -> {\n+            PListWriter.writePList(xml, srcPList.toXmlConsumer());\n+        });\n+\n+        try (var in = Files.newInputStream(sink)) {\n+            var dstPList = new PListReader(initDocumentBuilder().parse(in));\n+\n+            var src = srcPList.toMap(true);\n+            var dst = dstPList.toMap(true);\n+\n+            assertEquals(data.xmlAsMap(), src);\n+            assertEquals(data.xmlAsMap(), dst);\n+        }\n+    }\n+\n+    private record ParsedPList(Map<String, Object> xmlAsMap, String... xml) {\n+        ParsedPList {\n+            Objects.requireNonNull(xmlAsMap);\n+        }\n+\n+        ParsedPList(Map<String, Object> xmlAsMap, List<String> xml) {\n+            this(xmlAsMap, xml.toArray(String[]::new));\n+        }\n+    }\n@@ -283,1 +324,1 @@\n-        var builder = testSpec();\n+    private static Stream<ParsedPList> parsedPLists() {\n@@ -285,1 +326,1 @@\n-        builder.xml(\n+        var xml = List.of(\n@@ -370,1 +411,1 @@\n-        builder.expect(expected).queryType(QueryType.TO_MAP_RECURSIVE).create().test();\n+        return Stream.of(new ParsedPList(expected, xml));\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PListReaderTest.java","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.jpackage.internal.util.Slot;\n@@ -31,0 +32,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -46,0 +48,1 @@\n+import java.util.function.Consumer;\n@@ -52,1 +55,1 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -55,0 +58,1 @@\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -72,1 +76,0 @@\n- * @key jpackagePlatformPackage\n@@ -76,1 +79,0 @@\n- * @requires (jpackage.test.SQETest == null)\n@@ -85,4 +87,1 @@\n-        var cmd = cfg.init(JPackageCommand.helloAppImage());\n-        var verifier = cfg.createPListFilesVerifier(cmd.executePrerequisiteActions());\n-        cmd.executeAndAssertHelloAppImageCreated();\n-        verifier.accept(cmd);\n+        testApp(new ConfigurationTarget(JPackageCommand.helloAppImage()), cfg);\n@@ -93,6 +92,21 @@\n-    public void testNativePackage(TestConfig cfg) {\n-        List<ThrowingConsumer<JPackageCommand>> verifier = new ArrayList<>();\n-        new PackageTest().configureHelloApp().addInitializer(cmd -> {\n-            cfg.init(cmd.setFakeRuntime());\n-        }).addRunOnceInitializer(() -> {\n-            verifier.add(cfg.createPListFilesVerifier(JPackageCommand.helloAppImage().executePrerequisiteActions()));\n+    public void testPackage(TestConfig cfg) {\n+        testApp(new ConfigurationTarget(new PackageTest().configureHelloApp()), cfg);\n+    }\n+\n+    @Test\n+    @ParameterSupplier(\"customPLists\")\n+    public void testFromAppImage(TestConfig cfg) {\n+\n+        var verifier = Slot.<Consumer<JPackageCommand>>createEmpty();\n+\n+        var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            \/\/ Create the input app image with custom plist file(s).\n+            \/\/ Call JPackageCommand.executePrerequisiteActions() to initialize\n+            \/\/ all command line options.\n+            cfg.init(appImageCmd.executePrerequisiteActions());\n+            appImageCmd.execute();\n+            verifier.set(cfg.createPListFilesVerifier(appImageCmd));\n+        }).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--input\").setArgumentValue(\"--app-image\", appImageCmd.outputBundle());\n@@ -100,1 +114,1 @@\n-            verifier.get(0).accept(cmd);\n+            verifier.get().accept(cmd);\n@@ -105,2 +119,5 @@\n-    public void testRuntime() {\n-        final Path runtimeImage[] = new Path[1];\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testRuntime(boolean runtimeBundle) {\n+\n+        var runtimeImage = Slot.<Path>createEmpty();\n@@ -111,1 +128,13 @@\n-            runtimeImage[0] = JPackageCommand.createInputRuntimeImage();\n+            if (runtimeBundle) {\n+                \/\/ Use custom plist file with the input runtime bundle.\n+                runtimeImage.set(MacHelper.createRuntimeBundle(toConsumer(buildRuntimeBundleCmd -> {\n+                    \/\/ Use the same name for the input runtime bundle as the name of the output bundle.\n+                    \/\/ This is to make the plist file validation pass, as the custom plist file\n+                    \/\/ is configured for the command building the input runtime bundle,\n+                    \/\/ but the plist file from the output bundle is examined.\n+                    buildRuntimeBundleCmd.setDefaultAppName();\n+                    cfg.init(buildRuntimeBundleCmd);\n+                })));\n+            } else {\n+                runtimeImage.set(JPackageCommand.createInputRuntimeImage());\n+            }\n@@ -115,2 +144,4 @@\n-                    .setArgumentValue(\"--runtime-image\", runtimeImage[0]);\n-            cfg.init(cmd);\n+                    .setArgumentValue(\"--runtime-image\", runtimeImage.get());\n+            if (!runtimeBundle) {\n+                cfg.init(cmd);\n+            }\n@@ -133,0 +164,25 @@\n+    private void testApp(ConfigurationTarget target, TestConfig cfg) {\n+\n+        List<Consumer<JPackageCommand>> verifier = new ArrayList<>();\n+\n+        target.addInitializer(JPackageCommand::setFakeRuntime);\n+\n+        target.addInitializer(toConsumer(cfg::init));\n+\n+        target.addRunOnceInitializer(_ -> {\n+            verifier.add(cfg.createPListFilesVerifier(\n+                    target.cmd().orElseGet(JPackageCommand::helloAppImage).executePrerequisiteActions()\n+            ));\n+        });\n+\n+        target.cmd().ifPresent(JPackageCommand::executeAndAssertHelloAppImageCreated);\n+\n+        target.addInstallVerifier(cmd -> {\n+            verifier.get(0).accept(cmd);\n+        });\n+\n+        target.test().ifPresent(test -> {\n+            test.run(Action.CREATE_AND_UNPACK);\n+        });\n+    }\n+\n@@ -176,2 +232,2 @@\n-        ThrowingConsumer<JPackageCommand> createPListFilesVerifier(JPackageCommand cmd) throws IOException {\n-            ThrowingConsumer<JPackageCommand> defaultVerifier = otherCmd -> {\n+        Consumer<JPackageCommand> createPListFilesVerifier(JPackageCommand cmd) {\n+            Consumer<JPackageCommand> customPListFilesVerifier = toConsumer(otherCmd -> {\n@@ -181,1 +237,1 @@\n-            };\n+            });\n@@ -183,0 +239,2 @@\n+            \/\/ Get the list of default plist files.\n+            \/\/ These are the plist files created from the plist file templates in jpackage resources.\n@@ -186,1 +244,2 @@\n-                return defaultVerifier;\n+                \/\/ All plist files in the bundle are customized.\n+                return customPListFilesVerifier;\n@@ -188,1 +247,6 @@\n-                var vanillaCmd = new JPackageCommand().setFakeRuntime()\n+                \/\/ There are some default plist files in the bundle.\n+                \/\/ Verify the expected default plist files are such.\n+\n+                \/\/ Create a copy of the `cmd` without the resource directory and with the app image bundling type.\n+                \/\/ Execute it and get the default plist files.\n+                var vanillaCmd = new JPackageCommand()\n@@ -193,1 +257,1 @@\n-                vanillaCmd.executeIgnoreExitCode().assertExitCodeIsZero();\n+                vanillaCmd.execute();\n@@ -196,1 +260,3 @@\n-                    defaultVerifier.accept(otherCmd);\n+                    \/\/ Verify custom plist files.\n+                    customPListFilesVerifier.accept(otherCmd);\n+                    \/\/ Verify default plist files.\n@@ -239,1 +305,4 @@\n-        APP_WITH_FA(APP),\n+        APP_WITH_FA(\n+                CustomPListFactory.PLIST_INPUT::writeAppPlistWithFa,\n+                CustomPListFactory.PLIST_OUTPUT::writeAppPlistWithFa,\n+                \"Info.plist\"),\n@@ -261,6 +330,0 @@\n-        private CustomPListType(CustomPListType other) {\n-            this.inputPlistWriter = other.inputPlistWriter;\n-            this.outputPlistWriter = other.outputPlistWriter;\n-            this.outputPlistFilename = other.outputPlistFilename;\n-        }\n-\n@@ -318,0 +381,4 @@\n+        private void writeAppPlistWithFa(JPackageCommand cmd, XMLStreamWriter xml) throws XMLStreamException, IOException {\n+            writeAppPlist(cmd, xml, true);\n+        }\n+\n@@ -319,0 +386,4 @@\n+            writeAppPlist(cmd, xml, false);\n+        }\n+\n+        private void writeAppPlist(JPackageCommand cmd, XMLStreamWriter xml, boolean withFa) throws XMLStreamException, IOException {\n@@ -331,1 +402,1 @@\n-                    if (cmd.hasArgument(\"--file-associations\")) {\n+                    if (withFa) {\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/CustomInfoPListTest.java","additions":105,"deletions":34,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n- * @key jpackagePlatformPackage\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/DmgContentTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- * @key jpackagePlatformPackage\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/HostArchPkgTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+    @ParameterSupplier(\"testSelectSigningIdentity_JDK_8371094\")\n@@ -210,0 +211,6 @@\n+    public static Collection<Object[]> testSelectSigningIdentity_JDK_8371094() {\n+        return List.<Object[]>of(new Object[] {\n+                \"ACME Technologies Limited\", SigningBase.StandardCertificateRequest.CODESIGN_ACME_TECH_LTD.spec()\n+        });\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacSignTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-\n-import java.nio.file.Path;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.ApplicationLayout;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.MacSign;\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.PackageType;\n-import jdk.jpackage.test.TKit;\n-\n-\/**\n- * Tests generation of dmg and pkg from signed predefined app image which was\n- * signed using two step process (generate app image and then signed using\n- * --app-image and --mac-sign). Test will generate pkg and verifies its\n- * signature. It verifies that dmg is not signed, but app image inside dmg\n- * is signed. This test requires that the machine is configured with test\n- * certificate for \"Developer ID Installer: jpackage.openjdk.java.net\" in\n- * jpackagerTest keychain with always allowed access to this keychain for user\n- * which runs test.\n- * note:\n- * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n- * \"jpackage.mac.signing.key.user.name\", and\n- * \"jpackagerTest\" can be over-ridden by system property\n- * \"jpackage.mac.signing.keychain\"\n- *\/\n-\n-\/*\n- * @test\n- * @summary jpackage with --type pkg,dmg --app-image\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @library base\n- * @key jpackagePlatformPackage\n- * @build SigningBase\n- * @build jdk.jpackage.test.*\n- * @build SigningPackageFromTwoStepAppImageTest\n- * @requires (jpackage.test.MacSignTests == \"run\")\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=SigningPackageFromTwoStepAppImageTest\n- *  --jpt-before-run=SigningBase.verifySignTestEnvReady\n- *\/\n-public class SigningPackageFromTwoStepAppImageTest {\n-\n-    private static void verifyPKG(JPackageCommand cmd) {\n-        if (!cmd.hasArgument(\"--mac-sign\")) {\n-            return; \/\/ Nothing to check if not signed\n-        }\n-\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyPkgutil(outputBundle, true, SigningBase.DEFAULT_INDEX);\n-        SigningBase.verifySpctl(outputBundle, \"install\", SigningBase.DEFAULT_INDEX);\n-    }\n-\n-    private static void verifyDMG(JPackageCommand cmd) {\n-        \/\/ DMG always unsigned, so we will check it\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyDMG(outputBundle);\n-    }\n-\n-    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n-            \/\/ we only need to verify app.\n-            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n-                Path launcherPath = ApplicationLayout.platformAppImage()\n-                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n-                SigningBase.verifyCodesign(launcherPath, true, SigningBase.DEFAULT_INDEX);\n-                SigningBase.verifyCodesign(dmgImage, true, SigningBase.DEFAULT_INDEX);\n-                SigningBase.verifySpctl(dmgImage, \"exec\", SigningBase.DEFAULT_INDEX);\n-            }\n-        });\n-    }\n-\n-    @Test\n-    \/\/ ({\"sign or not\", \"signing-key or sign-identity\"})\n-    \/\/ Sign and signing-key\n-    @Parameter({\"true\", \"true\"})\n-    \/\/ Sign and sign-identity\n-    @Parameter({\"true\", \"false\"})\n-    \/\/ Unsigned\n-    @Parameter({\"false\", \"true\"})\n-    public void test(boolean signAppImage, boolean signingKey) throws Exception {\n-        MacSign.withKeychain(toConsumer(keychain -> {\n-            test(keychain, signAppImage, signingKey);\n-        }), SigningBase.StandardKeychain.MAIN.keychain());\n-    }\n-\n-    private void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n-\n-        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n-\n-        \/\/ Generate app image. Signed or unsigned based on test\n-        \/\/ parameter. We should able to sign predfined app images\n-        \/\/ which are signed or unsigned.\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n-        if (signAppImage) {\n-            appImageCmd.addArguments(\"--mac-sign\",\n-                    \"--mac-signing-keychain\", keychain.name());\n-            if (signingKey) {\n-                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n-                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-            } else {\n-                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n-                    SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n-            }\n-        }\n-\n-        \/\/ Generate app image\n-        appImageCmd.executeAndAssertHelloAppImageCreated();\n-\n-        \/\/ Double check if it is signed or unsigned based on signAppImage\n-        SigningBase.verifyAppImageSignature(appImageCmd, signAppImage);\n-\n-        \/\/ Sign app image\n-        JPackageCommand appImageSignedCmd = new JPackageCommand();\n-        appImageSignedCmd.setPackageType(PackageType.IMAGE)\n-            .addArguments(\"--app-image\", appImageCmd.outputBundle().toAbsolutePath())\n-            .addArguments(\"--mac-sign\")\n-            .addArguments(\"--mac-signing-keychain\", keychain.name());\n-        if (signingKey) {\n-            appImageSignedCmd.addArguments(\"--mac-signing-key-user-name\",\n-                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-        } else {\n-            appImageSignedCmd.addArguments(\"--mac-app-image-sign-identity\",\n-                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n-        }\n-        appImageSignedCmd.executeAndAssertImageCreated();\n-\n-        \/\/ Should be signed app image\n-        SigningBase.verifyAppImageSignature(appImageCmd, true);\n-\n-        new PackageTest()\n-                .forTypes(PackageType.MAC)\n-                .addInitializer(cmd -> {\n-                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    cmd.removeArgumentWithValue(\"--input\");\n-                    if (signAppImage) {\n-                        cmd.addArguments(\"--mac-sign\",\n-                                \"--mac-signing-keychain\",\n-                                keychain.name());\n-                        if (signingKey) {\n-                           cmd.addArguments(\"--mac-signing-key-user-name\",\n-                               SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-                        } else {\n-                            cmd.addArguments(\"--mac-installer-sign-identity\",\n-                                SigningBase.getInstallerCert(SigningBase.DEFAULT_INDEX));\n-                        }\n-                    }\n-                })\n-                .forTypes(PackageType.MAC_PKG)\n-                .addBundleVerifier(\n-                    SigningPackageFromTwoStepAppImageTest::verifyPKG)\n-                .forTypes(PackageType.MAC_DMG)\n-                .addInitializer(cmd -> {\n-                    if (signAppImage && !signingKey) {\n-                        \/\/ jpackage throws expected error with\n-                        \/\/ --mac-installer-sign-identity and DMG type\n-                        cmd.removeArgument(\"--mac-sign\");\n-                        cmd.removeArgumentWithValue(\"--mac-signing-keychain\");\n-                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n-                    }\n-                })\n-                .addBundleVerifier(\n-                    SigningPackageFromTwoStepAppImageTest::verifyDMG)\n-                .addBundleVerifier(\n-                    SigningPackageFromTwoStepAppImageTest::verifyAppImageInDMG)\n-                .run();\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -69,0 +69,1 @@\n+ * @requires (jpackage.test.SQETest == null)\n@@ -201,1 +202,1 @@\n-            }).addInitializer(cmd -> {\n+            }).usePredefinedAppImage(appImageCmd).addInitializer(cmd -> {\n@@ -203,2 +204,0 @@\n-                cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                cmd.removeArgumentWithValue(\"--input\");\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.IOException;\n@@ -32,1 +31,0 @@\n-import jdk.jpackage.test.Executor;\n@@ -37,2 +35,0 @@\n-import jdk.jpackage.test.PackageType;\n-import jdk.jpackage.test.TKit;\n@@ -83,0 +79,1 @@\n+ * @requires (jpackage.test.SQETest == null)\n@@ -99,28 +96,3 @@\n-    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) throws IOException {\n-\n-        final var runtimeImage = JPackageCommand.createInputRuntimeImage();\n-\n-        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n-\n-        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n-\n-        var cmd = new JPackageCommand()\n-                .useToolProvider(true)\n-                .ignoreDefaultRuntime(true)\n-                .dumpOutput(true)\n-                .setPackageType(PackageType.MAC_DMG)\n-                .setArgumentValue(\"--name\", \"foo\")\n-                .addArguments(\"--runtime-image\", runtimeImage)\n-                .addArguments(\"--dest\", runtimeBundleWorkDir);\n-\n-        addSignOptions(cmd, keychain, certIndex);\n-\n-        cmd.execute();\n-\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n-                Executor.of(\"cp\", \"-R\")\n-                        .addArgument(dmgImage)\n-                        .addArgument(unpackadeRuntimeBundleDir)\n-                        .execute(0);\n-            }\n+    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) {\n+        return MacHelper.createRuntimeBundle(cmd -> {\n+            addSignOptions(cmd, keychain, certIndex);\n@@ -128,2 +100,0 @@\n-\n-        return unpackadeRuntimeBundleDir;\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":4,"deletions":34,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+        CODESIGN_ACME_TECH_LTD(cert().days(100).userName(\"ACME Technologies Limited (ABC12345)\")),\n@@ -104,1 +105,2 @@\n-                StandardCertificateRequest.PKG_UNICODE),\n+                StandardCertificateRequest.PKG_UNICODE,\n+                StandardCertificateRequest.CODESIGN_ACME_TECH_LTD),\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,3 @@\n-        Path[] predefinedAppImage = new Path[1];\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--name\", \"foo\")\n+                .setFakeRuntime();\n@@ -201,12 +203,5 @@\n-        new PackageTest().addRunOnceInitializer(() -> {\n-            var cmd = JPackageCommand.helloAppImage()\n-                    .setArgumentValue(\"--name\", \"foo\")\n-                    .setFakeRuntime();\n-\n-            for (var i = 1; i != cfgs.length; ++i) {\n-                var al = new AdditionalLauncher(\"launcher-\" + i);\n-                cfgs[i].applyToAdditionalLauncher(al);\n-                al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(cmd);\n-            }\n-\n-            cmd.execute();\n+        for (var i = 1; i != cfgs.length; ++i) {\n+            var al = new AdditionalLauncher(\"launcher-\" + i);\n+            cfgs[i].applyToAdditionalLauncher(al);\n+            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(appImageCmd);\n+        }\n@@ -214,2 +209,4 @@\n-            predefinedAppImage[0] = cmd.outputBundle();\n-        }).addInitializer(cmd -> {\n+        new PackageTest()\n+        .addRunOnceInitializer(appImageCmd::execute)\n+        .usePredefinedAppImage(appImageCmd)\n+        .addInitializer(cmd -> {\n@@ -217,1 +214,0 @@\n-            cmd.removeArgumentWithValue(\"--input\");\n@@ -219,1 +215,0 @@\n-            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n@@ -240,6 +235,3 @@\n-        Path[] predefinedAppImage = new Path[1];\n-\n-        new PackageTest().addRunOnceInitializer(() -> {\n-            var cmd = JPackageCommand.helloAppImage()\n-                    .setArgumentValue(\"--name\", \"foo\")\n-                    .setFakeRuntime();\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--name\", \"foo\")\n+                .setFakeRuntime();\n@@ -247,5 +239,4 @@\n-            cmd.execute();\n-\n-            predefinedAppImage[0] = cmd.outputBundle();\n-        }).addInitializer(cmd -> {\n-            cmd.removeArgumentWithValue(\"--input\");\n+        new PackageTest()\n+        .addRunOnceInitializer(appImageCmd::execute)\n+        .usePredefinedAppImage(appImageCmd)\n+        .addInitializer(cmd -> {\n@@ -253,1 +244,0 @@\n-            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-                \/\/ Should not have impact of launcher descriptions, but it does.\n+                \/\/ Should not have impact on launcher descriptions, but it does.\n@@ -280,2 +280,1 @@\n-                cmd.removeArgumentWithValue(\"--input\").setArgumentValue(\"--app-image\", target.cmd().orElseThrow().outputBundle());\n-            }).mutate(addLinuxShortcuts()).run(Action.CREATE_AND_UNPACK);\n+            }).usePredefinedAppImage(target.cmd().orElseThrow()).mutate(addLinuxShortcuts()).run(Action.CREATE_AND_UNPACK);\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -502,1 +502,1 @@\n-            for (var textFile : Map.ofEntries(\n+            for (var textFile : List.of(\n@@ -506,1 +506,1 @@\n-            ).entrySet()) {\n+            )) {\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,2 +65,1 @@\n-        var appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n+        final var appImageCmd = createAppImageCommand();\n@@ -70,4 +69,2 @@\n-        .addInitializer(cmd -> {\n-            cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-            cmd.removeArgumentWithValue(\"--input\");\n-        }).addBundleDesktopIntegrationVerifier(false).run();\n+        .usePredefinedAppImage(appImageCmd)\n+        .addBundleDesktopIntegrationVerifier(false).run();\n@@ -88,4 +85,1 @@\n-        var appImageCmd = JPackageCommand.helloAppImage()\n-                .setFakeRuntime()\n-                .setArgumentValue(\"--name\", \"EmptyAppImagePackageTest\")\n-                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n+        final var appImageCmd = createAppImageCommand();\n@@ -119,0 +113,1 @@\n+        .usePredefinedAppImage(appImageCmd)\n@@ -120,1 +115,0 @@\n-            cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n@@ -122,1 +116,1 @@\n-                cmd.addArguments(\"--icon\", iconPath(\"icon\"));\n+                cmd.setArgumentValue(\"--icon\", iconPath(\"icon\"));\n@@ -124,1 +118,0 @@\n-            cmd.removeArgumentWithValue(\"--input\");\n@@ -163,1 +156,0 @@\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\");\n@@ -165,2 +157,1 @@\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage().\n-                setFakeRuntime().setArgumentValue(\"--dest\", appImageDir);\n+        final var appImageCmd = createAppImageCommand();\n@@ -179,1 +170,0 @@\n-        final var appImageRoot = TKit.createTempDirectory(\"appimage\");\n@@ -181,2 +171,1 @@\n-        final var appImageCmd = JPackageCommand.helloAppImage().\n-                setFakeRuntime().setArgumentValue(\"--dest\", appImageRoot);\n+        final var appImageCmd = createAppImageCommand();\n@@ -205,2 +194,1 @@\n-            cmd.addArguments(\"--app-image\", appImageDir);\n-            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.usePredefinedAppImage(appImageDir);\n@@ -212,0 +200,5 @@\n+    private static JPackageCommand createAppImageCommand() {\n+        final var appImageRoot = TKit.createTempDirectory(\"appimage\");\n+        return JPackageCommand.helloAppImage().setFakeRuntime().setArgumentValue(\"--dest\", appImageRoot);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.TKit.TextStreamVerifier;\n@@ -116,1 +114,1 @@\n-    record DmgTestSpec(Path installDir, boolean runtimeInstaller) {\n+    record TestSpec(Path installDir, boolean runtimeInstaller) {\n@@ -118,1 +116,1 @@\n-        DmgTestSpec {\n+        TestSpec {\n@@ -138,2 +136,2 @@\n-            DmgTestSpec create() {\n-                return new DmgTestSpec(installDir, runtimeInstaller);\n+            TestSpec create() {\n+                return new TestSpec(installDir, runtimeInstaller);\n@@ -157,1 +155,1 @@\n-            final var test = new PackageTest().forTypes(PackageType.MAC_DMG).ignoreBundleOutputDir();\n+            final var test = new PackageTest().ignoreBundleOutputDir();\n@@ -167,1 +165,1 @@\n-                cmd.addArguments(\"--install-dir\", installDir);\n+                cmd.setArgumentValue(\"--install-dir\", installDir);\n@@ -174,1 +172,1 @@\n-    public static void testDmg(DmgTestSpec testSpec) {\n+    public static void testMac(TestSpec testSpec) {\n@@ -178,1 +176,1 @@\n-    public static List<Object[]> testDmg() {\n+    public static List<Object[]> testMac() {\n@@ -180,4 +178,4 @@\n-                DmgTestSpec.build().acceptedInstallDir(\"\/foo\"),\n-                DmgTestSpec.build().acceptedInstallDir(\"\/foo\/bar\"),\n-                DmgTestSpec.build().acceptedInstallDir(\"\/foo\").runtimeInstaller(),\n-                DmgTestSpec.build().acceptedInstallDir(\"\/foo\/bar\").runtimeInstaller(),\n+                TestSpec.build().acceptedInstallDir(\"\/foo\"),\n+                TestSpec.build().acceptedInstallDir(\"\/foo\/bar\"),\n+                TestSpec.build().acceptedInstallDir(\"\/foo\").runtimeInstaller(),\n+                TestSpec.build().acceptedInstallDir(\"\/foo\/bar\").runtimeInstaller(),\n@@ -185,2 +183,2 @@\n-                DmgTestSpec.build().acceptedInstallDir(\"\/Library\/Java\/JavaVirtualMachines\"),\n-                DmgTestSpec.build().acceptedInstallDir(\"\/Applications\").runtimeInstaller(),\n+                TestSpec.build().acceptedInstallDir(\"\/Library\/Java\/JavaVirtualMachines\"),\n+                TestSpec.build().acceptedInstallDir(\"\/Applications\").runtimeInstaller(),\n@@ -188,2 +186,2 @@\n-                DmgTestSpec.build().acceptedInstallDir(\"\/Applications\"),\n-                DmgTestSpec.build().acceptedInstallDir(\"\/Applications\/foo\/bar\/buz\"),\n+                TestSpec.build().acceptedInstallDir(\"\/Applications\"),\n+                TestSpec.build().acceptedInstallDir(\"\/Applications\/foo\/bar\/buz\"),\n@@ -191,3 +189,3 @@\n-                DmgTestSpec.build().runtimeInstaller().acceptedInstallDir(\"\/Library\/Java\/JavaVirtualMachines\"),\n-                DmgTestSpec.build().runtimeInstaller().acceptedInstallDir(\"\/Library\/Java\/JavaVirtualMachines\/foo\/bar\/buz\")\n-        ).map(DmgTestSpec.Builder::create).map(testSpec -> {\n+                TestSpec.build().runtimeInstaller().acceptedInstallDir(\"\/Library\/Java\/JavaVirtualMachines\"),\n+                TestSpec.build().runtimeInstaller().acceptedInstallDir(\"\/Library\/Java\/JavaVirtualMachines\/foo\/bar\/buz\")\n+        ).map(TestSpec.Builder::create).map(testSpec -> {\n","filename":"test\/jdk\/tools\/jpackage\/share\/InstallDirTest.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.IOException;\n@@ -27,0 +26,2 @@\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -30,2 +31,0 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.JPackageCommand;\n@@ -58,1 +57,1 @@\n-    public static void test() throws IOException {\n+    public static void test() {\n@@ -71,1 +70,1 @@\n-                .addRunOnceInitializer(() -> appImageCmd.execute())\n+                .addRunOnceInitializer(appImageCmd::execute)\n@@ -73,4 +72,1 @@\n-                .addInitializer(cmd -> {\n-                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    cmd.removeArgumentWithValue(\"--input\");\n-                })\n+                .usePredefinedAppImage(appImageCmd)\n","filename":"test\/jdk\/tools\/jpackage\/share\/MultiLauncherTwoPhaseTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n-import java.io.IOException;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -29,3 +31,0 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.JPackageCommand;\n@@ -61,3 +60,1 @@\n-    public static void test(String... testArgs) throws IOException {\n-        String appName = testArgs[0];\n-        String installName = testArgs[1];\n+    public static void test(String appName, String installName) {\n@@ -77,0 +74,1 @@\n+                .usePredefinedAppImage(appImageCmd)\n@@ -78,2 +76,0 @@\n-                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    cmd.removeArgumentWithValue(\"--input\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/MultiNameTwoPhaseTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -110,4 +110,1 @@\n-                    test.addInitializer(cmd -> {\n-                        cmd.removeArgumentWithValue(\"--input\");\n-                        cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    });\n+                    test.usePredefinedAppImage(appImageCmd);\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n- * @key jpackagePlatformPackage\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimeImageSymbolicLinksTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @key jpackagePlatformPackage\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimeImageTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.IOException;\n@@ -37,1 +36,0 @@\n-import jdk.jpackage.test.Executor;\n@@ -39,1 +37,0 @@\n-import jdk.jpackage.test.JavaTool;\n@@ -92,1 +89,1 @@\n-        init(RuntimePackageTest::createInputRuntimeBundle).run();\n+        init(MacHelper::createRuntimeBundle).run();\n@@ -117,1 +114,1 @@\n-        return init(RuntimePackageTest::createInputRuntimeImage);\n+        return init(JPackageCommand::createInputRuntimeImage);\n@@ -171,54 +168,0 @@\n-\n-    private static Path createInputRuntimeImage() throws IOException {\n-\n-        final Path runtimeImageDir;\n-\n-        if (JPackageCommand.DEFAULT_RUNTIME_IMAGE != null) {\n-            runtimeImageDir = JPackageCommand.DEFAULT_RUNTIME_IMAGE;\n-        } else {\n-            runtimeImageDir = TKit.createTempDirectory(\"runtime-image\").resolve(\"data\");\n-\n-            new Executor().setToolProvider(JavaTool.JLINK)\n-                    .dumpOutput()\n-                    .addArguments(\n-                            \"--output\", runtimeImageDir.toString(),\n-                            \"--add-modules\", \"java.desktop\",\n-                            \"--strip-debug\",\n-                            \"--no-header-files\",\n-                            \"--no-man-pages\")\n-                    .execute();\n-        }\n-\n-        return runtimeImageDir;\n-    }\n-\n-    private static Path createInputRuntimeBundle() throws IOException {\n-\n-        final var runtimeImage = createInputRuntimeImage();\n-\n-        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n-\n-        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n-\n-        var cmd = new JPackageCommand()\n-                .useToolProvider(true)\n-                .ignoreDefaultRuntime(true)\n-                .dumpOutput(true)\n-                .setPackageType(PackageType.MAC_DMG)\n-                .setArgumentValue(\"--name\", \"foo\")\n-                .addArguments(\"--runtime-image\", runtimeImage)\n-                .addArguments(\"--dest\", runtimeBundleWorkDir);\n-\n-        cmd.execute();\n-\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n-                Executor.of(\"cp\", \"-R\")\n-                        .addArgument(dmgImage)\n-                        .addArgument(unpackadeRuntimeBundleDir)\n-                        .execute(0);\n-            }\n-        });\n-\n-        return unpackadeRuntimeBundleDir;\n-    }\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":2,"deletions":59,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import static jdk.jpackage.test.PackageType.MAC_DMG;\n+import static jdk.jpackage.test.PackageType.WINDOWS;\n+\n@@ -25,0 +28,1 @@\n+import java.io.UncheckedIOException;\n@@ -27,0 +31,1 @@\n+import java.util.HexFormat;\n@@ -28,0 +33,1 @@\n+import java.util.function.Consumer;\n@@ -29,1 +35,2 @@\n-import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -31,0 +38,1 @@\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -34,2 +42,2 @@\n-import static jdk.jpackage.test.PackageType.MAC_DMG;\n-import static jdk.jpackage.test.PackageType.WINDOWS;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n+import jdk.jpackage.test.PackageTest;\n@@ -50,0 +58,14 @@\n+ * @requires (jpackage.test.SQETest != null)\n+ * @compile -Xlint:all -Werror ServiceTest.java\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=ServiceTest.test,ServiceTest.testUpdate\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Launcher as service packaging test\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @key jpackagePlatformPackage\n+ * @requires (jpackage.test.SQETest == null)\n@@ -51,1 +73,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n@@ -55,0 +77,1 @@\n+\n@@ -89,1 +112,0 @@\n-        var testInitializer = createTestInitializer();\n@@ -92,1 +114,1 @@\n-        testInitializer.applyTo(pkg);\n+        createTestInitializer().applyTo(pkg);\n@@ -135,0 +157,99 @@\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testAddL(boolean mainLauncherAsService) {\n+\n+        final var uniqueOutputFile = uniqueOutputFile();\n+\n+        createPackageTest()\n+                .addHelloAppInitializer(\"com.buz.AddLaunchersServiceTest\")\n+                .mutate(test -> {\n+                    if (mainLauncherAsService) {\n+                        LauncherAsServiceVerifier.build()\n+                                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-\")\n+                                .setExpectedValue(\"Main\").applyTo(test);\n+                    }\n+                })\n+                \/\/ Regular launcher. The installer should not automatically execute it.\n+                .mutate(new AdditionalLauncher(\"notservice\")\n+                        .withoutVerifyActions(Action.EXECUTE_LAUNCHER)\n+                        .setProperty(\"launcher-as-service\", Boolean.FALSE)\n+                        .addJavaOptions(\"-Djpackage.test.noexit=true\")::applyTo)\n+                \/\/ Additional launcher with explicit \"launcher-as-service=true\" property in the property file.\n+                .mutate(LauncherAsServiceVerifier.build()\n+                        .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A1-\")\n+                        .setLauncherName(\"AL1\")\n+                        .setExpectedValue(\"AL1\")::applyTo)\n+                .mutate(test -> {\n+                    if (mainLauncherAsService) {\n+                        \/\/ Additional launcher without \"launcher-as-service\" property in the property file.\n+                        \/\/ Still, should be installed as a service.\n+                        LauncherAsServiceVerifier.build()\n+                                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A2-\")\n+                                .setLauncherName(\"AL2\")\n+                                .setExpectedValue(\"AL2\")\n+                                .setAdditionalLauncherCallback(al -> {\n+                                    al.removeProperty(\"launcher-as-service\");\n+                                })\n+                                .applyTo(test);\n+                    }\n+                })\n+                .mutate(createTestInitializer()::applyTo)\n+                .run();\n+        }\n+\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testAddLFromAppImage(boolean mainLauncherAsService) {\n+\n+        var uniqueOutputFile = uniqueOutputFile();\n+\n+        var appImageCmd = new ConfigurationTarget(JPackageCommand.helloAppImage(\"com.bar.AddLaunchersFromAppImageServiceTest\"));\n+\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and we want to verify launchers are automatically started by the installer.\n+            appImageCmd.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+\n+        if (mainLauncherAsService) {\n+            LauncherAsServiceVerifier.build()\n+                    .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-\")\n+                    .setExpectedValue(\"Main\")\n+                    .applyTo(appImageCmd);\n+            \/\/ Can not use \"--launcher-as-service\" option with app image packaging.\n+            appImageCmd.cmd().orElseThrow().removeArgument(\"--launcher-as-service\");\n+        } else {\n+            appImageCmd.addInitializer(cmd -> {\n+                \/\/ Configure the main launcher to hang at the end of the execution.\n+                \/\/ The main launcher should not be executed in this test.\n+                \/\/ If it is executed, it indicates it was started as a service,\n+                \/\/ which must fail the test. The launcher's hang-up will be the event failing the test.\n+                cmd.addArguments(\"--java-options\", \"-Djpackage.test.noexit=true\");\n+            });\n+        }\n+\n+        \/\/ Additional launcher with explicit \"launcher-as-service=true\" property in the property file.\n+        LauncherAsServiceVerifier.build()\n+                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A1-\")\n+                .setLauncherName(\"AL1\")\n+                .setExpectedValue(\"AL1\").applyTo(appImageCmd);\n+\n+        \/\/ Regular launcher. The installer should not automatically execute it.\n+        appImageCmd.add(new AdditionalLauncher(\"notservice\")\n+                .withoutVerifyActions(Action.EXECUTE_LAUNCHER)\n+                .addJavaOptions(\"-Djpackage.test.noexit=true\"));\n+\n+        new PackageTest().excludeTypes(MAC_DMG)\n+                .addRunOnceInitializer(appImageCmd.cmd().orElseThrow()::execute)\n+                .usePredefinedAppImage(appImageCmd.cmd().orElseThrow())\n+                .addInitializer(cmd -> {\n+                    if (mainLauncherAsService) {\n+                        cmd.addArgument(\"--launcher-as-service\");\n+                    }\n+                })\n+                .mutate(createTestInitializer()::applyTo)\n+                .run();\n+    }\n+\n@@ -142,1 +263,1 @@\n-        void applyTo(PackageTest test) throws IOException {\n+        void applyTo(PackageTest test) {\n@@ -145,2 +266,5 @@\n-                Files.copy(winServiceInstaller, resourceDir.resolve(\n-                        \"service-installer.exe\"));\n+                try {\n+                    Files.copy(winServiceInstaller, resourceDir.resolve(\"service-installer.exe\"));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n@@ -168,1 +292,1 @@\n-        return new PackageTest()\n+        var test = new PackageTest()\n@@ -171,0 +295,19 @@\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and we want to verify launchers are automatically started by the installer.\n+            test.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+        return test;\n+    }\n+\n+    private static Consumer<LauncherAsServiceVerifier.Builder> uniqueOutputFile() {\n+        var prefix = uniquePrefix();\n+        return builder -> {\n+            builder.setAppOutputFileNamePrefixToAppName()\n+                    .appendAppOutputFileNamePrefix(\"-\")\n+                    .appendAppOutputFileNamePrefix(prefix);\n+        };\n+    }\n+\n+    private static String uniquePrefix() {\n+        return HexFormat.of().toHexDigits(System.currentTimeMillis());\n","filename":"test\/jdk\/tools\/jpackage\/share\/ServiceTest.java","additions":153,"deletions":10,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.JPackageCommand;\n+import java.util.List;\n+import java.util.stream.Stream;\n@@ -30,0 +30,2 @@\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.PackageTest;\n@@ -51,1 +53,1 @@\n-    public void test() throws IOException {\n+    public void test() {\n@@ -57,1 +59,1 @@\n-        String[] filesWithDollarCharsInNames = new String[]{\n+        var filesWithDollarCharsInNames = Stream.of(\n@@ -66,1 +68,1 @@\n-        };\n+        ).map(Path::of).toList();\n@@ -68,3 +70,3 @@\n-        String[] dirsWithDollarCharsInNames = new String[]{\n-            Path.of(\"foo\", String.join(\"\/\", filesWithDollarCharsInNames)).toString()\n-        };\n+        var dirsWithDollarCharsInNames = List.of(\n+                filesWithDollarCharsInNames.stream().reduce(Path.of(\"foo\"), Path::resolve)\n+        );\n@@ -78,1 +80,1 @@\n-                        createImageFile(appImageCmd, Path.of(path));\n+                        createImageFile(appImageCmd, path);\n@@ -86,0 +88,1 @@\n+                .usePredefinedAppImage(appImageCmd)\n@@ -88,2 +91,0 @@\n-                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    cmd.removeArgumentWithValue(\"--input\");\n@@ -95,1 +96,1 @@\n-                        verifyImageFile(appImageCmd, Path.of(path));\n+                        verifyImageFile(appImageCmd, path);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8282351Test.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n- * @key jpackagePlatformPackage\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinInstallerResourceTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n- * @key jpackagePlatformPackage\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongPathTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,13 +69,0 @@\n-\/*\n- * @test\n- * @summary jpackage with long version number\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @key jpackagePlatformPackage\n- * @requires (jpackage.test.SQETest != null)\n- * @build jdk.jpackage.test.*\n- * @requires (os.family == \"windows\")\n- * @compile -Xlint:all -Werror WinLongVersionTest.java\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=WinLongVersionTest.test\n- *\/\n-\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongVersionTest.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @key jpackagePlatformPackage\n@@ -41,1 +40,0 @@\n- * @requires (jpackage.test.SQETest == null)\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinOSConditionTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n- * @key jpackagePlatformPackage\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinRenameTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @bug 6994753 7123582 8305950 8281658 8310201 8311653 8343804 8351354\n+ * @bug 6994753 7123582 8305950 8281658 8310201 8311653 8343804 8351354 8366364\n@@ -87,0 +87,2 @@\n+    private static final String ENABLED_SIG_SCHEMES_SETTINGS =\n+            \"Enabled Signature Schemes:\";\n@@ -110,0 +112,1 @@\n+        checkContains(tr, ENABLED_SIG_SCHEMES_SETTINGS);\n@@ -240,0 +243,1 @@\n+        checkContains(tr, ENABLED_SIG_SCHEMES_SETTINGS);\n","filename":"test\/jdk\/tools\/launcher\/Settings.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,8 +1,24 @@\n-# Requires javadoc\n-jdk\/javadoc\/tool\/6964914\/TestStdDoclet.java                                8346719 generic-all\n-jdk\/javadoc\/tool\/6964914\/TestUserDoclet.java                               8346719 generic-all\n-jdk\/javadoc\/tool\/AddOpensTest.java                                         8346719 generic-all\n-jdk\/javadoc\/tool\/EncodingTest.java                                         8346719 generic-all\n-jdk\/javadoc\/tool\/EnsureNewOldDoclet.java                                   8346719 generic-all\n-jdk\/javadoc\/tool\/QuietOption.java                                          8346719 generic-all\n-jdk\/javadoc\/tool\/testLocaleOption\/TestLocaleOption.java                    8346719 generic-all\n+###########################################################################\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+###########################################################################\n@@ -10,20 +26,1 @@\n-# Requires javac\n-tools\/javac\/ClassPathTest\/ClassPathTest.java                               8346719 generic-all\n-tools\/javac\/Paths\/ClassPath.java                                           8346719 generic-all\n-tools\/javac\/Paths\/WildcardMineField.java                                   8346719 generic-all\n-tools\/javac\/T8132562\/ClassPathWithDoubleQuotesTest.java                    8346719 generic-all\n-tools\/javac\/file\/MultiReleaseJar\/MultiReleaseJarTest.java                  8346719 generic-all\n-tools\/javac\/modules\/AllDefaultTest.java                                    8346719 generic-all\n-tools\/javac\/modules\/EnvVarTest.java                                        8346719 generic-all\n-tools\/javac\/modules\/InheritRuntimeEnvironmentTest.java                     8346719 generic-all\n-tools\/javac\/modules\/NPEEmptyFileTest.java                                  8346719 generic-all\n-tools\/javac\/newlines\/NewLineTest.java                                      8346719 generic-all\n-tools\/javac\/options\/smokeTests\/OptionSmokeTest.java                        8346719 generic-all\n-tools\/javac\/platform\/PlatformProviderTest.java                             8346719 generic-all\n-tools\/javac\/processing\/options\/testPrintProcessorInfo\/TestWithXstdout.java 8346719 generic-all\n-\n-# Requires jar\n-tools\/jdeps\/MultiReleaseJar.java                                           8346719 generic-all\n-\n-# Requires jimage\n-tools\/javac\/Paths\/MineField.java                                           8346719 generic-all\n+# Currently empty\n","filename":"test\/langtools\/ProblemList-StaticJdk.txt","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8198801 8212167 8210527\n+ * @bug 8198801 8212167 8210527 8370175\n@@ -323,0 +323,10 @@\n+    @Test\n+    public void recursiveCauses() {\n+        assertEval(\"var one = new Throwable();\");\n+        assertEval(\"var two = new Error();\");\n+        assertEval(\"one.initCause(two);\");\n+        assertEval(\"two.initCause(one);\");\n+        assertExecuteException(\"throw one;\", Throwable.class);\n+        assertExecuteException(\"throw two;\", Error.class);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-CrashInAnnotateTest.java:11:37: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:11:12: compiler.err.proc.messager: annotations not allowed\n@@ -4,4 +4,4 @@\n-CrashInAnnotateTest.java:21:23: compiler.err.proc.messager: syntax error in reference\n-CrashInAnnotateTest.java:24:54: compiler.err.proc.messager: syntax error in reference\n-CrashInAnnotateTest.java:25:37: compiler.err.proc.messager: syntax error in reference\n-6 errors\n\\ No newline at end of file\n+CrashInAnnotateTest.java:21:12: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:24:12: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:25:12: compiler.err.proc.messager: annotations not allowed\n+6 errors\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,21 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8370237\n+ * @summary AssertionError in Annotate.fromAnnotations with -Xdoclint and type annotations\n+ * @compile\/fail\/ref=CrashInTypeAnnotateTest.out -Xdoclint:all,-missing -XDrawDiagnostics CrashInTypeAnnotateTest.java\n+ *\/\n+\n+import java.util.List;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target(ElementType.TYPE_PARAMETER)\n+@Retention(RetentionPolicy.RUNTIME)\n+@interface A {}\n+\n+\/** {@link List<@A String>}\n+ *\/\n+class CrashInTypeAnnotateTest {\n+}\n","filename":"test\/langtools\/tools\/doclint\/CrashInTypeAnnotateTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CrashInTypeAnnotateTest.java:18:17: compiler.err.proc.messager: annotations not allowed\n+1 error\n","filename":"test\/langtools\/tools\/doclint\/CrashInTypeAnnotateTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8370865\n+ * @summary Check that multiple comma-separated fields work\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main MultipleFields\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class MultipleFields extends TestRunner {\n+\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new MultipleFields().runTests();\n+    }\n+\n+    MultipleFields() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testWithExplicitImport(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     int f1, f2;\n+\n+                     public void main() {\n+                         f1 = 1;\n+                         f2 = f1 + 1;\n+                         System.out.println(\"field: \" + f1 + \"\/\" + f2);\n+                     }\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        var out = new JavaTask(tb)\n+                .classpath(classes.toString())\n+                .className(\"Test\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        var expectedOut = List.of(\"field: 1\/2\");\n+\n+        if (!Objects.equals(expectedOut, out)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/MultipleFields.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8369489\n+ * @summary Verify annotations on member references work reasonably.\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run junit TypeAnnosOnMemberReferenceTest\n+ *\/\n+\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreeScanner;\n+import com.sun.source.util.Trees;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.ElementFilter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class TypeAnnosOnMemberReferenceTest {\n+    private ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testAnnoOnMemberRef() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                import java.lang.annotation.Target;\n+                import java.lang.annotation.ElementType;\n+                import java.lang.annotation.Retention;\n+                import java.lang.annotation.RetentionPolicy;\n+\n+                public class Test {\n+                    interface I {\n+                        void foo(int i);\n+                    }\n+\n+                    @Target(ElementType.TYPE_USE)\n+                    @interface Ann1 {}\n+                    @Target(ElementType.TYPE_USE)\n+                    @interface Ann2 {}\n+                    I i = @Ann1 Test @Ann2 []::new;\n+                }\n+                \"\"\");\n+\n+        Path classDir = getClassDir();\n+        new JavacTask(tb)\n+                .classpath(classDir)\n+                .outdir(classes)\n+                .options(\"-processor\", VerifyAnnotations.class.getName())\n+                .files(tb.findJavaFiles(src))\n+                .outdir(classes)\n+                .run(Task.Expect.SUCCESS);\n+    }\n+\n+    public Path getClassDir() {\n+        String classes = ToolBox.testClasses;\n+        if (classes == null) {\n+            return Paths.get(\"build\");\n+        } else {\n+            return Paths.get(classes);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class VerifyAnnotations extends AbstractProcessor {\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            TypeElement testElement = processingEnv.getElementUtils().getTypeElement(\"Test\");\n+            VariableElement iElement = ElementFilter.fieldsIn(testElement.getEnclosedElements()).getFirst();\n+            Trees trees = Trees.instance(processingEnv);\n+            TreePath iPath = trees.getPath(iElement);\n+            StringBuilder text = new StringBuilder();\n+            new TreeScanner<>() {\n+                int ident = 0;\n+                @Override\n+                public Object scan(Tree tree, Object p) {\n+                    if (tree != null) {\n+                        String indent =\n+                                Stream.generate(() -> \" \")\n+                                      .limit(ident)\n+                                      .collect(Collectors.joining());\n+\n+                        text.append(\"\\n\")\n+                            .append(indent)\n+                            .append(\"(\")\n+                            .append(tree.getKind());\n+                        ident += 4;\n+                        super.scan(tree, p);\n+                        ident -= 4;\n+                        text.append(\"\\n\")\n+                            .append(indent)\n+                            .append(\")\");\n+                    }\n+                    return null;\n+                }\n+\n+                @Override\n+                public Object visitIdentifier(IdentifierTree node, Object p) {\n+                    text.append(\" \").append(node.getName());\n+                    return super.visitIdentifier(node, p);\n+                }\n+            }.scan(((VariableTree) iPath.getLeaf()).getInitializer(), null);\n+            String expected =\n+                    \"\"\"\n+\n+                    (MEMBER_REFERENCE\n+                        (ANNOTATED_TYPE\n+                            (TYPE_ANNOTATION\n+                                (IDENTIFIER Ann2\n+                                )\n+                            )\n+                            (ARRAY_TYPE\n+                                (ANNOTATED_TYPE\n+                                    (TYPE_ANNOTATION\n+                                        (IDENTIFIER Ann1\n+                                        )\n+                                    )\n+                                    (IDENTIFIER Test\n+                                    )\n+                                )\n+                            )\n+                        )\n+                    )\"\"\";\n+\n+            String actual = text.toString();\n+\n+            if (!expected.equals(actual)) {\n+                throw new AssertionError(\"Expected: \" + expected + \",\" +\n+                                         \"got: \" + actual);\n+            }\n+\n+            return false;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/TypeAnnosOnMemberReferenceTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859 8344706 8351260\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859 8344706 8351260 8370865 8369489\n@@ -3079,0 +3079,75 @@\n+    @Test \/\/JDK-8370865\n+    void testCompactSourceFileMultiField1() throws IOException {\n+        String code = \"\"\"\n+                      int i, j, k;\n+                      void main() {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"-XDrawDiagnostics\"),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        \/\/no exceptions:\n+        ct.parse().iterator().next();\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testCompactSourceFileMultiField1: \" + codes,\n+                     List.of(),\n+                     codes);\n+    }\n+\n+    @Test \/\/JDK-8370865\n+    void testCompactSourceFileMultiField2() throws IOException {\n+        String code = \"\"\"\n+                      int i, j = 0, k = 0;\n+                      void main() {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"-XDrawDiagnostics\"),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        \/\/no exceptions:\n+        ct.parse().iterator().next();\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testCompactSourceFileMultiField2: \" + codes,\n+                     List.of(),\n+                     codes);\n+    }\n+\n+    @Test \/\/JDK-8369489\n+    void testTypeAnnotationBrokenMethodRef() throws IOException {\n+        String code = \"\"\"\n+                      public class Test {\n+                          Object o1 = @Ann any()::test;\n+                          Object o2 = @Ann any().field::test;\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                null,\n+                null, Arrays.asList(new MyFileObject(code)));\n+        \/\/no exceptions:\n+        ct.parse().iterator().next();\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testTypeAnnotationBrokenMethodRef: \" + codes,\n+                     List.of(\"2:22:compiler.err.illegal.start.of.type\",\n+                             \"3:22:compiler.err.illegal.start.of.type\"),\n+                     codes);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230 8338678 8351260\n+ * @bug 8301580 8322159 8333107 8332230 8338678 8351260 8366196\n@@ -343,0 +343,54 @@\n+\n+\n+    @Test \/\/JDK-8366196\n+    public void testInferenceFailure() throws Exception {\n+        String code = \"\"\"\n+                      import module java.base;\n+                      public class Test {\n+                          public void test(Consumer<String> c) {\n+                            List.of(\"\")\n+                                .stream()\n+                                .filter(\n+                                    buildPredicate(\n+                                        String.class,\n+                                        \/\/missing supplier\n+                                        c,\n+                                        buildSupplier(\n+                                            \/\/ Missing: Class,\n+                                            Integer.class,\n+                                            String.class,\n+                                            i -> { int check; return i; })));\n+                          }\n+\n+                          private static <T> Predicate<T> buildPredicate(\n+                              Class<T> tClass,\n+                              Supplier<T> bSupplier,\n+                              Consumer<T> cConsumer,\n+                              Supplier<T> dSupplier) {\n+                            return null;\n+                          }\n+\n+                          private static <T, A, B> Supplier<String> buildSupplier(\n+                              Class<T> tClass, Class<A> aClass, Class<B> bClass,\n+                              Function<A, B> function) {\n+                            return null;\n+                          }\n+                      }\"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDshould-stop.at=FLOW\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:7:29: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: T, (compiler.misc.inconvertible.types: java.util.function.Consumer<java.lang.String>, java.util.function.Supplier<T>))\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8369654\n+ * @summary javac OutOfMemoryError for complex intersection type\n+ * @compile ExpressionSwitchComplexIntersectionTest.java\n+ *\/\n+\n+public class ExpressionSwitchComplexIntersectionTest {\n+    interface WithMixin01<T> {}\n+    interface WithMixin02<T> {}\n+    interface WithMixin03<T> {}\n+    interface WithMixin04<T> {}\n+    interface WithMixin05<T> {}\n+    interface WithMixin06<T> {}\n+    interface WithMixin07<T> {}\n+    interface WithMixin08<T> {}\n+    interface WithMixin09<T> {}\n+    interface WithMixin10<T> {}\n+    interface WithMixin11<T> {}\n+    interface WithMixin12<T> {}\n+    interface WithMixin13<T> {}\n+    interface WithMixin14<T> {}\n+    interface WithMixin15<T> {}\n+    interface WithMixin16<T> {}\n+    interface WithMixin17<T> {}\n+    interface WithMixin18<T> {}\n+    interface WithMixin19<T> {}\n+    interface WithMixin20<T> {}\n+\n+    interface ClientA extends\n+            WithMixin01<ClientA>,\n+            WithMixin02<ClientA>,\n+            WithMixin03<ClientA>,\n+            WithMixin04<ClientA>,\n+            WithMixin05<ClientA>,\n+            WithMixin06<ClientA>,\n+            WithMixin07<ClientA>,\n+            WithMixin08<ClientA>,\n+            WithMixin09<ClientA>,\n+            WithMixin10<ClientA>,\n+            WithMixin11<ClientA>,\n+            WithMixin12<ClientA>,\n+            WithMixin13<ClientA>,\n+            WithMixin14<ClientA>,\n+            WithMixin15<ClientA>,\n+            WithMixin16<ClientA>,\n+            WithMixin17<ClientA>,\n+            WithMixin18<ClientA>,\n+            WithMixin19<ClientA>,\n+            WithMixin20<ClientA> {\n+    }\n+\n+    interface ClientB extends\n+            WithMixin01<ClientB>,\n+            WithMixin02<ClientB>,\n+            WithMixin03<ClientB>,\n+            WithMixin04<ClientB>,\n+            WithMixin05<ClientB>,\n+            WithMixin06<ClientB>,\n+            WithMixin07<ClientB>,\n+            WithMixin08<ClientB>,\n+            WithMixin09<ClientB>,\n+            WithMixin10<ClientB>,\n+            WithMixin11<ClientB>,\n+            WithMixin12<ClientB>,\n+            WithMixin13<ClientB>,\n+            WithMixin14<ClientB>,\n+            WithMixin15<ClientB>,\n+            WithMixin16<ClientB>,\n+            WithMixin17<ClientB>,\n+            WithMixin18<ClientB>,\n+            WithMixin19<ClientB>,\n+            WithMixin20<ClientB> {\n+    }\n+\n+    Object f1(boolean b, ClientA c1, ClientB c2) {\n+        return b ? c1 : c2;\n+    }\n+\n+    Object f2(boolean b, ClientA[] array1, ClientB[] array2) {\n+        return b ? array1 : array2;\n+    }\n+\n+    <TA extends ClientA, TB extends ClientB> Object f3(boolean b, TA[] array1, TB[] array2) {\n+        return b ? array1 : array2;\n+    }\n+\n+    <TA extends ClientA, TB extends ClientB, TAA extends TA, TBB extends TB> Object f4(boolean b, TAA[] array1, TBB[] array2) {\n+        return b ? array1 : array2;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchComplexIntersectionTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337142\n+ * @summary StackOverflowError in Types.containsTypeRecursive with deeply nested type hierarchy\n+ * @compile SOEForDeeplyNestedTypeTest.java\n+ *\/\n+\n+import java.util.List;\n+\n+public class SOEForDeeplyNestedTypeTest {\n+    class T {\n+        List<M<?, ?>> xs = List.of(new M<>(One.class), new M<>(Two.class), new M<>(Two.class));\n+    }\n+\n+    class M<R extends Eight, I extends Nine<? extends R>> {\n+        M(Class<? extends I> c) {}\n+    }\n+\n+    class One implements Three<Five>, Six<One> {}\n+    class Two implements Four<Seven>, Six<Two> {}\n+    interface Three<R extends Eight> extends Nine<R> {}\n+    interface Four<R extends Eight> extends Nine<R> {}\n+    class Five extends Ten<Five> implements Eleven<Twelve>, Thirteen {}\n+    interface Six<FullKeyT extends TwentyTwo> extends TwentyTwo {}\n+    class Seven extends Ten<Seven> implements Eleven<Fourteen>, Thirteen {}\n+    interface Eight {}\n+    interface Nine<R extends Eight> extends TwentyTwo {}\n+    class Ten<K extends TwentyTwo> implements TwentyTwo {}\n+    interface Eleven<PkT extends Twenty> extends Twenty {}\n+    class Twelve extends Ten<Twelve> implements Eleven<Sixteen>, Thirteen {}\n+    interface Thirteen extends Seventeen {}\n+    class Fourteen extends Ten<Fourteen> implements Eleven<Fifteen>, Thirteen {}\n+    class Fifteen extends Ten<Fifteen> implements Eleven<Twelve>, Thirteen {}\n+    class Sixteen extends Nineteen<Sixteen> implements Eighteen, Thirteen {}\n+    interface Seventeen extends Twenty {}\n+    interface Eighteen extends Twenty {}\n+    class Nineteen<K extends Twenty> extends Ten<K> implements Twenty {}\n+    interface Twenty extends TwentyTwo {}\n+    class TwentyOne<R extends Eight> {}\n+    interface TwentyTwo extends Eight {}\n+}\n","filename":"test\/langtools\/tools\/javac\/types\/SOEForDeeplyNestedTypeTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -1,2 +1,26 @@\n-# Requires jcmd\n-jdk\/test\/lib\/hprof\/HprofTest.java   8346719 generic-all\n+###########################################################################\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+###########################################################################\n+\n+# Currently empty\n","filename":"test\/lib-test\/ProblemList-StaticJdk.txt","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,0 +220,63 @@\n+        {\n+            \/\/ Multi-line output: OutputAnalyzer uses MULTILINE but not DOTALL, so \".\" doesn't match newline, but\n+            \/\/ \"^\" and \"$\" matches just after or just before, respectively, a newline.\n+            stdout = \"aaaaaa\\nxxxxxx\\n\";\n+            stderr = \"bbbbbb\\nyyyyyy\\n\";\n+\n+            OutputAnalyzer out = new OutputAnalyzer(stdout, stderr);\n+\n+            out.shouldMatch(\"aaa\");\n+            out.shouldMatch(\"xxx\");\n+            out.shouldMatch(\"bbb\");\n+            out.shouldMatch(\"yyy\");\n+\n+            out.stdoutShouldMatch(\"aaaaaa\");\n+            out.stdoutShouldMatch(\"xxxxxx\");\n+            out.stderrShouldMatch(\"bbbbbb\");\n+            out.stderrShouldMatch(\"yyyyyy\");\n+\n+            out.shouldMatch(\"^aaaaaa$\");\n+            out.shouldMatch(\"^xxxxxx$\");\n+            out.shouldMatch(\"^bbbbbb$\");\n+            out.shouldMatch(\"^yyyyyy$\");\n+\n+            out.stdoutShouldMatch(\"^aaaaaa$\");\n+            out.stdoutShouldMatch(\"^xxxxxx$\");\n+            out.stderrShouldMatch(\"^bbbbbb$\");\n+            out.stderrShouldMatch(\"^yyyyyy$\");\n+\n+            out.shouldMatch   (\"a.*\");\n+            out.shouldNotMatch(\"a.*x\");\n+            out.shouldMatch   (\"b.*\");\n+            out.shouldNotMatch(\"b.*y\");\n+            out.stdoutShouldMatch   (\"a.*\");\n+            out.stdoutShouldNotMatch(\"a.*x\");\n+            out.stderrShouldMatch   (\"b.*\");\n+            out.stderrShouldNotMatch(\"b.*y\");\n+\n+            check(out.matches(\"^aaaaaa$\"));\n+            check(out.matches(\"^yyyyyy$\"));\n+            check(out.stdoutMatches(\"^aaaaaa$\"));\n+            check(out.stderrMatches(\"^yyyyyy$\"));\n+\n+            check( out.matches(\"a.*\"));\n+            check(!out.matches(\"a.*x\"));\n+\n+            check( out.stdoutMatches(\"a.*\"));\n+            check(!out.stdoutMatches(\"a.*x\"));\n+\n+            check( out.stderrMatches(\"b.*\"));\n+            check(!out.stderrMatches(\"b.*y\"));\n+\n+            \/\/ Test the \"contains\" methods as well\n+            check(out.contains(\"aaa\\nxxx\"));\n+            check(out.contains(\"bbb\\nyyy\"));\n+            check(out.stdoutContains(\"aaa\\nxxx\"));\n+            check(out.stderrContains(\"bbb\\nyyy\"));\n+\n+            check(!out.contains(\"X\"));\n+            check(!out.contains(\"X\"));\n+            check(!out.stdoutContains(\"X\"));\n+            check(!out.stderrContains(\"X\"));\n+        }\n+\n@@ -247,0 +310,5 @@\n+    private static void check(boolean b) {\n+        if (!b) {\n+            throw new RuntimeException(\"Check failed\");\n+        }\n+    }\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/OutputAnalyzerTest.java","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -327,0 +327,18 @@\n+static char*\n+get_field_name(jvmtiEnv *jvmti, JNIEnv* jni, jclass field_class, jfieldID field) {\n+  char* name = nullptr;\n+  jvmtiError err = jvmti->GetFieldName(field_class, field, &name, nullptr, nullptr);\n+  check_jvmti_status(jni, err, \"get_field_name: error in JVMTI GetFieldName call\");\n+  return name;\n+}\n+\n+static char*\n+get_object_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jobject object) {\n+  char *obj_class_name = nullptr;\n+  jclass object_class = jni->GetObjectClass(object);\n+  jvmtiError err = jvmti->GetClassSignature(object_class, &obj_class_name, nullptr);\n+  check_jvmti_error(err, \"GetClassSignature\");\n+  jni->DeleteLocalRef(object_class);\n+  return obj_class_name;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -357,0 +357,19 @@\n+    \/**\n+     * Returns true if the pattern can be found in the given string(s).\n+     *\n+     * NOTE: The meaning of \"match\" in OutputAnalyzer is NOT the same as String.matches().\n+     * Rather it means \"can the pattern be found in stdout and\/or stderr\".\n+     *\n+     * The pattern is comiled with MULTILINE but without DOTALL, so \".\" doesn't match newline, but\n+     * \"^\" and \"$\" matches just after or just before, respectively, a newline.\n+     *\/\n+    private boolean findPattern(String regexp, String... strings) {\n+        Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n+        for (String s : strings) {\n+            if (pattern.matcher(s).find()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -361,1 +380,1 @@\n-        return getStdout().matches(regexp);\n+        return findPattern(regexp, getStdout());\n@@ -368,1 +387,1 @@\n-        return getStderr().matches(regexp);\n+        return findPattern(regexp, getStderr());\n@@ -375,1 +394,1 @@\n-        return stdoutMatches(regexp) || stderrMatches(regexp);\n+        return findPattern(regexp, getStdout(), getStderr());\n@@ -386,6 +405,1 @@\n-        String stdout = getStdout();\n-        String stderr = getStderr();\n-        Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n-        Matcher stdoutMatcher = pattern.matcher(stdout);\n-        Matcher stderrMatcher = pattern.matcher(stderr);\n-        if (!stdoutMatcher.find() && !stderrMatcher.find()) {\n+        if (!matches(regexp)) {\n@@ -407,3 +421,1 @@\n-        String stdout = getStdout();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);\n-        if (!matcher.find()) {\n+        if (!stdoutMatches(regexp)) {\n@@ -424,4 +436,2 @@\n-    public OutputAnalyzer stderrShouldMatch(String pattern) {\n-        String stderr = getStderr();\n-        Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);\n-        if (!matcher.find()) {\n+    public OutputAnalyzer stderrShouldMatch(String regexp) {\n+        if (!stderrMatches(regexp)) {\n@@ -429,1 +439,1 @@\n-            throw new RuntimeException(\"'\" + pattern\n+            throw new RuntimeException(\"'\" + regexp\n@@ -471,3 +481,1 @@\n-        String stdout = getStdout();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);\n-        if (matcher.find()) {\n+        if (stdoutMatches(regexp)) {\n@@ -489,3 +497,1 @@\n-        String stderr = getStderr();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stderr);\n-        if (matcher.find()) {\n+        if (stderrMatches(regexp)) {\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":29,"deletions":23,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 3, time = 3)\n+@Fork(value = 3)\n+public class FloatingPointParse {\n+\n+    private static final int N = 1_000_000;\n+    private static final int M = 100_000;\n+\n+    private String[] doubleToString, floatToString, s1, s2, s4, s10;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random();\n+\n+        doubleToString = new String[N];\n+        for (int i = 0; i < doubleToString.length;) {\n+            double v = Double.longBitsToDouble(r.nextLong());\n+            if (Double.isFinite(v)) {\n+                doubleToString[i++] = Double.toString(v);\n+            }\n+        }\n+\n+        floatToString = new String[N];\n+        for (int i = 0; i < floatToString.length;) {\n+            float v = Float.intBitsToFloat(r.nextInt());\n+            if (Float.isFinite(v)) {\n+                floatToString[i++] = Float.toString(v);\n+            }\n+        }\n+\n+        s1 = new String[M];\n+        for (int i = 0; i < s1.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s1[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+        s2 = new String[M];\n+        for (int i = 0; i < s2.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s2[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+        s4 = new String[M];\n+        for (int i = 0; i < s4.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s4[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+        s10 = new String[M];\n+        for (int i = 0; i < s10.length; ++i) {\n+            String f = \"0.\" + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL)\n+                    + (r.nextLong() & 0x7fff_ffff_ffff_ffffL);\n+            s10[i] = f + \"e\" + (r.nextInt(600) - 300);\n+        }\n+\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(N)\n+    public void parseDoubleToString(Blackhole bh) {\n+        for (String s : doubleToString) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS1(Blackhole bh) {\n+        for (String s : s1) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS2(Blackhole bh) {\n+        for (String s : s2) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS4(Blackhole bh) {\n+        for (String s : s4) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseDoubleS10(Blackhole bh) {\n+        for (String s : s10) {\n+            bh.consume(Double.parseDouble(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(N)\n+    public void parseFloatToString(Blackhole bh) {\n+        for (String s : floatToString) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS1(Blackhole bh) {\n+        for (String s : s1) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS2(Blackhole bh) {\n+        for (String s : s2) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS4(Blackhole bh) {\n+        for (String s : s4) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(M)\n+    public void parseFloatS10(Blackhole bh) {\n+        for (String s : s10) {\n+            bh.consume(Float.parseFloat(s));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FloatingPointParse.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,674 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+public class StrictMathExtraBench {\n+\n+    public static final int SIZE = 1022;\n+\n+    private static final Random rnd = new Random(42);\n+\n+    @State(Scope.Thread)\n+    public static class RangeState {\n+        final double[] values = new double[SIZE];\n+        final double min, max;\n+        final boolean signed;\n+\n+        public RangeState(boolean signed, double min, double max) {\n+            this.min = min;\n+            this.max = max;\n+            this.signed = signed;\n+        }\n+\n+        public RangeState(double min, double max) {\n+            this(true, min, max);\n+        }\n+\n+        @Setup\n+        public void setup() {\n+            for (int i = 0; i < values.length; i++) {\n+                values[i] = rnd.nextDouble(min, max);\n+                if (signed & rnd.nextBoolean()) {\n+                    values[i] = -values[i];\n+                }\n+            }\n+        }\n+    }\n+\n+    public static class RangeSubnormal extends RangeState {\n+        public RangeSubnormal() {\n+            super(0, Double.MIN_NORMAL);\n+        }\n+    }\n+\n+    public static class RangeNormal extends RangeState {\n+        public RangeNormal() {\n+            super(Double.MIN_NORMAL, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    public static class RangePositiveSubnormal extends RangeState {\n+        public RangePositiveSubnormal() {\n+            super(false, 0, Double.MIN_NORMAL);\n+        }\n+    }\n+\n+    public static class RangePositiveNormal extends RangeState {\n+        public RangePositiveNormal() {\n+            super(false, Double.MIN_NORMAL, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    public static class RangePiQuarter extends RangeState {\n+        public RangePiQuarter() {\n+            super(Double.MIN_NORMAL, Math.PI \/ 4);\n+        }\n+    }\n+\n+    public static class RangePiQuarterTo3PiQuarter extends RangeState {\n+        public RangePiQuarterTo3PiQuarter() {\n+            super(Math.PI \/ 4, 3 * Math.PI \/ 4);\n+        }\n+    }\n+\n+    public static class Range3PiQuarterToPiHalfTwo19 extends RangeState {\n+        public Range3PiQuarterToPiHalfTwo19() {\n+            super(3 * Math.PI \/ 4, 0x1.0p19 * Math.PI \/ 2);\n+        }\n+    }\n+\n+    public static class RangeBeyondPiHalfTwo19 extends RangeState {\n+        public RangeBeyondPiHalfTwo19() {\n+            super(0x1.0p19 * Math.PI \/ 2, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_pi_quarter(Blackhole bh, RangePiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_3pi_quarter(Blackhole bh, RangePiQuarterTo3PiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_pi_half_two19(Blackhole bh, Range3PiQuarterToPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sin_beyond_pi_half_two19(Blackhole bh, RangeBeyondPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_pi_quarter(Blackhole bh, RangePiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_3pi_quarter(Blackhole bh, RangePiQuarterTo3PiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_pi_half_two19(Blackhole bh, Range3PiQuarterToPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cos_beyond_pi_half_two19(Blackhole bh, RangeBeyondPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_pi_quarter(Blackhole bh, RangePiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_3pi_quarter(Blackhole bh, RangePiQuarterTo3PiQuarter r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_pi_half_two19(Blackhole bh, Range3PiQuarterToPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tan_beyond_pi_half_two19(Blackhole bh, RangeBeyondPiHalfTwo19 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tan(v));\n+        }\n+    }\n+\n+    public static class RangeHalf extends RangeState {\n+        public RangeHalf() {\n+            super(Double.MIN_NORMAL, 0.5);\n+        }\n+    }\n+\n+    public static class RangeHalfToOne extends RangeState {\n+        public RangeHalfToOne() {\n+            super(0.5, 1.0);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void asin_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.asin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void asin_half(Blackhole bh, RangeHalf r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.asin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void asin_one(Blackhole bh, RangeHalfToOne r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.asin(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void acos_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.acos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void acos_half(Blackhole bh, RangeHalf r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.acos(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void acos_one(Blackhole bh, RangeHalfToOne r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.acos(v));\n+        }\n+    }\n+\n+    public static class RangeTwo66 extends RangeState {\n+        public RangeTwo66() {\n+            super(Double.MIN_NORMAL, 0x1.0p66);\n+        }\n+    }\n+\n+    public static class RangeBeyondTwo66 extends RangeState {\n+        public RangeBeyondTwo66() {\n+            super(0x1.0p66, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.atan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan_two66(Blackhole bh, RangeTwo66 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.atan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan_beyond_two66(Blackhole bh, RangeBeyondTwo66 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.atan(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan2_subnormal(Blackhole bh, RangeSubnormal r0, RangeSubnormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.atan2(values0[i], values1[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void atan2_normal(Blackhole bh, RangeNormal r0, RangeNormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.atan2(values0[i], values1[i]));\n+        }\n+    }\n+\n+    private static final double LN2 = Math.log(2)\/Math.log(Math.E);\n+\n+    public static class RangeHalfLn2 extends RangeState {\n+        public RangeHalfLn2() {\n+            super(Double.MIN_NORMAL, LN2 \/ 2);\n+        }\n+    }\n+\n+    public static class RangeBeyondHalfLn2 extends RangeState {\n+        public RangeBeyondHalfLn2() {\n+            super(LN2 \/ 2, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void exp_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.exp(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void exp_half_ln2(Blackhole bh, RangeHalfLn2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.exp(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void exp_beyond_half_ln2(Blackhole bh, RangeBeyondHalfLn2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.exp(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log_subnormal(Blackhole bh, RangePositiveSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log_normal(Blackhole bh, RangePositiveNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log10_subnormal(Blackhole bh, RangePositiveSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log10(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log10_normal(Blackhole bh, RangePositiveNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log10(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log1p_subnormal(Blackhole bh, RangePositiveSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log1p(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void log1p_normal(Blackhole bh, RangePositiveNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.log1p(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cbrt_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cbrt(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cbrt_normal(Blackhole bh, RangeNormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cbrt(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void pow_subnormal(Blackhole bh, RangeSubnormal r0, RangeSubnormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.pow(values0[i], values1[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void pow_normal(Blackhole bh, RangeNormal r0, RangeNormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.pow(values0[i], values1[i]));\n+        }\n+    }\n+\n+    public static class Range22 extends RangeState {\n+        public Range22() {\n+            super(Double.MIN_NORMAL, 22);\n+        }\n+    }\n+\n+    public static class RangeBeyond22 extends RangeState {\n+        public RangeBeyond22() {\n+            super(22, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sinh_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sinh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sinh_22(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sinh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void sinh_beyond_22(Blackhole bh, RangeBeyond22 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.sinh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cosh_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cosh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cosh_22(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cosh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void cosh_beyond_22(Blackhole bh, RangeBeyond22 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.cosh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tanh_subnormal(Blackhole bh, RangeSubnormal r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tanh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void tanh_22(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.tanh(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void hypot_subnormal(Blackhole bh, RangeSubnormal r0, RangeSubnormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.hypot(values0[i], values1[i]));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void hypot_normal(Blackhole bh, RangeNormal r0, RangeNormal r1) {\n+        double[] values0 = r0.values;\n+        double[] values1 = r1.values;\n+        for (int i = 0; i < values0.length; i++) {\n+            bh.consume(StrictMath.hypot(values0[i], values1[i]));\n+        }\n+    }\n+\n+    public static class RangeTwoNeg54 extends RangeState {\n+        public RangeTwoNeg54() {\n+            super(Double.MIN_NORMAL, 0x1.0p-54);\n+        }\n+    }\n+\n+    public static class RangeTwoNeg54ToHalfLn2 extends RangeState {\n+        public RangeTwoNeg54ToHalfLn2() {\n+            super(0x1.0p-54, LN2 \/ 2);\n+        }\n+    }\n+\n+    public static class RangeHalfLn2To56Ln2 extends RangeState {\n+        public RangeHalfLn2To56Ln2() {\n+            super(LN2 \/ 2, 56 * LN2);\n+        }\n+    }\n+\n+    public static class RangeBeyond56Ln2 extends RangeState {\n+        public RangeBeyond56Ln2() {\n+            super(56 * LN2, Double.MAX_VALUE);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_two_neg_54(Blackhole bh, RangeTwoNeg54 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_half_ln2(Blackhole bh, RangeTwoNeg54ToHalfLn2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_56ln2(Blackhole bh, RangeHalfLn2To56Ln2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(SIZE)\n+    public void expm1_beyond_56ln2(Blackhole bh, RangeBeyond56Ln2 r) {\n+        double[] values = r.values;\n+        for (double v : values) {\n+            bh.consume(StrictMath.expm1(v));\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StrictMathExtraBench.java","additions":674,"deletions":0,"binary":false,"changes":674,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 1, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class SharedCloseStackWalk {\n+\n+    @Param({\"1\", \"10\", \"100\"})\n+    int numOtherThread;\n+\n+    @Param({\"10\", \"100\", \"1000\"})\n+    int extraFrames;\n+\n+    @Param({\"false\", \"true\"})\n+    boolean virtualThreads;\n+\n+    private CountDownLatch stop;\n+\n+    @Setup\n+    public void setup() {\n+        stop = new CountDownLatch(1);\n+        for (int i = 0; i < numOtherThread; i++) {\n+            (virtualThreads\n+                    ? Thread.ofVirtual()\n+                    : Thread.ofPlatform()).start(() -> recurse(0));\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        stop.countDown();\n+    }\n+\n+    @Benchmark\n+    public void sharedOpenClose() {\n+        Arena.ofShared().close();\n+    }\n+\n+    private void recurse(int depth) {\n+        if (depth == extraFrames) {\n+            try {\n+                stop.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Don't interrupt me!\", e);\n+            }\n+        } else {\n+            recurse(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SharedCloseStackWalk.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}