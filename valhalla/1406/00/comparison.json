{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"jvm_io.h\"\n@@ -149,1 +150,14 @@\n-  if (allow_inline && allow_intrinsics) {\n+  if (callee->intrinsic_id() == vmIntrinsics::_makePrivateBuffer || callee->intrinsic_id() == vmIntrinsics::_finishPrivateBuffer) {\n+    \/\/ These methods must be inlined so that we don't have larval value objects crossing method\n+    \/\/ boundaries\n+    assert(!call_does_dispatch, \"callee should not be virtual %s\", callee->name()->as_utf8());\n+    CallGenerator* cg = find_intrinsic(callee, call_does_dispatch);\n+\n+    if (cg == nullptr) {\n+      char reason[256];\n+      jio_snprintf(reason, sizeof(reason), \"cannot find an intrinsics for %s\", callee->name()->as_utf8());\n+      C->record_method_not_compilable(reason);\n+      return nullptr;\n+    }\n+    return cg;\n+  } else if (allow_inline && allow_intrinsics) {\n@@ -647,0 +661,4 @@\n+  if (failing()) {\n+    return;\n+  }\n+  assert(cg != nullptr, \"must find a CallGenerator for callee %s\", callee->name()->as_utf8());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3540,1 +3540,0 @@\n-        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2666,1 +2666,4 @@\n-  if (!value->is_InlineType()) {\n+\n+  const Type* type = gvn().type(value);\n+  if (!type->is_inlinetypeptr()) {\n+    C->record_method_not_compilable(\"value passed to Unsafe::makePrivateBuffer is not of a constant value type\");\n@@ -2670,1 +2673,1 @@\n-  receiver = null_check(receiver);\n+  null_check(receiver);\n@@ -2675,1 +2678,13 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  value = null_check(value);\n+  if (stopped()) {\n+    return true;\n+  }\n+\n+  ciInlineKlass* vk = type->inline_klass();\n+  Node* klass = makecon(TypeKlassPtr::make(vk));\n+  Node* obj = new_instance(klass);\n+\n+  assert(value->is_InlineType(), \"must be an InlineTypeNode\");\n+  value->as_InlineType()->store(this, obj, obj, vk);\n+\n+  set_result(obj);\n@@ -2682,5 +2697,4 @@\n-  if (!buffer->is_InlineType()) {\n-    return false;\n-  }\n-  InlineTypeNode* vt = buffer->as_InlineType();\n-  if (!vt->is_allocated(&_gvn)) {\n+\n+  const Type* type = gvn().type(buffer);\n+  if (!type->is_inlinetypeptr()) {\n+    C->record_method_not_compilable(\"value passed to Unsafe::finishPrivateBuffer is not of a constant value type\");\n@@ -2689,2 +2703,4 @@\n-  \/\/ TODO 8239003 Why is this needed?\n-  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n+\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer);\n+  if (alloc == nullptr) {\n+    C->record_method_not_compilable(\"value passed to Unsafe::finishPrivateBuffer must be allocated by Unsafe::makePrivateBuffer\");\n@@ -2694,1 +2710,1 @@\n-  receiver = null_check(receiver);\n+  null_check(receiver);\n@@ -2699,1 +2715,4 @@\n-  set_result(vt->finish_larval(this));\n+  \/\/ We must ensure that the buffer is properly published\n+  insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out(AllocateNode::RawAddress));\n+  assert(!type->maybe_null(), \"result of an allocation should not be null\");\n+  set_result(InlineTypeNode::make_from_oop(this, buffer, type->inline_klass(), false));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"}]}