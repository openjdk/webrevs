{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"jvm_io.h\"\n@@ -149,1 +150,15 @@\n-  if (allow_inline && allow_intrinsics) {\n+  if (callee->intrinsic_id() == vmIntrinsics::_makePrivateBuffer || callee->intrinsic_id() == vmIntrinsics::_finishPrivateBuffer) {\n+    \/\/ These methods must be inlined so that we don't have larval value objects crossing method\n+    \/\/ boundaries\n+    assert(!call_does_dispatch, \"callee should not be virtual %s\", callee->name()->as_utf8());\n+    CallGenerator* cg = find_intrinsic(callee, call_does_dispatch);\n+\n+    if (cg == nullptr) {\n+      \/\/ This is probably because the intrinsics is disabled from the command line\n+      char reason[256];\n+      jio_snprintf(reason, sizeof(reason), \"cannot find an intrinsics for %s\", callee->name()->as_utf8());\n+      C->record_method_not_compilable(reason);\n+      return nullptr;\n+    }\n+    return cg;\n+  } else if (allow_inline && allow_intrinsics) {\n@@ -647,0 +662,4 @@\n+  if (failing()) {\n+    return;\n+  }\n+  assert(cg != nullptr, \"must find a CallGenerator for callee %s\", callee->name()->as_utf8());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3529,0 +3529,1 @@\n+\n@@ -3530,0 +3531,11 @@\n+      if (t->is_inlinetypeptr() && !t->maybe_null() && kptr == improved_klass_ptr_type) {\n+        \/\/ Special case: larval inline objects must not be scalarized. They are also generally not\n+        \/\/ allowed to participate in most operations except as an argument to Unsafe::putXXX or\n+        \/\/ Unsafe::finishPrivateBuffer. This allows us to aggressively scalarize value objects in\n+        \/\/ all other places. This special case comes from the limitation of the Java language,\n+        \/\/ Unsafe::makePrivateBuffer returns an Object that is checkcast-ed to the concrete value\n+        \/\/ type. We must do this first because C->static_subtype_check may do nothing when\n+        \/\/ StressReflectiveCode is set.\n+        return obj;\n+      }\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2666,1 +2666,4 @@\n-  if (!value->is_InlineType()) {\n+\n+  const Type* type = gvn().type(value);\n+  if (!type->is_inlinetypeptr()) {\n+    C->record_method_not_compilable(\"value passed to Unsafe::makePrivateBuffer is not of a constant value type\");\n@@ -2670,1 +2673,1 @@\n-  receiver = null_check(receiver);\n+  null_check(receiver);\n@@ -2675,1 +2678,14 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  value = null_check(value);\n+  if (stopped()) {\n+    return true;\n+  }\n+\n+  ciInlineKlass* vk = type->inline_klass();\n+  Node* klass = makecon(TypeKlassPtr::make(vk));\n+  Node* obj = new_instance(klass);\n+  AllocateNode::Ideal_allocation(obj)->_larval = true;\n+\n+  assert(value->is_InlineType(), \"must be an InlineTypeNode\");\n+  value->as_InlineType()->store(this, obj, obj, vk);\n+\n+  set_result(obj);\n@@ -2682,5 +2698,4 @@\n-  if (!buffer->is_InlineType()) {\n-    return false;\n-  }\n-  InlineTypeNode* vt = buffer->as_InlineType();\n-  if (!vt->is_allocated(&_gvn)) {\n+\n+  const Type* type = gvn().type(buffer);\n+  if (!type->is_inlinetypeptr()) {\n+    C->record_method_not_compilable(\"value passed to Unsafe::finishPrivateBuffer is not of a constant value type\");\n@@ -2689,2 +2704,4 @@\n-  \/\/ TODO 8239003 Why is this needed?\n-  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n+\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer);\n+  if (alloc == nullptr) {\n+    C->record_method_not_compilable(\"value passed to Unsafe::finishPrivateBuffer must be allocated by Unsafe::makePrivateBuffer\");\n@@ -2694,1 +2711,1 @@\n-  receiver = null_check(receiver);\n+  null_check(receiver);\n@@ -2699,1 +2716,9 @@\n-  set_result(vt->finish_larval(this));\n+  \/\/ Unset the larval bit in the object header\n+  Node* old_header = make_load(control(), buffer, TypeX_X, TypeX_X->basic_type(), MemNode::unordered, LoadNode::Pinned);\n+  Node* new_header = gvn().transform(new AndXNode(old_header, MakeConX(~markWord::larval_bit_in_place)));\n+  access_store_at(buffer, buffer, type->is_ptr(), new_header, TypeX_X, TypeX_X->basic_type(), MO_UNORDERED | IN_HEAP);\n+\n+  \/\/ We must ensure that the buffer is properly published\n+  insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out(AllocateNode::RawAddress));\n+  assert(!type->maybe_null(), \"result of an allocation should not be null\");\n+  set_result(InlineTypeNode::make_from_oop(this, buffer, type->inline_klass(), false));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":37,"deletions":12,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1685,0 +1685,22 @@\n+    \/*\n+    TODO: 8335256: Properly handle merging of value object oops\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    public MyValue1 test84(MyValue1 v) {\n+        v = U.makePrivateBuffer(v);\n+        for (int i = 0; i < 10; i++) {\n+            U.putInt(v, X_OFFSET, i);\n+        }\n+        U.putInt(v, X_OFFSET, rI);\n+        v = U.finishPrivateBuffer(v);\n+        return v;\n+    }\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier() {\n+        MyValue1 v1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1 v2 = test84(MyValue1.setX(v1, 0));\n+        Asserts.assertEQ(v1.hash(), v2.hash());\n+    }\n+    *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}