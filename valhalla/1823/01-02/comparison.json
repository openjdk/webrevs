{"files":[{"patch":"@@ -673,1 +673,1 @@\n-bool InlineTypeNode::can_emit_substitutability_check(Node* other) {\n+bool InlineTypeNode::can_emit_substitutability_check(Node* other) const {\n@@ -693,3 +693,3 @@\n-\/\/ Emit IR to check substitutability between 'this' (left operand) and the value object referred to by 'ptr' (right operand).\n-\/\/ Parse-time checks guarantee that both operands have the same type. If 'ptr' is not an InlineTypeNode, we need to emit loads for the field values.\n-void InlineTypeNode::check_substitutability(PhaseIterGVN* igvn, RegionNode* region, Node* phi, Node** ctrl, Node* mem, Node* base, Node* ptr, bool flat) {\n+\/\/ Emit IR to check substitutability between 'this' (left operand) and the value object referred to by 'other' (right operand).\n+\/\/ Parse-time checks guarantee that both operands have the same type. If 'other' is not an InlineTypeNode, we need to emit loads for the field values.\n+void InlineTypeNode::check_substitutability(PhaseIterGVN* igvn, RegionNode* region, Node* phi, Node** ctrl, Node* mem, Node* base, Node* other, bool flat) const {\n@@ -707,1 +707,1 @@\n-    Node* val = field_value(i);\n+    Node* this_field = field_value(i);\n@@ -711,2 +711,2 @@\n-    Node* field_base = base;\n-    Node* field_ptr = ptr;\n+    Node* other_base = base;\n+    Node* other_field = other;\n@@ -715,3 +715,3 @@\n-    if (ptr->is_InlineType()) {\n-      field_ptr = ptr->as_InlineType()->field_value(i);\n-      field_base = nullptr;\n+    if (other->is_InlineType()) {\n+      other_field = other->as_InlineType()->field_value(i);\n+      other_base = nullptr;\n@@ -719,2 +719,2 @@\n-      \/\/ 'ptr' is an oop, compute address of the field\n-      field_ptr = igvn->register_new_node_with_optimizer(new AddPNode(base, ptr, igvn->MakeConX(field_off)));\n+      \/\/ 'other' is an oop, compute address of the field\n+      other_field = igvn->register_new_node_with_optimizer(new AddPNode(base, other, igvn->MakeConX(field_off)));\n@@ -723,1 +723,1 @@\n-        assert(val->is_InlineType(), \"inconsistent field value\");\n+        assert(this_field->is_InlineType(), \"inconsistent field value\");\n@@ -726,2 +726,2 @@\n-        assert(is_java_primitive(bt) || field_ptr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent field type\");\n-        C2AccessValuePtr addr(field_ptr, field_ptr->bottom_type()->is_ptr());\n+        assert(is_java_primitive(bt) || other_field->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent field type\");\n+        C2AccessValuePtr addr(other_field, other_field->bottom_type()->is_ptr());\n@@ -729,2 +729,2 @@\n-        field_ptr = bs->load_at(access, Type::get_const_type(ft));\n-        field_base = field_ptr;\n+        other_field = bs->load_at(access, Type::get_const_type(ft));\n+        other_base = other_field;\n@@ -734,1 +734,1 @@\n-    if (val->is_InlineType()) {\n+    if (this_field->is_InlineType()) {\n@@ -741,1 +741,1 @@\n-          if (field_ptr->is_InlineType()) {\n+          if (other_field->is_InlineType()) {\n@@ -743,1 +743,1 @@\n-            null_marker = field_ptr->as_InlineType()->get_null_marker();\n+            null_marker = other_field->as_InlineType()->get_null_marker();\n@@ -746,1 +746,1 @@\n-            Node* nm_adr = igvn->register_new_node_with_optimizer(new AddPNode(base, field_ptr, nm_offset));\n+            Node* nm_adr = igvn->register_new_node_with_optimizer(new AddPNode(base, other_field, nm_offset));\n@@ -752,1 +752,1 @@\n-          acmp_val_guard(igvn, region, phi, ctrl, T_INT, BoolTest::ne, val->as_InlineType()->get_null_marker(), null_marker);\n+          acmp_val_guard(igvn, region, phi, ctrl, T_INT, BoolTest::ne, this_field->as_InlineType()->get_null_marker(), null_marker);\n@@ -755,1 +755,1 @@\n-          acmp_val_guard(igvn, done_region, nullptr, ctrl, T_INT, BoolTest::eq, val->as_InlineType()->get_null_marker(), igvn->intcon(0));\n+          acmp_val_guard(igvn, done_region, nullptr, ctrl, T_INT, BoolTest::eq, this_field->as_InlineType()->get_null_marker(), igvn->intcon(0));\n@@ -759,1 +759,1 @@\n-          \/\/ Check if left operand is null\n+          \/\/ Check if 'this' is null\n@@ -761,1 +761,1 @@\n-          acmp_val_guard(igvn, not_null_region, nullptr, ctrl, T_INT, BoolTest::ne, val->as_InlineType()->get_null_marker(), igvn->intcon(0));\n+          acmp_val_guard(igvn, not_null_region, nullptr, ctrl, T_INT, BoolTest::ne, this_field->as_InlineType()->get_null_marker(), igvn->intcon(0));\n@@ -763,2 +763,2 @@\n-          \/\/ Left operand is null. If right operand is non-null, return false.\n-          acmp_val_guard(igvn, region, phi, ctrl, T_OBJECT, BoolTest::ne, field_ptr, igvn->zerocon(T_OBJECT));\n+          \/\/ 'this' is null. If 'other' is non-null, return false.\n+          acmp_val_guard(igvn, region, phi, ctrl, T_OBJECT, BoolTest::ne, other_field, igvn->zerocon(T_OBJECT));\n@@ -769,1 +769,1 @@\n-          \/\/ Left operand is not null. If right operand is null, return false.\n+          \/\/ 'this' is not null. If 'other' is null, return false.\n@@ -771,1 +771,1 @@\n-          acmp_val_guard(igvn, region, phi, ctrl, T_OBJECT, BoolTest::eq, field_ptr, igvn->zerocon(T_OBJECT));\n+          acmp_val_guard(igvn, region, phi, ctrl, T_OBJECT, BoolTest::eq, other_field, igvn->zerocon(T_OBJECT));\n@@ -775,1 +775,1 @@\n-      val->as_InlineType()->check_substitutability(igvn, region, phi, ctrl, mem, field_base, field_ptr, field_is_flat(i));\n+      this_field->as_InlineType()->check_substitutability(igvn, region, phi, ctrl, mem, other_base, other_field, field_is_flat(i));\n@@ -781,1 +781,1 @@\n-      acmp_val_guard(igvn, region, phi, ctrl, bt, BoolTest::ne, val, field_ptr);\n+      acmp_val_guard(igvn, region, phi, ctrl, bt, BoolTest::ne, this_field, other_field);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-  bool can_emit_substitutability_check(Node* other);\n-  void check_substitutability(PhaseIterGVN* igvn, RegionNode* region, Node* phi, Node** ctrl, Node* mem, Node* base, Node* ptr, bool flat = false);\n+  bool can_emit_substitutability_check(Node* other) const;\n+  void check_substitutability(PhaseIterGVN* igvn, RegionNode* region, Node* phi, Node** ctrl, Node* mem, Node* base, Node* other, bool flat = false) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1217,1 +1217,4 @@\n-    \/\/ If one operand is an inline type, convert this to a \"both operands are null\" check:\n+    \/\/ In C2 IR, CmpP on value objects is a pointer comparison, not a value comparison.\n+    \/\/ For non-null operands it cannot reliably be true, since their buffer oops are not\n+    \/\/ guaranteed to be identical. Therefore, the comparison can only be true when both\n+    \/\/ operands are null. Convert expressions like this to a \"both operands are null\" check:\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}