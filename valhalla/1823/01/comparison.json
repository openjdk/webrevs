{"files":[{"patch":"@@ -143,0 +143,11 @@\n+\n+int ciInlineKlass::field_map_offset() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->acmp_maps_offset();)\n+}\n+\n+ciConstant ciInlineKlass::get_field_map() const {\n+  VM_ENTRY_MARK\n+  InlineKlass* vk = get_InlineKlass();\n+  oop array = vk->java_mirror()->obj_field(vk->acmp_maps_offset());\n+  return ciConstant(T_ARRAY, CURRENT_ENV->get_object(array));\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  int field_map_offset() const;\n+  ciConstant get_field_map() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,0 +432,1 @@\n+  case vmIntrinsics::_getFieldMap:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -712,4 +712,7 @@\n-  do_intrinsic(_arrayInstanceIndexScale,  jdk_internal_misc_Unsafe,     _arrayInstanceIndexScale_name, arrayProperties_signature, F_RN) \\\n-   do_name(    _arrayInstanceIndexScale_name,                           \"arrayInstanceIndexScale0\")                              \\\n-  do_intrinsic(_arrayLayout,  jdk_internal_misc_Unsafe,                 _arrayLayout_name, arrayProperties_signature, F_RN)      \\\n-   do_name(    _arrayLayout_name,                                       \"arrayLayout0\")                                          \\\n+  do_intrinsic(_arrayInstanceIndexScale,  jdk_internal_misc_Unsafe,     arrayInstanceIndexScale_name, arrayProperties_signature, F_RN) \\\n+   do_name(     arrayInstanceIndexScale_name,                           \"arrayInstanceIndexScale0\")                              \\\n+  do_intrinsic(_arrayLayout,              jdk_internal_misc_Unsafe,     arrayLayout_name, arrayProperties_signature, F_RN)       \\\n+   do_name(     arrayLayout_name,                                       \"arrayLayout0\")                                          \\\n+  do_intrinsic(_getFieldMap,              jdk_internal_misc_Unsafe,     getFieldMap_name, getFieldMap_signature, F_RN)           \\\n+   do_name(     getFieldMap_name,                                       \"getFieldMap0\")                                          \\\n+   do_signature(getFieldMap_signature,                                  \"(Ljava\/lang\/Class;)[I\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -169,2 +169,2 @@\n-  static ByteSize klass_offset() { return in_ByteSize(offset_of(InlineLayoutInfo, _klass)); }\n-  static ByteSize null_marker_offset_offset() { return in_ByteSize(offset_of(InlineLayoutInfo, _null_marker_offset)); }\n+  static ByteSize klass_offset() { return byte_offset_of(InlineLayoutInfo, _klass); }\n+  static ByteSize null_marker_offset_offset() { return byte_offset_of(InlineLayoutInfo, _null_marker_offset); }\n@@ -630,2 +630,2 @@\n-  static ByteSize kind_offset() { return in_ByteSize(offset_of(InstanceKlass, _kind)); }\n-  static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }\n+  static ByteSize kind_offset() { return byte_offset_of(InstanceKlass, _kind); }\n+  static ByteSize misc_flags_offset() { return byte_offset_of(InstanceKlass, _misc_flags); }\n@@ -654,0 +654,1 @@\n+  static ByteSize acmp_maps_offset_offset() { return byte_offset_of(InstanceKlass, _acmp_maps_offset); }\n@@ -975,2 +976,2 @@\n-  static ByteSize inline_layout_info_array_offset() { return in_ByteSize(offset_of(InstanceKlass, _inline_layout_info_array)); }\n-  static ByteSize adr_inline_klass_members_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_inline_klass_members)); }\n+  static ByteSize inline_layout_info_array_offset() { return byte_offset_of(InstanceKlass, _inline_layout_info_array); }\n+  static ByteSize adr_inline_klass_members_offset() { return byte_offset_of(InstanceKlass, _adr_inline_klass_members); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -754,0 +754,1 @@\n+  case vmIntrinsics::_getFieldMap:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"opto\/movenode.hpp\"\n@@ -1174,2 +1176,2 @@\n-    if (remove_unknown_flat_array_load(igvn, in(0), in(TypeFunc::Memory), in(TypeFunc::Parms))) {\n-      if (!in(0)->is_Region()) {\n+    if (remove_unknown_flat_array_load(igvn, control(), memory(), in(TypeFunc::Parms))) {\n+      if (!control()->is_Region()) {\n@@ -1182,0 +1184,55 @@\n+  \/\/ Try to replace the runtime call to the substitutability test emitted by acmp if (at least) one operand is a known type\n+  if (can_reshape && !control()->is_top() && method() != nullptr && method()->holder() == phase->C->env()->ValueObjectMethods_klass() &&\n+      (method()->name() == ciSymbols::isSubstitutableAlt_name() || method()->name() == ciSymbols::isSubstitutable_name())) {\n+    Node* left = in(TypeFunc::Parms);\n+    Node* right = in(TypeFunc::Parms + 1);\n+    if (!left->is_top() && !right->is_top() && (left->is_InlineType() || right->is_InlineType())) {\n+      if (!left->is_InlineType()) {\n+        swap(left, right);\n+      }\n+      InlineTypeNode* vt = left->as_InlineType();\n+\n+      \/\/ Check if the field layout can be optimized\n+      if (vt->can_emit_substitutability_check(right)) {\n+        PhaseIterGVN* igvn = phase->is_IterGVN();\n+\n+        Node* ctrl = control();\n+        RegionNode* region = new RegionNode(1);\n+        Node* phi = new PhiNode(region, TypeInt::POS);\n+\n+        Node* base = right;\n+        Node* ptr = right;\n+        if (!base->is_InlineType()) {\n+          \/\/ Parse time checks guarantee that both operands are non-null and have the same type\n+          base = igvn->register_new_node_with_optimizer(new CheckCastPPNode(ctrl, base, vt->bottom_type()));\n+          ptr = base;\n+        }\n+        \/\/ Emit IR for field-wise comparison\n+        vt->check_substitutability(igvn, region, phi, &ctrl, in(MemNode::Memory), base, ptr);\n+\n+        \/\/ Equals\n+        region->add_req(ctrl);\n+        phi->add_req(igvn->intcon(1));\n+\n+        ctrl = igvn->register_new_node_with_optimizer(region);\n+        Node* res = igvn->register_new_node_with_optimizer(phi);\n+\n+        \/\/ Kill exception projections and return a tuple that will replace the call\n+        CallProjections* projs = extract_projections(false \/*separate_io_proj*\/);\n+        if (projs->fallthrough_catchproj != nullptr) {\n+          igvn->replace_node(projs->fallthrough_catchproj, ctrl);\n+        }\n+        if (projs->catchall_memproj != nullptr) {\n+          igvn->replace_node(projs->catchall_memproj, igvn->C->top());\n+        }\n+        if (projs->catchall_ioproj != nullptr) {\n+          igvn->replace_node(projs->catchall_ioproj, igvn->C->top());\n+        }\n+        if (projs->catchall_catchproj != nullptr) {\n+          igvn->replace_node(projs->catchall_catchproj, igvn->C->top());\n+        }\n+        return TupleNode::make(tf()->range_cc(), ctrl, i_o(), memory(), frameptr(), returnadr(), res);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -560,16 +560,0 @@\n-\n-  if (t->is_zero_type() || !t->maybe_null()) {\n-    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n-      Node* u = fast_out(i);\n-      if (u->Opcode() == Op_OrL) {\n-        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n-          Node* cmp = u->fast_out(j);\n-          if (cmp->Opcode() == Op_CmpL) {\n-            \/\/ Give CmpL a chance to get optimized\n-            phase->record_for_igvn(cmp);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5583,21 +5583,0 @@\n-Node* Compile::optimize_acmp(PhaseGVN* phase, Node* a, Node* b) {\n-  const TypeInstPtr* ta = phase->type(a)->isa_instptr();\n-  const TypeInstPtr* tb = phase->type(b)->isa_instptr();\n-  if (!Arguments::is_valhalla_enabled() || ta == nullptr || tb == nullptr ||\n-      ta->is_zero_type() || tb->is_zero_type() ||\n-      !ta->can_be_inline_type() || !tb->can_be_inline_type()) {\n-    \/\/ Use old acmp if one operand is null or not an inline type\n-    return new CmpPNode(a, b);\n-  } else if (ta->is_inlinetypeptr() || tb->is_inlinetypeptr()) {\n-    \/\/ We know that one operand is an inline type. Therefore,\n-    \/\/ new acmp will only return true if both operands are nullptr.\n-    \/\/ Check if both operands are null by or'ing the oops.\n-    a = phase->transform(new CastP2XNode(nullptr, a));\n-    b = phase->transform(new CastP2XNode(nullptr, b));\n-    a = phase->transform(new OrXNode(a, b));\n-    return new CmpXNode(a, phase->MakeConX(0));\n-  }\n-  \/\/ Use new acmp\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1343,2 +1343,0 @@\n-  Node* optimize_acmp(PhaseGVN* phase, Node* a, Node* b);\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4843,9 +4843,0 @@\n-\/\/---------------------------load_mirror_from_klass----------------------------\n-\/\/ Given a klass oop, load its java mirror (a java.lang.Class oop).\n-Node* GraphKit::load_mirror_from_klass(Node* klass) {\n-  Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));\n-  Node* load = make_load(nullptr, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n-  \/\/ mirror = ((OopHandle)mirror)->resolve();\n-  return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -634,0 +634,152 @@\n+\/\/ Adds a check between val1 and val2. Jumps to 'region' if check passes and optionally sets the corresponding phi input to false.\n+static void acmp_val_guard(PhaseIterGVN* igvn, RegionNode* region, Node* phi, Node** ctrl, BasicType bt, BoolTest::mask test, Node* val1, Node* val2) {\n+  Node* cmp = nullptr;\n+  switch (bt) {\n+  case T_FLOAT:\n+    val1 = igvn->register_new_node_with_optimizer(new MoveF2INode(val1));\n+    val2 = igvn->register_new_node_with_optimizer(new MoveF2INode(val2));\n+    \/\/ Fall-through to the int case\n+  case T_BOOLEAN:\n+  case T_CHAR:\n+  case T_BYTE:\n+  case T_SHORT:\n+  case T_INT:\n+    cmp = igvn->register_new_node_with_optimizer(new CmpINode(val1, val2));\n+    break;\n+  case T_DOUBLE:\n+    val1 = igvn->register_new_node_with_optimizer(new MoveD2LNode(val1));\n+    val2 = igvn->register_new_node_with_optimizer(new MoveD2LNode(val2));\n+    \/\/ Fall-through to the long case\n+  case T_LONG:\n+    cmp = igvn->register_new_node_with_optimizer(new CmpLNode(val1, val2));\n+    break;\n+  default:\n+    assert(is_reference_type(bt), \"must be\");\n+    cmp = igvn->register_new_node_with_optimizer(new CmpPNode(val1, val2));\n+  }\n+  Node* bol = igvn->register_new_node_with_optimizer(new BoolNode(cmp, test));\n+  IfNode* iff = igvn->register_new_node_with_optimizer(new IfNode(*ctrl, bol, PROB_MAX, COUNT_UNKNOWN))->as_If();\n+  Node* if_f = igvn->register_new_node_with_optimizer(new IfFalseNode(iff));\n+  Node* if_t = igvn->register_new_node_with_optimizer(new IfTrueNode(iff));\n+\n+  region->add_req(if_t);\n+  if (phi != nullptr) {\n+    phi->add_req(igvn->intcon(0));\n+  }\n+  *ctrl = if_f;\n+}\n+\n+\/\/ Check if a substitutability check between 'this' and 'other' can be implemented in IR\n+bool InlineTypeNode::can_emit_substitutability_check(Node* other) {\n+  if (other != nullptr && other->is_InlineType() && bottom_type() != other->bottom_type()) {\n+    \/\/ Different types, this is dead code because there's a check above that guarantees this.\n+    return false;\n+  }\n+  for (uint i = 0; i < field_count(); i++) {\n+    ciType* ft = field_type(i);\n+    if (ft->is_inlinetype()) {\n+      \/\/ Check recursively\n+      if (!field_value(i)->as_InlineType()->can_emit_substitutability_check(nullptr)){\n+        return false;\n+      }\n+    } else if (!ft->is_primitive_type() && ft->as_klass()->can_be_inline_klass()) {\n+      \/\/ Comparing this field might require (another) substitutability check, bail out\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Emit IR to check substitutability between 'this' (left operand) and the value object referred to by 'ptr' (right operand).\n+\/\/ Parse-time checks guarantee that both operands have the same type. If 'ptr' is not an InlineTypeNode, we need to emit loads for the field values.\n+void InlineTypeNode::check_substitutability(PhaseIterGVN* igvn, RegionNode* region, Node* phi, Node** ctrl, Node* mem, Node* base, Node* ptr, bool flat) {\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  DecoratorSet decorators = IN_HEAP | MO_UNORDERED | C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD;\n+  MergeMemNode* local_mem = igvn->register_new_node_with_optimizer(MergeMemNode::make(mem))->as_MergeMem();\n+\n+  ciInlineKlass* vk = inline_klass();\n+  for (uint i = 0; i < field_count(); i++) {\n+    int field_off = field_offset(i);\n+    if (flat) {\n+      \/\/ Flat access, no header\n+      field_off -= vk->payload_offset();\n+    }\n+    Node* val = field_value(i);\n+    ciType* ft = field_type(i);\n+    BasicType bt = ft->basic_type();\n+\n+    Node* field_base = base;\n+    Node* field_ptr = ptr;\n+\n+    \/\/ Get field value of the other operand\n+    if (ptr->is_InlineType()) {\n+      field_ptr = ptr->as_InlineType()->field_value(i);\n+      field_base = nullptr;\n+    } else {\n+      \/\/ 'ptr' is an oop, compute address of the field\n+      field_ptr = igvn->register_new_node_with_optimizer(new AddPNode(base, ptr, igvn->MakeConX(field_off)));\n+      if (field_is_flat(i)) {\n+        \/\/ Flat field, load is handled recursively below\n+        assert(val->is_InlineType(), \"inconsistent field value\");\n+      } else {\n+        \/\/ Non-flat field, load the field value and update the base because we are now operating on a different object\n+        assert(is_java_primitive(bt) || field_ptr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent field type\");\n+        C2AccessValuePtr addr(field_ptr, field_ptr->bottom_type()->is_ptr());\n+        C2OptAccess access(*igvn, *ctrl, local_mem, decorators, bt, base, addr);\n+        field_ptr = bs->load_at(access, Type::get_const_type(ft));\n+        field_base = field_ptr;\n+      }\n+    }\n+\n+    if (val->is_InlineType()) {\n+      RegionNode* done_region = new RegionNode(1);\n+      if (!field_is_null_free(i)) {\n+        \/\/ Nullable field, check null marker before accessing the fields\n+        if (field_is_flat(i)) {\n+          \/\/ Flat field, check embedded null marker\n+          Node* null_marker = nullptr;\n+          if (field_ptr->is_InlineType()) {\n+            \/\/ TODO 8350865 Should we add an IGVN optimization to fold null marker loads from InlineTypeNodes?\n+            null_marker = field_ptr->as_InlineType()->get_null_marker();\n+          } else {\n+            Node* nm_offset = igvn->MakeConX(ft->as_inline_klass()->null_marker_offset_in_payload());\n+            Node* nm_adr = igvn->register_new_node_with_optimizer(new AddPNode(base, field_ptr, nm_offset));\n+            C2AccessValuePtr addr(nm_adr, nm_adr->bottom_type()->is_ptr());\n+            C2OptAccess access(*igvn, *ctrl, local_mem, decorators, T_BOOLEAN, base, addr);\n+            null_marker = bs->load_at(access, TypeInt::BOOL);\n+          }\n+          \/\/ Return false if null markers are not equal\n+          acmp_val_guard(igvn, region, phi, ctrl, T_INT, BoolTest::ne, val->as_InlineType()->get_null_marker(), null_marker);\n+\n+          \/\/ Null markers are equal. If both operands are null, skip the comparison of the fields.\n+          acmp_val_guard(igvn, done_region, nullptr, ctrl, T_INT, BoolTest::eq, val->as_InlineType()->get_null_marker(), igvn->intcon(0));\n+        } else {\n+          \/\/ Non-flat field, check if oop is null\n+\n+          \/\/ Check if left operand is null\n+          RegionNode* not_null_region = new RegionNode(1);\n+          acmp_val_guard(igvn, not_null_region, nullptr, ctrl, T_INT, BoolTest::ne, val->as_InlineType()->get_null_marker(), igvn->intcon(0));\n+\n+          \/\/ Left operand is null. If right operand is non-null, return false.\n+          acmp_val_guard(igvn, region, phi, ctrl, T_OBJECT, BoolTest::ne, field_ptr, igvn->zerocon(T_OBJECT));\n+\n+          \/\/ Both are null, skip comparing the fields\n+          done_region->add_req(*ctrl);\n+\n+          \/\/ Left operand is not null. If right operand is null, return false.\n+          *ctrl = igvn->register_new_node_with_optimizer(not_null_region);\n+          acmp_val_guard(igvn, region, phi, ctrl, T_OBJECT, BoolTest::eq, field_ptr, igvn->zerocon(T_OBJECT));\n+        }\n+      }\n+      \/\/ Both operands are non-null, compare all the fields recursively\n+      val->as_InlineType()->check_substitutability(igvn, region, phi, ctrl, mem, field_base, field_ptr, field_is_flat(i));\n+\n+      done_region->add_req(*ctrl);\n+      *ctrl = igvn->register_new_node_with_optimizer(done_region);\n+    } else {\n+      assert(ft->is_primitive_type() || !ft->as_klass()->can_be_inline_klass(), \"Needs substitutability test\");\n+      acmp_val_guard(igvn, region, phi, ctrl, bt, BoolTest::ne, val, field_ptr);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -143,0 +143,4 @@\n+  \/\/ Implementation of the substitutability check for acmp\n+  bool can_emit_substitutability_check(Node* other);\n+  void check_substitutability(PhaseIterGVN* igvn, RegionNode* region, Node* phi, Node** ctrl, Node* mem, Node* base, Node* ptr, bool flat = false);\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -490,0 +490,1 @@\n+  case vmIntrinsics::_getFieldMap:              return inline_getFieldMap();\n@@ -3318,1 +3319,1 @@\n-  Node* layout_kind_addr = basic_plus_adr(klass_node, klass_node, layout_kind_offset);\n+  Node* layout_kind_addr = basic_plus_adr(klass_node, layout_kind_offset);\n@@ -3329,0 +3330,26 @@\n+\/\/ private native int[] getFieldMap0(Class <?> c);\n+\/\/   int offset = c._klass._acmp_maps_offset;\n+\/\/   return (int[])c.obj_field(offset);\n+bool LibraryCallKit::inline_getFieldMap() {\n+  if (!UseAltSubstitutabilityMethod) {\n+    return false;\n+  }\n+\n+  Node* mirror = argument(1);\n+  Node* klass = load_klass_from_mirror(mirror, false, nullptr, 0);\n+\n+  int field_map_offset_offset = in_bytes(InstanceKlass::acmp_maps_offset_offset());\n+  Node* field_map_offset_addr = basic_plus_adr(klass, field_map_offset_offset);\n+  Node* field_map_offset = make_load(nullptr, field_map_offset_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  field_map_offset = _gvn.transform(ConvI2L(field_map_offset));\n+\n+  Node* map_addr = basic_plus_adr(mirror, field_map_offset);\n+  const TypeAryPtr* val_type = TypeAryPtr::INTS->cast_to_ptr_type(TypePtr::NotNull)->with_offset(0);\n+  \/\/ TODO 8350865 Remove this\n+  val_type = val_type->cast_to_not_flat(true)->cast_to_not_null_free(true);\n+  Node* map = access_load_at(mirror, map_addr, TypeAryPtr::INTS, val_type, T_ARRAY, IN_HEAP | MO_UNORDERED);\n+\n+  set_result(map);\n+  return true;\n+}\n+\n@@ -4397,0 +4424,9 @@\n+\/\/---------------------------load_mirror_from_klass----------------------------\n+\/\/ Given a klass oop, load its java mirror (a java.lang.Class oop).\n+Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {\n+  Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));\n+  Node* load = make_load(nullptr, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  \/\/ mirror = ((OopHandle)mirror)->resolve();\n+  return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  Node* load_mirror_from_klass(Node* klass);\n@@ -355,0 +356,1 @@\n+  bool inline_getFieldMap();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,0 +278,3 @@\n+      } else if (proj_in->Opcode() == Op_Tuple) {\n+        \/\/ The call will be folded, skip over it.\n+        break;\n@@ -2021,0 +2024,1 @@\n+        \/\/ TODO 8350865 Can we re-enable this?\n@@ -2176,1 +2180,0 @@\n-\n@@ -2269,0 +2272,14 @@\n+    \/\/ Fold loads of the field map\n+    if (UseAltSubstitutabilityMethod && tinst != nullptr) {\n+      ciInstanceKlass* ik = tinst->instance_klass();\n+      int offset = tinst->offset();\n+      if (ik == phase->C->env()->Class_klass()) {\n+        ciType* t = tinst->java_mirror_type();\n+        if (t != nullptr && t->is_inlinetype() && offset == t->as_inline_klass()->field_map_offset()) {\n+          ciConstant map = t->as_inline_klass()->get_field_map();\n+          bool is_narrow_oop = (bt == T_NARROWOOP);\n+          return Type::make_from_constant(map, true, 1, is_narrow_oop);\n+        }\n+      }\n+    }\n+\n@@ -2319,1 +2336,4 @@\n-      if (tkls->offset() == in_bytes(ObjArrayKlass::next_refined_array_klass_offset()) && klass->is_obj_array_klass()) {\n+      if (klass->is_inlinetype() && tkls->offset() == in_bytes(InstanceKlass::acmp_maps_offset_offset())) {\n+        return TypeInt::make(klass->as_inline_klass()->field_map_offset());\n+      }\n+      if (klass->is_obj_array_klass() && tkls->offset() == in_bytes(ObjArrayKlass::next_refined_array_klass_offset())) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -201,0 +201,1 @@\n+  \/\/ TODO 8350865 Still needed? Yes, I think this is from PhaseMacroExpand::expand_mh_intrinsic_return\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1998,1 +1998,0 @@\n-  assert(!stopped(), \"null input should have been caught earlier\");\n@@ -2122,13 +2121,4 @@\n-    if (_gvn.type(right)->is_zero_type() ||\n-        (right->is_InlineType() && _gvn.type(right->as_InlineType()->get_null_marker())->is_zero_type())) {\n-      \/\/ Null checking a scalarized but nullable inline type. Check the null marker\n-      \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n-      Node* cmp = CmpI(left->as_InlineType()->get_null_marker(), intcon(0));\n-      do_if(btest, cmp);\n-      return;\n-    } else {\n-      PreserveReexecuteState preexecs(this);\n-      inc_sp(2);\n-      jvms()->set_should_reexecute(true);\n-      left = left->as_InlineType()->buffer(this)->get_oop();\n-    }\n+    PreserveReexecuteState preexecs(this);\n+    inc_sp(2);\n+    jvms()->set_should_reexecute(true);\n+    left = left->as_InlineType()->buffer(this);\n@@ -2140,1 +2130,1 @@\n-    right = right->as_InlineType()->buffer(this)->get_oop();\n+    right = right->as_InlineType()->buffer(this);\n@@ -2250,1 +2240,2 @@\n-  Node* null_ctl;\n+  Node* null_ctl = nullptr;\n+  Node* not_null_left = nullptr;\n@@ -2254,20 +2245,24 @@\n-  \/\/ First operand is non-null, check if it is an inline type\n-  Node* is_value = inline_type_test(not_null_right);\n-  IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);\n-  Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));\n-  ne_region->init_req(2, not_value);\n-  set_control(_gvn.transform(new IfTrueNode(is_value_iff)));\n-\n-  \/\/ The first operand is an inline type, check if the second operand is non-null\n-  Node* not_null_left = acmp_null_check(left, tleft, left_ptr, null_ctl);\n-  ne_region->init_req(3, null_ctl);\n-\n-  \/\/ Check if both operands are of the same class.\n-  Node* kls_left = load_object_klass(not_null_left);\n-  Node* kls_right = load_object_klass(not_null_right);\n-  Node* kls_cmp = CmpP(kls_left, kls_right);\n-  Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));\n-  IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);\n-  Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));\n-  set_control(_gvn.transform(new IfFalseNode(kls_iff)));\n-  ne_region->init_req(4, kls_ne);\n+  if (!stopped()) {\n+    \/\/ First operand is non-null, check if it is an inline type\n+    Node* is_value = inline_type_test(not_null_right);\n+    IfNode* is_value_iff = create_and_map_if(control(), is_value, PROB_FAIR, COUNT_UNKNOWN);\n+    Node* not_value = _gvn.transform(new IfFalseNode(is_value_iff));\n+    ne_region->init_req(2, not_value);\n+    set_control(_gvn.transform(new IfTrueNode(is_value_iff)));\n+\n+    \/\/ The first operand is an inline type, check if the second operand is non-null\n+    not_null_left = acmp_null_check(left, tleft, left_ptr, null_ctl);\n+    ne_region->init_req(3, null_ctl);\n+\n+    if (!stopped()) {\n+      \/\/ Check if both operands are of the same class.\n+      Node* kls_left = load_object_klass(not_null_left);\n+      Node* kls_right = load_object_klass(not_null_right);\n+      Node* kls_cmp = CmpP(kls_left, kls_right);\n+      Node* kls_bol = _gvn.transform(new BoolNode(kls_cmp, BoolTest::ne));\n+      IfNode* kls_iff = create_and_map_if(control(), kls_bol, PROB_FAIR, COUNT_UNKNOWN);\n+      Node* kls_ne = _gvn.transform(new IfTrueNode(kls_iff));\n+      set_control(_gvn.transform(new IfFalseNode(kls_iff)));\n+      ne_region->init_req(4, kls_ne);\n+    }\n+  }\n@@ -2308,1 +2303,1 @@\n-  CallStaticJavaNode *call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method);\n+  CallStaticJavaNode* call = new CallStaticJavaNode(C, TypeFunc::make(subst_method), SharedRuntime::get_resolve_static_call_stub(), subst_method);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1032,1 +1032,1 @@\n-  const int max_live_nodes_increase_per_iteration = NodeLimitFudgeFactor * 3;\n+  const int max_live_nodes_increase_per_iteration = NodeLimitFudgeFactor * 5;\n@@ -2674,0 +2674,1 @@\n+      \/\/ TODO 8350865 Still needed? Yes, I think this is from PhaseMacroExpand::expand_mh_intrinsic_return\n@@ -2677,0 +2678,9 @@\n+      \/\/ Search for CmpL(OrL(CastP2X(..), CastP2X(..)), 0L)\n+      if (u->Opcode() == Op_OrL) {\n+        for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {\n+          Node* cmp = u->fast_out(i3);\n+          if (cmp->Opcode() == Op_CmpL) {\n+            worklist.push(cmp);\n+          }\n+        }\n+      }\n@@ -3105,0 +3115,1 @@\n+\/\/ TODO 8350865 Still needed? Yes, I think this is from PhaseMacroExpand::expand_mh_intrinsic_return\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"opto\/convertnode.hpp\"\n@@ -927,5 +929,23 @@\n-  Node* a = nullptr;\n-  Node* b = nullptr;\n-  if (is_double_null_check(phase, a, b) && (phase->type(a)->is_zero_type() || phase->type(b)->is_zero_type())) {\n-    \/\/ Degraded to a simple null check, use old acmp\n-    return new CmpPNode(a, b);\n+  \/\/ Optimize expressions like\n+  \/\/   CmpL(OrL(CastP2X(..), CastP2X(..)), 0L)\n+  \/\/ that are used by acmp to implement a \"both operands are null\" check.\n+  \/\/ See also the corresponding code in CmpPNode::Ideal.\n+  if (can_reshape && in(1)->Opcode() == Op_OrL &&\n+      in(2)->bottom_type()->is_zero_type()) {\n+    for (int i = 1; i <= 2; ++i) {\n+      Node* orIn = in(1)->in(i);\n+      if (orIn->Opcode() == Op_CastP2X) {\n+        Node* castIn = orIn->in(1);\n+        if (castIn->is_InlineType()) {\n+          \/\/ Replace the CastP2X by the null marker\n+          InlineTypeNode* vt = castIn->as_InlineType();\n+          Node* nm = phase->transform(new ConvI2LNode(vt->get_null_marker()));\n+          phase->is_IterGVN()->replace_input_of(in(1), i, nm);\n+          return this;\n+        } else if (!phase->type(castIn)->maybe_null()) {\n+          \/\/ Never null. Replace the CastP2X by constant 1L.\n+          phase->is_IterGVN()->replace_input_of(in(1), i, phase->longcon(1));\n+          return this;\n+        }\n+      }\n+    }\n@@ -943,25 +963,0 @@\n-\/\/ Match double null check emitted by Compile::optimize_acmp()\n-bool CmpLNode::is_double_null_check(PhaseGVN* phase, Node*& a, Node*& b) const {\n-  if (in(1)->Opcode() == Op_OrL &&\n-      in(1)->in(1)->Opcode() == Op_CastP2X &&\n-      in(1)->in(2)->Opcode() == Op_CastP2X &&\n-      in(2)->bottom_type()->is_zero_type()) {\n-    assert(Arguments::is_valhalla_enabled(), \"unexpected double null check\");\n-    a = in(1)->in(1)->in(1);\n-    b = in(1)->in(2)->in(1);\n-    return true;\n-  }\n-  return false;\n-}\n-\n-\/\/------------------------------Value------------------------------------------\n-const Type* CmpLNode::Value(PhaseGVN* phase) const {\n-  Node* a = nullptr;\n-  Node* b = nullptr;\n-  if (is_double_null_check(phase, a, b) && (!phase->type(a)->maybe_null() || !phase->type(b)->maybe_null())) {\n-    \/\/ One operand is never nullptr, emit constant false\n-    return TypeInt::CC_GT;\n-  }\n-  return SubNode::Value(phase);\n-}\n-\n@@ -1221,0 +1216,15 @@\n+  if (in(1)->is_InlineType() || in(2)->is_InlineType()) {\n+    \/\/ If one operand is an inline type, convert this to a \"both operands are null\" check:\n+    \/\/   CmpL(OrL(CastP2X(..), CastP2X(..)), 0L)\n+    \/\/ CmpLNode::Ideal might optimize this further to avoid keeping buffer allocations alive.\n+    Node* input[2];\n+    for (int i = 1; i <= 2; ++i) {\n+      if (in(i)->is_InlineType()) {\n+        input[i-1] = phase->transform(new ConvI2LNode(in(i)->as_InlineType()->get_null_marker()));\n+      } else {\n+        input[i-1] = phase->transform(new CastP2XNode(nullptr, in(i)));\n+      }\n+    }\n+    Node* orL = phase->transform(new OrXNode(input[0], input[1]));\n+    return new CmpXNode(orL, phase->MakeConX(0));\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -221,1 +221,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -223,1 +222,0 @@\n-  bool is_double_null_check(PhaseGVN* phase, Node*& a, Node*& b) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1412,29 +1412,37 @@\n-      \/\/ This method assumes a and b are not null and their are both instances of the same value class\n-      final Unsafe U = UNSAFE;\n-      int[] map = U.getFieldMap(a.getClass());\n-      int nbNonRef = map[0];\n-      for (int i = 0; i < nbNonRef; i++) {\n-        int offset = map[i * 2 + 1];\n-        int size = map[i * 2 + 2];\n-        int nlong = size \/ 8;\n-        for (int j = 0; j < nlong; j++) {\n-          long la = U.getLong(a, offset);\n-          long lb = U.getLong(b, offset);\n-          if (la != lb) return false;\n-          offset += 8;\n-        }\n-        size -= nlong * 8;\n-        int nint = size \/ 4;\n-        for (int j = 0; j < nint; j++) {\n-          int ia = U.getInt(a, offset);\n-          int ib = U.getInt(b, offset);\n-          if (ia != ib) return false;\n-          offset += 4;\n-        }\n-        size -= nint * 4;\n-        int nshort = size \/ 2;\n-        for (int j = 0; j < nshort; j++) {\n-          short sa = U.getShort(a, offset);\n-          short sb = U.getShort(b, offset);\n-          if (sa != sb) return false;\n-          offset += 2;\n+        \/\/ This method assumes a and b are not null and they are both instances of the same value class\n+        final Unsafe U = UNSAFE;\n+        int[] map = U.getFieldMap(a.getClass());\n+        int nbNonRef = map[0];\n+        for (int i = 0; i < nbNonRef; i++) {\n+            int offset = map[i * 2 + 1];\n+            int size = map[i * 2 + 2];\n+            int nlong = size \/ 8;\n+            for (int j = 0; j < nlong; j++) {\n+                long la = U.getLong(a, offset);\n+                long lb = U.getLong(b, offset);\n+                if (la != lb) return false;\n+                offset += 8;\n+            }\n+            size -= nlong * 8;\n+            int nint = size \/ 4;\n+            for (int j = 0; j < nint; j++) {\n+                int ia = U.getInt(a, offset);\n+                int ib = U.getInt(b, offset);\n+                if (ia != ib) return false;\n+                offset += 4;\n+            }\n+            size -= nint * 4;\n+            int nshort = size \/ 2;\n+            for (int j = 0; j < nshort; j++) {\n+                short sa = U.getShort(a, offset);\n+                short sb = U.getShort(b, offset);\n+                if (sa != sb) return false;\n+                offset += 2;\n+            }\n+            size -= nshort * 2;\n+            for (int j = 0; j < size; j++) {\n+                byte ba = U.getByte(a, offset);\n+                byte bb = U.getByte(b, offset);\n+                if (ba != bb) return false;\n+                offset++;\n+            }\n@@ -1442,6 +1450,5 @@\n-        size -= nshort * 2;\n-        for (int j = 0; j < size; j++) {\n-          byte ba = U.getByte(a, offset);\n-          byte bb = U.getByte(b, offset);\n-          if (ba != bb) return false;\n-          offset++;\n+        for (int i = nbNonRef * 2 + 1; i < map.length; i++) {\n+            int offset = map[i];\n+            Object oa = U.getReference(a, offset);\n+            Object ob = U.getReference(b, offset);\n+            if (oa != ob) return false;\n@@ -1449,8 +1456,1 @@\n-      }\n-      for (int i = nbNonRef * 2 + 1; i < map.length; i++) {\n-        int offset = map[i];\n-        Object oa = U.getReference(a, offset);\n-        Object ob = U.getReference(b, offset);\n-        if (oa != ob) return false;\n-      }\n-      return true;\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -4425,0 +4425,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,5 +72,0 @@\n-    public static final String SUBSTITUTABILITY_TEST = PREFIX + \"SUBSTITUTABILITY_TEST\" + POSTFIX;\n-    static {\n-        IRNode.staticCallOfMethodNodes(SUBSTITUTABILITY_TEST, InlineTypeRegexes.VALUE_OBJECT_METHODS_IS_SUBSTITUTABLE);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeIRNode.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-    public static final String VALUE_OBJECT_METHODS_IS_SUBSTITUTABLE = \"java.lang.runtime.ValueObjectMethods::isSubstitutable\";\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,462 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correctness of acmp\/substitutability with edge case values.\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAcmpEdgeCases\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:+UseFieldFlattening\n+ *                   compiler.valhalla.inlinetypes.TestAcmpEdgeCases\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:-UseFieldFlattening\n+ *                   compiler.valhalla.inlinetypes.TestAcmpEdgeCases\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestAcmpEdgeCases {\n+\n+    static value class ByteValue {\n+        byte value;\n+\n+        static final byte[] EDGE_CASES = {\n+                (byte)0, (byte)-1, (byte)1, (byte)Utils.getRandomInstance().nextInt(),\n+                Byte.MIN_VALUE, Byte.MAX_VALUE\n+        };\n+\n+        public ByteValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"ByteValue(\" + value +\n+                   \", bits=0x\" + Integer.toHexString(value & 0xFF) + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    static value class BooleanValue {\n+        boolean value;\n+\n+        static final boolean[] EDGE_CASES = {\n+                false, true\n+        };\n+\n+        public BooleanValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"BooleanValue(\" + value +\n+                   \", bits=\" + (value ? \"1\" : \"0\") + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    static value class CharValue {\n+        char value;\n+\n+        static final char[] EDGE_CASES = {\n+                (char)0,\n+                (char)1,\n+                (char)0xFFFF,\n+                Character.MIN_VALUE,\n+                Character.MAX_VALUE,\n+                (char)Utils.getRandomInstance().nextInt()\n+        };\n+\n+        public CharValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"CharValue(\" + (int)value +\n+                   \", bits=0x\" + Integer.toHexString(value) + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    static value class ShortValue {\n+        short value;\n+\n+        static final short[] EDGE_CASES = {\n+                (short)0, (short)-1, (short)1,\n+                Short.MIN_VALUE, Short.MAX_VALUE,\n+                (short)Utils.getRandomInstance().nextInt()\n+        };\n+\n+        public ShortValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"ShortValue(\" + value +\n+                   \", bits=0x\" + Integer.toHexString(value & 0xFFFF) + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    static value class IntValue {\n+        int value;\n+\n+        static final int[] EDGE_CASES = {\n+                0, -1, 1,\n+                Integer.MIN_VALUE, Integer.MAX_VALUE,\n+                Utils.getRandomInstance().nextInt()\n+        };\n+\n+        public IntValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"IntValue(\" + value +\n+                   \", bits=0x\" + Integer.toHexString(value) + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    static value class LongValue {\n+        long value;\n+\n+        static final long[] EDGE_CASES = {\n+                0L, -1L, 1L,\n+                Long.MIN_VALUE, Long.MAX_VALUE,\n+                Utils.getRandomInstance().nextLong()\n+        };\n+\n+        public LongValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"LongValue(\" + value +\n+                   \", bits=0x\" + Long.toHexString(value) + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    static value class FloatValue {\n+        float value;\n+\n+        static final float[] EDGE_CASES = {\n+                +0.0f, -0.0f,\n+                Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY,\n+                Float.NaN,\n+                Float.MIN_VALUE, -Float.MIN_VALUE,\n+                Float.MAX_VALUE, -Float.MAX_VALUE,\n+                Float.intBitsToFloat(0x00800000), \/\/ smallest normal\n+                Float.intBitsToFloat(0x80800000),\n+                Float.intBitsToFloat(0x007FFFFF), \/\/ largest subnormal\n+                Float.intBitsToFloat(0x807FFFFF),\n+                Float.intBitsToFloat(0x7FC00000), \/\/ quiet NaN\n+                Float.intBitsToFloat(0x7F800001), \/\/ signaling NaN\n+                Float.intBitsToFloat(0x7FFFFFFF), \/\/ max payload\n+                Float.intBitsToFloat(0xFFC00000), \/\/ negative quiet\n+                Float.intBitsToFloat(0xFF800001), \/\/ negative signaling\n+                Float.intBitsToFloat(0xFFFFFFFF),  \/\/ negative max payload\n+                Utils.getRandomInstance().nextFloat()\n+        };\n+\n+        public FloatValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            int bits = Float.floatToRawIntBits(value);\n+            return \"FloatValue(\" + value +\n+                   \", bits=0x\" + Integer.toHexString(bits) + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return Float.floatToRawIntBits(EDGE_CASES[i]) == Float.floatToRawIntBits(EDGE_CASES[j]);\n+        }\n+    }\n+\n+    static value class DoubleValue {\n+        double value;\n+\n+        static final double[] EDGE_CASES = {\n+                +0.0, -0.0,\n+                Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,\n+                Double.NaN,\n+                Double.MIN_VALUE, -Double.MIN_VALUE,\n+                Double.MAX_VALUE, -Double.MAX_VALUE,\n+                Double.longBitsToDouble(0x0010000000000000L), \/\/ smallest normal\n+                Double.longBitsToDouble(0x8010000000000000L),\n+                Double.longBitsToDouble(0x000FFFFFFFFFFFFFL), \/\/ largest subnormal\n+                Double.longBitsToDouble(0x800FFFFFFFFFFFFFL),\n+                Double.longBitsToDouble(0x7FF8000000000000L), \/\/ quiet NaN\n+                Double.longBitsToDouble(0x7FF0000000000001L), \/\/ signaling NaN\n+                Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL), \/\/ max payload\n+                Double.longBitsToDouble(0xFFF8000000000000L), \/\/ negative quiet NaN\n+                Double.longBitsToDouble(0xFFF0000000000001L), \/\/ negative signaling\n+                Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL), \/\/ negative max payload\n+                Utils.getRandomInstance().nextDouble()\n+        };\n+\n+        public DoubleValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            long bits = Double.doubleToRawLongBits(value);\n+            return \"DoubleValue(\" + value +\n+                   \", bits=0x\" + Long.toHexString(bits) + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return Double.doubleToRawLongBits(EDGE_CASES[i]) == Double.doubleToRawLongBits(EDGE_CASES[j]);\n+        }\n+    }\n+\n+    static value class ObjectValue {\n+        Object value;\n+\n+        static final Object[] EDGE_CASES = {\n+                null, 42, new LongValue(0), new IntValue(5), new Object()\n+        };\n+\n+        public ObjectValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"ObjectValue(\" + value + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    static value class NestedValue {\n+        IntValue value;\n+\n+        static final IntValue[] EDGE_CASES = {\n+                null, new IntValue(0), new IntValue(1), new IntValue(2),\n+                new IntValue(3), new IntValue(4), new IntValue(5)\n+        };\n+\n+        public NestedValue(int index) {\n+            value = EDGE_CASES[index];\n+        }\n+\n+        public String toString() {\n+            return \"NestedValue(\" + value + \")\";\n+        }\n+\n+        static boolean cmp(int i, int j) {\n+            return EDGE_CASES[i] == EDGE_CASES[j];\n+        }\n+    }\n+\n+    public static boolean testByteValue(ByteValue v1, ByteValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testBooleanValue(BooleanValue v1, BooleanValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testCharValue(CharValue v1, CharValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testShortValue(ShortValue v1, ShortValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testIntValue(IntValue v1, IntValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testLongValue(LongValue v1, LongValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testFloatValue(FloatValue v1, FloatValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testDoubleValue(DoubleValue v1, DoubleValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testObjectValue(ObjectValue v1, ObjectValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static boolean testNestedValue(NestedValue v1, NestedValue v2) {\n+        return v1 == v2;\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        for (int k = 0; k < 10_000; ++k) {\n+            \/\/ ByteValue\n+            for (int i = 0; i < ByteValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < ByteValue.EDGE_CASES.length; ++j) {\n+                    ByteValue val1 = new ByteValue(i);\n+                    ByteValue val2 = new ByteValue(j);\n+                    boolean res = testByteValue(val1, val2);\n+                    if (res != (ByteValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ BooleanValue\n+            for (int i = 0; i < BooleanValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < BooleanValue.EDGE_CASES.length; ++j) {\n+                    BooleanValue val1 = new BooleanValue(i);\n+                    BooleanValue val2 = new BooleanValue(j);\n+                    boolean res = testBooleanValue(val1, val2);\n+                    if (res != (BooleanValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ CharValue\n+            for (int i = 0; i < CharValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < CharValue.EDGE_CASES.length; ++j) {\n+                    CharValue val1 = new CharValue(i);\n+                    CharValue val2 = new CharValue(j);\n+                    boolean res = testCharValue(val1, val2);\n+                    if (res != (CharValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ ShortValue\n+            for (int i = 0; i < ShortValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < ShortValue.EDGE_CASES.length; ++j) {\n+                    ShortValue val1 = new ShortValue(i);\n+                    ShortValue val2 = new ShortValue(j);\n+                    boolean res = testShortValue(val1, val2);\n+                    if (res != (ShortValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ IntValue\n+            for (int i = 0; i < IntValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < IntValue.EDGE_CASES.length; ++j) {\n+                    IntValue val1 = new IntValue(i);\n+                    IntValue val2 = new IntValue(j);\n+                    boolean res = testIntValue(val1, val2);\n+                    if (res != (IntValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ LongValue\n+            for (int i = 0; i < LongValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < LongValue.EDGE_CASES.length; ++j) {\n+                    LongValue val1 = new LongValue(i);\n+                    LongValue val2 = new LongValue(j);\n+                    boolean res = testLongValue(val1, val2);\n+                    if (res != (LongValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ FloatValue\n+            for (int i = 0; i < FloatValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < FloatValue.EDGE_CASES.length; ++j) {\n+                    FloatValue val1 = new FloatValue(i);\n+                    FloatValue val2 = new FloatValue(j);\n+                    boolean res = testFloatValue(val1, val2);\n+                    if (res != (FloatValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ DoubleValue\n+            for (int i = 0; i < DoubleValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < DoubleValue.EDGE_CASES.length; ++j) {\n+                    DoubleValue val1 = new DoubleValue(i);\n+                    DoubleValue val2 = new DoubleValue(j);\n+                    boolean res = testDoubleValue(val1, val2);\n+                    if (res != (DoubleValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ ObjectValue\n+            for (int i = 0; i < ObjectValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < ObjectValue.EDGE_CASES.length; ++j) {\n+                    ObjectValue val1 = new ObjectValue(i);\n+                    ObjectValue val2 = new ObjectValue(j);\n+                    boolean res = testObjectValue(val1, val2);\n+                    if (res != (ObjectValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+\n+            \/\/ NestedValue\n+            for (int i = 0; i < NestedValue.EDGE_CASES.length; ++i) {\n+                for (int j = 0; j < NestedValue.EDGE_CASES.length; ++j) {\n+                    NestedValue val1 = new NestedValue(i);\n+                    NestedValue val2 = new NestedValue(j);\n+                    boolean res = testNestedValue(val1, val2);\n+                    if (res != (NestedValue.cmp(i, j))) {\n+                        throw new RuntimeException(\"Incorrect result '\" + res + \"' for \" + val1 + \" == \" + val2);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAcmpEdgeCases.java","additions":462,"deletions":0,"binary":false,"changes":462,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n- * @key randomness\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAcmpStressUnstableIf.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static compiler.lib.ir_framework.IRNode.LOAD;\n@@ -46,1 +47,0 @@\n-import static compiler.valhalla.inlinetypes.InlineTypeIRNode.LOAD_OF_ANY_KLASS;\n@@ -174,1 +174,2 @@\n-                             \"-XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=000\")\n+                             \"-XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=000\",\n+                             \"-XX:+UseAltSubstitutabilityMethod\")\n@@ -2069,1 +2070,1 @@\n-    @IR(failOn = {CALL_UNSAFE, LOAD_KLASS, LOAD_OF_ANY_KLASS})\n+    @IR(failOn = {CALL_UNSAFE, LOAD_KLASS, LOAD})\n@@ -2095,1 +2096,1 @@\n-    @IR(failOn = {CALL_UNSAFE, LOAD_KLASS, LOAD_OF_ANY_KLASS})\n+    @IR(failOn = {CALL_UNSAFE, LOAD_KLASS, LOAD})\n@@ -2121,1 +2122,1 @@\n-    @IR(failOn = {CALL_UNSAFE, LOAD_KLASS, LOAD_OF_ANY_KLASS})\n+    @IR(failOn = {CALL_UNSAFE, LOAD_KLASS, LOAD})\n@@ -2130,0 +2131,43 @@\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE, LOAD_KLASS, LOAD})\n+    public int test95() {\n+        int res = 0;\n+        int[] map = U.getFieldMap(MyValue1.class);\n+        for (int i = 0; i < map.length; i++) {\n+            res += map[1];\n+        }\n+        return res;\n+    }\n+\n+    static int test95ExpectedResult = -1;\n+\n+    @Run(test = \"test95\")\n+    public void test95_verifier() {\n+        if (test95ExpectedResult == -1) {\n+            test95ExpectedResult = test95();\n+        }\n+        Asserts.assertEQ(test95(), test95ExpectedResult);\n+    }\n+\n+    @Test\n+    @IR(failOn = {CALL_UNSAFE})\n+    public int test96(Object obj) {\n+        int res = 0;\n+        int[] map = U.getFieldMap(obj.getClass());\n+        for (int i = 0; i < map.length; i++) {\n+            res += map[1];\n+        }\n+        return res;\n+    }\n+\n+    static int test96ExpectedResult = -1;\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        if (test96ExpectedResult == -1) {\n+            test96ExpectedResult = test96(v);\n+        }\n+        Asserts.assertEQ(test96(v), test96ExpectedResult);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":49,"deletions":5,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import static compiler.valhalla.inlinetypes.InlineTypeIRNode.SUBSTITUTABILITY_TEST;\n@@ -55,0 +54,1 @@\n+import static compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD;\n@@ -56,0 +56,2 @@\n+import static compiler.lib.ir_framework.IRNode.LOAD;\n+import static compiler.lib.ir_framework.IRNode.STORE;\n@@ -61,0 +63,1 @@\n+import static compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD;\n@@ -154,1 +157,2 @@\n-@ForceCompileClassInitializer\n+\/\/ TODO 8373598 Re-enable\n+\/\/@ForceCompileClassInitialize\n@@ -3710,1 +3714,1 @@\n-    @IR(failOn = SUBSTITUTABILITY_TEST)\n+    @IR(failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n@@ -3724,1 +3728,1 @@\n-    @IR(failOn = {SUBSTITUTABILITY_TEST})\n+    @IR(failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n@@ -4019,2 +4023,1 @@\n-    \/\/ TODO 8228361\n-    \/\/ @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n@@ -4034,2 +4037,1 @@\n-    \/\/ TODO 8228361\n-    \/\/ @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n@@ -4235,2 +4237,2 @@\n-    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n-        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    @IR(failOn = {DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n@@ -4260,2 +4262,2 @@\n-    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n-        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    @IR(failOn = {DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n@@ -4855,0 +4857,401 @@\n+\n+    static final MyClass152 MY_NON_VALUE = new MyClass152(rI);\n+    static final int[] MY_ARRAY = new int[0];\n+\n+    @LooselyConsistentValue\n+    static value class AllPrimitives {\n+        boolean boolValue;\n+        byte byteValue;\n+        short shortValue;\n+        int intValue;\n+        long longValue;\n+        char charValue;\n+        float floatValue;\n+        double doubleValue;\n+\n+        MyClass152 nonValue = MY_NON_VALUE;\n+        int[] array = MY_ARRAY;\n+        Integer integerValue;\n+\n+        public AllPrimitives(int i, Integer integerValue) {\n+            this.boolValue = (rI % 2) == 0;\n+            this.byteValue = (byte) i;\n+            this.shortValue = (short) i;\n+            this.intValue = i;\n+            this.longValue = rL;\n+            this.charValue = (char) i;\n+            this.floatValue = (float) i;\n+            this.doubleValue = rD;\n+            this.integerValue = integerValue;\n+        }\n+\n+        public AllPrimitives(AllPrimitives other, int[] offsets) {\n+            this.boolValue = (offsets[test178Idx++] != 0) ? !other.boolValue : other.boolValue;\n+            this.byteValue = (byte)(other.byteValue + offsets[test178Idx++]);\n+            this.shortValue = (short)(other.shortValue + offsets[test178Idx++]);\n+            this.intValue = other.intValue + offsets[test178Idx++];\n+            this.longValue = other.longValue + offsets[test178Idx++];\n+            this.charValue = (char)(other.charValue + offsets[test178Idx++]);\n+            this.floatValue = (float)(other.floatValue + offsets[test178Idx++]);\n+            this.doubleValue = other.doubleValue + offsets[test178Idx++];\n+            this.integerValue = other.integerValue + offsets[test178Idx++];\n+        }\n+\n+        public String toString() {\n+            return \"AllPrimitives(\" + boolValue + \", \" + byteValue + \", \" + shortValue + \", \" + intValue + \", \" + longValue + \", \" + charValue + \", \" + floatValue + \", \" + doubleValue + \", \" + integerValue + \")\";\n+        }\n+    }\n+\n+    \/\/ Hides the type during parsing when always incrementally inlining\n+    @ForceInline\n+    public Object getter(Object o) {\n+        return o;\n+    }\n+\n+    \/\/ Verify that the substitutability runtime call is removed if (at least) one of the arguments has a known type\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {LOAD, \"= 2\"}) \/\/ Need to load from non-flat 'integerValue' fields\n+    public boolean test174(AllPrimitives x, AllPrimitives y) {\n+        return getter(x) == getter(y);\n+    }\n+\n+    @Run(test = \"test174\")\n+    public void test174_verifier() {\n+        AllPrimitives x = new AllPrimitives(rI, rI);\n+        AllPrimitives y = new AllPrimitives(rI + 1, rI);\n+        AllPrimitives z = new AllPrimitives(rI, null);\n+        Asserts.assertTrue(test174(x, x));\n+        Asserts.assertTrue(test174(z, z));\n+        Asserts.assertTrue(test174(null, null));\n+        Asserts.assertFalse(test174(x, y));\n+        Asserts.assertFalse(test174(x, null));\n+        Asserts.assertFalse(test174(null, x));\n+        Asserts.assertFalse(test174(x, z));\n+        Asserts.assertFalse(test174(z, x));\n+        Asserts.assertFalse(test174(z, new AllPrimitives(rI, 0)));\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE_OF_ANY_KLASS, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n+    public boolean test175(AllPrimitives x, Integer y) {\n+        return getter(x) == getter(y);\n+    }\n+\n+    @Run(test = \"test175\")\n+    public void test175_verifier() {\n+        AllPrimitives x = new AllPrimitives(rI, rI);\n+        Asserts.assertTrue(test175(null, null));\n+        Asserts.assertFalse(test175(x, null));\n+        Asserts.assertFalse(test175(null, 42));\n+        Asserts.assertFalse(test175(x, 42));\n+    }\n+\n+    \/\/ Same as test174 but only one operand has a known type\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {LOAD, \"= 15\"}) \/\/ Need to load the fields from 'y'\n+    public boolean test176(AllPrimitives x, Object y) {\n+        return getter(x) == getter(y);\n+    }\n+\n+    @Run(test = \"test176\")\n+    public void test176_verifier() {\n+        AllPrimitives x = new AllPrimitives(rI, rI);\n+        AllPrimitives y = new AllPrimitives(rI + 1, rI);\n+        AllPrimitives z = new AllPrimitives(rI, null);\n+        Asserts.assertTrue(test176(x, x));\n+        Asserts.assertTrue(test174(z, z));\n+        Asserts.assertTrue(test176(null, null));\n+        Asserts.assertFalse(test176(x, y));\n+        Asserts.assertFalse(test176(x, null));\n+        Asserts.assertFalse(test176(null, x));\n+        Asserts.assertFalse(test176(x, 42));\n+        Asserts.assertFalse(test176(x, z));\n+        Asserts.assertFalse(test176(z, x));\n+        Asserts.assertFalse(test176(z, new AllPrimitives(rI, 0)));\n+    }\n+\n+    \/\/ Same as above but type of 'y' is only known after loop opts\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {LOAD, \"= 14\"}) \/\/ Need to load the fields from 'x'\n+    public boolean test177(Object x, AllPrimitives y) {\n+        Object val = null;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            val = y;\n+        }\n+        return getter(x) == getter(val);\n+    }\n+\n+    @Run(test = \"test177\")\n+    public void test177_verifier() {\n+        AllPrimitives x = new AllPrimitives(rI, rI);\n+        AllPrimitives y = new AllPrimitives(rI + 1, rI);\n+        AllPrimitives z = new AllPrimitives(rI, null);\n+        Asserts.assertTrue(test177(x, x));\n+        Asserts.assertTrue(test174(z, z));\n+        Asserts.assertTrue(test177(null, null));\n+        Asserts.assertFalse(test177(x, y));\n+        Asserts.assertFalse(test177(x, null));\n+        Asserts.assertFalse(test177(null, x));\n+        Asserts.assertFalse(test177(42, x));\n+        Asserts.assertFalse(test177(x, z));\n+        Asserts.assertFalse(test177(z, x));\n+        Asserts.assertFalse(test177(z, new AllPrimitives(rI, 0)));\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Value178_1 {\n+        long l1;\n+        long l2;\n+        @Strict\n+        @NullRestricted\n+        AllPrimitives prims1;\n+        AllPrimitives prims2;\n+        Integer i;\n+\n+        public Value178_1() {\n+            this.l1 = rL;\n+            this.l2 = rL + 1;\n+            this.prims1 = new AllPrimitives(rI, rI);\n+            this.prims2 = new AllPrimitives(rI, rI);\n+            this.i = rI;\n+        }\n+\n+        public Value178_1(Value178_1 other, int[] offsets) {\n+            this.l1 = other.l1 + offsets[test178Idx++];\n+            this.l2 = other.l2 + offsets[test178Idx++];\n+            this.prims1 = new AllPrimitives(other.prims1, offsets);\n+            this.prims2 = (offsets[test178Idx++] != 0) ? null : new AllPrimitives(other.prims2, offsets);\n+            this.i = (offsets[test178Idx++] != 0) ? null : (other.i + offsets[test178Idx++]);\n+        }\n+\n+        public String toString() {\n+            return \"Value178_1(\" + l1 + \", \" + l2 + \", \" + prims1 + \", \" + prims2 + \")\";\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Value178 {\n+        @Strict\n+        @NullRestricted\n+        Value178_1 val1;\n+\n+        Value178_1 val2;\n+\n+        @Strict\n+        @NullRestricted\n+        Value178_1 val3;\n+\n+        Value178_1 val4;\n+\n+        @Strict\n+        @NullRestricted\n+        AllPrimitives prims1;\n+\n+        AllPrimitives prims2;\n+\n+        public Value178() {\n+            this.val1 = new Value178_1();\n+            this.val2 = new Value178_1();\n+            this.val3 = new Value178_1();\n+            this.val4 = new Value178_1();\n+            this.prims1 = new AllPrimitives(rI, rI);\n+            this.prims2 = new AllPrimitives(rI, rI);\n+        }\n+\n+        public Value178(Value178 other, int[] offsets) {\n+            test178Idx = 0;\n+            this.val1 = new Value178_1(other.val1, offsets);\n+            this.val2 = (offsets[test178Idx++] != 0) ? null : new Value178_1(other.val2, offsets);\n+            this.val3 = new Value178_1(other.val3, offsets);\n+            this.val4 = (offsets[test178Idx++] != 0) ? null : new Value178_1(other.val4, offsets);\n+            this.prims1 = new AllPrimitives(other.prims1, offsets);\n+            this.prims2 = (offsets[test178Idx++] != 0) ? null : new AllPrimitives(other.prims2, offsets);\n+        }\n+\n+        public String toString() {\n+            return \"Value178(\" + val1 + \", \" + val2 + \", \" + val3 + \", \" + val4 + \", \" + prims1 + \", \" + prims2 + \")\";\n+        }\n+    }\n+\n+    static int test178Idx = 0;\n+\n+    static Value178[] test178Values;\n+\n+    static {\n+        Value178 defVal = new Value178();\n+\n+        \/\/ The 'offset' array is used to modify exactly one of the fields in Value178\n+        int[] offsets = new int[113];\n+        Value178 val2 = new Value178(defVal, offsets);\n+        Asserts.assertEquals(offsets.length, test178Idx);\n+        Asserts.assertEquals(defVal, val2);\n+\n+        test178Values = new Value178[offsets.length];\n+        for (int i = 0; i < offsets.length; ++i) {\n+            offsets[i] = 1;\n+            if (i > 0) {\n+                offsets[i-1] = 0;\n+            }\n+            test178Values[i] = new Value178(defVal, offsets);\n+        }\n+    }\n+\n+    \/\/ Test acmp with deep nesting of flat fields\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n+    public boolean test178(Value178 x, Value178 y) {\n+        return getter(x) == getter(y);\n+    }\n+\n+    @Run(test = \"test178\")\n+    public void test178_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Asserts.assertTrue(test178(test178Values[0], test178Values[0]));\n+            Asserts.assertTrue(test178(null, null));\n+            Asserts.assertFalse(test178(test178Values[0], test178Values[1]));\n+        } else {\n+            \/\/ After warmup, check all combinations\n+            for (int i = 0; i < test178Values.length; ++i) {\n+                Value178 val1 = test178Values[i];\n+                Asserts.assertTrue(test178(val1, val1), \"i = \" + i + \": \" + val1 + \" should be equal to itself\");\n+                for (int j = 0; j < test178Values.length; ++j) {\n+                    Value178 val2 = test178Values[j];\n+                    if (i == j) {\n+                        Asserts.assertTrue(test178(val1, val2), \"i = \" + i + \": \" + val1 + \" should be equal to \" + val2);\n+                    } else {\n+                        \/\/ Verify that the modification of one field is detected\n+                        Asserts.assertFalse(test178(val1, val2), \"i = \" + i + \": \" + val1 + \" should not be equal to \" + val2);\n+                        Asserts.assertFalse(test178(val2, val1), \"i = \" + i + \": \" + val2 + \" should not be equal to \" + val1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test178 but with object argument\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n+    public boolean test179(Value178 x, Object y) {\n+        return getter(x) == getter(y);\n+    }\n+\n+    @Run(test = \"test179\")\n+    public void test179_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Asserts.assertTrue(test179(test178Values[0], test178Values[0]));\n+            Asserts.assertTrue(test179(null, null));\n+            Asserts.assertFalse(test179(test178Values[0], test178Values[1]));\n+        } else {\n+            \/\/ After warmup, check all combinations\n+            for (int i = 0; i < test178Values.length; ++i) {\n+                Value178 val1 = test178Values[i];\n+                Asserts.assertTrue(test179(val1, val1), \"i = \" + i + \": \" + val1 + \" should be equal to itself\");\n+                for (int j = 0; j < test178Values.length; ++j) {\n+                    Value178 val2 = test178Values[j];\n+                    if (i == j) {\n+                        Asserts.assertTrue(test179(val1, val2), \"i = \" + i + \": \" + val1 + \" should be equal to \" + val2);\n+                    } else {\n+                        \/\/ Verify that the modification of one field is detected\n+                        Asserts.assertFalse(test179(val1, val2), \"i = \" + i + \": \" + val1 + \" should not be equal to \" + val2);\n+                        Asserts.assertFalse(test179(val2, val1), \"i = \" + i + \": \" + val2 + \" should not be equal to \" + val1);\n+                    }\n+                }\n+            }\n+        }\n+        Asserts.assertFalse(test179(test178Values[0], 42));\n+    }\n+\n+    static final Value178 op1 = test178Values[Math.abs(rI) % test178Values.length];\n+    static final Value178 op2 = op1;\n+    static final Value178 op3 = new Value178();\n+\n+    \/\/ Test constant folding\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD, STORE, STATIC_CALL_OF_METHOD, \"isSubstitutable\"})\n+    public boolean test180() {\n+        Object val1 = null;\n+        Object val2 = null;\n+        Object val3 = null;\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            val1 = op1;\n+            val2 = op2;\n+            val3 = op3;\n+        }\n+        boolean b1 = (val1 == val2);\n+        boolean b2 = (val2 == val1);\n+        boolean b3 = (val1 != val3);\n+        boolean b4 = (val3 != val1);\n+        return b1 && b2 && b3 && b4;\n+    }\n+\n+    @Run(test = \"test180\")\n+    public void test180_verifier() {\n+        Asserts.assertTrue(test180());\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Value181 {\n+        Object obj;\n+\n+        public Value181(Object obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    \/\/ Non-optimizable case because the object field would require another substitutability check\n+    @Test\n+    @IR(counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n+    public boolean test181(Value181 val1, Value181 val2) {\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test181\")\n+    public void test181_verifier() {\n+        Value181 val1 = new Value181(new Value181(42));\n+        Value181 val2 = new Value181(new Value181(42));\n+        Value181 val3 = new Value181(new Value181(43));\n+        Asserts.assertTrue(test181(val1, val1));\n+        Asserts.assertTrue(test181(val1, val2));\n+        Asserts.assertFalse(test181(val2, val3));\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Value182 {\n+        @Strict\n+        @NullRestricted\n+        Value181 val; \/\/ This will require another substitutability check because it has an Object field\n+\n+        public Value182(Value181 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as test181 but the Object field \"hides\" one level deeper\n+    @Test\n+    @IR(counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n+    public boolean test182(Value182 val1, Value182 val2) {\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test182\")\n+    public void test182_verifier() {\n+        Value182 val1 = new Value182(new Value181(42));\n+        Value182 val2 = new Value182(new Value181(43));\n+        Value182 val3 = new Value182(new Value181(new Value181(42)));\n+        Value182 val4 = new Value182(new Value181(new Value181(42)));\n+        Asserts.assertTrue(test182(val1, val1));\n+        Asserts.assertTrue(test182(val2, val2));\n+        Asserts.assertFalse(test182(val1, val2));\n+        Asserts.assertFalse(test182(val2, val3));\n+        Asserts.assertTrue(test182(val3, val4));\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":415,"deletions":12,"binary":false,"changes":427,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import static compiler.valhalla.inlinetypes.InlineTypeIRNode.SUBSTITUTABILITY_TEST;\n@@ -47,0 +46,1 @@\n+import static compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD;\n@@ -678,1 +678,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -681,1 +681,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -703,1 +703,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -706,1 +706,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -728,1 +728,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -731,1 +731,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -753,1 +753,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -756,1 +756,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -779,1 +779,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -782,1 +782,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -806,1 +806,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -809,1 +809,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -833,1 +833,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -836,1 +836,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -860,1 +860,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -863,1 +863,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -887,1 +887,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", NULL_CHECK_TRAP},\n@@ -890,1 +890,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -915,1 +915,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP})\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", NULL_CHECK_TRAP})\n@@ -917,1 +917,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -943,1 +943,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -946,1 +946,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -971,1 +971,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -974,1 +974,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -999,1 +999,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -1002,1 +1002,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -1027,1 +1027,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -1030,1 +1030,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -1055,1 +1055,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", NULL_CHECK_TRAP},\n@@ -1058,1 +1058,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -1083,1 +1083,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST, NULL_CHECK_TRAP})\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", NULL_CHECK_TRAP})\n@@ -1085,1 +1085,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 1\"})\n@@ -1112,1 +1112,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -1115,1 +1115,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 2\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 2\"})\n@@ -1140,1 +1140,1 @@\n-        failOn = {SUBSTITUTABILITY_TEST},\n+        failOn = {STATIC_CALL_OF_METHOD, \"isSubstitutable\"},\n@@ -1143,1 +1143,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 2\"})\n+        counts = {STATIC_CALL_OF_METHOD, \"isSubstitutable\", \"= 2\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"}]}