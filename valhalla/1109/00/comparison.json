{"files":[{"patch":"@@ -4412,1 +4412,1 @@\n-  \/\/ Inline types are only supported by class file version 61.65535 and later\n+  \/\/ Inline types are only supported by class file version 67.65535 and later\n@@ -4744,1 +4744,0 @@\n-    if (!is_identity)  class_note = \" (a value class)\";\n@@ -4844,1 +4843,0 @@\n-  const bool is_abstract = class_access_flags.is_abstract();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,28 +135,0 @@\n-\/*\n-    \/\/ This code implements non-covariance between inline type arrays and both\n-    \/\/ arrays of objects and arrays of interface types.  If covariance is\n-    \/\/ supported for inline type arrays then this code should be removed.\n-    if (comp_from.is_inline_type() && !comp_this.is_null() && comp_this.is_reference()) {\n-      \/\/ An array of inline types is not assignable to an array of java.lang.Objects.\n-      if (comp_this.name() == vmSymbols::java_lang_Object()) {\n-        return false;\n-      }\n-\n-      \/\/ Need to load 'comp_this' to see if it is an interface.\n-      InstanceKlass* klass = context->current_class();\n-      {\n-        HandleMark hm(THREAD);\n-        Klass* comp_this_class = SystemDictionary::resolve_or_fail(\n-            comp_this.name(), Handle(THREAD, klass->class_loader()),\n-            Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n-        klass->class_loader_data()->record_dependency(comp_this_class);\n-        if (log_is_enabled(Debug, class, resolve)) {\n-          Verifier::trace_class_resolution(comp_this_class, klass);\n-        }\n-        \/\/ An array of inline types is not assignable to an array of interface types.\n-        if (comp_this_class->is_interface()) {\n-          return false;\n-        }\n-      }\n-    }\n-*\/\n@@ -171,39 +143,0 @@\n-bool VerificationType::is_inline_type_assignable_from(const VerificationType& from) const {\n-  \/\/ Check that 'from' is not null, is an inline type, and is the same inline type.\n-  assert(is_inline_type(), \"called with a non-inline type\");\n-  assert(!is_null(), \"inline type is not null\");\n-  return (!from.is_null() && from.is_inline_type() && name() == from.name());\n-}\n-\n-bool VerificationType::is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const {\n-  assert(!from.is_null(), \"Inline type should not be null\");\n-  if (!is_null() && (name()->is_same_fundamental_type(from.name()) ||\n-      name() == vmSymbols::java_lang_Object())) {\n-    return true;\n-  }\n-\n-  \/\/ Need to load 'this' to see if it is an interface or supertype.\n-  InstanceKlass* klass = context->current_class();\n-  {\n-    HandleMark hm(THREAD);\n-    Klass* this_class = SystemDictionary::resolve_or_fail(\n-        name(), Handle(THREAD, klass->class_loader()),\n-        Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n-    klass->class_loader_data()->record_dependency(this_class);\n-    if (log_is_enabled(Debug, class, resolve)) {\n-      Verifier::trace_class_resolution(this_class, klass);\n-    }\n-    if (this_class->is_interface()) {\n-      return true;\n-    } else {\n-      Klass* from_class = SystemDictionary::resolve_or_fail(\n-        from.name(), Handle(THREAD, klass->class_loader()),\n-        Handle(THREAD, klass->protection_domain()), true, CHECK_false);\n-      if (log_is_enabled(Debug, class, resolve)) {\n-        Verifier::trace_class_resolution(from_class, klass);\n-      }\n-      return from_class->is_subclass_of(this_class);\n-    }\n-  }\n-}\n-\n@@ -256,2 +189,0 @@\n-    case InlineTypeQuery:  st->print(\"inline type\"); break;\n-    case NonScalarQuery:   st->print(\"reference or inline type\"); break;\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":1,"deletions":70,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,0 @@\n-      InlineType         = 0x4,        \/\/ _sym contains the name of an inline type\n@@ -87,2 +86,0 @@\n-      InlineTypeFlag     = 0x08,       \/\/ For inline type query types\n-      NonScalarFlag      = 0x10,       \/\/ For either inline type or reference queries\n@@ -121,2 +118,0 @@\n-      InlineTypeQuery    = (InlineTypeFlag    << 1 * BitsPerByte) | TypeQuery,\n-      NonScalarQuery     = (NonScalarFlag     << 1 * BitsPerByte) | TypeQuery\n@@ -155,2 +150,0 @@\n-  static VerificationType inline_type_check()\n-    { return VerificationType(InlineTypeQuery); }\n@@ -163,2 +156,0 @@\n-  static VerificationType nonscalar_check()\n-    { return VerificationType(NonScalarQuery); }\n@@ -179,11 +170,0 @@\n-  \/\/ For inline types, store the actual Symbol* and set the 3rd bit.\n-  \/\/ Provides a way for an inline type to be distinguished from a reference type.\n-  static VerificationType inline_type(Symbol* sh) {\n-      assert(((uintptr_t)sh & TypeMask) == 0, \"Symbols must be aligned\");\n-      assert((uintptr_t)sh != 0, \"Null is not a valid inline type\");\n-      \/\/ If the above assert fails in the future because oop* isn't aligned,\n-      \/\/ then this type encoding system will have to change to have a tag value\n-      \/\/ to discriminate between oops and primitives.\n-      return VerificationType((uintptr_t)sh | InlineType);\n-  }\n-\n@@ -205,2 +185,1 @@\n-  bool is_reference() const { return (((_u._data & TypeMask) == Reference) && !is_inline_type_check()); }\n-  bool is_inline_type() const { return ((_u._data & TypeMask) == InlineType); }\n+  bool is_reference() const { return ((_u._data & TypeMask) == Reference); }\n@@ -224,2 +203,0 @@\n-  bool is_inline_type_check() const { return _u._data == InlineTypeQuery; }\n-  bool is_nonscalar_check() const { return _u._data == NonScalarQuery; }\n@@ -264,6 +241,0 @@\n-  static VerificationType change_ref_to_inline_type(VerificationType ref) {\n-    assert(ref.is_reference(), \"Bad arg\");\n-    assert(!ref.is_null(), \"Unexpected nullptr\");\n-    return inline_type(ref.name());\n-  }\n-\n@@ -276,2 +247,2 @@\n-    assert(!is_null() && (is_reference() || is_inline_type()), \"Must be a non-null reference or an inline type\");\n-    return (is_reference() ? _u._sym : ((Symbol*)(_u._data & ~(uintptr_t)InlineType)));\n+    assert(!is_null() && is_reference(), \"Must be a non-null reference\");\n+    return _u._sym;\n@@ -282,3 +253,2 @@\n-            (((is_reference() && t.is_reference()) ||\n-             (is_inline_type() && t.is_inline_type())) &&\n-              !is_null() && !t.is_null() && name() == t.name()));\n+            (((is_reference() && t.is_reference())) &&\n+             !is_null() && !t.is_null() && name() == t.name()));\n@@ -314,5 +284,0 @@\n-        case NonScalarQuery:\n-          return from.is_reference() || from.is_uninitialized() ||\n-                 from.is_inline_type();\n-        case InlineTypeQuery:\n-          return from.is_inline_type();\n@@ -326,5 +291,1 @@\n-          if (is_inline_type()) {\n-            return is_inline_type_assignable_from(from);\n-          } else if (is_reference() && from.is_inline_type()) {\n-            return is_ref_assignable_from_inline_type(from, context, THREAD);\n-          } else if (is_reference() && from.is_reference()) {\n+          if (is_reference() && from.is_reference()) {\n@@ -378,5 +339,0 @@\n-  bool is_inline_type_assignable_from(const VerificationType& from) const;\n-\n-  bool is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const;\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":7,"deletions":51,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -601,9 +601,0 @@\n-VerificationType reference_or_inline_type(InstanceKlass* klass) {\n-  \/\/ if (klass->is_inline_klass()) {\n-  \/\/   return VerificationType::inline_type(klass->name());\n-  \/\/ } else {\n-  \/\/   return VerificationType::reference_type(klass->name());\n-  \/\/ }  \/\/ LW401 CR required: verifier update\/cleanup\n-  return VerificationType::reference_type(klass->name());\n-}\n-\n@@ -613,1 +604,1 @@\n-  _this_type = reference_or_inline_type(klass);\n+  _this_type = VerificationType::reference_type(klass->name());\n@@ -636,0 +627,5 @@\n+static bool supports_strict_fields(InstanceKlass* klass) {\n+  int ver = klass->major_version();\n+  return ver > Verifier::VALUE_TYPES_MAJOR_VERSION ||\n+         (ver == Verifier::VALUE_TYPES_MAJOR_VERSION && klass->minor_version() == Verifier::JAVA_PREVIEW_MINOR_VERSION);\n+}\n@@ -1057,1 +1053,1 @@\n-          if (!atype.is_nonscalar_array()) {\n+          if (!atype.is_reference_array()) {\n@@ -1235,1 +1231,1 @@\n-          if (!atype.is_nonscalar_array()) {\n+          if (!atype.is_reference_array()) {\n@@ -1635,1 +1631,1 @@\n-            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n+            VerificationType::reference_check(), CHECK_VERIFY(this));\n@@ -1640,1 +1636,1 @@\n-            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n+            VerificationType::reference_check(), CHECK_VERIFY(this));\n@@ -1691,1 +1687,1 @@\n-            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n+            VerificationType::reference_check(), CHECK_VERIFY(this));\n@@ -1790,1 +1786,1 @@\n-            VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n+            VerificationType::reference_check(), CHECK_VERIFY(this));\n@@ -2397,1 +2393,1 @@\n-      \/\/ The JVMS 2nd edition allows field initialization before the superclass\n+      \/\/ Field initialization is allowed before the superclass\n@@ -2400,4 +2396,14 @@\n-      if (stack_object_type == VerificationType::uninitialized_this_type() &&\n-          target_class_type.equals(current_type()) &&\n-          _klass->find_local_field(field_name, field_sig, &fd)) {\n-        stack_object_type = current_type();\n+      bool is_local_field = _klass->find_local_field(field_name, field_sig, &fd) &&\n+                            target_class_type.equals(current_type());\n+      if (stack_object_type == VerificationType::uninitialized_this_type()) {\n+        if (is_local_field) {\n+          \/\/ Set the type to the current type so the is_assignable check passes.\n+          stack_object_type = current_type();\n+        }\n+      } else if (supports_strict_fields(_klass)) {\n+        \/\/ `strict` fields are not writable, but only local fields produce verification errors\n+        if (is_local_field && fd.access_flags().is_strict()) {\n+          verify_error(ErrorContext::bad_code(bci),\n+                       \"Illegal use of putfield on a strict field\");\n+          return;\n+        }\n@@ -3108,1 +3114,1 @@\n-    index, VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n+    index, VerificationType::reference_check(), CHECK_VERIFY(this));\n@@ -3145,1 +3151,1 @@\n-    VerificationType::nonscalar_check(), CHECK_VERIFY(this));\n+    VerificationType::reference_check(), CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":30,"deletions":24,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+    VALUE_TYPES_MAJOR_VERSION           = 67,\n+    JAVA_PREVIEW_MINOR_VERSION          = 65535,\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-\n-\n@@ -4,1 +2,1 @@\n- * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +70,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/IllegalFieldModifiers.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/fieldModifiersTest.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @compile strictFields.jasm\n+ * @run main\/othervm -Xverify:remote StrictFields\n+ *\/\n+\n+public class StrictFields {\n+    public static void main(String[] args) throws Throwable {\n+\n+        \/\/ First load a class where strict should be ignored\n+        Class<?> c = Class.forName(\"StrictIgnore\");\n+\n+        \/\/ Now load a well-formed strict-using value class\n+        c = Class.forName(\"StrictBase\");\n+\n+        \/\/ Now a bad class\n+        try {\n+            c = Class.forName(\"PostInitStrict\");\n+            throw new Error(\"VerifyError was not thrown as expected!\");\n+        } catch (VerifyError ve) {\n+            if (!ve.getMessage().startsWith(\"Illegal use of putfield on a strict field\")) {\n+                throw new Error(\"Wrong VerifyError thrown\", ve);\n+            } else {\n+                System.out.println(\"Expected VerifyError was thrown\");\n+            }\n+        }\n+\n+        \/\/ Now a bad class that tries to write to a super class's strict field\n+        \/\/ in the preinit phase\n+        try {\n+            c = Class.forName(\"BadStrictSubPreInit\");\n+            throw new Error(\"VerifyError was not thrown as expected!\");\n+        } catch (VerifyError ve) {\n+            if (!ve.getMessage().startsWith(\"Bad type on operand stack\")) {\n+                throw new Error(\"Wrong VerifyError thrown\", ve);\n+            } else {\n+                System.out.println(\"Expected VerifyError was thrown\");\n+            }\n+        }\n+\n+        \/\/ Now a bad class that tries to write to a super class's strict field\n+        \/\/ in the post phase. This is not a verification error but we test it\n+        \/\/ here for completeness.Expected exception:\n+        \/\/    java.lang.IllegalAccessError: Update to non-static final field\n+        \/\/      BadStrictSubPostInit.x attempted from a different class\n+        \/\/       (BadStrictSubPostInit) than the field's declaring class\n+        try {\n+            c = Class.forName(\"BadStrictSubPostInit\");\n+            Object o = c.newInstance();\n+            throw new Error(\"IllegalAccessErrorError was not thrown as expected!\");\n+        } catch (IllegalAccessError iae) {\n+            if (!iae.getMessage().startsWith(\"Update to non-static final field\")) {\n+                throw new Error(\"Wrong IllegalAccessError thrown\", iae);\n+            } else {\n+                System.out.println(\"Expected IllegalAccessError was thrown\");\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFields.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Defines the classes used by StrictFields.java to check verification\n+\/\/ of strict fields.\n+\n+\/\/ StrictIgnore is an earlier classfile version for which strict must be ignored\n+\/\/ so we can write to it multiple times in the constructor.\n+public class StrictIgnore version 66:0 {\n+  final strict Field x:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      return;\n+   }\n+}\n+\n+\/\/ StrictBase is a well formed value class with a strict field, that can\n+\/\/ be used for subclassing.\n+public abstract class StrictBase version 67:65535 {\n+  protected final strict Field x:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      return;\n+   }\n+}\n+\n+\/\/ PostInitStrict is a bad value class that writes to a strict field after the\n+\/\/ super constructor call.\n+public final class PostInitStrict version 67:65535 {\n+  final strict Field y:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield y:I;\n+      return;\n+   }\n+}\n+\n+\/\/ BadStrictSubPreInit is a bad value class that tries to write to an inherited\n+\/\/ strict field while acting on UninitializedThis.\n+public final class BadStrictSubPreInit extends StrictBase version 67:65535 {\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method StrictBase.\"<init>\":\"()V\";\n+      return;\n+   }\n+}\n+\n+\/\/ BadStrictSubPostInit is a bad value class that tries to write to an inherited\n+\/\/ strict field in \"regular\" code.\n+public final class BadStrictSubPostInit extends StrictBase version 67:65535 {\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      invokespecial Method StrictBase.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      return;\n+   }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/strictFields.jasm","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}