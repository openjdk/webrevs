{"files":[{"patch":"@@ -228,1 +228,1 @@\n-  Label alloc_failed, empty_value, done;\n+  Label alloc_failed, done;\n@@ -242,3 +242,0 @@\n-  \/\/ check for empty value klass\n-  test_klass_is_empty_inline_type(field_klass, rscratch1, empty_value);\n-\n@@ -259,4 +256,0 @@\n-  bind(empty_value);\n-  get_empty_inline_type_oop(field_klass, alloc_temp, obj);\n-  b(done);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1193,36 +1193,0 @@\n-void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {\n-  assert_different_registers(inline_klass, temp_reg, obj, rscratch2);\n-#ifdef ASSERT\n-  {\n-    Label done_check;\n-    test_klass_is_inline_type(inline_klass, temp_reg, done_check);\n-    stop(\"get_default_value_oop from non inline type klass\");\n-    bind(done_check);\n-  }\n-#endif\n-  Register offset = temp_reg;\n-  \/\/ Getting the offset of the pre-allocated default value\n-  ldr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));\n-  load_sized_value(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())), sizeof(int), true \/*is_signed*\/);\n-\n-  \/\/ Getting the mirror\n-  ldr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));\n-  resolve_oop_handle(obj, inline_klass, rscratch2);\n-\n-  \/\/ Getting the pre-allocated default value from the mirror\n-  Address field(obj, offset);\n-  load_heap_oop(obj, field, inline_klass, rscratch2);\n-}\n-\n-void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {\n-#ifdef ASSERT\n-  {\n-    Label done_check;\n-    test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);\n-    stop(\"get_empty_value from non-empty inline klass\");\n-    bind(done_check);\n-  }\n-#endif\n-  get_default_value_oop(inline_klass, temp_reg, obj);\n-}\n-\n@@ -2318,14 +2282,0 @@\n-void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type) {\n-#ifdef ASSERT\n-  {\n-    Label done_check;\n-    test_klass_is_inline_type(klass, temp_reg, done_check);\n-    stop(\"test_klass_is_empty_inline_type with non inline type klass\");\n-    bind(done_check);\n-  }\n-#endif\n-  ldrw(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n-  andr(temp_reg, temp_reg, InstanceKlassFlags::is_empty_inline_type_value());\n-  cbnz(temp_reg, is_empty_inline_type);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -662,1 +662,0 @@\n-  void test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type);\n@@ -665,6 +664,0 @@\n-  \/\/ Get the default value oop for the given InlineKlass\n-  void get_default_value_oop(Register inline_klass, Register temp_reg, Register obj);\n-  \/\/ The empty value oop, for the given InlineKlass (\"empty\" as in no instance fields)\n-  \/\/ get_default_value_oop with extra assertion for empty inline klass\n-  void get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2783,12 +2783,1 @@\n-          Label slow_case, finish;\n-          __ ldrb(rscratch1, Address(klass, InstanceKlass::init_state_offset()));\n-          __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);\n-          __ br(Assembler::NE, slow_case);\n-          __ get_default_value_oop(klass, off \/* temp *\/, r0);\n-        __ b(finish);\n-        __ bind(slow_case);\n-          __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, cache);\n-          __ bind(finish);\n-          __ verify_oop(r0);\n-          __ push(atos);\n-          __ b(Done);\n+          __ b(ExternalAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n@@ -2811,2 +2800,1 @@\n-            __ get_inline_type_field_klass(klass, field_index, inline_klass);\n-            __ get_default_value_oop(inline_klass, klass \/* temp *\/, r0);\n+            __ b(ExternalAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n@@ -3458,4 +3446,1 @@\n-          __ load_unsigned_short(index, Address(r2, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-          __ ldr(klass, Address(r2, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n-          __ get_inline_type_field_klass(klass, index, inline_klass);\n-          __ get_default_value_oop(inline_klass, tmp \/* temp *\/, r0);\n+          __ b(ExternalAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":18,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1259,1 +1259,1 @@\n-  Label alloc_failed, empty_value, done;\n+  Label alloc_failed, done;\n@@ -1273,3 +1273,0 @@\n-    \/\/check for empty value klass\n-  test_klass_is_empty_inline_type(field_klass, dst_temp, empty_value);\n-\n@@ -1296,4 +1293,0 @@\n-  bind(empty_value);\n-  get_empty_inline_type_oop(field_klass, dst_temp, obj);\n-  jmp(done);\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2972,14 +2972,0 @@\n-void MacroAssembler::test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type) {\n-#ifdef ASSERT\n-  {\n-    Label done_check;\n-    test_klass_is_inline_type(klass, temp_reg, done_check);\n-    stop(\"test_klass_is_empty_inline_type with non inline type klass\");\n-    bind(done_check);\n-  }\n-#endif\n-  movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));\n-  testl(temp_reg, InstanceKlassFlags::is_empty_inline_type_value());\n-  jcc(Assembler::notZero, is_empty_inline_type);\n-}\n-\n@@ -4675,36 +4661,0 @@\n-void MacroAssembler::get_default_value_oop(Register inline_klass, Register temp_reg, Register obj) {\n-#ifdef ASSERT\n-  {\n-    Label done_check;\n-    test_klass_is_inline_type(inline_klass, temp_reg, done_check);\n-    stop(\"get_default_value_oop from non inline type klass\");\n-    bind(done_check);\n-  }\n-#endif\n-  Register offset = temp_reg;\n-  \/\/ Getting the offset of the pre-allocated default value\n-  movptr(offset, Address(inline_klass, in_bytes(InstanceKlass::adr_inlineklass_fixed_block_offset())));\n-  movl(offset, Address(offset, in_bytes(InlineKlass::default_value_offset_offset())));\n-\n-  \/\/ Getting the mirror\n-  movptr(obj, Address(inline_klass, in_bytes(Klass::java_mirror_offset())));\n-  resolve_oop_handle(obj, inline_klass);\n-\n-  \/\/ Getting the pre-allocated default value from the mirror\n-  Address field(obj, offset, Address::times_1);\n-  load_heap_oop(obj, field);\n-}\n-\n-void MacroAssembler::get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj) {\n-#ifdef ASSERT\n-  {\n-    Label done_check;\n-    test_klass_is_empty_inline_type(inline_klass, temp_reg, done_check);\n-    stop(\"get_empty_value from non-empty inline klass\");\n-    bind(done_check);\n-  }\n-#endif\n-  get_default_value_oop(inline_klass, temp_reg, obj);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-  void test_klass_is_empty_inline_type(Register klass, Register temp_reg, Label& is_empty_inline_type);\n@@ -116,6 +115,0 @@\n-  \/\/ Get the default value oop for the given InlineKlass\n-  void get_default_value_oop(Register inline_klass, Register temp_reg, Register obj);\n-  \/\/ The empty value oop, for the given InlineKlass (\"empty\" as in no instance fields)\n-  \/\/ get_default_value_oop with extra assertion for empty inline klass\n-  void get_empty_inline_type_oop(Register inline_klass, Register temp_reg, Register obj);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1201,1 +1201,1 @@\n-    Label is_null_into_value_array_npe, store_null;\n+    Label write_null_to_null_free_array, store_null;\n@@ -1211,1 +1211,1 @@\n-    __ test_null_free_array_oop(rdx, rbx, is_null_into_value_array_npe);\n+    __ test_null_free_array_oop(rdx, rbx, write_null_to_null_free_array);\n@@ -1214,1 +1214,1 @@\n-    __ bind(is_null_into_value_array_npe);\n+    __ bind(write_null_to_null_free_array);\n@@ -3162,17 +3162,1 @@\n-#ifdef _LP64\n-          Label slow_case, finish;\n-          __ movptr(rbx, Address(obj, java_lang_Class::klass_offset()));\n-          __ cmpb(Address(rbx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n-          __ jcc(Assembler::notEqual, slow_case);\n-        __ get_default_value_oop(rbx, rscratch1, rax);\n-        __ jmp(finish);\n-        __ bind(slow_case);\n-#endif \/\/ LP64\n-          __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field),\n-                obj, cache);\n-#ifdef _LP64\n-          __ bind(finish);\n-  #endif \/\/ _LP64\n-        __ verify_oop(rax);\n-        __ push(atos);\n-        __ jmp(Done);\n+          __ jump(RuntimeAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n@@ -3180,2 +3164,2 @@\n-      Label is_flat, nonnull, is_inline_type, rewrite_inline, has_null_marker;\n-      __ test_field_is_null_free_inline_type(flags, rscratch1, is_inline_type);\n+      Label is_flat, nonnull, is_null_free_inline_type, rewrite_inline, has_null_marker;\n+      __ test_field_is_null_free_inline_type(flags, rscratch1, is_null_free_inline_type);\n@@ -3191,1 +3175,1 @@\n-      __ bind(is_inline_type);\n+      __ bind(is_null_free_inline_type);\n@@ -3198,4 +3182,1 @@\n-            __ load_unsigned_short(flags, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-            __ movptr(rcx, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n-            __ get_inline_type_field_klass(rcx, flags, rbx);\n-            __ get_default_value_oop(rbx, rcx, rax);\n+          __ jump(RuntimeAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n@@ -3885,4 +3866,1 @@\n-          __ load_unsigned_short(rdx, Address(rcx, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-          __ movptr(rcx, Address(rcx, ResolvedFieldEntry::field_holder_offset()));\n-          __ get_inline_type_field_klass(rcx, rdx, rbx);\n-          __ get_default_value_oop(rbx, rcx, rax);\n+          __ jump(RuntimeAddress(Interpreter::_throw_NPE_UninitializedField_entry));\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1112,15 +1112,9 @@\n-      if (elem_klass->is_empty()) {\n-        \/\/ No need to create a new instance, the default instance will be used instead\n-        load_indexed = new LoadIndexed(array, index, length, type, state_before);\n-        apush(append(load_indexed));\n-      } else {\n-        NewInstance* new_instance = new NewInstance(elem_klass, state_before, false, true);\n-        _memory->new_instance(new_instance);\n-        apush(append_split(new_instance));\n-        load_indexed = new LoadIndexed(array, index, length, type, state_before);\n-        load_indexed->set_vt(new_instance);\n-        \/\/ The LoadIndexed node will initialise this instance by copying from\n-        \/\/ the flat field.  Ensure these stores are visible before any\n-        \/\/ subsequent store that publishes this reference.\n-        need_membar = true;\n-      }\n+      NewInstance* new_instance = new NewInstance(elem_klass, state_before, false, true);\n+      _memory->new_instance(new_instance);\n+      apush(append_split(new_instance));\n+      load_indexed = new LoadIndexed(array, index, length, type, state_before);\n+      load_indexed->set_vt(new_instance);\n+      \/\/ The LoadIndexed node will initialise this instance by copying from\n+      \/\/ the flat field.  Ensure these stores are visible before any\n+      \/\/ subsequent store that publishes this reference.\n+      need_membar = true;\n@@ -1895,4 +1889,0 @@\n-      } else if (field->is_null_free() && field->type()->as_instance_klass()->is_initialized() &&\n-                 field->type()->as_inline_klass()->is_empty()) {\n-        \/\/ Loading from a field of an empty, null-free inline type. Just return the default instance.\n-        constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n@@ -1924,2 +1914,2 @@\n-      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n-        \/\/ Storing to a field of an empty, null-free inline type. Ignore.\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty() && (!method()->is_class_initializer() || field->is_flat())) {\n+        \/\/ Storing to a field of an empty, null-free inline type that is already initialized. Ignore.\n@@ -1942,6 +1932,1 @@\n-        if (field->is_null_free() && field->type()->as_instance_klass()->is_initialized()\n-            && field->type()->as_inline_klass()->is_empty()) {\n-          \/\/ Loading from a field of an empty, null-free inline type. Just return the default instance.\n-          null_check(obj);\n-          constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n-        } else if (field->is_constant() && !field->is_flat() && obj_type->is_constant() && !PatchALot) {\n+        if (field->is_constant() && !field->is_flat() && obj_type->is_constant() && !PatchALot) {\n@@ -1952,6 +1937,1 @@\n-              if (field->is_null_free() && field_value.is_null_or_zero()) {\n-                \/\/ Non-flat inline type field. Replace null by the default value.\n-                constant = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n-              } else {\n-                constant = make_constant(field_value, field);\n-              }\n+              constant = make_constant(field_value, field);\n@@ -2057,8 +2037,1 @@\n-              if (field->is_null_free() && inline_klass->is_initialized() && inline_klass->is_empty()) {\n-                apush(append(new Constant(new InstanceConstant(inline_klass->default_instance()))));\n-                if (has_pending_field_access()) {\n-                  set_pending_field_access(nullptr);\n-                } else if (has_pending_load_indexed()) {\n-                  set_pending_load_indexed(nullptr);\n-                }\n-              } else if (has_pending_load_indexed()) {\n+              if (has_pending_load_indexed()) {\n@@ -2087,0 +2060,4 @@\n+                  if (field->type()->as_instance_klass()->is_initialized() && field->type()->as_inline_klass()->is_empty()) {\n+                    \/\/ Needs an explicit null check because below code does not perform any actual load if there are no fields\n+                    null_check(obj);\n+                  }\n@@ -2113,2 +2090,3 @@\n-      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty()) {\n-        \/\/ Storing to a field of an empty, null-free inline type. Ignore.\n+\n+      if (field->is_null_free() && field->type()->is_loaded() && field->type()->as_inline_klass()->is_empty() && (!method()->is_object_constructor() || field->is_flat())) {\n+        \/\/ Storing to a field of an empty, null-free inline type that is already initialized. Ignore.\n@@ -2522,9 +2500,3 @@\n-  if (!stream()->is_unresolved_klass() && klass->is_inlinetype() &&\n-      klass->as_inline_klass()->is_initialized() && klass->as_inline_klass()->is_empty()) {\n-    ciInlineKlass* vk = klass->as_inline_klass();\n-    apush(append(new Constant(new InstanceConstant(vk->default_instance()))));\n-  } else {\n-    NewInstance* new_instance = new NewInstance(klass->as_instance_klass(), state_before, stream()->is_unresolved_klass(), false);\n-    _memory->new_instance(new_instance);\n-    apush(append_split(new_instance));\n-  }\n+  NewInstance* new_instance = new NewInstance(klass->as_instance_klass(), state_before, stream()->is_unresolved_klass(), false);\n+  _memory->new_instance(new_instance);\n+  apush(append_split(new_instance));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":24,"deletions":52,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1774,18 +1774,0 @@\n-\n-  if (field->is_null_free()) {\n-    assert(field->type()->is_loaded(), \"Must be\");\n-    assert(field->type()->is_inlinetype(), \"Must be if loaded\");\n-    assert(field->type()->as_inline_klass()->is_initialized(), \"Must be\");\n-    LabelObj* L_end = new LabelObj();\n-    __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(nullptr));\n-    __ branch(lir_cond_notEqual, L_end->label());\n-    set_in_conditional_code(true);\n-    Constant* default_value = new Constant(new InstanceConstant(field->type()->as_inline_klass()->default_instance()));\n-    if (default_value->is_pinned()) {\n-      __ move(LIR_OprFact::value_type(default_value->type()), result);\n-    } else {\n-      __ move(load_constant(default_value), result);\n-    }\n-    __ branch_destination(L_end->label());\n-    set_in_conditional_code(false);\n-  }\n@@ -2174,33 +2156,0 @@\n-\n-  if (field->is_null_free()) {\n-    \/\/ Load from non-flat inline type field requires\n-    \/\/ a null check to replace null with the default value.\n-    ciInstanceKlass* holder = field->holder();\n-    if (field->is_static() && holder->is_loaded()) {\n-      ciObject* val = holder->java_mirror()->field_value(field).as_object();\n-      if (!val->is_null_object()) {\n-        \/\/ Static field is initialized, we don't need to perform a null check.\n-        return;\n-      }\n-    }\n-    ciInlineKlass* inline_klass = field->type()->as_inline_klass();\n-    if (inline_klass->is_initialized()) {\n-      LabelObj* L_end = new LabelObj();\n-      __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(nullptr));\n-      __ branch(lir_cond_notEqual, L_end->label());\n-      set_in_conditional_code(true);\n-      Constant* default_value = new Constant(new InstanceConstant(inline_klass->default_instance()));\n-      if (default_value->is_pinned()) {\n-        __ move(LIR_OprFact::value_type(default_value->type()), result);\n-      } else {\n-        __ move(load_constant(default_value), result);\n-      }\n-      __ branch_destination(L_end->label());\n-      set_in_conditional_code(false);\n-    } else {\n-      info = state_for(x, x->state_before());\n-      __ cmp(lir_cond_equal, result, LIR_OprFact::oopConst(nullptr));\n-      __ branch(lir_cond_equal, new DeoptimizeStub(info, Deoptimization::Reason_uninitialized,\n-                                                         Deoptimization::Action_make_not_entrant));\n-    }\n-  }\n@@ -2383,13 +2332,0 @@\n-  } else if (x->array() != nullptr && x->array()->is_loaded_flat_array() &&\n-             x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_initialized() &&\n-             x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass()->is_empty()) {\n-    \/\/ Load the default instance instead of reading the element\n-    ciInlineKlass* elem_klass = x->array()->declared_type()->as_flat_array_klass()->element_klass()->as_inline_klass();\n-    LIR_Opr result = rlock_result(x, x->elt_type());\n-    assert(elem_klass->is_initialized(), \"Must be\");\n-    Constant* default_value = new Constant(new InstanceConstant(elem_klass->default_instance()));\n-    if (default_value->is_pinned()) {\n-      __ move(LIR_OprFact::value_type(default_value->type()), result);\n-    } else {\n-      __ move(load_constant(default_value), result);\n-    }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -375,8 +375,2 @@\n-  oop obj = nullptr;\n-  if (h->is_inline_klass() && InlineKlass::cast(h)->is_empty_inline_type()) {\n-    obj = InlineKlass::cast(h)->default_value();\n-    assert(obj != nullptr, \"default value must exist\");\n-  } else {\n-    \/\/ allocate instance and return via TLS\n-    obj = h->allocate_instance(CHECK);\n-  }\n+  \/\/ allocate instance and return via TLS\n+  oop obj = h->allocate_instance(CHECK);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  GUARDED_VM_ENTRY(return !is_type_array_klass() && get_Klass()->is_null_free_array_klass();)\n+  GUARDED_VM_ENTRY(return get_Klass()->is_null_free_array_klass();)\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-  tty->print(\" null_marker_offset=%s\", bool_to_str(_null_marker_offset));\n+  tty->print(\" null_marker_offset=%d\", _null_marker_offset);\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,6 +118,0 @@\n-ciInstance* ciInlineKlass::default_instance() const {\n-  VM_ENTRY_MARK;\n-  oop default_value = to_InlineKlass()->default_value();\n-  return CURRENT_ENV->get_instance(default_value);\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-  ciInstance* default_instance() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    if (is_null_free_array != nullptr && (k->is_flatArray_klass() || (k->is_objArray_klass() && k->is_null_free_array_klass()))) {\n+    if (is_null_free_array != nullptr && (k->is_array_klass() && k->is_null_free_array_klass())) {\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -943,1 +943,0 @@\n-    _jdk_internal_ImplicitlyConstructible,\n@@ -1463,2 +1462,10 @@\n-              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s with signature %s (primitive types can never be null)\",\n-              name->as_C_string(), sig->as_C_string());\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s with signature %s (primitive types can never be null)\",\n+              class_name()->as_C_string(), name->as_C_string(), sig->as_C_string());\n+          }\n+          const bool is_strict = (flags & JVM_ACC_STRICT) != 0;\n+          if (!is_strict) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s which doesn't have the @jdk.internal.vm.annotation.Strict annotation\",\n+              class_name()->as_C_string(), name->as_C_string());\n@@ -1547,13 +1554,4 @@\n-    \/\/ Inject static \".default\" field\n-    FieldInfo::FieldFlags fflags(0);\n-    fflags.update_injected(true);\n-    AccessFlags aflags(JVM_ACC_STATIC);\n-    FieldInfo fi(aflags,\n-                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(default_value_name)),\n-                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n-                 0,\n-                 fflags);\n-    int idx = _temp_field_info->append(fi);\n-    _temp_field_info->adr_at(idx)->set_index(idx);\n-    _static_oop_count++;\n-    \/\/ Inject static \".null_reset\" field. This is the same as the .default field but will never have its null-channel set to non-zero.\n+    \/\/ Inject static \".null_reset\" field. This is an all-zero value with its null-channel set to zero.\n+    \/\/ IT should never be seen by user code, it is used when writing \"null\" to a nullable flat field\n+    \/\/ The all-zero value ensure that any embedded oop will be set to null, to avoid keeping dead objects\n+    \/\/ alive.\n@@ -1951,4 +1949,0 @@\n-    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ImplicitlyConstructible_signature): {\n-      if (_location != _in_class)   break; \/\/ only allow for classes\n-      return _jdk_internal_ImplicitlyConstructible;\n-    }\n@@ -4578,11 +4572,0 @@\n-  if (supports_inline_types()) {\n-    if (is_strict && is_static) {\n-      is_illegal = true;\n-      error_msg = \"field cannot be strict and static\";\n-    }\n-    else if (is_strict && !is_final) {\n-      is_illegal = true;\n-      error_msg = \"strict field must be final\";\n-    }\n-  }\n-\n@@ -4605,1 +4588,1 @@\n-        if (!is_identity_class && !is_static && !is_strict) {\n+        if (!is_identity_class && !is_static && (!is_strict || !is_final)) {\n@@ -4607,1 +4590,1 @@\n-          error_msg = \"value class fields must be either strict or static\";\n+          error_msg = \"value class fields must be either non-static final and strict, or static\";\n@@ -5317,3 +5300,0 @@\n-  if (_is_implicitly_constructible) {\n-    ik->set_is_implicitly_constructible();\n-  }\n@@ -5495,1 +5475,0 @@\n-    vk->set_default_value_offset(_layout_info->_default_value_offset);\n@@ -5627,1 +5606,0 @@\n-  _is_implicitly_constructible(false),\n@@ -5629,1 +5607,0 @@\n-  _has_implicitly_constructible_annotation(false),\n@@ -6077,5 +6054,0 @@\n-  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_ImplicitlyConstructible) && _access_flags.is_identity_class()) {\n-    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n-          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.ImplicitlyConstructible, because it is not a value class\",\n-                  _class_name->as_klass_external_name()));\n-  }\n@@ -6094,5 +6066,0 @@\n-    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)\n-        && (_super_klass == vmClasses::Object_klass() || _super_klass == vmClasses::Record_klass()\n-        || _super_klass->is_implicitly_constructible())) {\n-      _is_implicitly_constructible = true;\n-    }\n@@ -6226,5 +6193,0 @@\n-        if (!vk->is_implicitly_constructible()) {\n-          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                    err_msg(\"class %s is not implicitly constructible and it is used in a null restricted non-static field (not supported)\",\n-                    klass->name()->as_C_string()));\n-        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":16,"deletions":54,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-  int _default_value_offset;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    assert(vk->is_implicitly_constructible(), \"null-free fields must be implicitly constructible\");\n+    assert(field_info.access_flags().is_strict(), \"null-free fields must be strict\");\n@@ -211,1 +211,0 @@\n-  _default_value_offset(-1),\n@@ -401,3 +400,0 @@\n-    if (_field_info->adr_at(block->field_index())->name(_cp) == vmSymbols::default_value_name()) {\n-      _default_value_offset = block->offset();\n-    }\n@@ -1313,1 +1309,0 @@\n-    _info->_default_value_offset = _static_layout->default_value_offset();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -201,1 +201,0 @@\n-  int _default_value_offset;  \/\/ offset of the default value in class mirror, only for static layout of inline classes\n@@ -227,4 +226,0 @@\n-  int default_value_offset() const {\n-    assert(_default_value_offset != -1, \"Must have been set\");\n-    return _default_value_offset;\n-  }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1471,1 +1471,1 @@\n-  if (klass->is_flatArray_klass() || (klass->is_objArray_klass() && ObjArrayKlass::cast(klass)->is_null_free_array_klass())) {\n+  if (klass->is_flatArray_klass() || (ArrayKlass::cast(klass)->is_null_free_array_klass())) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2432,1 +2432,1 @@\n-        if (is_local_field && fd.access_flags().is_strict()) {\n+        if (is_local_field && fd.access_flags().is_strict() && fd.access_flags().is_final()) {\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  case vmIntrinsics::_newNullRestrictedArray:\n+  case vmIntrinsics::_newNullRestrictedNonAtomicArray:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -325,3 +325,1 @@\n-  do_intrinsic(_newNullRestrictedArray, jdk_internal_value_ValueClass, newNullRestrictedArray_name, newArray_signature2, F_SN) \\\n-   do_name(     newNullRestrictedArray_name,                      \"newNullRestrictedArray\")                             \\\n-  do_intrinsic(_newNullRestrictedAtomicArray, jdk_internal_value_ValueClass, newNullRestrictedAtomicArray_name, newArray_signature2, F_SN) \\\n+  do_intrinsic(_newNullRestrictedAtomicArray, jdk_internal_value_ValueClass, newNullRestrictedAtomicArray_name, newArray_signature3, F_SN) \\\n@@ -329,2 +327,4 @@\n-  do_intrinsic(_newNullableAtomicArray, jdk_internal_value_ValueClass, _newNullableAtomicArray_name, newArray_signature2, F_SN) \\\n-   do_name(    _newNullableAtomicArray_name,                      \"newNullableAtomicArray\")                             \\\n+  do_intrinsic(_newNullRestrictedNonAtomicArray, jdk_internal_value_ValueClass, newNullRestrictedNonAtomicArray_name, newArray_signature3, F_SN) \\\n+   do_name(     newNullRestrictedNonAtomicArray_name,             \"newNullRestrictedNonAtomicArray\")                    \\\n+  do_intrinsic(_newNullableAtomicArray, jdk_internal_value_ValueClass, newNullableAtomicArray_name, newArray_signature2, F_SN) \\\n+   do_name(     newNullableAtomicArray_name,                      \"newNullableAtomicArray\")                             \\\n@@ -332,0 +332,1 @@\n+   do_signature(newArray_signature3,                              \"(Ljava\/lang\/Class;ILjava\/lang\/Object;)[Ljava\/lang\/Object;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -255,1 +255,0 @@\n-  template(jdk_internal_vm_annotation_ImplicitlyConstructible_signature,     \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\") \\\n@@ -508,1 +507,0 @@\n-  template(default_value_name,                        \".default\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -558,3 +558,0 @@\n-JNIEXPORT jboolean JNICALL\n-JVM_IsImplicitlyConstructibleClass(JNIEnv *env, jclass cls);\n-\n@@ -1098,1 +1095,4 @@\n-JVM_NewNullRestrictedArray(JNIEnv *env, jclass elmClass, jint len);\n+JVM_CopyOfSpecialArray(JNIEnv *env, jarray orig, jint from, jint to);\n+\n+JNIEXPORT jarray JNICALL\n+JVM_NewNullRestrictedNonAtomicArray(JNIEnv *env, jclass elmClass, jint len, jobject initVal);\n@@ -1101,1 +1101,1 @@\n-JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len);\n+JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len, jobject initVal);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -231,59 +231,0 @@\n-JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, ResolvedFieldEntry* entry))\n-  \/\/ The interpreter tries to access an inline static field that has not been initialized.\n-  \/\/ This situation can happen in different scenarios:\n-  \/\/   1 - if the load or initialization of the field failed during step 8 of\n-  \/\/       the initialization of the holder of the field, in this case the access to the field\n-  \/\/       must fail\n-  \/\/   2 - it can also happen when the initialization of the holder class triggered the initialization of\n-  \/\/       another class which accesses this field in its static initializer, in this case the\n-  \/\/       access must succeed to allow circularity\n-  \/\/ The code below tries to load and initialize the field's class again before returning the default value.\n-  \/\/ If the field was not initialized because of an error, an exception should be thrown.\n-  \/\/ If the class is being initialized, the default value is returned.\n-  assert(entry->is_valid(), \"Invalid ResolvedFieldEntry\");\n-  instanceHandle mirror_h(THREAD, (instanceOop)mirror);\n-  InstanceKlass* klass = entry->field_holder();\n-  u2 index = entry->field_index();\n-  assert(klass == java_lang_Class::as_Klass(mirror), \"Not the field holder klass\");\n-  assert(klass->field_is_null_free_inline_type(index), \"Sanity check\");\n-  if (klass->is_being_initialized() && klass->is_reentrant_initialization(THREAD)) {\n-    int offset = klass->field_offset(index);\n-    Klass* field_k = klass->get_inline_type_field_klass_or_null(index);\n-    if (field_k == nullptr) {\n-      field_k = SystemDictionary::resolve_or_fail(klass->field_signature(index)->fundamental_name(THREAD),\n-          Handle(THREAD, klass->class_loader()),\n-          true, CHECK);\n-      assert(field_k != nullptr, \"Should have been loaded or an exception thrown above\");\n-      if (!field_k->is_inline_klass()) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  err_msg(\"class %s expects class %s to be a concrete value class but it is not\",\n-                  klass->name()->as_C_string(), field_k->external_name()));\n-      }\n-      InlineLayoutInfo* li = klass->inline_layout_info_adr(index);\n-      li->set_klass(InlineKlass::cast(field_k));\n-      li->set_kind(LayoutKind::REFERENCE);\n-    }\n-    field_k->initialize(CHECK);\n-    oop defaultvalue = InlineKlass::cast(field_k)->default_value();\n-    \/\/ It is safe to initialize the static field because 1) the current thread is the initializing thread\n-    \/\/ and is the only one that can access it, and 2) the field is actually not initialized (i.e. null)\n-    \/\/ otherwise the JVM should not be executing this code.\n-    mirror_h()->obj_field_put(offset, defaultvalue);\n-    current->set_vm_result(defaultvalue);\n-  } else {\n-    assert(klass->is_in_error_state(), \"If not initializing, initialization must have failed to get there\");\n-    ResourceMark rm(THREAD);\n-    const char* desc = \"Could not initialize class \";\n-    const char* className = klass->external_name();\n-    size_t msglen = strlen(desc) + strlen(className) + 1;\n-    char* message = NEW_RESOURCE_ARRAY(char, msglen);\n-    if (nullptr == message) {\n-      \/\/ Out of memory: can't create detailed error message\n-      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);\n-    } else {\n-      jio_snprintf(message, msglen, \"%s%s\", desc, className);\n-      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);\n-    }\n-  }\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":59,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  static void    uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, ResolvedFieldEntry* entry);\n@@ -95,0 +94,1 @@\n+  static void    throw_NPE_UninitializedField_entry(JavaThread* current);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+address    TemplateInterpreter::_throw_NPE_UninitializedField_entry         = nullptr;\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+  static address    _throw_NPE_UninitializedField_entry;\n@@ -156,0 +157,1 @@\n+  static address    throw_NPE_UninitializedField_entry()        { return _throw_NPE_UninitializedField_entry; }\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+    Interpreter::_throw_NPE_UninitializedField_entry         = generate_exception_handler(\"java\/lang\/NullPointerException\", \"Uninitialized null-restricted field\");\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-  set_default_value_offset(0);\n@@ -89,8 +88,0 @@\n-void InlineKlass::set_default_value(oop val) {\n-  assert(val != nullptr, \"Sanity check\");\n-  assert(oopDesc::is_oop(val), \"Sanity check\");\n-  assert(val->is_inline_type(), \"Sanity check\");\n-  assert(val->klass() == this, \"sanity check\");\n-  java_mirror()->obj_field_put(default_value_offset(), val);\n-}\n-\n@@ -251,3 +242,0 @@\n-      if (is_empty_inline_type()) {\n-        return default_value();\n-      }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -78,5 +78,0 @@\n-  address adr_default_value_offset() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(default_value_offset_offset());\n-  }\n-\n@@ -326,4 +321,0 @@\n-  static ByteSize default_value_offset_offset() {\n-    return byte_offset_of(InlineKlassFixedBlock, _default_value_offset);\n-  }\n-\n@@ -342,19 +333,0 @@\n-  void set_default_value_offset(int offset) {\n-    *((int*)adr_default_value_offset()) = offset;\n-  }\n-\n-  int default_value_offset() {\n-    int offset = *((int*)adr_default_value_offset());\n-    assert(offset != 0, \"must not be called if not initialized\");\n-    return offset;\n-  }\n-\n-  void set_default_value(oop val);\n-\n-  oop default_value() {\n-    assert(is_initialized() || is_being_initialized() || is_in_error_state(), \"default value is set at the beginning of initialization\");\n-    oop val = java_mirror()->obj_field_acquire(default_value_offset());\n-    assert(val != nullptr, \"Sanity check\");\n-    return val;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1061,0 +1061,1 @@\n+        assert(fs.access_flags().is_strict(), \"null-free fields must be strict\");\n@@ -1088,5 +1089,5 @@\n-          if (!vk->is_implicitly_constructible()) {\n-             THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                        err_msg(\"class %s is not implicitly constructible and it is used in a null restricted static field (not supported)\",\n-                        klass->external_name()), false);\n-          }\n+          \/\/ if (!vk->is_implicitly_constructible()) {\n+          \/\/    THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+          \/\/               err_msg(\"class %s is not implicitly constructible and it is used in a null restricted static field (not supported)\",\n+          \/\/               klass->external_name()), false);\n+          \/\/ }\n@@ -1443,1 +1444,1 @@\n-  \/\/ Pre-allocating an instance of the default value\n+  \/\/ Pre-allocating an all-zero value to be used to reset nullable flat storages\n@@ -1446,14 +1447,0 @@\n-      oop val = vk->allocate_instance(THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-          Handle e(THREAD, PENDING_EXCEPTION);\n-          CLEAR_PENDING_EXCEPTION;\n-          {\n-              EXCEPTION_MARK;\n-              add_initialization_error(THREAD, e);\n-              \/\/ Locks object, set state, and notify all waiting threads\n-              set_initialization_state_and_notify(initialization_error, THREAD);\n-              CLEAR_PENDING_EXCEPTION;\n-          }\n-          THROW_OOP(e());\n-      }\n-      vk->set_default_value(val);\n@@ -1461,1 +1448,1 @@\n-        val = vk->allocate_instance(THREAD);\n+        oop val = vk->allocate_instance(THREAD);\n@@ -1511,33 +1498,0 @@\n-  \/\/ Initialize classes of inline fields\n-  if (EnableValhalla) {\n-    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n-      if (fs.is_null_free_inline_type()) {\n-\n-        \/\/ inline type field klass array entries must have alreadyt been filed at load time or link time\n-        Klass* klass = get_inline_type_field_klass(fs.index());\n-\n-        InstanceKlass::cast(klass)->initialize(THREAD);\n-        if (fs.access_flags().is_static()) {\n-          if (java_mirror()->obj_field(fs.offset()) == nullptr) {\n-            java_mirror()->obj_field_put(fs.offset(), InlineKlass::cast(klass)->default_value());\n-          }\n-        }\n-\n-        if (HAS_PENDING_EXCEPTION) {\n-          Handle e(THREAD, PENDING_EXCEPTION);\n-          CLEAR_PENDING_EXCEPTION;\n-          {\n-            EXCEPTION_MARK;\n-            add_initialization_error(THREAD, e);\n-            \/\/ Locks object, set state, and notify all waiting threads\n-            set_initialization_state_and_notify(initialization_error, THREAD);\n-            CLEAR_PENDING_EXCEPTION;\n-          }\n-          THROW_OOP(e());\n-        }\n-      }\n-    }\n-  }\n-\n-\n-  \/\/ Step 9\n@@ -1565,1 +1519,1 @@\n-  \/\/ Step 10\n+  \/\/ Step 9\n@@ -1571,1 +1525,1 @@\n-    \/\/ Step 11 and 12\n+    \/\/ Step 10 and 11\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":10,"deletions":56,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -148,1 +148,0 @@\n-  int* _default_value_offset;\n@@ -420,6 +419,0 @@\n-  \/\/ Query if this class can be implicitly constructed, meaning the VM is allowed\n-  \/\/ to create instances without calling a constructor\n-  \/\/ Applies to inline classes and their super types\n-  bool is_implicitly_constructible() const { return _misc_flags.is_implicitly_constructible(); }\n-  void set_is_implicitly_constructible()   { _misc_flags.set_is_implicitly_constructible(true); }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-    flag(is_implicitly_constructible        , 1 << 19) \/* the class has the ImplicitlyConstrutible annotation *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -721,1 +721,1 @@\n-  inline bool is_null_free_array_klass()      const { return layout_helper_is_null_free(layout_helper()); }\n+  inline bool is_null_free_array_klass() const { return !is_typeArray_klass() && layout_helper_is_null_free(layout_helper()); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-  bool populate_null_free = is_null_free_array_klass();\n@@ -162,11 +161,0 @@\n-  if (populate_null_free) {\n-    assert(dimension() == 1, \"Can only populate the final dimension\");\n-    assert(element_klass()->is_inline_klass(), \"Unexpected\");\n-    assert(!element_klass()->is_array_klass(), \"ArrayKlass unexpected here\");\n-    element_klass()->initialize(CHECK_NULL);\n-    \/\/ Populate default values...\n-    instanceOop value = (instanceOop) InlineKlass::cast(element_klass())->default_value();\n-    for (int i = 0; i < length; i++) {\n-      array_h->obj_at_put(i, value);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-  case vmIntrinsics::_newNullRestrictedArray:\n+  case vmIntrinsics::_newNullRestrictedNonAtomicArray:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1846,3 +1846,3 @@\n-        mark_node = phase->transform(mark_node);\n-        \/\/ Avoid returning a constant (old node) here because this method is used by LoadNode::Ideal\n-        mark_node = new OrXNode(mark_node, phase->MakeConX(_larval ? markWord::larval_bit_in_place : 0));\n+      mark_node = phase->transform(mark_node);\n+      \/\/ Avoid returning a constant (old node) here because this method is used by LoadNode::Ideal\n+      mark_node = new OrXNode(mark_node, phase->MakeConX(_larval ? markWord::larval_bit_in_place : 0));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1004,2 +1004,2 @@\n-    DefaultValue,                     \/\/ default value in case of non-flat inline type array\n-    RawDefaultValue,                  \/\/ same as above but as raw machine word\n+    InitValue,                        \/\/ Init value for null-free inline type arrays\n+    RawInitValue,                     \/\/ Same as above but as raw machine word\n@@ -1017,2 +1017,2 @@\n-    fields[DefaultValue] = TypeInstPtr::NOTNULL;\n-    fields[RawDefaultValue] = TypeX_X;\n+    fields[InitValue] = TypeInstPtr::NOTNULL;\n+    fields[RawInitValue] = TypeX_X;\n@@ -1117,1 +1117,1 @@\n-                    Node* default_value, Node* raw_default_value)\n+                    Node* init_value, Node* raw_init_value)\n@@ -1122,1 +1122,1 @@\n-    set_req(AllocateNode::ALength,        count_val);\n+    set_req(AllocateNode::ALength, count_val);\n@@ -1124,2 +1124,2 @@\n-    init_req(AllocateNode::DefaultValue,  default_value);\n-    init_req(AllocateNode::RawDefaultValue, raw_default_value);\n+    init_req(AllocateNode::InitValue, init_value);\n+    init_req(AllocateNode::RawInitValue, raw_init_value);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1354,2 +1354,1 @@\n-    bool default_value_load = EnableValhalla && tj->is_instptr()->instance_klass() == ciEnv::current()->Class_klass();\n-    assert(InlineUnsafeOps || StressReflectiveCode || default_value_load, \"indeterminate pointers come only from unsafe ops\");\n+    assert(InlineUnsafeOps || StressReflectiveCode, \"indeterminate pointers come only from unsafe ops\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass(), !gvn().type(retnode)->maybe_null());\n+      retnode = InlineTypeNode::make_from_oop(this, retnode, rtype->as_inline_klass());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2800,1 +2800,1 @@\n-    if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != nullptr) {\n+    if (alloc->as_Allocate()->in(AllocateNode::InitValue) != nullptr) {\n@@ -2802,3 +2802,3 @@\n-      \/\/ the default value instead of null. Handle them here.\n-      init_val = ptnode_adr(alloc->as_Allocate()->in(AllocateNode::DefaultValue)->_idx);\n-      assert(init_val != nullptr, \"default value should be registered\");\n+      \/\/ an init value instead of null. Handle them here.\n+      init_val = ptnode_adr(alloc->as_Allocate()->in(AllocateNode::InitValue)->_idx);\n+      assert(init_val != nullptr, \"init value should be registered\");\n@@ -2838,1 +2838,1 @@\n-  if (!alloc->is_Allocate() || alloc->as_Allocate()->in(AllocateNode::DefaultValue) != nullptr) {\n+  if (!alloc->is_Allocate() || alloc->as_Allocate()->in(AllocateNode::InitValue) != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1908,1 +1908,1 @@\n-        arg = InlineTypeNode::make_from_oop(this, arg, t->inline_klass(), t->inline_klass()->is_null_free());\n+        arg = InlineTypeNode::make_from_oop(this, arg, t->inline_klass());\n@@ -2016,1 +2016,1 @@\n-        ret = InlineTypeNode::make_from_oop(this, ret, type->inline_klass(), type->inline_klass()->is_null_free());\n+        ret = InlineTypeNode::make_from_oop(this, ret, type->inline_klass());\n@@ -2029,1 +2029,1 @@\n-                                                               inline_type_receiver->bottom_type()->inline_klass(), true);\n+                                                               inline_type_receiver->bottom_type()->inline_klass());\n@@ -3740,1 +3740,1 @@\n-      Node* vt = InlineTypeNode::make_from_oop(this, res, toop->inline_klass(), !gvn().type(res)->maybe_null());\n+      Node* vt = InlineTypeNode::make_from_oop(this, res, toop->inline_klass());\n@@ -4290,1 +4290,2 @@\n-                          bool deoptimize_on_exception) {\n+                          bool deoptimize_on_exception,\n+                          Node* init_val) {\n@@ -4441,10 +4442,8 @@\n-  const TypeAryPtr* ary_ptr = ary_type->isa_aryptr();\n-\n-  \/\/ Check if the array is a null-free, non-flat inline type array\n-  \/\/ that needs to be initialized with the default inline type.\n-  Node* default_value = nullptr;\n-  Node* raw_default_value = nullptr;\n-  if (ary_ptr != nullptr && ary_ptr->klass_is_exact() &&\n-      ary_ptr->is_null_free() && !ary_ptr->is_flat() && ary_ptr->elem()->make_ptr()->is_inlinetypeptr()) {\n-    ciInlineKlass* vk = ary_ptr->elem()->inline_klass();\n-    default_value = InlineTypeNode::default_oop(gvn(), vk);\n+\n+  Node* raw_init_value = nullptr;\n+  if (init_val != nullptr) {\n+    \/\/ TODO 8350865 Fast non-zero init not implemented yet for flat, null-free arrays\n+    if (ary_type->is_flat()) {\n+      initial_slow_test = intcon(1);\n+    }\n+\n@@ -4453,2 +4452,2 @@\n-      default_value = _gvn.transform(new EncodePNode(default_value, default_value->bottom_type()->make_narrowoop()));\n-      Node* lower = _gvn.transform(new CastP2XNode(control(), default_value));\n+      init_val = _gvn.transform(new EncodePNode(init_val, init_val->bottom_type()->make_narrowoop()));\n+      Node* lower = _gvn.transform(new CastP2XNode(control(), init_val));\n@@ -4456,1 +4455,1 @@\n-      raw_default_value = _gvn.transform(new OrLNode(lower, upper));\n+      raw_init_value = _gvn.transform(new OrLNode(lower, upper));\n@@ -4458,1 +4457,1 @@\n-      raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));\n+      raw_init_value = _gvn.transform(new CastP2XNode(control(), init_val));\n@@ -4477,1 +4476,1 @@\n-                            default_value, raw_default_value);\n+                            init_val, raw_init_value);\n@@ -4779,1 +4778,1 @@\n-      con = InlineTypeNode::make_from_oop(this, con, field->type()->as_inline_klass(), field->is_null_free());\n+      con = InlineTypeNode::make_from_oop(this, con, field->type()->as_inline_klass());\n@@ -4781,1 +4780,1 @@\n-      con = InlineTypeNode::make_from_oop(this, con, con_type->inline_klass(), field->is_null_free());\n+      con = InlineTypeNode::make_from_oop(this, con, con_type->inline_klass());\n@@ -4806,1 +4805,1 @@\n-    obj = InlineTypeNode::make_from_oop(this, obj, sig_type->inline_klass(), !gvn().type(obj)->maybe_null());\n+    obj = InlineTypeNode::make_from_oop(this, obj, sig_type->inline_klass());\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -861,1 +861,2 @@\n-                  bool deoptimize_on_exception = false);\n+                  bool deoptimize_on_exception = false,\n+                  Node* init_val = nullptr);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -497,1 +497,1 @@\n-      new_value = make_from_oop_impl(kit, value, ft->as_inline_klass(), field_is_null_free(i), visited);\n+      new_value = make_from_oop_impl(kit, value, ft->as_inline_klass(), visited);\n@@ -519,2 +519,2 @@\n-      \/\/ Loading from a field of an empty inline type. Just return the default instance.\n-      value = make_default_impl(kit->gvn(), ft->as_inline_klass(), visited);\n+      \/\/ Loading from a field of an empty inline type. Just return the all-zero instance.\n+      value = make_all_zero_impl(kit->gvn(), ft->as_inline_klass(), visited);\n@@ -544,1 +544,0 @@\n-          null_free = true;\n@@ -553,0 +552,3 @@\n+        if (null_free) {\n+          val_type = val_type->join_speculative(TypePtr::NOTNULL);\n+        }\n@@ -561,1 +563,1 @@\n-        value = make_from_oop_impl(kit, value, ft->as_inline_klass(), null_free, visited);\n+        value = make_from_oop_impl(kit, value, ft->as_inline_klass(), visited);\n@@ -602,0 +604,1 @@\n+    bool field_null_free = field_is_null_free(i);\n@@ -605,2 +608,2 @@\n-      InlineTypeNode* vt = make_uninitialized(*gvn, ft->as_inline_klass(), field_is_null_free(i));\n-      vt->convert_from_payload(kit, bt, payload, offset, field_is_null_free(i), null_marker_offset);\n+      InlineTypeNode* vt = make_uninitialized(*gvn, ft->as_inline_klass(), field_null_free);\n+      vt->convert_from_payload(kit, bt, payload, offset, field_null_free, null_marker_offset);\n@@ -613,1 +616,4 @@\n-        const Type* val_type = Type::get_const_type(ft)->make_narrowoop();\n+        const Type* val_type = Type::get_const_type(ft);\n+        if (field_null_free) {\n+          val_type = val_type->join_speculative(TypePtr::NOTNULL);\n+        }\n@@ -615,1 +621,1 @@\n-        value = gvn->transform(new DecodeNNode(value, val_type));\n+        value = gvn->transform(new DecodeNNode(value, val_type->make_narrowoop()));\n@@ -617,1 +623,1 @@\n-        value = gvn->transform(new CastPPNode(kit->control(), value, Type::get_const_type(ft), ConstraintCastNode::UnconditionalDependency));\n+        value = gvn->transform(new CastPPNode(kit->control(), value, val_type, ConstraintCastNode::UnconditionalDependency));\n@@ -623,1 +629,1 @@\n-          value = make_from_oop_impl(kit, value, ft->as_inline_klass(), field_is_null_free(i), visited);\n+          value = make_from_oop_impl(kit, value, ft->as_inline_klass(), visited);\n@@ -934,3 +940,18 @@\n-    if (vk->is_initialized() && (vk->is_empty() || (is_default(&kit->gvn()) && !is_larval(&kit->gvn()) && !is_larval()))) {\n-      \/\/ Don't buffer an empty or default inline type, use the default oop instead\n-      oop->init_req(3, default_oop(kit->gvn(), vk));\n+    \/\/ Allocate and initialize buffer, re-execute on deoptimization.\n+    kit->jvms()->set_bci(kit->bci());\n+    kit->jvms()->set_should_reexecute(true);\n+    kit->kill_dead_locals();\n+    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, \/* deoptimize_on_exception *\/ true, this);\n+\n+    if (must_init) {\n+      \/\/ Either not a larval or a larval receiver on which we are about to invoke an abstract value class constructor\n+      \/\/ or the Object constructor which is not inlined. It is therefore escaping, and we must initialize the buffer\n+      \/\/ because we have not done this, yet, for larvals (see else case).\n+      store(kit, alloc_oop, alloc_oop, vk);\n+\n+      \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n+      \/\/ store that would make this buffer accessible by other threads.\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+      assert(alloc != nullptr, \"must have an allocation node\");\n+      kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n@@ -938,24 +959,3 @@\n-      \/\/ Allocate and initialize buffer, re-execute on deoptimization.\n-      kit->jvms()->set_bci(kit->bci());\n-      kit->jvms()->set_should_reexecute(true);\n-      kit->kill_dead_locals();\n-      Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n-      Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, \/* deoptimize_on_exception *\/ true, this);\n-\n-      if (must_init) {\n-        \/\/ Either not a larval or a larval receiver on which we are about to invoke an abstract value class constructor\n-        \/\/ or the Object constructor which is not inlined. It is therefore escaping, and we must initialize the buffer\n-        \/\/ because we have not done this, yet, for larvals (see else case).\n-        store(kit, alloc_oop, alloc_oop, vk);\n-\n-        \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n-        \/\/ store that would make this buffer accessible by other threads.\n-        AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-        assert(alloc != nullptr, \"must have an allocation node\");\n-        kit->insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n-      } else {\n-        \/\/ We do not need to initialize the buffer because a larval could still be updated which will create a new buffer.\n-        \/\/ Once the larval escapes, we will initialize the buffer (must_init set).\n-        assert(is_larval(), \"only larvals can possibly skip the initialization of their buffer\");\n-      }\n-      oop->init_req(3, alloc_oop);\n+      \/\/ We do not need to initialize the buffer because a larval could still be updated which will create a new buffer.\n+      \/\/ Once the larval escapes, we will initialize the buffer (must_init set).\n+      assert(is_larval(), \"only larvals can possibly skip the initialization of their buffer\");\n@@ -963,0 +963,1 @@\n+    oop->init_req(3, alloc_oop);\n@@ -1091,10 +1092,0 @@\n-  const TypeInt* tinit = phase->type(get_is_init())->isa_int();\n-  if ((tinit != nullptr && tinit->is_con(1)) &&\n-      ((is_default(phase) && !is_larval(phase) && !is_larval()) || inline_klass()->is_empty()) &&\n-      inline_klass()->is_initialized() &&\n-      (!oop->is_Con() || phase->type(oop)->is_zero_type())) {\n-    \/\/ Use the pre-allocated oop for null-free default or empty inline types\n-    set_oop(*phase, default_oop(*phase, inline_klass()));\n-    assert(is_allocated(phase), \"should now be allocated\");\n-    return this;\n-  }\n@@ -1148,4 +1139,2 @@\n-  bool use_default_oop = vk->is_empty() && vk->is_initialized() && null_free;\n-  Node* oop = use_default_oop ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop, null_free);\n-  vt->set_is_buffered(gvn, use_default_oop);\n+  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT), null_free);\n+  vt->set_is_buffered(gvn, false);\n@@ -1156,6 +1145,1 @@\n-Node* InlineTypeNode::default_oop(PhaseGVN& gvn, ciInlineKlass* vk) {\n-  \/\/ Returns the constant oop of the default inline type allocation\n-  return gvn.makecon(TypeInstPtr::make(vk->default_instance()));\n-}\n-\n-InlineTypeNode* InlineTypeNode::make_default(PhaseGVN& gvn, ciInlineKlass* vk, bool is_larval) {\n+InlineTypeNode* InlineTypeNode::make_all_zero(PhaseGVN& gvn, ciInlineKlass* vk, bool is_larval) {\n@@ -1164,1 +1148,1 @@\n-  return make_default_impl(gvn, vk, visited, is_larval);\n+  return make_all_zero_impl(gvn, vk, visited, is_larval);\n@@ -1167,5 +1151,4 @@\n-InlineTypeNode* InlineTypeNode::make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval) {\n-  \/\/ Create a new InlineTypeNode with default values\n-  Node* oop = vk->is_initialized() && !is_larval ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n-  InlineTypeNode* vt = new InlineTypeNode(vk, oop, \/* null_free= *\/ true);\n-  vt->set_is_buffered(gvn, vk->is_initialized() && !is_larval);\n+InlineTypeNode* InlineTypeNode::make_all_zero_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval) {\n+  \/\/ Create a new InlineTypeNode initialized with all zero\n+  InlineTypeNode* vt = new InlineTypeNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ true);\n+  vt->set_is_buffered(gvn, false);\n@@ -1184,1 +1167,1 @@\n-        value = make_default_impl(gvn, vk, visited);\n+        value = make_all_zero_impl(gvn, vk, visited);\n@@ -1193,1 +1176,1 @@\n-  assert(vt->is_default(&gvn), \"must be the default inline type\");\n+  assert(vt->is_all_zero(&gvn), \"must be the all-zero inline type\");\n@@ -1197,1 +1180,1 @@\n-bool InlineTypeNode::is_default(PhaseGVN* gvn) const {\n+bool InlineTypeNode::is_all_zero(PhaseGVN* gvn, bool flat) const {\n@@ -1205,2 +1188,3 @@\n-      \/\/ Null-free value class field must have the default value\n-      if (!value->is_InlineType() || !value->as_InlineType()->is_default(gvn)) {\n+      \/\/ Null-free value class field must have the all-zero value. If 'flat' is set,\n+      \/\/ reject non-flat fields because they need to be initialized with an oop to a buffer.\n+      if (!value->is_InlineType() || !value->as_InlineType()->is_all_zero(gvn) || (flat && !field_is_flat(i))) {\n@@ -1217,2 +1201,1 @@\n-    }\n-    if (!gvn->type(value)->is_zero_type()) {\n+    } else if (!gvn->type(value)->is_zero_type()) {\n@@ -1225,1 +1208,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, bool is_larval) {\n+InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool is_larval) {\n@@ -1228,1 +1211,1 @@\n-  return make_from_oop_impl(kit, oop, vk, null_free, visited, is_larval);\n+  return make_from_oop_impl(kit, oop, vk, visited, is_larval);\n@@ -1231,1 +1214,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited, bool is_larval) {\n+InlineTypeNode* InlineTypeNode::make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval) {\n@@ -1234,5 +1217,0 @@\n-  if (!is_larval && vk->is_empty() && null_free) {\n-    InlineTypeNode* def = make_default_impl(gvn, vk, visited);\n-    kit->record_for_igvn(def);\n-    return def;\n-  }\n@@ -1260,5 +1238,1 @@\n-      if (null_free) {\n-        vt = make_default_impl(gvn, vk, visited);\n-      } else {\n-        vt = make_null_impl(gvn, vk, visited);\n-      }\n+      vt = make_null_impl(gvn, vk, visited);\n@@ -1268,1 +1242,1 @@\n-    vt = new InlineTypeNode(vk, not_null_oop, null_free);\n+    vt = new InlineTypeNode(vk, not_null_oop, \/* null_free= *\/ false);\n@@ -1275,6 +1249,1 @@\n-      InlineTypeNode* null_vt = nullptr;\n-      if (null_free) {\n-        null_vt = make_default_impl(gvn, vk, visited);\n-      } else {\n-        null_vt = make_null_impl(gvn, vk, visited);\n-      }\n+      InlineTypeNode* null_vt = make_null_impl(gvn, vk, visited);\n@@ -1286,3 +1255,1 @@\n-      if (!null_free) {\n-        vt->set_oop(gvn, oop);\n-      }\n+      vt->set_oop(gvn, oop);\n@@ -1300,1 +1267,1 @@\n-\/\/    assert(!null_free || vt->as_InlineType()->is_default(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineType ||\n+\/\/    assert(!null_free || vt->as_InlineType()->is_all_zero(&gvn) || init_ctl != kit->control() || !gvn.type(oop)->is_inlinetypeptr() || oop->is_Con() || oop->Opcode() == Op_InlineType ||\n@@ -1303,1 +1270,1 @@\n-  assert(vt->is_allocated(&gvn) || (null_free && !vk->is_initialized()), \"inline type should be allocated\");\n+  assert(vt->is_allocated(&gvn), \"inline type should be allocated\");\n@@ -1522,10 +1489,0 @@\n-  if (field_count() == 0 && vk->is_initialized()) {\n-    const TypeInt* tinit = phase->type(get_is_init())->isa_int();\n-    if (tinit != nullptr && tinit->is_con(1)) {\n-      assert(is_allocated(phase), \"must be allocated\");\n-      return get_oop();\n-    } else {\n-      \/\/ TODO 8284443\n-      return nullptr;\n-    }\n-  }\n@@ -1682,0 +1639,1 @@\n+      bool null_free = field_is_null_free(i);\n@@ -1695,0 +1653,1 @@\n+          null_free = false;\n@@ -1701,1 +1660,4 @@\n-          parm = make_from_oop_impl(kit, parm, type->as_inline_klass(), field_is_null_free(i), visited);\n+          if (null_free) {\n+            parm = kit->cast_not_null(parm);\n+          }\n+          parm = make_from_oop_impl(kit, parm, type->as_inline_klass(), visited);\n@@ -1742,1 +1704,0 @@\n-      assert((!is_default(igvn) || !inline_klass()->is_initialized()) && !is_allocated(igvn), \"re-allocation should be removed by Ideal transformation\");\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":69,"deletions":108,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  \/\/ Checks if the inline type fields are all set to default values\n-  bool is_default(PhaseGVN* gvn) const;\n-\n@@ -84,2 +81,2 @@\n-  static InlineTypeNode* make_default_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval = false);\n-  static InlineTypeNode* make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free, GrowableArray<ciType*>& visited, bool is_larval = false);\n+  static InlineTypeNode* make_all_zero_impl(PhaseGVN& gvn, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval = false);\n+  static InlineTypeNode* make_from_oop_impl(GraphKit* kit, Node* oop, ciInlineKlass* vk, GrowableArray<ciType*>& visited, bool is_larval = false);\n@@ -93,2 +90,2 @@\n-  \/\/ Create with default field values\n-  static InlineTypeNode* make_default(PhaseGVN& gvn, ciInlineKlass* vk, bool is_larval = false);\n+  \/\/ Create with all-zero field values\n+  static InlineTypeNode* make_all_zero(PhaseGVN& gvn, ciInlineKlass* vk, bool is_larval = false);\n@@ -98,1 +95,1 @@\n-  static InlineTypeNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true, bool is_larval = false);\n+  static InlineTypeNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool is_larval = false);\n@@ -107,3 +104,0 @@\n-  \/\/ Returns the constant oop of the default inline type allocation\n-  static Node* default_oop(PhaseGVN& gvn, ciInlineKlass* vk);\n-\n@@ -127,0 +121,3 @@\n+  \/\/ Checks if the inline type fields are all set to zero\n+  bool is_all_zero(PhaseGVN* gvn, bool flat = false) const;\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-  case vmIntrinsics::_newNullRestrictedArray:     return inline_newArray(\/* null_free *\/ true, \/* atomic *\/ false);\n+  case vmIntrinsics::_newNullRestrictedNonAtomicArray: return inline_newArray(\/* null_free *\/ true, \/* atomic *\/ false);\n@@ -2601,1 +2601,1 @@\n-          p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass(), !ptr->maybe_null());\n+          p = InlineTypeNode::make_from_oop(this, p, ptr->inline_klass());\n@@ -3110,1 +3110,1 @@\n-    obj = InlineTypeNode::make_default(_gvn, tkls->instance_klass()->as_inline_klass())->buffer(this);\n+    obj = InlineTypeNode::make_all_zero(_gvn, tkls->instance_klass()->as_inline_klass())->buffer(this);\n@@ -4500,2 +4500,2 @@\n-\/\/ public static native Object[] newNullRestrictedArray(Class<?> componentType, int length);\n-\/\/ public static native Object[] newNullRestrictedAtomicArray(Class<?> componentType, int length);\n+\/\/ public static native Object[] newNullRestrictedAtomicArray(Class<?> componentType, int length, Object initVal);\n+\/\/ public static native Object[] newNullRestrictedNonAtomicArray(Class<?> componentType, int length, Object initVal);\n@@ -4507,0 +4507,1 @@\n+  Node* init_val = null_free ? argument(2) : nullptr;\n@@ -4525,1 +4526,1 @@\n-        \/\/ TOOD 8350865 ZGC needs card marks on initializing default value stores\n+        \/\/ TOOD 8350865 ZGC needs card marks on initializing oop stores\n@@ -4533,1 +4534,12 @@\n-          Node* obj = new_array(makecon(array_klass_type), length, 0);\n+          if (null_free) {\n+            if (init_val->is_InlineType()) {\n+              if (array_klass_type->is_flat() && init_val->as_InlineType()->is_all_zero(&gvn(), \/* flat *\/ true)) {\n+                \/\/ Zeroing is enough because the init value is the all-zero value\n+                init_val = nullptr;\n+              } else {\n+                init_val = init_val->as_InlineType()->buffer(this);\n+              }\n+            }\n+            \/\/ TODO 8350865 Should we add a check of the init_val type (maybe in debug only + halt)?\n+          }\n+          Node* obj = new_array(makecon(array_klass_type), length, 0, nullptr, false, init_val);\n@@ -5791,3 +5803,3 @@\n-    \/\/ A null-free, tightly coupled array allocation can only come from LibraryCallKit::inline_newNullRestrictedArray\n-    \/\/ which requires both the component type and the array length on stack for re-execution. Re-create and push\n-    \/\/ the component type.\n+    \/\/ A null-free, tightly coupled array allocation can only come from LibraryCallKit::inline_newArray which\n+    \/\/ also requires the componentType and initVal on stack for re-execution.\n+    \/\/ Re-create and push the componentType.\n@@ -5802,0 +5814,11 @@\n+  if (ary_klass_ptr->is_null_free()) {\n+    \/\/ Re-create and push the initVal.\n+    Node* init_val = alloc->in(AllocateNode::InitValue);\n+    if (init_val == nullptr) {\n+      init_val = InlineTypeNode::make_all_zero(_gvn, ary_klass_ptr->elem()->is_instklassptr()->instance_klass()->as_inline_klass());\n+    } else if (UseCompressedOops) {\n+      init_val = _gvn.transform(new DecodeNNode(init_val, init_val->bottom_type()->make_ptr()));\n+    }\n+    sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp() + adjustment, init_val);\n+    adjustment++;\n+  }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -391,4 +391,9 @@\n-        \/\/ hit a sentinel, return appropriate 0 value\n-        Node* default_value = alloc->in(AllocateNode::DefaultValue);\n-        if (default_value != nullptr) {\n-          values.at_put(j, default_value);\n+        \/\/ hit a sentinel, return appropriate value\n+        Node* init_value = alloc->in(AllocateNode::InitValue);\n+        if (init_value != nullptr) {\n+          if (val == start_mem) {\n+            \/\/ TODO 8350865 Somehow we ended up with root mem and therefore walked past the alloc. Fix this. Triggered by TestGenerated::test15\n+            \/\/ Don't we need field_value_by_offset?\n+            return nullptr;\n+          }\n+          values.at_put(j, init_value);\n@@ -396,1 +401,1 @@\n-          assert(alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n+          assert(alloc->in(AllocateNode::RawInitValue) == nullptr, \"init value may not be null\");\n@@ -417,4 +422,5 @@\n-      } else if(val->is_Proj() && val->in(0) == alloc) {\n-        Node* default_value = alloc->in(AllocateNode::DefaultValue);\n-        if (default_value != nullptr) {\n-          values.at_put(j, default_value);\n+      } else if (val->is_Proj() && val->in(0) == alloc) {\n+        Node* init_value = alloc->in(AllocateNode::InitValue);\n+        if (init_value != nullptr) {\n+          \/\/ TODO 8350865 Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n+          values.at_put(j, init_value);\n@@ -422,1 +428,1 @@\n-          assert(alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n+          assert(alloc->in(AllocateNode::RawInitValue) == nullptr, \"init value may not be null\");\n@@ -532,4 +538,15 @@\n-      \/\/ hit a sentinel, return appropriate 0 value\n-      Node* default_value = alloc->in(AllocateNode::DefaultValue);\n-      if (default_value != nullptr) {\n-        return default_value;\n+      \/\/ hit a sentinel, return appropriate value\n+      Node* init_value = alloc->in(AllocateNode::InitValue);\n+      if (init_value != nullptr) {\n+        if (adr_t->is_flat()) {\n+          if (init_value->is_EncodeP()) {\n+            init_value = init_value->in(1);\n+          }\n+          assert(adr_t->is_aryptr()->field_offset().get() != Type::OffsetBot, \"Unknown offset\");\n+          offset = adr_t->is_aryptr()->field_offset().get() + init_value->bottom_type()->inline_klass()->payload_offset();\n+          init_value = init_value->as_InlineType()->field_value_by_offset(offset, true);\n+          if (ft == T_NARROWOOP) {\n+            init_value = transform_later(new EncodePNode(init_value, init_value->bottom_type()->make_ptr()));\n+          }\n+        }\n+        return init_value;\n@@ -537,1 +554,1 @@\n-      assert(alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n+      assert(alloc->in(AllocateNode::RawInitValue) == nullptr, \"init value may not be null\");\n@@ -605,1 +622,1 @@\n-        } else {\n+        } else if (!value->is_InlineType()) {\n@@ -902,0 +919,9 @@\n+      ciField* flat_field = iklass->get_non_flat_field_by_offset(offset);\n+      if (flat_field != nullptr && flat_field->is_flat() && !flat_field->is_null_free()) {\n+        \/\/ TODO 8353432 Add support for nullable, flat fields in non-value class holders\n+        \/\/ Below code only iterates over the flat representation and therefore misses to\n+        \/\/ add null markers like we do in InlineTypeNode::add_fields_to_safepoint for value\n+        \/\/ class holders.\n+        return nullptr;\n+      }\n+\n@@ -1417,0 +1443,1 @@\n+            Node* init_val, \/\/ value to initialize the array with\n@@ -1599,0 +1626,3 @@\n+    if (init_val != nullptr) {\n+      call->init_req(TypeFunc::Parms+2, init_val);\n+    }\n@@ -1924,2 +1954,2 @@\n-                                            alloc->in(AllocateNode::DefaultValue),\n-                                            alloc->in(AllocateNode::RawDefaultValue),\n+                                            alloc->in(AllocateNode::InitValue),\n+                                            alloc->in(AllocateNode::RawInitValue),\n@@ -2100,1 +2130,1 @@\n-  expand_allocate_common(alloc, nullptr,\n+  expand_allocate_common(alloc, nullptr, nullptr,\n@@ -2110,0 +2140,1 @@\n+  Node* init_value = alloc->in(AllocateNode::InitValue);\n@@ -2111,0 +2142,1 @@\n+  const TypeFunc* slow_call_type;\n@@ -2117,0 +2149,1 @@\n+    slow_call_type = OptoRuntime::new_array_nozero_Type();\n@@ -2119,0 +2152,7 @@\n+    slow_call_type = OptoRuntime::new_array_Type();\n+\n+    if (init_value == nullptr) {\n+      init_value = _igvn.zerocon(T_OBJECT);\n+    } else if (UseCompressedOops) {\n+      init_value = transform_later(new DecodeNNode(init_value, init_value->bottom_type()->make_ptr()));\n+    }\n@@ -2120,2 +2160,2 @@\n-  expand_allocate_common(alloc, length,\n-                         OptoRuntime::new_array_Type(),\n+  expand_allocate_common(alloc, length, init_value,\n+                         slow_call_type,\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":61,"deletions":21,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+                              Node* init_val,\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -439,2 +439,2 @@\n-  Node* default_value = nullptr;\n-  Node* raw_default_value = nullptr;\n+  Node* init_value = nullptr;\n+  Node* raw_init_value = nullptr;\n@@ -471,2 +471,2 @@\n-      default_value = alloc->in(AllocateNode::DefaultValue);\n-      raw_default_value = alloc->in(AllocateNode::RawDefaultValue);\n+      init_value = alloc->in(AllocateNode::InitValue);\n+      raw_init_value = alloc->in(AllocateNode::RawInitValue);\n@@ -549,1 +549,1 @@\n-                             default_value, raw_default_value,\n+                             init_value, raw_init_value,\n@@ -587,1 +587,1 @@\n-                           default_value, raw_default_value,\n+                           init_value, raw_init_value,\n@@ -638,1 +638,1 @@\n-                             default_value, raw_default_value,\n+                             init_value, raw_init_value,\n@@ -650,1 +650,1 @@\n-                             default_value, raw_default_value,\n+                             init_value, raw_init_value,\n@@ -830,1 +830,1 @@\n-                           default_value, raw_default_value,\n+                           init_value, raw_init_value,\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1124,1 +1124,0 @@\n-\n@@ -1235,3 +1234,4 @@\n-      Node* default_value = ld_alloc->in(AllocateNode::DefaultValue);\n-      if (default_value != nullptr) {\n-        return default_value;\n+      Node* init_value = ld_alloc->in(AllocateNode::InitValue);\n+      if (init_value != nullptr) {\n+        \/\/ TODO 8350865 Is this correct for non-all-zero init values? Don't we need field_value_by_offset?\n+        return init_value;\n@@ -1239,1 +1239,1 @@\n-      assert(ld_alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n+      assert(ld_alloc->in(AllocateNode::RawInitValue) == nullptr, \"init value may not be null\");\n@@ -2273,0 +2273,5 @@\n+      \/\/ TODO 8350865 This is needed for flat array accesses, somehow the memory of the loads bypasses the intrinsic\n+      \/\/ Run TestArrays.test6 in Scenario4, we need more tests for this. TestBasicFunctionality::test20 also needs this.\n+      if (tp->isa_aryptr() && tp->is_aryptr()->is_flat() && !UseFieldFlattening) {\n+        return _type;\n+      }\n@@ -3521,1 +3526,1 @@\n-        (phase->type(val)->is_zero_type() || mem->in(0)->in(AllocateNode::DefaultValue) == val)) {\n+        (phase->type(val)->is_zero_type() || mem->in(0)->in(AllocateNode::InitValue) == val)) {\n@@ -5200,2 +5205,2 @@\n-                                              allocation()->in(AllocateNode::DefaultValue),\n-                                              allocation()->in(AllocateNode::RawDefaultValue),\n+                                              allocation()->in(AllocateNode::InitValue),\n+                                              allocation()->in(AllocateNode::RawInitValue),\n@@ -5261,2 +5266,2 @@\n-                                            allocation()->in(AllocateNode::DefaultValue),\n-                                            allocation()->in(AllocateNode::RawDefaultValue),\n+                                            allocation()->in(AllocateNode::InitValue),\n+                                            allocation()->in(AllocateNode::RawInitValue),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -627,1 +627,1 @@\n-      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), !t->maybe_null(), is_larval);\n+      Node* vt = InlineTypeNode::make_from_oop(this, parm, t->inline_klass(), is_larval);\n@@ -2356,1 +2356,1 @@\n-        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), false);\n+        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-          ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass(), !element_ptr->maybe_null());\n+          ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass());\n@@ -158,1 +158,1 @@\n-    ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass(), !element_ptr->maybe_null());\n+    ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass());\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-    ld = InlineTypeNode::make_default(_gvn, field_klass->as_inline_klass());\n+    ld = InlineTypeNode::make_all_zero(_gvn, field_klass->as_inline_klass());\n@@ -177,7 +177,2 @@\n-        if (field->is_null_free() && field->is_static()) {\n-          \/\/ Check if static inline type field is already initialized\n-          ciInstance* mirror = field->holder()->java_mirror();\n-          ciObject* val = mirror->field_value(field).as_object();\n-          if (!val->is_null_object()) {\n-            type = type->join_speculative(TypePtr::NOTNULL);\n-          }\n+        if (field->is_null_free()) {\n+          type = type->join_speculative(TypePtr::NOTNULL);\n@@ -196,1 +191,1 @@\n-      ld = InlineTypeNode::make_from_oop(this, ld, field_klass->as_inline_klass(), field->is_null_free());\n+      ld = InlineTypeNode::make_from_oop(this, ld, field_klass->as_inline_klass());\n@@ -267,2 +262,2 @@\n-  if (field->is_null_free() && field->type()->as_inline_klass()->is_empty()) {\n-    \/\/ Storing to a field of an empty inline type. Ignore.\n+  if (field->is_null_free() && field->type()->as_inline_klass()->is_empty() && (!method()->is_object_constructor() || field->is_flat())) {\n+    \/\/ Storing to a field of an empty, null-free inline type that is already initialized. Ignore.\n@@ -347,1 +342,1 @@\n-    val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass(), field->is_null_free());\n+    val = InlineTypeNode::make_from_oop(this, val, field->type()->as_inline_klass());\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-    push(InlineTypeNode::make_default(_gvn, klass->as_inline_klass(), \/* is_larval *\/ true));\n+    push(InlineTypeNode::make_all_zero(_gvn, klass->as_inline_klass(), \/* is_larval *\/ true));\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+const TypeFunc* OptoRuntime::_new_array_nozero_Type               = nullptr;\n@@ -366,1 +367,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread* current))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, oopDesc* init_val, JavaThread* current))\n@@ -375,0 +376,1 @@\n+  Handle h_init_val(current, init_val); \/\/ keep the init_val object alive\n@@ -379,2 +381,8 @@\n-    Klass* elem_type = fak->element_klass();\n-    result = oopFactory::new_flatArray(elem_type, len, fak->layout_kind(), THREAD);\n+    InlineKlass* vk = fak->element_klass();\n+    result = oopFactory::new_flatArray(vk, len, fak->layout_kind(), THREAD);\n+    if (array_type->is_null_free_array_klass() && !h_init_val.is_null()) {\n+      \/\/ Null-free arrays need to be initialized\n+      for (int i = 0; i < len; i++) {\n+        vk->write_value_to_addr(h_init_val(), ((flatArrayOop)result)->value_at_addr(i, fak->layout_helper()), fak->layout_kind(), true, CHECK);\n+      }\n+    }\n@@ -388,1 +396,8 @@\n-    result = ObjArrayKlass::cast(array_type)->allocate(len, THREAD);\n+    ObjArrayKlass* array_klass = ObjArrayKlass::cast(array_type);\n+    result = array_klass->allocate(len, THREAD);\n+    if (array_type->is_null_free_array_klass() && !h_init_val.is_null()) {\n+      \/\/ Null-free arrays need to be initialized\n+      for (int i = 0; i < len; i++) {\n+        ((objArrayOop)result)->obj_at_put(i, h_init_val());\n+      }\n+    }\n@@ -631,0 +646,17 @@\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(3);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   \/\/ element klass\n+  fields[TypeFunc::Parms+1] = TypeInt::INT;       \/\/ array size\n+  fields[TypeFunc::Parms+2] = TypeInstPtr::NOTNULL;       \/\/ init value\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+3, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; \/\/ Returned oop\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n+static const TypeFunc* make_new_array_nozero_Type() {\n@@ -2084,0 +2116,1 @@\n+  _new_array_nozero_Type              = make_new_array_nozero_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  static const TypeFunc* _new_array_nozero_Type;\n@@ -222,1 +223,1 @@\n-  static void new_array_C(Klass* array_klass, int len, JavaThread* current);\n+  static void new_array_C(Klass* array_klass, int len, oopDesc* init_val, JavaThread* current);\n@@ -334,1 +335,2 @@\n-    return new_array_Type();\n+    assert(_new_array_nozero_Type != nullptr, \"should be initialized\");\n+    return _new_array_nozero_Type;\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -428,1 +428,44 @@\n-JVM_ENTRY(jarray, JVM_NewNullRestrictedArray(JNIEnv *env, jclass elmClass, jint len))\n+JVM_ENTRY(jarray, JVM_CopyOfSpecialArray(JNIEnv *env, jarray orig, jint from, jint to))\n+  oop o = JNIHandles::resolve_non_null(orig);\n+  assert(o->is_array(), \"Must be\");\n+  oop array = nullptr;\n+  arrayOop org = (arrayOop)o;\n+  arrayHandle oh(THREAD, org);\n+  ArrayKlass* ak = ArrayKlass::cast(org->klass());\n+  InlineKlass* vk = InlineKlass::cast(ak->element_klass());\n+  int len = to - from;\n+  if (ak->is_null_free_array_klass()) {\n+    if (from >= org->length() || to > org->length()) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Copying of null-free array with uninitialized elements\");\n+    }\n+  }\n+  if (org->is_flatArray()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(org->klass());\n+    LayoutKind lk = fak->layout_kind();\n+    array = oopFactory::new_flatArray(vk, len, lk, CHECK_NULL);\n+    arrayHandle ah(THREAD, (arrayOop)array);\n+    for (int i = from; i < to; i++) {\n+      void* src = ((flatArrayOop)oh())->value_at_addr(i, fak->layout_helper());\n+      void* dst = ((flatArrayOop)ah())->value_at_addr(i - from, fak->layout_helper());\n+      vk->copy_payload_to_addr(src, dst, lk, false);\n+    }\n+    array = ah();\n+  } else {\n+    if (org->is_null_free_array()) {\n+      array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n+    } else {\n+      array = oopFactory::new_objArray(vk, len, CHECK_NULL);\n+    }\n+    for (int i = from; i < to; i++) {\n+      if (i < ((objArrayOop)oh())->length()) {\n+        ((objArrayOop)array)->obj_at_put(i - from, ((objArrayOop)oh())->obj_at(i));\n+      } else {\n+        assert(!ak->is_null_free_array_klass(), \"Must be a nullable array\");\n+        ((objArrayOop)array)->obj_at_put(i - from, nullptr);\n+      }\n+    }\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedNonAtomicArray(JNIEnv *env, jclass elmClass, jint len, jobject initVal))\n@@ -430,0 +473,5 @@\n+  oop init = JNIHandles::resolve(initVal);\n+  if (init == nullptr) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Initial value cannot be null\");\n+  }\n+  Handle init_h(THREAD, init);\n@@ -431,1 +479,3 @@\n-  klass->initialize(CHECK_NULL);\n+  if (klass != init_h()->klass()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Type mismatch between array and initial value\");\n+  }\n@@ -434,3 +484,3 @@\n-  if (!vk->is_implicitly_constructible()) {\n-    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n-  }\n+  \/\/ if (!vk->is_implicitly_constructible()) {\n+  \/\/   THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n+  \/\/ }\n@@ -440,0 +490,3 @@\n+    for (int i = 0; i < len; i++) {\n+      ((flatArrayOop)array)->write_value_to_flat_array(init_h(), i, CHECK_NULL);\n+    }\n@@ -442,0 +495,3 @@\n+    for (int i = 0; i < len; i++) {\n+      ((objArrayOop)array)->obj_at_put(i, init_h());\n+    }\n@@ -446,1 +502,1 @@\n-JVM_ENTRY(jarray, JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len))\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len, jobject initVal))\n@@ -448,0 +504,5 @@\n+  oop init = JNIHandles::resolve(initVal);\n+  if (init == nullptr) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Initial value cannot be null\");\n+  }\n+  Handle init_h(THREAD, init);\n@@ -449,1 +510,3 @@\n-  klass->initialize(CHECK_NULL);\n+  if (klass != init_h()->klass()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Type mismatch between array and initial value\");\n+  }\n@@ -452,3 +515,3 @@\n-  if (!vk->is_implicitly_constructible()) {\n-    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n-  }\n+  \/\/ if (!vk->is_implicitly_constructible()) {\n+  \/\/   THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n+  \/\/ }\n@@ -456,1 +519,1 @@\n-  if (UseArrayFlattening && vk->is_naturally_atomic() && vk->has_non_atomic_layout()) {\n+  if (UseArrayFlattening && vk->is_naturally_atomic()  && vk->has_non_atomic_layout()) {\n@@ -458,0 +521,3 @@\n+    for (int i = 0; i < len; i++) {\n+      ((flatArrayOop)array)->write_value_to_flat_array(init_h(), i, CHECK_NULL);\n+    }\n@@ -460,0 +526,3 @@\n+    for (int i = 0; i < len; i++) {\n+      ((flatArrayOop)array)->write_value_to_flat_array(init_h(), i, CHECK_NULL);\n+    }\n@@ -462,0 +531,5 @@\n+    for (int i = 0; i < len; i++) {\n+      \/\/ need a type check here\n+\n+      ((objArrayOop)array)->obj_at_put(i, init_h());\n+    }\n@@ -1333,7 +1407,0 @@\n-JVM_ENTRY(jboolean, JVM_IsImplicitlyConstructibleClass(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n-  return ik->is_implicitly_constructible();\n-JVM_END\n-\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":85,"deletions":18,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -441,7 +441,0 @@\n-UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n-  InlineKlass* vk = InlineKlass::cast(k);\n-  oop v = vk->default_value();\n-  return JNIHandles::make_local(THREAD, v);\n-} UNSAFE_END\n-\n@@ -1150,1 +1143,0 @@\n-    {CC \"uninitializedDefaultValue\", CC \"(\" CLS \")\" OBJ,  FN_PTR(Unsafe_UninitializedDefaultValue)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1642,0 +1642,1 @@\n+    assert(null_marker_offsets->length() == (sv->field_size() - svIndex), \"Missing null marker(s) in debug info\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -624,5 +624,0 @@\n-    @ForceInline\n-    \/*non-public*\/ static Object zeroInstanceIfNull(Class<?> fieldType, Object obj) {\n-        return obj != null ? obj : UNSAFE.uninitializedDefaultValue(fieldType);\n-    }\n-\n@@ -833,2 +828,0 @@\n-        final int FIELD_TYPE = (isNullRestricted && isGetter ? nameCursor++ : -1);\n-        final int ZERO_INSTANCE = (isNullRestricted && isGetter ? nameCursor++ : -1);\n@@ -836,1 +829,1 @@\n-        final int RESULT    = nameCursor-1;  \/\/ either the call, zero instance, or the cast\n+        final int RESULT    = nameCursor-1;  \/\/ either the call, or the cast\n@@ -868,11 +861,2 @@\n-        if (isGetter) {\n-            int argIndex = LINKER_CALL;\n-            if (isNullRestricted) {\n-                names[FIELD_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])\n-                                             : new Name(getFunction(NF_fieldType), names[DMH_THIS]);\n-                names[ZERO_INSTANCE] = new Name(getFunction(NF_zeroInstance), names[FIELD_TYPE], names[LINKER_CALL]);\n-                argIndex = ZERO_INSTANCE;\n-            }\n-            if (needsCast)\n-                names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[argIndex]);\n-        }\n+        if (needsCast && isGetter)\n+            names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);\n@@ -926,1 +910,1 @@\n-            NF_zeroInstance = 14,\n+            NF_fieldLayout = 14,\n@@ -928,2 +912,1 @@\n-            NF_fieldLayout = 16,\n-            NF_LIMIT = 17;\n+            NF_LIMIT = 16;\n@@ -990,2 +973,0 @@\n-                case NF_zeroInstance:\n-                    return getNamedFunction(\"zeroInstanceIfNull\", MethodType.methodType(Object.class, Class.class, Object.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n@@ -128,1 +128,1 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n@@ -141,1 +141,2 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n+\n@@ -154,1 +155,1 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n@@ -504,1 +505,2 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                \/\/ return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n@@ -518,1 +520,2 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                \/\/return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n@@ -531,1 +534,2 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                \/\/return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n@@ -544,1 +548,2 @@\n-                return ValueClass.zeroInstance(handle.fieldType);\n+                \/\/return ValueClass.zeroInstance(handle.fieldType);\n+                throw new NullPointerException(\"Uninitialized null-restricted field\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3509,0 +3509,10 @@\n+        Object tmp = null;\n+        if (original.getClass() == newType && componentType.isValue()) {\n+            tmp = ValueClass.copyOfSpecialArray((Object[])original, 0, newLength);\n+        } else {\n+            tmp = ((Object)newType == (Object)Object[].class)\n+                ? new Object[newLength]\n+                : Array.newInstance(componentType, newLength);\n+            System.arraycopy(original, 0, tmp, 0,\n+                             Math.min(original.length, newLength));\n+        }\n@@ -3510,7 +3520,1 @@\n-        T[] copy = ((Object)newType == (Object)Object[].class)\n-            ? (T[]) new Object[newLength]\n-            : (original.getClass() == newType && componentType.isValue() && ValueClass.isNullRestrictedArray(original)\n-                    ? (T[]) ValueClass.newNullRestrictedArray(newType.getComponentType(), newLength)\n-                    : (T[]) Array.newInstance(componentType, newLength));\n-        System.arraycopy(original, 0, copy, 0,\n-                         Math.min(original.length, newLength));\n+        T[] copy = (T[])tmp;\n@@ -3811,0 +3815,10 @@\n+        Object tmp = null;\n+        if (original.getClass() == newType && componentType.isValue()) {\n+            tmp = ValueClass.copyOfSpecialArray((Object[])original, from, to);\n+        } else {\n+            tmp = ((Object)newType == (Object)Object[].class)\n+                    ? new Object[newLength]\n+                    : Array.newInstance(componentType, newLength);\n+            System.arraycopy(original, from, tmp, 0,\n+                Math.min(original.length - from, newLength));\n+        }\n@@ -3812,7 +3826,1 @@\n-        T[] copy = ((Object)newType == (Object)Object[].class)\n-            ? (T[]) new Object[newLength]\n-            : (original.getClass() == newType && componentType.isValue() && ValueClass.isNullRestrictedArray(original)\n-                    ? (T[]) ValueClass.newNullRestrictedArray(componentType, newLength)\n-                    : (T[]) Array.newInstance(componentType, newLength));\n-        System.arraycopy(original, from, copy, 0,\n-                         Math.min(original.length - from, newLength));\n+        T[] copy = (T[])tmp;\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,6 +382,0 @@\n-\n-    \/**\n-     * Returns an uninitialized default instance of the given value class.\n-     *\/\n-    public native <V> V uninitializedDefaultValue(Class<?> type);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -37,1 +36,1 @@\n- * Utilities to access\n+ * Utilities to access package private methods of java.lang.Class and related reflection classes.\n@@ -40,1 +39,0 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -44,10 +42,1 @@\n-     * {@return true if the given {@code Class} object is implicitly constructible}\n-     *\/\n-    public static native boolean isImplicitlyConstructible(Class<?> cls);\n-\n-    \/**\n-     * {@return the default value of the given value class type}\n-     *\n-     * @throws IllegalArgumentException if {@code cls} is not a\n-     *         value class type or is not annotated with\n-     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n+     * {@return {@code CheckedType} representing the type of the given field}\n@@ -55,9 +44,3 @@\n-    public static <T> T zeroInstance(Class<T> cls) {\n-        if (!cls.isValue()) {\n-            throw new IllegalArgumentException(cls.getName() + \" not a value class\");\n-        }\n-        if (!isImplicitlyConstructible(cls)) {\n-            throw new IllegalArgumentException(cls.getName() + \" not implicitly constructible\");\n-        }\n-        UNSAFE.ensureClassInitialized(cls);\n-        return UNSAFE.uninitializedDefaultValue(cls);\n+    public static CheckedType checkedType(Field f) {\n+        return isNullRestrictedField(f) ? NullRestrictedCheckedType.of(f.getType())\n+                                             : NormalCheckedType.of(f.getType());\n@@ -67,1 +50,1 @@\n-     * {@return {@code CheckedType} representing the type of the given field}\n+     * {@return {@code true} if the field is NullRestricted}\n@@ -69,3 +52,2 @@\n-    public static CheckedType checkedType(Field f) {\n-        return JLRA.isNullRestrictedField(f) ? NullRestrictedCheckedType.of(f.getType())\n-                                             : NormalCheckedType.of(f.getType());\n+    public static boolean isNullRestrictedField(Field f) {\n+        return JLRA.isNullRestrictedField(f);\n@@ -92,3 +74,4 @@\n-     * @throws IllegalArgumentException if {@code componentType} is not a\n-     *         value class type or is not annotated with\n-     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n+     * @param componentType the CheckedType componentType\n+     * @param length length of the array\n+     * @param initVal the object to initialize NullRestricted arrays with\n+     * @throws IllegalArgumentException if {@code componentType} is not a value class type\n@@ -96,2 +79,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[] newArrayInstance(CheckedType componentType, int length) {\n+    public static Object[] newArrayInstance(CheckedType componentType, int length, Object initVal) {\n@@ -99,1 +81,2 @@\n-            return newNullRestrictedArray(componentType.boundingClass(), length);\n+            \/\/ Only support atomic NullRestricted arrays\n+            return newNullRestrictedAtomicArray(componentType.boundingClass(), length, initVal);\n@@ -115,2 +98,1 @@\n-     *         value class type or is not annotated with\n-     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n+     *                                  value class type.\n@@ -119,2 +101,2 @@\n-    public static native Object[] newNullRestrictedArray(Class<?> componentType,\n-                                                         int length);\n+    public static native Object[] newNullRestrictedAtomicArray(Class<?> componentType,\n+                                                               int length, Object initVal);\n@@ -123,2 +105,2 @@\n-    public static native Object[] newNullRestrictedAtomicArray(Class<?> componentType,\n-                                                         int length);\n+    public static native Object[] newNullRestrictedNonAtomicArray(Class<?> componentType,\n+                                                                  int length, Object initVal);\n@@ -132,0 +114,6 @@\n+    public static Object[] copyOfSpecialArray(Object[] array, int from, int to) {\n+        return copyOfSpecialArray0(array, from, to);\n+    }\n+\n+    private static native Object[] copyOfSpecialArray0(Object[] array, int from, int to);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":26,"deletions":38,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.vm.annotation;\n-\n-import java.lang.annotation.*;\n-\n-\/**\n- * An implicitly-constructible value class is a class that authorizes the JVM\n- * to create its <em>zero instance<\/em>, where all instance fields are set to\n- * their default values (0, {@code null}, etc.), without any code execution.\n- * Any superclasses other than {@code Object} are also expected to be marked\n- * {@code @ImplicitlyConstructible}.\n- * <p>\n- * The HotSpot VM depends on this annotation being present to properly\n- * initialize {@link NullRestricted} fields and arrays of a value class type.\n- * <p>\n- * Because these behaviors are not specified by Java SE, this annotation should\n- * only be used by internal JDK code for experimental purposes and should not\n- * affect user-observable outcomes.\n- *\/\n-@Target(ElementType.TYPE)\n-@Retention(RetentionPolicy.RUNTIME)\n-public @interface ImplicitlyConstructible {\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/ImplicitlyConstructible.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -33,2 +33,2 @@\n- * {@link ImplicitlyConstructible} annotation. The initial value of the field\n- * is the zero instance of the given class, and attempts to write {@code null}\n+ * {@link Strict} annotation. The field must be initialized according\n+ * to the strict fields rules, and attempts to write {@code null}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/NullRestricted.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * Annotation to indicate the compiler that the ACC_STRICT flag should be set to\n- * the annotated field. Internal and experimental use only\n+ * Annotation to indicate that the strict field semantic applies to this field.\n+ * Internal and experimental use only\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/Strict.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,5 +31,0 @@\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_internal_value_ValueClass_isImplicitlyConstructible(JNIEnv *env, jclass dummy, jclass cls) {\n-    return JVM_IsImplicitlyConstructibleClass(env, cls);\n-}\n-\n@@ -37,1 +32,1 @@\n-Java_jdk_internal_value_ValueClass_newNullRestrictedArray(JNIEnv *env, jclass cls, jclass elmClass, jint len)\n+Java_jdk_internal_value_ValueClass_newNullRestrictedNonAtomicArray(JNIEnv *env, jclass cls, jclass elmClass, jint len, jobject initVal)\n@@ -39,1 +34,1 @@\n-    return JVM_NewNullRestrictedArray(env, elmClass, len);\n+    return JVM_NewNullRestrictedNonAtomicArray(env, elmClass, len, initVal);\n@@ -43,1 +38,1 @@\n-Java_jdk_internal_value_ValueClass_newNullRestrictedAtomicArray(JNIEnv *env, jclass cls, jclass elmClass, jint len)\n+Java_jdk_internal_value_ValueClass_newNullRestrictedAtomicArray(JNIEnv *env, jclass cls, jclass elmClass, jint len, jobject initVal)\n@@ -45,1 +40,1 @@\n-    return JVM_NewNullRestrictedAtomicArray(env, elmClass, len);\n+    return JVM_NewNullRestrictedAtomicArray(env, elmClass, len, initVal);\n@@ -60,0 +55,6 @@\n+JNIEXPORT jarray JNICALL\n+Java_jdk_internal_value_ValueClass_copyOfSpecialArray0(JNIEnv *env, jclass cls, jarray array, jint from, jint to)\n+{\n+    return JVM_CopyOfSpecialArray(env, array, from, to);\n+}\n+\n@@ -70,1 +71,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/ValueClass.c","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -43,1 +44,0 @@\n-    @ImplicitlyConstructible\n@@ -49,0 +49,1 @@\n+    @Strict\n@@ -50,1 +51,2 @@\n-    static MyValue v;\n+    static MyValue v = new MyValue();\n+    @Strict\n@@ -52,1 +54,1 @@\n-    static volatile MyValue vv;\n+    static volatile MyValue vv = new MyValue();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/BlackholeTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/\/ Generated from the following class files with PointN.x removed and RectangleP.p1 made private\n+\/\/ Generated from the following class files with PointN.x renamed and RectangleP.p1 made private\n@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -34,1 +34,0 @@\n-@ImplicitlyConstructible\n@@ -46,1 +45,0 @@\n-@ImplicitlyConstructible\n@@ -49,0 +47,1 @@\n+    @Strict\n@@ -54,0 +53,1 @@\n+    @Strict\n@@ -63,1 +63,0 @@\n-@ImplicitlyConstructible\n@@ -66,0 +65,1 @@\n+    @Strict\n@@ -71,0 +71,1 @@\n+    @Strict\n@@ -79,0 +80,1 @@\n+\n@@ -87,4 +89,4 @@\n-    Method #2 #3; \/\/ #1\n-    class #4; \/\/ #2\n-    NameAndType #5 #6; \/\/ #3\n-    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n@@ -93,16 +95,16 @@\n-    class #8; \/\/ #7\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #8\n-    Method #7 #3; \/\/ #9\n-    Field #11 #12; \/\/ #10\n-    class #13; \/\/ #11\n-    NameAndType #14 #15; \/\/ #12\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #13\n-    Utf8 \"rect\"; \/\/ #14\n-    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #15\n-    String #17; \/\/ #16\n-    Utf8 \"\"; \/\/ #17\n-    Field #11 #19; \/\/ #18\n-    NameAndType #20 #21; \/\/ #19\n-    Utf8 \"name\"; \/\/ #20\n-    Utf8 \"Ljava\/lang\/String;\"; \/\/ #21\n-    Field #7 #23; \/\/ #22\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #10\n+    Utf8 \"rect\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"\"; \/\/ #14\n+    Field #8 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"name\"; \/\/ #17\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #18\n+    Method #20 #4; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Field #1 #23; \/\/ #22\n@@ -120,7 +122,9 @@\n-    Utf8 \"Code\"; \/\/ #34\n-    Utf8 \"LineNumberTable\"; \/\/ #35\n-    Utf8 \"getP1X\"; \/\/ #36\n-    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #37\n-    Utf8 \"SourceFile\"; \/\/ #38\n-    Utf8 \"Point.java\"; \/\/ #39\n-    Utf8 \"Preload\"; \/\/ #40\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #34\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #35\n+    Utf8 \"Code\"; \/\/ #36\n+    Utf8 \"LineNumberTable\"; \/\/ #37\n+    Utf8 \"getP1X\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"PointN.java\"; \/\/ #41\n+    Utf8 \"LoadableDescriptors\"; \/\/ #42\n@@ -130,2 +134,2 @@\n-  #11;\/\/ this_cpx\n-  #2;\/\/ super_cpx\n+  #8;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n@@ -138,3 +142,3 @@\n-      0x0000; \/\/ access\n-      #14; \/\/ name_index\n-      #15; \/\/ descriptor_index\n+      0x0800; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n@@ -151,0 +155,10 @@\n+        ;\n+        Attr(#34) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #35;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n@@ -156,2 +170,2 @@\n-      #20; \/\/ name_index\n-      #21; \/\/ descriptor_index\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n@@ -169,1 +183,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#36) { \/\/ Code\n@@ -173,3 +187,3 @@\n-            0x2AB700012ABB0007;\n-            0x59B70009B5000A2A;\n-            0x1210B50012B1;\n+            0x2ABB000159B70003;\n+            0xB500072A120DB500;\n+            0x0F2AB70013B1;\n@@ -180,1 +194,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#37) { \/\/ LineNumberTable\n@@ -183,2 +197,3 @@\n-                4  27;\n-                15  29;\n+                11  29;\n+                17  25;\n+                21  29;\n@@ -194,2 +209,2 @@\n-      #36; \/\/ name_index\n-      #37; \/\/ descriptor_index\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n@@ -197,1 +212,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#36) { \/\/ Code\n@@ -201,1 +216,1 @@\n-            0x2AB4000AB40016B4;\n+            0x2AB40007B40016B4;\n@@ -207,1 +222,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#37) { \/\/ LineNumberTable\n@@ -219,2 +234,2 @@\n-    Attr(#38) { \/\/ SourceFile\n-      #39;\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n@@ -223,3 +238,3 @@\n-    Attr(#40) { \/\/ Preload\n-      0x00010007;\n-    } \/\/ end Preload\n+    Attr(#42) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n@@ -228,0 +243,1 @@\n+\n@@ -234,4 +250,4 @@\n-    Method #2 #3; \/\/ #1\n-    class #4; \/\/ #2\n-    NameAndType #5 #6; \/\/ #3\n-    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n@@ -240,16 +256,16 @@\n-    class #8; \/\/ #7\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #8\n-    Method #7 #3; \/\/ #9\n-    Field #11 #12; \/\/ #10\n-    class #13; \/\/ #11\n-    NameAndType #14 #15; \/\/ #12\n-    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #13\n-    Utf8 \"rect\"; \/\/ #14\n-    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #15\n-    String #17; \/\/ #16\n-    Utf8 \"\"; \/\/ #17\n-    Field #11 #19; \/\/ #18\n-    NameAndType #20 #21; \/\/ #19\n-    Utf8 \"name\"; \/\/ #20\n-    Utf8 \"Ljava\/lang\/String;\"; \/\/ #21\n-    Field #7 #23; \/\/ #22\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #10\n+    Utf8 \"rect\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"\"; \/\/ #14\n+    Field #8 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"name\"; \/\/ #17\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #18\n+    Method #20 #4; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Field #1 #23; \/\/ #22\n@@ -267,7 +283,9 @@\n-    Utf8 \"Code\"; \/\/ #34\n-    Utf8 \"LineNumberTable\"; \/\/ #35\n-    Utf8 \"getP1Y\"; \/\/ #36\n-    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #37\n-    Utf8 \"SourceFile\"; \/\/ #38\n-    Utf8 \"Point.java\"; \/\/ #39\n-    Utf8 \"Preload\"; \/\/ #40\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #34\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #35\n+    Utf8 \"Code\"; \/\/ #36\n+    Utf8 \"LineNumberTable\"; \/\/ #37\n+    Utf8 \"getP1Y\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"PointN.java\"; \/\/ #41\n+    Utf8 \"LoadableDescriptors\"; \/\/ #42\n@@ -277,2 +295,2 @@\n-  #11;\/\/ this_cpx\n-  #2;\/\/ super_cpx\n+  #8;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n@@ -285,3 +303,3 @@\n-      0x0000; \/\/ access\n-      #14; \/\/ name_index\n-      #15; \/\/ descriptor_index\n+      0x0800; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n@@ -298,0 +316,10 @@\n+        ;\n+        Attr(#34) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #35;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n@@ -303,2 +331,2 @@\n-      #20; \/\/ name_index\n-      #21; \/\/ descriptor_index\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n@@ -316,1 +344,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#36) { \/\/ Code\n@@ -320,3 +348,3 @@\n-            0x2AB700012ABB0007;\n-            0x59B70009B5000A2A;\n-            0x1210B50012B1;\n+            0x2ABB000159B70003;\n+            0xB500072A120DB500;\n+            0x0F2AB70013B1;\n@@ -327,1 +355,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#37) { \/\/ LineNumberTable\n@@ -329,3 +357,4 @@\n-                0  43;\n-                4  44;\n-                15  46;\n+                0  44;\n+                11  47;\n+                17  43;\n+                21  47;\n@@ -341,2 +370,2 @@\n-      #36; \/\/ name_index\n-      #37; \/\/ descriptor_index\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n@@ -344,1 +373,1 @@\n-        Attr(#34) { \/\/ Code\n+        Attr(#36) { \/\/ Code\n@@ -348,1 +377,1 @@\n-            0x2AB4000AB40016B4;\n+            0x2AB40007B40016B4;\n@@ -354,1 +383,1 @@\n-            Attr(#35) { \/\/ LineNumberTable\n+            Attr(#37) { \/\/ LineNumberTable\n@@ -356,1 +385,1 @@\n-                0  49;\n+                0  50;\n@@ -366,2 +395,2 @@\n-    Attr(#38) { \/\/ SourceFile\n-      #39;\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n@@ -370,3 +399,3 @@\n-    Attr(#40) { \/\/ Preload\n-      0x00010007;\n-    } \/\/ end Preload\n+    Attr(#42) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n@@ -375,0 +404,1 @@\n+\n@@ -385,1 +415,1 @@\n-    Utf8 \"y\"; \/\/ #5\n+    Utf8 \"x0\"; \/\/ #5\n@@ -387,14 +417,16 @@\n-    Method #8 #9; \/\/ #7\n-    class #10; \/\/ #8\n-    NameAndType #11 #12; \/\/ #9\n-    Utf8 \"java\/lang\/Object\"; \/\/ #10\n-    Utf8 \"<init>\"; \/\/ #11\n-    Utf8 \"()V\"; \/\/ #12\n-    Utf8 \"(II)V\"; \/\/ #13\n-    Utf8 \"Code\"; \/\/ #14\n-    Utf8 \"LineNumberTable\"; \/\/ #15\n-    Utf8 \"SourceFile\"; \/\/ #16\n-    Utf8 \"PointN.java\"; \/\/ #17\n-    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #18\n-    Utf8 \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\"; \/\/ #19\n-    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #20\n+    Field #2 #8; \/\/ #7\n+    NameAndType #9 #6; \/\/ #8\n+    Utf8 \"y\"; \/\/ #9\n+    Method #11 #12; \/\/ #10\n+    class #13; \/\/ #11\n+    NameAndType #14 #15; \/\/ #12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #13\n+    Utf8 \"<init>\"; \/\/ #14\n+    Utf8 \"()V\"; \/\/ #15\n+    Utf8 \"(II)V\"; \/\/ #16\n+    Utf8 \"Code\"; \/\/ #17\n+    Utf8 \"LineNumberTable\"; \/\/ #18\n+    Utf8 \"SourceFile\"; \/\/ #19\n+    Utf8 \"PointN.java\"; \/\/ #20\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #21\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #22\n@@ -405,1 +437,1 @@\n-  #8;\/\/ super_cpx\n+  #11;\/\/ super_cpx\n@@ -418,0 +450,8 @@\n+    ;\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #9; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n@@ -423,2 +463,2 @@\n-      #11; \/\/ name_index\n-      #13; \/\/ descriptor_index\n+      #14; \/\/ name_index\n+      #16; \/\/ descriptor_index\n@@ -426,1 +466,1 @@\n-        Attr(#14) { \/\/ Code\n+        Attr(#17) { \/\/ Code\n@@ -430,2 +470,2 @@\n-            0x2A1CB500012AB700;\n-            0x07B1;\n+            0x2A1BB500012A1CB5;\n+            0x00072AB7000AB1;\n@@ -436,1 +476,1 @@\n-            Attr(#15) { \/\/ LineNumberTable\n+            Attr(#18) { \/\/ LineNumberTable\n@@ -439,2 +479,3 @@\n-                5  12;\n-                9  14;\n+                5  14;\n+                10  12;\n+                14  15;\n@@ -450,2 +491,2 @@\n-    Attr(#16) { \/\/ SourceFile\n-      #17;\n+    Attr(#19) { \/\/ SourceFile\n+      #20;\n@@ -454,1 +495,1 @@\n-    Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+    Attr(#21) { \/\/ RuntimeVisibleAnnotations\n@@ -457,7 +498,1 @@\n-          #19;\n-          [] { \/\/ element_value_pairs\n-          }  \/\/  element_value_pairs\n-        }  \/\/  annotation\n-        ;\n-        {  \/\/  annotation\n-          #20;\n+          #22;\n@@ -471,0 +506,1 @@\n+\n@@ -496,7 +532,8 @@\n-    Utf8 \"Code\"; \/\/ #20\n-    Utf8 \"LineNumberTable\"; \/\/ #21\n-    Utf8 \"SourceFile\"; \/\/ #22\n-    Utf8 \"Point.java\"; \/\/ #23\n-    Utf8 \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\"; \/\/ #24\n-    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #25\n-    Utf8 \"Preload\"; \/\/ #26\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #20\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #21\n+    Utf8 \"Code\"; \/\/ #22\n+    Utf8 \"LineNumberTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"PointN.java\"; \/\/ #25\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #26\n+    Utf8 \"LoadableDescriptors\"; \/\/ #27\n@@ -527,0 +564,10 @@\n+        ;\n+        Attr(#20) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #21;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n@@ -537,1 +584,1 @@\n-        Attr(#20) { \/\/ Code\n+        Attr(#22) { \/\/ Code\n@@ -548,1 +595,1 @@\n-            Attr(#21) { \/\/ LineNumberTable\n+            Attr(#23) { \/\/ LineNumberTable\n@@ -550,3 +597,3 @@\n-                0  22;\n-                14  21;\n-                18  22;\n+                0  20;\n+                14  19;\n+                18  20;\n@@ -562,2 +609,2 @@\n-    Attr(#22) { \/\/ SourceFile\n-      #23;\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n@@ -569,7 +616,1 @@\n-          #24;\n-          [] { \/\/ element_value_pairs\n-          }  \/\/  element_value_pairs\n-        }  \/\/  annotation\n-        ;\n-        {  \/\/  annotation\n-          #25;\n+          #26;\n@@ -582,3 +623,3 @@\n-    Attr(#26) { \/\/ Preload\n-      0x00010001;\n-    } \/\/ end Preload\n+    Attr(#27) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n@@ -587,0 +628,1 @@\n+\n@@ -612,7 +654,8 @@\n-    Utf8 \"Code\"; \/\/ #20\n-    Utf8 \"LineNumberTable\"; \/\/ #21\n-    Utf8 \"SourceFile\"; \/\/ #22\n-    Utf8 \"Point.java\"; \/\/ #23\n-    Utf8 \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\"; \/\/ #24\n-    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #25\n-    Utf8 \"Preload\"; \/\/ #26\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #20\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #21\n+    Utf8 \"Code\"; \/\/ #22\n+    Utf8 \"LineNumberTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"PointN.java\"; \/\/ #25\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #26\n+    Utf8 \"LoadableDescriptors\"; \/\/ #27\n@@ -643,0 +686,10 @@\n+        ;\n+        Attr(#20) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #21;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n@@ -653,1 +706,1 @@\n-        Attr(#20) { \/\/ Code\n+        Attr(#22) { \/\/ Code\n@@ -664,1 +717,1 @@\n-            Attr(#21) { \/\/ LineNumberTable\n+            Attr(#23) { \/\/ LineNumberTable\n@@ -666,3 +719,3 @@\n-                0  39;\n-                14  38;\n-                18  39;\n+                0  38;\n+                14  37;\n+                18  38;\n@@ -678,2 +731,2 @@\n-    Attr(#22) { \/\/ SourceFile\n-      #23;\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n@@ -685,7 +738,1 @@\n-          #24;\n-          [] { \/\/ element_value_pairs\n-          }  \/\/  element_value_pairs\n-        }  \/\/  annotation\n-        ;\n-        {  \/\/  annotation\n-          #25;\n+          #26;\n@@ -698,3 +745,3 @@\n-    Attr(#26) { \/\/ Preload\n-      0x00010001;\n-    } \/\/ end Preload\n+    Attr(#27) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":239,"deletions":192,"binary":false,"changes":431,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,1 +28,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyAbstract.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -34,0 +33,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -35,1 +35,0 @@\n-@ImplicitlyConstructible\n@@ -46,0 +45,1 @@\n+    @Strict\n@@ -48,0 +48,1 @@\n+    @Strict\n@@ -50,0 +51,1 @@\n+    @Strict\n@@ -53,0 +55,1 @@\n+    @Strict\n@@ -57,0 +60,2 @@\n+    static final MyValue1 DEFAULT = createDefaultInline();\n+\n@@ -131,13 +136,5 @@\n-    @ForceInline\n-    public void print() {\n-        System.out.print(\"s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z + \", o=\" + (o != null ? (Integer)o : \"NULL\") + \", oa=\" + (oa != null ? oa[0] : \"NULL\") + \", v1[\");\n-        v1.print();\n-        System.out.print(\"], v2[\");\n-        v2.print();\n-        System.out.print(\"], v3[\");\n-        v3.print();\n-        System.out.print(\"], v4[\");\n-        v4.print();\n-        System.out.print(\"], v5[\");\n-        v5.print();\n-        System.out.print(\"], c=\" + c);\n+    @Override\n+    public String toString() {\n+        return \"s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z +\n+               \", o=\" + (o != null ? (Integer)o : \"NULL\") + \", oa=\" + (oa != null ? oa[0] : \"NULL\") +\n+               \", v1=[\" + v1 + \"], v2=[\" + v2 + \"], v3=[\" + v3 + \"], v4=[\" + v4 + \"], v5=[\" + v5 +\"], c=\" + c;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue1.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -32,0 +31,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -33,1 +33,0 @@\n-@ImplicitlyConstructible\n@@ -67,0 +66,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"d=\" + d + \", l=\" + l;\n+    }\n@@ -69,1 +73,0 @@\n-@ImplicitlyConstructible\n@@ -74,0 +77,1 @@\n+    @Strict\n@@ -77,0 +81,2 @@\n+    static final MyValue2 DEFAULT = createDefaultInline();\n+\n@@ -126,3 +132,3 @@\n-    @ForceInline\n-    public void print() {\n-        System.out.print(\"x=\" + x + \", y=\" + y + \", d=\" + v.d + \", l=\" + v.l);\n+    @Override\n+    public String toString() {\n+        return \"x=\" + x + \", y=\" + y + \", v=[\" + v + \"]\";\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue2.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -34,0 +33,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -35,1 +35,0 @@\n-@ImplicitlyConstructible\n@@ -73,1 +72,0 @@\n-@ImplicitlyConstructible\n@@ -88,0 +86,1 @@\n+    @Strict\n@@ -91,0 +90,3 @@\n+    static final MyValue3 DEFAULT = new MyValue3((char)0, (byte)0, (short)0, 0, 0, null,\n+                                                 0, 0, 0, 0, 0, 0, new MyValue3Inline(0, 0));\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue3.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -31,0 +30,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -33,1 +33,0 @@\n-@ImplicitlyConstructible\n@@ -36,0 +35,1 @@\n+    @Strict\n@@ -38,0 +38,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue4.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,1 +28,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueEmpty.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -46,1 +45,0 @@\n-@ImplicitlyConstructible\n@@ -108,1 +106,1 @@\n-            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, new MyValue1());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayAccessDeopt.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -61,1 +60,0 @@\n-    @ImplicitlyConstructible\n@@ -75,5 +73,1 @@\n-        ManyOops[] array = (ManyOops[])ValueClass.newNullRestrictedArray(ManyOops.class, LEN);\n-        for (int i = 0; i < LEN; ++i) {\n-            array[i] = new ManyOops();\n-        }\n-        return array;\n+        return (ManyOops[])ValueClass.newNullRestrictedNonAtomicArray(ManyOops.class, LEN, new ManyOops());\n@@ -111,1 +105,1 @@\n-        ManyOops[] dst = (ManyOops[])ValueClass.newNullRestrictedArray(ManyOops.class, LEN);\n+        ManyOops[] dst = (ManyOops[])ValueClass.newNullRestrictedNonAtomicArray(ManyOops.class, LEN, new ManyOops());\n@@ -123,1 +117,1 @@\n-        ManyOops[] dst = (ManyOops[])ValueClass.newNullRestrictedArray(ManyOops.class, LEN);\n+        ManyOops[] dst = (ManyOops[])ValueClass.newNullRestrictedNonAtomicArray(ManyOops.class, LEN, new ManyOops());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -36,1 +35,0 @@\n- * @key randomness\n@@ -92,1 +90,0 @@\n-    @ImplicitlyConstructible\n@@ -100,0 +97,2 @@\n+\n+        static final OneByte DEFAULT = new OneByte((byte)0);\n@@ -103,1 +102,0 @@\n-    @ImplicitlyConstructible\n@@ -113,0 +111,2 @@\n+\n+        static final TwoBytes DEFAULT = new TwoBytes((byte)0, (byte)0);\n@@ -116,1 +116,0 @@\n-    @ImplicitlyConstructible\n@@ -126,0 +125,2 @@\n+\n+        static final TwoShorts DEFAULT = new TwoShorts((short)0, (short)0);\n@@ -129,1 +130,0 @@\n-    @ImplicitlyConstructible\n@@ -139,0 +139,2 @@\n+\n+        static final TwoInts DEFAULT = new TwoInts(0, 0);\n@@ -142,1 +144,0 @@\n-    @ImplicitlyConstructible\n@@ -152,0 +153,2 @@\n+\n+        static final TwoLongs DEFAULT = new TwoLongs(0, 0);\n@@ -155,1 +158,0 @@\n-    @ImplicitlyConstructible\n@@ -165,0 +167,2 @@\n+\n+        static final ByteAndOop DEFAULT = new ByteAndOop((byte)0, null);\n@@ -274,1 +278,37 @@\n-        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedArray(TwoBytes.class, size);\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, TwoBytes.DEFAULT);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], TwoBytes.DEFAULT);\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    \/\/ Non-final value to initialize null-restricted arrays\n+    static Object initVal1 = CANARY1;\n+    static TwoBytes initVal2 = CANARY1;\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsicDynamic1(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, initVal1);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], CANARY1);\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsicDynamic2(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, initVal2);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], CANARY1);\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    static byte myByte = 0;\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsicDynamic3(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, new TwoBytes(++myByte, myByte));\n@@ -277,1 +317,1 @@\n-        Asserts.assertEquals(nullFreeArray[idx], new TwoBytes((byte)0, (byte)0));\n+        Asserts.assertEquals(nullFreeArray[idx], new TwoBytes(myByte, myByte));\n@@ -284,1 +324,11 @@\n-        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size);\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, TwoBytes.DEFAULT);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], TwoBytes.DEFAULT);\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsicDynamic1(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, initVal1);\n@@ -287,1 +337,21 @@\n-        Asserts.assertEquals(nullFreeAtomicArray[idx], new TwoBytes((byte)0, (byte)0));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], CANARY1);\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsicDynamic2(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, initVal2);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], CANARY1);\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsicDynamic3(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, new TwoBytes(++myByte, myByte));\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], new TwoBytes(myByte, myByte));\n@@ -303,1 +373,0 @@\n-    @ImplicitlyConstructible\n@@ -311,0 +380,2 @@\n+\n+        static final ValueHolder1 DEFAULT = new ValueHolder1(null);\n@@ -314,4 +385,4 @@\n-    public static void testScalarReplacement1(boolean trap) {\n-        OneByte[] nullFreeArray = (OneByte[])ValueClass.newNullRestrictedArray(OneByte.class, 1);\n-        OneByte val = new OneByte((byte)42);\n-        nullFreeArray[0] = val;\n+    public static void testScalarReplacement1(OneByte valNullFree, OneByte val, boolean trap) {\n+        OneByte[] nullFreeArray = (OneByte[])ValueClass.newNullRestrictedNonAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n+        nullFreeArray[0] = valNullFree;\n+        nullFreeArray[1] = new OneByte((byte)42);\n@@ -319,1 +390,2 @@\n-            Asserts.assertEQ(nullFreeArray[0], val);\n+            Asserts.assertEQ(nullFreeArray[0], valNullFree);\n+            Asserts.assertEQ(nullFreeArray[1], new OneByte((byte)42));\n@@ -322,2 +394,3 @@\n-        OneByte[] nullFreeAtomicArray = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 1);\n-        nullFreeAtomicArray[0] = val;\n+        OneByte[] nullFreeAtomicArray = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n+        nullFreeAtomicArray[0] = valNullFree;\n+        nullFreeAtomicArray[1] = new OneByte((byte)42);\n@@ -325,1 +398,2 @@\n-            Asserts.assertEQ(nullFreeAtomicArray[0], val);\n+            Asserts.assertEQ(nullFreeAtomicArray[0], valNullFree);\n+            Asserts.assertEQ(nullFreeAtomicArray[1], new OneByte((byte)42));\n@@ -328,3 +402,5 @@\n-        OneByte[] nullableAtomicArray = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 2);\n-        nullableAtomicArray[0] = val;\n-        nullableAtomicArray[1] = null;\n+        OneByte[] nullableAtomicArray = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 4);\n+        nullableAtomicArray[0] = valNullFree;\n+        nullableAtomicArray[1] = val;\n+        nullableAtomicArray[2] = new OneByte((byte)42);\n+        nullableAtomicArray[3] = null;\n@@ -332,2 +408,4 @@\n-            Asserts.assertEQ(nullableAtomicArray[0], val);\n-            Asserts.assertEQ(nullableAtomicArray[1], null);\n+            Asserts.assertEQ(nullableAtomicArray[0], valNullFree);\n+            Asserts.assertEQ(nullableAtomicArray[1], val);\n+            Asserts.assertEQ(nullableAtomicArray[2], new OneByte((byte)42));\n+            Asserts.assertEQ(nullableAtomicArray[3], null);\n@@ -336,3 +414,5 @@\n-        OneByte[] nullableArray = new OneByte[2];\n-        nullableArray[0] = val;\n-        nullableArray[1] = null;\n+        OneByte[] nullableArray = new OneByte[4];\n+        nullableArray[0] = valNullFree;\n+        nullableArray[1] = val;\n+        nullableArray[2] = new OneByte((byte)42);\n+        nullableArray[3] = null;\n@@ -340,2 +420,4 @@\n-            Asserts.assertEQ(nullableArray[0], val);\n-            Asserts.assertEQ(nullableArray[1], null);\n+            Asserts.assertEQ(nullableArray[0], valNullFree);\n+            Asserts.assertEQ(nullableArray[1], val);\n+            Asserts.assertEQ(nullableArray[2], new OneByte((byte)42));\n+            Asserts.assertEQ(nullableArray[3], null);\n@@ -346,3 +428,2 @@\n-    public static void testScalarReplacement2(boolean trap) {\n-        ValueHolder1[] nullFreeArray = (ValueHolder1[])ValueClass.newNullRestrictedArray(ValueHolder1.class, 1);\n-        TwoBytes val = new TwoBytes((byte)42, (byte)43);\n+    public static void testScalarReplacement2(TwoBytes val, boolean trap) {\n+        ValueHolder1[] nullFreeArray = (ValueHolder1[])ValueClass.newNullRestrictedNonAtomicArray(ValueHolder1.class, 1, ValueHolder1.DEFAULT);\n@@ -354,1 +435,1 @@\n-        ValueHolder1[] nullFreeAtomicArray = (ValueHolder1[])ValueClass.newNullRestrictedAtomicArray(ValueHolder1.class, 1);\n+        ValueHolder1[] nullFreeAtomicArray = (ValueHolder1[])ValueClass.newNullRestrictedAtomicArray(ValueHolder1.class, 1, ValueHolder1.DEFAULT);\n@@ -362,1 +443,1 @@\n-        nullableAtomicArray[1] = new ValueHolder1(null);\n+        nullableAtomicArray[1] = ValueHolder1.DEFAULT;\n@@ -370,1 +451,1 @@\n-        nullableArray[1] = new ValueHolder1(null);\n+        nullableArray[1] = ValueHolder1.DEFAULT;\n@@ -387,1 +468,1 @@\n-    static TwoShorts[] array1 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 1);\n+    static TwoShorts[] array1 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 1, TwoShorts.DEFAULT);\n@@ -390,1 +471,1 @@\n-        array2[0] = new TwoShorts((short)0, (short)0);\n+        array2[0] = TwoShorts.DEFAULT;\n@@ -392,1 +473,1 @@\n-    static TwoShorts[] array3 = new TwoShorts[] { new TwoShorts((short)0, (short)0) };\n+    static TwoShorts[] array3 = new TwoShorts[] { TwoShorts.DEFAULT };\n@@ -401,2 +482,2 @@\n-    static final OneByte[] NULL_FREE_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedArray(OneByte.class, 2);\n-    static final OneByte[] NULL_FREE_ATOMIC_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 2);\n+    static final OneByte[] NULL_FREE_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedNonAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n+    static final OneByte[] NULL_FREE_ATOMIC_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n@@ -406,2 +487,2 @@\n-    static final TwoBytes[] NULL_FREE_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedArray(TwoBytes.class, 2);\n-    static final TwoBytes[] NULL_FREE_ATOMIC_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 2);\n+    static final TwoBytes[] NULL_FREE_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, 2, TwoBytes.DEFAULT);\n+    static final TwoBytes[] NULL_FREE_ATOMIC_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 2, TwoBytes.DEFAULT);\n@@ -411,2 +492,2 @@\n-    static final TwoShorts[] NULL_FREE_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedArray(TwoShorts.class, 2);\n-    static final TwoShorts[] NULL_FREE_ATOMIC_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 2);\n+    static final TwoShorts[] NULL_FREE_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedNonAtomicArray(TwoShorts.class, 2, TwoShorts.DEFAULT);\n+    static final TwoShorts[] NULL_FREE_ATOMIC_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 2, TwoShorts.DEFAULT);\n@@ -416,2 +497,2 @@\n-    static final TwoInts[] NULL_FREE_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedArray(TwoInts.class, 1);\n-    static final TwoInts[] NULL_FREE_ATOMIC_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 1);\n+    static final TwoInts[] NULL_FREE_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedNonAtomicArray(TwoInts.class, 1, TwoInts.DEFAULT);\n+    static final TwoInts[] NULL_FREE_ATOMIC_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 1, TwoInts.DEFAULT);\n@@ -421,2 +502,2 @@\n-    static final TwoLongs[] NULL_FREE_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedArray(TwoLongs.class, 1);\n-    static final TwoLongs[] NULL_FREE_ATOMIC_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 1);\n+    static final TwoLongs[] NULL_FREE_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedNonAtomicArray(TwoLongs.class, 1, TwoLongs.DEFAULT);\n+    static final TwoLongs[] NULL_FREE_ATOMIC_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 1, TwoLongs.DEFAULT);\n@@ -426,2 +507,2 @@\n-    static final ByteAndOop[] NULL_FREE_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedArray(ByteAndOop.class, 1);\n-    static final ByteAndOop[] NULL_FREE_ATOMIC_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 1);\n+    static final ByteAndOop[] NULL_FREE_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedNonAtomicArray(ByteAndOop.class, 1, ByteAndOop.DEFAULT);\n+    static final ByteAndOop[] NULL_FREE_ATOMIC_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 1, ByteAndOop.DEFAULT);\n@@ -433,1 +514,0 @@\n-        OneByte default0 = new OneByte((byte)0);\n@@ -435,2 +515,2 @@\n-        Asserts.assertEQ(NULL_FREE_ARRAY_0[0], default0);\n-        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_0[0], default0);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_0[0], OneByte.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_0[0], OneByte.DEFAULT);\n@@ -463,2 +543,2 @@\n-        NULL_FREE_ARRAY_0[0] = default0;\n-        NULL_FREE_ATOMIC_ARRAY_0[0] = default0;\n+        NULL_FREE_ARRAY_0[0] = OneByte.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_0[0] = OneByte.DEFAULT;\n@@ -468,1 +548,0 @@\n-        TwoBytes default1 = new TwoBytes((byte)0, (byte)0);\n@@ -470,2 +549,2 @@\n-        Asserts.assertEQ(NULL_FREE_ARRAY_1[0], default1);\n-        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_1[0], default1);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_1[0], TwoBytes.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_1[0], TwoBytes.DEFAULT);\n@@ -498,2 +577,2 @@\n-        NULL_FREE_ARRAY_1[0] = default1;\n-        NULL_FREE_ATOMIC_ARRAY_1[0] = default1;\n+        NULL_FREE_ARRAY_1[0] = TwoBytes.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_1[0] = TwoBytes.DEFAULT;\n@@ -503,1 +582,0 @@\n-        TwoShorts default2 = new TwoShorts((short)0, (short)0);\n@@ -505,2 +583,2 @@\n-        Asserts.assertEQ(NULL_FREE_ARRAY_2[0], default2);\n-        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_2[0], default2);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_2[0], TwoShorts.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_2[0], TwoShorts.DEFAULT);\n@@ -533,2 +611,2 @@\n-        NULL_FREE_ARRAY_2[0] = default2;\n-        NULL_FREE_ATOMIC_ARRAY_2[0] = default2;\n+        NULL_FREE_ARRAY_2[0] = TwoShorts.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_2[0] = TwoShorts.DEFAULT;\n@@ -538,1 +616,0 @@\n-        TwoInts default3 = new TwoInts(0, 0);\n@@ -540,2 +617,2 @@\n-        Asserts.assertEQ(NULL_FREE_ARRAY_3[0], default3);\n-        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_3[0], default3);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_3[0], TwoInts.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_3[0], TwoInts.DEFAULT);\n@@ -568,2 +645,2 @@\n-        NULL_FREE_ARRAY_3[0] = default3;\n-        NULL_FREE_ATOMIC_ARRAY_3[0] = default3;\n+        NULL_FREE_ARRAY_3[0] = TwoInts.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_3[0] = TwoInts.DEFAULT;\n@@ -573,1 +650,0 @@\n-        TwoLongs default4 = new TwoLongs(0, 0);\n@@ -575,2 +651,2 @@\n-        Asserts.assertEQ(NULL_FREE_ARRAY_4[0], default4);\n-        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_4[0], default4);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_4[0], TwoLongs.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_4[0], TwoLongs.DEFAULT);\n@@ -603,2 +679,2 @@\n-        NULL_FREE_ARRAY_4[0] = default4;\n-        NULL_FREE_ATOMIC_ARRAY_4[0] = default4;\n+        NULL_FREE_ARRAY_4[0] = TwoLongs.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_4[0] = TwoLongs.DEFAULT;\n@@ -608,1 +684,0 @@\n-        ByteAndOop default5 = new ByteAndOop((byte)0, null);\n@@ -610,2 +685,2 @@\n-        Asserts.assertEQ(NULL_FREE_ARRAY_5[0], default5);\n-        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_5[0], default5);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_5[0], ByteAndOop.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_5[0], ByteAndOop.DEFAULT);\n@@ -638,2 +713,2 @@\n-        NULL_FREE_ARRAY_5[0] = default5;\n-        NULL_FREE_ATOMIC_ARRAY_5[0] = default5;\n+        NULL_FREE_ARRAY_5[0] = ByteAndOop.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_5[0] = ByteAndOop.DEFAULT;\n@@ -664,2 +739,2 @@\n-        OneByte[] nullFreeArray0 = (OneByte[])ValueClass.newNullRestrictedArray(OneByte.class, 3);\n-        OneByte[] nullFreeAtomicArray0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 3);\n+        OneByte[] nullFreeArray0 = (OneByte[])ValueClass.newNullRestrictedNonAtomicArray(OneByte.class, 3, OneByte.DEFAULT);\n+        OneByte[] nullFreeAtomicArray0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 3, OneByte.DEFAULT);\n@@ -669,2 +744,2 @@\n-        TwoBytes[] nullFreeArray1 = (TwoBytes[])ValueClass.newNullRestrictedArray(TwoBytes.class, 3);\n-        TwoBytes[] nullFreeAtomicArray1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 3);\n+        TwoBytes[] nullFreeArray1 = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, 3, TwoBytes.DEFAULT);\n+        TwoBytes[] nullFreeAtomicArray1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 3, TwoBytes.DEFAULT);\n@@ -674,2 +749,2 @@\n-        TwoShorts[] nullFreeArray2 = (TwoShorts[])ValueClass.newNullRestrictedArray(TwoShorts.class, 3);\n-        TwoShorts[] nullFreeAtomicArray2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 3);\n+        TwoShorts[] nullFreeArray2 = (TwoShorts[])ValueClass.newNullRestrictedNonAtomicArray(TwoShorts.class, 3, TwoShorts.DEFAULT);\n+        TwoShorts[] nullFreeAtomicArray2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 3, TwoShorts.DEFAULT);\n@@ -679,2 +754,2 @@\n-        TwoInts[] nullFreeArray3 = (TwoInts[])ValueClass.newNullRestrictedArray(TwoInts.class, 3);\n-        TwoInts[] nullFreeAtomicArray3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 3);\n+        TwoInts[] nullFreeArray3 = (TwoInts[])ValueClass.newNullRestrictedNonAtomicArray(TwoInts.class, 3, TwoInts.DEFAULT);\n+        TwoInts[] nullFreeAtomicArray3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 3, TwoInts.DEFAULT);\n@@ -684,2 +759,2 @@\n-        TwoLongs[] nullFreeArray4 = (TwoLongs[])ValueClass.newNullRestrictedArray(TwoLongs.class, 3);\n-        TwoLongs[] nullFreeAtomicArray4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 3);\n+        TwoLongs[] nullFreeArray4 = (TwoLongs[])ValueClass.newNullRestrictedNonAtomicArray(TwoLongs.class, 3, TwoLongs.DEFAULT);\n+        TwoLongs[] nullFreeAtomicArray4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 3, TwoLongs.DEFAULT);\n@@ -689,2 +764,2 @@\n-        ByteAndOop[] nullFreeArray5 = (ByteAndOop[])ValueClass.newNullRestrictedArray(ByteAndOop.class, 3);\n-        ByteAndOop[] nullFreeAtomicArray5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 3);\n+        ByteAndOop[] nullFreeArray5 = (ByteAndOop[])ValueClass.newNullRestrictedNonAtomicArray(ByteAndOop.class, 3, ByteAndOop.DEFAULT);\n+        ByteAndOop[] nullFreeAtomicArray5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 3, ByteAndOop.DEFAULT);\n@@ -901,0 +976,6 @@\n+            res = testNullRestrictedArrayIntrinsicDynamic1(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedArrayIntrinsicDynamic2(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedArrayIntrinsicDynamic3(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n@@ -903,0 +984,6 @@\n+            res = testNullRestrictedAtomicArrayIntrinsicDynamic1(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedAtomicArrayIntrinsicDynamic2(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedAtomicArrayIntrinsicDynamic3(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n@@ -938,2 +1025,2 @@\n-            testScalarReplacement1(false);\n-            testScalarReplacement2(false);\n+            testScalarReplacement1(val0, null, false);\n+            testScalarReplacement2(val1, false);\n@@ -1047,0 +1134,18 @@\n+        try {\n+            testNullRestrictedArrayIntrinsicDynamic1(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedArrayIntrinsicDynamic2(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedArrayIntrinsicDynamic3(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n@@ -1053,0 +1158,18 @@\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsicDynamic1(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsicDynamic2(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsicDynamic3(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n@@ -1054,2 +1177,2 @@\n-        testScalarReplacement1(true);\n-        testScalarReplacement2(true);\n+        testScalarReplacement1(CANARY0, null, true);\n+        testScalarReplacement2(CANARY1, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":221,"deletions":98,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -88,30 +88,0 @@\n-        if (src instanceof MyInterface[] && dst instanceof MyInterface[]) {\n-            for (int i = 0; i < src.length; ++i) {\n-                Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());\n-            }\n-        } else {\n-            for (int i = 0; i < src.length; ++i) {\n-                Asserts.assertEQ(src[i], dst[i]);\n-            }\n-        }\n-    }\n-\n-    static void verify(MyValue1[] src, MyValue1[] dst) {\n-        for (int i = 0; i < src.length; ++i) {\n-            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n-        }\n-    }\n-\n-    static void verify(MyValue1[] src, Object[] dst) {\n-        for (int i = 0; i < src.length; ++i) {\n-            Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n-        }\n-    }\n-\n-    static void verify(MyValue2[] src, MyValue2[] dst) {\n-        for (int i = 0; i < src.length; ++i) {\n-            Asserts.assertEQ(src[i].hash(), dst[i].hash());\n-        }\n-    }\n-\n-    static void verify(MyValue2[] src, Object[] dst) {\n@@ -119,1 +89,1 @@\n-            Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n+            Asserts.assertEQ(src[i], dst[i]);\n@@ -133,1 +103,0 @@\n-    @ImplicitlyConstructible\n@@ -142,0 +111,2 @@\n+\n+        static final NotFlattenable DEFAULT = new NotFlattenable();\n@@ -152,1 +123,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -172,1 +143,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -198,1 +169,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, MyValue1.DEFAULT);\n@@ -222,1 +193,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, MyValue1.DEFAULT);\n@@ -237,1 +208,1 @@\n-            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 5);\n+            va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 5, MyValue1.DEFAULT);\n@@ -242,1 +213,1 @@\n-            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+            va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, MyValue1.DEFAULT);\n@@ -274,1 +245,1 @@\n-    @IR(failOn = {ALLOC, ALLOCA, LOOP, LOAD, STORE, TRAP})\n+    @IR(failOn = {ALLOCA, LOOP, LOAD, TRAP})\n@@ -276,1 +247,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -282,1 +253,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -287,1 +258,1 @@\n-    \/\/ Test default initialization of value class arrays\n+    \/\/ Test initialization of value class arrays\n@@ -291,1 +262,1 @@\n-        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -297,1 +268,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -308,1 +279,1 @@\n-        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0);\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT);\n@@ -328,1 +299,1 @@\n-        test9_va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        test9_va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -398,1 +369,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, arraySize, MyValue1.DEFAULT);\n@@ -420,1 +391,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, arraySize, MyValue1.DEFAULT);\n@@ -447,1 +418,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, arraySize, MyValue1.DEFAULT);\n@@ -468,1 +439,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, arraySize, MyValue1.DEFAULT);\n@@ -489,1 +460,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, arraySize, MyValue1.DEFAULT);\n@@ -516,1 +487,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, arraySize);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, arraySize, MyValue1.DEFAULT);\n@@ -547,1 +518,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -562,1 +533,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -588,2 +559,2 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -608,2 +579,2 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -623,1 +594,1 @@\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, src.length);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, src.length, MyValue1.DEFAULT);\n@@ -631,1 +602,1 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -645,1 +616,1 @@\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, src.length + 10);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, src.length + 10, MyValue1.DEFAULT);\n@@ -653,1 +624,1 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -672,2 +643,2 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[] dst1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -696,2 +667,2 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -715,2 +686,2 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -734,2 +705,2 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -751,1 +722,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -773,1 +744,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -780,1 +751,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -792,1 +763,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -801,1 +772,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -814,1 +785,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT);\n@@ -847,1 +818,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -884,1 +855,1 @@\n-            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+            va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -937,2 +908,2 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[] dst1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -961,2 +932,2 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -982,2 +953,2 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -1005,1 +976,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -1029,1 +1000,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -1052,1 +1023,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -1076,1 +1047,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -1117,2 +1088,2 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -1137,2 +1108,2 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -1157,2 +1128,2 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -1179,1 +1150,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -1202,1 +1173,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -1224,1 +1195,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -1247,1 +1218,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -1289,1 +1260,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1297,1 +1268,1 @@\n-    static final MyValue1[] test52_va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+    static final MyValue1[] test52_va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -1323,1 +1294,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1339,1 +1310,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1355,1 +1326,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1388,1 +1359,1 @@\n-        Object[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        Object[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1404,1 +1375,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1426,2 +1397,2 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len + 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, len);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, len + 1);\n@@ -1433,3 +1404,0 @@\n-        \/\/ Result is a null-restricted array\n-        Asserts.assertEQ(result[len], ValueClass.zeroInstance(MyValue1.class));\n-        result[len] = MyValue1.createDefaultInline();\n@@ -1447,2 +1415,2 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len + 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, len);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, len + 1);\n@@ -1454,3 +1422,0 @@\n-        \/\/ Result is a null-restricted array\n-        Asserts.assertEQ(result[len], ValueClass.zeroInstance(MyValue1.class));\n-        result[len] = MyValue1.createDefaultInline();\n@@ -1502,1 +1467,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1538,2 +1503,2 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len + 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, len);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, len + 1);\n@@ -1547,3 +1512,0 @@\n-        \/\/ Result is a null-restricted array\n-        Asserts.assertEQ(result[len], MyValue1.createDefaultInline());\n-        result[len] = MyValue1.createDefaultInline();\n@@ -1553,1 +1515,1 @@\n-    \/\/ Test default initialization of value class arrays: small array\n+    \/\/ Test initialization of value class arrays: small array\n@@ -1556,1 +1518,1 @@\n-        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -1561,1 +1523,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -1568,1 +1530,1 @@\n-    \/\/ Test default initialization of value class arrays: large array\n+    \/\/ Test initialization of value class arrays: large array\n@@ -1571,1 +1533,1 @@\n-        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 32);\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 32, MyValue1.DEFAULT);\n@@ -1576,1 +1538,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 32);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 32, MyValue1.DEFAULT);\n@@ -1587,1 +1549,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1602,1 +1564,1 @@\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 16);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 16, MyValue1.DEFAULT);\n@@ -1609,1 +1571,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 16);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 16, MyValue1.DEFAULT);\n@@ -1616,1 +1578,1 @@\n-    \/\/ A store with a default value can be eliminated\n+    \/\/ A store with an all-zero value can be eliminated\n@@ -1619,1 +1581,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1626,1 +1588,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1636,1 +1598,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 4);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 4, MyValue1.DEFAULT);\n@@ -1645,1 +1607,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 4);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 4, MyValue1.DEFAULT);\n@@ -1654,2 +1616,1 @@\n-    \/\/ A store with a default value can be eliminated: same as test68\n-    \/\/ but store is further away from allocation\n+    \/\/ Same as test68 but store is further away from allocation\n@@ -1659,1 +1620,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1667,1 +1628,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1678,2 +1639,2 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -1729,1 +1690,1 @@\n-        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 3, MyValue1.DEFAULT);\n@@ -1753,1 +1714,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT);\n@@ -1781,1 +1742,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1819,2 +1780,2 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] verif = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1844,1 +1805,1 @@\n-        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1867,1 +1828,1 @@\n-        MyValue1[] a = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, n);\n+        MyValue1[] a = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, n, MyValue1.DEFAULT);\n@@ -1918,1 +1879,1 @@\n-        NotFlattenable[] array = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n+        NotFlattenable[] array = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 2, NotFlattenable.DEFAULT);\n@@ -1970,1 +1931,1 @@\n-        NotFlattenable[] array1 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 3);\n+        NotFlattenable[] array1 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 3, NotFlattenable.DEFAULT);\n@@ -2034,1 +1995,1 @@\n-            NotFlattenable[] array3 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n+            NotFlattenable[] array3 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 2, NotFlattenable.DEFAULT);\n@@ -2076,1 +2037,1 @@\n-            NotFlattenable[] array3 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n+            NotFlattenable[] array3 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 2, NotFlattenable.DEFAULT);\n@@ -2112,1 +2073,1 @@\n-            NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 2);\n+            NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 2, NotFlattenable.DEFAULT);\n@@ -2148,1 +2109,1 @@\n-            MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+            MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2173,1 +2134,1 @@\n-            MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2195,1 +2156,1 @@\n-            MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2209,1 +2170,1 @@\n-        MyValue1[] qArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0);\n+        MyValue1[] qArray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT);\n@@ -2215,1 +2176,1 @@\n-        MyValue1[][] qArray2 = { (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 0) };\n+        MyValue1[][] qArray2 = { (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 0, MyValue1.DEFAULT) };\n@@ -2229,1 +2190,0 @@\n-    @ImplicitlyConstructible\n@@ -2270,1 +2230,1 @@\n-        Test91Value[] array = (Test91Value[])ValueClass.newNullRestrictedArray(Test91Value.class, 5);\n+        Test91Value[] array = (Test91Value[])ValueClass.newNullRestrictedNonAtomicArray(Test91Value.class, 5, new Test91Value(0));\n@@ -2288,2 +2248,2 @@\n-        MyValue1[] a = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n-        MyValue1[] b = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] a = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        MyValue1[] b = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2308,1 +2268,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -2318,1 +2278,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -2333,1 +2293,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -2343,1 +2303,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -2354,1 +2314,1 @@\n-    static final MyValue1[] nullFreeArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+    static final MyValue1[] nullFreeArray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2368,1 +2328,1 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2397,1 +2357,1 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2426,1 +2386,1 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2470,2 +2430,2 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n-        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 1, NotFlattenable.DEFAULT);\n@@ -2503,2 +2463,2 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n-        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 1, NotFlattenable.DEFAULT);\n@@ -2535,2 +2495,2 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n-        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 1, NotFlattenable.DEFAULT);\n@@ -2559,2 +2519,2 @@\n-        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n-        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 1, NotFlattenable.DEFAULT);\n+        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2576,2 +2536,2 @@\n-        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n-        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        NotFlattenable[] array2 = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 1, NotFlattenable.DEFAULT);\n+        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2593,2 +2553,2 @@\n-    static final MyValue2[] val_src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n-    static final MyValue2[] val_dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+    static final MyValue2[] val_src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+    static final MyValue2[] val_dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -3157,0 +3117,1 @@\n+    @Strict\n@@ -3162,1 +3123,1 @@\n-    @IR(failOn = {ALLOC, ALLOCA, LOAD})\n+    @IR(failOn = {LOAD})\n@@ -3170,1 +3131,1 @@\n-        MyValueEmpty[] array = (MyValueEmpty[])ValueClass.newNullRestrictedArray(MyValueEmpty.class, 2);\n+        MyValueEmpty[] array = (MyValueEmpty[])ValueClass.newNullRestrictedNonAtomicArray(MyValueEmpty.class, 2, empty);\n@@ -3176,1 +3137,0 @@\n-    @ImplicitlyConstructible\n@@ -3179,0 +3139,1 @@\n+        @Strict\n@@ -3185,1 +3146,1 @@\n-    @IR(failOn = {ALLOC, ALLOCA, LOAD})\n+    @IR(failOn = {LOAD})\n@@ -3193,1 +3154,1 @@\n-        EmptyContainer[] array = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 2);\n+        EmptyContainer[] array = (EmptyContainer[])ValueClass.newNullRestrictedNonAtomicArray(EmptyContainer.class, 2, new EmptyContainer());\n@@ -3208,1 +3169,1 @@\n-        Object[] array = (MyValueEmpty[])ValueClass.newNullRestrictedArray(MyValueEmpty.class, 2);\n+        Object[] array = (MyValueEmpty[])ValueClass.newNullRestrictedNonAtomicArray(MyValueEmpty.class, 2, empty);\n@@ -3228,1 +3189,1 @@\n-        Object[] array = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 2);\n+        Object[] array = (EmptyContainer[])ValueClass.newNullRestrictedNonAtomicArray(EmptyContainer.class, 2, new EmptyContainer());\n@@ -3262,1 +3223,1 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -3291,1 +3252,1 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -3316,1 +3277,1 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 100);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 100, MyValue1.DEFAULT);\n@@ -3359,1 +3320,1 @@\n-        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 100);\n+        MyValue1[] array1 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 100, MyValue1.DEFAULT);\n@@ -3385,1 +3346,1 @@\n-        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -3406,1 +3367,1 @@\n-        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -3431,1 +3392,1 @@\n-        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -3452,1 +3413,1 @@\n-        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        Object[] varray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -3534,1 +3495,1 @@\n-        Object[] array = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 1);\n+        Object[] array = (EmptyContainer[])ValueClass.newNullRestrictedNonAtomicArray(EmptyContainer.class, 1, new EmptyContainer());\n@@ -3566,1 +3527,1 @@\n-        MyValue2[] array = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n+        MyValue2[] array = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT);\n@@ -3597,2 +3558,2 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -3646,1 +3607,0 @@\n-    @ImplicitlyConstructible\n@@ -3649,1 +3609,5 @@\n-        Object s = \"test\";\n+        Object s;\n+\n+        public Test150Value(String s) {\n+            this.s = s;\n+        }\n@@ -3654,3 +3618,3 @@\n-    static String test150() {\n-        Test150Value[] array = (Test150Value[])ValueClass.newNullRestrictedArray(Test150Value.class, 1);\n-        array[0] = new Test150Value();\n+    static String test150(String s) {\n+        Test150Value[] array = (Test150Value[])ValueClass.newNullRestrictedNonAtomicArray(Test150Value.class, 1, new Test150Value(\"test\"));\n+        array[0] = new Test150Value(s);\n@@ -3659,0 +3623,5 @@\n+\n+    @Run(test = \"test150\")\n+    public void test150_verifier() {\n+        Asserts.assertEquals(test150(\"bla\"), \"bla\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":177,"deletions":208,"binary":false,"changes":385,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -35,0 +34,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -160,1 +160,1 @@\n-        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the all-zero value)\n@@ -163,1 +163,1 @@\n-        counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the all-zero value)\n@@ -295,1 +295,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, Math.abs(rI) % 10);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, Math.abs(rI) % 10, MyValue1.DEFAULT);\n@@ -325,1 +325,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, Math.abs(rI) % 10);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, Math.abs(rI) % 10, MyValue1.DEFAULT);\n@@ -375,1 +375,1 @@\n-        counts = {ALLOC, \"<= 1\"}) \/\/ 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 1\"}) \/\/ 1 MyValue2 allocation (if not the all-zero value)\n@@ -378,1 +378,1 @@\n-        counts = {ALLOC, \"<= 2\"}) \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 2\"}) \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the all-zero value)\n@@ -425,1 +425,1 @@\n-        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the all-zero value)\n@@ -428,1 +428,1 @@\n-        counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the all-zero value)\n@@ -447,1 +447,1 @@\n-        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the all-zero value)\n@@ -450,1 +450,1 @@\n-        counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the all-zero value)\n@@ -474,1 +474,1 @@\n-        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the default value)\n+        counts = {ALLOC, \"<= 1\"}, \/\/ 1 MyValue2 allocation (if not the all-zero value)\n@@ -476,3 +476,4 @@\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n-        counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the default value)\n-        failOn = LOAD)\n+    \/\/ TODO 8350865\n+    \/\/@IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+    \/\/    counts = {ALLOC, \"<= 2\"}, \/\/ 1 MyValue1 and 1 MyValue2 allocation (if not the all-zero value)\n+    \/\/    failOn = LOAD)\n@@ -481,1 +482,1 @@\n-        MyValue2[] va = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 3);\n+        MyValue2[] va = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 3, MyValue2.DEFAULT);\n@@ -493,1 +494,1 @@\n-        MyValue2[] va = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 42);\n+        MyValue2[] va = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 42, MyValue2.DEFAULT);\n@@ -499,1 +500,0 @@\n-    @NullRestricted\n@@ -501,1 +501,0 @@\n-    @NullRestricted\n@@ -503,0 +502,1 @@\n+    @Strict\n@@ -505,0 +505,1 @@\n+    @Strict\n@@ -506,1 +507,2 @@\n-    static MyValue1 val4;\n+    static MyValue1 val4 = MyValue1.DEFAULT;\n+    @Strict\n@@ -615,0 +617,1 @@\n+        @Strict\n@@ -616,1 +619,1 @@\n-        public MyValue1 v;\n+        public MyValue1 v = MyValue1.DEFAULT;\n@@ -637,0 +640,1 @@\n+    @Strict\n@@ -638,1 +642,2 @@\n-    static MyValue3 staticVal3;\n+    static MyValue3 staticVal3 = MyValue3.DEFAULT;\n+    @Strict\n@@ -640,1 +645,1 @@\n-    static MyValue3 staticVal3_copy;\n+    static MyValue3 staticVal3_copy = MyValue3.DEFAULT;\n@@ -665,1 +670,1 @@\n-        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -702,1 +707,1 @@\n-        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -725,1 +730,1 @@\n-        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -746,1 +751,1 @@\n-        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -766,1 +771,1 @@\n-        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        MyValue3[] va = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -785,1 +790,1 @@\n-    static final MyValue3[] test34Array = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 2);\n+    static final MyValue3[] test34Array = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 2, MyValue3.DEFAULT);\n@@ -787,2 +792,2 @@\n-    \/\/ Verify that the default value class is never allocated.\n-    \/\/ C2 code should load and use the default oop from the java mirror.\n+    \/\/ Verify that the all-zero value class is never allocated.\n+    \/\/ C2 code should load and use the all-zero oop from the java mirror.\n@@ -790,2 +795,3 @@\n-    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n-        failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    \/\/ The concept of a pre-allocated \"all-zero value\" was removed.\n+    \/\/ @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+    \/\/     failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n@@ -793,1 +799,1 @@\n-        \/\/ Explicitly create default value\n+        \/\/ Explicitly create all-zero value\n@@ -799,2 +805,2 @@\n-        \/\/ Load default value from uninitialized value class array\n-        MyValue3[] dva = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        \/\/ Load all-zero value from uninitialized value class array\n+        MyValue3[] dva = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -820,1 +826,1 @@\n-    static final MyValue3[] test35Array = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+    static final MyValue3[] test35Array = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -822,1 +828,1 @@\n-    \/\/ Same as above but manually initialize value class fields to default.\n+    \/\/ Same as above but manually initialize value class fields to all-zero.\n@@ -824,2 +830,3 @@\n-    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n-        failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n+    \/\/ The concept of a pre-allocated \"all-zero value\" was removed.\n+    \/\/ @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+    \/\/     failOn = {ALLOC, ALLOCA, LOAD, STORE, LOOP, TRAP})\n@@ -882,1 +889,0 @@\n-    @ImplicitlyConstructible\n@@ -889,1 +895,0 @@\n-    @ImplicitlyConstructible\n@@ -894,0 +899,1 @@\n+        @Strict\n@@ -910,1 +916,0 @@\n-    @ImplicitlyConstructible\n@@ -912,1 +917,1 @@\n-    value class Test38Value {\n+    static value class Test38Value {\n@@ -917,0 +922,1 @@\n+    @Strict\n@@ -918,1 +924,1 @@\n-    static Test38Value test38Field;\n+    static Test38Value test38Field = new Test38Value(0);\n@@ -940,1 +946,0 @@\n-    @ImplicitlyConstructible\n@@ -951,0 +956,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":53,"deletions":47,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -44,1 +43,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -46,1 +44,0 @@\n-@ImplicitlyConstructible\n@@ -55,0 +52,2 @@\n+\n+    public static final Point DEFAULT = new Point(0, 0);\n@@ -57,1 +56,0 @@\n-@ImplicitlyConstructible\n@@ -66,0 +64,2 @@\n+\n+    public static final Rect DEFAULT = new Rect(Point.DEFAULT, Point.DEFAULT);\n@@ -70,1 +70,1 @@\n-    public static Point[] points = (Point[])ValueClass.newNullRestrictedArray(Point.class, 1);\n+    public static Point[] points = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, 1, Point.DEFAULT);\n@@ -72,1 +72,1 @@\n-    public static Rect[] rects = (Rect[])ValueClass.newNullRestrictedArray(Rect.class, 1);\n+    public static Rect[] rects = (Rect[])ValueClass.newNullRestrictedNonAtomicArray(Rect.class, 1, Rect.DEFAULT);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearingC1.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -36,0 +35,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -99,1 +99,0 @@\n-    @ImplicitlyConstructible\n@@ -119,1 +118,1 @@\n-        SimpleValue2[] array = (SimpleValue2[])ValueClass.newNullRestrictedArray(SimpleValue2.class, 1);\n+        SimpleValue2[] array = (SimpleValue2[])ValueClass.newNullRestrictedNonAtomicArray(SimpleValue2.class, 1, new SimpleValue2(0));\n@@ -203,1 +202,0 @@\n-    @ImplicitlyConstructible\n@@ -206,1 +204,1 @@\n-        long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18,l19 ;\n+        long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18,l19;\n@@ -214,0 +212,5 @@\n+        Big() {\n+            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = l10 =\n+            l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = 0;\n+        }\n+\n@@ -238,1 +241,0 @@\n-    @ImplicitlyConstructible\n@@ -242,0 +244,1 @@\n+        @Strict\n@@ -245,3 +248,3 @@\n-        TestValue(int n) {\n-            i = n;\n-            big = new Big(n);\n+        TestValue(int i, Big big) {\n+            this.i = i;\n+            this.big = big;\n@@ -258,1 +261,1 @@\n-        TestValue[] array = (TestValue[])ValueClass.newNullRestrictedArray(TestValue.class, 7);\n+        TestValue[] array = (TestValue[])ValueClass.newNullRestrictedNonAtomicArray(TestValue.class, 7, new TestValue(0, new Big()));\n@@ -261,1 +264,1 @@\n-        TestValue tv = new TestValue(9);\n+        TestValue tv = new TestValue(9, new Big(9));\n@@ -289,1 +292,0 @@\n-    @ImplicitlyConstructible\n@@ -295,1 +297,1 @@\n-        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 10);\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedNonAtomicArray(EmptyType.class, 10, new EmptyType());\n@@ -312,1 +314,1 @@\n-        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 16);\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedNonAtomicArray(EmptyType.class, 16, new EmptyType());\n@@ -325,1 +327,1 @@\n-        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 10);\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedNonAtomicArray(EmptyType.class, 10, new EmptyType());\n@@ -356,1 +358,1 @@\n-        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedArray(EmptyType.class, 16);\n+        EmptyType[] array = (EmptyType[])ValueClass.newNullRestrictedNonAtomicArray(EmptyType.class, 16, new EmptyType());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1.java","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -44,0 +43,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -46,1 +46,0 @@\n-    @ImplicitlyConstructible\n@@ -63,0 +62,1 @@\n+    @Strict\n@@ -64,1 +64,1 @@\n-    Point p;\n+    Point p = new Point(0, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1ValueNumbering.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -42,0 +41,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -326,1 +326,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -356,0 +356,1 @@\n+    @Strict\n@@ -364,3 +365,0 @@\n-    @NullRestricted\n-    MyValue3 test15_vt2;\n-\n@@ -370,2 +368,2 @@\n-    public void test15() {\n-        test15_vt2 = test15_interp();\n+    public MyValue3 test15() {\n+        return test15_interp();\n@@ -376,2 +374,1 @@\n-        test15();\n-        test15_vt.verify(test15_vt2);\n+        test15_vt.verify(test15());\n@@ -381,0 +378,1 @@\n+    @Strict\n@@ -398,0 +396,1 @@\n+    @Strict\n@@ -406,3 +405,0 @@\n-    @NullRestricted\n-    MyValue3 test17_vt2;\n-\n@@ -412,2 +408,2 @@\n-    public void test17() {\n-        test17_vt2 = test17_comp();\n+    public MyValue3 test17() {\n+        return test17_comp();\n@@ -424,2 +420,1 @@\n-        test17();\n-        test17_vt.verify(test17_vt2);\n+        test17_vt.verify(test17());\n@@ -431,0 +426,1 @@\n+    @Strict\n@@ -439,1 +435,0 @@\n-    @NullRestricted\n@@ -454,0 +449,1 @@\n+    @Strict\n@@ -469,0 +465,1 @@\n+    @Strict\n@@ -477,1 +474,0 @@\n-    @NullRestricted\n@@ -497,0 +493,1 @@\n+    @Strict\n@@ -534,1 +531,0 @@\n-    @ImplicitlyConstructible\n@@ -536,1 +532,1 @@\n-    value class TestValue23 {\n+    static value class TestValue23 {\n@@ -609,1 +605,0 @@\n-    @ImplicitlyConstructible\n@@ -611,1 +606,1 @@\n-    value class Test27Value1 {\n+    static value class Test27Value1 {\n@@ -624,1 +619,0 @@\n-    @ImplicitlyConstructible\n@@ -626,1 +620,1 @@\n-    value class Test27Value2 {\n+    static value class Test27Value2 {\n@@ -639,1 +633,0 @@\n-    @ImplicitlyConstructible\n@@ -641,1 +634,1 @@\n-    value class Test27Value3 {\n+    static value class Test27Value3 {\n@@ -682,0 +675,1 @@\n+    @Strict\n@@ -705,1 +699,1 @@\n-        MyValue3[] array = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        MyValue3[] array = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, MyValue3.DEFAULT);\n@@ -710,1 +704,0 @@\n-    @NullRestricted\n@@ -837,1 +830,0 @@\n-    @NullRestricted\n@@ -857,1 +849,0 @@\n-    @ImplicitlyConstructible\n@@ -859,1 +850,1 @@\n-    value class Test37Value {\n+    static value class Test37Value {\n@@ -895,1 +886,0 @@\n-    @ImplicitlyConstructible\n@@ -930,1 +920,0 @@\n-    @ImplicitlyConstructible\n@@ -1016,1 +1005,0 @@\n-    @ImplicitlyConstructible\n@@ -1019,0 +1007,1 @@\n+        @Strict\n@@ -1034,1 +1023,0 @@\n-    @ImplicitlyConstructible\n@@ -1038,0 +1026,1 @@\n+        @Strict\n@@ -1056,1 +1045,3 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE, TRAP})\n+    @IR(failOn = {LOAD, STORE, TRAP})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC})\n@@ -1176,0 +1167,1 @@\n+    @Strict\n@@ -1178,0 +1170,1 @@\n+    @Strict\n@@ -1179,1 +1172,1 @@\n-    final MyValue3 test50_vt2 = test50_vt;\n+    final MyValue3 test50_vt2 = MyValue3.create();\n@@ -1196,1 +1189,1 @@\n-        test50_vt.verify(vt);\n+        vt.verify(b ? test50_vt : test50_vt2);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":32,"deletions":39,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -34,0 +33,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -99,1 +99,0 @@\n-    @ImplicitlyConstructible\n@@ -173,0 +172,1 @@\n+    @Strict\n@@ -175,0 +175,1 @@\n+    @Strict\n@@ -177,0 +178,1 @@\n+    @Strict\n@@ -225,1 +227,0 @@\n-    @ImplicitlyConstructible\n@@ -242,1 +243,0 @@\n-    @ImplicitlyConstructible\n@@ -259,1 +259,0 @@\n-    @ImplicitlyConstructible\n@@ -274,1 +273,0 @@\n-    @ImplicitlyConstructible\n@@ -301,1 +299,0 @@\n-    @ImplicitlyConstructible\n@@ -312,0 +309,1 @@\n+    @Strict\n@@ -315,1 +313,0 @@\n-    @ImplicitlyConstructible\n@@ -326,1 +323,0 @@\n-    @ImplicitlyConstructible\n@@ -336,0 +332,1 @@\n+    @Strict\n@@ -338,0 +335,1 @@\n+    @Strict\n@@ -341,1 +339,0 @@\n-    @ImplicitlyConstructible\n@@ -374,1 +371,0 @@\n-    @ImplicitlyConstructible\n@@ -461,0 +457,1 @@\n+    @Strict\n@@ -463,0 +460,1 @@\n+    @Strict\n@@ -468,1 +466,0 @@\n-    @ImplicitlyConstructible\n@@ -483,0 +480,1 @@\n+    @Strict\n@@ -2208,1 +2206,0 @@\n-    @ImplicitlyConstructible\n@@ -2235,1 +2232,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConventionC1.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -37,0 +36,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -48,1 +48,0 @@\n-@ImplicitlyConstructible\n@@ -66,0 +65,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeadAllocationRemoval.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -91,1 +91,0 @@\n-    @ImplicitlyConstructible\n@@ -96,0 +95,1 @@\n+        @Strict\n@@ -124,0 +124,2 @@\n+\n+        public static final MyValue1 DEFAULT = new MyValue1(0, new MyValue2(0), new MyValue2(0));\n@@ -126,1 +128,0 @@\n-    @ImplicitlyConstructible\n@@ -164,0 +165,1 @@\n+    @Strict\n@@ -165,1 +167,1 @@\n-    static MyValue1 vtField1;\n+    static MyValue1 vtField1 = MyValue1.DEFAULT;\n@@ -181,1 +183,1 @@\n-    static MyValue1[] vtArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+    static MyValue1[] vtArray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -217,0 +219,1 @@\n+    @Strict\n@@ -255,1 +258,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 3, MyValue1.DEFAULT);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBuffering.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -30,0 +29,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -80,1 +80,0 @@\n-    @ImplicitlyConstructible\n@@ -98,1 +97,0 @@\n-    @ImplicitlyConstructible\n@@ -109,1 +107,0 @@\n-    @ImplicitlyConstructible\n@@ -122,1 +119,0 @@\n-    @ImplicitlyConstructible\n@@ -140,1 +136,0 @@\n-    @ImplicitlyConstructible\n@@ -156,1 +151,0 @@\n-    @ImplicitlyConstructible\n@@ -166,1 +160,0 @@\n-    @ImplicitlyConstructible\n@@ -178,1 +171,0 @@\n-    @ImplicitlyConstructible\n@@ -191,1 +183,0 @@\n-    @ImplicitlyConstructible\n@@ -203,1 +194,0 @@\n-    @ImplicitlyConstructible\n@@ -210,1 +200,0 @@\n-    @ImplicitlyConstructible\n@@ -221,1 +210,0 @@\n-    @ImplicitlyConstructible\n@@ -233,1 +221,0 @@\n-    @ImplicitlyConstructible\n@@ -243,1 +230,0 @@\n-    @ImplicitlyConstructible\n@@ -253,1 +239,0 @@\n-    @ImplicitlyConstructible\n@@ -263,1 +248,0 @@\n-    @ImplicitlyConstructible\n@@ -273,1 +257,0 @@\n-    @ImplicitlyConstructible\n@@ -283,1 +266,0 @@\n-    @ImplicitlyConstructible\n@@ -294,1 +276,0 @@\n-    @ImplicitlyConstructible\n@@ -297,0 +278,1 @@\n+        @Strict\n@@ -305,0 +287,2 @@\n+\n+        public static final MyValue14 DEFAULT = new MyValue14(new MyValue8((byte)0), null);\n@@ -316,1 +300,0 @@\n-    @ImplicitlyConstructible\n@@ -327,1 +310,0 @@\n-    @ImplicitlyConstructible\n@@ -340,1 +322,0 @@\n-    @ImplicitlyConstructible\n@@ -366,0 +347,1 @@\n+    @Strict\n@@ -367,1 +349,1 @@\n-    volatile MyValue8 field12;\n+    volatile MyValue8 field12 = new MyValue8((byte)0);\n@@ -369,0 +351,1 @@\n+    @Strict\n@@ -370,1 +353,1 @@\n-    MyValue14 field13;          \/\/ Null-free, flat\n+    MyValue14 field13 = MyValue14.DEFAULT; \/\/ Null-free, flat\n@@ -373,0 +356,1 @@\n+    @Strict\n@@ -374,1 +358,1 @@\n-    volatile MyValue14 field16; \/\/ Null-free, atomic, flat\n+    volatile MyValue14 field16 = MyValue14.DEFAULT; \/\/ Null-free, atomic, flat\n@@ -376,0 +360,1 @@\n+    @Strict\n@@ -377,1 +362,1 @@\n-    volatile MyValue15 field17;\n+    volatile MyValue15 field17 = new MyValue15(null);\n@@ -379,0 +364,1 @@\n+    @Strict\n@@ -380,1 +366,2 @@\n-    volatile MyValue16 field19;\n+    volatile MyValue16 field19 = new MyValue16(null, null);\n+    @Strict\n@@ -382,1 +369,1 @@\n-    volatile MyValue17 field20;\n+    volatile MyValue17 field20 = new MyValue17(null, (byte)0, (byte)0);\n@@ -392,1 +379,0 @@\n-    @ImplicitlyConstructible\n@@ -402,0 +388,2 @@\n+\n+        public static final TwoBytes DEFAULT = new TwoBytes((byte)0, (byte)0);\n@@ -409,0 +397,1 @@\n+        @Strict\n@@ -410,1 +399,1 @@\n-        volatile TwoBytes field;\n+        volatile TwoBytes field = TwoBytes.DEFAULT;\n@@ -422,0 +411,1 @@\n+        @Strict\n@@ -425,0 +415,1 @@\n+        @Strict\n@@ -426,1 +417,1 @@\n-        volatile TwoBytes field;\n+        volatile TwoBytes field = TwoBytes.DEFAULT;\n@@ -428,0 +419,1 @@\n+        @Strict\n@@ -439,0 +431,1 @@\n+        @Strict\n@@ -444,0 +437,1 @@\n+        @Strict\n@@ -744,0 +738,1 @@\n+        @Strict\n@@ -745,1 +740,1 @@\n-        TwoBytes field1;\n+        TwoBytes field1 = TwoBytes.DEFAULT;\n@@ -749,0 +744,1 @@\n+        @Strict\n@@ -750,1 +746,1 @@\n-        volatile TwoBytes field3;\n+        volatile TwoBytes field3 = TwoBytes.DEFAULT;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":30,"deletions":34,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -38,1 +37,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -40,1 +38,0 @@\n-@ImplicitlyConstructible\n@@ -63,1 +60,1 @@\n-        Test0[] array = (Test0[])ValueClass.newNullRestrictedArray(Test0.class, 1);\n+        Test0[] array = (Test0[])ValueClass.newNullRestrictedNonAtomicArray(Test0.class, 1, new Test0());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatArrayAliasesCardMark.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -45,1 +44,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -47,1 +45,0 @@\n-@ImplicitlyConstructible\n@@ -53,3 +50,3 @@\n-    public MyValue1() {\n-        o1 = new Integer(42);\n-        o2 = new Integer(43);\n+    public MyValue1(Object o1, Object o2) {\n+        this.o1 = o1;\n+        this.o2 = o2;\n@@ -97,2 +94,2 @@\n-        MyValue1 vt = new MyValue1();\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1 vt = new MyValue1(new Integer(42), new Integer(43));\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, new MyValue1(null, null));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatArrayThreshold.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -241,1 +240,0 @@\n-    @ImplicitlyConstructible\n@@ -263,1 +261,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatInArraysFolding.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -43,0 +42,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -44,1 +44,0 @@\n-@ImplicitlyConstructible\n@@ -54,1 +53,0 @@\n-@ImplicitlyConstructible\n@@ -61,1 +59,0 @@\n-@ImplicitlyConstructible\n@@ -69,1 +66,0 @@\n-@ImplicitlyConstructible\n@@ -76,1 +72,0 @@\n-@ImplicitlyConstructible\n@@ -91,1 +86,0 @@\n-@ImplicitlyConstructible\n@@ -102,1 +96,0 @@\n-    @NullRestricted\n@@ -104,1 +97,0 @@\n-    @NullRestricted\n@@ -143,0 +135,1 @@\n+    @Strict\n@@ -154,1 +147,0 @@\n-    @NullRestricted\n@@ -158,1 +150,1 @@\n-        MyValue2[] array1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 6);\n+        MyValue2[] array1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 6, new MyValue2());\n@@ -189,1 +181,1 @@\n-        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, new MyValue1());\n@@ -215,1 +207,2 @@\n-    MyValue4[] d = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 1);\n+    MyValue4[] d = (MyValue4[])ValueClass.newNullRestrictedNonAtomicArray(MyValue4.class, 1, new MyValue4());\n+    @Strict\n@@ -217,1 +210,1 @@\n-    MyValue4 e;\n+    MyValue4 e = new MyValue4();\n@@ -223,1 +216,1 @@\n-            MyValue4[] k = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 0);\n+            MyValue4[] k = (MyValue4[])ValueClass.newNullRestrictedNonAtomicArray(MyValue4.class, 0, new MyValue4());\n@@ -240,1 +233,0 @@\n-    @NullRestricted\n@@ -242,0 +234,1 @@\n+    @Strict\n@@ -243,1 +236,1 @@\n-    MyValue5 test13_t;\n+    MyValue5 test13_t = new MyValue5();\n@@ -253,1 +246,1 @@\n-            MyValue5[] array2 = (MyValue5[])ValueClass.newNullRestrictedArray(MyValue5.class, 1);\n+            MyValue5[] array2 = (MyValue5[])ValueClass.newNullRestrictedNonAtomicArray(MyValue5.class, 1, new MyValue5());\n@@ -264,1 +257,1 @@\n-            MyValue4[] array = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 1);\n+            MyValue4[] array = (MyValue4[])ValueClass.newNullRestrictedNonAtomicArray(MyValue4.class, 1, new MyValue4());\n@@ -278,1 +271,1 @@\n-                MyValue4[] array = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 1);\n+                MyValue4[] array = (MyValue4[])ValueClass.newNullRestrictedNonAtomicArray(MyValue4.class, 1, new MyValue4());\n@@ -317,1 +310,0 @@\n-    @NullRestricted\n@@ -330,3 +322,3 @@\n-        EmptyPrimitive[] array1 = (EmptyPrimitive[])ValueClass.newNullRestrictedArray(EmptyPrimitive.class, 1);\n-        MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n-        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        EmptyPrimitive[] array1 = (EmptyPrimitive[])ValueClass.newNullRestrictedNonAtomicArray(EmptyPrimitive.class, 1, new EmptyPrimitive());\n+        MyValue1[] array2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, new MyValue1());\n+        MyValue1[] array3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, new MyValue1());\n@@ -334,1 +326,1 @@\n-        MyValue3[] array4 = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 1);\n+        MyValue3[] array4 = (MyValue3[])ValueClass.newNullRestrictedNonAtomicArray(MyValue3.class, 1, new MyValue3());\n@@ -336,1 +328,1 @@\n-        MyValue5[] array5 = (MyValue5[])ValueClass.newNullRestrictedArray(MyValue5.class, 1);\n+        MyValue5[] array5 = (MyValue5[])ValueClass.newNullRestrictedNonAtomicArray(MyValue5.class, 1, new MyValue5());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGenerated.java","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -35,0 +34,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -51,1 +51,0 @@\n-@ImplicitlyConstructible\n@@ -58,1 +57,0 @@\n-@ImplicitlyConstructible\n@@ -61,0 +59,1 @@\n+    @Strict\n@@ -63,0 +62,1 @@\n+    @Strict\n@@ -68,0 +68,1 @@\n+    @Strict\n@@ -213,1 +214,0 @@\n-    @ImplicitlyConstructible\n@@ -217,1 +217,0 @@\n-    @ImplicitlyConstructible\n@@ -221,0 +220,1 @@\n+        @Strict\n@@ -225,1 +225,0 @@\n-    @ImplicitlyConstructible\n@@ -228,0 +227,1 @@\n+        @Strict\n@@ -230,0 +230,1 @@\n+        @Strict\n@@ -248,1 +249,1 @@\n-        Container1[] ca = (Container1[])ValueClass.newNullRestrictedArray(Container1.class, 10);\n+        Container1[] ca = (Container1[])ValueClass.newNullRestrictedNonAtomicArray(Container1.class, 10, new Container1());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -35,0 +34,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -51,0 +51,1 @@\n+        @Strict\n@@ -61,1 +62,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestInlineFieldNonFlattened.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -38,0 +37,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -172,1 +172,1 @@\n-    \/\/ Test default value class array creation via reflection\n+    \/\/ Test value class array creation via reflection\n@@ -174,2 +174,2 @@\n-    public Object[] test7(Class<?> componentType, int len) {\n-        Object[] va = ValueClass.newNullRestrictedArray(componentType, len);\n+    public Object[] test7(Class<?> componentType, int len, Object initValue) {\n+        Object[] va = ValueClass.newNullRestrictedNonAtomicArray(componentType, len, initValue);\n@@ -183,1 +183,1 @@\n-        Object[] va = test7(MyValue1.class, len);\n+        Object[] va = test7(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -276,1 +276,1 @@\n-        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        Object[] va = ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -404,1 +404,0 @@\n-    @NullRestricted\n@@ -408,1 +407,1 @@\n-    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    @IR(failOn = {CALL_UNSAFE})\n@@ -436,0 +435,1 @@\n+    @Strict\n@@ -452,1 +452,0 @@\n-    @ImplicitlyConstructible\n@@ -454,1 +453,1 @@\n-    value class Test25Value {\n+    static value class Test25Value {\n@@ -457,2 +456,2 @@\n-        public Test25Value() {\n-            this.x = 42;\n+        public Test25Value(int x) {\n+            this.x = x;\n@@ -462,1 +461,1 @@\n-    final Test25Value[] test25Array = (Test25Value[])ValueClass.newNullRestrictedArray(Test25Value.class, 10);\n+    final Test25Value[] test25Array = (Test25Value[])ValueClass.newNullRestrictedNonAtomicArray(Test25Value.class, 10, new Test25Value(0));\n@@ -466,2 +465,2 @@\n-        Object[] newArray = Arrays.copyOf(test25Array, test25Array.length + 1);\n-        newArray[test25Array.length] = element;\n+        Object[] newArray = Arrays.copyOf(test25Array, test25Array.length);\n+        newArray[test25Array.length - 1] = element;\n@@ -473,1 +472,1 @@\n-        Test25Value vt = new Test25Value();\n+        Test25Value vt = new Test25Value(42);\n@@ -478,1 +477,1 @@\n-    @IR(failOn = IRNode.LOAD_I) \/\/ Load of the default value should be folded\n+    @IR(failOn = IRNode.LOAD_I) \/\/ Load of the all-zero value should be folded\n@@ -485,1 +484,1 @@\n-        return ValueClass.newNullRestrictedArray(ca[0], 1);\n+        return ValueClass.newNullRestrictedNonAtomicArray(ca[0], 1, MyValue1.DEFAULT);\n@@ -588,1 +587,0 @@\n-    @NullRestricted\n@@ -647,1 +645,1 @@\n-            TEST33_ARRAY = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+            TEST33_ARRAY = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -784,1 +782,1 @@\n-    \/\/ Test default value class array creation via reflection\n+    \/\/ Test value class array creation via reflection\n@@ -957,1 +955,1 @@\n-        MyValue1[] va  = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] va  = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -1000,1 +998,1 @@\n-            va1[0] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va1[0] = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1032,1 +1030,1 @@\n-            va1[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va1[i] = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1034,1 +1032,1 @@\n-            va3[i] = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            va3[i] = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1093,0 +1091,1 @@\n+    @Strict\n@@ -1115,1 +1114,1 @@\n-        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        Object[] va = ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1129,1 +1128,1 @@\n-        Object[] va = ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        Object[] va = ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1140,0 +1139,10 @@\n+    \/\/ Use a value class without strict fields for Unsafe allocation in below tests\n+    \/\/ because without the constructor, these fields won't be initialized with is illegal.\n+    static value class ValueWithNoStrictFields1 {\n+        int x = rI;\n+    }\n+\n+    static value class ValueWithNoStrictFields2 {\n+        long x = rL;\n+    }\n+\n@@ -1150,1 +1159,1 @@\n-        boolean res = test58(MyValue1.class, MyValue1.class);\n+        boolean res = test58(ValueWithNoStrictFields1.class, ValueWithNoStrictFields1.class);\n@@ -1152,1 +1161,1 @@\n-        res = test58(Object.class, MyValue1.class);\n+        res = test58(Object.class, ValueWithNoStrictFields1.class);\n@@ -1154,1 +1163,1 @@\n-        res = test58(MyValue1.class, Object.class);\n+        res = test58(ValueWithNoStrictFields1.class, Object.class);\n@@ -1171,1 +1180,1 @@\n-            test59(MyValue1.class);\n+            test59(ValueWithNoStrictFields1.class);\n@@ -1188,5 +1197,5 @@\n-        Asserts.assertTrue(test60(MyValue1.class, MyValue1.class, false, false));\n-        Asserts.assertFalse(test60(MyValue1.class, MyValue2.class, false, false));\n-        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, false, true));\n-        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, false));\n-        Asserts.assertFalse(test60(MyValue1.class, MyValue1.class, true, true));\n+        Asserts.assertTrue(test60(ValueWithNoStrictFields1.class, ValueWithNoStrictFields1.class, false, false));\n+        Asserts.assertFalse(test60(ValueWithNoStrictFields1.class, ValueWithNoStrictFields2.class, false, false));\n+        Asserts.assertFalse(test60(ValueWithNoStrictFields1.class, ValueWithNoStrictFields1.class, false, true));\n+        Asserts.assertFalse(test60(ValueWithNoStrictFields1.class, ValueWithNoStrictFields1.class, true, false));\n+        Asserts.assertFalse(test60(ValueWithNoStrictFields1.class, ValueWithNoStrictFields1.class, true, true));\n@@ -1239,1 +1248,1 @@\n-        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1352,1 +1361,1 @@\n-        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1470,0 +1479,1 @@\n+    @Strict\n@@ -1497,1 +1507,0 @@\n-    @ImplicitlyConstructible\n@@ -1503,1 +1512,0 @@\n-    @ImplicitlyConstructible\n@@ -1517,1 +1525,1 @@\n-        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedNonAtomicArray(EmptyInline.class, 100, new EmptyInline());\n@@ -1531,1 +1539,1 @@\n-        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedNonAtomicArray(EmptyInline.class, 100, new EmptyInline());\n@@ -1546,1 +1554,1 @@\n-        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedNonAtomicArray(ByteInline.class, 100, new ByteInline());\n@@ -1560,1 +1568,1 @@\n-        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedArray(ByteInline.class, 100);\n+        ByteInline[] byteArray = (ByteInline[])ValueClass.newNullRestrictedNonAtomicArray(ByteInline.class, 100, new ByteInline());\n@@ -1603,1 +1611,0 @@\n-    @ImplicitlyConstructible\n@@ -1606,0 +1613,1 @@\n+        @Strict\n@@ -1610,1 +1618,0 @@\n-    @ImplicitlyConstructible\n@@ -1672,1 +1679,1 @@\n-        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, MyValue1.DEFAULT);\n@@ -1680,1 +1687,1 @@\n-            MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+            MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, MyValue1.DEFAULT);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":56,"deletions":49,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,0 +40,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -89,0 +89,1 @@\n+    @Strict\n@@ -91,0 +92,1 @@\n+    @Strict\n@@ -143,0 +145,1 @@\n+    @Strict\n@@ -145,0 +148,1 @@\n+    @Strict\n@@ -148,0 +152,1 @@\n+    @Strict\n@@ -149,1 +154,1 @@\n-    MyValue1 valueField4;\n+    MyValue1 valueField4 = MyValue1.DEFAULT;\n@@ -153,0 +158,1 @@\n+    @Strict\n@@ -155,0 +161,1 @@\n+    @Strict\n@@ -156,1 +163,1 @@\n-    static MyValue1 staticValueField3;\n+    static MyValue1 staticValueField3 = MyValue1.DEFAULT;\n@@ -324,2 +331,2 @@\n-        test7(true);\n-        test7(false);\n+        Asserts.assertEQ(test7(true), valueField1);\n+        Asserts.assertEQ(test7(false), objectField1);\n@@ -341,2 +348,2 @@\n-        test8(true);\n-        test8(false);\n+        Asserts.assertEQ(test8(true), objectField1);\n+        Asserts.assertEQ(test8(false), valueField1);\n@@ -358,1 +365,1 @@\n-        test9();\n+        Asserts.assertEQ(test9(), MyValue1.setX(valueField1, valueField1.x + 7));\n@@ -658,1 +665,1 @@\n-    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 3, MyValue1.DEFAULT);\n@@ -669,1 +676,1 @@\n-    private static final MyValue2[] testValue2Array = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 3);\n+    private static final MyValue2[] testValue2Array = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 3, MyValue2.DEFAULT);\n@@ -1173,1 +1180,1 @@\n-        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -1211,1 +1218,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -1245,1 +1252,1 @@\n-        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -1297,1 +1304,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -1380,1 +1387,1 @@\n-        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1398,1 +1405,1 @@\n-        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1414,1 +1421,1 @@\n-        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -1554,1 +1561,0 @@\n-    @ImplicitlyConstructible\n@@ -1556,1 +1562,1 @@\n-    value class Test51Value {\n+    static value class Test51Value {\n@@ -1564,0 +1570,1 @@\n+        @Strict\n@@ -1566,0 +1573,1 @@\n+        @Strict\n@@ -1569,0 +1577,1 @@\n+        @Strict\n@@ -1637,0 +1646,1 @@\n+    @Strict\n@@ -1638,1 +1648,2 @@\n-    static Test51Value test51_arg1;\n+    static Test51Value test51_arg1 = new Test51Value();\n+    @Strict\n@@ -1640,1 +1651,1 @@\n-    static MyValue1 test51_arg2;\n+    static MyValue1 test51_arg2 = MyValue1.DEFAULT;\n@@ -1940,1 +1951,1 @@\n-        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -1952,1 +1963,1 @@\n-        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2064,1 +2075,0 @@\n-    @ImplicitlyConstructible\n@@ -2110,1 +2120,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2120,1 +2130,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2205,1 +2215,0 @@\n-    @ImplicitlyConstructible\n@@ -2209,0 +2218,1 @@\n+        @Strict\n@@ -2216,0 +2226,5 @@\n+\n+        private Small(int i, Big big) {\n+            this.i = i;\n+            this.big = big;\n+        }\n@@ -2218,1 +2233,0 @@\n-    @ImplicitlyConstructible\n@@ -2230,0 +2244,6 @@\n+\n+        private Big(long l) {\n+            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = l10 =\n+            l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = l20 =\n+            l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = 0;\n+        }\n@@ -2232,0 +2252,1 @@\n+    @Strict\n@@ -2234,0 +2255,1 @@\n+    @Strict\n@@ -2235,1 +2257,2 @@\n-    Small smallDefault;\n+    Small smallDefault = new Small(0, new Big(0));\n+    @Strict\n@@ -2238,0 +2261,1 @@\n+    @Strict\n@@ -2239,1 +2263,1 @@\n-    Big bigDefault;\n+    Big bigDefault = new Big(0);\n@@ -2286,1 +2310,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT);\n@@ -2307,1 +2331,1 @@\n-            dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1); \/\/ constant null free property\n+            dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT); \/\/ constant null free property\n@@ -2315,1 +2339,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT);\n@@ -2354,1 +2378,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -2356,1 +2380,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -2399,1 +2423,1 @@\n-        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -2423,1 +2447,1 @@\n-        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -2447,1 +2471,1 @@\n-        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -2449,1 +2473,1 @@\n-        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -2494,1 +2518,1 @@\n-        Asserts.assertFalse(test91((MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1)));\n+        Asserts.assertFalse(test91((MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT)));\n@@ -2499,1 +2523,0 @@\n-    @ImplicitlyConstructible\n@@ -2558,1 +2581,1 @@\n-            Object[] array = (Test92Value[])ValueClass.newNullRestrictedArray(Test92Value.class, 1);\n+            Object[] array = (Test92Value[])ValueClass.newNullRestrictedNonAtomicArray(Test92Value.class, 1, new Test92Value());\n@@ -2985,1 +3008,1 @@\n-        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -3016,1 +3039,1 @@\n-        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 100);\n+        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n@@ -3046,1 +3069,0 @@\n-    @ImplicitlyConstructible\n@@ -3049,0 +3071,1 @@\n+        @Strict\n@@ -3127,0 +3150,1 @@\n+        @Strict\n@@ -3338,1 +3362,1 @@\n-        public static WrapperInterface2 wrap_default(long val) {\n+        public static WrapperInterface2 wrap_dynamic(long val) {\n@@ -3343,1 +3367,0 @@\n-    @ImplicitlyConstructible\n@@ -3359,1 +3382,0 @@\n-    @ImplicitlyConstructible\n@@ -3375,1 +3397,1 @@\n-            this.content = def ? WrapperInterface2.wrap_default(val) : WrapperInterface2.wrap(val);\n+            this.content = def ? WrapperInterface2.wrap_dynamic(val) : WrapperInterface2.wrap(val);\n@@ -3384,1 +3406,1 @@\n-        static InterfaceBox2 box_default(long val) {\n+        static InterfaceBox2 box_dynamic(long val) {\n@@ -3408,1 +3430,1 @@\n-    \/\/ Same as test114 but with default instead of ZERO field\n+    \/\/ Same as test114 but with dynamic instead of constant ZERO field\n@@ -3415,1 +3437,1 @@\n-            res += InterfaceBox2.box_default(lArr[i]).content.value();\n+            res += InterfaceBox2.box_dynamic(lArr[i]).content.value();\n@@ -3427,0 +3449,1 @@\n+    @Strict\n@@ -3428,1 +3451,1 @@\n-    static MyValueEmpty fEmpty1;\n+    static MyValueEmpty fEmpty1 = new MyValueEmpty();\n@@ -3430,0 +3453,1 @@\n+    @Strict\n@@ -3431,1 +3455,1 @@\n-           MyValueEmpty fEmpty3;\n+           MyValueEmpty fEmpty3 = new MyValueEmpty();\n@@ -3436,1 +3460,0 @@\n-    @IR(failOn = {ALLOC_G, TRAP})\n@@ -3454,1 +3477,0 @@\n-    @IR(failOn = {ALLOC_G})\n@@ -3481,1 +3503,0 @@\n-    @ImplicitlyConstructible\n@@ -3484,0 +3505,1 @@\n+        @Strict\n@@ -3488,1 +3510,0 @@\n-    @ImplicitlyConstructible\n@@ -3492,0 +3513,1 @@\n+        @Strict\n@@ -3496,0 +3518,1 @@\n+    @Strict\n@@ -3499,0 +3522,1 @@\n+    @Strict\n@@ -3502,0 +3526,1 @@\n+    @Strict\n@@ -3507,1 +3532,0 @@\n-    @IR(failOn = {ALLOC_G})\n@@ -3510,1 +3534,1 @@\n-        EmptyContainer[] array2 = (EmptyContainer[])ValueClass.newNullRestrictedArray(EmptyContainer.class, 1);\n+        EmptyContainer[] array2 = (EmptyContainer[])ValueClass.newNullRestrictedNonAtomicArray(EmptyContainer.class, 1, emptyC);\n@@ -3512,1 +3536,1 @@\n-        MixedContainer[] array3 = (MixedContainer[])ValueClass.newNullRestrictedArray(MixedContainer.class, 1);\n+        MixedContainer[] array3 = (MixedContainer[])ValueClass.newNullRestrictedNonAtomicArray(MixedContainer.class, 1, mixedContainer);\n@@ -3528,1 +3552,1 @@\n-    \/\/ Test removal of empty inline type field stores\n+    \/\/ Test optimization of empty inline type field stores\n@@ -3530,1 +3554,1 @@\n-    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    @IR(failOn = {ALLOC_G, LOAD, STORE, NULL_CHECK_TRAP, TRAP})\n@@ -3541,1 +3565,0 @@\n-        Asserts.assertEquals(fEmpty2, empty);\n@@ -3546,1 +3569,1 @@\n-    @IR(failOn = {ALLOC_G, LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n+    @IR(failOn = {LOAD, STORE, FIELD_ACCESS, NULL_CHECK_TRAP, TRAP})\n@@ -3560,1 +3583,2 @@\n-    @IR(failOn = {ALLOC_G})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC_G})\n@@ -3941,1 +3965,0 @@\n-    @ImplicitlyConstructible\n@@ -3945,0 +3968,1 @@\n+        @Strict\n@@ -3949,1 +3973,0 @@\n-    @ImplicitlyConstructible\n@@ -3952,0 +3975,1 @@\n+        @Strict\n@@ -3957,1 +3981,3 @@\n-    @IR(failOn = {ALLOC_G, LOAD, STORE, TRAP})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC_G})\n+    @IR(failOn = {LOAD, STORE, TRAP})\n@@ -3970,1 +3996,0 @@\n-    @ImplicitlyConstructible\n@@ -3995,1 +4020,0 @@\n-    @ImplicitlyConstructible\n@@ -4040,1 +4064,1 @@\n-    \/\/ Test merging of buffered default and non-default inline types\n+    \/\/ Test merging of buffered inline types\n@@ -4042,1 +4066,0 @@\n-    @IR(failOn = {ALLOC_G})\n@@ -4176,1 +4199,0 @@\n-    @ImplicitlyConstructible\n@@ -4195,1 +4217,0 @@\n-    @ImplicitlyConstructible\n@@ -4212,1 +4233,0 @@\n-    @ImplicitlyConstructible\n@@ -4216,0 +4236,1 @@\n+        @Strict\n@@ -4317,0 +4338,1 @@\n+    @Strict\n@@ -4332,0 +4354,1 @@\n+    @Strict\n@@ -4499,1 +4522,0 @@\n-    @ImplicitlyConstructible\n@@ -4509,1 +4531,0 @@\n-    @ImplicitlyConstructible\n@@ -4519,1 +4540,0 @@\n-    @ImplicitlyConstructible\n@@ -4529,1 +4549,0 @@\n-    @ImplicitlyConstructible\n@@ -4540,1 +4559,0 @@\n-    @ImplicitlyConstructible\n@@ -4552,4 +4570,4 @@\n-    static final ValueClassWithInt[] VALUE_CLASS_WITH_INT_ARRAY = (ValueClassWithInt[]) ValueClass.newNullRestrictedArray(ValueClassWithInt.class, 2);\n-    static final ValueClassWithDouble[] VALUE_CLASS_WITH_DOUBLE_ARRAY = (ValueClassWithDouble[]) ValueClass.newNullRestrictedArray(ValueClassWithDouble.class, 2);\n-    static final SubValueClassWithInt[] SUB_VALUE_CLASS_WITH_INT_ARRAY = (SubValueClassWithInt[]) ValueClass.newNullRestrictedArray(SubValueClassWithInt.class, 2);\n-    static final SubValueClassWithDouble[] SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY = (SubValueClassWithDouble[]) ValueClass.newNullRestrictedArray(SubValueClassWithDouble.class, 2);\n+    static final ValueClassWithInt[] VALUE_CLASS_WITH_INT_ARRAY = (ValueClassWithInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueClassWithInt.class, 2, new ValueClassWithInt(0));\n+    static final ValueClassWithDouble[] VALUE_CLASS_WITH_DOUBLE_ARRAY = (ValueClassWithDouble[]) ValueClass.newNullRestrictedNonAtomicArray(ValueClassWithDouble.class, 2, new ValueClassWithDouble(0));\n+    static final SubValueClassWithInt[] SUB_VALUE_CLASS_WITH_INT_ARRAY = (SubValueClassWithInt[]) ValueClass.newNullRestrictedNonAtomicArray(SubValueClassWithInt.class, 2, new SubValueClassWithInt(0));\n+    static final SubValueClassWithDouble[] SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY = (SubValueClassWithDouble[]) ValueClass.newNullRestrictedNonAtomicArray(SubValueClassWithDouble.class, 2, new SubValueClassWithDouble(0));\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":103,"deletions":85,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -36,0 +35,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -111,0 +111,1 @@\n+    @Strict\n@@ -113,0 +114,1 @@\n+    @Strict\n@@ -115,1 +117,1 @@\n-    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -119,1 +121,1 @@\n-    private static final MyValue2[] testValue2Array = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 1);\n+    private static final MyValue2[] testValue2Array = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT);\n@@ -465,1 +467,0 @@\n-    @ImplicitlyConstructible\n@@ -476,0 +477,1 @@\n+    @Strict\n@@ -478,1 +480,1 @@\n-    private static final NotFlattenable[] testNotFlattenableArray = (NotFlattenable[])ValueClass.newNullRestrictedArray(NotFlattenable.class, 1);\n+    private static final NotFlattenable[] testNotFlattenableArray = (NotFlattenable[])ValueClass.newNullRestrictedNonAtomicArray(NotFlattenable.class, 1, new NotFlattenable());\n@@ -1114,1 +1116,0 @@\n-    @ImplicitlyConstructible\n@@ -1118,1 +1119,0 @@\n-    @ImplicitlyConstructible\n@@ -1169,1 +1169,1 @@\n-            Test40Inline[] array = (Test40Inline[])ValueClass.newNullRestrictedArray(Test40Inline.class, 1);\n+            Test40Inline[] array = (Test40Inline[])ValueClass.newNullRestrictedNonAtomicArray(Test40Inline.class, 1, new Test40Inline());\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -39,0 +38,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -159,0 +159,1 @@\n+    @Strict\n@@ -186,0 +187,1 @@\n+    @Strict\n@@ -214,0 +216,1 @@\n+    @Strict\n@@ -247,0 +250,1 @@\n+    @Strict\n@@ -274,0 +278,1 @@\n+    @Strict\n@@ -290,0 +295,1 @@\n+    @Strict\n@@ -298,0 +304,1 @@\n+    @Strict\n@@ -396,0 +403,1 @@\n+    @Strict\n@@ -404,0 +412,1 @@\n+    @Strict\n@@ -412,0 +421,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -32,0 +31,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -55,1 +55,0 @@\n-@ImplicitlyConstructible\n@@ -67,0 +66,1 @@\n+    @Strict\n@@ -86,1 +86,0 @@\n-@ImplicitlyConstructible\n@@ -89,0 +88,1 @@\n+    @Strict\n@@ -110,1 +110,0 @@\n-    @NullRestricted\n@@ -126,2 +125,1 @@\n-    @NullRestricted\n-    private static MyValue vt;\n+    private static MyValue vt = null;\n@@ -145,1 +143,0 @@\n-@ImplicitlyConstructible\n@@ -148,1 +145,0 @@\n-    @NullRestricted\n@@ -169,1 +165,0 @@\n-    @NullRestricted\n@@ -184,1 +179,0 @@\n-@ImplicitlyConstructible\n@@ -187,1 +181,0 @@\n-    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNestmateAccess.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -246,1 +243,1 @@\n-    \/\/ Test default initialization of value class arrays\n+    \/\/ Test initialization of value class arrays\n@@ -520,1 +517,1 @@\n-        MyValue1[]  va2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  va2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -583,2 +580,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -586,1 +583,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -588,1 +585,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -627,2 +624,2 @@\n-        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n-        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -630,1 +627,1 @@\n-        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -632,1 +629,1 @@\n-        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, len);\n+        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -673,1 +670,1 @@\n-        MyValue1[]  src2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  src2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -703,1 +700,1 @@\n-        MyValue1[] src2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] src2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -731,2 +728,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -734,1 +731,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -736,1 +733,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -774,2 +771,2 @@\n-        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n-        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -777,1 +774,1 @@\n-        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -779,1 +776,1 @@\n-        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 8);\n+        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -813,2 +810,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -816,1 +813,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -818,1 +815,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -852,2 +849,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -855,1 +852,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -857,1 +854,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -914,1 +911,1 @@\n-        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -941,1 +938,1 @@\n-        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 10);\n+        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n@@ -993,1 +990,1 @@\n-        MyValue1[] va2 = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, len);\n+        MyValue1[] va2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -1735,1 +1732,1 @@\n-    \/\/ Test default initialization of value class arrays: small array\n+    \/\/ Test initialization of value class arrays: small array\n@@ -1749,1 +1746,1 @@\n-    \/\/ Test default initialization of value class arrays: large array\n+    \/\/ Test initialization of value class arrays: large array\n@@ -1796,1 +1793,1 @@\n-    \/\/ A store with a default value can be eliminated\n+    \/\/ A store with a zero value can be eliminated\n@@ -1833,2 +1830,1 @@\n-    \/\/ A store with a default value can be eliminated: same as test68\n-    \/\/ but store is farther away from allocation\n+    \/\/ Same as test68 but store is further away from allocation\n@@ -2011,1 +2007,1 @@\n-            result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+            result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -2024,2 +2020,2 @@\n-        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n-        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -2053,1 +2049,1 @@\n-            va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+            va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, MyValue1.DEFAULT);\n@@ -2092,1 +2088,1 @@\n-            result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+            result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -2108,2 +2104,2 @@\n-        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n-        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -2140,1 +2136,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2163,1 +2159,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2191,1 +2187,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2218,1 +2214,1 @@\n-            result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+            result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2235,1 +2231,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2265,1 +2261,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 42);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n@@ -2275,1 +2271,1 @@\n-        MyValue1[] result = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2302,1 +2298,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2323,1 +2319,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2368,1 +2364,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2391,1 +2387,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2413,1 +2409,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2433,1 +2429,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2454,1 +2450,1 @@\n-        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2470,1 +2466,1 @@\n-        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2484,1 +2480,1 @@\n-        MyValue1[]  dst = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 8);\n+        MyValue1[]  dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -2614,1 +2610,1 @@\n-            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2708,1 +2704,1 @@\n-            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2735,1 +2731,1 @@\n-            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2822,1 +2818,1 @@\n-            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2844,1 +2840,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2877,1 +2873,1 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2892,1 +2888,1 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2907,1 +2903,1 @@\n-        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n@@ -2919,1 +2915,1 @@\n-    static final MyValue1[] flatArray = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 1);\n+    static final MyValue1[] flatArray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":67,"deletions":71,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,0 +40,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -97,0 +97,1 @@\n+    @Strict\n@@ -100,1 +101,1 @@\n-    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 3);\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 3, MyValue1.DEFAULT);\n@@ -108,0 +109,2 @@\n+\n+    @Strict\n@@ -514,2 +517,1 @@\n-    \/\/ Test scalarization of default value class with non-flattenable field\n-    @ImplicitlyConstructible\n+    \/\/ Test scalarization of value class with non-flattenable field\n@@ -627,1 +629,0 @@\n-    @ImplicitlyConstructible\n@@ -631,0 +632,1 @@\n+        @Strict\n@@ -696,1 +698,1 @@\n-        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 2);\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -896,1 +898,0 @@\n-    @ImplicitlyConstructible\n@@ -902,1 +903,0 @@\n-    @ImplicitlyConstructible\n@@ -912,0 +912,1 @@\n+    @Strict\n@@ -1048,0 +1049,1 @@\n+    @Strict\n@@ -1049,1 +1051,1 @@\n-    MyValue1 flatField;\n+    MyValue1 flatField = MyValue1.DEFAULT;\n@@ -1288,1 +1290,0 @@\n-    @ImplicitlyConstructible\n@@ -1304,0 +1305,1 @@\n+    @Strict\n@@ -1305,1 +1307,1 @@\n-    MyValue1Wrapper wrapperField;\n+    MyValue1Wrapper wrapperField = new MyValue1Wrapper(testValue1);\n@@ -1319,1 +1321,0 @@\n-        wrapperField = new MyValue1Wrapper(testValue1);\n@@ -2440,1 +2441,0 @@\n-    @ImplicitlyConstructible\n@@ -2446,1 +2446,0 @@\n-    @ImplicitlyConstructible\n@@ -2449,0 +2448,1 @@\n+        @Strict\n@@ -2453,1 +2453,0 @@\n-    @ImplicitlyConstructible\n@@ -2456,0 +2455,1 @@\n+        @Strict\n@@ -2477,1 +2477,0 @@\n-    @ImplicitlyConstructible\n@@ -2620,1 +2619,1 @@\n-        counts = {ALLOC_G, \" <= 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation (if not the default value)\n+        counts = {ALLOC_G, \" <= 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n@@ -2622,1 +2621,1 @@\n-        counts = {ALLOC_G, \" <= 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation (if not the default value)\n+        counts = {ALLOC_G, \" <= 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n@@ -2656,1 +2655,1 @@\n-        counts = {ALLOC_G, \" <= 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation (if not the default value)\n+        counts = {ALLOC_G, \" <= 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n@@ -2658,1 +2657,1 @@\n-        counts = {ALLOC_G, \" <= 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation (if not the default value)\n+        counts = {ALLOC_G, \" <= 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n@@ -2694,1 +2693,1 @@\n-        counts = {ALLOC_G, \" <= 1\"}) \/\/ No allocation required if the MyValue2 return is the default value\n+        counts = {ALLOC_G, \" <= 1\"}) \/\/ No allocation required if the MyValue2 return is the all-zero value\n@@ -2719,1 +2718,1 @@\n-        return b ? null: MyValue3.create();\n+        return b ? null : test97_res1;\n@@ -2729,1 +2728,1 @@\n-        return b ? null: MyValue3.create();\n+        return b ? null : test97_res3;\n@@ -2732,0 +2731,1 @@\n+    @Strict\n@@ -2733,1 +2733,3 @@\n-    MyValue3 test97_res1;\n+    final MyValue3 test97_res1 = MyValue3.create();\n+\n+    @Strict\n@@ -2735,1 +2737,1 @@\n-    MyValue3 test97_res3;\n+    final MyValue3 test97_res3 = MyValue3.create();\n@@ -2740,1 +2742,1 @@\n-        counts = {ALLOC_G, \" = 1\"}) \/\/ 1 Object allocation\n+        failOn = {ALLOC_G})\n@@ -2742,1 +2744,1 @@\n-        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValue3 allocation + 1 Object allocation\n+        counts = {ALLOC_G, \" <= 1\"}) \/\/ No allocation required if the MyValue3 return is the all-zero value\n@@ -2747,3 +2749,0 @@\n-            if (res != null) {\n-                test97_res1 = res;\n-            }\n@@ -2754,3 +2753,0 @@\n-            if (res != null) {\n-                test97_res3 = res;\n-            }\n@@ -2771,1 +2767,0 @@\n-    @ImplicitlyConstructible\n@@ -2798,1 +2793,0 @@\n-    @ImplicitlyConstructible\n@@ -2801,0 +2795,1 @@\n+        @Strict\n@@ -2824,1 +2819,0 @@\n-    @ImplicitlyConstructible\n@@ -2837,1 +2831,0 @@\n-    @ImplicitlyConstructible\n@@ -2840,0 +2833,1 @@\n+        @Strict\n@@ -2863,1 +2857,0 @@\n-    @ImplicitlyConstructible\n@@ -2866,0 +2859,1 @@\n+        @Strict\n@@ -2877,1 +2871,0 @@\n-    @ImplicitlyConstructible\n@@ -2937,1 +2930,0 @@\n-    @ImplicitlyConstructible\n@@ -2940,0 +2932,1 @@\n+        @Strict\n@@ -2941,1 +2934,1 @@\n-        static MyValue105 field1;\n+        static MyValue105 field1 = new MyValue105();\n@@ -2943,0 +2936,1 @@\n+        @Strict\n@@ -2946,0 +2940,1 @@\n+        @Strict\n@@ -2947,1 +2942,1 @@\n-        static MyValueEmpty field3;\n+        static MyValueEmpty field3 = new MyValueEmpty();\n@@ -2949,0 +2944,1 @@\n+        @Strict\n@@ -2969,1 +2965,0 @@\n-    @ImplicitlyConstructible\n@@ -2975,0 +2970,1 @@\n+    @Strict\n@@ -2976,1 +2972,1 @@\n-    static MyValue104 field1;\n+    static MyValue104 field1 = new MyValue104();\n@@ -2978,0 +2974,1 @@\n+    @Strict\n@@ -2979,1 +2976,1 @@\n-    MyValue104 field2;\n+    MyValue104 field2 = new MyValue104();\n@@ -2981,0 +2978,1 @@\n+    @Strict\n@@ -2982,1 +2980,1 @@\n-    static MyValueEmpty field3;\n+    static MyValueEmpty field3 = new MyValueEmpty();\n@@ -2984,0 +2982,1 @@\n+    @Strict\n@@ -2985,1 +2984,1 @@\n-    MyValueEmpty field4;\n+    MyValueEmpty field4 = new MyValueEmpty();\n@@ -3048,1 +3047,1 @@\n-    void test109(MyValue104 arg) {\n+    void test109() {\n@@ -3054,1 +3053,1 @@\n-    public void test109_verifier() {\n+    void test109_verifier() {\n@@ -3056,1 +3055,1 @@\n-            test109(new MyValue104());\n+            test109();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":49,"deletions":50,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -80,1 +80,1 @@\n-        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, Math.abs(rI) % 3);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, Math.abs(rI) % 3, MyValue1.DEFAULT);\n@@ -196,1 +196,0 @@\n-    @ImplicitlyConstructible\n@@ -225,1 +224,0 @@\n-    @ImplicitlyConstructible\n@@ -236,1 +234,0 @@\n-    @ImplicitlyConstructible\n@@ -261,0 +258,1 @@\n+        @Strict\n@@ -288,1 +286,0 @@\n-    @NullRestricted\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -37,0 +36,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -82,1 +82,0 @@\n-@ImplicitlyConstructible\n@@ -103,0 +102,2 @@\n+    static final MyValue DEFAULT = new MyValue((short)0, (short)0);\n+\n@@ -124,0 +125,1 @@\n+    @Strict\n@@ -125,1 +127,2 @@\n-    volatile static MyValue field1;\n+    volatile static MyValue field1 = MyValue.DEFAULT;\n+    @Strict\n@@ -127,1 +130,1 @@\n-    volatile MyValue field2;\n+    volatile MyValue field2 = MyValue.DEFAULT;\n@@ -133,1 +136,1 @@\n-    static final MyValue[] array1 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1);\n+    static final MyValue[] array1 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1, MyValue.DEFAULT);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTearing.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -55,0 +54,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -64,0 +64,1 @@\n+    @Strict\n@@ -67,0 +68,1 @@\n+    @Strict\n@@ -120,4 +122,0 @@\n-    public void setter3(MyValue3 val) {\n-        field = val;\n-    }\n-\n@@ -153,1 +151,0 @@\n-            t.setter3(staticField);\n@@ -183,2 +180,0 @@\n-        m = TestTrivialMethods.class.getMethod(\"setter3\", MyValue3.class);\n-        Asserts.assertEQ(WHITE_BOX.getMethodCompilationLevel(m, false), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION, \"setter3 is not C2 compiled\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTrivialMethods.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @summary Test that uninitialized default value class is properly handled by C2.\n+ * @summary Test that uninitialized value class is properly handled by C2.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUninitializedValueClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -60,1 +59,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -62,1 +60,0 @@\n-@ImplicitlyConstructible\n@@ -72,1 +69,0 @@\n-@ImplicitlyConstructible\n@@ -82,1 +78,0 @@\n-@ImplicitlyConstructible\n@@ -92,1 +87,0 @@\n-@ImplicitlyConstructible\n@@ -102,1 +96,0 @@\n-@ImplicitlyConstructible\n@@ -112,1 +105,0 @@\n-@ImplicitlyConstructible\n@@ -126,1 +118,0 @@\n-@ImplicitlyConstructible\n@@ -136,1 +127,0 @@\n-@ImplicitlyConstructible\n@@ -145,1 +135,0 @@\n-@ImplicitlyConstructible\n@@ -154,1 +143,0 @@\n-@ImplicitlyConstructible\n@@ -160,1 +148,0 @@\n-@ImplicitlyConstructible\n@@ -171,1 +158,1 @@\n-        return (MyValue1[])ValueClass.newNullRestrictedArray(MyValue1.class, 10);\n+        return (MyValue1[])ValueClass.newNullableAtomicArray(MyValue1.class, 10);\n@@ -203,1 +190,1 @@\n-        MyValue2[] arr = (MyValue2[])ValueClass.newNullRestrictedArray(MyValue2.class, 2);\n+        MyValue2[] arr = (MyValue2[])ValueClass.newNullableAtomicArray(MyValue2.class, 2);\n@@ -251,1 +238,1 @@\n-        MyValue3[] arr = (MyValue3[])ValueClass.newNullRestrictedArray(MyValue3.class, 2);\n+        MyValue3[] arr = (MyValue3[])ValueClass.newNullableAtomicArray(MyValue3.class, 2);\n@@ -283,1 +270,1 @@\n-            MyValue4[] arr = (MyValue4[])ValueClass.newNullRestrictedArray(MyValue4.class, 10);\n+            MyValue4[] arr = (MyValue4[])ValueClass.newNullableAtomicArray(MyValue4.class, 10);\n@@ -337,1 +324,1 @@\n-            MyValue5[] arr = (MyValue5[])ValueClass.newNullRestrictedArray(MyValue5.class, 10);\n+            MyValue5[] arr = (MyValue5[])ValueClass.newNullableAtomicArray(MyValue5.class, 10);\n@@ -396,2 +383,2 @@\n-        MyValue7[][] arr = { (MyValue7[])ValueClass.newNullRestrictedArray(MyValue7.class, 2),\n-                             (MyValue7[])ValueClass.newNullRestrictedArray(MyValue7.class, 2) };\n+        MyValue7[][] arr = { (MyValue7[])ValueClass.newNullableAtomicArray(MyValue7.class, 2),\n+                             (MyValue7[])ValueClass.newNullableAtomicArray(MyValue7.class, 2) };\n@@ -399,1 +386,1 @@\n-        Asserts.assertNE(oa[0], null);\n+        Asserts.assertEQ(oa[0], null);\n@@ -444,1 +431,1 @@\n-        MyValue8 b[] = (MyValue8[])ValueClass.newNullRestrictedArray(MyValue8.class, 0);\n+        MyValue8 b[] = (MyValue8[])ValueClass.newNullableAtomicArray(MyValue8.class, 0);\n@@ -452,1 +439,1 @@\n-        a[0] = (MyValue9[])ValueClass.newNullRestrictedArray(MyValue9.class, 0);\n+        a[0] = (MyValue9[])ValueClass.newNullableAtomicArray(MyValue9.class, 0);\n@@ -457,1 +444,1 @@\n-        MyValue10[][] a = { (MyValue10[])ValueClass.newNullRestrictedArray(MyValue10.class, 1) };\n+        MyValue10[][] a = { (MyValue10[])ValueClass.newNullRestrictedNonAtomicArray(MyValue10.class, 1, new MyValue10()) };\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeArray.java","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -83,1 +83,0 @@\n-    @ImplicitlyConstructible\n@@ -94,0 +93,1 @@\n+        @Strict\n@@ -135,1 +135,0 @@\n-    @ImplicitlyConstructible\n@@ -146,0 +145,1 @@\n+        @Strict\n@@ -176,1 +176,0 @@\n-    @ImplicitlyConstructible\n@@ -187,0 +186,1 @@\n+        @Strict\n@@ -217,1 +217,0 @@\n-    @ImplicitlyConstructible\n@@ -228,0 +227,1 @@\n+        @Strict\n@@ -270,1 +270,0 @@\n-    @ImplicitlyConstructible\n@@ -281,0 +280,1 @@\n+        @Strict\n@@ -316,1 +316,0 @@\n-    @ImplicitlyConstructible\n@@ -327,0 +326,1 @@\n+        @Strict\n@@ -351,1 +351,0 @@\n-    @ImplicitlyConstructible\n@@ -362,0 +361,1 @@\n+        @Strict\n@@ -395,1 +395,0 @@\n-    @ImplicitlyConstructible\n@@ -406,0 +405,1 @@\n+        @Strict\n@@ -435,1 +435,0 @@\n-    @ImplicitlyConstructible\n@@ -446,0 +445,1 @@\n+        @Strict\n@@ -478,1 +478,0 @@\n-    @ImplicitlyConstructible\n@@ -489,0 +488,1 @@\n+        @Strict\n@@ -522,1 +522,0 @@\n-    @ImplicitlyConstructible\n@@ -533,0 +532,1 @@\n+        @Strict\n@@ -565,1 +565,0 @@\n-    @ImplicitlyConstructible\n@@ -576,0 +575,1 @@\n+        @Strict\n@@ -662,1 +662,0 @@\n-    @ImplicitlyConstructible\n@@ -673,0 +672,1 @@\n+        @Strict\n@@ -699,1 +699,0 @@\n-    @ImplicitlyConstructible\n@@ -710,0 +709,1 @@\n+        @Strict\n@@ -711,1 +711,1 @@\n-        static MyValue19 v;\n+        static MyValue19 v = new MyValue19(0);\n@@ -740,1 +740,0 @@\n-    @ImplicitlyConstructible\n@@ -761,1 +760,0 @@\n-    @ImplicitlyConstructible\n@@ -764,1 +762,0 @@\n-        @NullRestricted\n@@ -766,0 +763,1 @@\n+        @Strict\n@@ -767,1 +765,1 @@\n-        static Test21ClassC c;\n+        static Test21ClassC c = new Test21ClassC();\n@@ -770,1 +768,0 @@\n-    @ImplicitlyConstructible\n@@ -776,1 +773,0 @@\n-    @ImplicitlyConstructible\n@@ -797,1 +793,0 @@\n-    @ImplicitlyConstructible\n@@ -801,0 +796,1 @@\n+        @Strict\n@@ -802,1 +798,1 @@\n-        static Test22ClassB b;\n+        static Test22ClassB b = new Test22ClassB();\n@@ -805,1 +801,0 @@\n-    @ImplicitlyConstructible\n@@ -841,1 +836,0 @@\n-    @ImplicitlyConstructible\n@@ -845,0 +839,1 @@\n+        @Strict\n@@ -846,1 +841,1 @@\n-        static Test23ClassB b;\n+        static Test23ClassB b = new Test23ClassB();\n@@ -849,1 +844,0 @@\n-    @ImplicitlyConstructible\n@@ -884,1 +878,0 @@\n-    @ImplicitlyConstructible\n@@ -887,0 +880,1 @@\n+        @Strict\n@@ -891,1 +885,0 @@\n-    @ImplicitlyConstructible\n@@ -927,1 +920,0 @@\n-    @ImplicitlyConstructible\n@@ -930,0 +922,1 @@\n+        @Strict\n@@ -934,1 +927,0 @@\n-    @ImplicitlyConstructible\n@@ -971,1 +963,0 @@\n-    @ImplicitlyConstructible\n@@ -974,0 +965,1 @@\n+        @Strict\n@@ -978,1 +970,0 @@\n-    @ImplicitlyConstructible\n@@ -1011,1 +1002,0 @@\n-    @ImplicitlyConstructible\n@@ -1018,1 +1008,0 @@\n-        @NullRestricted\n@@ -1027,1 +1016,1 @@\n-    public static int test27() {\n+    public static Object test27() {\n@@ -1029,1 +1018,1 @@\n-        return holder.v.foo;\n+        return holder.v;\n@@ -1034,1 +1023,1 @@\n-        Asserts.assertEQ(test27(), 42);\n+        Asserts.assertEQ(test27(), null);\n@@ -1037,1 +1026,0 @@\n-    @ImplicitlyConstructible\n@@ -1040,0 +1028,1 @@\n+        @Strict\n@@ -1041,1 +1030,1 @@\n-        static MyValue28 field1;\n+        static MyValue28 field1 = new MyValue28();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":31,"deletions":42,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -37,0 +36,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -530,1 +530,1 @@\n-        counts = {ALLOC_G, \" <= 7\"}) \/\/ 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation (if not the default value)\n+        counts = {ALLOC_G, \" <= 7\"}) \/\/ 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation (if not the all-zero value)\n@@ -532,1 +532,1 @@\n-        counts = {ALLOC_G, \" <= 8\"}) \/\/ 1 MyValueClass1 allocation + 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation (if not the default value)\n+        counts = {ALLOC_G, \" <= 8\"}) \/\/ 1 MyValueClass1 allocation + 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation (if not the all-zero value)\n@@ -567,1 +567,1 @@\n-        counts = {ALLOC_G, \" <= 1\"}) \/\/ 1 MyValueClass2Inline allocation (if not the default value)\n+        counts = {ALLOC_G, \" <= 1\"}) \/\/ 1 MyValueClass2Inline allocation (if not the all-zero value)\n@@ -569,1 +569,1 @@\n-        counts = {ALLOC_G, \" <= 2\"}) \/\/ 1 MyValueClass2 + 1 MyValueClass2Inline allocation  (if not the default value)\n+        counts = {ALLOC_G, \" <= 2\"}) \/\/ 1 MyValueClass2 + 1 MyValueClass2Inline allocation  (if not the all-zero value)\n@@ -592,1 +592,0 @@\n-    @ImplicitlyConstructible\n@@ -603,0 +602,1 @@\n+        @Strict\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -47,1 +46,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -52,1 +50,1 @@\n-        ValueWithLong[] arrWithLong = (ValueWithLong[])ValueClass.newNullRestrictedArray(ValueWithLong.class, 3);\n+        ValueWithLong[] arrWithLong = (ValueWithLong[])ValueClass.newNullRestrictedNonAtomicArray(ValueWithLong.class, 3, new ValueWithLong(0));\n@@ -65,4 +63,1 @@\n-        ValueWithOop[] arrWithOop = (ValueWithOop[])ValueClass.newNullRestrictedArray(ValueWithOop.class, 2);\n-        arrWithOop[0] = new ValueWithOop();\n-        arrWithOop[1] = new ValueWithOop();\n-\n+        ValueWithOop[] arrWithOop = (ValueWithOop[])ValueClass.newNullRestrictedNonAtomicArray(ValueWithOop.class, 2, new ValueWithOop());\n@@ -87,1 +82,0 @@\n-@ImplicitlyConstructible\n@@ -97,1 +91,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWrongFlatArrayCopyStubWithZGC.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -31,0 +30,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -56,1 +56,0 @@\n-    @ImplicitlyConstructible\n@@ -59,0 +58,1 @@\n+        @Strict\n@@ -71,1 +71,0 @@\n-    @ImplicitlyConstructible\n@@ -74,0 +73,1 @@\n+        @Strict\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/bootstrap\/TestBootClassloader.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -32,1 +31,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/bootstrap\/ValueOnBootclasspath.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -28,0 +27,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -31,1 +31,0 @@\n-    @ImplicitlyConstructible\n@@ -58,1 +57,0 @@\n-    @ImplicitlyConstructible\n@@ -67,0 +65,1 @@\n+    @Strict\n@@ -68,1 +67,1 @@\n-    Point point;\n+    Point point = new Point(0, 0);\n@@ -70,0 +69,1 @@\n+    @Strict\n@@ -71,1 +71,1 @@\n-    static Rectangle rectangle;\n+    static Rectangle rectangle = new Rectangle();\n@@ -113,1 +113,2 @@\n-        if (HelloInlineClassApp.rectangle.p0 != pzero || HelloInlineClassApp.rectangle.p1 != pzero) {\n+        Point pone = new Point(1, 1);\n+        if (HelloInlineClassApp.rectangle.p0 != pzero || HelloInlineClassApp.rectangle.p1 != pone) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/HelloInlineClassApp.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -28,1 +27,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/Point.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -28,0 +29,1 @@\n+  @Strict\n@@ -29,1 +31,1 @@\n-  Point p;\n+  Point p = new Point();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/WithInlinedField.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -34,0 +33,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -41,1 +41,1 @@\n- * @summary Test of ImplicitlyConstructible, NullRestricted and LooselyConsistentValue annotations\n+ * @summary Test of NullRestricted, Strict and LooselyConsistentValue annotations\n@@ -76,0 +76,1 @@\n+        @Strict\n@@ -77,1 +78,1 @@\n-        String s;\n+        String s = new String(\"bad\");\n@@ -92,1 +93,1 @@\n-    \/\/ Test detection of mismatch between a @NullRestricted field and its class that is not @ImplicitlyConstructible\n+    \/\/ Test detection of non-static field annotated with @NullRestricted but not @Strict\n@@ -107,1 +108,1 @@\n-        } catch (IncompatibleClassChangeError e) {\n+        } catch (ClassFormatError e) {\n@@ -111,1 +112,1 @@\n-        Asserts.assertNotNull(exception, \"Failed to detect illegal use of @NullRestricted\");\n+        Asserts.assertNotNull(exception, \"Failed to detect illegal use of @NullRestricted without @Strict on a non-static field\");\n@@ -114,2 +115,1 @@\n-    \/\/ Test a valid @NullRestricted field with a class that is @ImplicitlyConstructible\n-    @ImplicitlyConstructible\n+    \/\/ Invalid usage of @NullRestricted on a non-strict non-static field\n@@ -121,1 +121,1 @@\n-    static class GoodClass2 {\n+    static class BadClass2 {\n@@ -123,1 +123,1 @@\n-        ValueClass2 vc;\n+        static ValueClass2 val;\n@@ -129,18 +129,1 @@\n-            GoodClass2 tc = new GoodClass2();\n-        } catch (IncompatibleClassChangeError e) {\n-            exception = e;\n-            System.out.println(\"Received \" + e);\n-        }\n-        Asserts.assertNull(exception, \"Unexpected exception: \" + exception);\n-    }\n-\n-    \/\/ Invalid usage of @ImplicitlyConstructible on an identity class\n-    @ImplicitlyConstructible\n-    static class BadClass3 {\n-\n-    }\n-\n-    void test_3() {\n-        Throwable exception = null;\n-        try {\n-            BadClass3 tc = new BadClass3();\n+            BadClass2 tc = new BadClass2();\n@@ -151,1 +134,1 @@\n-        Asserts.assertNotNull(exception, \"Failed to detect illegal use of @ImplicitlyConstructible\");\n+        Asserts.assertNotNull(exception, \"FFailed to detect illegal use of @NullRestricted without @Strict on a static field\");\n@@ -173,1 +156,0 @@\n-    @ImplicitlyConstructible\n@@ -176,1 +158,1 @@\n-      int i = 0;\n+        int i = 0;\n@@ -182,2 +164,3 @@\n-      @NullRestricted\n-      ValueClass5 f1 = new ValueClass5();\n+        @Strict\n+        @NullRestricted\n+        ValueClass5 f1 = new ValueClass5();\n@@ -210,1 +193,0 @@\n-    @ImplicitlyConstructible\n@@ -212,0 +194,1 @@\n+        @Strict\n@@ -216,1 +199,0 @@\n-    @ImplicitlyConstructible\n@@ -218,0 +200,1 @@\n+        @Strict\n@@ -223,0 +206,1 @@\n+        @Strict\n@@ -239,1 +223,0 @@\n-    @ImplicitlyConstructible\n@@ -245,0 +228,1 @@\n+        @Strict\n@@ -246,1 +230,1 @@\n-        static ValueClass7 sval;\n+        static ValueClass7 sval = new ValueClass7();\n@@ -262,1 +246,0 @@\n-    @ImplicitlyConstructible\n@@ -264,0 +247,1 @@\n+        @Strict\n@@ -265,1 +249,1 @@\n-        static ValueClass8 sval;\n+        static ValueClass8 sval = new ValueClass8();\n@@ -281,1 +265,0 @@\n-    @ImplicitlyConstructible\n@@ -287,0 +270,1 @@\n+        @Strict\n@@ -304,1 +288,0 @@\n-    @ImplicitlyConstructible\n@@ -306,0 +289,1 @@\n+        @Strict\n@@ -307,1 +291,1 @@\n-        static ValueClass10 sval;\n+        static ValueClass10 sval = new ValueClass10();\n@@ -321,1 +305,1 @@\n-    \/\/ Test uninitialized static null restricted field with a class not implicitly constructible\n+    \/\/ Test static null restricted field that is not declared strict\n@@ -329,1 +313,1 @@\n-        static ValueClass11 val;\n+        static ValueClass11 val = new ValueClass11();\n@@ -337,1 +321,1 @@\n-        } catch(IncompatibleClassChangeError e) {\n+        } catch(ClassFormatError e) {\n@@ -341,1 +325,1 @@\n-        Asserts.assertNotNull(exception, \"Expected IncompatibleClassChangerError not received\");\n+        Asserts.assertNotNull(exception, \"Expected ClassFormatError not received\");\n@@ -346,0 +330,1 @@\n+        @Strict\n@@ -347,1 +332,1 @@\n-        int i;\n+        int i = 0;\n@@ -363,0 +348,1 @@\n+        @Strict\n@@ -364,1 +350,1 @@\n-        int Integer[];\n+        int[] intArray = new int[1];\n@@ -378,71 +364,0 @@\n-\n-    \/\/ Test that a value class annotated with @ImplicitlyConstructible but extending\n-    \/\/ an abstract value class not annotated with @ImplicitlyConstructible is not\n-    \/\/ considered as implicitely constructible\n-\n-    static abstract value class AbstractValue14 { }\n-    @ImplicitlyConstructible\n-    static value class Value14 extends AbstractValue14 { }\n-\n-    static class Test14 {\n-        @NullRestricted\n-        Value14 val;\n-    }\n-\n-    void test_14() {\n-        Throwable exception = null;\n-        try {\n-            Test14 t14 = new Test14();\n-        } catch(IncompatibleClassChangeError e) {\n-            exception = e;\n-            System.out.println(\"Received \"+ e);\n-        }\n-        Asserts.assertNotNull(exception, \"Expected IncompatibleClassChangeError not received\");\n-    }\n-\n-    \/\/ Test that a value class annotated with @ImplicitlyConstructible but extending\n-    \/\/ an abstract value class also annotated with @ImplicitlyConstructible is\n-    \/\/ considered as implicitely constructible\n-\n-    @ImplicitlyConstructible\n-    static abstract value class AbstractValue15 { }\n-    @ImplicitlyConstructible\n-    static value class Value15 extends AbstractValue15 { }\n-\n-    static class Test15 {\n-        @NullRestricted\n-        Value15 val;\n-    }\n-\n-    void test_15() {\n-        Throwable exception = null;\n-        try {\n-            Test15 t15 = new Test15();\n-        } catch(IncompatibleClassChangeError e) {\n-            exception = e;\n-            System.out.println(\"Received \"+ e);\n-        }\n-        Asserts.assertNull(exception, \"Unexpected IncompatibleClassChangeError received\");\n-    }\n-\n-    \/\/ Test that value record can be considered @ImplicitlyConstructible\n-    \/\/ (note java.lang.Record is a special super-class because it is not annotated with @ImplicitlyConstructible)\n-\n-    @ImplicitlyConstructible\n-    static value record Value16(byte b) { }\n-\n-    static class Test16 {\n-        @NullRestricted\n-        Value16 v = new Value16((byte)1);\n-    }\n-\n-    void test_16() {\n-        Throwable exception = null;\n-        try {\n-            Test16 t16 = new Test16();\n-        } catch(Throwable e) {\n-            exception = e;\n-            System.out.println(\"Received \"+ e);\n-        }\n-        Asserts.assertNull(exception, \"Unexpected exception \" + exception);\n-    }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/AnnotationsTests.java","additions":34,"deletions":119,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n- import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -46,1 +45,0 @@\n-    @ImplicitlyConstructible\n@@ -52,1 +50,0 @@\n-    @ImplicitlyConstructible\n@@ -59,1 +56,0 @@\n-    @ImplicitlyConstructible\n@@ -64,1 +60,0 @@\n-    @ImplicitlyConstructible\n@@ -78,1 +73,1 @@\n-        Object[] array1 = ValueClass.newNullRestrictedAtomicArray(SmallValue.class, 10);\n+        Object[] array1 = ValueClass.newNullRestrictedAtomicArray(SmallValue.class, 10, new SmallValue());\n@@ -88,1 +83,1 @@\n-        Object[] array3 = ValueClass.newNullRestrictedArray(WeakValue.class, 10);\n+        Object[] array3 = ValueClass.newNullRestrictedNonAtomicArray(WeakValue.class, 10, new WeakValue());\n@@ -93,1 +88,1 @@\n-        Object[] array4 = ValueClass.newNullRestrictedAtomicArray(WeakValue.class, 10);\n+        Object[] array4 = ValueClass.newNullRestrictedAtomicArray(WeakValue.class, 10, new WeakValue());\n@@ -98,1 +93,1 @@\n-        Object[] array5 = ValueClass.newNullRestrictedAtomicArray(NaturallyAtomic.class, 10);\n+        Object[] array5 = ValueClass.newNullRestrictedAtomicArray(NaturallyAtomic.class, 10, new NaturallyAtomic());\n@@ -103,1 +98,1 @@\n-        Object[] array6 = ValueClass.newNullRestrictedArray(BigValue.class, 10);\n+        Object[] array6 = ValueClass.newNullRestrictedNonAtomicArray(BigValue.class, 10, new BigValue());\n@@ -108,1 +103,1 @@\n-        Object[] array7 = ValueClass.newNullRestrictedAtomicArray(BigValue.class, 10);\n+        Object[] array7 = ValueClass.newNullRestrictedAtomicArray(BigValue.class, 10, new BigValue());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ArrayQueryTest.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -26,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -36,1 +37,0 @@\n- * @compile CircularityTest.java\n@@ -44,1 +44,0 @@\n-    @ImplicitlyConstructible\n@@ -47,0 +46,1 @@\n+        @Strict\n@@ -49,0 +49,1 @@\n+        @Strict\n@@ -54,1 +55,0 @@\n-    @ImplicitlyConstructible\n@@ -63,1 +63,0 @@\n-    @ImplicitlyConstructible\n@@ -72,1 +71,0 @@\n-    @ImplicitlyConstructible\n@@ -75,0 +73,1 @@\n+        @Strict\n@@ -86,1 +85,0 @@\n-    @ImplicitlyConstructible\n@@ -89,0 +87,1 @@\n+        @Strict\n@@ -91,0 +90,1 @@\n+        @Strict\n@@ -96,1 +96,0 @@\n-    @ImplicitlyConstructible\n@@ -105,1 +104,0 @@\n-    @ImplicitlyConstructible\n@@ -108,0 +106,1 @@\n+        @Strict\n@@ -113,1 +112,0 @@\n-    @ImplicitlyConstructible\n@@ -125,1 +123,0 @@\n-    @ImplicitlyConstructible\n@@ -128,0 +125,1 @@\n+        @Strict\n@@ -130,0 +128,1 @@\n+        @Strict\n@@ -135,1 +134,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CircularityTest.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -30,0 +29,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -45,1 +45,0 @@\n-    @ImplicitlyConstructible\n@@ -56,1 +55,0 @@\n-    @ImplicitlyConstructible\n@@ -59,0 +57,1 @@\n+        @Strict\n@@ -95,1 +94,0 @@\n-    @ImplicitlyConstructible\n@@ -106,1 +104,0 @@\n-    @ImplicitlyConstructible\n@@ -122,1 +119,1 @@\n-            BadTwo[] array = (BadTwo[]) ValueClass.newNullRestrictedArray(BadTwo.class, 10);\n+            BadTwo[] array = (BadTwo[]) ValueClass.newNullRestrictedNonAtomicArray(BadTwo.class, 10, new BadTwo());\n@@ -130,1 +127,1 @@\n-            BadTwo[] array = (BadTwo[]) ValueClass.newNullRestrictedArray(BadTwo.class, 10);\n+            BadTwo[] array = (BadTwo[]) ValueClass.newNullRestrictedNonAtomicArray(BadTwo.class, 10, new BadTwo());\n@@ -160,1 +157,0 @@\n-    @ImplicitlyConstructible\n@@ -166,1 +162,1 @@\n-            array = (BadFour[]) ValueClass.newNullRestrictedArray(BadFour.class, 10);\n+            array = (BadFour[]) ValueClass.newNullRestrictedNonAtomicArray(BadFour.class, 10, new BadFour());\n@@ -197,1 +193,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ClassInitializationFailuresTest.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -32,0 +31,2 @@\n+import jdk.internal.vm.annotation.Strict;\n+\n@@ -45,1 +46,0 @@\n-    @ImplicitlyConstructible\n@@ -52,1 +52,0 @@\n-    @ImplicitlyConstructible\n@@ -55,0 +54,1 @@\n+        @Strict\n@@ -57,0 +57,1 @@\n+        @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ClassPrintLayoutDcmd.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -48,1 +48,0 @@\n-    @ImplicitlyConstructible\n@@ -56,1 +55,0 @@\n-    @ImplicitlyConstructible\n@@ -59,0 +57,1 @@\n+        @Strict\n@@ -76,0 +75,1 @@\n+        @Strict\n@@ -77,1 +77,1 @@\n-        EmptyInline empty;\n+        EmptyInline empty = new EmptyInline();\n@@ -100,1 +100,1 @@\n-        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n+        EmptyInline[] emptyArray = (EmptyInline[])ValueClass.newNullRestrictedNonAtomicArray(EmptyInline.class, 100, new EmptyInline());\n@@ -107,1 +107,1 @@\n-        EmptyInline[] array2 = (EmptyInline[])ValueClass.newNullRestrictedArray(EmptyInline.class, 100);\n+        EmptyInline[] array2 = (EmptyInline[])ValueClass.newNullRestrictedNonAtomicArray(EmptyInline.class, 100, new EmptyInline());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/EmptyInlineTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -31,0 +30,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -63,1 +63,0 @@\n-  @ImplicitlyConstructible\n@@ -79,1 +78,0 @@\n-  @ImplicitlyConstructible\n@@ -103,1 +101,0 @@\n-  @ImplicitlyConstructible\n@@ -231,2 +228,2 @@\n-    SmallValue[] nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n-    SmallValue[] atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    SmallValue[] nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    SmallValue[] atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n@@ -285,2 +282,2 @@\n-    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n-    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n@@ -293,1 +290,1 @@\n-    SmallValue[] nonAtomicArray2 = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n+    SmallValue[] nonAtomicArray2 = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n@@ -307,2 +304,2 @@\n-    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n-    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n@@ -322,1 +319,1 @@\n-    SmallValue[] atomicArray2 = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    SmallValue[] atomicArray2 = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n@@ -333,2 +330,2 @@\n-    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n-    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n@@ -437,1 +434,1 @@\n-      array = ValueClass.newNullRestrictedArray(c, ARRAY_SIZE);\n+      array = ValueClass.newNullRestrictedNonAtomicArray(c, ARRAY_SIZE, c.newInstance());\n@@ -444,1 +441,1 @@\n-      array = ValueClass.newNullRestrictedAtomicArray(c, ARRAY_SIZE);\n+      array = ValueClass.newNullRestrictedAtomicArray(c, ARRAY_SIZE, c.newInstance());\n@@ -459,1 +456,0 @@\n-  @ImplicitlyConstructible\n@@ -516,1 +512,1 @@\n-      Object[] array1 = ValueClass.newNullRestrictedArray(SmallValue.class, 10);\n+      Object[] array1 = ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, 10, new SmallValue());\n@@ -518,1 +514,1 @@\n-      Object[] array2 = ValueClass.newNullRestrictedAtomicArray(SmallValue.class, 10);\n+      Object[] array2 = ValueClass.newNullRestrictedAtomicArray(SmallValue.class, 10, new SmallValue());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -30,0 +29,2 @@\n+import jdk.internal.vm.annotation.Strict;\n+\n@@ -43,1 +44,0 @@\n-    @ImplicitlyConstructible\n@@ -50,1 +50,0 @@\n-    @ImplicitlyConstructible\n@@ -52,1 +51,1 @@\n-    public value class JumboInline {\n+    public static value class JumboInline {\n@@ -76,0 +75,1 @@\n+    @Strict\n@@ -77,1 +77,1 @@\n-    static Point fsp;\n+    static Point fsp = new Point();\n@@ -80,0 +80,1 @@\n+    @Strict\n@@ -84,0 +85,1 @@\n+    @Strict\n@@ -85,1 +87,1 @@\n-    static JumboInline fsj;\n+    static JumboInline fsj = new JumboInline();\n@@ -88,0 +90,1 @@\n+    @Strict\n@@ -95,1 +98,4 @@\n-    FlattenableSemanticTest() { }\n+    FlattenableSemanticTest() {\n+        fip = new Point();\n+        fij = new JumboInline();\n+    }\n@@ -101,4 +107,4 @@\n-        Asserts.assertNull(nfsp, \"Invalid non null value for unitialized non flattenable field\");\n-        Asserts.assertNull(nfsj, \"Invalid non null value for unitialized non flattenable field\");\n-        Asserts.assertNull(test.nfip, \"Invalid non null value for unitialized non flattenable field\");\n-        Asserts.assertNull(test.nfij, \"Invalid non null value for unitialized non flattenable field\");\n+        Asserts.assertNull(nfsp, \"Invalid non null value for uninitialized non flattenable field\");\n+        Asserts.assertNull(nfsj, \"Invalid non null value for uninitialized non flattenable field\");\n+        Asserts.assertNull(test.nfip, \"Invalid non null value for uninitialized non flattenable field\");\n+        Asserts.assertNull(test.nfij, \"Invalid non null value for uninitialized non flattenable field\");\n@@ -109,4 +115,4 @@\n-        Asserts.assertNotNull(fsp, \"Invalid null value for unitialized flattenable field\");\n-        Asserts.assertNotNull(fsj, \"Invalid null value for unitialized flattenable field\");\n-        Asserts.assertNotNull(test.fip, \"Invalid null value for unitialized flattenable field\");\n-        Asserts.assertNotNull(test.fij, \"Invalid null value for unitialized flattenable field\");\n+        Asserts.assertNotNull(fsp, \"Invalid null value for uninitialized flattenable field\");\n+        Asserts.assertNotNull(fsj, \"Invalid null value for uninitialized flattenable field\");\n+        Asserts.assertNotNull(test.fip, \"Invalid null value for uninitialized flattenable field\");\n+        Asserts.assertNotNull(test.fij, \"Invalid null value for uninitialized flattenable field\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlattenableSemanticTest.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -42,1 +41,0 @@\n-    @ImplicitlyConstructible\n@@ -48,1 +46,1 @@\n-    @ImplicitlyConstructible\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Ifacmp.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -36,0 +35,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -170,0 +170,1 @@\n+        @Strict\n@@ -171,1 +172,2 @@\n-        public Person onePerson;\n+        public Person onePerson = new Person(0, null, null);\n+        @Strict\n@@ -173,1 +175,1 @@\n-        public Person otherPerson;\n+        public Person otherPerson = new Person(0, null, null);\n@@ -176,1 +178,0 @@\n-    @ImplicitlyConstructible\n@@ -179,0 +180,1 @@\n+        @Strict\n@@ -181,0 +183,1 @@\n+        @Strict\n@@ -199,1 +202,1 @@\n-        Person[] array = (Person[])ValueClass.newNullRestrictedArray(Person.class, NOF_PEOPLE);\n+        Person[] array = (Person[])ValueClass.newNullRestrictedNonAtomicArray(Person.class, NOF_PEOPLE, new Person(0, null, null));\n@@ -495,1 +498,1 @@\n-        return (Person)ValueClass.newNullRestrictedArray(Person.class, 1)[0];\n+        return (Person)ValueClass.newNullRestrictedNonAtomicArray(Person.class, 1, new Person(0, null, null))[0];\n@@ -541,1 +544,0 @@\n-    @ImplicitlyConstructible\n@@ -577,1 +579,0 @@\n-    @ImplicitlyConstructible\n@@ -649,1 +650,1 @@\n-            FooValue[] fa = (FooValue[])ValueClass.newNullRestrictedArray(FooValue.class, 1);\n+            FooValue[] fa = (FooValue[])ValueClass.newNullRestrictedNonAtomicArray(FooValue.class, 1, new FooValue());\n@@ -680,1 +681,0 @@\n-    @ImplicitlyConstructible\n@@ -683,0 +683,1 @@\n+        @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -30,0 +29,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -67,1 +67,3 @@\n-        testUtilArrays();\n+        testUtilArraysOnNullRestrictedNonAtomicArrays();\n+        testUtilArraysOnNullRestrictedAtomicArrays();\n+        testUtilArraysOnNullableAtomicArrays();\n@@ -89,1 +91,1 @@\n-        Point[] defaultPoint = (Point[])ValueClass.newNullRestrictedArray(Point.class, 1);\n+        Point[] defaultPoint = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, 1, new Point(0, 0));\n@@ -110,1 +112,1 @@\n-        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedArray(Point.class, points.length);\n+        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, points.length, new Point(0, 0));\n@@ -128,1 +130,1 @@\n-        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedArray(Point.class, points.length);\n+        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, points.length, new Point(0, 0));\n@@ -143,1 +145,1 @@\n-        Point[] ps = (Point[])ValueClass.newNullRestrictedArray(Point.class, 4);\n+        Point[] ps = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, 4, new Point(0, 0));\n@@ -170,1 +172,1 @@\n-        Long8Inline[] values = (Long8Inline[])ValueClass.newNullRestrictedArray(Long8Inline.class, 3);\n+        Long8Inline[] values = (Long8Inline[])ValueClass.newNullRestrictedNonAtomicArray(Long8Inline.class, 3, new Long8Inline());\n@@ -180,1 +182,1 @@\n-        Long8Inline[] copy = (Long8Inline[])ValueClass.newNullRestrictedArray(Long8Inline.class, values.length);\n+        Long8Inline[] copy = (Long8Inline[])ValueClass.newNullRestrictedNonAtomicArray(Long8Inline.class, values.length, new Long8Inline());\n@@ -187,1 +189,1 @@\n-        Person[] people = (Person[])ValueClass.newNullRestrictedArray(Person.class, 3);\n+        Person[] people = (Person[])ValueClass.newNullRestrictedNonAtomicArray(Person.class, 3, new Person(0, null, null));\n@@ -197,1 +199,1 @@\n-        Person[] peopleCopy = (Person[])ValueClass.newNullRestrictedArray(Person.class, people.length);\n+        Person[] peopleCopy = (Person[])ValueClass.newNullRestrictedNonAtomicArray(Person.class, people.length, new Person(0, null, null));\n@@ -239,1 +241,0 @@\n-    @ImplicitlyConstructible\n@@ -260,1 +261,0 @@\n-        \/\/ Null-able fields here are a temp hack to avoid ClassCircularityError\n@@ -272,1 +272,1 @@\n-        staticMyIntArray = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, 1);\n+        staticMyIntArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 1, new MyInt());\n@@ -277,0 +277,28 @@\n+    static value class MyShorts implements Comparable<MyShorts> {\n+        short s0, s1;\n+\n+        private MyShorts() { this((short)0, (short)0); }\n+        private MyShorts(short sa, short sb) { s0 = sa; s1 = sb; }\n+        public short getS0() { return s0; }\n+        public short getS1() { return s1; }\n+        public String toString() { return \"MyShorts: \" + getS0() + \" \" + getS1(); }\n+        public int compareTo(MyShorts that) {\n+            int r = Short.compare(this.getS0(), that.getS0());\n+            return r != 0 ? r : Short.compare(this.getS1(), that.getS1());\n+        }\n+        public boolean equals(Object o) {\n+            if (o instanceof MyShorts) {\n+                return this.getS0() == ((MyShorts) o).getS0() && this.getS1() == ((MyShorts) o).getS1();\n+            }\n+            return false;\n+        }\n+\n+        public static MyShorts create(short s0, short s1) {\n+            return new MyShorts(s0, s1);\n+        }\n+\n+        public static final MyShorts MIN = MyShorts.create(Short.MIN_VALUE, Short.MIN_VALUE);\n+        public static final MyShorts ZERO = MyShorts.create((short)0, (short)0);\n+        public static final MyShorts MAX = MyShorts.create(Short.MAX_VALUE, Short.MAX_VALUE);\n+    }\n+\n@@ -281,1 +309,0 @@\n-    @ImplicitlyConstructible\n@@ -289,1 +316,1 @@\n-        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, 1);\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 1, new MyInt());\n@@ -332,1 +359,1 @@\n-    void testUtilArrays() {\n+    void testUtilArraysOnNullRestrictedNonAtomicArrays() {\n@@ -335,4 +362,5 @@\n-        \/\/ cast to q-type temp effect of avoiding circularity error (decl static MyInt.ref)\n-        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, 2);\n-        myInts[0] = (MyInt) MyInt.MAX;\n-        myInts[1] = (MyInt) MyInt.MIN;\n+        \/\/ Testing Arrays.copyOf()\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        myInts[0] = MyInt.MAX;\n+        myInts[1] = MyInt.MIN;\n+        myInts[2] = MyInt.ZERO;\n@@ -340,3 +368,3 @@\n-        \/\/ Sanity sort another copy\n-        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);\n-        MyInt[] expected = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, 3);\n+        \/\/ Copy of same length, must work\n+        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length);\n+        MyInt[] expected = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n@@ -345,1 +373,1 @@\n-        expected[2] = (MyInt) MyInt.ZERO;\n+        expected[2] = myInts[2];\n@@ -348,0 +376,48 @@\n+        \/\/ Copy of shorter length, must work\n+        MyInt[] smallCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length - 1);\n+        MyInt[] expected2 = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 2, new MyInt());\n+        expected2[0] = myInts[0];\n+        expected2[1] = myInts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+        IllegalArgumentException iae = null;\n+        try {\n+            MyInt[] bigCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyInt[] fullRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, myInts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyInt[] beginningRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+\n+        MyInt[] endingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length);\n+        MyInt[] expected3 = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 2, new MyInt());\n+        expected3[0] = myInts[1];\n+        expected3[1] = myInts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyInt[] exceedingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Range starting after the end of the original array, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyInt[] farRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, myInts.length, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n@@ -349,1 +425,1 @@\n-        expected = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, 3);\n+        expected = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n@@ -357,1 +433,1 @@\n-        MyInt[] dest = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, copyMyInts.length);\n+        MyInt[] dest = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, copyMyInts.length, new MyInt());\n@@ -372,0 +448,172 @@\n+    void testUtilArraysOnNullRestrictedAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyShorts[] myShorts = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        myShorts[0] = MyShorts.MAX;\n+        myShorts[1] = MyShorts.MIN;\n+        myShorts[2] = MyShorts.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyShorts[] copyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length);\n+        MyShorts[] expected = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        expected[0] = myShorts[0];\n+        expected[1] = myShorts[1];\n+        expected[2] = myShorts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyShorts[] smallCopyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length - 1);\n+        MyShorts[] expected2 = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 2, new MyShorts());\n+        expected2[0] = myShorts[0];\n+        expected2[1] = myShorts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+        IllegalArgumentException iae = null;\n+        try {\n+            MyShorts[] bigCopyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyShorts[] fullRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 0, myShorts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyShorts[] beginningRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+\n+        MyShorts[] endingRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 1, myShorts.length);\n+        MyShorts[] expected3 = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 2, new MyShorts());\n+        expected3[0] = myShorts[1];\n+        expected3[1] = myShorts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyShorts[] exceedingRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 1, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Range starting after the end of the original array, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyShorts[] farRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, myShorts.length, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        expected[0] = (MyShorts) MyShorts.MIN;\n+        expected[1] = (MyShorts) MyShorts.ZERO;\n+        expected[2] = (MyShorts) MyShorts.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyShorts[] dest = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, copyMyInts.length, new MyShorts());\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyShorts> aList = new ArrayList<MyShorts>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyShorts.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyShorts.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyShorts.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyShorts.create((short)5, (short)7));\n+    }\n+\n+    void testUtilArraysOnNullableAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        myInts[0] = MyInt.MAX;\n+        myInts[1] = MyInt.MIN;\n+        myInts[2] = MyInt.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length);\n+        MyInt[] expected = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected[0] = myInts[0];\n+        expected[1] = myInts[1];\n+        expected[2] = myInts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyInt[] smallCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length - 1);\n+        MyInt[] expected2 = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 2);\n+        expected2[0] = myInts[0];\n+        expected2[1] = myInts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+        \/\/ Copy of bigger length, must work for nullable arrays\n+        MyInt[] bigCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);\n+        MyInt[] expected2b = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 4);\n+        expected2b[0] = myInts[0];\n+        expected2b[1] = myInts[1];\n+        expected2b[2] = myInts[2];\n+        expected2b[3] = null;\n+        checkArrayElementsEqual(bigCopyMyInts, expected2b);\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyInt[] fullRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, myInts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyInt[] beginningRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+        MyInt[] endingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length);\n+        MyInt[] expected3 = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 2);\n+        expected3[0] = myInts[1];\n+        expected3[1] = myInts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must succeed for nullable arrays\n+        MyInt[] exceedingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length + 1);\n+        MyInt[] expected3b = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected3b[0] = myInts[1];\n+        expected3b[1] = myInts[2];\n+        expected3b[2] = null;\n+        checkArrayElementsEqual(exceedingRangeCopy, expected3b);\n+\n+        \/\/ Range starting after the end of the original array, must fail for null-restricted arrays\n+        MyInt[] farRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, myInts.length, myInts.length + 1);\n+        MyInt[] expected3c = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 1);\n+        expected3c[0] = null;\n+        checkArrayElementsEqual(farRangeCopy, expected3c);\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected[0] = (MyInt) MyInt.MIN;\n+        expected[1] = (MyInt) MyInt.ZERO;\n+        expected[2] = (MyInt) MyInt.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyInt[] dest = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, copyMyInts.length);\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyInt> aList = new ArrayList<MyInt>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyInt.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyInt.create(5));\n+    }\n@@ -449,1 +697,1 @@\n-        valArray = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, 3);\n+        valArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n@@ -456,1 +704,1 @@\n-        valArray = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, 3);\n+        valArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n@@ -484,1 +732,0 @@\n-    @ImplicitlyConstructible\n@@ -487,0 +734,1 @@\n+        @Strict\n@@ -489,0 +737,1 @@\n+        @Strict\n@@ -510,0 +759,1 @@\n+        @Strict\n@@ -520,1 +770,1 @@\n-        MyPoint[] pts = (MyPoint[])ValueClass.newNullRestrictedArray(MyPoint.class, 3);\n+        MyPoint[] pts = (MyPoint[])ValueClass.newNullRestrictedNonAtomicArray(MyPoint.class, 3, new MyPoint());\n@@ -524,1 +774,1 @@\n-        pts = (MyPoint[])ValueClass.newNullRestrictedArray(MyPoint.class, 3);\n+        pts = (MyPoint[])ValueClass.newNullRestrictedNonAtomicArray(MyPoint.class, 3, new MyPoint());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":281,"deletions":31,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -27,1 +26,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -81,1 +79,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeCreation.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -87,1 +87,0 @@\n-    @ImplicitlyConstructible\n@@ -106,1 +105,0 @@\n-    @ImplicitlyConstructible\n@@ -128,1 +126,0 @@\n-    @ImplicitlyConstructible\n@@ -131,0 +128,1 @@\n+        @Strict\n@@ -133,0 +131,1 @@\n+        @Strict\n@@ -233,1 +232,0 @@\n-    @ImplicitlyConstructible\n@@ -236,1 +234,0 @@\n-    @ImplicitlyConstructible\n@@ -239,1 +236,0 @@\n-    @ImplicitlyConstructible\n@@ -242,1 +238,0 @@\n-    @ImplicitlyConstructible\n@@ -258,1 +253,1 @@\n-            MyByte[] mba = (MyByte[])ValueClass.newNullRestrictedArray(MyByte.class, testSize);\n+            MyByte[] mba = (MyByte[])ValueClass.newNullRestrictedNonAtomicArray(MyByte.class, testSize, new MyByte());\n@@ -266,1 +261,1 @@\n-            MyShort[] msa = (MyShort[])ValueClass.newNullRestrictedArray(MyShort.class, testSize);\n+            MyShort[] msa = (MyShort[])ValueClass.newNullRestrictedNonAtomicArray(MyShort.class, testSize, new MyShort());\n@@ -274,1 +269,1 @@\n-            MyInt[] mia = (MyInt[])ValueClass.newNullRestrictedArray(MyInt.class, testSize);\n+            MyInt[] mia = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, testSize, new MyInt());\n@@ -282,1 +277,1 @@\n-            MyLong[] mla = (MyLong[])ValueClass.newNullRestrictedArray(MyLong.class, testSize);\n+            MyLong[] mla = (MyLong[])ValueClass.newNullRestrictedNonAtomicArray(MyLong.class, testSize, new MyLong());\n@@ -295,1 +290,0 @@\n-    @ImplicitlyConstructible\n@@ -298,1 +292,0 @@\n-    @ImplicitlyConstructible\n@@ -301,1 +294,0 @@\n-    @ImplicitlyConstructible\n@@ -304,1 +296,0 @@\n-    @ImplicitlyConstructible\n@@ -307,1 +298,0 @@\n-    @ImplicitlyConstructible\n@@ -314,5 +304,5 @@\n-        assertArraySameSize(new short[testSize], ValueClass.newNullRestrictedArray(bbValue.class, testSize), testSize);\n-        assertArraySameSize(new long[testSize], ValueClass.newNullRestrictedArray(siValue.class, testSize), testSize);\n-        assertArraySameSize(new long[testSize], ValueClass.newNullRestrictedArray(ssiValue.class, testSize), testSize);\n-        assertArraySameSize(new long[testSize*2], ValueClass.newNullRestrictedArray(blValue.class, testSize), testSize);\n-        assertArraySameSize(new int[testSize], ValueClass.newNullRestrictedArray(bsValue.class, testSize), testSize);\n+        assertArraySameSize(new short[testSize], ValueClass.newNullRestrictedNonAtomicArray(bbValue.class, testSize, new bbValue()), testSize);\n+        assertArraySameSize(new long[testSize], ValueClass.newNullRestrictedNonAtomicArray(siValue.class, testSize, new siValue()), testSize);\n+        assertArraySameSize(new long[testSize], ValueClass.newNullRestrictedNonAtomicArray(ssiValue.class, testSize, new ssiValue()), testSize);\n+        assertArraySameSize(new long[testSize*2], ValueClass.newNullRestrictedNonAtomicArray(blValue.class, testSize, new blValue()), testSize);\n+        assertArraySameSize(new int[testSize], ValueClass.newNullRestrictedNonAtomicArray(bsValue.class, testSize, new bsValue()), testSize);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeDensity.java","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -39,0 +40,1 @@\n+    @Strict\n@@ -41,0 +43,1 @@\n+    @Strict\n@@ -43,0 +46,1 @@\n+    @Strict\n@@ -45,0 +49,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeGetField.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -47,0 +46,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -73,0 +73,1 @@\n+    @Strict\n@@ -74,1 +75,1 @@\n-    TestValue1 nonStaticInlineField;\n+    TestValue1 nonStaticInlineField = new TestValue1();\n@@ -78,1 +79,0 @@\n-@ImplicitlyConstructible\n@@ -114,0 +114,1 @@\n+    @Strict\n@@ -115,1 +116,1 @@\n-    TestValue2 nonStaticInlineField;\n+    TestValue2 nonStaticInlineField = new TestValue2();\n@@ -119,1 +120,0 @@\n-@ImplicitlyConstructible\n@@ -162,0 +162,1 @@\n+    @Strict\n@@ -163,1 +164,1 @@\n-    TestValue3 nonStaticInlineField;\n+    TestValue3 nonStaticInlineField = new TestValue3();\n@@ -167,1 +168,0 @@\n-@ImplicitlyConstructible\n@@ -198,0 +198,1 @@\n+    @Strict\n@@ -199,1 +200,1 @@\n-    TestValue4 nonStaticInlineField;\n+    TestValue4 nonStaticInlineField = new TestValue4();\n@@ -203,1 +204,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -28,1 +27,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/JumboInline.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -30,1 +29,0 @@\n-@ImplicitlyConstructible\n@@ -43,0 +41,4 @@\n+    public Long8Inline() {\n+        this(0, 0, 0, 0, 0, 0, 0, 0);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Long8Inline.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -71,1 +70,1 @@\n-        ValueClass.newNullRestrictedArray(String.class, 4);\n+        ValueClass.newNullRestrictedNonAtomicArray(String.class, 4, new String());\n@@ -80,1 +79,0 @@\n-  @ImplicitlyConstructible\n@@ -90,18 +88,1 @@\n-        ValueClass.newNullRestrictedArray(ValueClass1.class, -1);\n-      } catch (IllegalArgumentException e) {\n-        System.out.println(\"Received: \" + e);\n-        exception = e;\n-      }\n-      Asserts.assertNotNull(exception, \"Expected IllegalArgumentException not received\");\n-  }\n-\n-  \/\/ Test illegal attempt to create a null restricted array with a value class not annotated with @ImplicitlyConstructible\n-  static value class ValueClass2 {\n-    int i = 0;\n-    int j = 0;\n-  }\n-\n-  public void test_2() {\n-      Throwable exception = null;\n-      try {\n-        ValueClass.newNullRestrictedArray(ValueClass2.class, 8);\n+        ValueClass.newNullRestrictedNonAtomicArray(ValueClass1.class, -1, new ValueClass1());\n@@ -116,1 +97,0 @@\n-  @ImplicitlyConstructible\n@@ -126,1 +106,1 @@\n-        Object array = ValueClass.newNullRestrictedArray(ValueClass3.class, 8);\n+        Object array = ValueClass.newNullRestrictedNonAtomicArray(ValueClass3.class, 8, new ValueClass3());\n@@ -136,1 +116,0 @@\n-  @ImplicitlyConstructible\n@@ -138,1 +117,0 @@\n-\n@@ -147,1 +125,1 @@\n-        Object[] array = ValueClass.newNullRestrictedArray(ValueClass4.class, 8);\n+        Object[] array = ValueClass.newNullRestrictedNonAtomicArray(ValueClass4.class, 8, new ValueClass4());\n@@ -157,1 +135,0 @@\n-  @ImplicitlyConstructible\n@@ -167,1 +144,1 @@\n-        Object[] array = ValueClass.newNullRestrictedArray(ValueClass4.class, 8);\n+        Object[] array = ValueClass.newNullRestrictedNonAtomicArray(ValueClass5.class, 8, new ValueClass5());\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullRestrictedArrayTest.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @ignore\n@@ -34,1 +33,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -42,1 +40,0 @@\n-  @ImplicitlyConstructible\n@@ -96,1 +93,0 @@\n-  @ImplicitlyConstructible\n@@ -116,1 +112,0 @@\n-  @ImplicitlyConstructible\n@@ -166,1 +161,0 @@\n-  @ImplicitlyConstructible\n@@ -184,1 +178,0 @@\n-  @ImplicitlyConstructible\n@@ -268,1 +261,0 @@\n-  @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullableFlatFieldTest.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,1 +28,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Person.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -28,1 +27,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Point.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,4 +35,4 @@\n- import java.lang.reflect.Method;\n- import java.util.ArrayList;\n- import java.util.Collections;\n- import java.util.List;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -42,4 +42,4 @@\n- import jdk.internal.value.ValueClass;\n- import jdk.internal.vm.annotation.ImplicitlyConstructible;\n- import jdk.internal.vm.annotation.LooselyConsistentValue;\n- import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n@@ -57,0 +57,1 @@\n+        @Strict\n@@ -61,1 +62,0 @@\n-    @ImplicitlyConstructible\n@@ -63,0 +63,1 @@\n+        @Strict\n@@ -67,1 +68,0 @@\n-    @ImplicitlyConstructible\n@@ -83,0 +83,1 @@\n+        @Strict\n@@ -87,1 +88,0 @@\n-    @ImplicitlyConstructible\n@@ -106,0 +106,1 @@\n+        @Strict\n@@ -110,1 +111,0 @@\n-    @ImplicitlyConstructible\n@@ -112,0 +112,1 @@\n+        @Strict\n@@ -116,1 +117,0 @@\n-    @ImplicitlyConstructible\n@@ -118,0 +118,1 @@\n+        @Strict\n@@ -134,0 +135,1 @@\n+        @Strict\n@@ -138,1 +140,0 @@\n-    @ImplicitlyConstructible\n@@ -140,0 +141,1 @@\n+        @Strict\n@@ -144,1 +146,0 @@\n-    @ImplicitlyConstructible\n@@ -161,0 +162,1 @@\n+        @Strict\n@@ -165,1 +167,0 @@\n-    @ImplicitlyConstructible\n@@ -167,0 +168,1 @@\n+        @Strict\n@@ -183,0 +185,1 @@\n+        @Strict\n@@ -188,0 +191,1 @@\n+        @Strict\n@@ -192,1 +196,0 @@\n-    @ImplicitlyConstructible\n@@ -198,0 +201,1 @@\n+        @Strict\n@@ -222,0 +226,1 @@\n+        @Strict\n@@ -226,1 +231,0 @@\n-    @ImplicitlyConstructible\n@@ -230,0 +234,1 @@\n+        @Strict\n@@ -238,1 +243,0 @@\n-    @ImplicitlyConstructible\n@@ -240,0 +244,1 @@\n+        @Strict\n@@ -257,1 +262,0 @@\n-    @ImplicitlyConstructible\n@@ -259,0 +263,1 @@\n+        @Strict\n@@ -280,0 +285,1 @@\n+        @Strict\n@@ -294,0 +300,1 @@\n+        @Strict\n@@ -300,6 +307,6 @@\n-    void test_10() throws Exception {\n-        OutputAnalyzer out = tryLoadingClass(\"PreloadCircularityTest$Class10a\");\n-        out.shouldHaveExitValue(1);\n-        out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class10b during loading of class PreloadCircularityTest$Class10a. Cause: a null-free non-static field is declared with this type\");\n-        out.shouldContain(\"java.lang.IncompatibleClassChangeError: class PreloadCircularityTest$Class10b is not implicitly constructible and it is used in a null restricted non-static field (not supported)\");\n-    }\n+    \/\/ void test_10() throws Exception {\n+    \/\/     OutputAnalyzer out = tryLoadingClass(\"PreloadCircularityTest$Class10a\");\n+    \/\/     out.shouldHaveExitValue(1);\n+    \/\/     out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class10b during loading of class PreloadCircularityTest$Class10a. Cause: a null-free non-static field is declared with this type\");\n+    \/\/     out.shouldContain(\"java.lang.IncompatibleClassChangeError: class PreloadCircularityTest$Class10b is not implicitly constructible and it is used in a null restricted non-static field (not supported)\");\n+    \/\/ }\n@@ -309,1 +316,0 @@\n-    @ImplicitlyConstructible\n@@ -311,0 +317,1 @@\n+        @Strict\n@@ -312,1 +319,1 @@\n-        static Class50a sa;\n+        static Class50a sa = new Class50a();\n@@ -321,1 +328,0 @@\n-    @ImplicitlyConstructible\n@@ -323,0 +329,1 @@\n+        @Strict\n@@ -324,1 +331,1 @@\n-        static Class51b sb;\n+        static Class51b sb = new Class51b();\n@@ -326,0 +333,1 @@\n+        @Strict\n@@ -327,1 +335,1 @@\n-        static Class51c sc;\n+        static Class51c sc = new Class51c();\n@@ -330,1 +338,0 @@\n-    @ImplicitlyConstructible\n@@ -332,0 +339,1 @@\n+        @Strict\n@@ -333,1 +341,1 @@\n-        static Class51a sa;\n+        static Class51a sa = new Class51a();\n@@ -336,1 +344,0 @@\n-    @ImplicitlyConstructible\n@@ -338,0 +345,1 @@\n+        @Strict\n@@ -356,0 +364,1 @@\n+        @Strict\n@@ -357,1 +366,1 @@\n-        static Class52b vb;\n+        static Class52b vb = new Class52b();\n@@ -360,1 +369,0 @@\n-    @ImplicitlyConstructible\n@@ -362,0 +370,1 @@\n+        @Strict\n@@ -366,1 +375,0 @@\n-    @ImplicitlyConstructible\n@@ -368,0 +376,1 @@\n+        @Strict\n@@ -382,1 +391,0 @@\n-    @ImplicitlyConstructible\n@@ -386,0 +394,1 @@\n+        @Strict\n@@ -387,1 +396,1 @@\n-        static Class53b sb;\n+        static Class53b sb = new Class53b();\n@@ -390,1 +399,0 @@\n-    @ImplicitlyConstructible\n@@ -392,0 +400,1 @@\n+        @Strict\n@@ -398,12 +407,12 @@\n-    void test_53() throws Exception {\n-        OutputAnalyzer out = tryLoadingClass(\"PreloadCircularityTest$Class53a\");\n-        out.shouldHaveExitValue(0);\n-        out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class53b during loading of class PreloadCircularityTest$Class53a. Cause: field type in LoadableDescriptors attribute\");\n-        out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b. Cause: a null-free non-static field is declared with this type\");\n-        out.shouldContain(\"[warning][class,preload] Preloading of class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b (cause: null-free non-static field) failed: java\/lang\/ClassCircularityError\");\n-        out.shouldContain(\"[warning][class,preload] Preloading of class PreloadCircularityTest$Class53b during loading of class PreloadCircularityTest$Class53a (cause: field type in LoadableDescriptors attribute) failed : java\/lang\/ClassCircularityError\");\n-        out.shouldContain(\"[info   ][class,preload] Preloading class PreloadCircularityTest$Class53b during linking of class PreloadCircularityTest$Class53a. Cause: a null-free static field is declared with this type\");\n-        out.shouldContain(\"[info   ][class,preload] Preloading class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b. Cause: a null-free non-static field is declared with this type\");\n-        out.shouldContain(\"[info   ][class,preload] Preloading of class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b (cause: null-free non-static field) succeeded\");\n-        out.shouldContain(\"[info   ][class,preload] Preloading of class PreloadCircularityTest$Class53b during linking of class PreloadCircularityTest$Class53a (cause: null-free static field) succeeded\");\n-    }\n+    \/\/ void test_53() throws Exception {\n+    \/\/     OutputAnalyzer out = tryLoadingClass(\"PreloadCircularityTest$Class53a\");\n+    \/\/     out.shouldHaveExitValue(0);\n+    \/\/     out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class53b during loading of class PreloadCircularityTest$Class53a. Cause: field type in LoadableDescriptors attribute\");\n+    \/\/     out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b. Cause: a null-free non-static field is declared with this type\");\n+    \/\/     out.shouldContain(\"[warning][class,preload] Preloading of class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b (cause: null-free non-static field) failed: java\/lang\/ClassCircularityError\");\n+    \/\/     out.shouldContain(\"[warning][class,preload] Preloading of class PreloadCircularityTest$Class53b during loading of class PreloadCircularityTest$Class53a (cause: field type in LoadableDescriptors attribute) failed : java\/lang\/ClassCircularityError\");\n+    \/\/     out.shouldContain(\"[info   ][class,preload] Preloading class PreloadCircularityTest$Class53b during linking of class PreloadCircularityTest$Class53a. Cause: a null-free static field is declared with this type\");\n+    \/\/     out.shouldContain(\"[info   ][class,preload] Preloading class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b. Cause: a null-free non-static field is declared with this type\");\n+    \/\/     out.shouldContain(\"[info   ][class,preload] Preloading of class PreloadCircularityTest$Class53a during loading of class PreloadCircularityTest$Class53b (cause: null-free non-static field) succeeded\");\n+    \/\/     out.shouldContain(\"[info   ][class,preload] Preloading of class PreloadCircularityTest$Class53b during linking of class PreloadCircularityTest$Class53a (cause: null-free static field) succeeded\");\n+    \/\/ }\n@@ -412,0 +421,1 @@\n+        @Strict\n@@ -413,1 +423,1 @@\n-        static Class54b sb;\n+        static Class54b sb = new Class54b();\n@@ -427,0 +437,1 @@\n+        @Strict\n@@ -428,1 +439,1 @@\n-        static Class55b sb;\n+        static Class55b sb = new Class55b();\n@@ -433,7 +444,7 @@\n-    void test_55() throws Exception {\n-        OutputAnalyzer out = tryLoadingClass(\"PreloadCircularityTest$Class55a\");\n-        out.shouldHaveExitValue(1);\n-        out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class55b during linking of class PreloadCircularityTest$Class55a. Cause: a null-free static field is declared with this type\");\n-        out.shouldContain(\"[info][class,preload] Preloading of class PreloadCircularityTest$Class55b during linking of class PreloadCircularityTest$Class55a (cause: null-free static field) succeeded\");\n-        out.shouldContain(\"java.lang.IncompatibleClassChangeError: class PreloadCircularityTest$Class55b is not implicitly constructible and it is used in a null restricted static field (not supported)\");\n-    }\n+    \/\/ void test_55() throws Exception {\n+    \/\/     OutputAnalyzer out = tryLoadingClass(\"PreloadCircularityTest$Class55a\");\n+    \/\/     out.shouldHaveExitValue(1);\n+    \/\/     out.shouldContain(\"[info][class,preload] Preloading class PreloadCircularityTest$Class55b during linking of class PreloadCircularityTest$Class55a. Cause: a null-free static field is declared with this type\");\n+    \/\/     out.shouldContain(\"[info][class,preload] Preloading of class PreloadCircularityTest$Class55b during linking of class PreloadCircularityTest$Class55a (cause: null-free static field) succeeded\");\n+    \/\/     out.shouldContain(\"java.lang.IncompatibleClassChangeError: class PreloadCircularityTest$Class55b is not implicitly constructible and it is used in a null restricted static field (not supported)\");\n+    \/\/ }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/PreloadCircularityTest.java","additions":72,"deletions":61,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,0 +28,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -43,1 +43,0 @@\n-    @ImplicitlyConstructible\n@@ -55,1 +54,0 @@\n-    @ImplicitlyConstructible\n@@ -105,0 +103,1 @@\n+    @Strict\n@@ -106,1 +105,2 @@\n-    Point fp;         \/* Flattenable and flattened inline field *\/\n+    Point fp = new Point(1, 2);         \/* Flattenable and flattened inline field *\/\n+    @Strict\n@@ -108,1 +108,1 @@\n-    JumboInline fj;    \/* Flattenable not flattened inline field *\/\n+    JumboInline fj = new JumboInline(3L, 4L);    \/* Flattenable not flattened inline field *\/\n@@ -118,0 +118,1 @@\n+        @Strict\n@@ -119,1 +120,2 @@\n-        Point fp2;        \/* Flattenable and flattened inline field *\/\n+        Point fp2 = new Point(5, 6);        \/* Flattenable and flattened inline field *\/\n+        @Strict\n@@ -121,1 +123,1 @@\n-        JumboInline fj2;   \/* Flattenable not flattened inline field *\/\n+        JumboInline fj2 = new JumboInline(7L, 8L);   \/* Flattenable not flattened inline field *\/\n@@ -128,1 +130,0 @@\n-    @ImplicitlyConstructible\n@@ -132,0 +133,1 @@\n+        @Strict\n@@ -134,0 +136,1 @@\n+        @Strict\n@@ -139,2 +142,2 @@\n-            fp = new Point(0, 0);\n-            fj = new JumboInline(0, 0);\n+            fp = new Point(9, 10);\n+            fj = new JumboInline(11L, 12L);\n@@ -147,4 +150,4 @@\n-        Asserts.assertEquals(p.fp.x, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(p.fp.y, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(p.fj.l0, 0L, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(p.fj.l1, 0L, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(p.fp.x, 1, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(p.fp.y, 2, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(p.fj.l0, 3L, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(p.fj.l1, 4L, \"invalid value for uninitialized flattened field\");\n@@ -154,4 +157,4 @@\n-        Asserts.assertEquals(c.fp.x, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(c.fp.y, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(c.fj.l0, 0L, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(c.fj.l1, 0L, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(c.fp.x, 1, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(c.fp.y, 2, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(c.fj.l0, 3L, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(c.fj.l1, 4L, \"invalid value for uninitialized flattened field\");\n@@ -159,4 +162,4 @@\n-        Asserts.assertEquals(c.fp2.x, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(c.fp2.y, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(c.fj2.l0, 0L, \"invalid value for uninitialized not flattened field\");\n-        Asserts.assertEquals(c.fj2.l1, 0L, \"invalid value for uninitialized not flattened field\");\n+        Asserts.assertEquals(c.fp2.x, 5, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(c.fp2.y, 6, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(c.fj2.l0, 7L, \"invalid value for uninitialized not flattened field\");\n+        Asserts.assertEquals(c.fj2.l1, 8L, \"invalid value for uninitialized not flattened field\");\n@@ -166,4 +169,4 @@\n-        Asserts.assertEquals(v.fp.x, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(v.fp.y, 0, \"invalid value for uninitialized flattened field\");\n-        Asserts.assertEquals(v.fj.l0, 0L, \"invalid value for uninitialized not flattened field\");\n-        Asserts.assertEquals(v.fj.l1, 0L, \"invalid value for uninitialized not flattened field\");\n+        Asserts.assertEquals(v.fp.x, 9, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(v.fp.y, 10, \"invalid value for uninitialized flattened field\");\n+        Asserts.assertEquals(v.fj.l0, 11L, \"invalid value for uninitialized not flattened field\");\n+        Asserts.assertEquals(v.fj.l1, 12L, \"invalid value for uninitialized not flattened field\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/QuickeningTest.java","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,0 +28,2 @@\n+import jdk.internal.vm.annotation.Strict;\n+\n@@ -46,1 +47,0 @@\n-    @ImplicitlyConstructible\n@@ -49,0 +49,1 @@\n+        @Strict\n@@ -50,1 +51,1 @@\n-        static ClassB b;\n+        static ClassB b = new ClassB();\n@@ -58,1 +59,0 @@\n-    @ImplicitlyConstructible\n@@ -61,0 +61,1 @@\n+        @Strict\n@@ -62,1 +63,1 @@\n-        static ClassA a;\n+        static ClassA a = new ClassA();\n@@ -71,1 +72,1 @@\n-    \/\/ to initialize itelf successfully. Access to this static field after initialization\n+    \/\/ to initialize itself successfully. Access to this static field after initialization\n@@ -73,1 +74,0 @@\n-    @ImplicitlyConstructible\n@@ -76,0 +76,1 @@\n+        @Strict\n@@ -77,1 +78,1 @@\n-        static ClassC c;\n+        static ClassC c = new ClassC();\n@@ -90,1 +91,0 @@\n-    @ImplicitlyConstructible\n@@ -93,0 +93,1 @@\n+        @Strict\n@@ -94,1 +95,1 @@\n-        static ClassE e;\n+        static ClassE e = new ClassE();\n@@ -98,1 +99,1 @@\n-            Asserts.assertEquals(e.i, 0, \"Static field e.i incorrect\");\n+            Asserts.assertEquals(e.i, 42, \"Static field e.i incorrect\");\n@@ -106,1 +107,0 @@\n-    @ImplicitlyConstructible\n@@ -109,0 +109,1 @@\n+        @Strict\n@@ -110,1 +111,1 @@\n-        static ClassD d;\n+        static ClassD d = new ClassD();\n@@ -114,1 +115,1 @@\n-            Asserts.assertEquals(d.i, 0, \"Static field d.i incorrect\");\n+            Asserts.assertEquals(d.i, 42, \"Static field d.i incorrect\");\n@@ -125,1 +126,0 @@\n-    @ImplicitlyConstructible\n@@ -128,0 +128,1 @@\n+        @Strict\n@@ -129,1 +130,1 @@\n-        static ClassG g;\n+        static ClassG g = new ClassG();\n@@ -142,1 +143,0 @@\n-    @ImplicitlyConstructible\n@@ -145,0 +145,1 @@\n+        @Strict\n@@ -146,1 +147,1 @@\n-        static ClassF f;\n+        static ClassF f = new ClassF();\n@@ -160,3 +161,3 @@\n-        Asserts.assertEquals(ClassA.b.i, 0, \"Static field ClassA.b.i incorrect\");\n-        Asserts.assertEquals(ClassB.a.i, 0, \"Static field Classb.a.i incorrect\");\n-        Asserts.assertEquals(ClassC.c.i, 0, \"Static field ClassC.c.i incorrect\");\n+        Asserts.assertEquals(ClassA.b.i, 700, \"Static field ClassA.b.i incorrect\");\n+        Asserts.assertEquals(ClassB.a.i, 3, \"Static field Classb.a.i incorrect\");\n+        Asserts.assertEquals(ClassC.c.i, 42, \"Static field ClassC.c.i incorrect\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/StaticFieldsTest.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -29,0 +28,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -52,1 +52,0 @@\n-@ImplicitlyConstructible\n@@ -64,1 +63,1 @@\n-        MyValueType[] array = (MyValueType[])ValueClass.newNullRestrictedArray(MyValueType.class, 1);\n+        MyValueType[] array = (MyValueType[])ValueClass.newNullRestrictedNonAtomicArray(MyValueType.class, 1, new MyValueType(0, 0));\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Test8186715.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -39,0 +38,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -43,1 +43,0 @@\n-    @ImplicitlyConstructible\n@@ -53,1 +52,0 @@\n-    @ImplicitlyConstructible\n@@ -67,0 +65,1 @@\n+        @Strict\n@@ -68,1 +67,1 @@\n-        MyValue nullfreeField;       \/\/ flattened\n+        MyValue nullfreeField = new MyValue();       \/\/ flattened\n@@ -70,0 +69,1 @@\n+        @Strict\n@@ -71,1 +71,1 @@\n-        MyBigValue nullfreeBigField; \/\/ not flattened\n+        MyBigValue nullfreeBigField = new MyBigValue(); \/\/ not flattened\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldNullability.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -40,0 +41,1 @@\n+    @Strict\n@@ -41,1 +43,1 @@\n-    Point p;\n+    Point p = new Point(1, 2);\n@@ -57,0 +59,1 @@\n+    @Strict\n@@ -58,1 +61,1 @@\n-    Point p1;\n+    Point p1 = new Point(3, 4);\n@@ -66,0 +69,1 @@\n+    @Strict\n@@ -67,1 +71,1 @@\n-    Point p2;\n+    Point p2 = new Point(5, 6);\n@@ -80,3 +84,0 @@\n-        Asserts.assertEquals(b.p.x, 0);\n-        Asserts.assertEquals(b.p.y, 0);\n-        b.p = new Point(1,2);\n@@ -85,0 +86,3 @@\n+        b.p = new Point(2,3);\n+        Asserts.assertEquals(b.p.x, 2);\n+        Asserts.assertEquals(b.p.y, 3);\n@@ -87,4 +91,4 @@\n-        Asserts.assertEquals(g.p1.x, 0);\n-        Asserts.assertEquals(g.p1.y, 0);\n-        Asserts.assertEquals(g.p2.x, 0);\n-        Asserts.assertEquals(g.p2.y, 0);\n+        Asserts.assertEquals(g.p1.x, 3);\n+        Asserts.assertEquals(g.p1.y, 4);\n+        Asserts.assertEquals(g.p2.x, 5);\n+        Asserts.assertEquals(g.p2.y, 6);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestInheritedInlineTypeFields.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,1 +40,0 @@\n-  @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestJNIIsSameObject.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package runtime.valhalla.inlinetypes;\n-\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @summary Uninitialized inline fields test\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.vm.annotation\n- * @enablePreview\n- * @compile Point.java JumboInline.java UninitializedInlineFieldsTest.java\n- * @run main\/othervm -XX:+UseFieldFlattening runtime.valhalla.inlinetypes.UninitializedInlineFieldsTest\n- *\/\n-public class UninitializedInlineFieldsTest {\n-    static Point nonFlattenableStaticPoint;\n-    @NullRestricted\n-    static Point staticPoint;\n-\n-    @NullRestricted\n-    Point instancePoint;\n-\n-    static JumboInline sj1;\n-    @NullRestricted\n-    static JumboInline sj2;\n-\n-    JumboInline j1;\n-    @NullRestricted\n-    JumboInline j2;\n-\n-    static Object getNull() {\n-        return null;\n-    }\n-\n-    UninitializedInlineFieldsTest() { }\n-\n-    public static void main(String[] args) {\n-        checkUninitializedPoint(UninitializedInlineFieldsTest.staticPoint, 0, 0);\n-        Asserts.assertEquals(nonFlattenableStaticPoint, null, \"invalid non flattenable static inline field\");\n-        UninitializedInlineFieldsTest.staticPoint = new Point(456, 678);\n-        checkUninitializedPoint(UninitializedInlineFieldsTest.staticPoint, 456, 678);\n-        UninitializedInlineFieldsTest test = new UninitializedInlineFieldsTest();\n-        checkUninitializedPoint(test.instancePoint, 0, 0);\n-        test.instancePoint = new Point(123, 345);\n-        checkUninitializedPoint(test.instancePoint, 123, 345);\n-\n-        Asserts.assertEquals(test.j1, null, \"invalid non flattenable instance inline field\");\n-        Asserts.assertEquals(test.j2.l0, 0L, \"invalid flattenable instance inline field\");\n-    }\n-\n-    static void checkUninitializedPoint(Point p, int x, int y) {\n-        Asserts.assertEquals(p.x, x, \"invalid x value\");\n-        Asserts.assertEquals(p.y, y, \"invalid y value\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UninitializedInlineFieldsTest.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -46,1 +46,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -58,1 +57,0 @@\n-    @ImplicitlyConstructible\n@@ -70,1 +68,0 @@\n-    @ImplicitlyConstructible\n@@ -83,1 +80,0 @@\n-    @ImplicitlyConstructible\n@@ -97,1 +93,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -39,0 +38,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -47,1 +47,0 @@\n-  @ImplicitlyConstructible\n@@ -58,0 +57,1 @@\n+  @Strict\n@@ -59,1 +59,1 @@\n-  TestValue tv;\n+  TestValue tv = new TestValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueCopyingTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -42,0 +41,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -126,1 +126,0 @@\n-    @ImplicitlyConstructible\n@@ -147,0 +146,1 @@\n+        @Strict\n@@ -148,2 +148,2 @@\n-        TPoint field;\n-        TPoint[] array = (TPoint[])ValueClass.newNullRestrictedArray(TPoint.class, 1);\n+        TPoint field = new TPoint(0, 0);\n+        TPoint[] array = (TPoint[])ValueClass.newNullRestrictedNonAtomicArray(TPoint.class, 1, new TPoint(0, 0));\n@@ -191,1 +191,0 @@\n-    @ImplicitlyConstructible\n@@ -199,0 +198,1 @@\n+        @Strict\n@@ -200,2 +200,2 @@\n-        NTPoint field;\n-        NTPoint[] array = (NTPoint[])ValueClass.newNullRestrictedArray(NTPoint.class, 1);\n+        NTPoint field = new NTPoint(0, 0);\n+        NTPoint[] array = (NTPoint[])ValueClass.newNullRestrictedNonAtomicArray(NTPoint.class, 1, new NTPoint(0, 0));\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueTearing.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -32,1 +31,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -45,1 +43,0 @@\n-@ImplicitlyConstructible\n@@ -211,1 +208,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/VarArgsArray.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,0 +40,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -53,1 +53,0 @@\n-    @ImplicitlyConstructible\n@@ -61,0 +60,1 @@\n+        @Strict\n@@ -62,1 +62,2 @@\n-        MyValue mv0;\n+        MyValue mv0 = new MyValue();\n+        @Strict\n@@ -64,1 +65,1 @@\n-        volatile MyValue mv1;\n+        volatile MyValue mv1 = new MyValue();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/VolatileTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    runTest(\"StrictAndStatic\", \"Illegal field modifiers (field cannot be strict and static) in class StrictAndStatic: 0x808\");\n+    \/\/ runTest(\"StrictAndStatic\", \"Illegal field modifiers (field cannot be strict and static) in class StrictAndStatic: 0x808\");\n@@ -60,1 +60,1 @@\n-    runTest(\"StrictNotFinal\", \"Illegal field modifiers (strict field must be final) in class StrictNotFinal: 0x800\");\n+    \/\/ runTest(\"StrictNotFinal\", \"Illegal field modifiers (strict field must be final) in class StrictNotFinal: 0x800\");\n@@ -63,1 +63,1 @@\n-    runTest(\"NotStaticNotStrict\", \"Illegal field modifiers (value class fields must be either strict or static) in class NotStaticNotStrict: 0x10\");\n+    runTest(\"NotStaticNotStrict\", \"Illegal field modifiers (value class fields must be either non-static final and strict, or static) in class NotStaticNotStrict: 0x10\");\n@@ -66,1 +66,1 @@\n-    runTest(\"NotStaticNotStrictInAbstract\", \"Illegal field modifiers (value class fields must be either strict or static) in class NotStaticNotStrictInAbstract: 0x10\");\n+    runTest(\"NotStaticNotStrictInAbstract\", \"Illegal field modifiers (value class fields must be either non-static final and strict, or static) in class NotStaticNotStrictInAbstract: 0x10\");\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/IllegalFieldModifiers.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n- import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -64,0 +63,2 @@\n+ import jdk.internal.vm.annotation.Strict;\n+\n@@ -101,7 +102,7 @@\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueOneByte { byte val = 0; }\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueOneChar { char val = 0; }\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueOneShort { short val = 0; }\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueOneInt { int val = 0; }\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueOneLong { long val = 0; }\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueOneFloat { float val = 0f; }\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueOneDouble { double val = 0d; }\n+  @LooselyConsistentValue static value class ValueOneByte { byte val = 0; }\n+  @LooselyConsistentValue static value class ValueOneChar { char val = 0; }\n+  @LooselyConsistentValue static value class ValueOneShort { short val = 0; }\n+  @LooselyConsistentValue static value class ValueOneInt { int val = 0; }\n+  @LooselyConsistentValue static value class ValueOneLong { long val = 0; }\n+  @LooselyConsistentValue static value class ValueOneFloat { float val = 0f; }\n+  @LooselyConsistentValue static value class ValueOneDouble { double val = 0d; }\n@@ -109,2 +110,2 @@\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueByteLong { byte b = 0; long l = 0; }\n-  @ImplicitlyConstructible @LooselyConsistentValue static value class ValueByteInt { byte b = 0; int i = 0; }\n+  @LooselyConsistentValue static value class ValueByteLong { byte b = 0; long l = 0; }\n+  @LooselyConsistentValue static value class ValueByteInt { byte b = 0; int i = 0; }\n@@ -118,1 +119,2 @@\n-        String sourceCode = \"import jdk.internal.vm.annotation.NullRestricted; \" +\n+        String sourceCode = \"import jdk.internal.vm.annotation.NullRestricted;\" +\n+                            \"import jdk.internal.vm.annotation.Strict;\" +\n@@ -120,0 +122,1 @@\n+                            \"    @Strict\" +\n@@ -121,1 +124,1 @@\n-                            \"    \" + vName + \" v1;\" +\n+                            \"    \" + vName + \" v1 = new \" + vName + \"();\" +\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldAlignmentTest.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -75,0 +73,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -121,1 +120,0 @@\n-  @ImplicitlyConstructible\n@@ -129,0 +127,1 @@\n+    @Strict\n@@ -177,1 +176,0 @@\n-  @ImplicitlyConstructible\n@@ -183,0 +181,1 @@\n+    @Strict\n@@ -184,1 +183,1 @@\n-    Value3 val0;\n+    Value3 val0 = new Value3();\n@@ -190,0 +189,1 @@\n+    @Strict\n@@ -191,1 +191,1 @@\n-    Value3 val3;\n+    Value3 val3 = new Value3();\n@@ -227,1 +227,0 @@\n-  @ImplicitlyConstructible\n@@ -253,1 +252,0 @@\n-  @ImplicitlyConstructible\n@@ -260,1 +258,0 @@\n-  @ImplicitlyConstructible\n@@ -263,0 +260,1 @@\n+    @Strict\n@@ -265,0 +263,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/NullMarkersTest.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -105,0 +104,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -130,1 +130,0 @@\n-    @ImplicitlyConstructible\n@@ -156,0 +155,1 @@\n+        @Strict\n@@ -172,0 +172,1 @@\n+        @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/TestLayoutFlags.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -69,0 +68,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -94,1 +94,0 @@\n-  @ImplicitlyConstructible\n@@ -101,0 +100,1 @@\n+    @Strict\n@@ -126,1 +126,0 @@\n-  @ImplicitlyConstructible\n@@ -128,0 +127,1 @@\n+    @Strict\n@@ -153,1 +153,0 @@\n-  @ImplicitlyConstructible\n@@ -156,0 +155,1 @@\n+    @Strict\n@@ -174,1 +174,0 @@\n-  @ImplicitlyConstructible\n@@ -182,0 +181,1 @@\n+    @Strict\n@@ -203,1 +203,0 @@\n-  @ImplicitlyConstructible\n@@ -205,0 +204,1 @@\n+    @Strict\n@@ -226,1 +226,0 @@\n-  @ImplicitlyConstructible\n@@ -229,0 +228,1 @@\n+    @Strict\n@@ -246,1 +246,0 @@\n-  @ImplicitlyConstructible\n@@ -252,0 +251,1 @@\n+    @Strict\n@@ -273,1 +273,0 @@\n-  @ImplicitlyConstructible\n@@ -275,0 +274,1 @@\n+    @Strict\n@@ -296,1 +296,0 @@\n-  @ImplicitlyConstructible\n@@ -299,0 +298,1 @@\n+    @Strict\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueCompositionTest.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -72,6 +72,0 @@\n-import org.w3c.dom.views.AbstractView;\n-\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueFieldInheritanceTest.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -37,0 +36,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -42,1 +42,0 @@\n-    @ImplicitlyConstructible\n@@ -53,0 +52,1 @@\n+        @Strict\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/ForceEarlyReturn\/ValueForceEarlyReturn.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,1 +40,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/GetClassFields\/ValueGetClassFields.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -38,0 +37,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -41,1 +41,0 @@\n-    @ImplicitlyConstructible\n@@ -50,1 +49,0 @@\n-    @ImplicitlyConstructible\n@@ -53,0 +51,1 @@\n+        @Strict\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/GetObjectHashCode\/ValueGetObjectHashCodeTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,1 +40,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/GetObjectMonitorUsage\/ValueGetObjectMonitorUsage.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,1 +40,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/GetObjectSize\/ValueGetObjectSize.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -42,1 +41,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/GetSetLocal\/ValueGetSetLocal.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -26,1 +25,0 @@\n-@ImplicitlyConstructible\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/Value.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -38,0 +37,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -44,1 +44,0 @@\n-    @ImplicitlyConstructible\n@@ -54,1 +53,0 @@\n-    @ImplicitlyConstructible\n@@ -56,1 +54,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -58,1 +56,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n","filename":"test\/jdk\/valhalla\/valuetypes\/ArrayElementVarHandleTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -45,0 +45,1 @@\n+import java.util.Objects;\n@@ -46,0 +47,1 @@\n+import java.util.function.Function;\n@@ -62,1 +64,12 @@\n-    @ImplicitlyConstructible\n+    @FunctionalInterface\n+    interface TriFunction<A, B, C, R> {\n+\n+        R apply(A a, B b, C c);\n+\n+        default <V> TriFunction<A, B, C, V> andThen(\n+                Function<? super R, ? extends V> after) {\n+            Objects.requireNonNull(after);\n+            return (A a, B b, C c) -> after.apply(apply(a, b, c));\n+        }\n+    }\n+\n@@ -75,0 +88,8 @@\n+\n+        static WeakPoint[] makePoints(int len, Object initval, TriFunction<Class<?>, Integer, Object, Object[]> arrayFactory) {\n+            WeakPoint[] array = (WeakPoint[])arrayFactory.apply(WeakPoint.class, len, initval);\n+            for (int i = 0; i < len; ++i) {\n+                array[i] = new WeakPoint(i, i);\n+            }\n+            return array;\n+        }\n@@ -80,0 +101,1 @@\n+        @Strict\n@@ -82,0 +104,1 @@\n+        @Strict\n@@ -86,1 +109,0 @@\n-    @ImplicitlyConstructible\n@@ -98,0 +120,8 @@\n+\n+        static StrongPoint[] makePoints(int len, Object initval, TriFunction<Class<?>, Integer, Object, Object[]> arrayFactory) {\n+            StrongPoint[] array = (StrongPoint[])arrayFactory.apply(StrongPoint.class, len, initval);\n+            for (int i = 0; i < len; ++i) {\n+                array[i] = new StrongPoint(i, i);\n+            }\n+            return array;\n+        }\n@@ -165,2 +195,2 @@\n-                WeakPoint.makePoints(10, ValueClass::newNullRestrictedArray),\n-                WeakPoint.makePoints(10, ValueClass::newNullRestrictedAtomicArray),\n+                WeakPoint.makePoints(10, new WeakPoint(0, 0), ValueClass::newNullRestrictedNonAtomicArray),\n+                WeakPoint.makePoints(10, new WeakPoint(0, 0), ValueClass::newNullRestrictedAtomicArray),\n@@ -169,2 +199,2 @@\n-                StrongPoint.makePoints(10, ValueClass::newNullRestrictedArray),\n-                StrongPoint.makePoints(10, ValueClass::newNullRestrictedAtomicArray),\n+                StrongPoint.makePoints(10, new StrongPoint(0, 0), ValueClass::newNullRestrictedNonAtomicArray),\n+                StrongPoint.makePoints(10, new StrongPoint(0, 0), ValueClass::newNullRestrictedAtomicArray),\n","filename":"test\/jdk\/valhalla\/valuetypes\/FlatVarHandleTest.java","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -36,0 +35,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -40,1 +40,0 @@\n-    @ImplicitlyConstructible\n@@ -52,1 +51,0 @@\n-    @ImplicitlyConstructible\n@@ -54,1 +52,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaMetaFactory\/LambdaTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -42,0 +42,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -49,1 +50,1 @@\n-    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n@@ -59,1 +60,1 @@\n-    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n@@ -61,1 +62,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -63,1 +64,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -73,1 +74,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -85,1 +86,0 @@\n-    @ImplicitlyConstructible\n@@ -165,1 +165,1 @@\n-                Arguments.of(Point[].class, newNullRestrictedArray(Point.class), P, true),\n+                Arguments.of(Point[].class, newNullRestrictedNonAtomicArray(Point.class, new Point(0, 0)), P, true),\n@@ -167,1 +167,1 @@\n-                Arguments.of(Line[].class, newNullRestrictedArray(Line.class), L, true),\n+                Arguments.of(Line[].class, newNullRestrictedNonAtomicArray(Line.class, new Line(0, 0, 0, 0)), L, true),\n@@ -177,2 +177,2 @@\n-    private static Object[] newNullRestrictedArray(Class<?> componentClass) throws Throwable {\n-        return ValueClass.newNullRestrictedArray(componentClass, ARRAY_SIZE);\n+    private static Object[] newNullRestrictedNonAtomicArray(Class<?> componentClass, Object initVal) throws Throwable {\n+        return ValueClass.newNullRestrictedNonAtomicArray(componentClass, ARRAY_SIZE, initVal);\n@@ -192,1 +192,1 @@\n-                assertTrue(v == ValueClass.zeroInstance(componentType));\n+                assertTrue(v != null);\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -47,1 +46,0 @@\n-    @ImplicitlyConstructible\n@@ -54,1 +52,0 @@\n-        @ImplicitlyConstructible\n","filename":"test\/jdk\/valhalla\/valuetypes\/Nest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -47,0 +46,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -59,1 +59,0 @@\n-    @ImplicitlyConstructible\n@@ -77,0 +76,1 @@\n+        @Strict\n@@ -78,1 +78,1 @@\n-        Value value;\n+        Value value = new Value();\n@@ -82,0 +82,1 @@\n+        Value v = new Value();\n@@ -83,3 +84,3 @@\n-                Arguments.of(T.class.getDeclaredField(\"s\"), String.class, false),\n-                Arguments.of(T.class.getDeclaredField(\"obj\"), Value.class, false),\n-                Arguments.of(T.class.getDeclaredField(\"value\"), Value.class, true)\n+                Arguments.of(T.class.getDeclaredField(\"s\"), String.class, \"\", false),\n+                Arguments.of(T.class.getDeclaredField(\"obj\"), Value.class, null, false),\n+                Arguments.of(T.class.getDeclaredField(\"value\"), Value.class, v, true)\n@@ -94,1 +95,2 @@\n-    public void testCheckedTypeArrays(Field field, Class<?> type, boolean nullRestricted) throws ReflectiveOperationException {\n+    public void testCheckedTypeArrays(Field field, Class<?> type, Object initValue,\n+                                      boolean nullRestricted) throws ReflectiveOperationException {\n@@ -98,1 +100,1 @@\n-        Object[] array = ValueClass.newArrayInstance(checkedType, 4);\n+        Object[] array = ValueClass.newArrayInstance(checkedType, 4, initValue);\n@@ -119,1 +121,1 @@\n-        Object[] nullRestrictedArray = ValueClass.newNullRestrictedArray(Value.class, len);\n+        Object[] nullRestrictedArray = ValueClass.newNullRestrictedNonAtomicArray(Value.class, len, new Value());\n@@ -125,1 +127,2 @@\n-        testCopyOfRange(array, nullRestrictedArray, 1, len+2);\n+        \/\/ Cannot extend a null-restricted array without providing a value to fill the new elements\n+        \/\/ testCopyOfRange(array, nullRestrictedArray, 1, len+2);\n@@ -145,2 +148,1 @@\n-        Object[] newArray2 = Arrays.copyOfRange(nullRestrictedArray, from, to);\n-        System.out.println(\"newArray2 \" + newArray2.length + \" \" + Arrays.toString(newArray2));\n+\n@@ -151,2 +153,0 @@\n-        \/\/ NPE thrown if elements in a null-restricted array set to null\n-        assertThrows(NullPointerException.class, () -> newArray2[0] = null);\n@@ -162,6 +162,9 @@\n-        Class<?> componentType = nullRestrictedArray.getClass().getComponentType();\n-        for (int i=0; i < newArray2.length; i++) {\n-            if (from+1 >= nullRestrictedArray.length) {\n-                \/\/ padded with zero instance\n-                assertTrue(newArray2[i] == ValueClass.zeroInstance(componentType));\n-            }\n+\n+        if (to > array.length) {\n+            \/\/ NullRestricted arrays do not have a value to fill new array elements\n+            assertThrows(IllegalArgumentException.class, () -> Arrays.copyOfRange(nullRestrictedArray, from, to));\n+        } else {\n+            Object[] newArray2 = Arrays.copyOfRange(nullRestrictedArray, from, to);\n+            System.out.println(\"newArray2 \" + newArray2.length + \" \" + Arrays.toString(newArray2));\n+            \/\/ NPE thrown if elements in a null-restricted array set to null\n+            assertThrows(NullPointerException.class, () -> newArray2[0] = null);\n@@ -175,1 +178,1 @@\n-        Object[] nullRestrictedArray = ValueClass.newNullRestrictedArray(Value.class, len);\n+        Object[] nullRestrictedArray = ValueClass.newNullRestrictedNonAtomicArray(Value.class, len, new Value());\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedArraysTest.java","additions":25,"deletions":22,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -41,0 +40,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -49,1 +49,0 @@\n-    @ImplicitlyConstructible\n@@ -56,1 +55,0 @@\n-    @ImplicitlyConstructible\n@@ -59,1 +57,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -65,0 +63,4 @@\n+        Value(EmptyValue empty) {\n+            this.o = null;\n+            this.empty = empty;\n+        }\n@@ -69,4 +71,4 @@\n-        @NullRestricted\n-        EmptyValue empty;\n-        @NullRestricted\n-        volatile EmptyValue vempty;\n+        @NullRestricted  @Strict\n+        EmptyValue empty = new EmptyValue();\n+        @NullRestricted  @Strict\n+        volatile EmptyValue vempty = new EmptyValue();\n@@ -83,4 +85,3 @@\n-    public void lazyInitializedDefaultValue() {\n-        \/\/ VM lazily sets the null-restricted non-flat field to zero default\n-        assertTrue(new Value() == ValueClass.zeroInstance(Value.class));\n-        assertTrue(new Value().empty == ValueClass.zeroInstance(EmptyValue.class));\n+    public void testNonNullFieldAssignment() {\n+        var npe = assertThrows(NullPointerException.class, () -> new Value(null));\n+        System.err.println(npe);    \/\/ log the exception message\n@@ -91,1 +92,1 @@\n-        EmptyValue emptyValue = ValueClass.zeroInstance(EmptyValue.class);\n+        EmptyValue emptyValue = new EmptyValue();\n@@ -121,1 +122,1 @@\n-        EmptyValue emptyValue = ValueClass.zeroInstance(EmptyValue.class);\n+        EmptyValue emptyValue = new EmptyValue();\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedTest.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -39,0 +38,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -47,1 +47,0 @@\n-    @ImplicitlyConstructible\n@@ -57,1 +56,0 @@\n-    @ImplicitlyConstructible\n@@ -59,1 +57,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -61,1 +59,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -71,1 +69,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -80,1 +78,0 @@\n-    @ImplicitlyConstructible\n@@ -82,1 +79,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -84,1 +81,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -96,1 +93,0 @@\n-    @ImplicitlyConstructible\n@@ -173,2 +169,0 @@\n-                Arguments.of(ValueClass.zeroInstance(Line.class), new Line(0, 0, 0, 0), true),\n-                Arguments.of(ValueClass.zeroInstance(Value.class), ValueClass.zeroInstance(Value.class), true),\n@@ -193,1 +187,0 @@\n-                Arguments.of(ValueClass.zeroInstance(Value.class)),\n@@ -196,1 +189,0 @@\n-                Arguments.of(ValueClass.zeroInstance(ValueOptional.class)),\n@@ -214,1 +206,0 @@\n-\n@@ -216,3 +207,2 @@\n-        Point p = ValueClass.zeroInstance(Point.class);\n-        Line l = ValueClass.zeroInstance(Line.class);\n-        Value v = ValueClass.zeroInstance(Value.class);\n+        Point p = new Point(0, 0);\n+        Line l = new Line(0, 0, 0, 0);\n@@ -226,1 +216,0 @@\n-                Arguments.of(v, hash(Value.class, p, l, null, null)),\n@@ -267,1 +256,0 @@\n-    @ImplicitlyConstructible\n@@ -278,1 +266,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":9,"deletions":22,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectNewInstance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -46,1 +45,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/jdk\/valhalla\/valuetypes\/ProxyTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -54,1 +52,0 @@\n-    @ImplicitlyConstructible\n@@ -65,1 +62,0 @@\n-    @ImplicitlyConstructible\n@@ -75,1 +71,0 @@\n-    @ImplicitlyConstructible\n@@ -83,1 +78,0 @@\n-    @ImplicitlyConstructible\n@@ -93,1 +87,0 @@\n-    @ImplicitlyConstructible\n@@ -103,1 +96,0 @@\n-    @ImplicitlyConstructible\n@@ -111,1 +103,0 @@\n-    @ImplicitlyConstructible\n@@ -119,1 +110,0 @@\n-    @ImplicitlyConstructible\n@@ -127,1 +117,0 @@\n-    @ImplicitlyConstructible\n@@ -136,1 +125,1 @@\n-        var n1 = ValueClass.zeroInstance(Node.class);\n+        var n1 = new Node(null, null);\n@@ -140,1 +129,1 @@\n-        var v1 = ValueClass.zeroInstance(V.class);\n+        var v1 = new V(null);\n@@ -147,1 +136,1 @@\n-        var e1 = new E(ValueClass.zeroInstance(F.class));\n+        var e1 = new E(new F(null));\n@@ -152,1 +141,1 @@\n-        var a = new A(ValueClass.zeroInstance(B.class), ValueClass.zeroInstance(E.class));\n+        var a = new A(new B(null, null), new E(null));\n@@ -205,1 +194,1 @@\n-        var n1 = ValueClass.zeroInstance(Node.class);\n+        var n1 = new Node(null, null);\n@@ -212,1 +201,1 @@\n-        var e1 = new E(ValueClass.zeroInstance(F.class));\n+        var e1 = new E(new F(null));\n@@ -217,1 +206,1 @@\n-        var a = new A(ValueClass.zeroInstance(B.class), ValueClass.zeroInstance(E.class));\n+        var a = new A(new B(null, null), new E(null));\n@@ -261,1 +250,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -43,0 +43,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -50,1 +51,1 @@\n-    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n@@ -58,1 +59,1 @@\n-    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n@@ -60,1 +61,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -107,1 +108,1 @@\n-        V[] varrayNR = (V[]) ValueClass.newNullRestrictedArray(V.class, 3);\n+        V[] varrayNR = (V[]) ValueClass.newNullRestrictedAtomicArray(V.class, 3, new V(0));\n@@ -109,1 +110,1 @@\n-        Value[] valuearrayNR = (Value[]) ValueClass.newNullRestrictedArray(Value.class, 3);\n+        Value[] valuearrayNR = (Value[]) ValueClass.newNullRestrictedNonAtomicArray(Value.class, 3, new Value(new V(0), new V(0)));\n@@ -136,1 +137,1 @@\n-                assertTrue(o == ValueClass.zeroInstance(componentType));\n+                assertTrue(o != null);\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -33,0 +32,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -53,1 +53,0 @@\n-    @ImplicitlyConstructible\n@@ -63,1 +62,0 @@\n-    @ImplicitlyConstructible\n@@ -66,1 +64,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n","filename":"test\/jdk\/valhalla\/valuetypes\/StreamTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -39,0 +38,1 @@\n+import jdk.internal.vm.annotation.Strict;\n@@ -48,1 +48,0 @@\n-    @ImplicitlyConstructible\n@@ -58,1 +57,0 @@\n-    @ImplicitlyConstructible\n@@ -60,1 +58,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -62,1 +60,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -75,1 +73,0 @@\n-    @ImplicitlyConstructible\n@@ -78,1 +75,1 @@\n-        @NullRestricted\n+        @NullRestricted  @Strict\n@@ -86,1 +83,0 @@\n-    @ImplicitlyConstructible\n@@ -95,1 +91,0 @@\n-    @ImplicitlyConstructible\n@@ -108,1 +103,0 @@\n-    @ImplicitlyConstructible\n@@ -125,1 +119,1 @@\n-        MyValue v1 = new MyValue(null, ValueClass.zeroInstance(MyValue2.class));\n+        MyValue v1 = new MyValue(null, new MyValue2(0));\n@@ -138,1 +132,0 @@\n-                Arguments.of(v1, ValueClass.zeroInstance(MyValue.class)),\n@@ -151,3 +144,0 @@\n-        \/\/ MyValue![] va = new MyValue![1];\n-        MyValue[] va = new MyValue[] { ValueClass.zeroInstance(MyValue.class) };\n-        Object[] oa = new Object[] { va };\n@@ -165,5 +155,0 @@\n-                Arguments.of(va[0], null),\n-                Arguments.of(null, va[0]),\n-                Arguments.of(va[0], oa),\n-                Arguments.of(va[0], oa[0]),\n-                Arguments.of(va, oa),\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/valhalla\/valuetypes\/UseValueClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueConstantDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -39,1 +38,0 @@\n-    @ImplicitlyConstructible\n","filename":"test\/jdk\/valhalla\/valuetypes\/WeakReferenceTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}