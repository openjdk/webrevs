{"files":[{"patch":"@@ -1858,0 +1858,5 @@\n+void MacroAssembler::test_field_has_null_marker(Register flags, Register temp_reg, Label& has_null_marker) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ResolvedFieldEntry::has_null_marker_shift, has_null_marker);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -652,0 +652,1 @@\n+  void test_field_has_null_marker(Register flags, Register temp_reg, Label& has_null_marker);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  case Bytecodes::_fast_qputfield:\n+  case Bytecodes::_fast_vputfield:\n@@ -2820,1 +2820,1 @@\n-      Label is_flat, nonnull, is_inline_type, rewrite_inline;\n+      Label is_flat, nonnull, is_inline_type, has_null_marker, rewrite_inline;\n@@ -2822,0 +2822,1 @@\n+      __ test_field_has_null_marker(flags, noreg \/*temp*\/, has_null_marker);\n@@ -2846,0 +2847,5 @@\n+          __ b(rewrite_inline);\n+        __ bind(has_null_marker);\n+          call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), obj, cache);\n+          __ verify_oop(r0);\n+          __ push(atos);\n@@ -2848,1 +2854,1 @@\n-        patch_bytecode(Bytecodes::_fast_qgetfield, bc, r1);\n+        patch_bytecode(Bytecodes::_fast_vgetfield, bc, r1);\n@@ -3092,1 +3098,1 @@\n-        Label is_inline_type, is_flat, rewrite_not_inline, rewrite_inline;\n+        Label is_inline_type, is_flat, has_null_marker, rewrite_not_inline, rewrite_inline;\n@@ -3094,0 +3100,1 @@\n+        __ test_field_has_null_marker(flags, noreg \/*temp*\/, has_null_marker);\n@@ -3120,0 +3127,5 @@\n+        __ b(rewrite_inline);\n+        __ bind(has_null_marker);\n+        assert_different_registers(r0, cache, r19);\n+        pop_and_check_object(r19);\n+        __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), r19, r0, cache);\n@@ -3122,1 +3134,1 @@\n-          patch_bytecode(Bytecodes::_fast_qputfield, bc, r19, true, byte_no);\n+          patch_bytecode(Bytecodes::_fast_vputfield, bc, r19, true, byte_no);\n@@ -3265,1 +3277,1 @@\n-    case Bytecodes::_fast_qputfield: \/\/fall through\n+    case Bytecodes::_fast_vputfield: \/\/fall through\n@@ -3292,1 +3304,1 @@\n-    case Bytecodes::_fast_qputfield: \/\/fall through\n+    case Bytecodes::_fast_vputfield: \/\/fall through\n@@ -3343,1 +3355,1 @@\n-  case Bytecodes::_fast_qputfield: \/\/fall through\n+  case Bytecodes::_fast_vputfield:\n@@ -3345,1 +3357,2 @@\n-      Label is_flat, done;\n+      Label is_flat, has_null_marker, done;\n+      __ test_field_has_null_marker(r3, noreg \/* temp *\/, has_null_marker);\n@@ -3357,0 +3370,5 @@\n+      __ b(done);\n+      __ bind(has_null_marker);\n+      __ load_field_entry(r4, r1);\n+      __ mov(r1, r2);\n+      __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), r1, r0, r4);\n@@ -3455,1 +3473,1 @@\n-  case Bytecodes::_fast_qgetfield:\n+  case Bytecodes::_fast_vgetfield:\n@@ -3458,1 +3476,2 @@\n-      Label is_flat, nonnull, Done;\n+      Label is_flat, has_null_marker, nonnull, Done;\n+      __ test_field_has_null_marker(r3, noreg \/*temp*\/, has_null_marker);\n@@ -3476,0 +3495,4 @@\n+        __ b(Done);\n+      __ bind(has_null_marker);\n+        call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), r0, r2);\n+        __ verify_oop(r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":34,"deletions":11,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -3021,0 +3021,6 @@\n+void MacroAssembler::test_field_has_null_marker(Register flags, Register temp_reg, Label& has_null_marker) {\n+  movl(temp_reg, flags);\n+  testl(temp_reg, 1 << ResolvedFieldEntry::has_null_marker_shift);\n+  jcc(Assembler::notEqual, has_null_marker);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  void test_field_has_null_marker(Register flags, Register temp_reg, Label& has_null_marker);\n@@ -419,1 +420,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-  case Bytecodes::_fast_qputfield:\n+  case Bytecodes::_fast_vputfield:\n@@ -3197,1 +3197,1 @@\n-      Label is_flat, nonnull, is_inline_type, rewrite_inline;\n+      Label is_flat, nonnull, is_inline_type, rewrite_inline, has_null_marker;\n@@ -3199,0 +3199,1 @@\n+      __ test_field_has_null_marker(flags, rscratch1, has_null_marker);\n@@ -3224,1 +3225,1 @@\n-          __ load_unsigned_short(flags, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+          __ load_unsigned_short(rdx, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n@@ -3226,1 +3227,1 @@\n-          __ read_flat_field(rcx, flags, rbx, rax);\n+          __ read_flat_field(rcx, rdx, rbx, rax);\n@@ -3229,0 +3230,7 @@\n+          __ jmp(rewrite_inline);\n+      __ bind(has_null_marker);\n+        pop_and_check_object(rax);\n+        __ load_field_entry(rcx, rbx);\n+        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), rax, rcx);\n+        __ get_vm_result(rax, r15_thread);\n+        __ push(atos);\n@@ -3231,1 +3239,1 @@\n-        patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);\n+        patch_bytecode(Bytecodes::_fast_vgetfield, bc, rbx);\n@@ -3518,11 +3526,13 @@\n-        Label is_inline_type, is_flat, rewrite_not_inline, rewrite_inline;\n-        __ test_field_is_null_free_inline_type(flags, rscratch1, is_inline_type);\n-        \/\/ Not an inline type\n-        pop_and_check_object(obj);\n-        \/\/ Store into the field\n-        do_oop_store(_masm, field, rax);\n-        __ bind(rewrite_not_inline);\n-        if (rc == may_rewrite) {\n-          patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n-        }\n-        __ jmp(Done);\n+        Label is_null_free_inline_type, is_flat, has_null_marker,\n+              write_null, rewrite_not_inline, rewrite_inline;\n+        __ test_field_is_null_free_inline_type(flags, rscratch1, is_null_free_inline_type);\n+        __ test_field_has_null_marker(flags, rscratch1, has_null_marker);\n+          \/\/ Not an inline type\n+          pop_and_check_object(obj);\n+          \/\/ Store into the field\n+          do_oop_store(_masm, field, rax);\n+          __ bind(rewrite_not_inline);\n+          if (rc == may_rewrite) {\n+            patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);\n+          }\n+          __ jmp(Done);\n@@ -3530,16 +3540,21 @@\n-        __ bind(is_inline_type);\n-        __ null_check(rax);\n-        __ test_field_is_flat(flags, rscratch1, is_flat);\n-        \/\/ field is not flat\n-        pop_and_check_object(obj);\n-        \/\/ Store into the field\n-        do_oop_store(_masm, field, rax);\n-        __ jmp(rewrite_inline);\n-        __ bind(is_flat);\n-        \/\/ field is flat\n-        pop_and_check_object(obj);\n-        assert_different_registers(rax, rdx, obj, off);\n-        __ load_klass(rdx, rax, rscratch1);\n-        __ data_for_oop(rax, rax, rdx);\n-        __ addptr(obj, off);\n-        __ access_value_copy(IN_HEAP, rax, obj, rdx);\n+        __ bind(is_null_free_inline_type);\n+          __ null_check(rax);\n+          __ test_field_is_flat(flags, rscratch1, is_flat);\n+            \/\/ field is not flat\n+            pop_and_check_object(obj);\n+            \/\/ Store into the field\n+            do_oop_store(_masm, field, rax);\n+          __ jmp(rewrite_inline);\n+          __ bind(is_flat);\n+            \/\/ field is flat\n+            pop_and_check_object(obj);\n+            assert_different_registers(rax, rdx, obj, off);\n+            __ load_klass(rdx, rax, rscratch1);\n+            __ data_for_oop(rax, rax, rdx);\n+            __ addptr(obj, off);\n+            __ access_value_copy(IN_HEAP, rax, obj, rdx);\n+            __ jmp(rewrite_inline);\n+        __ bind(has_null_marker); \/\/ has null marker means the field is flat with a null marker\n+          pop_and_check_object(rbx);\n+          __ load_field_entry(rcx, rdx);\n+          call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), rbx, rax, rcx);\n@@ -3548,1 +3563,1 @@\n-          patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);\n+          patch_bytecode(Bytecodes::_fast_vputfield, bc, rbx, true, byte_no);\n@@ -3691,1 +3706,1 @@\n-    case Bytecodes::_fast_qputfield: \/\/fall through\n+    case Bytecodes::_fast_vputfield: \/\/fall through\n@@ -3717,1 +3732,1 @@\n-    case Bytecodes::_fast_qputfield: \/\/ fall through\n+    case Bytecodes::_fast_vputfield: \/\/ fall through\n@@ -3736,2 +3751,0 @@\n-  Register cache = rcx;\n-\n@@ -3744,1 +3757,1 @@\n-  load_resolved_field_entry(noreg, cache, rax, rbx, rdx);\n+  load_resolved_field_entry(noreg, rcx, rax, rbx, rdx);\n@@ -3773,0 +3786,2 @@\n+  \/\/ DANGER: 'field' argument depends on rcx and rbx\n+\n@@ -3775,1 +3790,1 @@\n-  case Bytecodes::_fast_qputfield:\n+  case Bytecodes::_fast_vputfield:\n@@ -3777,1 +3792,3 @@\n-      Label is_flat, done;\n+      Label is_flat, has_null_marker, write_null, done;\n+      __ test_field_has_null_marker(flags, rscratch1, has_null_marker);\n+      \/\/ Null free field cases: flat or not flat\n@@ -3780,3 +3797,3 @@\n-      \/\/ field is not flat\n-      do_oop_store(_masm, field, rax);\n-      __ jmp(done);\n+        \/\/ field is not flat\n+        do_oop_store(_masm, field, rax);\n+        __ jmp(done);\n@@ -3784,5 +3801,10 @@\n-      \/\/ field is flat\n-      __ load_klass(rdx, rax, rscratch1);\n-      __ data_for_oop(rax, rax, rdx);\n-      __ lea(rcx, field);\n-      __ access_value_copy(IN_HEAP, rax, rcx, rdx);\n+        \/\/ field is flat\n+        __ load_klass(rdx, rax, rscratch1);\n+        __ data_for_oop(rax, rax, rdx);\n+        __ lea(rcx, field);\n+        __ access_value_copy(IN_HEAP, rax, rcx, rdx);\n+        __ jmp(done);\n+      __ bind(has_null_marker); \/\/ has null marker means the field is flat with a null marker\n+        __ movptr(rbx, rcx);\n+        __ load_field_entry(rcx, rdx);\n+        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::write_nullable_flat_field), rbx, rax, rcx);\n@@ -3866,1 +3888,1 @@\n-  case Bytecodes::_fast_qgetfield:\n+  case Bytecodes::_fast_vgetfield:\n@@ -3868,1 +3890,1 @@\n-      Label is_flat, nonnull, Done;\n+      Label is_flat, nonnull, Done, has_null_marker;\n@@ -3870,0 +3892,1 @@\n+      __ test_field_has_null_marker(rscratch1, rscratch2, has_null_marker);\n@@ -3889,0 +3912,5 @@\n+        __ jmp(Done);\n+      __ bind(has_null_marker);\n+        \/\/ rax = instance, rcx = resolved entry\n+        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_nullable_flat_field), rax, rcx);\n+        __ get_vm_result(rax, r15_thread);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":78,"deletions":50,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -4112,0 +4112,1 @@\n+  this_klass->set_null_marker_offsets_array(_null_marker_offsets);\n@@ -5734,1 +5735,2 @@\n-    vk->set_exact_size_in_bytes(_exact_size_in_bytes);\n+    vk->set_payload_size_in_bytes(_payload_size_in_bytes);\n+    vk->set_internal_null_marker_offset(_internal_null_marker_offset);\n@@ -5845,0 +5847,1 @@\n+  _null_marker_offsets(nullptr),\n@@ -5937,0 +5940,1 @@\n+  _null_marker_offsets = nullptr;\n@@ -5959,0 +5963,4 @@\n+  if (_null_marker_offsets != nullptr) {\n+     MetadataFactory::free_array<int>(_loader_data, _null_marker_offsets);\n+  }\n+\n@@ -6485,0 +6493,1 @@\n+          assert(klass->is_instance_klass(), \"Sanity check\");\n@@ -6537,1 +6546,1 @@\n-  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n+  FieldLayoutBuilder lb(class_name(), loader_data(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n@@ -6540,1 +6549,1 @@\n-  lb.build_layout(CHECK);\n+  lb.build_layout();\n@@ -6544,1 +6553,2 @@\n-    _exact_size_in_bytes = lb.get_exact_size_in_byte();\n+    _payload_size_in_bytes = lb.get_payload_size_in_byte();\n+    _internal_null_marker_offset = lb.get_internal_null_marker_offset();\n@@ -6552,0 +6562,1 @@\n+\n@@ -6555,0 +6566,11 @@\n+  if (_field_info->_has_null_marker_offsets) {\n+    int idx = 0;\n+    _null_marker_offsets = MetadataFactory::new_array<int>(_loader_data, _temp_field_info->length(), 0, CHECK);\n+    for (GrowableArrayIterator<FieldInfo> it = _temp_field_info->begin(); it != _temp_field_info->end(); ++it, ++idx) {\n+      FieldInfo fieldinfo = *it;\n+      if (fieldinfo.field_flags().has_null_marker()) {\n+        assert(fieldinfo.null_marker_offset() != 0, \"Invalid value\");\n+        _null_marker_offsets->at_put(idx, fieldinfo.null_marker_offset());\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  bool  _has_nonstatic_fields;\n-  bool  _is_naturally_atomic;\n+  bool _has_nonstatic_fields;\n+  bool _is_naturally_atomic;\n@@ -80,0 +80,1 @@\n+  bool _has_null_marker_offsets;\n@@ -151,0 +152,1 @@\n+  Array<int>* _null_marker_offsets;\n@@ -166,1 +168,2 @@\n-  int _exact_size_in_bytes;\n+  int _payload_size_in_bytes;\n+  int _internal_null_marker_offset;\n@@ -207,0 +210,1 @@\n+  bool _has_null_marker_offsets;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,2 +49,4 @@\n-  _is_reference(false) {\n-  assert(kind == EMPTY || kind == RESERVED || kind == PADDING || kind == INHERITED,\n+  _null_marker_offset(-1),\n+  _is_reference(false),\n+  _needs_null_marker(false) {\n+  assert(kind == EMPTY || kind == RESERVED || kind == PADDING || kind == INHERITED || kind == NULL_MARKER,\n@@ -65,2 +67,4 @@\n- _is_reference(is_reference) {\n-  assert(kind == REGULAR || kind == FLAT || kind == INHERITED,\n+ _null_marker_offset(-1),\n+ _is_reference(is_reference),\n+ _needs_null_marker(false) {\n+  assert(kind == REGULAR || kind == FLAT || kind == INHERITED || kind == INHERITED_NULL_MARKER,\n@@ -108,2 +112,2 @@\n-void FieldGroup::add_flat_field(int idx, InlineKlass* vk) {\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+void FieldGroup::add_flat_field(int idx, InlineKlass* vk, bool needs_null_marker) {\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_payload_size_in_bytes(), vk->get_alignment(), false);\n@@ -111,0 +115,1 @@\n+  if (needs_null_marker) block->set_needs_null_marker();\n@@ -146,1 +151,2 @@\n-  _last(_blocks) {}\n+  _last(_blocks),\n+  _has_missing_null_markers(false) {}\n@@ -324,0 +330,3 @@\n+  if (block->needs_null_marker()) {\n+    _has_missing_null_markers = true;\n+  }\n@@ -327,1 +336,5 @@\n-  _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+  \/\/ NULL_MARKER blocks have a field index pointing to the field that needs a null marker,\n+  \/\/ so the field_info at this index must not be updated with the null marker's offset\n+  if (block->kind() != LayoutRawBlock::NULL_MARKER) {\n+    _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+  }\n@@ -341,1 +354,1 @@\n-      if (fs.field_flags().is_null_free_inline_type()) {\n+      if (fs.is_flat()) {\n@@ -343,1 +356,1 @@\n-        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, vk->get_exact_size_in_bytes(),\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, vk->get_payload_size_in_bytes(),\n@@ -345,1 +358,7 @@\n-\n+        if (!fs.field_flags().is_null_free_inline_type()) {\n+          assert(fs.field_flags().has_null_marker(), \"Nullable flat fields must have a null marker\");\n+          LayoutRawBlock* marker = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED_NULL_MARKER, 1 \/* current NULL_MARKER block are one byte *\/,\n+                                    1, false);\n+          marker->set_offset(fs.null_marker_offset());\n+          all_fields->append(marker);\n+        }\n@@ -443,0 +462,3 @@\n+  if (_start == slot) {\n+    _start = block;\n+  }\n@@ -464,1 +486,1 @@\n-void FieldLayout::print(outputStream* output, bool is_static, const InstanceKlass* super) {\n+void FieldLayout::print(outputStream* output, bool is_static, const InstanceKlass* super, Array<InlineKlass*>* inline_fields) {\n@@ -471,1 +493,1 @@\n-        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+        output->print_cr(\" @%d %s %d\/%d \\\"%s\\\" %s\",\n@@ -473,2 +495,1 @@\n-                         fi->name(_cp)->as_C_string(),\n-                         fi->signature(_cp)->as_C_string(),\n+                         \"REGULAR\",\n@@ -477,1 +498,2 @@\n-                         \"REGULAR\");\n+                         fi->name(_cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string());\n@@ -482,1 +504,3 @@\n-        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+        InlineKlass* ik = inline_fields->at(fi->index());\n+        assert(ik != nullptr, \"\");\n+        output->print(\" @%d %s %d\/%d \\\"%s\\\" %s %s@%p\",\n@@ -484,2 +508,1 @@\n-                         fi->name(_cp)->as_C_string(),\n-                         fi->signature(_cp)->as_C_string(),\n+                         \"FLAT\",\n@@ -488,1 +511,10 @@\n-                         \"FLAT\");\n+                         fi->name(_cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string(),\n+                         ik->name()->as_C_string(),\n+                         ik->class_loader_data());\n+        if (fi->field_flags().has_null_marker()) {\n+          output->print_cr(\" null marker offset %d %s\", fi->null_marker_offset(),\n+                           fi->field_flags().is_null_marker_internal() ? \"(internal)\" : \"\");\n+        } else {\n+          output->print_cr(\"\");\n+        }\n@@ -492,1 +524,1 @@\n-        output->print_cr(\" @%d %d\/- %s\",\n+        output->print_cr(\" @%d %s %d\/-\",\n@@ -494,2 +526,2 @@\n-                         b->size(),\n-                         \"RESERVED\");\n+                         \"RESERVED\",\n+                         b->size());\n@@ -505,2 +537,2 @@\n-            if (fs.offset() == b->offset()) {\n-              output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+            if (fs.offset() == b->offset() && fs.access_flags().is_static() == is_static) {\n+              output->print_cr(\" @%d %s %d\/%d \\\"%s\\\" %s\",\n@@ -508,2 +540,1 @@\n-                  fs.name()->as_C_string(),\n-                  fs.signature()->as_C_string(),\n+                  \"INHERITED\",\n@@ -511,2 +542,3 @@\n-                  b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla\n-                  \"INHERITED\");\n+                  b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla => FIXME\n+                  fs.name()->as_C_string(),\n+                  fs.signature()->as_C_string());\n@@ -521,0 +553,6 @@\n+    case LayoutRawBlock::INHERITED_NULL_MARKER :\n+      output->print_cr(\" @%d %s %d\/1\",\n+                       b->offset(),\n+                      \"INHERITED_NULL_MARKER\",\n+                       b->size());\n+      break;\n@@ -522,1 +560,1 @@\n-      output->print_cr(\" @%d %d\/1 %s\",\n+      output->print_cr(\" @%d %s %d\/1\",\n@@ -524,2 +562,2 @@\n-                       b->size(),\n-                       \"EMPTY\");\n+                      \"EMPTY\",\n+                       b->size());\n@@ -528,4 +566,13 @@\n-      output->print_cr(\" @%d %d\/1 %s\",\n-                       b->offset(),\n-                       b->size(),\n-                       \"PADDING\");\n+      output->print_cr(\" @%d %s %d\/1\",\n+                      b->offset(),\n+                      \"PADDING\",\n+                      b->size());\n+      break;\n+    case LayoutRawBlock::NULL_MARKER:\n+    {\n+      FieldInfo* fi = _field_info->adr_at(b->field_index());\n+      output->print_cr(\" @%d %s %d\/1 null marker for field at offset %d\",\n+                      b->offset(),\n+                      \"NULL_MARKER\",\n+                      b->size(),\n+                      fi->offset());\n@@ -534,0 +581,3 @@\n+    default:\n+      fatal(\"Unknown block type\");\n+    }\n@@ -538,1 +588,1 @@\n-FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,\n+FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, ClassLoaderData* loader_data, const InstanceKlass* super_klass, ConstantPool* constant_pool,\n@@ -542,0 +592,1 @@\n+  _loader_data(loader_data),\n@@ -555,1 +606,2 @@\n-  _exact_size_in_bytes(-1),\n+  _internal_null_marker_offset(-1),\n+  _payload_size_in_bytes(-1),\n@@ -564,2 +616,2 @@\n-  _nullable_atomic_flat_candidate(false)\n- {}\n+  _nullable_atomic_flat_candidate(false),\n+  _has_null_markers(false) {}\n@@ -598,1 +650,1 @@\n-void FieldLayoutBuilder::regular_field_sorting(TRAPS) {\n+void FieldLayoutBuilder::regular_field_sorting() {\n@@ -601,1 +653,0 @@\n-    FieldInfo ctrl = _field_info->at(0);\n@@ -636,1 +687,6 @@\n-      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+    {\n+      bool field_is_known_value_class =  !fieldinfo.field_flags().is_injected() && _inline_type_field_klasses != nullptr && _inline_type_field_klasses->at(fieldinfo.index()) != nullptr;\n+      bool value_has_oops = field_is_known_value_class ? _inline_type_field_klasses->at(fieldinfo.index())->nonstatic_oop_count() > 0 : true;\n+      bool is_candidate_for_flattening = fieldinfo.field_flags().is_null_free_inline_type() || (EnableNullableFieldFlattening && field_is_known_value_class && !value_has_oops);\n+      \/\/ if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+      if (!is_candidate_for_flattening) {\n@@ -652,1 +708,1 @@\n-          assert(vk->is_implicitly_constructible(), \"must be, should have been checked in post_process_parsed_stream()\");\n+          assert(!fieldinfo.field_flags().is_null_free_inline_type() || vk->is_implicitly_constructible(), \"must be, should have been checked in post_process_parsed_stream()\");\n@@ -667,1 +723,1 @@\n-            group->add_flat_field(idx, vk);\n+            group->add_flat_field(idx, vk, !fieldinfo.field_flags().is_null_free_inline_type());\n@@ -674,0 +730,1 @@\n+            if (!fieldinfo.field_flags().is_null_free_inline_type()) _has_null_markers = true;\n@@ -681,0 +738,1 @@\n+    }\n@@ -705,1 +763,1 @@\n-void FieldLayoutBuilder::inline_class_field_sorting(TRAPS) {\n+void FieldLayoutBuilder::inline_class_field_sorting() {\n@@ -737,1 +795,6 @@\n-      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+    {\n+      bool field_is_known_value_class =  !fieldinfo.field_flags().is_injected() && _inline_type_field_klasses != nullptr && _inline_type_field_klasses->at(fieldinfo.index()) != nullptr;\n+      bool value_has_oops = field_is_known_value_class ? _inline_type_field_klasses->at(fieldinfo.index())->nonstatic_oop_count() > 0 : true;\n+      bool is_candidate_for_flattening = fieldinfo.field_flags().is_null_free_inline_type() || (EnableNullableFieldFlattening && field_is_known_value_class && !value_has_oops);\n+      \/\/ if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+      if (!is_candidate_for_flattening) {\n@@ -770,1 +833,1 @@\n-            group->add_flat_field(fieldinfo.index(), vk);\n+            group->add_flat_field(fieldinfo.index(), vk, !fieldinfo.field_flags().is_null_free_inline_type());\n@@ -778,0 +841,1 @@\n+            if (!fieldinfo.field_flags().is_null_free_inline_type()) _has_null_markers = true;\n@@ -786,0 +850,1 @@\n+    }\n@@ -792,7 +857,1 @@\n-  if (!_has_nonstatic_fields) {\n-    \/\/ There are a number of fixes required throughout the type system and JIT\n-    Exceptions::fthrow(THREAD_AND_LOCATION,\n-                       vmSymbols::java_lang_ClassFormatError(),\n-                       \"Value Types do not support zero instance size yet\");\n-    return;\n-  }\n+  assert(_has_nonstatic_fields, \"Empty value instances should have an injected field to have a non-zero size\");\n@@ -815,1 +874,1 @@\n-void FieldLayoutBuilder::compute_regular_layout(TRAPS) {\n+void FieldLayoutBuilder::compute_regular_layout() {\n@@ -818,1 +877,1 @@\n-  regular_field_sorting(CHECK);\n+  regular_field_sorting();\n@@ -845,0 +904,5 @@\n+\n+  if (EnableNullableFieldFlattening && _layout->has_missing_null_markers()) {\n+    insert_null_markers();\n+  }\n+\n@@ -853,0 +917,33 @@\n+void FieldLayoutBuilder::insert_null_markers() {\n+  if (!EnableNullableFieldFlattening || !_layout->has_missing_null_markers()) return;\n+  GrowableArray<LayoutRawBlock*>* list = new GrowableArray<LayoutRawBlock*>(10);\n+  for (LayoutRawBlock* block = _layout->first_field_block(); block != _layout->last_block(); block = block->next_block()) {\n+    if (block->needs_null_marker()) {\n+      assert(block->kind() == LayoutRawBlock::FLAT, \"Only flat fields might need null markers\");\n+      if (block->inline_klass()->has_internal_null_marker_offset()) {\n+        \/\/ The inline klass has an internal null marker slot, let's use it\n+        \/\/ The inline klass has the internal null marker offset from the begining of the object,\n+        \/\/ compute the offset relative to begining of payload\n+        int internal_null_marker_offset = block->inline_klass()->get_internal_null_marker_offset() - block->inline_klass()->first_field_offset();\n+        block->set_null_marker_offset(block->offset() + internal_null_marker_offset);\n+        _field_info->adr_at(block->field_index())->set_null_marker_offset(block->null_marker_offset());\n+        _field_info->adr_at(block->field_index())->field_flags_addr()->update_null_marker(true);\n+        _field_info->adr_at(block->field_index())->field_flags_addr()->update_internal_null_marker(true);\n+      } else {\n+        \/\/ No internal null marker, need a external slot in the container\n+        LayoutRawBlock* marker = new LayoutRawBlock(LayoutRawBlock::NULL_MARKER, 1);\n+        marker->set_field_index(block->field_index());\n+        list->append(marker);\n+      }\n+    }\n+  }\n+  _layout->add(list);\n+  for (GrowableArrayIterator<LayoutRawBlock*> it = list->begin(); it != list->end(); ++it) {\n+    LayoutRawBlock* block = *it;\n+    assert(block->offset() != -1, \"Must be set\");\n+    assert(!block->needs_null_marker(), \"Must have been set\");\n+    _field_info->adr_at(block->field_index())->set_null_marker_offset(block->offset());\n+    _field_info->adr_at(block->field_index())->field_flags_addr()->update_null_marker(true);\n+  }\n+}\n+\n@@ -865,1 +962,1 @@\n-void FieldLayoutBuilder::compute_inline_class_layout(TRAPS) {\n+void FieldLayoutBuilder::compute_inline_class_layout() {\n@@ -867,1 +964,1 @@\n-  inline_class_field_sorting(CHECK);\n+  inline_class_field_sorting();\n@@ -884,0 +981,4 @@\n+  if (EnableNullableFieldFlattening && _layout->has_missing_null_markers()) {\n+    insert_null_markers();\n+  }\n+\n@@ -887,1 +988,1 @@\n-     _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+     _payload_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n@@ -891,1 +992,1 @@\n-     _exact_size_in_bytes = 0;\n+     _payload_size_in_bytes = 0;\n@@ -893,1 +994,14 @@\n-  _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+  _payload_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+\n+  \/\/ Looking if there's an empty slot inside the layout that could be used to store a null marker\n+  LayoutRawBlock* b = _layout->first_field_block();\n+  while (b != _layout->last_block()) {\n+    if (b->kind() == LayoutRawBlock::EMPTY) {\n+      break;\n+    }\n+    b = b->next_block();\n+  }\n+  if (b != _layout->last_block()) {\n+    \/\/ found an empty slot, register its offset from the beginning of the payload\n+    _internal_null_marker_offset = b->offset();\n+  }\n@@ -976,0 +1090,1 @@\n+  _info->_has_null_marker_offsets = _has_null_markers;\n@@ -989,0 +1104,21 @@\n+#ifdef ASSERT\n+  \/\/ Tests verifying integrity of field layouts are using the output of -XX:+PrintFieldLayout\n+  \/\/ which prints the details of LayoutRawBlocks used to compute the layout.\n+  \/\/ The code below checks that offsets in the _field_info meta-data match offsets\n+  \/\/ in the LayoutRawBlocks\n+  LayoutRawBlock* b = _layout->blocks();\n+  while(b != _layout->last_block()) {\n+    if (b->kind() == LayoutRawBlock::REGULAR || b->kind() == LayoutRawBlock::FLAT) {\n+      assert(_field_info->adr_at(b->field_index())->offset() == (u4)b->offset(),\" Must match\");\n+    }\n+    b = b->next_block();\n+  }\n+  b = _static_layout->blocks();\n+  while(b != _static_layout->last_block()) {\n+    if (b->kind() == LayoutRawBlock::REGULAR || b->kind() == LayoutRawBlock::FLAT) {\n+      assert(_field_info->adr_at(b->field_index())->offset() == (u4)b->offset(),\" Must match\");\n+    }\n+    b = b->next_block();\n+  }\n+#endif \/\/ ASSERT\n+\n@@ -992,1 +1128,7 @@\n-    tty->print_cr(\"Layout of class %s\", _classname->as_C_string());\n+    ttyLocker ttl;\n+    if (_super_klass != nullptr) {\n+      tty->print_cr(\"Layout of class %s@%p extends %s@%p\", _classname->as_C_string(),\n+                    _loader_data, _super_klass->name()->as_C_string(), _super_klass->class_loader_data());\n+    } else {\n+      tty->print_cr(\"Layout of class %s@%p\", _classname->as_C_string(), _loader_data);\n+    }\n@@ -994,1 +1136,1 @@\n-    _layout->print(tty, false, _super_klass);\n+    _layout->print(tty, false, _super_klass, _inline_type_field_klasses);\n@@ -996,1 +1138,1 @@\n-    _static_layout->print(tty, true, nullptr);\n+    _static_layout->print(tty, true, nullptr, _inline_type_field_klasses);\n@@ -1001,1 +1143,4 @@\n-      tty->print_cr(\"Exact size = %d bytes\", _exact_size_in_bytes);\n+      tty->print_cr(\"Exact size = %d bytes\", _payload_size_in_bytes);\n+      if (_internal_null_marker_offset != -1) {\n+        tty->print_cr(\"Null marker offset = %d\", _internal_null_marker_offset);\n+      }\n@@ -1007,1 +1152,1 @@\n-void FieldLayoutBuilder::build_layout(TRAPS) {\n+void FieldLayoutBuilder::build_layout() {\n@@ -1009,1 +1154,1 @@\n-    compute_inline_class_layout(CHECK);\n+    compute_inline_class_layout();\n@@ -1011,1 +1156,1 @@\n-    compute_regular_layout(CHECK);\n+    compute_regular_layout();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":214,"deletions":69,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -56,6 +56,8 @@\n-    EMPTY,            \/\/ empty slot, space is taken from this to allocate fields\n-    RESERVED,         \/\/ reserved for JVM usage (for instance object header)\n-    PADDING,          \/\/ padding (because of alignment constraints or @Contended)\n-    REGULAR,          \/\/ primitive or oop field (including not flat inline type fields)\n-    FLAT,             \/\/ flat field\n-    INHERITED         \/\/ field(s) inherited from super classes\n+    EMPTY,                 \/\/ empty slot, space is taken from this to allocate fields\n+    RESERVED,              \/\/ reserved for JVM usage (for instance object header)\n+    PADDING,               \/\/ padding (because of alignment constraints or @Contended)\n+    REGULAR,               \/\/ primitive or oop field (including not flat inline type fields)\n+    FLAT,                  \/\/ flat field\n+    INHERITED,             \/\/ field(s) inherited from super classes\n+    NULL_MARKER,           \/\/ stores the null marker for a flat field\n+    INHERITED_NULL_MARKER  \/\/ a super-class used this slot to store a null marker\n@@ -73,0 +75,1 @@\n+  int _null_marker_offset;\n@@ -74,0 +77,1 @@\n+  bool _needs_null_marker;\n@@ -77,0 +81,1 @@\n+\n@@ -95,0 +100,4 @@\n+  void set_field_index(int field_index) {\n+    assert(_field_index == -1, \"Must not be initialized\");\n+    _field_index = field_index;\n+  }\n@@ -101,0 +110,8 @@\n+  void set_needs_null_marker() { _needs_null_marker = true; }\n+  bool needs_null_marker() const { return _needs_null_marker; }\n+  void set_null_marker_offset(int offset) {\n+    assert(_needs_null_marker, \"\");\n+    _null_marker_offset = offset;\n+    _needs_null_marker = false;\n+  }\n+  int null_marker_offset() const { return _null_marker_offset; }\n@@ -153,1 +170,1 @@\n-  void add_flat_field(int idx, InlineKlass* vk);\n+  void add_flat_field(int idx, InlineKlass* vk, bool needs_null_marker);\n@@ -184,0 +201,1 @@\n+  bool _has_missing_null_markers;\n@@ -198,1 +216,1 @@\n-  LayoutRawBlock* blocks() { return _blocks; }\n+  LayoutRawBlock* blocks() const { return _blocks; }\n@@ -200,1 +218,1 @@\n-  LayoutRawBlock* start() { return _start; }\n+  LayoutRawBlock* start() const { return _start; }\n@@ -202,1 +220,2 @@\n-  LayoutRawBlock* last_block() { return _last; }\n+  LayoutRawBlock* last_block() const { return _last; }\n+  bool has_missing_null_markers() const { return _has_missing_null_markers; }\n@@ -213,1 +232,1 @@\n-  void print(outputStream* output, bool is_static, const InstanceKlass* super);\n+  void print(outputStream* output, bool is_static, const InstanceKlass* super, Array<InlineKlass*>* inline_fields);\n@@ -243,0 +262,1 @@\n+  ClassLoaderData* _loader_data;\n@@ -256,1 +276,2 @@\n-  int _exact_size_in_bytes;\n+  int _internal_null_marker_offset; \/\/ if any, -1 means no internal null marker\n+  int _payload_size_in_bytes;\n@@ -266,0 +287,1 @@\n+  bool _has_null_markers;\n@@ -270,1 +292,1 @@\n-  FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,\n+  FieldLayoutBuilder(const Symbol* classname, ClassLoaderData* loader_data, const InstanceKlass* super_klass, ConstantPool* constant_pool,\n@@ -284,3 +306,7 @@\n-  int get_exact_size_in_byte() {\n-    assert(_exact_size_in_bytes != -1, \"Uninitialized\");\n-    return _exact_size_in_bytes;\n+  int get_payload_size_in_byte() {\n+    assert(_payload_size_in_bytes != -1, \"Uninitialized\");\n+    return _payload_size_in_bytes;\n+  }\n+\n+  int get_internal_null_marker_offset() {\n+    return _internal_null_marker_offset;\n@@ -289,3 +315,3 @@\n-  void build_layout(TRAPS);\n-  void compute_regular_layout(TRAPS);\n-  void compute_inline_class_layout(TRAPS);\n+  void build_layout();\n+  void compute_regular_layout();\n+  void compute_inline_class_layout();\n@@ -293,0 +319,1 @@\n+  void insert_null_markers();\n@@ -297,2 +324,2 @@\n-  void regular_field_sorting(TRAPS);\n-  void inline_class_field_sorting(TRAPS);\n+  void regular_field_sorting();\n+  void inline_class_field_sorting();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":48,"deletions":21,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  \/\/ PRIMITIVE_OBJECT_FIELD: needed to check for inline type fields circularity\n+  \/\/ VALUE_OBJECT_FIELD: needed to check for inline type fields circularity\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  def(_fast_qgetfield            , \"fast_qgetfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield          ) \\\n+  def(_fast_vgetfield            , \"fast_qgetfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _getfield          ) \\\n@@ -44,1 +44,1 @@\n-  def(_fast_qputfield            , \"fast_qputfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield          ) \\\n+  def(_fast_vputfield            , \"fast_qputfield\"            , \"bJJ\"  , nullptr    , T_OBJECT ,  0, true , _putfield          ) \\\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-    _fast_qgetfield       ,\n+    _fast_vgetfield       ,\n@@ -262,1 +262,1 @@\n-    _fast_qputfield       ,\n+    _fast_vputfield       ,\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -318,0 +318,56 @@\n+\/\/ The protocol to read a nullable flat field is:\n+\/\/ Step 1: read the null marker with an load_acquire barrier to ensure that\n+\/\/         reordered loads won't try to load the value before the null marker is read\n+\/\/ Step 2: if the null marker value is zero, the field's value is null\n+\/\/         otherwise the flat field value can be read like a regular flat field\n+JRT_ENTRY(void, InterpreterRuntime::read_nullable_flat_field(JavaThread* current, oopDesc* obj, ResolvedFieldEntry* entry))\n+  assert(oopDesc::is_oop(obj), \"Sanity check\");\n+  assert(entry->has_null_marker(), \"Otherwise should not get there\");\n+  Handle obj_h(THREAD, obj);\n+\n+  InstanceKlass* ik = InstanceKlass::cast(obj_h()->klass());\n+  int field_index = entry->field_index();\n+  int nm_offset = ik->null_marker_offsets_array()->at(field_index);\n+  if (obj_h()->byte_field_acquire(nm_offset) == 0) {\n+    current->set_vm_result(nullptr);\n+  } else {\n+    InlineKlass* field_vklass = InlineKlass::cast(ik->get_inline_type_field_klass(field_index));\n+    oop res = field_vklass->read_flat_field(obj_h(), ik->field_offset(field_index), CHECK);\n+    current->set_vm_result(res);\n+  }\n+JRT_END\n+\n+\/\/ The protocol to write a nullable flat field is:\n+\/\/ If the new field value is null, just write zero to the null marker\n+\/\/ Otherwise:\n+\/\/ Step 1: write the field value like a regular flat field\n+\/\/ Step 2: have a memory barrier to ensure that the whole value content is visible\n+\/\/ Step 3: update the null marker to a non zero value\n+JRT_ENTRY(void, InterpreterRuntime::write_nullable_flat_field(JavaThread* current, oopDesc* obj, oopDesc* value, ResolvedFieldEntry* entry))\n+  assert(oopDesc::is_oop(obj), \"Sanity check\");\n+  Handle obj_h(THREAD, obj);\n+  assert(value == nullptr || oopDesc::is_oop(value), \"Sanity check\");\n+  Handle val_h(THREAD, value);\n+\n+  InstanceKlass* ik = InstanceKlass::cast(obj_h()->klass());\n+  int nm_offset = ik->null_marker_offsets_array()->at(entry->field_index());\n+  if (val_h() == nullptr) {\n+    obj_h()->byte_field_put(nm_offset, (jbyte)0);\n+    return;\n+  }\n+  InlineKlass* vk = InlineKlass::cast(val_h()->klass());\n+  if (entry->has_internal_null_marker()) {\n+    \/\/ The interpreter copies values with a bulk operation\n+    \/\/ To avoid accidently setting the null marker to \"null\" during\n+    \/\/ the copying, the null marker is set to non zero in the source object\n+    if (val_h()->byte_field(vk->get_internal_null_marker_offset()) == 0) {\n+      val_h()->byte_field_put(vk->get_internal_null_marker_offset(), (jbyte)1);\n+    }\n+    vk->write_non_null_flat_field(obj_h(), entry->field_offset(), val_h());\n+  } else {\n+    vk->write_non_null_flat_field(obj_h(), entry->field_offset(), val_h());\n+    OrderAccess::release();\n+    obj_h()->byte_field_put(nm_offset, (jbyte)1);\n+  }\n+JRT_END\n+\n@@ -832,1 +888,3 @@\n-                   info.is_flat(), info.is_null_free_inline_type());\n+                   info.is_flat(), info.is_null_free_inline_type(),\n+                   info.has_null_marker(), info.has_internal_null_marker());\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  static void    read_nullable_flat_field(JavaThread* current, oopDesc* object, ResolvedFieldEntry* entry);\n+  static void    write_nullable_flat_field(JavaThread* current, oopDesc* object, oopDesc* value, ResolvedFieldEntry* entry);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-  def(Bytecodes::_fast_qgetfield      , ubcp|____|clvm|____, atos, atos, fast_accessfield    ,  atos        );\n+  def(Bytecodes::_fast_vgetfield      , ubcp|____|clvm|____, atos, atos, fast_accessfield    ,  atos        );\n@@ -468,1 +468,1 @@\n-  def(Bytecodes::_fast_qputfield      , ubcp|____|clvm|____, atos, vtos, fast_storefield ,   atos        );\n+  def(Bytecodes::_fast_vputfield      , ubcp|____|clvm|____, atos, vtos, fast_storefield ,   atos        );\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  AccessInternal::arraycopy_conjoint_atomic(src, dst, static_cast<size_t>(md->get_exact_size_in_bytes()));\n+  AccessInternal::arraycopy_conjoint_atomic(src, dst, static_cast<size_t>(md->get_payload_size_in_bytes()));\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,0 +111,3 @@\n+    if (fi_ref->field_flags().has_null_marker()) {\n+      assert(fi_ref->null_marker_offset() == fi.null_marker_offset(), \"Must be\");\n+    }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+      _ff_null_marker,  \/\/ field has a null marker, optional section include the null marker offset\n+      _ff_internal_null_marker \/\/ null marker is internal (inside the layout of a flat field)\n@@ -89,1 +91,2 @@\n-      flag_mask((int)_ff_contended);\n+      flag_mask((int)_ff_contended)   |\n+      flag_mask((int)_ff_null_marker);\n@@ -118,0 +121,2 @@\n+    bool has_null_marker() const    { return test_flag(_ff_null_marker); }\n+    bool is_null_marker_internal() const {return test_flag(_ff_internal_null_marker); }\n@@ -126,0 +131,2 @@\n+    void update_null_marker(bool z) { update_flag(_ff_null_marker, z); }\n+    void update_internal_null_marker(bool z) { update_flag(_ff_internal_null_marker, z); }\n@@ -141,0 +148,1 @@\n+  u4 _null_marker_offset;       \/\/ null marker offset for this field in the object layout\n@@ -152,0 +160,1 @@\n+                _null_marker_offset(0),\n@@ -162,0 +171,1 @@\n+            _null_marker_offset(0),\n@@ -181,0 +191,2 @@\n+  u4 null_marker_offset() const              { return _null_marker_offset; }\n+  void set_null_marker_offset(u4 offset)     { _null_marker_offset = offset; }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+    if (fi.field_flags().has_null_marker()) {\n+      _consumer->accept_uint(fi.null_marker_offset());\n+    }\n@@ -92,0 +95,1 @@\n+    assert(fi.null_marker_offset() == 0, \"\");\n@@ -122,0 +126,5 @@\n+  if (fi._field_flags.has_null_marker()) {\n+    fi._null_marker_offset = next_uint();\n+  } else {\n+    fi._null_marker_offset = 0;\n+  }\n@@ -132,1 +141,2 @@\n-                                ff.is_contended());\n+                                ff.is_contended() +\n+                                ff.has_null_marker());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,0 +130,4 @@\n+  int null_marker_offset() const {\n+    return field()->null_marker_offset();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  int esize = log2i_exact(round_up_power_of_2(vk->get_exact_size_in_bytes()));\n+  int esize = log2i_exact(round_up_power_of_2(vk->get_payload_size_in_bytes()));\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,0 +149,5 @@\n+  write_non_null_flat_field(obj, offset, value);\n+}\n+\n+void InlineKlass::write_non_null_flat_field(oop obj, int offset, oop value) {\n+  assert(value != nullptr, \"\");\n@@ -161,1 +166,1 @@\n-  int elem_bytes = get_exact_size_in_bytes();\n+  int elem_bytes = get_payload_size_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  address adr_exact_size_in_bytes() const {\n+  address adr_payload_size_in_bytes() const {\n@@ -104,1 +104,6 @@\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _exact_size_in_bytes));\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _payload_size_in_bytes));\n+  }\n+\n+  address adr_internal_null_marker_offset() const {\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n+    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _internal_null_marker_offset));\n@@ -126,2 +131,2 @@\n-  int get_exact_size_in_bytes() const {\n-    return *(int*)adr_exact_size_in_bytes();\n+  int get_payload_size_in_bytes() const {\n+    return *(int*)adr_payload_size_in_bytes();\n@@ -130,2 +135,15 @@\n-  void set_exact_size_in_bytes(int exact_size) {\n-    *(int*)adr_exact_size_in_bytes() = exact_size;\n+  void set_payload_size_in_bytes(int payload_size) {\n+    *(int*)adr_payload_size_in_bytes() = payload_size;\n+  }\n+\n+  void set_internal_null_marker_offset(int offset) {\n+    *(int*)adr_internal_null_marker_offset() = offset;\n+  }\n+\n+  bool has_internal_null_marker_offset() const {\n+    return *(int*)adr_internal_null_marker_offset() != -1;\n+  }\n+\n+  int get_internal_null_marker_offset() const {\n+    assert(has_internal_null_marker_offset(), \"Must not be call if value class has no internal null marker\");\n+    return *(int*)adr_internal_null_marker_offset();\n@@ -204,0 +222,1 @@\n+  void write_non_null_flat_field(oop obj, int offset, oop value);\n@@ -255,0 +274,4 @@\n+  static ByteSize internal_null_marker_offset_offset() {\n+    return byte_offset_of(InlineKlassFixedBlock, _internal_null_marker_offset);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -570,0 +570,1 @@\n+  _null_marker_offsets(nullptr),\n@@ -725,0 +726,4 @@\n+  if (null_marker_offsets_array() != nullptr) {\n+    MetadataFactory::free_array<int>(loader_data, null_marker_offsets_array());\n+  }\n+\n@@ -1007,0 +1012,1 @@\n+\n@@ -1018,1 +1024,1 @@\n-                                                          Handle(THREAD, loader), Handle(THREAD, protection_domain), THREAD);\n+                                                         Handle(THREAD, loader), Handle(THREAD, protection_domain), THREAD);\n@@ -1953,1 +1959,1 @@\n-    return offset >= vk->first_field_offset() && offset < (vk->first_field_offset() + vk->get_exact_size_in_bytes());\n+    return offset >= vk->first_field_offset() && offset < (vk->first_field_offset() + vk->get_payload_size_in_bytes());\n@@ -2838,0 +2844,1 @@\n+  it->push(&_null_marker_offsets);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -150,1 +150,2 @@\n-  int _exact_size_in_bytes;\n+  int _payload_size_in_bytes;\n+  int _internal_null_marker_offset; \/\/ -1 if none\n@@ -301,0 +302,1 @@\n+  Array<int>* _null_marker_offsets; \/\/ for flat fields with a null marker\n@@ -447,0 +449,1 @@\n+  bool field_has_null_marker(int index) const { return field_flags(index).has_null_marker(); }\n@@ -938,0 +941,1 @@\n+  static ByteSize null_marker_array_offset() { return in_ByteSize(offset_of(InstanceKlass, _null_marker_offsets)); }\n@@ -1028,0 +1032,3 @@\n+  Array<int>* null_marker_offsets_array() const { return _null_marker_offsets; }\n+  void set_null_marker_offsets_array(Array<int>* array) { _null_marker_offsets = array; }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  u1 _flags;                    \/\/ Flags: [0000|is_null_free_inline_type|is_flat|is_final|is_volatile]\n+  u1 _flags;                    \/\/ Flags: [00|has_internal_null_marker|has_null_marker|is_null_free_inline_type|is_flat|is_final|is_volatile]\n@@ -78,1 +78,3 @@\n-      max_flag_shift = is_null_free_inline_type_shift,\n+      has_null_marker_shift = 4,\n+      has_internal_null_marker_shift = 5,\n+      max_flag_shift = has_internal_null_marker_shift\n@@ -93,0 +95,2 @@\n+  bool has_null_marker()        const { return (_flags & (1 << has_null_marker_shift)) != 0; }\n+  bool has_internal_null_marker() const { return (_flags & (1 << has_internal_null_marker_shift)) != 0; }\n@@ -110,4 +114,7 @@\n-  void set_flags(bool is_final_flag, bool is_volatile_flag, bool is_flat_flag, bool is_null_free_inline_type_flag) {\n-    u1 new_flags = (is_final_flag << is_final_shift) | static_cast<int>(is_volatile_flag) |\n-      (is_flat_flag << is_flat_shift) |\n-      (is_null_free_inline_type_flag << is_null_free_inline_type_shift);\n+  void set_flags(bool is_final_flag, bool is_volatile_flag, bool is_flat_flag, bool is_null_free_inline_type_flag,\n+                 bool has_null_marker_flag, bool has_internal_null_marker_flag) {\n+    u1 new_flags = ((is_final_flag ? 1 : 0) << is_final_shift) | static_cast<int>(is_volatile_flag) |\n+      ((is_flat_flag ? 1 : 0) << is_flat_shift) |\n+      ((is_null_free_inline_type_flag ? 1 : 0) << is_null_free_inline_type_shift) |\n+      ((has_null_marker_flag ? 1 : 0) << has_null_marker_shift) |\n+      ((has_internal_null_marker_flag ? 1 : 0) << has_internal_null_marker_shift);\n@@ -119,0 +126,2 @@\n+    assert(has_null_marker() == has_null_marker_flag, \"Must be\");\n+    assert(has_internal_null_marker() == has_internal_null_marker_flag, \"Must be\");\n@@ -130,1 +139,1 @@\n-  \/\/ Populate the strucutre with resolution information\n+  \/\/ Populate the structure with resolution information\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -364,0 +364,14 @@\n+UNSAFE_ENTRY(jboolean, Unsafe_HasNullMarker(JNIEnv *env, jobject unsage, jobject o)) {\n+  oop f = JNIHandles::resolve_non_null(o);\n+  Klass* k = java_lang_Class::as_Klass(java_lang_reflect_Field::clazz(f));\n+  int slot = java_lang_reflect_Field::slot(f);\n+  return InstanceKlass::cast(k)->field_has_null_marker(slot);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jint, Unsafe_NullMarkerOffset(JNIEnv *env, jobject unsage, jobject o)) {\n+  oop f = JNIHandles::resolve_non_null(o);\n+  Klass* k = java_lang_Class::as_Klass(java_lang_reflect_Field::clazz(f));\n+  int slot = java_lang_reflect_Field::slot(f);\n+  return InstanceKlass::cast(k)->null_marker_offsets_array()->at(slot);\n+} UNSAFE_END\n+\n@@ -1007,0 +1021,2 @@\n+    {CC \"hasNullMarker0\"   , CC \"(\" OBJ \")Z\",                    FN_PTR(Unsafe_HasNullMarker)},\n+    {CC \"nullMarkerOffset0\", CC \"(\" OBJ \")I\",                    FN_PTR(Unsafe_NullMarkerOffset)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -89,2 +89,4 @@\n-  inline bool is_flat()        const;\n-  inline bool is_null_free_inline_type()    const;\n+  inline bool is_flat()           const;\n+  inline bool is_null_free_inline_type() const;\n+  inline bool has_null_marker()   const;\n+  inline bool has_internal_null_marker() const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+inline bool fieldDescriptor::has_null_marker() const { return field().field_flags().has_null_marker(); }\n+inline bool fieldDescriptor::has_internal_null_marker() const { return field().field_flags().is_null_marker_internal(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -809,1 +809,1 @@\n-  notproduct(bool, PrintFieldLayout, false,                                 \\\n+  product(bool, PrintFieldLayout, false, DIAGNOSTIC,                        \\\n@@ -812,2 +812,2 @@\n-  notproduct(bool, PrintInlineLayout, false,                                \\\n-          \"Print field layout for each inline type\")                        \\\n+  product(bool, PrintInlineLayout, false, DIAGNOSTIC,                       \\\n+          \"Print field layout for each inline type or class with inline fields\") \\\n@@ -824,0 +824,3 @@\n+  develop(bool, EnableNullableFieldFlattening, false,                       \\\n+          \"Allow the JVM to flatten some nullable fields\")                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -193,0 +193,29 @@\n+    \/* Returns true if the given field has a null marker\n+     * <p>\n+     * Nullable flat fields are stored in a flattened representation\n+     * and have an associated null marker to indicate if the the field value is\n+     * null or the one stored with the flat representation\n+     *\/\n+\n+     public boolean hasNullMarker(Field f) {\n+        if (f == null) {\n+            throw new NullPointerException();\n+        }\n+        return hasNullMarker0(f);\n+     }\n+\n+     private native boolean hasNullMarker0(Object o);\n+\n+     \/* Returns the offset of the null marker of the field,\n+      * or -1 if the field doesn't have a null marker\n+      *\/\n+\n+     public int nullMarkerOffset(Field f) {\n+        if (f == null) {\n+            throw new NullPointerException();\n+        }\n+        return nullMarkerOffset0(f);\n+     }\n+\n+     private native int nullMarkerOffset0(Object o);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test NullableFlatFieldTest\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @run main\/othervm -Xint -XX:+EnableNullableFieldFlattening -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlineLayout NullableFlatFieldTest\n+ *\/\n+\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class NullableFlatFieldTest {\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value0 {\n+    long l;\n+    int i;\n+    short s;\n+    byte b;\n+\n+    Value0() {\n+      l = 0;\n+      i = 0;\n+      s = 0;\n+      b = 0;\n+    }\n+\n+    Value0(long l0, int i0, short s0, byte b0) {\n+      l = l0;\n+      i = i0;\n+      s = s0;\n+      b = b0;\n+    }\n+  }\n+\n+  static class Container0 {\n+    Value0 val;\n+    long l;\n+    int i;\n+  }\n+\n+  \/\/ Container0 had a external null marker located just between two Java fields,\n+  \/\/ and test0 checks that updating the null marker doesn't corrupt\n+  \/\/ the surrounding fields and vice-versa.\n+  static void test0() {\n+    Container0 c = new Container0();\n+    Asserts.assertNull(c.val);\n+    Asserts.assertEquals(c.l, 0L);\n+    Asserts.assertEquals(c.i, 0);\n+    c.l = -1L;\n+    c.i = -1;\n+    Asserts.assertNull(c.val);\n+    Value0 v = new Value0(-1L, -1, (short)-1, (byte)-1);\n+    c.val = v;\n+    Asserts.assertEquals(c.l, -1L);\n+    Asserts.assertEquals(c.i, -1);\n+    Value0 vr = c.val;\n+    Asserts.assertEquals(vr.l, -1L);\n+    Asserts.assertEquals(vr.i, -1);\n+    Asserts.assertEquals(vr.s, (short)-1);\n+    Asserts.assertEquals(vr.b, (byte)-1);\n+    c.val = null;\n+    Asserts.assertEquals(c.l, -1L);\n+    Asserts.assertEquals(c.i, -1);\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value1a {\n+    long l;\n+    short s;\n+    byte b;\n+\n+    Value1a() {\n+      l = 0;\n+      s = 0;\n+      b = 0;\n+    }\n+\n+    Value1a(long l0, short s0, byte b0) {\n+      l = l0;\n+      s = s0;\n+      b = b0;\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value1b {\n+    @NullRestricted\n+    Value1a vala;\n+    long l;\n+    int i;\n+\n+    Value1b() {\n+      vala = new Value1a();\n+      l = 1L;\n+      i = 1;\n+    }\n+\n+    Value1b(Value1a v0, long l0, int i0) {\n+      vala = v0;\n+      l = l0;\n+      i = i0;\n+    }\n+  }\n+\n+  static class Container1 {\n+    Value1b valb;\n+  }\n+\n+  \/\/ Container1 has a nullable flat field with an internal null marker,\n+  \/\/ test1 checks that updating the null marker doesn't corrupt the\n+  \/\/ flat field's values\n+  static void test1() {\n+    Container1 c = new Container1();\n+    Asserts.assertNull(c.valb);\n+    Value1a va = new Value1a(-1L, (short)-1, (byte)-1);\n+    Asserts.assertEquals(va.l, -1L);\n+    Asserts.assertEquals(va.s, (short)-1);\n+    Asserts.assertEquals(va.b, (byte)-1);\n+    Value1b vb = new Value1b(va, -1L, -1);\n+    Asserts.assertNotNull(vb.vala);\n+    Asserts.assertEquals(vb.vala.l, -1L);\n+    Asserts.assertEquals(vb.vala.s, (short)-1);\n+    Asserts.assertEquals(vb.vala.b, (byte)-1);\n+    c.valb = vb;\n+    Asserts.assertNotNull(c.valb);\n+    Asserts.assertEquals(c.valb, vb);\n+    Asserts.assertEquals(c.valb.vala, va);\n+    Asserts.assertEquals(c.valb.l, -1L);\n+    Asserts.assertEquals(c.valb.i, -1);\n+    c.valb = null;\n+    Asserts.assertNull(c.valb);\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value2a {\n+    long l;\n+    int i;\n+    byte b;\n+    Value2a() {\n+      l = 0;\n+      i = 0;\n+      b = 0;\n+    }\n+    Value2a(long l0, int i0, byte b0) {\n+      l = l0;\n+      i = i0;\n+      b = b0;\n+    }\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value2b {\n+    long l;\n+    Value2b() {\n+      l = 0;\n+    }\n+    Value2b(long l0) {\n+      l = l0;\n+    }\n+  }\n+\n+  static class Container2 {\n+    Value2a vala;\n+    Value2b valb0;\n+    Value2b valb1;\n+    int i;\n+  }\n+\n+  \/\/ Container2 has 3 contiguous null markers,\n+  \/\/ test2 checks that updating a null marker doesn't affect the other markers\n+  public static void test2() {\n+    Container2 c = new Container2();\n+    Asserts.assertNull(c.vala);\n+    Asserts.assertNull(c.valb0);\n+    Asserts.assertNull(c.valb1);\n+    Value2a va = new Value2a(-1L, -1, (byte)-1);\n+    c.vala = va;\n+    Asserts.assertNotNull(c.vala);\n+    Asserts.assertNull(c.valb0);\n+    Asserts.assertNull(c.valb1);\n+    c.vala = null;\n+    Asserts.assertNull(c.vala);\n+    Asserts.assertNull(c.valb0);\n+    Asserts.assertNull(c.valb1);\n+    Value2b vb = new Value2b(-1L);\n+    c.valb0 = vb;\n+    Asserts.assertNull(c.vala);\n+    Asserts.assertNotNull(c.valb0);\n+    Asserts.assertNull(c.valb1);\n+    c.valb0 = null;\n+    Asserts.assertNull(c.vala);\n+    Asserts.assertNull(c.valb0);\n+    Asserts.assertNull(c.valb1);\n+    c.valb1 = vb;\n+    Asserts.assertNull(c.vala);\n+    Asserts.assertNull(c.valb0);\n+    Asserts.assertNotNull(c.valb1);\n+    c.valb1 = null;\n+    Asserts.assertNull(c.vala);\n+    Asserts.assertNull(c.valb0);\n+    Asserts.assertNull(c.valb1);\n+    c.vala = va;\n+    c.valb0 = vb;\n+    c.valb1 = vb;\n+    Asserts.assertNotNull(c.vala);\n+    Asserts.assertNotNull(c.valb0);\n+    Asserts.assertNotNull(c.valb1);\n+    c.vala = null;\n+    Asserts.assertNull(c.vala);\n+    Asserts.assertNotNull(c.valb0);\n+    Asserts.assertNotNull(c.valb1);\n+    c.vala = va;\n+    Asserts.assertNotNull(c.vala);\n+    Asserts.assertNotNull(c.valb0);\n+    Asserts.assertNotNull(c.valb1);\n+    c.valb0 = null;\n+    Asserts.assertNotNull(c.vala);\n+    Asserts.assertNull(c.valb0);\n+    Asserts.assertNotNull(c.valb1);\n+    c.valb0 = vb;\n+    Asserts.assertNotNull(c.vala);\n+    Asserts.assertNotNull(c.valb0);\n+    Asserts.assertNotNull(c.valb1);\n+    c.valb1 = null;\n+    Asserts.assertNotNull(c.vala);\n+    Asserts.assertNotNull(c.valb0);\n+    Asserts.assertNull(c.valb1);\n+    c.valb1 = vb;\n+    Asserts.assertNotNull(c.vala);\n+    Asserts.assertNotNull(c.valb0);\n+    Asserts.assertNotNull(c.valb1);\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value3 {\n+    int i = 0;\n+  }\n+\n+  static class Container3 {\n+    Value3 val;\n+  }\n+\n+  static Container3 getNullContainer3() {\n+    return null;\n+  }\n+\n+  public static void test3() {\n+    NullPointerException npe = null;\n+    Container3 c = getNullContainer3();\n+    try {\n+      Value3 v = c.val;\n+    } catch(NullPointerException e) {\n+      npe = e;\n+    }\n+    Asserts.assertNotNull(npe);\n+  }\n+\n+  public static void main(String[] args) {\n+    \/\/ All tests are run twice to exercise both the unresolved bytecodes and the rewritten ones\n+    for (int i = 0; i < 2; i++) {\n+      System.out.println(\"Pass \" + i);\n+      test0();\n+      test1();\n+      test2();\n+      test3();\n+    }\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullableFlatFieldTest.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n- * @run main\/othervm -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 runtime.valhalla.inlinetypes.UnsafeTest\n+ * @run main\/othervm -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 -XX:+EnableNullableFieldFlattening runtime.valhalla.inlinetypes.UnsafeTest\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.Asserts;\n@@ -92,1 +93,1 @@\n-    public static void main(String[] args) throws Throwable {\n+    public static void test0() throws Throwable {\n@@ -166,0 +167,39 @@\n+\n+    static value class MyValue0 {\n+        int val;\n+\n+        public MyValue0(int i) {\n+            val = i;\n+        }\n+    }\n+\n+    static class Container0 {\n+        MyValue0 v;\n+    }\n+\n+    public static void test1() throws Throwable {\n+        Container0 c = new Container0();\n+        Class<?> cc = Container0.class;\n+        Field[] fields = cc.getDeclaredFields();\n+        Asserts.assertEquals(fields.length, 1);\n+        Field f = fields[0];\n+        System.out.println(\"Field found: \" + f);\n+        Asserts.assertTrue(U.isFlatField(f));\n+        Asserts.assertTrue(U.hasNullMarker(f));\n+        int nmOffset = U.nullMarkerOffset(f);\n+        Asserts.assertNotEquals(nmOffset, -1);\n+        byte nm = U.getByte(c, nmOffset);\n+        Asserts.assertEquals(nm, (byte)0);\n+        c.v = new MyValue0(42);\n+        Asserts.assertNotNull(c.v);\n+        nm = U.getByte(c, nmOffset);\n+        Asserts.assertNotEquals(nm, 0);\n+        U.getAndSetByteRelease(c, nmOffset, (byte)0);\n+        Asserts.assertNull(c.v);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        test0();\n+        test1();\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Oops32\n+ * @requires vm.bits == 32\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java FieldAlignmentTest.java\n+ * @run main\/othervm FieldAlignmentTest 0\n+ *\/\n+\n+  \/*\n+ * @test id=CompressedOops\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java FieldAlignmentTest.java\n+ * @run main\/othervm FieldAlignmentTest 1\n+ *\/\n+\n+  \/*\n+ * @test id=NoCompressedOops\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java FieldAlignmentTest.java\n+ * @run main\/othervm FieldAlignmentTest 2\n+ *\/\n+\n+ import java.util.ArrayList;\n+ import java.util.Collections;\n+ import java.util.List;\n+\n+ import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+\n+ import jdk.test.lib.Asserts;\n+ import jdk.test.lib.ByteCodeLoader;\n+ import jdk.test.lib.helpers.ClassFileInstaller;\n+ import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+ import jdk.test.lib.process.OutputAnalyzer;\n+ import jdk.test.lib.process.ProcessTools;\n+\n+ public class FieldAlignmentTest {\n+  public static class ZeroByte { }\n+  public static class OneByte { byte b; }\n+  public static class TwoByte { byte b0; byte b1; }\n+  public static class ThreeByte { byte b0; byte b1; byte b2; }\n+  public static class FourByte { byte b0; byte b1; byte b2; byte b3; }\n+  public static class FiveByte { byte b0; byte b1; byte b2; byte b3; byte b4; }\n+  public static class SixByte { byte b0; byte b1; byte b2; byte b3; byte b4; byte b5; }\n+  public static class SevenByte { byte b0; byte b1; byte b2; byte b3; byte b4; byte b5; byte b6; }\n+  public static final String[] superNames = { ZeroByte.class.getCanonicalName(),\n+                                              OneByte.class.getCanonicalName(),\n+                                              TwoByte.class.getCanonicalName(),\n+                                              ThreeByte.class.getCanonicalName(),\n+                                              FourByte.class.getCanonicalName(),\n+                                              FiveByte.class.getCanonicalName(),\n+                                              SixByte.class.getCanonicalName(),\n+                                              SevenByte.class.getCanonicalName() };\n+  public static final String[] valueNames = { ValueOneByte.class.getCanonicalName(),\n+                                              ValueOneChar.class.getCanonicalName(),\n+                                              ValueOneShort.class.getCanonicalName(),\n+                                              ValueOneInt.class.getCanonicalName(),\n+                                              ValueOneLong.class.getCanonicalName(),\n+                                              ValueOneFloat.class.getCanonicalName(),\n+                                              ValueOneDouble.class.getCanonicalName(),\n+                                              ValueByteLong.class.getCanonicalName(),\n+                                              ValueByteInt.class.getCanonicalName() };\n+\n+  List<String> testNames = new ArrayList<String>();\n+\n+  @ImplicitlyConstructible static value class ValueOneByte { byte val = 0; }\n+  @ImplicitlyConstructible static value class ValueOneChar { char val = 0; }\n+  @ImplicitlyConstructible static value class ValueOneShort { short val = 0; }\n+  @ImplicitlyConstructible static value class ValueOneInt { int val = 0; }\n+  @ImplicitlyConstructible static value class ValueOneLong { long val = 0; }\n+  @ImplicitlyConstructible static value class ValueOneFloat { float val = 0f; }\n+  @ImplicitlyConstructible static value class ValueOneDouble { double val = 0d; }\n+\n+  @ImplicitlyConstructible static value class ValueByteLong { byte b = 0; long l = 0; }\n+  @ImplicitlyConstructible static value class ValueByteInt { byte b = 0; int i = 0; }\n+\n+  void generateTests() throws Exception {\n+    for (String vName : valueNames) {\n+      for (String sName : superNames) {\n+        String vNameShort = vName.substring(vName.lastIndexOf('.') + 1);\n+        String sNameShort = sName.substring(sName.lastIndexOf('.') + 1);\n+        String className = \"Test\" + vNameShort + \"With\" + sNameShort;\n+        String sourceCode = \"import jdk.internal.vm.annotation.NullRestricted; \" +\n+                            \"public class \" + className + \" extends \" + sName + \" { \" +\n+                            \"    @NullRestricted\" +\n+                            \"    \" + vName + \" v1;\" +\n+                            \"}\";\n+        byte[] byteCode = InMemoryJavaCompiler.compile(className, sourceCode,\n+                                                      \"-source\", \"22\", \"--enable-preview\",\n+                                                      \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\");\n+        jdk.test.lib.helpers.ClassFileInstaller.writeClassToDisk(className, byteCode);\n+        testNames.add(className);\n+      }\n+    }\n+  }\n+\n+  void generateTestRunner() throws Exception {\n+    String className = \"TestRunner\";\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"public class \").append(className).append(\" {\");\n+    sb.append(\"    public void main(String[] args) {\");\n+    for (String name : testNames) {\n+      sb.append(\"        \").append(name).append(\" var\").append(name).append(\" = new \").append(name).append(\"();\");\n+    }\n+    sb.append(\"    }\");\n+    sb.append(\"}\");\n+    byte[] byteCode = InMemoryJavaCompiler.compile(className, sb.toString(),\n+                                                   \"-source\", \"22\", \"--enable-preview\",\n+                                                   \"-cp\", \".\");\n+    jdk.test.lib.helpers.ClassFileInstaller.writeClassToDisk(className, byteCode);\n+  }\n+\n+  static ProcessBuilder exec(String compressedOopsArg, String... args) throws Exception {\n+    List<String> argsList = new ArrayList<>();\n+    Collections.addAll(argsList, \"--enable-preview\");\n+    Collections.addAll(argsList, \"-XX:+UnlockDiagnosticVMOptions\");\n+    Collections.addAll(argsList, \"-XX:+PrintFieldLayout\");\n+    if (compressedOopsArg != null) {\n+      Collections.addAll(argsList, compressedOopsArg);\n+    }\n+    Collections.addAll(argsList, \"-Xmx256m\");\n+    Collections.addAll(argsList, \"-cp\", System.getProperty(\"java.class.path\") + \":.\");\n+    Collections.addAll(argsList, args);\n+    return ProcessTools.createTestJavaProcessBuilder(argsList);\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    boolean useCompressedOops;\n+    String compressedOopsArg;\n+\n+    switch(args[0]) {\n+      case \"0\": useCompressedOops = false;\n+                compressedOopsArg = null;\n+                break;\n+      case \"1\": useCompressedOops = true;\n+                compressedOopsArg = \"-XX:+UseCompressedOops\";\n+                break;\n+      case \"2\": useCompressedOops = false;\n+                compressedOopsArg = \"-XX:-UseCompressedOops\";\n+                break;\n+      default: throw new RuntimeException(\"Unrecognized configuration\");\n+    }\n+\n+    \/\/ Generate test classes\n+    FieldAlignmentTest fat = new FieldAlignmentTest();\n+    fat.generateTests();\n+    fat.generateTestRunner();\n+\n+    \/\/ Execute the test runner in charge of loading all test classes\n+    ProcessBuilder pb = exec(compressedOopsArg, \"TestRunner\");\n+    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+\n+    \/\/ Analyze the test runner output\n+    System.out.print(out.getOutput());\n+    FieldLayoutAnalyzer.LogOutput lo = new FieldLayoutAnalyzer.LogOutput(out.asLines());\n+\n+    FieldLayoutAnalyzer fla =  FieldLayoutAnalyzer.createFieldLayoutAnalyzer(lo, useCompressedOops);\n+    fla.check();\n+  }\n+ }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldAlignmentTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,554 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class FieldLayoutAnalyzer {\n+\n+  \/\/ Mutable wrapper around log output to manage the cursor while parsing\n+  static class LogOutput {\n+    List<String> lines;\n+    int cursor;\n+\n+    public LogOutput(List<String> lines) {\n+      this.lines = lines;\n+      cursor = 0;\n+    }\n+\n+    String getCurrentLine() { return lines.get(cursor); }\n+    String get(int idx) { return lines.get(idx); }\n+    int size() { return lines.size(); }\n+    void moveToNextLine() { cursor = cursor + 1; }\n+    boolean hasMoreLines() { return cursor < lines.size(); }\n+  }\n+\n+  static enum BlockType {\n+    RESERVED,\n+    INHERITED,\n+    EMPTY,\n+    REGULAR,\n+    PADDING,\n+    FLAT,\n+    NULL_MARKER,\n+    INHERITED_NULL_MARKER;\n+\n+    static BlockType parseType(String s) {\n+      switch(s) {\n+        case \"RESERVED\"    : return RESERVED;\n+        case \"INHERITED\"   : return INHERITED;\n+        case \"EMPTY\"       : return EMPTY;\n+        case \"REGULAR\"     : return REGULAR;\n+        case \"PADDING\"     : return PADDING;\n+        case \"FLAT\"        : return FLAT;\n+        case \"NULL_MARKER\" : return NULL_MARKER;\n+        case \"INHERITED_NULL_MARKER\" : return INHERITED_NULL_MARKER;\n+        default:\n+          throw new RuntimeException(\"Unknown block type: \" + s);\n+      }\n+    }\n+  }\n+\n+  static public record FieldBlock (int offset,\n+                            BlockType type,\n+                            int size,\n+                            int alignment,\n+                            String name,\n+                            String signature,\n+                            String fieldClass,\n+                            int nullMarkerOffset,\n+                            boolean hasInternalNullMarker,\n+                            int referenceFieldOffset) { \/\/ for null marker blocks, gives the offset of the field they refer to\n+\n+\n+    static FieldBlock createSpecialBlock(int offset, BlockType type, int size, int alignment, int referenceFieldOffset) {\n+      return new FieldBlock(offset, type, size, alignment, null, null, null, -1, false, referenceFieldOffset);\n+    }\n+\n+    static FieldBlock createJavaFieldBlock(int offset, BlockType type, int size, int alignment, String name, String signature, String fieldClass, int nullMarkerOffset, boolean hasInternalNullMarker) {\n+      return new FieldBlock(offset, type, size, alignment, name, signature, fieldClass, nullMarkerOffset, hasInternalNullMarker, -1);\n+    }\n+\n+    void print(PrintStream out) {\n+      out.println(\"Offset=\" + offset+\n+                \" type=\" + type +\n+                \" size=\" + size +\n+                \" alignment=\" + alignment +\n+                \" name=\" + name +\n+                \" signature=\" + signature +\n+                \" fieldClass=\" + fieldClass);\n+    }\n+\n+    boolean isFlat() { return type == BlockType.FLAT; } \/\/ Warning: always return false for inherited fields, even flat ones\n+    boolean hasNullMarker() {return nullMarkerOffset != -1; }\n+\n+    static FieldBlock parseField(String line) {\n+      String[] fieldLine = line.split(\"\\\\s+\");\n+      \/\/ for(String  s : fieldLine) {\n+      \/\/   System.out.print(\"[\"+s+\"]\");  \/\/ debugging statement to be removed\n+      \/\/ }\n+      \/\/ System.out.println();\n+      int offset = Integer.parseInt(fieldLine[1].substring(1, fieldLine[1].length()));\n+      BlockType type = BlockType.parseType(fieldLine[2]);\n+      String[] size_align = fieldLine[3].split(\"\/\");\n+      int size = Integer.parseInt(size_align[0]);\n+      int alignment = -1;\n+      if (type != BlockType.RESERVED) {\n+        alignment = Integer.parseInt(size_align[1]);\n+      } else {\n+        Asserts.assertTrue(size_align[1].equals(\"-\"));\n+      }\n+      FieldBlock block = null;\n+      switch(type) {\n+        case BlockType.RESERVED:\n+        case BlockType.EMPTY:\n+        case BlockType.PADDING:\n+        case BlockType.INHERITED_NULL_MARKER: {\n+            block = FieldBlock.createSpecialBlock(offset, type, size, alignment, 0);\n+            break;\n+        }\n+        case BlockType.REGULAR:\n+        case BlockType.INHERITED:\n+        case BlockType.FLAT: {\n+            String name = fieldLine[4];\n+            String signature = fieldLine[5];\n+            String fieldClass = \"\";\n+            int nullMarkerOffset = -1;\n+            boolean hasInternalNullMarker = false;\n+            if (type == BlockType.FLAT) {\n+              fieldClass = fieldLine[6];\n+              if (fieldLine.length >= 11) {\n+                nullMarkerOffset = Integer.parseInt(fieldLine[10]);\n+              }\n+              if (fieldLine.length >= 12 ) {\n+                Asserts.assertEquals(fieldLine[11], \"(internal)\");\n+                hasInternalNullMarker = true;\n+              }\n+            }\n+            block = FieldBlock.createJavaFieldBlock(offset, type, size, alignment, name, signature, fieldClass, nullMarkerOffset, hasInternalNullMarker);\n+            break;\n+          }\n+        case BlockType.NULL_MARKER: {\n+          int referenceFieldOffset = Integer.parseInt(fieldLine[10]);\n+          block = FieldBlock.createSpecialBlock(offset, type, size, alignment, referenceFieldOffset);\n+          break;\n+        }\n+      }\n+      Asserts.assertNotNull(block);\n+      return block;\n+    }\n+  }\n+\n+  static class ClassLayout {\n+    String name;\n+    String superName;\n+    boolean isValue;\n+    int size;\n+    int firstFieldOffset;\n+    int alignment;\n+    int exactSize;\n+    String[] lines;\n+    ArrayList<FieldBlock> staticFields;\n+    ArrayList<FieldBlock> nonStaticFields;\n+    int internalNullMarkerOffset; \/\/ -1 if no internal null marker\n+\n+    private ClassLayout() {\n+      staticFields = new ArrayList<FieldBlock>();\n+      nonStaticFields = new ArrayList<FieldBlock>();\n+    }\n+\n+    void processField(String line, boolean isStatic) {\n+      FieldBlock block = FieldBlock.parseField(line);\n+      if (isStatic) {\n+        Asserts.assertTrue(block.type != BlockType.INHERITED); \/\/ static fields cannotbe inherited\n+        staticFields.add(block);\n+      } else {\n+        nonStaticFields.add(block);\n+      }\n+    }\n+\n+    static ClassLayout parseClassLayout(LogOutput lo) {\n+      ClassLayout cl = new ClassLayout();\n+      \/\/ Parsing class name\n+      Asserts.assertTrue(lo.getCurrentLine().startsWith(\"Layout of class\"), lo.getCurrentLine());\n+      String[] first = lo.getCurrentLine().split(\"\\\\s+\");\n+      cl.name = first[3];\n+      if (first.length == 6) {\n+        Asserts.assertEquals(first[4], \"extends\");\n+        cl.superName = first[5];\n+      } else {\n+        cl.superName = null;\n+      }\n+      \/\/ System.out.println(\"Class name: \" + cl.name);\n+      lo.moveToNextLine();\n+      Asserts.assertTrue(lo.getCurrentLine().startsWith(\"Instance fields:\"), lo.getCurrentLine());\n+      lo.moveToNextLine();\n+      \/\/ Parsing instance fields\n+      while (lo.getCurrentLine().startsWith(\" @\")) {\n+        cl.processField(lo.getCurrentLine(), false);\n+        lo.moveToNextLine();\n+      }\n+      Asserts.assertTrue(lo.getCurrentLine().startsWith(\"Static fields:\"), lo.getCurrentLine());\n+      lo.moveToNextLine();\n+      \/\/ Parsing static fields\n+      while (lo.getCurrentLine().startsWith(\" @\")) {\n+        cl.processField(lo.getCurrentLine(), true);\n+        lo.moveToNextLine();\n+      }\n+      Asserts.assertTrue(lo.getCurrentLine().startsWith(\"Instance size =\"), lo.getCurrentLine());\n+      String[] sizeLine = lo.getCurrentLine().split(\"\\\\s+\");\n+      cl.size = Integer.parseInt(sizeLine[3]);\n+      lo.moveToNextLine();\n+      if (lo.getCurrentLine().startsWith(\"First field offset =\")) {\n+        \/\/ The class is a value class, more lines to parse\n+        cl.isValue = true;\n+        String[] firstOffsetLine = lo.getCurrentLine().split(\"\\\\s+\");\n+        cl.firstFieldOffset = Integer.parseInt(firstOffsetLine[4]);\n+        lo.moveToNextLine();\n+        String[] alignmentLine = lo.getCurrentLine().split(\"\\\\s+\");\n+        cl.alignment = Integer.parseInt(alignmentLine[2]);\n+        lo.moveToNextLine();\n+        String[] exactSizeLine = lo.getCurrentLine().split(\"\\\\s+\");\n+        cl.exactSize = Integer.parseInt(exactSizeLine[3]);\n+        lo.moveToNextLine();\n+        if (lo.getCurrentLine().startsWith(\"Null marker offset\")) {\n+          String[] nullMarkerLine = lo.getCurrentLine().split(\"\\\\s+\");\n+          cl.internalNullMarkerOffset = Integer.parseInt(nullMarkerLine[4]);\n+          lo.moveToNextLine();\n+        } else {\n+          cl.internalNullMarkerOffset = -1;\n+        }\n+      } else {\n+        cl.isValue = false;\n+      }\n+\n+      Asserts.assertTrue(lo.getCurrentLine().startsWith(\"---\"), lo.getCurrentLine());\n+      lo.moveToNextLine();\n+      return cl;\n+    }\n+\n+    FieldBlock getFieldAtOffset(int offset, boolean isStatic) {\n+      ArrayList<FieldBlock> fields = isStatic ? staticFields : nonStaticFields;\n+      for (FieldBlock block : fields) {\n+        if (block.offset == offset) return block;\n+      }\n+      throw new RuntimeException(\"No \" + (isStatic ? \"static\" : \"nonstatic\") + \" field found at offset \"+ offset);\n+    }\n+\n+    FieldBlock getFieldFromName(String fieldName, boolean isStatic) {\n+      Asserts.assertTrue(fieldName != null);\n+      ArrayList<FieldBlock> fields = isStatic ? staticFields : nonStaticFields;\n+      for (FieldBlock block : fields) {\n+        if (block.name() == null) continue;\n+        String n = block.name().substring(1, block.name().length() - 1); \/\/ in the log, name is surrounded by double quotes\n+        if (fieldName.equals(n)) return block;\n+      }\n+      throw new RuntimeException(\"No \" + (isStatic ? \"static\" : \"nonstatic\") + \" field found with name \"+ fieldName);\n+    }\n+\n+  }\n+\n+  ArrayList<ClassLayout> layouts;\n+  boolean compressOops;\n+\n+  static String signatureToName(String sig) {\n+    Asserts.assertTrue((sig.charAt(0) == 'L'));\n+    Asserts.assertTrue((sig.charAt(sig.length() - 1) == ';'));\n+    return sig.substring(1, sig.length() - 1);\n+  }\n+\n+  private FieldLayoutAnalyzer(boolean coop) {\n+    compressOops = coop;\n+    layouts = new ArrayList<ClassLayout>();\n+  }\n+\n+  public static FieldLayoutAnalyzer createFieldLayoutAnalyzer(LogOutput lo, boolean compressOops) {\n+    FieldLayoutAnalyzer fla = new FieldLayoutAnalyzer(compressOops);\n+    fla.generate(lo);\n+    return fla;\n+  }\n+\n+  ClassLayout getClassLayout(String name) {\n+    for(ClassLayout layout : layouts) {\n+      if (layout.name.equals(name)) return layout;\n+    }\n+    return null;\n+  }\n+\n+  ClassLayout getClassLayoutFromName(String name) {\n+    for(ClassLayout layout : layouts) {\n+      String sub = layout.name.substring(0, layout.name.indexOf('@'));\n+      if (name.equals(sub)) return layout;\n+    }\n+    return null;\n+  }\n+\n+  void checkNoOverlapOnFields(ArrayList<FieldBlock> fields) {\n+    for (int i = 0; i < fields.size() - 1; i++) {\n+      FieldBlock f0 = fields.get(i);\n+      FieldBlock f1 = fields.get(i + 1);\n+      if (f0.offset + f0.size < f1.offset) {\n+        throw new RuntimeException(\"Hole issue found at offset \" + f1.offset);\n+      } else if (f0.offset + f0.size > f1.offset) {\n+        throw new RuntimeException(\"Overlap issue found at offset \" + f1.offset);\n+      }\n+    }\n+  }\n+\n+  void checkNoOverlap() {\n+    System.out.println(\"Checking for overlap\");\n+    for (ClassLayout layout : layouts) {\n+      System.out.println(\"\\t\" + layout.name);\n+      try {\n+        checkNoOverlapOnFields(layout.staticFields);\n+        checkNoOverlapOnFields(layout.nonStaticFields);\n+      } catch(Throwable t) {\n+        throw new RuntimeException(\"Unexpection exception when checking for overlaps\/holes in class \" + layout.name);\n+      }\n+    }\n+  }\n+\n+  void checkSizeAndAlignmentForField(FieldBlock block) {\n+    if (block.type == BlockType.RESERVED) {\n+      Asserts.assertTrue(block.alignment == -1);\n+      return;\n+    }\n+    if (block.type == BlockType.EMPTY || block.type == BlockType.PADDING\n+        || block.type == BlockType.NULL_MARKER || block.type == BlockType.INHERITED_NULL_MARKER) {\n+      Asserts.assertTrue(block.alignment == 1, \"alignment = \" + block.alignment);\n+      return;\n+    }\n+\n+    switch(block.signature()) {\n+      case \"Z\" :\n+      case \"B\" : Asserts.assertTrue(block.size() == 1);\n+                 Asserts.assertTrue(block.alignment() == 1);\n+        break;\n+      case \"S\" :\n+      case \"C\" : Asserts.assertTrue(block.size() == 2);\n+                 Asserts.assertTrue(block.alignment() == 2);\n+        break;\n+      case \"F\" :\n+      case \"I\" : Asserts.assertTrue(block.size() == 4);\n+                 Asserts.assertTrue(block.alignment() == 4);\n+        break;\n+      case \"J\" :\n+      case \"D\" : Asserts.assertTrue(block.size() == 8);\n+                 Asserts.assertTrue(block.alignment() == 8);\n+        break;\n+      default: {\n+        if (block.signature().startsWith(\"[\")) {\n+          Asserts.assertEquals(compressOops ? 4 : 8, block.size());\n+        } else if (block.signature().startsWith(\"L\")) {\n+          if (block.type == BlockType.INHERITED || block.type == BlockType.INHERITED_NULL_MARKER) {\n+            \/\/ Skip for now, will be verified when checking the class declaring the field\n+          } else if (block.type == BlockType.REGULAR) {\n+            Asserts.assertEquals(compressOops ? 4 : 8, block.size());\n+          } else {\n+            Asserts.assertEquals(BlockType.FLAT, block.type);\n+            ClassLayout fcl = getClassLayout(block.fieldClass);\n+            Asserts.assertNotNull(fcl);\n+            Asserts.assertEquals(block.size(), fcl.exactSize);\n+            Asserts.assertEquals(block.alignment(), fcl.alignment);\n+          }\n+        } else {\n+          throw new RuntimeException(\"Unknown signature type: \" + block.signature);\n+        }\n+      }\n+      Asserts.assertTrue(block.offset % block.alignment == 0);\n+    }\n+  }\n+\n+  void checkSizeAndAlignment() {\n+    System.out.println(\"Checking size and alignment\");\n+    for (ClassLayout layout : layouts) {\n+      System.out.println(\"\\t\" + layout.name);\n+      for (FieldBlock block : layout.staticFields) {\n+        checkSizeAndAlignmentForField(block);\n+      }\n+      for (FieldBlock block : layout.nonStaticFields) {\n+        checkSizeAndAlignmentForField(block);\n+      }\n+    }\n+  }\n+\n+  \/\/ Verify that fields marked as INHERITED are declared in a super class\n+  void checkInheritedFields() {\n+    System.out.println(\"Checking Inherited Fields\");\n+    for (ClassLayout layout : layouts) {\n+      System.out.println(\"\\t\" + layout.name);\n+      \/\/ Preparing the list of ClassLayout of super classes\n+      ArrayList<ClassLayout> supers = new ArrayList<ClassLayout>();\n+      String className = layout.superName;\n+      while (className != null) {\n+        ClassLayout cl = getClassLayout(className);\n+        supers.add(cl);\n+        className = cl.superName;\n+      }\n+      for (FieldBlock field : layout.nonStaticFields) {\n+        if (field.type == BlockType.INHERITED) {\n+          int i = 0;\n+          boolean found = false;\n+          FieldBlock b = null;\n+          while(i < supers.size() && !found) {\n+            b = supers.get(i).getFieldAtOffset(field.offset, false);\n+            if (b.type != BlockType.INHERITED) found = true;\n+            i++;\n+          }\n+          String location = new String(\" at \" + layout.name + \" offset \" + field.offset());\n+          Asserts.assertTrue(found, \"No declaration found for an inherited field \" + location);\n+          Asserts.assertNotEquals(field.type, BlockType.EMPTY, location);\n+          Asserts.assertEquals(field.size, b.size, location);\n+          Asserts.assertEquals(field.alignment, b.alignment, location );\n+          Asserts.assertEquals(field.name(), b.name(), location);\n+          Asserts.assertEquals(field.signature(), b.signature(), location);\n+        }\n+      }\n+    }\n+  }\n+\n+  static class Node {\n+    ClassLayout classLayout;\n+    Node superClass;\n+    ArrayList<Node> subClasses = new ArrayList<Node>();\n+  }\n+\n+  \/\/ Verify that all fields declared in a class are present in all subclass\n+  void checkSubClasses() {\n+    System.out.println(\"Checking sub-classes\");\n+    \/\/ Generating the class inheritance graph\n+    HashMap<String, Node> nodes = new HashMap<String, Node>();\n+    for (ClassLayout layout : layouts) {\n+      if (layout.name.contains(\"$$Lambda@0\")) continue; \/\/ Skipping lambda classes\n+      Node current = nodes.get(layout.name);\n+      if (current == null) {\n+        current = new Node();\n+        nodes.put(layout.name, current);\n+      }\n+      if (current.classLayout == null) {\n+        current.classLayout = layout;\n+      } else {\n+        System.out.println(current.classLayout.name + \" vs \" + layout.name);\n+        Asserts.assertEQ(current.classLayout, layout);\n+      }\n+      if (layout.superName != null) {\n+        Node superNode = nodes.get(layout.superName);\n+        if (superNode == null) {\n+          superNode = new Node();\n+          superNode.subClasses.add(current);\n+          nodes.put(layout.superName, superNode);\n+        }\n+        superNode.subClasses.add(current);\n+      }\n+    }\n+    \/\/ Field verification\n+    for (Node node : nodes.values()) {\n+      ClassLayout layout = node.classLayout;\n+      System.out.println(\"\\t\" + layout.name);\n+      for (FieldBlock block : layout.nonStaticFields) {\n+        if (block.offset() == 0) continue; \/\/ Skip object header\n+        if (block.type() == BlockType.EMPTY) continue; \/\/ Empty spaces can be used by subclasses\n+        \/\/ A special case for PADDING might be needed too => must NOT be used in subclasses\n+        for (Node subnode : node.subClasses) {\n+          checkFieldInClass(block, subnode);\n+        }\n+      }\n+    }\n+  }\n+\n+  void checkFieldInClass(FieldBlock block, Node node) {\n+    FieldBlock b = node.classLayout.getFieldAtOffset(block.offset, false);\n+    Asserts.assertTrue((block.type != BlockType.NULL_MARKER && block.type != BlockType.INHERITED_NULL_MARKER && b.type == BlockType.INHERITED)\n+                       || ((block.type == BlockType.NULL_MARKER || block.type == BlockType.INHERITED_NULL_MARKER) && b.type == BlockType.INHERITED_NULL_MARKER));\n+    Asserts.assertEquals(b.signature(), block.signature());\n+    Asserts.assertEquals(b.name(), block.name());\n+    Asserts.assertEquals(b.size(), block.size());\n+    Asserts.assertTrue(b.alignment() == block.alignment());\n+    for (Node subnode : node.subClasses) {\n+      checkFieldInClass(block, subnode);\n+    }\n+  }\n+\n+  void checkNullMarkers() {\n+    System.out.println(\"Checking null markers\");\n+    for (ClassLayout layout : layouts) {\n+      System.out.println(\"\\t\" + layout.name);\n+      BlockType last_type = BlockType.RESERVED;\n+      boolean has_empty_slot = false;\n+      for (FieldBlock block : layout.nonStaticFields) {\n+        last_type = block.type;\n+        if (block.type() == BlockType.FLAT && block.nullMarkerOffset() != -1) {\n+          if (block.hasInternalNullMarker()) {\n+            Asserts.assertTrue(block.nullMarkerOffset() > block.offset());\n+            Asserts.assertTrue(block.nullMarkerOffset() < block.offset() + block.size());\n+          } else {\n+            FieldBlock marker = layout.getFieldAtOffset(block.nullMarkerOffset(), false);\n+            Asserts.assertEquals(block.nullMarkerOffset(), marker.offset());\n+          }\n+        }\n+        if (block.type() == BlockType.NULL_MARKER) {\n+          FieldBlock flatField = layout.getFieldAtOffset(block.referenceFieldOffset(), false);\n+          Asserts.assertEquals(flatField.type(), BlockType.FLAT);\n+          Asserts.assertEquals(flatField.nullMarkerOffset(), block.offset());\n+        }\n+        if (block.type() == BlockType.EMPTY) has_empty_slot = true;\n+      }\n+      \/\/ null marker should not be added at the end of the layout if there's an empty slot\n+      Asserts.assertTrue(last_type != BlockType.NULL_MARKER || has_empty_slot == false,\n+                         \"Problem detected in layout of class \" + layout.name);\n+      \/\/ static layout => must not have NULL_MARKERS because static fields are never flat\n+      for (FieldBlock block : layout.staticFields) {\n+        Asserts.assertNotEquals(block.type(), BlockType.NULL_MARKER);\n+        if (block.type() == BlockType.FLAT) {\n+          Asserts.assertEquals(block.nullMarkerOffset(), -1); \/\/ -1 means no null marker\n+        }\n+      }\n+    }\n+  }\n+\n+  void check() {\n+    checkNoOverlap();\n+    checkSizeAndAlignment();\n+    checkInheritedFields();\n+    checkSubClasses();\n+    checkNullMarkers();\n+  }\n+\n+  private void generate(LogOutput lo) {\n+    while (lo.hasMoreLines()) {\n+      if (lo.getCurrentLine().startsWith(\"Layout of class\")) {\n+        ClassLayout cl = ClassLayout.parseClassLayout(lo);\n+        layouts.add(cl);\n+      } else {\n+        lo.moveToNextLine(); \/\/ skipping line\n+      }\n+    }\n+  }\n+ }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldLayoutAnalyzer.java","additions":554,"deletions":0,"binary":false,"changes":554,"status":"added"},{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test id=NullMarker32\n+ * @requires vm.bits == 32\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java NullMarkersTest.java\n+ * @run main\/othervm NullMarkersTest 0\n+ *\/\n+\n+\/*\n+ * @test id=NullMarker64CompressedOops\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java NullMarkersTest.java\n+ * @run main\/othervm NullMarkersTest 1\n+ *\/\n+\n+\/*\n+ * @test id=NullMarker64NoCompressedOops\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java NullMarkersTest.java\n+ * @run main\/othervm NullMarkersTest 2\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NullMarkersTest {\n+\n+\n+  static class TestRunner {\n+    public static void main(String[] args) throws Exception {\n+      Class testClass = Class.forName(\"NullMarkersTest\");\n+      Asserts.assertNotNull(testClass);\n+      Method[] testMethods = testClass.getMethods();\n+      for (Method test : testMethods) {\n+        if (test.getName().startsWith(\"test_\")) {\n+          Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+          Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+          System.out.println(\"Running \" + test.getName());\n+          test.invoke(null);\n+        }\n+      }\n+    }\n+  }\n+\n+  static value class Value0 {\n+    int i = 0;\n+  }\n+\n+  static class Container0 {\n+    Value0 val;\n+  }\n+\n+  \/\/ Simple test with a single nullable flattenable field\n+  static public void test_0() {\n+    Container0 c = new Container0();\n+  }\n+\n+  static public void check_0(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"NullMarkersTest$Container0\");\n+    FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val\", false);\n+    Asserts.assertTrue(f.isFlat());\n+    Asserts.assertTrue(f.hasNullMarker());\n+  }\n+\n+  @ImplicitlyConstructible\n+  static value class Value1 {\n+    short s = 0;\n+  }\n+\n+  static class Container1 {\n+    Value1 val0;\n+    Value1 val1;\n+    @NullRestricted\n+    Value1 val2 = new Value1();\n+  }\n+\n+  static public void test_1() {\n+    Container1 c = new Container1();\n+  }\n+\n+  static public void check_1(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"NullMarkersTest$Container1\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertTrue(f0.isFlat());\n+    Asserts.assertTrue(f0.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    Asserts.assertTrue(f1.isFlat());\n+    Asserts.assertTrue(f1.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock f2 = cl.getFieldFromName(\"val2\", false);\n+    Asserts.assertTrue(f2.isFlat());\n+    Asserts.assertFalse(f2.hasNullMarker());\n+  }\n+\n+  static value class Value2 {\n+    long l = 0;\n+  }\n+\n+  static class Container2a {\n+    Value2 vala;\n+  }\n+\n+  static class Container2b extends Container2a {\n+    Value2 valb;\n+  }\n+\n+  static public void test_2() {\n+    Container2b c = new Container2b();\n+  }\n+\n+  static public void check_2(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cla = fla.getClassLayoutFromName(\"NullMarkersTest$Container2a\");\n+    FieldLayoutAnalyzer.FieldBlock fa = cla.getFieldFromName(\"vala\", false);\n+    Asserts.assertTrue(fa.isFlat());\n+    Asserts.assertTrue(fa.hasNullMarker());\n+    FieldLayoutAnalyzer.ClassLayout clb = fla.getClassLayoutFromName(\"NullMarkersTest$Container2b\");\n+    FieldLayoutAnalyzer.FieldBlock fb = clb.getFieldFromName(\"valb\", false);\n+    Asserts.assertTrue(fb.isFlat());\n+    Asserts.assertTrue(fb.hasNullMarker());\n+  }\n+\n+  @ImplicitlyConstructible\n+  static value class Value3 {\n+    double d = 0.0d;\n+  }\n+\n+  static class Container3a {\n+    @NullRestricted\n+    Value3 val0;\n+    Value3 val1;\n+  }\n+\n+  static class Container3b extends Container3a {\n+    Value3 val2;\n+    @NullRestricted\n+    Value3 val3;\n+  }\n+\n+  static class Container3c extends Container3b {\n+    Value3 val4;\n+    Value3 val5;\n+  }\n+\n+  static public void test_3() {\n+    Container3c c = new Container3c();\n+  }\n+\n+  static public void check_3(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cla = fla.getClassLayoutFromName(\"NullMarkersTest$Container3a\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cla.getFieldFromName(\"val0\", false);\n+    Asserts.assertTrue(f0.isFlat());\n+    Asserts.assertFalse(f0.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cla.getFieldFromName(\"val1\", false);\n+    Asserts.assertTrue(f1.isFlat());\n+    Asserts.assertTrue(f1.hasNullMarker());\n+    FieldLayoutAnalyzer.ClassLayout clb = fla.getClassLayoutFromName(\"NullMarkersTest$Container3b\");\n+    FieldLayoutAnalyzer.FieldBlock f2 = clb.getFieldFromName(\"val2\", false);\n+    Asserts.assertTrue(f2.isFlat());\n+    Asserts.assertTrue(f2.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock f3 = clb.getFieldFromName(\"val3\", false);\n+    Asserts.assertTrue(f3.isFlat());\n+    Asserts.assertFalse(f3.hasNullMarker());\n+    FieldLayoutAnalyzer.ClassLayout clc = fla.getClassLayoutFromName(\"NullMarkersTest$Container3c\");\n+    FieldLayoutAnalyzer.FieldBlock f4 = clc.getFieldFromName(\"val4\", false);\n+    Asserts.assertTrue(f4.isFlat());\n+    Asserts.assertTrue(f4.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock f5 = clc.getFieldFromName(\"val5\", false);\n+    Asserts.assertTrue(f5.isFlat());\n+    Asserts.assertTrue(f5.hasNullMarker());\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value4 {\n+    int i = 0;\n+    byte b = 0;\n+  }\n+\n+  static class Container4 {\n+    Value4 val0;\n+    Value4 val1;\n+  }\n+\n+  static public void test_4() {\n+    Container4 c = new Container4();\n+  }\n+\n+  static void check_4(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"NullMarkersTest$Container4\");\n+    FieldLayoutAnalyzer.FieldBlock f0 = cl.getFieldFromName(\"val0\", false);\n+    Asserts.assertTrue(f0.isFlat());\n+    Asserts.assertTrue(f0.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock f1 = cl.getFieldFromName(\"val1\", false);\n+    Asserts.assertTrue(f1.isFlat());\n+    Asserts.assertTrue(f1.hasNullMarker());\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value5a {\n+    short s = 0;\n+    byte b = 0;\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class Value5b {\n+    @NullRestricted\n+    Value5a val0 = new Value5a();\n+    @NullRestricted\n+    Value5a val1 = new Value5a();\n+  }\n+\n+  static class Container5 {\n+    Value5a vala;\n+    Value5b valb0;\n+    Value5b valb1;\n+  }\n+\n+  static public void test_5() {\n+    Container5 c = new Container5();\n+  }\n+\n+  static void check_5(FieldLayoutAnalyzer fla) {\n+    FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"NullMarkersTest$Container5\");\n+    FieldLayoutAnalyzer.FieldBlock fa = cl.getFieldFromName(\"vala\", false);\n+    Asserts.assertTrue(fa.isFlat());\n+    Asserts.assertTrue(fa.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock fb0 = cl.getFieldFromName(\"valb0\", false);\n+    Asserts.assertTrue(fb0.isFlat());\n+    Asserts.assertTrue(fb0.hasNullMarker());\n+    FieldLayoutAnalyzer.FieldBlock fb1 = cl.getFieldFromName(\"valb1\", false);\n+    Asserts.assertTrue(fb1.isFlat());\n+    Asserts.assertTrue(fb1.hasNullMarker());\n+  }\n+\n+  static ProcessBuilder exec(String compressedOopsArg, String... args) throws Exception {\n+    List<String> argsList = new ArrayList<>();\n+    Collections.addAll(argsList, \"--enable-preview\");\n+    Collections.addAll(argsList, \"-Xint\");\n+    Collections.addAll(argsList, \"-XX:+UnlockDiagnosticVMOptions\");\n+    Collections.addAll(argsList, \"-XX:+PrintFieldLayout\");\n+    if (compressedOopsArg != null) {\n+      Collections.addAll(argsList, compressedOopsArg);\n+    }\n+    Collections.addAll(argsList, \"-Xmx256m\");\n+    Collections.addAll(argsList, \"-XX:+EnableNullableFieldFlattening\");\n+    Collections.addAll(argsList, \"-cp\", System.getProperty(\"java.class.path\") + \":.\");\n+    Collections.addAll(argsList, args);\n+    return ProcessTools.createTestJavaProcessBuilder(argsList);\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    boolean useCompressedOops;\n+    String compressedOopsArg;\n+\n+    switch(args[0]) {\n+      case \"0\": useCompressedOops = false;\n+                compressedOopsArg = null;\n+                break;\n+      case \"1\": useCompressedOops = true;\n+                compressedOopsArg = \"-XX:+UseCompressedOops\";\n+                break;\n+      case \"2\": useCompressedOops = false;\n+                compressedOopsArg = \"-XX:-UseCompressedOops\";\n+                break;\n+      default: throw new RuntimeException(\"Unrecognized configuration\");\n+    }\n+\n+    \/\/ Generate test classes\n+    NullMarkersTest fat = new NullMarkersTest();\n+\n+    \/\/ Execute the test runner in charge of loading all test classes\n+    ProcessBuilder pb = exec(compressedOopsArg, \"NullMarkersTest$TestRunner\");\n+    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+\n+    Asserts.assertEquals(out.getExitValue(), 0, \"Something went wrong while running the tests\");\n+\n+    \/\/ Get and parse the test output\n+    System.out.print(out.getOutput());\n+    FieldLayoutAnalyzer.LogOutput lo = new FieldLayoutAnalyzer.LogOutput(out.asLines());\n+    FieldLayoutAnalyzer fla =  FieldLayoutAnalyzer.createFieldLayoutAnalyzer(lo, useCompressedOops);\n+\n+    \/\/ Running tests verification method (check that tests produced the right configuration)\n+    Class testClass = NullMarkersTest.class;\n+      Method[] testMethods = testClass.getMethods();\n+      for (Method test : testMethods) {\n+        if (test.getName().startsWith(\"check_\")) {\n+          Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+          Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+          test.invoke(null, fla);\n+        }\n+      }\n+\n+    \/\/ Verify that all layouts are correct\n+    fla.check();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/NullMarkersTest.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"}]}