{"files":[{"patch":"@@ -123,1 +123,1 @@\n-          \"Options: none, nop, isb, yield.\")                            \\\n+          \"Options: none, nop, isb, yield, sb.\")                        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7608,0 +7608,3 @@\n+      case SpinWait::SB:\n+        sb();\n+        break;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1263,0 +1263,15 @@\n+void C2_MacroAssembler::vminmax_fp(int opc, BasicType elem_bt, XMMRegister dst, KRegister mask,\n+                                   XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  assert(opc == Op_MinV || opc == Op_MinReductionV ||\n+         opc == Op_MaxV || opc == Op_MaxReductionV, \"sanity\");\n+\n+  int imm8 = (opc == Op_MinV || opc == Op_MinReductionV) ? AVX10_MINMAX_MIN_COMPARE_SIGN\n+                                                         : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+  if (elem_bt == T_FLOAT) {\n+    evminmaxps(dst, mask, src1, src2, true, imm8, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_DOUBLE, \"\");\n+    evminmaxpd(dst, mask, src1, src2, true, imm8, vlen_enc);\n+  }\n+}\n+\n@@ -2570,1 +2585,6 @@\n-    vminmax_fp(opcode, T_FLOAT, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_FLOAT, wdst, k0, wtmp, wsrc, vlen_enc);\n+    } else {\n+      vminmax_fp(opcode, T_FLOAT, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+    }\n@@ -2575,1 +2595,5 @@\n-    vminmax_fp(opcode, T_FLOAT, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_FLOAT, dst, k0, wdst, dst, Assembler::AVX_128bit);\n+    } else {\n+      vminmax_fp(opcode, T_FLOAT, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    }\n@@ -2601,1 +2625,7 @@\n-    vminmax_fp(opcode, T_DOUBLE, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_DOUBLE, wdst, k0, wtmp, wsrc, vlen_enc);\n+    } else {\n+      vminmax_fp(opcode, T_DOUBLE, wdst, wtmp, wsrc, tmp, atmp, btmp, vlen_enc);\n+    }\n+\n@@ -2605,0 +2635,1 @@\n+\n@@ -2606,1 +2637,5 @@\n-    vminmax_fp(opcode, T_DOUBLE, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    if (VM_Version::supports_avx10_2()) {\n+      vminmax_fp(opcode, T_DOUBLE, dst, k0, wdst, dst, Assembler::AVX_128bit);\n+    } else {\n+      vminmax_fp(opcode, T_DOUBLE, dst, wdst, dst, tmp, atmp, btmp, Assembler::AVX_128bit);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  void vminmax_fp(int opc, BasicType elem_bt, XMMRegister dst, KRegister mask,\n+                  XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -9578,0 +9578,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -9593,0 +9597,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n@@ -9608,0 +9616,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxpd(dst, mask, nds, src, merge, AVX10_MINMAX_MIN_COMPARE_SIGN, vector_len); break;\n@@ -9623,0 +9635,4 @@\n+    case T_FLOAT:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n+    case T_DOUBLE:\n+      evminmaxps(dst, mask, nds, src, merge, AVX10_MINMAX_MAX_COMPARE_SIGN, vector_len); break;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2027,1 +2027,1 @@\n-      if (is_floating_point_type(bt)) {\n+      if (is_floating_point_type(bt) && !VM_Version::supports_avx10_2()) {\n@@ -5329,3 +5329,3 @@\n-instruct minmax_reduction2F(legRegF dst, immF src1, legVec src2, legVec tmp,\n-                            legVec atmp, legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+instruct minmax_reduction2F(legRegF dst, immF src1, legVec src2, legVec tmp, legVec atmp,\n+                            legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5352,1 +5352,1 @@\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5371,3 +5371,3 @@\n-instruct minmax_reduction2F_av(legRegF dst, legVec src, legVec tmp,\n-                               legVec atmp, legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+instruct minmax_reduction2F_av(legRegF dst, legVec src, legVec tmp, legVec atmp,\n+                               legVec btmp, legVec xmm_1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5391,3 +5391,3 @@\n-instruct minmax_reductionF_av(legRegF dst, legVec src, legVec tmp,\n-                              legVec atmp, legVec btmp, legVec xmm_0, legVec xmm_1, rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+instruct minmax_reductionF_av(legRegF dst, legVec src, legVec tmp, legVec atmp, legVec btmp,\n+                              legVec xmm_0, legVec xmm_1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n@@ -5410,0 +5410,67 @@\n+instruct minmax_reduction2F_avx10(regF dst, immF src1, vec src2, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeF::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeF::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax_reduction $dst, $src1, $src2 \\t; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceFloatMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister,\n+                         xnoreg, xnoreg, xnoreg, $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionF_avx10(regF dst, immF src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeF::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeF::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmax_reduction $dst, $src1, $src2 \\t; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceFloatMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg,\n+                         xnoreg, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reduction2F_avx10_av(regF dst, vec src, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax2F_reduction $dst, $src \\t; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceFloatMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg,\n+                         $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionF_avx10_av(regF dst, vec src, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_FLOAT &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmax2F_reduction $dst, $src \\t; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceFloatMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg,\n+                         $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -5412,4 +5479,3 @@\n-instruct minmax_reduction2D(legRegD dst, immD src1, legVec src2,\n-                            legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, \/\/ TEMPs\n-                            rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reduction2D(legRegD dst, immD src1, legVec src2, legVec tmp1, legVec tmp2,\n+                            legVec tmp3, legVec tmp4, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5434,4 +5500,3 @@\n-instruct minmax_reductionD(legRegD dst, immD src1, legVec src2,\n-                           legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, legVec tmp5, \/\/ TEMPs\n-                           rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reductionD(legRegD dst, immD src1, legVec src2, legVec tmp1, legVec tmp2,\n+                           legVec tmp3, legVec tmp4, legVec tmp5, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5457,4 +5522,3 @@\n-instruct minmax_reduction2D_av(legRegD dst, legVec src,\n-                               legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, \/\/ TEMPs\n-                               rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reduction2D_av(legRegD dst, legVec src, legVec tmp1, legVec tmp2,\n+                               legVec tmp3, legVec tmp4, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5477,4 +5541,3 @@\n-instruct minmax_reductionD_av(legRegD dst, legVec src,\n-                              legVec tmp1, legVec tmp2, legVec tmp3, legVec tmp4, legVec tmp5, \/\/ TEMPs\n-                              rFlagsReg cr) %{\n-  predicate(Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+instruct minmax_reductionD_av(legRegD dst, legVec src, legVec tmp1, legVec tmp2, legVec tmp3,\n+                              legVec tmp4, legVec tmp5, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n@@ -5497,0 +5560,69 @@\n+instruct minmax_reduction2D_avx10(regD dst, immD src1, vec src2, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeD::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeD::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax2D_reduction $dst, $src1, $src2 ; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceDoubleMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister, xnoreg,\n+                          xnoreg, xnoreg, $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionD_avx10(regD dst, immD src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            ((n->Opcode() == Op_MinReductionV && n->in(1)->bottom_type() == TypeD::POS_INF) ||\n+             (n->Opcode() == Op_MaxReductionV && n->in(1)->bottom_type() == TypeD::NEG_INF)) &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV src1 src2));\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmaxD_reduction $dst, $src1, $src2 ; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src2);\n+    __ reduceDoubleMinMax(opcode, vlen, false, $dst$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg,\n+                          xnoreg, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+instruct minmax_reduction2D_av_avx10(regD dst, vec src, vec xtmp1) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            Matcher::vector_length(n->in(2)) == 2);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1);\n+  format %{ \"vector_minmax2D_reduction $dst, $src ; using $xtmp1 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceDoubleMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister,\n+                          xnoreg, xnoreg, xnoreg, $xtmp1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct minmax_reductionD_av_avx10(regD dst, vec src, vec xtmp1, vec xtmp2) %{\n+  predicate(VM_Version::supports_avx10_2() && Matcher::vector_element_basic_type(n->in(2)) == T_DOUBLE &&\n+            Matcher::vector_length(n->in(2)) >= 4);\n+  match(Set dst (MinReductionV dst src));\n+  match(Set dst (MaxReductionV dst src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_minmaxD_reduction $dst, $src ; using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen = Matcher::vector_length(this, $src);\n+    __ reduceDoubleMinMax(opcode, vlen, true, $dst$$XMMRegister, $src$$XMMRegister,\n+                          xnoreg, xnoreg, xnoreg, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6383,0 +6515,16 @@\n+\/\/ Float\/Double vector Min\/Max\n+instruct minmaxFP_avx10_reg(vec dst, vec a, vec b) %{\n+  predicate(VM_Version::supports_avx10_2() &&\n+            is_floating_point_type(Matcher::vector_element_basic_type(n))); \/\/ T_FLOAT, T_DOUBLE\n+  match(Set dst (MinV a b));\n+  match(Set dst (MaxV a b));\n+  format %{ \"vector_minmaxFP  $dst, $a, $b\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int opcode = this->ideal_Opcode();\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vminmax_fp(opcode, elem_bt, $dst$$XMMRegister, k0, $a$$XMMRegister, $b$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -6385,1 +6533,1 @@\n-  predicate(Matcher::vector_length_in_bytes(n) <= 32 &&\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_length_in_bytes(n) <= 32 &&\n@@ -6406,2 +6554,2 @@\n-instruct evminmaxFP_reg_eavx(vec dst, vec a, vec b, vec atmp, vec btmp, kReg ktmp) %{\n-  predicate(Matcher::vector_length_in_bytes(n) == 64 &&\n+instruct evminmaxFP_reg_evex(vec dst, vec a, vec b, vec atmp, vec btmp, kReg ktmp) %{\n+  predicate(!VM_Version::supports_avx10_2() && Matcher::vector_length_in_bytes(n) == 64 &&\n@@ -10722,0 +10870,13 @@\n+instruct scalar_minmax_HF_avx10_reg(regF dst, regF src1, regF src2)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  format %{ \"scalar_min_max_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int function = this->ideal_Opcode() == Op_MinHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    __ eminmaxsh($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, function);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10724,0 +10885,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n@@ -10823,0 +10985,28 @@\n+instruct vector_minmax_HF_avx10_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinVHF src1 (VectorReinterpret (LoadVector src2))));\n+  match(Set dst (MaxVHF src1 (VectorReinterpret (LoadVector src2))));\n+  format %{ \"vector_min_max_fp16_mem $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    __ evminmaxph($dst$$XMMRegister, k0, $src1$$XMMRegister, $src2$$Address, true, function, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_minmax_HF_avx10_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinVHF src1 src2));\n+  match(Set dst (MaxVHF src1 src2));\n+  format %{ \"vector_min_max_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    int function =  this->ideal_Opcode() == Op_MinVHF ? AVX10_MINMAX_MIN_COMPARE_SIGN : AVX10_MINMAX_MAX_COMPARE_SIGN;\n+    __ evminmaxph($dst$$XMMRegister, k0, $src1$$XMMRegister, $src2$$XMMRegister, true, function, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10825,0 +11015,1 @@\n+  predicate(!VM_Version::supports_avx10_2());\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":221,"deletions":30,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -4478,0 +4478,11 @@\n+\/\/ max = java.lang.Math.max(float a, float b)\n+instruct maxF_avx10_reg(regF dst, regF a, regF b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxF a b));\n+  format %{ \"maxF $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4480,1 +4491,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4491,1 +4502,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4503,0 +4514,11 @@\n+\/\/ max = java.lang.Math.max(double a, double b)\n+instruct maxD_avx10_reg(regD dst, regD a, regD b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MaxD a b));\n+  format %{ \"maxD $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MAX_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4505,1 +4527,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4516,1 +4538,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4528,0 +4550,11 @@\n+\/\/ max = java.lang.Math.min(float a, float b)\n+instruct minF_avx10_reg(regF dst, regF a, regF b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinF a b));\n+  format %{ \"minF $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxss($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4530,1 +4563,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4541,1 +4574,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -4553,0 +4586,11 @@\n+\/\/ max = java.lang.Math.min(double a, double b)\n+instruct minD_avx10_reg(regD dst, regD a, regD b) %{\n+  predicate(VM_Version::supports_avx10_2());\n+  match(Set dst (MinD a b));\n+  format %{ \"minD $dst, $a, $b\" %}\n+  ins_encode %{\n+    __ eminmaxsd($dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, AVX10_MINMAX_MIN_COMPARE_SIGN);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4555,1 +4599,1 @@\n-  predicate(UseAVX > 0 && !VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && !VLoopReductions::is_reduction(n));\n@@ -4566,1 +4610,1 @@\n-  predicate(UseAVX > 0 && VLoopReductions::is_reduction(n));\n+  predicate(!VM_Version::supports_avx10_2() && UseAVX > 0 && VLoopReductions::is_reduction(n));\n@@ -6433,1 +6477,1 @@\n-instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2) \n+instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2)\n@@ -6816,1 +6860,1 @@\n-instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2) \n+instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2)\n@@ -6923,1 +6967,1 @@\n-instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2) \n+instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2)\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":55,"deletions":11,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -578,0 +578,3 @@\n+      if (RegeneratedClasses::has_been_regenerated(klass)) {\n+        klass = RegeneratedClasses::get_regenerated_object(klass);\n+      }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -546,0 +547,4 @@\n+      Klass* k = java_lang_Class::as_Klass(source_referent);\n+      if (RegeneratedClasses::has_been_regenerated(k)) {\n+        source_referent = RegeneratedClasses::get_regenerated_object(k)->java_mirror();\n+      }\n@@ -759,0 +764,5 @@\n+\n+    if (RegeneratedClasses::has_been_regenerated(native_ptr)) {\n+      native_ptr = RegeneratedClasses::get_regenerated_object(native_ptr);\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -841,3 +841,0 @@\n-  } else if (CDSConfig::is_dumping_method_handles()) {\n-    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n-    return false;\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -340,0 +341,3 @@\n+          if (RegeneratedClasses::has_been_regenerated(m)) {\n+            m = RegeneratedClasses::get_regenerated_object(m);\n+          }\n@@ -509,3 +513,9 @@\n-  oop orig_mirror = ik->java_mirror();\n-  oop m = scratch_java_mirror(ik);\n-  assert(ik->is_initialized(), \"must be\");\n+  oop orig_mirror;\n+  if (RegeneratedClasses::is_regenerated_object(ik)) {\n+    InstanceKlass* orig_ik = RegeneratedClasses::get_original_object(ik);\n+    precond(orig_ik->is_initialized());\n+    orig_mirror = orig_ik->java_mirror();\n+  } else {\n+    precond(ik->is_initialized());\n+    orig_mirror = ik->java_mirror();\n+  }\n@@ -513,0 +523,1 @@\n+  oop m = scratch_java_mirror(ik);\n@@ -1527,0 +1538,7 @@\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    Klass* k = java_lang_Class::as_Klass(orig_obj);\n+    if (RegeneratedClasses::has_been_regenerated(k)) {\n+      orig_obj = RegeneratedClasses::get_regenerated_object(k)->java_mirror();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -842,1 +842,0 @@\n-        vm_exit(0);\n@@ -845,1 +844,1 @@\n-        vm_exit(0);\n+      vm_direct_exit(0);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"oops\/jmethodIDTable.hpp\"\n@@ -592,0 +593,27 @@\n+void ClassLoaderData::add_jmethod_id(jmethodID mid) {\n+  MutexLocker m1(metaspace_lock(), Mutex::_no_safepoint_check_flag);\n+  if (_jmethod_ids == nullptr) {\n+    _jmethod_ids = new (mtClass) GrowableArray<jmethodID>(32, mtClass);\n+  }\n+  _jmethod_ids->push(mid);\n+}\n+\n+\/\/ Method::remove_jmethod_ids removes jmethodID entries from the table which\n+\/\/ releases memory.\n+\/\/ Because native code (e.g., JVMTI agent) holding jmethod_ids may access them\n+\/\/ after the associated classes and class loader are unloaded, subsequent lookups\n+\/\/ for these ids will return null since they are no longer found in the table.\n+\/\/ The Java Native Interface Specification says \"method ID\n+\/\/ does not prevent the VM from unloading the class from which the ID has\n+\/\/ been derived. After the class is unloaded, the method or field ID becomes\n+\/\/ invalid\".\n+void ClassLoaderData::remove_jmethod_ids() {\n+  MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n+  for (int i = 0; i < _jmethod_ids->length(); i++) {\n+    jmethodID mid = _jmethod_ids->at(i);\n+    JmethodIDTable::remove(mid);\n+  }\n+  delete _jmethod_ids;\n+  _jmethod_ids = nullptr;\n+}\n+\n@@ -615,12 +643,1 @@\n-  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to null without\n-  \/\/ releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.\n-  \/\/ This is done intentionally because native code (e.g. JVMTI agent) holding\n-  \/\/ jmethod_ids may access them after the associated classes and class loader\n-  \/\/ are unloaded. The Java Native Interface Specification says \"method ID\n-  \/\/ does not prevent the VM from unloading the class from which the ID has\n-  \/\/ been derived. After the class is unloaded, the method or field ID becomes\n-  \/\/ invalid\". In real world usages, the native code may rely on jmethod_ids\n-  \/\/ being null after class unloading. Hence, it is unsafe to free the memory\n-  \/\/ from the VM side without knowing when native code is going to stop using\n-  \/\/ them.\n-    Method::clear_jmethod_ids(this);\n+    remove_jmethod_ids();\n@@ -1057,3 +1074,1 @@\n-    out->print   (\" - jmethod count       \");\n-    Method::print_jmethod_ids_count(this, out);\n-    out->print_cr(\"\");\n+    out->print_cr(\" - jmethod count       %d\", _jmethod_ids->length());\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":30,"deletions":15,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,0 @@\n-class JNIMethodBlock;\n@@ -146,4 +145,3 @@\n-  \/\/ These method IDs are created for the class loader and set to null when the\n-  \/\/ class loader is unloaded.  They are rarely freed, only for redefine classes\n-  \/\/ and if they lose a data race in InstanceKlass.\n-  JNIMethodBlock*                  _jmethod_ids;\n+  \/\/ These method IDs are created for the class loader and removed when the\n+  \/\/ class loader is unloaded.\n+  GrowableArray<jmethodID>*        _jmethod_ids;\n@@ -320,2 +318,3 @@\n-  JNIMethodBlock* jmethod_ids() const              { return _jmethod_ids; }\n-  void set_jmethod_ids(JNIMethodBlock* new_block)  { _jmethod_ids = new_block; }\n+  void add_jmethod_id(jmethodID id);\n+  void remove_jmethod_ids();\n+  GrowableArray<jmethodID>* jmethod_ids() const { return _jmethod_ids; }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1930,1 +1930,1 @@\n-  class GetStackTraceClosure : public HandshakeClosure {\n+  class GetStackTraceHandshakeClosure : public HandshakeClosure {\n@@ -1938,2 +1938,2 @@\n-    GetStackTraceClosure(Handle java_thread) :\n-        HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n+    GetStackTraceHandshakeClosure(Handle java_thread) :\n+        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n@@ -1942,1 +1942,1 @@\n-    ~GetStackTraceClosure() {\n+    ~GetStackTraceHandshakeClosure() {\n@@ -2008,1 +2008,1 @@\n-  GetStackTraceClosure gstc(Handle(THREAD, java_thread));\n+  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, java_thread));\n@@ -2010,2 +2010,2 @@\n-   Handshake::execute(&gstc, &tlh, thread);\n-  } while (gstc.read_reset_retry());\n+   Handshake::execute(&gsthc, &tlh, thread);\n+  } while (gsthc.read_reset_retry());\n@@ -2014,1 +2014,1 @@\n-  if (gstc._depth == 0) {\n+  if (gsthc._depth == 0) {\n@@ -2024,1 +2024,1 @@\n-  objArrayHandle trace = oopFactory::new_objArray_handle(k, gstc._depth, CHECK_NULL);\n+  objArrayHandle trace = oopFactory::new_objArray_handle(k, gsthc._depth, CHECK_NULL);\n@@ -2026,2 +2026,2 @@\n-  for (int i = 0; i < gstc._depth; i++) {\n-    methodHandle method(THREAD, gstc._methods->at(i));\n+  for (int i = 0; i < gsthc._depth; i++) {\n+    methodHandle method(THREAD, gsthc._methods->at(i));\n@@ -2029,1 +2029,1 @@\n-                                                      gstc._bcis->at(i),\n+                                                      gsthc._bcis->at(i),\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1501,0 +1501,3 @@\n+  if (_stubs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _stubs_addr);\n+  }\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -211,0 +211,2 @@\n+    _mutable_data_size = 0;\n+    _relocation_size = 0;\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    st->verify();\n+    if (VerifyInlineCaches) st->verify();\n@@ -201,1 +201,1 @@\n-    st->verify();\n+    if (VerifyInlineCaches) st->verify();\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1957,0 +1957,8 @@\n+#if INCLUDE_JVMCI\n+  \/\/ Deoptimization count is used by the CompileBroker to reason about compilations\n+  \/\/ it requests so do not pollute the count for deoptimizations in non-default (i.e.\n+  \/\/ non-CompilerBroker) compilations.\n+  if (is_jvmci_hosted()) {\n+    return;\n+  }\n+#endif\n@@ -2178,0 +2186,1 @@\n+  JVMCI_ONLY( _metadata_size = 0; )\n@@ -3485,0 +3494,3 @@\n+    st->bol();\n+    st->cr();\n+    st->print_cr(\"Loading hsdis library failed, undisassembled code is shown in MachCode section\");\n@@ -3519,0 +3531,3 @@\n+    st->bol();\n+    st->cr();\n+    st->print_cr(\"Loading hsdis library failed, undisassembled code is shown in MachCode section\");\n@@ -4114,0 +4129,4 @@\n+\n+bool nmethod::is_jvmci_hosted() const {\n+  return jvmci_nmethod_data() != nullptr && !jvmci_nmethod_data()->is_default();\n+}\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -934,0 +934,4 @@\n+\n+  \/\/ Returns true if a JVMCI compiled method is non-default,\n+  \/\/ i.e., not triggered by CompilerBroker\n+  bool is_jvmci_hosted() const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1314,2 +1314,1 @@\n-    ref_processor()->set_active_mt_degree(active_gc_threads);\n-    stats = ref_processor()->process_discovered_references(task, pt);\n+    stats = ref_processor()->process_discovered_references(task, &ParallelScavengeHeap::heap()->workers(), pt);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -502,1 +502,1 @@\n-    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, pt);\n+    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, nullptr, pt);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-class ZMarkFlushStacksClosure : public HandshakeClosure {\n+class ZMarkFlushStacksHandshakeClosure : public HandshakeClosure {\n@@ -541,1 +541,1 @@\n-  ZMarkFlushStacksClosure(ZMark* mark)\n+  ZMarkFlushStacksHandshakeClosure(ZMark* mark)\n@@ -588,1 +588,1 @@\n-  ZMarkFlushStacksClosure cl(this);\n+  ZMarkFlushStacksHandshakeClosure cl(this);\n@@ -959,1 +959,1 @@\n-  ZMarkFlushStacksClosure cl(this);\n+  ZMarkFlushStacksHandshakeClosure cl(this);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -598,0 +598,4 @@\n+    if (log_is_enabled(Info, exceptions, stacktrace)) {\n+      Exceptions::log_exception_stacktrace(h_exception, h_method, current_bci);\n+    }\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"oops\/jmethodIDTable.hpp\"\n@@ -442,0 +443,3 @@\n+    \/\/ Initialize table for matching jmethodID, before SystemDictionary.\n+    JmethodIDTable::initialize();\n+\n@@ -450,1 +454,0 @@\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2693,0 +2693,18 @@\n+\/\/ Allocate the jmethodID cache.\n+static jmethodID* create_jmethod_id_cache(size_t size) {\n+  jmethodID* jmeths = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n+  memset(jmeths, 0, (size + 1) * sizeof(jmethodID));\n+  \/\/ cache size is stored in element[0], other elements offset by one\n+  jmeths[0] = (jmethodID)size;\n+  return jmeths;\n+}\n+\n+\/\/ When reading outside a lock, use this.\n+jmethodID* InstanceKlass::methods_jmethod_ids_acquire() const {\n+  return Atomic::load_acquire(&_methods_jmethod_ids);\n+}\n+\n+void InstanceKlass::release_set_methods_jmethod_ids(jmethodID* jmeths) {\n+  Atomic::release_store(&_methods_jmethod_ids, jmeths);\n+}\n+\n@@ -2694,6 +2712,1 @@\n-\/\/ This code is called by the VMThread and JavaThreads so the\n-\/\/ locking has to be done very carefully to avoid deadlocks\n-\/\/ and\/or other cache consistency problems.\n-\/\/\n-jmethodID InstanceKlass::get_jmethod_id(const methodHandle& method_h) {\n-  Method* method = method_h();\n+jmethodID InstanceKlass::get_jmethod_id(Method* method) {\n@@ -2720,1 +2733,1 @@\n-    jmeths = methods_jmethod_ids_acquire();\n+    jmeths = _methods_jmethod_ids;\n@@ -2725,4 +2738,1 @@\n-      jmeths = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n-      memset(jmeths, 0, (size + 1) * sizeof(jmethodID));\n-      \/\/ cache size is stored in element[0], other elements offset by one\n-      jmeths[0] = (jmethodID)size;\n+      jmeths = create_jmethod_id_cache(size);\n@@ -2758,4 +2768,1 @@\n-      jmethodID* new_cache = NEW_C_HEAP_ARRAY(jmethodID, size + 1, mtClass);\n-      memset(new_cache, 0, (size + 1) * sizeof(jmethodID));\n-      \/\/ The cache size is stored in element[0]; the other elements are offset by one.\n-      new_cache[0] = (jmethodID)size;\n+      jmethodID* new_cache = create_jmethod_id_cache(size);\n@@ -2772,3 +2779,2 @@\n-\/\/ Figure out how many jmethodIDs haven't been allocated, and make\n-\/\/ sure space for them is pre-allocated.  This makes getting all\n-\/\/ method ids much, much faster with classes with more than 8\n+\/\/ Make a jmethodID for all methods in this class.  This makes getting all method\n+\/\/ ids much, much faster with classes with more than 8\n@@ -2777,2 +2783,8 @@\n-void InstanceKlass::ensure_space_for_methodids(int start_offset) {\n-  int new_jmeths = 0;\n+void InstanceKlass::make_methods_jmethod_ids() {\n+  MutexLocker ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n+  jmethodID* jmeths = _methods_jmethod_ids;\n+  if (jmeths == nullptr) {\n+    jmeths = create_jmethod_id_cache(idnum_allocated_count());\n+    release_set_methods_jmethod_ids(jmeths);\n+  }\n+\n@@ -2780,1 +2792,1 @@\n-  for (int index = start_offset; index < length; index++) {\n+  for (int index = 0; index < length; index++) {\n@@ -2782,3 +2794,7 @@\n-    jmethodID id = m->find_jmethod_id_or_null();\n-    if (id == nullptr) {\n-      new_jmeths++;\n+    int idnum = m->method_idnum();\n+    assert(!m->is_old(), \"should not have old methods or I'm confused\");\n+    jmethodID id = Atomic::load_acquire(&jmeths[idnum + 1]);\n+    if (!m->is_overpass() &&  \/\/ skip overpasses\n+        id == nullptr) {\n+      id = Method::make_jmethod_id(class_loader_data(), m);\n+      Atomic::release_store(&jmeths[idnum + 1], id);\n@@ -2787,3 +2803,0 @@\n-  if (new_jmeths != 0) {\n-    Method::ensure_jmethod_ids(class_loader_data(), new_jmeths);\n-  }\n@@ -3233,1 +3246,1 @@\n-  jmethodID* jmeths = methods_jmethod_ids_acquire();\n+  jmethodID* jmeths = _methods_jmethod_ids;\n@@ -4635,8 +4648,4 @@\n-\/\/ This nulls out jmethodIDs for all methods in 'klass'\n-\/\/ It needs to be called explicitly for all previous versions of a class because these may not be cleaned up\n-\/\/ during class unloading.\n-\/\/ We can not use the jmethodID cache associated with klass directly because the 'previous' versions\n-\/\/ do not have the jmethodID cache filled in. Instead, we need to lookup jmethodID for each method and this\n-\/\/ is expensive - O(n) for one jmethodID lookup. For all contained methods it is O(n^2).\n-\/\/ The reason for expensive jmethodID lookup for each method is that there is no direct link between method and jmethodID.\n-void InstanceKlass::clear_jmethod_ids(InstanceKlass* klass) {\n+\/\/ This nulls out the jmethodID for all obsolete methods in the previous version of the 'klass'.\n+\/\/ These obsolete methods only exist in the previous version and we're about to delete the memory for them.\n+\/\/ The jmethodID for these are deallocated when we unload the class, so this doesn't remove them from the table.\n+void InstanceKlass::clear_obsolete_jmethod_ids(InstanceKlass* klass) {\n@@ -4646,0 +4655,1 @@\n+    \/\/ Only need to clear obsolete methods.\n@@ -4695,1 +4705,1 @@\n-      clear_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n+      clear_obsolete_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":47,"deletions":37,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -537,0 +537,3 @@\n+  InstanceKlass* nest_host_or_null() {\n+    return _nest_host;\n+  }\n@@ -889,2 +892,2 @@\n-  jmethodID get_jmethod_id(const methodHandle& method_h);\n-  void ensure_space_for_methodids(int start_offset = 0);\n+  jmethodID get_jmethod_id(Method* method);\n+  void make_methods_jmethod_ids();\n@@ -1190,4 +1193,4 @@\n-  inline jmethodID* methods_jmethod_ids_acquire() const;\n-  inline void release_set_methods_jmethod_ids(jmethodID* jmeths);\n-  \/\/ This nulls out jmethodIDs for all methods in 'klass'\n-  static void clear_jmethod_ids(InstanceKlass* klass);\n+  jmethodID* methods_jmethod_ids_acquire() const;\n+  void release_set_methods_jmethod_ids(jmethodID* jmeths);\n+  \/\/ This nulls out obsolete jmethodIDs for all methods in 'klass'.\n+  static void clear_obsolete_jmethod_ids(InstanceKlass* klass);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,8 +89,0 @@\n-inline jmethodID* InstanceKlass::methods_jmethod_ids_acquire() const {\n-  return Atomic::load_acquire(&_methods_jmethod_ids);\n-}\n-\n-inline void InstanceKlass::release_set_methods_jmethod_ids(jmethodID* jmeths) {\n-  Atomic::release_store(&_methods_jmethod_ids, jmeths);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"oops\/jmethodIDTable.hpp\"\n@@ -2127,146 +2128,3 @@\n-\n-\/\/ This is a block allocating object, sort of like JNIHandleBlock, only a\n-\/\/ lot simpler.\n-\/\/ It's allocated on the CHeap because once we allocate a jmethodID, we can\n-\/\/ never get rid of it.\n-\n-static const int min_block_size = 8;\n-\n-class JNIMethodBlockNode : public CHeapObj<mtClass> {\n-  friend class JNIMethodBlock;\n-  Method**        _methods;\n-  int             _number_of_methods;\n-  int             _top;\n-  JNIMethodBlockNode* _next;\n-\n- public:\n-\n-  JNIMethodBlockNode(int num_methods = min_block_size);\n-\n-  ~JNIMethodBlockNode() { FREE_C_HEAP_ARRAY(Method*, _methods); }\n-\n-  void ensure_methods(int num_addl_methods) {\n-    if (_top < _number_of_methods) {\n-      num_addl_methods -= _number_of_methods - _top;\n-      if (num_addl_methods <= 0) {\n-        return;\n-      }\n-    }\n-    if (_next == nullptr) {\n-      _next = new JNIMethodBlockNode(MAX2(num_addl_methods, min_block_size));\n-    } else {\n-      _next->ensure_methods(num_addl_methods);\n-    }\n-  }\n-};\n-\n-class JNIMethodBlock : public CHeapObj<mtClass> {\n-  JNIMethodBlockNode _head;\n-  JNIMethodBlockNode *_last_free;\n- public:\n-  static Method* const _free_method;\n-\n-  JNIMethodBlock(int initial_capacity = min_block_size)\n-      : _head(initial_capacity), _last_free(&_head) {}\n-\n-  void ensure_methods(int num_addl_methods) {\n-    _last_free->ensure_methods(num_addl_methods);\n-  }\n-\n-  Method** add_method(Method* m) {\n-    for (JNIMethodBlockNode* b = _last_free; b != nullptr; b = b->_next) {\n-      if (b->_top < b->_number_of_methods) {\n-        \/\/ top points to the next free entry.\n-        int i = b->_top;\n-        b->_methods[i] = m;\n-        b->_top++;\n-        _last_free = b;\n-        return &(b->_methods[i]);\n-      } else if (b->_top == b->_number_of_methods) {\n-        \/\/ if the next free entry ran off the block see if there's a free entry\n-        for (int i = 0; i < b->_number_of_methods; i++) {\n-          if (b->_methods[i] == _free_method) {\n-            b->_methods[i] = m;\n-            _last_free = b;\n-            return &(b->_methods[i]);\n-          }\n-        }\n-        \/\/ Only check each block once for frees.  They're very unlikely.\n-        \/\/ Increment top past the end of the block.\n-        b->_top++;\n-      }\n-      \/\/ need to allocate a next block.\n-      if (b->_next == nullptr) {\n-        b->_next = _last_free = new JNIMethodBlockNode();\n-      }\n-    }\n-    guarantee(false, \"Should always allocate a free block\");\n-    return nullptr;\n-  }\n-\n-  bool contains(Method** m) {\n-    if (m == nullptr) return false;\n-    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n-      if (b->_methods <= m && m < b->_methods + b->_number_of_methods) {\n-        \/\/ This is a bit of extra checking, for two reasons.  One is\n-        \/\/ that contains() deals with pointers that are passed in by\n-        \/\/ JNI code, so making sure that the pointer is aligned\n-        \/\/ correctly is valuable.  The other is that <= and > are\n-        \/\/ technically not defined on pointers, so the if guard can\n-        \/\/ pass spuriously; no modern compiler is likely to make that\n-        \/\/ a problem, though (and if one did, the guard could also\n-        \/\/ fail spuriously, which would be bad).\n-        ptrdiff_t idx = m - b->_methods;\n-        if (b->_methods + idx == m) {\n-          return true;\n-        }\n-      }\n-    }\n-    return false;  \/\/ not found\n-  }\n-\n-  \/\/ During class unloading the methods are cleared, which is different\n-  \/\/ than freed.\n-  void clear_all_methods() {\n-    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n-      for (int i = 0; i< b->_number_of_methods; i++) {\n-        b->_methods[i] = nullptr;\n-      }\n-    }\n-  }\n-#ifndef PRODUCT\n-  int count_methods() {\n-    \/\/ count all allocated methods\n-    int count = 0;\n-    for (JNIMethodBlockNode* b = &_head; b != nullptr; b = b->_next) {\n-      for (int i = 0; i< b->_number_of_methods; i++) {\n-        if (b->_methods[i] != _free_method) count++;\n-      }\n-    }\n-    return count;\n-  }\n-#endif \/\/ PRODUCT\n-};\n-\n-\/\/ Something that can't be mistaken for an address or a markWord\n-Method* const JNIMethodBlock::_free_method = (Method*)55;\n-\n-JNIMethodBlockNode::JNIMethodBlockNode(int num_methods) : _top(0), _next(nullptr) {\n-  _number_of_methods = MAX2(num_methods, min_block_size);\n-  _methods = NEW_C_HEAP_ARRAY(Method*, _number_of_methods, mtInternal);\n-  for (int i = 0; i < _number_of_methods; i++) {\n-    _methods[i] = JNIMethodBlock::_free_method;\n-  }\n-}\n-\n-void Method::ensure_jmethod_ids(ClassLoaderData* cld, int capacity) {\n-  \/\/ Have to add jmethod_ids() to class loader data thread-safely.\n-  \/\/ Also have to add the method to the list safely, which the lock\n-  \/\/ protects as well.\n-  MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n-  if (cld->jmethod_ids() == nullptr) {\n-    cld->set_jmethod_ids(new JNIMethodBlock(capacity));\n-  } else {\n-    cld->jmethod_ids()->ensure_methods(capacity);\n-  }\n-}\n+\/\/ jmethodIDs are 64-bit integers that will never run out and are mapped in a table\n+\/\/ to their Method and vice versa.  If JNI code has access to stale jmethodID, this\n+\/\/ wastes no memory but the Method* returned is null.\n@@ -2277,1 +2135,1 @@\n-  \/\/ Also have to add the method to the list safely, which the lock\n+  \/\/ Also have to add the method to the InstanceKlass list safely, which the lock\n@@ -2280,0 +2138,2 @@\n+  jmethodID jmid = JmethodIDTable::make_jmethod_id(m);\n+  assert(jmid != nullptr, \"must be created\");\n@@ -2281,7 +2141,3 @@\n-  ResourceMark rm;\n-  log_debug(jmethod)(\"Creating jmethodID for Method %s\", m->external_name());\n-  if (cld->jmethod_ids() == nullptr) {\n-    cld->set_jmethod_ids(new JNIMethodBlock());\n-  }\n-  \/\/ jmethodID is a pointer to Method*\n-  return (jmethodID)cld->jmethod_ids()->add_method(m);\n+  \/\/ Add to growable array in CLD.\n+  cld->add_jmethod_id(jmid);\n+  return jmid;\n@@ -2290,0 +2146,1 @@\n+\/\/ This looks in the InstanceKlass cache, then calls back to make_jmethod_id if not found.\n@@ -2291,2 +2148,7 @@\n-  methodHandle mh(Thread::current(), this);\n-  return method_holder()->get_jmethod_id(mh);\n+  return method_holder()->get_jmethod_id(this);\n+}\n+\n+\/\/ Get the Method out of the table given the method id.\n+Method* Method::resolve_jmethod_id(jmethodID mid) {\n+  assert(mid != nullptr, \"JNI method id should not be null\");\n+  return JmethodIDTable::resolve_jmethod_id(mid);\n@@ -2300,1 +2162,1 @@\n-           new_method->method_holder()->class_loader() == nullptr, \/\/ allow Unsafe substitution\n+         new_method->method_holder()->class_loader() == nullptr, \/\/ allow substitution to Unsafe method\n@@ -2302,2 +2164,1 @@\n-  \/\/ Just change the method in place, jmethodID pointer doesn't change.\n-  *((Method**)jmid) = new_method;\n+  JmethodIDTable::change_method_associated_with_jmethod_id(jmid, new_method);\n@@ -2306,1 +2167,11 @@\n-bool Method::is_method_id(jmethodID mid) {\n+\/\/ If there's a jmethodID for this method, clear the Method\n+\/\/ but leave jmethodID for this method in the table.\n+\/\/ It's deallocated with class unloading.\n+void Method::clear_jmethod_id() {\n+  jmethodID mid = method_holder()->jmethod_id_or_null(this);\n+  if (mid != nullptr) {\n+    JmethodIDTable::clear_jmethod_id(mid, this);\n+  }\n+}\n+\n+bool Method::validate_jmethod_id(jmethodID mid) {\n@@ -2312,1 +2183,1 @@\n-  return (cld->jmethod_ids()->contains((Method**)mid));\n+  return (cld->jmethod_ids()->contains(mid));\n@@ -2318,1 +2189,1 @@\n-  if (o == nullptr || o == JNIMethodBlock::_free_method) {\n+  if (o == nullptr) {\n@@ -2327,1 +2198,1 @@\n-};\n+}\n@@ -2348,19 +2219,0 @@\n-\/\/ Called when the class loader is unloaded to make all methods weak.\n-void Method::clear_jmethod_ids(ClassLoaderData* loader_data) {\n-  loader_data->jmethod_ids()->clear_all_methods();\n-}\n-\n-void Method::clear_jmethod_id() {\n-  \/\/ Being at a safepoint prevents racing against other class redefinitions\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n-  \/\/ The jmethodID is not stored in the Method instance, we need to look it up first\n-  jmethodID methodid = find_jmethod_id_or_null();\n-  \/\/ We need to make sure that jmethodID actually resolves to this method\n-  \/\/ - multiple redefined versions may share jmethodID slots and if a method\n-  \/\/   has already been rewired to a newer version we could be removing reference\n-  \/\/   to a still existing method instance\n-  if (methodid != nullptr && *((Method**)methodid) == this) {\n-    *((Method**)methodid) = nullptr;\n-  }\n-}\n-\n@@ -2416,7 +2268,0 @@\n-#ifndef PRODUCT\n-void Method::print_jmethod_ids_count(const ClassLoaderData* loader_data, outputStream* out) {\n-  out->print(\"%d\", loader_data->jmethod_ids()->count_methods());\n-}\n-#endif \/\/ PRODUCT\n-\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":34,"deletions":189,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -721,5 +721,0 @@\n-  \/\/ Ensure there is enough capacity in the internal tracking data\n-  \/\/ structures to hold the number of jmethodIDs you plan to generate.\n-  \/\/ This saves substantial time doing allocations.\n-  static void ensure_jmethod_ids(ClassLoaderData* cld, int capacity);\n-\n@@ -729,4 +724,1 @@\n-  inline static Method* resolve_jmethod_id(jmethodID mid) {\n-    assert(mid != nullptr, \"JNI method id should not be null\");\n-    return *((Method**)mid);\n-  }\n+  static Method* resolve_jmethod_id(jmethodID mid);\n@@ -740,1 +732,1 @@\n-  static bool is_method_id(jmethodID mid);\n+  static bool validate_jmethod_id(jmethodID mid);\n@@ -742,2 +734,1 @@\n-  \/\/ Clear methods\n-  static void clear_jmethod_ids(ClassLoaderData* loader_data);\n+  \/\/ Clear jmethodID\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+  product(bool, StressMacroElimination, false, DIAGNOSTIC,                  \\\n+          \"Randomize macro node elimination order\")                         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -755,2 +755,3 @@\n-      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout ||\n-      StressLoopPeeling) {\n+      StressIncrementalInlining || StressMacroExpansion ||\n+      StressMacroElimination || StressUnstableIfTraps ||\n+      StressBailout || StressLoopPeeling) {\n@@ -2927,0 +2928,2 @@\n+        print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n+\n@@ -3036,0 +3039,12 @@\n+    \/\/ Do not allow new macro nodes once we start to eliminate and expand\n+    C->reset_allow_macro_nodes();\n+    \/\/ Last attempt to eliminate macro nodes before expand\n+    mex.eliminate_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    mex.eliminate_opaque_looplimit_macro_nodes();\n+    if (failing()) {\n+      return;\n+    }\n+    print_method(PHASE_AFTER_MACRO_ELIMINATION, 2);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -275,0 +275,59 @@\n+\n+  \/\/ Detects following ideal graph pattern\n+  \/\/      ConvF2HF(binopF(conF, ConvHF2F(varS))) =>\n+  \/\/              ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))\n+  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode())) {\n+    Node* binopF = in(1);\n+    \/\/ Check if the incoming binary operation has one floating point constant\n+    \/\/ input and the other input is a half precision to single precision upcasting node.\n+    \/\/ We land here because a prior HalfFloat to Float conversion promotes\n+    \/\/ an integral constant holding Float16 value to a floating point constant.\n+    \/\/ i.e. ConvHF2F ConI(short) => ConF\n+    Node* conF = nullptr;\n+    Node* varS = nullptr;\n+    if (binopF->in(1)->is_Con() && binopF->in(2)->Opcode() == Op_ConvHF2F) {\n+      conF = binopF->in(1);\n+      varS = binopF->in(2)->in(1);\n+    } else if (binopF->in(2)->is_Con() &&  binopF->in(1)->Opcode() == Op_ConvHF2F) {\n+      conF = binopF->in(2);\n+      varS = binopF->in(1)->in(1);\n+    }\n+\n+    if (conF != nullptr &&\n+        varS != nullptr &&\n+        conF->bottom_type()->isa_float_constant() != nullptr &&\n+        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(binopF->Opcode())) &&\n+        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n+        Matcher::match_rule_supported(Op_ReinterpretHF2S) &&\n+        StubRoutines::hf2f_adr() != nullptr &&\n+        StubRoutines::f2hf_adr() != nullptr) {\n+      jfloat con = conF->bottom_type()->getf();\n+      \/\/ Conditions under which floating point constant can be considered for a pattern match.\n+      \/\/ 1. conF must lie within Float16 value range, otherwise we would have rounding issues:\n+      \/\/    Doing the operation in float32 and then rounding is not the same as\n+      \/\/    rounding first and doing the operation in float16.\n+      \/\/ 2. If a constant value is one of the valid IEEE 754 binary32 NaN bit patterns\n+      \/\/ then it's safe to consider it for pattern match because of the following reasons:\n+      \/\/   a. As per section 2.8 of JVMS, Java Virtual Machine does not support\n+      \/\/   signaling NaN value.\n+      \/\/   b. Any signaling NaN which takes part in a non-comparison expression\n+      \/\/   results in a quiet NaN but preserves the significand bits of signaling NaN.\n+      \/\/   c. The pattern being matched includes a Float to Float16 conversion after binary\n+      \/\/   expression, this downcast will still preserve the significand bits of binary32 NaN.\n+      bool isnan = g_isnan((jdouble)con);\n+      if (StubRoutines::hf2f(StubRoutines::f2hf(con)) == con || isnan) {\n+        Node* newVarHF = phase->transform(new ReinterpretS2HFNode(varS));\n+        Node* conHF = phase->makecon(TypeH::make(con));\n+        Node* binopHF = nullptr;\n+        \/\/ Preserving original input order for semantic correctness\n+        \/\/ of non-commutative operation.\n+        if (binopF->in(1) == conF) {\n+          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), conHF, newVarHF));\n+        } else {\n+          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), newVarHF, conHF));\n+        }\n+        return new ReinterpretHF2SNode(binopHF);\n+      }\n+    }\n+  }\n+\n@@ -277,0 +336,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -826,18 +826,2 @@\n-  \/\/ x\/x == 1, we ignore 0\/0.\n-  \/\/ Note: if t1 and t2 are zero then result is NaN (JVMS page 213)\n-  \/\/ Does not work for variables because of NaN's\n-  if (in(1) == in(2) && t1->base() == Type::HalfFloatCon &&\n-      !g_isnan(t1->getf()) && g_isfinite(t1->getf()) && t1->getf() != 0.0) { \/\/ could be negative ZERO or NaN\n-    return TypeH::ONE;\n-  }\n-\n-  if (t2 == TypeH::ONE) {\n-    return t1;\n-  }\n-\n-  \/\/ If divisor is a constant and not zero, divide the numbers\n-      t2->base() == Type::HalfFloatCon &&\n-      t2->getf() != 0.0)  {\n-    \/\/ could be negative zero\n-    return TypeH::make(t1->getf() \/ t2->getf());\n-  }\n+      t2->base() == Type::HalfFloatCon)  {\n+    \/\/ IEEE 754 floating point comparison treats 0.0 and -0.0 as equals.\n@@ -846,3 +830,4 @@\n-  \/\/ If the dividend is a constant zero\n-  \/\/ Note: if t1 and t2 are zero then result is NaN (JVMS page 213)\n-  \/\/ Test TypeHF::ZERO is not sufficient as it could be negative zero\n+    \/\/ Division of a zero by a zero results in NaN.\n+    if (t1->getf() == 0.0f && t2->getf() == 0.0f) {\n+      return TypeH::make(NAN);\n+    }\n@@ -850,3 +835,15 @@\n-  if (t1 == TypeH::ZERO && !g_isnan(t2->getf()) && t2->getf() != 0.0) {\n-    return TypeH::ZERO;\n-  }\n+    \/\/ As per C++ standard section 7.6.5 (expr.mul), behavior is undefined only if\n+    \/\/ the second operand is 0.0. In all other situations, we can expect a standard-compliant\n+    \/\/ C++ compiler to generate code following IEEE 754 semantics.\n+    if (t2->getf() == 0.0) {\n+      \/\/ If either operand is NaN, the result is NaN\n+      if (g_isnan(t1->getf())) {\n+        return TypeH::make(NAN);\n+      } else {\n+        \/\/ Division of a nonzero finite value by a zero results in a signed infinity. Also,\n+        \/\/ division of an infinity by a finite value results in a signed infinity.\n+        bool res_sign_neg = (jint_cast(t1->getf()) < 0) ^ (jint_cast(t2->getf()) < 0);\n+        const TypeF* res = res_sign_neg ? TypeF::NEG_INF : TypeF::POS_INF;\n+        return TypeH::make(res->getf());\n+      }\n+    }\n@@ -854,3 +851,1 @@\n-  \/\/ If divisor or dividend is nan then result is nan.\n-  if (g_isnan(t1->getf()) || g_isnan(t2->getf())) {\n-    return TypeH::make(NAN);\n+    return TypeH::make(t1->getf() \/ t2->getf());\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+#ifndef SHARE_OPTO_LIBRARY_CALL_HPP\n+#define SHARE_OPTO_LIBRARY_CALL_HPP\n+\n@@ -446,0 +449,1 @@\n+#endif \/\/ SHARE_OPTO_LIBRARY_CALL_HPP\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2985,0 +2985,4 @@\n+\n+  if (StressMacroElimination) {\n+    C->shuffle_macro_nodes();\n+  }\n@@ -3074,0 +3078,3 @@\n+      if (success) {\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n+      }\n@@ -3100,8 +3107,3 @@\n-\/\/------------------------------expand_macro_nodes----------------------\n-\/\/  Returns true if a failure occurred.\n-bool PhaseMacroExpand::expand_macro_nodes() {\n-  refine_strip_mined_loop_macro_nodes();\n-  \/\/ Do not allow new macro nodes once we started to expand\n-  C->reset_allow_macro_nodes();\n-  if (StressMacroExpansion) {\n-    C->shuffle_macro_nodes();\n+void PhaseMacroExpand::eliminate_opaque_looplimit_macro_nodes() {\n+  if (C->macro_count() == 0) {\n+    return;\n@@ -3109,1 +3111,1 @@\n-\n+  refine_strip_mined_loop_macro_nodes();\n@@ -3174,1 +3176,1 @@\n-        C->print_method(PHASE_AFTER_MACRO_EXPANSION_STEP, 5, n);\n+        C->print_method(PHASE_AFTER_MACRO_ELIMINATION_STEP, 5, n);\n@@ -3178,0 +3180,8 @@\n+}\n+\n+\/\/------------------------------expand_macro_nodes----------------------\n+\/\/  Returns true if a failure occurred.\n+bool PhaseMacroExpand::expand_macro_nodes() {\n+  if (StressMacroExpansion) {\n+    C->shuffle_macro_nodes();\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -228,0 +228,1 @@\n+  void eliminate_opaque_looplimit_macro_nodes();\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3187,0 +3187,1 @@\n+    add_users_to_worklist(n);   \/\/ if ideal or identity optimizations depend on the input type, users need to be notified\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  flags(AFTER_MACRO_ELIMINATION_STEP,   \"After Macro Elimination Step\") \\\n+  flags(AFTER_MACRO_ELIMINATION,        \"After Macro Elimination\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -564,2 +564,4 @@\n-  \/\/ no folding if one of operands is infinity or NaN, do not do constant folding\n-  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+  \/\/ Half precision floating point subtraction follows the rules of IEEE 754\n+  \/\/ applicable to other floating point types.\n+  if (t1->isa_half_float_constant() != nullptr &&\n+      t2->isa_half_float_constant() != nullptr)  {\n@@ -567,8 +569,1 @@\n-  }\n-  else if(g_isnan(t1->getf())) {\n-    return t1;\n-  }\n-  else if(g_isnan(t2->getf())) {\n-    return t2;\n-  }\n-  else {\n+  } else {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -331,3 +331,3 @@\n-  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a Float{Top,Con,Bot}\n-  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a FloatCon\n-  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a FloatCon\n+  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a HalfFloat{Top,Con,Bot}\n+  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a HalfFloatCon\n+  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a HalfFloatCon\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-  else if (!Method::is_method_id(method_id)) {\n+  else if (!Method::validate_jmethod_id(method_id)) {\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3146,1 +3146,1 @@\n-  return nullptr;\n+  THROW_NULL(vmSymbols::java_lang_UnsupportedOperationException());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2767,1 +2767,0 @@\n-  bool jmethodids_found = true;\n@@ -2770,0 +2769,3 @@\n+  \/\/ Make jmethodIDs for all non-overpass methods.\n+  ik->make_methods_jmethod_ids();\n+\n@@ -2782,14 +2784,2 @@\n-    jmethodID id;\n-    if (jmethodids_found) {\n-      id = m->find_jmethod_id_or_null();\n-      if (id == nullptr) {\n-        \/\/ If we find an uninitialized value, make sure there is\n-        \/\/ enough space for all the uninitialized values we might\n-        \/\/ find.\n-        ik->ensure_space_for_methodids(index);\n-        jmethodids_found = false;\n-        id = m->jmethod_id();\n-      }\n-    } else {\n-      id = m->jmethod_id();\n-    }\n+    jmethodID id = m->find_jmethod_id_or_null();\n+    assert(id != nullptr, \"should be created above\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3841,0 +3841,7 @@\n+    \/\/ The method_idnum should be within the range of 1..number-of-methods\n+    \/\/ until incremented later for obsolete methods.\n+    \/\/ The increment is so if a jmethodID is created for an old obsolete method\n+    \/\/ it gets a new jmethodID cache slot in the InstanceKlass.\n+    \/\/ They're cleaned out later when all methods of the previous version are purged.\n+    assert(old_method->method_idnum() <= _old_methods->length(),\n+           \"shouldn't be incremented yet for obsolete methods\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -2356,1 +2357,1 @@\n-  class ReadMonitorsClosure : public HandshakeClosure {\n+  class ReadMonitorsHandshakeClosure : public HandshakeClosure {\n@@ -2391,1 +2392,1 @@\n-    ReadMonitorsClosure() : HandshakeClosure(\"WB_HandshakeReadMonitors\"), _executed(false) {}\n+    ReadMonitorsHandshakeClosure() : HandshakeClosure(\"WB_HandshakeReadMonitors\"), _executed(false) {}\n@@ -2395,1 +2396,1 @@\n-  ReadMonitorsClosure rmc;\n+  ReadMonitorsHandshakeClosure rmhc;\n@@ -2401,1 +2402,1 @@\n-      Handshake::execute(&rmc, &tlh, target);\n+      Handshake::execute(&rmhc, &tlh, target);\n@@ -2404,1 +2405,1 @@\n-  return rmc.executed();\n+  return rmhc.executed();\n@@ -2408,1 +2409,1 @@\n-  class TraceSelfClosure : public HandshakeClosure {\n+  class TraceSelfHandshakeClosure : public HandshakeClosure {\n@@ -2422,1 +2423,1 @@\n-    TraceSelfClosure(Thread* thread) : HandshakeClosure(\"WB_TraceSelf\"), _num_threads_completed(0) {}\n+    TraceSelfHandshakeClosure(Thread* thread) : HandshakeClosure(\"WB_TraceSelf\"), _num_threads_completed(0) {}\n@@ -2426,1 +2427,1 @@\n-  TraceSelfClosure tsc(Thread::current());\n+  TraceSelfHandshakeClosure tshc(Thread::current());\n@@ -2429,1 +2430,1 @@\n-    Handshake::execute(&tsc);\n+    Handshake::execute(&tshc);\n@@ -2435,1 +2436,1 @@\n-      Handshake::execute(&tsc, &tlh, target);\n+      Handshake::execute(&tshc, &tlh, target);\n@@ -2438,1 +2439,1 @@\n-  return tsc.num_threads_completed();\n+  return tshc.num_threads_completed();\n@@ -2442,1 +2443,1 @@\n-  class TraceSelfClosure : public AsyncHandshakeClosure {\n+  class TraceSelfHandshakeClosure : public AsyncHandshakeClosure {\n@@ -2457,1 +2458,1 @@\n-    TraceSelfClosure(JavaThread* self_target) : AsyncHandshakeClosure(\"WB_TraceSelf\"), _self(self_target) {}\n+    TraceSelfHandshakeClosure(JavaThread* self_target) : AsyncHandshakeClosure(\"WB_TraceSelf\"), _self(self_target) {}\n@@ -2464,2 +2465,2 @@\n-      TraceSelfClosure* tsc = new TraceSelfClosure(target);\n-      Handshake::execute(tsc, target);\n+      TraceSelfHandshakeClosure* tshc = new TraceSelfHandshakeClosure(target);\n+      Handshake::execute(tshc, target);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -550,0 +550,1 @@\n+  { \"PSChunkLargeArrays\",           JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n@@ -1851,9 +1852,0 @@\n-#ifndef _LP64\n-  if (LockingMode == LM_LEGACY) {\n-    FLAG_SET_CMDLINE(LockingMode, LM_LIGHTWEIGHT);\n-    \/\/ Self-forwarding in bit 3 of the mark-word conflicts\n-    \/\/ with 4-byte-aligned stack-locks.\n-    warning(\"Legacy locking not supported on this platform\");\n-  }\n-#endif\n-\n@@ -3866,3 +3858,0 @@\n-  if (UseCompactObjectHeaders && LockingMode != LM_LIGHTWEIGHT) {\n-    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1099,1 +1099,1 @@\n-class DeoptimizeMarkedClosure : public HandshakeClosure {\n+class DeoptimizeMarkedHandshakeClosure : public HandshakeClosure {\n@@ -1101,1 +1101,1 @@\n-  DeoptimizeMarkedClosure() : HandshakeClosure(\"Deoptimize\") {}\n+  DeoptimizeMarkedHandshakeClosure() : HandshakeClosure(\"Deoptimize\") {}\n@@ -1114,1 +1114,1 @@\n-  DeoptimizeMarkedClosure deopt;\n+  DeoptimizeMarkedHandshakeClosure deopt;\n@@ -2486,0 +2486,8 @@\n+#if INCLUDE_JVMCI\n+    \/\/ Deoptimization count is used by the CompileBroker to reason about compilations\n+    \/\/ it requests so do not pollute the count for deoptimizations in non-default (i.e.\n+    \/\/ non-CompilerBroker) compilations.\n+    if (nm->is_jvmci_hosted()) {\n+      update_trap_state = false;\n+    }\n+#endif\n@@ -2596,1 +2604,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -296,0 +296,3 @@\n+  develop(bool, VerifyInlineCaches, true,                                   \\\n+          \"Verify Inline Caches\")                                           \\\n+                                                                            \\\n@@ -2010,7 +2013,0 @@\n-  product(int, LockingMode, LM_LIGHTWEIGHT,                                 \\\n-          \"(Deprecated) Select locking mode: \"                              \\\n-          \"0: (Deprecated) monitors only (LM_MONITOR), \"                    \\\n-          \"1: (Deprecated) monitors & legacy stack-locking (LM_LEGACY), \"   \\\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT, default)\") \\\n-          range(0, 2)                                                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1128,1 +1128,1 @@\n-void JavaThread::install_async_exception(AsyncExceptionHandshake* aeh) {\n+void JavaThread::install_async_exception(AsyncExceptionHandshakeClosure* aehc) {\n@@ -1132,1 +1132,1 @@\n-    delete aeh;\n+    delete aehc;\n@@ -1136,2 +1136,2 @@\n-  oop exception = aeh->exception();\n-  Handshake::execute(aeh, this);  \/\/ Install asynchronous handshake\n+  oop exception = aehc->exception();\n+  Handshake::execute(aehc, this);  \/\/ Install asynchronous handshake\n@@ -1155,2 +1155,2 @@\n-class InstallAsyncExceptionHandshake : public HandshakeClosure {\n-  AsyncExceptionHandshake* _aeh;\n+class InstallAsyncExceptionHandshakeClosure : public HandshakeClosure {\n+  AsyncExceptionHandshakeClosure* _aehc;\n@@ -1158,5 +1158,5 @@\n-  InstallAsyncExceptionHandshake(AsyncExceptionHandshake* aeh) :\n-    HandshakeClosure(\"InstallAsyncException\"), _aeh(aeh) {}\n-  ~InstallAsyncExceptionHandshake() {\n-    \/\/ If InstallAsyncExceptionHandshake was never executed we need to clean up _aeh.\n-    delete _aeh;\n+  InstallAsyncExceptionHandshakeClosure(AsyncExceptionHandshakeClosure* aehc) :\n+    HandshakeClosure(\"InstallAsyncException\"), _aehc(aehc) {}\n+  ~InstallAsyncExceptionHandshakeClosure() {\n+    \/\/ If InstallAsyncExceptionHandshakeClosure was never executed we need to clean up _aehc.\n+    delete _aehc;\n@@ -1166,2 +1166,2 @@\n-    target->install_async_exception(_aeh);\n-    _aeh = nullptr;\n+    target->install_async_exception(_aehc);\n+    _aehc = nullptr;\n@@ -1173,1 +1173,1 @@\n-  InstallAsyncExceptionHandshake iaeh(new AsyncExceptionHandshake(e));\n+  InstallAsyncExceptionHandshakeClosure iaeh(new AsyncExceptionHandshakeClosure(e));\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-class AsyncExceptionHandshake;\n+class AsyncExceptionHandshakeClosure;\n@@ -237,2 +237,2 @@\n-  friend class InstallAsyncExceptionHandshake;\n-  friend class AsyncExceptionHandshake;\n+  friend class InstallAsyncExceptionHandshakeClosure;\n+  friend class AsyncExceptionHandshakeClosure;\n@@ -243,1 +243,1 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n+  void install_async_exception(AsyncExceptionHandshakeClosure* aec = nullptr);\n@@ -1172,1 +1172,1 @@\n-  \/\/ (see EnterInterpOnlyModeClosure).\n+  \/\/ (see EnterInterpOnlyModeHandshakeClosure).\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1716,1 +1716,1 @@\n-class HandshakeForDeflation : public HandshakeClosure {\n+class DeflationHandshakeClosure : public HandshakeClosure {\n@@ -1718,1 +1718,1 @@\n-  HandshakeForDeflation() : HandshakeClosure(\"HandshakeForDeflation\") {}\n+  DeflationHandshakeClosure() : HandshakeClosure(\"DeflationHandshakeClosure\") {}\n@@ -1721,1 +1721,1 @@\n-    log_trace(monitorinflation)(\"HandshakeForDeflation::do_thread: thread=\"\n+    log_trace(monitorinflation)(\"DeflationHandshakeClosure::do_thread: thread=\"\n@@ -1886,2 +1886,2 @@\n-    HandshakeForDeflation hfd_hc;\n-    Handshake::execute(&hfd_hc);\n+    DeflationHandshakeClosure dhc;\n+    Handshake::execute(&dhc);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"jfr\/recorder\/service\/jfrRecorderThread.hpp\"\n@@ -1035,0 +1036,1 @@\n+        declare_type(JfrRecorderThread, JavaThread)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,0 +193,2 @@\n+  static void log_exception_stacktrace(Handle exception);\n+  static void log_exception_stacktrace(Handle exception, methodHandle method, int bci);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+const int LockingMode = LM_LIGHTWEIGHT;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1025,0 +1025,2 @@\n+extern const int LockingMode;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n- * <p>ConcurrentHashMaps support a set of sequential and parallel bulk\n+ * <p id=\"Bulk\">ConcurrentHashMaps support a set of sequential and parallel bulk\n@@ -3702,1 +3702,1 @@\n-     * Performs the given action for each (key, value).\n+     * Performs the given {@linkplain ##Bulk bulk} action for each (key, value).\n@@ -3718,1 +3718,1 @@\n-     * Performs the given action for each non-null transformation\n+     * Performs the given {@linkplain ##Bulk bulk} action for each non-null transformation\n@@ -3741,1 +3741,1 @@\n-     * Returns a non-null result from applying the given search\n+     * Returns a non-null result from applying the given {@linkplain ##Bulk bulk} search\n@@ -3765,1 +3765,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of accumulating the given {@linkplain ##Bulk bulk} transformation\n@@ -3791,1 +3791,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of accumulating the given {@linkplain ##Bulk bulk} transformation\n@@ -3817,1 +3817,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of accumulating the given {@linkplain ##Bulk bulk} transformation\n@@ -3843,1 +3843,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of accumulating the given {@linkplain ##Bulk bulk} transformation\n@@ -3869,1 +3869,1 @@\n-     * Performs the given action for each key.\n+     * Performs the given {@linkplain ##Bulk bulk} action for each key.\n@@ -3885,1 +3885,1 @@\n-     * Performs the given action for each non-null transformation\n+     * Performs the given {@linkplain ##Bulk bulk} action for each non-null transformation\n@@ -3908,1 +3908,1 @@\n-     * Returns a non-null result from applying the given search\n+     * Returns a non-null result from applying the given {@linkplain ##Bulk bulk} search\n@@ -3932,1 +3932,1 @@\n-     * Returns the result of accumulating all keys using the given\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating all keys using the given\n@@ -3951,1 +3951,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -3977,1 +3977,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4003,1 +4003,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4029,1 +4029,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4055,1 +4055,1 @@\n-     * Performs the given action for each value.\n+     * Performs the given {@linkplain ##Bulk bulk} action for each value.\n@@ -4072,1 +4072,1 @@\n-     * Performs the given action for each non-null transformation\n+     * Performs the given {@linkplain ##Bulk bulk} action for each non-null transformation\n@@ -4095,1 +4095,1 @@\n-     * Returns a non-null result from applying the given search\n+     * Returns a non-null result from {@linkplain ##Bulk bulk} applying the given search\n@@ -4119,1 +4119,1 @@\n-     * Returns the result of accumulating all values using the\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating all values using the\n@@ -4137,1 +4137,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4163,1 +4163,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4189,1 +4189,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4215,1 +4215,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4241,1 +4241,1 @@\n-     * Performs the given action for each entry.\n+     * Performs the given {@linkplain ##Bulk bulk} action for each entry.\n@@ -4256,1 +4256,1 @@\n-     * Performs the given action for each non-null transformation\n+     * Performs the given {@linkplain ##Bulk bulk} action for each non-null transformation\n@@ -4279,1 +4279,1 @@\n-     * Returns a non-null result from applying the given search\n+     * Returns a non-null result from {@linkplain ##Bulk bulk} applying the given search\n@@ -4303,1 +4303,1 @@\n-     * Returns the result of accumulating all entries using the\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating all entries using the\n@@ -4321,1 +4321,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4347,1 +4347,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4373,1 +4373,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n@@ -4399,1 +4399,1 @@\n-     * Returns the result of accumulating the given transformation\n+     * Returns the result of {@linkplain ##Bulk bulk} accumulating the given transformation\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-            if (options.isExplicitlyEnabled(Option.XLINT, lc)) {\n+            if (options.isLintExplicitlyEnabled(lc)) {\n@@ -188,1 +188,1 @@\n-            } else if (options.isExplicitlyDisabled(Option.XLINT, lc)) {\n+            } else if (options.isLintExplicitlyDisabled(lc)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -815,0 +815,5 @@\n+            \/\/make sure variables defined in the let expression are not included\n+            \/\/in the defined variables for jumps that go outside of this let\n+            \/\/expression:\n+            undefineVariablesInChain(result.falseJumps, limit);\n+            undefineVariablesInChain(result.trueJumps, limit);\n@@ -822,0 +827,7 @@\n+        \/\/where:\n+        private void undefineVariablesInChain(Chain toClear, int limit) {\n+            while (toClear != null) {\n+                toClear.state.defined.excludeFrom(limit);\n+                toClear = toClear.next;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderTest.java 8350208 generic-all\n-compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotResolvedJavaField.java 8350208 generic-all\n+compiler\/onSpinWait\/TestOnSpinWaitAArch64.java 8360936 linux-aarch64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+    vm.cds.default.archive.available \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-  gtest\/LockStackGtests.java \\\n@@ -440,0 +439,1 @@\n+ -runtime\/cds\/appcds\/aotProfile \\\n@@ -534,1 +534,1 @@\n-# Run CDS tests with -XX:+AOTClassLinking. This should include most CDS tests, except for\n+# Run \"old\" CDS tests with -XX:+AOTClassLinking. This should include most CDS tests, except for\n@@ -536,0 +536,2 @@\n+# Note that appcds\/aotXXX directories are excluded -- those tests already specifically\n+# test AOT class linking, so there's no need to run them again with -XX:+AOTClassLinking.\n@@ -542,0 +544,1 @@\n+ -runtime\/cds\/appcds\/aotProfile \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+        String relocMsg1 = \"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\";\n+        String relocMsg2 = \"Try to map archive(s) at an alternative address\";\n@@ -79,2 +81,4 @@\n-                        output.shouldContain(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\")\n-                              .shouldContain(\"Try to map archive(s) at an alternative address\");\n+                        if (!output.contains(relocMsg1) && !output.contains(relocMsg2)) {\n+                            throw new RuntimeException(\"Relocation messages \\\"\" + relocMsg1 +\n+                                \"\\\" and \\\"\" + relocMsg2 + \"\\\" are missing from the output\");\n+                        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ArchiveRelocationTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -827,0 +827,1 @@\n+java\/awt\/FileDialog\/DoubleActionESC.java 8356981 linux-all\n@@ -847,0 +848,1 @@\n+java\/awt\/Cursor\/CursorDragTest\/ListDragCursor.java 7177297 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,2 +121,0 @@\n-        map.put(\"vm.rtm.cpu\", this::vmRTMCPU);\n-        map.put(\"vm.rtm.compiler\", this::vmRTMCompiler);\n@@ -125,0 +123,1 @@\n+        map.put(\"vm.cds.default.archive.available\", this::vmCDSDefaultArchiveAvailable);\n@@ -421,22 +420,0 @@\n-    \/**\n-     * @return \"true\" if compiler in use supports RTM and \"false\" otherwise.\n-     * Note: Lightweight locking does not support RTM (for now).\n-     *\/\n-    protected String vmRTMCompiler() {\n-        boolean isRTMCompiler = false;\n-\n-        if (Compiler.isC2Enabled() &&\n-            (Platform.isX86() || Platform.isX64() || Platform.isPPC()) &&\n-            is_LM_LIGHTWEIGHT().equals(\"false\")) {\n-            isRTMCompiler = true;\n-        }\n-        return \"\" + isRTMCompiler;\n-    }\n-\n-    \/**\n-     * @return true if VM runs RTM supported CPU and false otherwise.\n-     *\/\n-    protected String vmRTMCPU() {\n-        return \"\" + CPUInfo.hasFeature(\"rtm\");\n-    }\n-\n@@ -452,0 +429,10 @@\n+    \/**\n+     * Check for CDS default archive existence.\n+     *\n+     * @return true if CDS default archive classes.jsa exists in the JDK to be tested.\n+     *\/\n+    protected String vmCDSDefaultArchiveAvailable() {\n+        Path archive = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"server\", \"classes.jsa\");\n+        return \"\" + (\"true\".equals(vmCDS()) && Files.exists(archive));\n+    }\n+\n@@ -536,28 +523,0 @@\n-    \/**\n-     * @return LockingMode.\n-     *\/\n-    protected String vmLockingMode() {\n-        return \"\" + WB.getIntVMFlag(\"LockingMode\");\n-    }\n-\n-    \/**\n-     * @return \"true\" if LockingMode == 0 (LM_MONITOR)\n-     *\/\n-    protected String is_LM_MONITOR() {\n-        return \"\" + vmLockingMode().equals(\"0\");\n-    }\n-\n-    \/**\n-     * @return \"true\" if LockingMode == 1 (LM_LEGACY)\n-     *\/\n-    protected String is_LM_LEGACY() {\n-        return \"\" + vmLockingMode().equals(\"1\");\n-    }\n-\n-    \/**\n-     * @return \"true\" if LockingMode == 2 (LM_LIGHTWEIGHT)\n-     *\/\n-    protected String is_LM_LIGHTWEIGHT() {\n-        return \"\" + vmLockingMode().equals(\"2\");\n-    }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":11,"deletions":52,"binary":false,"changes":63,"status":"modified"}]}