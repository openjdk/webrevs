{"files":[{"patch":"@@ -99,8 +99,0 @@\n-################################################################################\n-# Special targets for certain modules\n-\n-$(eval $(call SetupTarget, generate-exported-symbols, \\\n-    MAKEFILE := BuildStatic, \\\n-    DEPS := java.base-libs jdk.jdwp.agent-libs, \\\n-))\n-\n@@ -908,4 +900,0 @@\n-  ifeq ($(STATIC_BUILD), true)\n-    $(LAUNCHER_TARGETS): generate-exported-symbols\n-  endif\n-\n","filename":"make\/Main.gmk","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-ifeq ($(call check-jvm-feature, static-build), true)\n-  JVM_CFLAGS_FEATURES += -DSTATIC_BUILD=1\n-endif\n-\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -343,0 +343,4 @@\n+    private static final String RESTRICTED_ANNOTATION =\n+            \"Ljdk\/internal\/javac\/Restricted;\";\n+    private static final String RESTRICTED_ANNOTATION_INTERNAL =\n+            \"Ljdk\/internal\/javac\/Restricted+Annotation;\";\n@@ -357,1 +361,2 @@\n-                    MIGRATED_VALUE_CLASS_ANNOTATION));\n+                    MIGRATED_VALUE_CLASS_ANNOTATION,\n+                    RESTRICTED_ANNOTATION));\n@@ -1261,0 +1266,6 @@\n+        if (RESTRICTED_ANNOTATION.equals(annotationType)) {\n+            \/\/the non-public Restricted annotation will not be available in ct.sym,\n+            \/\/replace with purely synthetic javac-internal annotation:\n+            annotationType = RESTRICTED_ANNOTATION_INTERNAL;\n+        }\n+\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1517,1 +1517,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c exeGetProcessorInfo.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8625,0 +8625,1 @@\n+#ifdef COMPILER2\n@@ -8634,0 +8635,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1752,0 +1752,1 @@\n+    case Op_ClearArray:\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -437,3 +437,0 @@\n-  \/\/ Size of code without stubs generated at the end of instructions section\n-  csize_t      _main_code_size;\n-\n@@ -470,1 +467,0 @@\n-    _main_code_size  = 0;\n@@ -644,3 +640,0 @@\n-  \/\/ size of code without stubs in instruction section\n-  csize_t main_code_size() const         { return _main_code_size; }\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4748,0 +4748,1 @@\n+  append(new MemBar(lir_membar_storestore));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(S390)\n+#if defined(X86) || defined(AARCH64) || defined(S390) || defined(RISCV)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  if (is_dumping_static_archive() || UseSharedSpaces) {\n+  if (is_dumping_static_archive() || is_using_archive()) {\n@@ -325,1 +325,1 @@\n-  assert(UseSharedSpaces, \"this function is only used with -Xshare:{on,auto}\");\n+  assert(is_using_archive(), \"this function is only used with -Xshare:{on,auto}\");\n@@ -400,1 +400,1 @@\n-  if (UseSharedSpaces && java_base_module_patching_disables_cds() && module_patching_disables_cds()) {\n+  if (is_using_archive() && java_base_module_patching_disables_cds() && module_patching_disables_cds()) {\n@@ -403,1 +403,1 @@\n-  if (UseSharedSpaces && has_unsupported_runtime_module_options()) {\n+  if (is_using_archive() && has_unsupported_runtime_module_options()) {\n@@ -419,1 +419,1 @@\n-  return UseSharedSpaces; \/\/ TODO: UseSharedSpaces will be eventually replaced by CDSConfig::is_using_archive()\n+  return UseSharedSpaces;\n@@ -451,1 +451,1 @@\n-  if (UseSharedSpaces && ArchiveHeapLoader::can_use()) {\n+  if (is_using_archive() && ArchiveHeapLoader::can_use()) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-  if (UseSharedSpaces && is_modules_image()) {\n+  if (CDSConfig::is_using_archive() && is_modules_image()) {\n@@ -454,1 +454,1 @@\n-  assert(UseSharedSpaces, \"runtime only\");\n+  assert(CDSConfig::is_using_archive(), \"runtime only\");\n@@ -1006,1 +1006,1 @@\n-  assert(UseSharedSpaces, \"runtime only\");\n+  assert(CDSConfig::is_using_archive(), \"runtime only\");\n@@ -1052,1 +1052,1 @@\n-          assert(!UseSharedSpaces, \"UseSharedSpaces should be disabled\");\n+          assert(!CDSConfig::is_using_archive(), \"UseSharedSpaces should be disabled\");\n@@ -1061,1 +1061,1 @@\n-          assert(!UseSharedSpaces, \"UseSharedSpaces should be disabled\");\n+          assert(!CDSConfig::is_using_archive(), \"UseSharedSpaces should be disabled\");\n@@ -1109,1 +1109,1 @@\n-  assert(UseSharedSpaces, \"runtime only\");\n+  assert(CDSConfig::is_using_archive(), \"runtime only\");\n@@ -2162,1 +2162,1 @@\n-  assert(UseSharedSpaces, \"runtime only\");\n+  assert(CDSConfig::is_using_archive(), \"runtime only\");\n@@ -2174,1 +2174,1 @@\n-  assert(UseSharedSpaces, \"runtime only\");\n+  assert(CDSConfig::is_using_archive(), \"runtime only\");\n@@ -2302,1 +2302,1 @@\n-  assert(UseSharedSpaces, \"runtime only\");\n+  assert(CDSConfig::is_using_archive(), \"runtime only\");\n@@ -2391,1 +2391,1 @@\n-  assert(UseSharedSpaces, \"UseSharedSpaces expected.\");\n+  assert(CDSConfig::is_using_archive(), \"UseSharedSpaces expected.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-    assert(UseSharedSpaces, \"must be\");\n+    assert(CDSConfig::is_using_archive(), \"must be\");\n@@ -245,1 +245,1 @@\n-  assert(!CDSConfig::is_dumping_heap() && UseSharedSpaces, \"runtime only\");\n+  assert(!CDSConfig::is_dumping_heap() && CDSConfig::is_using_archive(), \"runtime only\");\n@@ -256,1 +256,1 @@\n-  assert(UseSharedSpaces, \"must be\");\n+  assert(CDSConfig::is_using_archive(), \"must be\");\n@@ -909,1 +909,1 @@\n-  assert(UseSharedSpaces, \"runtime only!\");\n+  assert(CDSConfig::is_using_archive(), \"runtime only!\");\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n@@ -933,1 +933,1 @@\n-  assert(UseSharedSpaces, \"Must be called when UseSharedSpaces is enabled\");\n+  assert(CDSConfig::is_using_archive(), \"Must be called when UseSharedSpaces is enabled\");\n@@ -1312,1 +1312,1 @@\n-  const size_t class_space_size = CompressedClassSpaceSize;\n+  size_t class_space_size = CompressedClassSpaceSize;\n@@ -1321,0 +1321,10 @@\n+  \/\/ Reduce class space size if it would not fit into the Klass encoding range\n+  constexpr size_t max_encoding_range_size = 4 * G;\n+  guarantee(archive_space_size < max_encoding_range_size - class_space_alignment, \"Archive too large\");\n+  if ((archive_space_size + gap_size + class_space_size) > max_encoding_range_size) {\n+    class_space_size = align_down(max_encoding_range_size - archive_space_size - gap_size, class_space_alignment);\n+    log_info(metaspace)(\"CDS initialization: reducing class space size from \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n+        CompressedClassSpaceSize, class_space_size);\n+    FLAG_SET_ERGO(CompressedClassSpaceSize, class_space_size);\n+  }\n+\n@@ -1413,1 +1423,1 @@\n-  assert(UseSharedSpaces, \"must be runtime\");\n+  assert(CDSConfig::is_using_archive(), \"must be runtime\");\n@@ -1443,1 +1453,1 @@\n-  assert(UseSharedSpaces, \"must be runtime\");\n+  assert(CDSConfig::is_using_archive(), \"must be runtime\");\n@@ -1541,1 +1551,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n@@ -1559,1 +1569,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1187,2 +1187,1 @@\n-\/\/ heuristic (e.g. post call nop instructions and GC barriers;\n-\/\/ see InlineSkippedInstructionsCounter).\n+\/\/ heuristic (e.g. post call nop instructions; see InlineSkippedInstructionsCounter)\n@@ -1194,1 +1193,1 @@\n-        int isize = code->inline_insts_size();\n+        int isize = code->insts_end() - code->verified_entry_point() - code->skipped_instructions_size();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -430,5 +430,3 @@\n-  Cell cell = state->next_cell(state->tos());\n-  state->set_stack_size(0);\n-  int limit = state->limit_cell();\n-  for (; cell < limit; cell = state->next_cell(cell)) {\n-    state->set_type_at(cell, state->bottom_type());\n+  assert(state->stack_size() <= 0, \"stack size should not be strictly positive\");\n+  while (state->stack_size() < 0) {\n+    state->push(state->bottom_type());\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1511,1 +1511,1 @@\n-    assert(!UseSharedSpaces, \"UsedSharedSpaces not supported with exploded module builds\");\n+    assert(!CDSConfig::is_using_archive(), \"UsedSharedSpaces not supported with exploded module builds\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5350,1 +5350,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    assert(UseSharedSpaces, \"must be\");\n+    assert(CDSConfig::is_using_archive(), \"must be\");\n@@ -158,1 +158,1 @@\n-    assert(UseSharedSpaces, \"must be\");\n+    assert(CDSConfig::is_using_archive(), \"must be\");\n@@ -1300,1 +1300,1 @@\n-    if (UseSharedSpaces)\n+    if (CDSConfig::is_using_archive())\n@@ -1655,1 +1655,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-  uint inline_insts_size;\n@@ -155,1 +154,0 @@\n-    inline_insts_size   += nm->inline_insts_size();\n@@ -190,3 +188,0 @@\n-    if (inline_insts_size != 0) {\n-      tty->print_cr(\"     inline code = %u (%f%%)\", inline_insts_size, (inline_insts_size * 100.0f)\/total_nm_size);\n-    }\n@@ -1273,9 +1268,0 @@\n-  int size = code_buffer->main_code_size();\n-  assert(size >= 0, \"should be initialized\");\n-  \/\/ Use instructions section size if it is 0 (e.g. native wrapper)\n-  if (size == 0) size = code_size(); \/\/ requires _stub_offset to be set\n-  assert(size <= code_size(), \"incorrect size: %d > %d\", size, code_size());\n-  _inline_insts_size = size - _verified_entry_offset\n-                     - code_buffer->total_skipped_instructions_size();\n-  assert(_inline_insts_size >= 0, \"sanity\");\n-\n@@ -1285,0 +1271,2 @@\n+\n+  _skipped_instructions_size = code_buffer->total_skipped_instructions_size();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  int _inline_insts_size;\n+  int _skipped_instructions_size;\n@@ -598,1 +598,1 @@\n-  int inline_insts_size() const { return _inline_insts_size; }\n+  int skipped_instructions_size () const { return _skipped_instructions_size; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -764,1 +764,1 @@\n-        if (match->EnableOption) {\n+        if (match->EnableOption || dir->is_default_directive()) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,15 +284,0 @@\n-void\n-print_generic_summary_data(ParallelCompactData& summary_data,\n-                           SpaceInfo* space_info)\n-{\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n-    return;\n-  }\n-\n-  for (unsigned int id = 0; id < PSParallelCompact::last_space_id; ++id) {\n-    const MutableSpace* space = space_info[id].space();\n-    print_generic_summary_data(summary_data, space->bottom(),\n-                               MAX2(space->top(), space_info[id].new_top()));\n-  }\n-}\n-\n@@ -2134,3 +2119,3 @@\n-  \/\/ All Regions between space bottom() to new_top() should be marked as filled\n-  \/\/ and all Regions between new_top() and top() should be available (i.e.,\n-  \/\/ should have been emptied).\n+  \/\/ All Regions served as compaction targets, from dense_prefix() to\n+  \/\/ new_top(), should be marked as filled and all Regions between new_top()\n+  \/\/ and top() should be available (i.e., should have been emptied).\n@@ -2141,1 +2126,1 @@\n-  const size_t beg_region = sd.addr_to_region_idx(si.space()->bottom());\n+  const size_t beg_region = sd.addr_to_region_idx(si.dense_prefix());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n@@ -399,1 +399,1 @@\n-    if (!UseSharedSpaces) {\n+    if (!CDSConfig::is_using_archive()) {\n@@ -430,1 +430,1 @@\n-    if (UseSharedSpaces) {\n+    if (CDSConfig::is_using_archive()) {\n@@ -533,1 +533,1 @@\n-    if (UseSharedSpaces &&\n+    if (CDSConfig::is_using_archive() &&\n@@ -571,1 +571,1 @@\n-  if (!UseSharedSpaces) {\n+  if (!CDSConfig::is_using_archive()) {\n@@ -882,1 +882,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n@@ -1080,1 +1080,1 @@\n-  if (!UseSharedSpaces) {\n+  if (!CDSConfig::is_using_archive()) {\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  assert(CDSConfig::is_dumping_static_archive() || UseSharedSpaces, \"only for CDS\");\n+  assert(CDSConfig::is_dumping_static_archive() || CDSConfig::is_using_archive(), \"only for CDS\");\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  assert(CDSConfig::is_dumping_static_archive() || UseSharedSpaces, \"only for CDS\");\n+  assert(CDSConfig::is_dumping_static_archive() || CDSConfig::is_using_archive(), \"only for CDS\");\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-  assert(CDSConfig::is_dumping_static_archive() || UseSharedSpaces, \"only for CDS\");\n+  assert(CDSConfig::is_dumping_static_archive() || CDSConfig::is_using_archive(), \"only for CDS\");\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -552,1 +552,1 @@\n-  assert(CDSConfig::is_dumping_static_archive() || UseSharedSpaces, \"only for CDS\");\n+  assert(CDSConfig::is_dumping_static_archive() || CDSConfig::is_using_archive(), \"only for CDS\");\n@@ -4305,1 +4305,1 @@\n-        ((UseSharedSpaces || CDSConfig::is_dumping_archive()) && length != 0)) {\n+        ((CDSConfig::is_using_archive() || CDSConfig::is_dumping_archive()) && length != 0)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-  assert(CDSConfig::is_dumping_static_archive() || UseSharedSpaces, \"only for cds\");\n+  assert(CDSConfig::is_dumping_static_archive() || CDSConfig::is_using_archive(), \"only for cds\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4891,0 +4891,14 @@\n+\n+    \/\/ If we have crossed the 3\/4 point of max node limit it's too risky\n+    \/\/ to continue with EA\/SR because we might hit the max node limit.\n+    if (_compile->live_nodes() >= _compile->max_node_limit() * 0.75) {\n+      if (_compile->do_reduce_allocation_merges()) {\n+        _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n+      } else if (_invocation > 0) {\n+        _compile->record_failure(C2Compiler::retry_no_iterative_escape_analysis());\n+      } else {\n+        _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n+      }\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2891,1 +2891,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5347,1 +5347,7 @@\n-  if (ReduceBulkZeroing) {\n+  if (ReduceBulkZeroing &&\n+      \/\/ If we are implementing an array clone without knowing its source type\n+      \/\/ (can happen when compiling the array-guarded branch of a reflective\n+      \/\/ Object.clone() invocation), initialize the array within the allocation.\n+      \/\/ This is needed because some GCs (e.g. ZGC) might fall back in this case\n+      \/\/ to a runtime clone call that assumes fully initialized source arrays.\n+      (!is_array || obj->get_ptr_type()->isa_aryptr() != nullptr)) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+  Node* partially_wrap_indexes(Node* index_vec, int num_elem, BasicType type_bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2337,2 +2337,2 @@\n-      \/\/ If the Data use is an IF, that means we have an IF outside of the\n-      \/\/ loop that is switching on a condition that is set inside of the\n+      \/\/ If the Data use is an IF, that means we have an IF outside the\n+      \/\/ loop that is switching on a condition that is set inside the\n@@ -2340,1 +2340,1 @@\n-      \/\/ in the loop to break the loop, then test is again outside of the\n+      \/\/ in the loop to break the loop, then test is again outside the\n@@ -2342,4 +2342,5 @@\n-      \/\/ Loop predicate If node connects to Bool node through Opaque1 node.\n-      \/\/ If the use is an AllocateArray through its ValidLengthTest input,\n-      \/\/ make sure the Bool\/Cmp input is cloned down to avoid a Phi between\n-      \/\/ the AllocateArray node and its ValidLengthTest input that could cause\n+      \/\/ For several uses we need to make sure that there is no phi between,\n+      \/\/ the use and the Bool\/Cmp. We therefore clone the Bool\/Cmp down here\n+      \/\/ to avoid such a phi in between.\n+      \/\/ For example, it is unexpected that there is a Phi between an\n+      \/\/ AllocateArray node and its ValidLengthTest input that could cause\n@@ -2348,1 +2349,1 @@\n-      if (use->is_If() || use->is_CMove() || use->is_Opaque4() ||\n+      if (use->is_If() || use->is_CMove() || use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate() ||\n@@ -3169,6 +3170,7 @@\n-\/\/------------------------------ insert_cmpi_loop_exit -------------------------------------\n-\/\/ Clone a signed compare loop exit from an unsigned compare and\n-\/\/ insert it before the unsigned cmp on the stay-in-loop path.\n-\/\/ All new nodes inserted in the dominator tree between the original\n-\/\/ if and it's projections.  The original if test is replaced with\n-\/\/ a constant to force the stay-in-loop path.\n+\/\/ Idea\n+\/\/ ----\n+\/\/ Partial Peeling tries to rotate the loop in such a way that it can later be turned into a counted loop. Counted loops\n+\/\/ require a signed loop exit test. When calling this method, we've only found a suitable unsigned test to partial peel\n+\/\/ with. Therefore, we try to split off a signed loop exit test from the unsigned test such that it can be used as new\n+\/\/ loop exit while keeping the unsigned test unchanged and preserving the same behavior as if we've used the unsigned\n+\/\/ test alone instead:\n@@ -3176,4 +3178,8 @@\n-\/\/ This is done to make sure that the original if and it's projections\n-\/\/ still dominate the same set of control nodes, that the ctrl() relation\n-\/\/ from data nodes to them is preserved, and that their loop nesting is\n-\/\/ preserved.\n+\/\/ Before Partial Peeling:\n+\/\/   Loop:\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     <-- CUT HERE -->\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     goto Loop\n@@ -3181,2 +3187,14 @@\n-\/\/ before\n-\/\/          if(i <u limit)    unsigned compare loop exit\n+\/\/ After Partial Peeling:\n+\/\/   <cloned peeled section>\n+\/\/   Cloned split off signed loop exit test\n+\/\/   Loop:\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     goto Loop\n+\/\/\n+\/\/ Details\n+\/\/ -------\n+\/\/ Before:\n+\/\/          if (i <u limit)    Unsigned loop exit condition\n@@ -3187,5 +3205,6 @@\n-\/\/ after\n-\/\/          if(stay-in-loop-const)  original if\n-\/\/         \/       |\n-\/\/        \/        v\n-\/\/       \/  if(i <  limit)    new signed test\n+\/\/ Split off a signed loop exit test (i.e. with CmpI) from an unsigned loop exit test (i.e. with CmpU) and insert it\n+\/\/ before the CmpU on the stay-in-loop path and keep both tests:\n+\/\/\n+\/\/          if (i <u limit)    Signed loop exit test\n+\/\/        \/        |\n+\/\/       \/  if (i <u limit)    Unsigned loop exit test\n@@ -3193,10 +3212,28 @@\n-\/\/     \/  \/        v\n-\/\/    \/  \/  if(i <u limit)    new cloned unsigned test\n-\/\/   \/  \/   \/      |\n-\/\/   v  v  v       |\n-\/\/    region       |\n-\/\/        |        |\n-\/\/      dum-if     |\n-\/\/     \/  |        |\n-\/\/ ether  |        |\n-\/\/        v        v\n+\/\/     v  v        v\n+\/\/  exit-region  stay-in-loop-proj\n+\/\/\n+\/\/ Implementation\n+\/\/ --------------\n+\/\/ We need to make sure that the new signed loop exit test is properly inserted into the graph such that the unsigned\n+\/\/ loop exit test still dominates the same set of control nodes, the ctrl() relation from data nodes to both loop\n+\/\/ exit tests is preserved, and their loop nesting is correct.\n+\/\/\n+\/\/ To achieve that, we clone the unsigned loop exit test completely (leave it unchanged), insert the signed loop exit\n+\/\/ test above it and kill the original unsigned loop exit test by setting it's condition to a constant\n+\/\/ (i.e. stay-in-loop-const in graph below) such that IGVN can fold it later:\n+\/\/\n+\/\/           if (stay-in-loop-const)  Killed original unsigned loop exit test\n+\/\/          \/       |\n+\/\/         \/        v\n+\/\/        \/  if (i <  limit)          Split off signed loop exit test\n+\/\/       \/  \/       |\n+\/\/      \/  \/        v\n+\/\/     \/  \/  if (i <u limit)          Cloned unsigned loop exit test\n+\/\/    \/  \/   \/      |\n+\/\/   v  v  v        |\n+\/\/  exit-region     |\n+\/\/        |         |\n+\/\/    dummy-if      |\n+\/\/     \/  |         |\n+\/\/ dead   |         |\n+\/\/        v         v\n@@ -3205,1 +3242,9 @@\n-IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree *loop) {\n+\/\/ Note: The dummy-if is inserted to create a region to merge the loop exits between the original to be killed unsigned\n+\/\/       loop exit test and its exit projection while keeping the exit projection (also see insert_region_before_proj()).\n+\/\/\n+\/\/ Requirements\n+\/\/ ------------\n+\/\/ Note that we can only split off a signed loop exit test from the unsigned loop exit test when the behavior is exactly\n+\/\/ the same as before with only a single unsigned test. This is only possible if certain requirements are met.\n+\/\/ Otherwise, we need to bail out (see comments in the code below).\n+IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree* loop) {\n@@ -3210,1 +3255,3 @@\n-  if (bol->_test._test != BoolTest::lt) return nullptr;\n+  if (bol->_test._test != BoolTest::lt) {\n+    return nullptr;\n+  }\n@@ -3212,1 +3259,2 @@\n-  if (cmpu->Opcode() != Op_CmpU) return nullptr;\n+  assert(cmpu->Opcode() == Op_CmpU, \"must be unsigned comparison\");\n+\n@@ -3214,1 +3262,3 @@\n-  if (stride == 0) return nullptr;\n+  if (stride == 0) {\n+    return nullptr;\n+  }\n@@ -3226,3 +3276,82 @@\n-  \/\/ The loop exit condition is !(i <u limit) ==> (i < 0 || i >= limit).\n-  \/\/ Split out the exit condition (i < 0) for stride < 0 or (i >= limit) for stride > 0.\n-  Node* limit = nullptr;\n+  \/\/ The unsigned loop exit condition is\n+  \/\/   !(i <u  limit)\n+  \/\/ =   i >=u limit\n+  \/\/\n+  \/\/ First, we note that for any x for which\n+  \/\/   0 <= x <= INT_MAX\n+  \/\/ we can convert x to an unsigned int and still get the same guarantee:\n+  \/\/   0 <=  (uint) x <=  INT_MAX = (uint) INT_MAX\n+  \/\/   0 <=u (uint) x <=u INT_MAX = (uint) INT_MAX   (LEMMA)\n+  \/\/\n+  \/\/ With that in mind, if\n+  \/\/   limit >= 0             (COND)\n+  \/\/ then the unsigned loop exit condition\n+  \/\/   i >=u limit            (ULE)\n+  \/\/ is equivalent to\n+  \/\/   i < 0 || i >= limit    (SLE-full)\n+  \/\/ because either i is negative and therefore always greater than MAX_INT when converting to unsigned\n+  \/\/   (uint) i >=u MAX_INT >= limit >= 0\n+  \/\/ or otherwise\n+  \/\/   i >= limit >= 0\n+  \/\/ holds due to (LEMMA).\n+  \/\/\n+  \/\/ For completeness, a counterexample with limit < 0:\n+  \/\/ Assume i = -3 and limit = -2:\n+  \/\/   i  < 0\n+  \/\/   -2 < 0\n+  \/\/ is true and thus also \"i < 0 || i >= limit\". But\n+  \/\/   i  >=u limit\n+  \/\/   -3 >=u -2\n+  \/\/ is false.\n+  Node* limit = cmpu->in(2);\n+  const TypeInt* type_limit = _igvn.type(limit)->is_int();\n+  if (type_limit->_lo < 0) {\n+    return nullptr;\n+  }\n+\n+  \/\/ We prove below that we can extract a single signed loop exit condition from (SLE-full), depending on the stride:\n+  \/\/   stride < 0:\n+  \/\/     i < 0        (SLE = SLE-negative)\n+  \/\/   stride > 0:\n+  \/\/     i >= limit   (SLE = SLE-positive)\n+  \/\/ such that we have the following graph before Partial Peeling with stride > 0 (similar for stride < 0):\n+  \/\/\n+  \/\/ Loop:\n+  \/\/   <peeled section>\n+  \/\/   i >= limit    (SLE-positive)\n+  \/\/   <-- CUT HERE -->\n+  \/\/   i >=u limit   (ULE)\n+  \/\/   <rest of unpeeled section>\n+  \/\/   goto Loop\n+  \/\/\n+  \/\/ We exit the loop if:\n+  \/\/   (SLE) is true OR (ULE) is true\n+  \/\/ However, if (SLE) is true then (ULE) also needs to be true to ensure the exact same behavior. Otherwise, we wrongly\n+  \/\/ exit a loop that should not have been exited if we did not apply Partial Peeling. More formally, we need to ensure:\n+  \/\/   (SLE) IMPLIES (ULE)\n+  \/\/ This indeed holds when (COND) is given:\n+  \/\/ - stride > 0:\n+  \/\/       i >=  limit             \/\/ (SLE = SLE-positive)\n+  \/\/       i >=  limit >= 0        \/\/ (COND)\n+  \/\/       i >=u limit >= 0        \/\/ (LEMMA)\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/ - stride < 0:\n+  \/\/       i        <  0           \/\/ (SLE = SLE-negative)\n+  \/\/       (uint) i >u MAX_INT     \/\/ (NEG) all negative values are greater than MAX_INT when converted to unsigned\n+  \/\/       MAX_INT >= limit >= 0   \/\/ (COND)\n+  \/\/       MAX_INT >=u limit >= 0  \/\/ (LEMMA)\n+  \/\/     and thus from (NEG) and (LEMMA):\n+  \/\/       i >=u limit\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/\n+  \/\/\n+  \/\/ After Partial Peeling, we have the following structure for stride > 0 (similar for stride < 0):\n+  \/\/   <cloned peeled section>\n+  \/\/   i >= limit (SLE-positive)\n+  \/\/   Loop:\n+  \/\/     i >=u limit (ULE)\n+  \/\/     <rest of unpeeled section>\n+  \/\/     <peeled section>\n+  \/\/     i >= limit (SLE-positive)\n+  \/\/     goto Loop\n+  Node* rhs_cmpi;\n@@ -3230,1 +3359,1 @@\n-    limit = cmpu->in(2);\n+    rhs_cmpi = limit; \/\/ For i >= limit\n@@ -3232,2 +3361,2 @@\n-    limit = _igvn.makecon(TypeInt::ZERO);\n-    set_ctrl(limit, C->root());\n+    rhs_cmpi = _igvn.makecon(TypeInt::ZERO); \/\/ For i < 0\n+    set_ctrl(rhs_cmpi, C->root());\n@@ -3241,1 +3370,1 @@\n-  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, limit, lp_continue);\n+  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, rhs_cmpi, lp_continue);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":175,"deletions":46,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -3571,1 +3571,1 @@\n-    if (!is_StoreVector() || as_StoreVector()->vect_type() == mem->as_LoadVector()->vect_type()) {\n+    if (!is_StoreVector() || (mem->is_LoadVector() && as_StoreVector()->vect_type() == mem->as_LoadVector()->vect_type())) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1393,2 +1393,1 @@\n-  \/\/ GC barrier stubs are generated in code section\n-  code_req += bs->estimate_stub_size();\n+  stub_req += bs->estimate_stub_size();\n@@ -1404,1 +1403,1 @@\n-  if (StressCodeBuffers) {\n+  if (StressCodeBuffers)\n@@ -1406,1 +1405,1 @@\n-  }\n+\n@@ -1415,4 +1414,3 @@\n-  if (C->has_method_handle_invokes()) {\n-    total_req += deopt_handler_req;        \/\/ deopt MH handler\n-    stub_req  += deopt_handler_req;\n-  }\n+  if (C->has_method_handle_invokes())\n+    total_req += deopt_handler_req;  \/\/ deopt MH handler\n+\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1975,2 +1975,3 @@\n-      if (cmpu->Opcode() == Op_CmpU) {\n-        \/\/ Got a CmpU which might need the new type information from node n.\n+      const uint cmpu_opcode = cmpu->Opcode();\n+      if (cmpu_opcode == Op_CmpU || cmpu_opcode == Op_CmpU3) {\n+        \/\/ Got a CmpU or CmpU3 which might need the new type information from node n.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2298,1 +2298,1 @@\n-  debug_only(int *lastPtr = (int *)((char *)&checked_jni_NativeInterface + \\\n+  debug_only(intptr_t *lastPtr = (intptr_t *)((char *)&checked_jni_NativeInterface + \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_obj);\n@@ -210,1 +210,1 @@\n-    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -589,1 +589,2 @@\n-    ThreadsListHandle tlh;\n+    JavaThread* current = JavaThread::current();\n+    ThreadsListHandle tlh(current);\n@@ -593,1 +594,1 @@\n-    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), event_thread, &java_thread, &thread_obj);\n+    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), event_thread, current, &java_thread, &thread_obj);\n@@ -864,1 +865,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_oop);\n@@ -936,1 +937,1 @@\n-    err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+    err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_oop);\n@@ -1078,1 +1079,2 @@\n-  ThreadsListHandle tlh;\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n@@ -1082,1 +1084,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_oop);\n@@ -1186,1 +1188,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_oop);\n@@ -1222,1 +1224,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -1360,1 +1362,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, calling_thread, &java_thread, &thread_oop);\n@@ -1418,1 +1420,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, calling_thread, &java_thread, &thread_oop);\n@@ -1733,1 +1735,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -1784,1 +1786,2 @@\n-  ThreadsListHandle tlh;\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n@@ -1788,1 +1791,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_obj);\n@@ -1793,1 +1796,0 @@\n-  JavaThread* current = JavaThread::current();\n@@ -2050,1 +2052,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2091,1 +2093,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2133,1 +2135,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2175,1 +2177,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2217,1 +2219,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2259,1 +2261,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2300,1 +2302,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2337,1 +2339,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2374,1 +2376,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2411,1 +2413,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -2448,1 +2450,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_obj);\n@@ -3719,1 +3721,1 @@\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current_thread, &java_thread, &thread_oop);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -248,1 +249,1 @@\n-  if (UseSharedSpaces) {\n+  if (CDSConfig::is_using_archive()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2150,1 +2150,1 @@\n-  return UseSharedSpaces;\n+  return CDSConfig::is_using_archive();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3711,1 +3711,1 @@\n-  if ((UseSharedSpaces && xshare_auto_cmd_line) ||\n+  if ((CDSConfig::is_using_archive() && xshare_auto_cmd_line) ||\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -893,0 +893,3 @@\n+  develop(bool, TraceBytecodesTruncated, false,                             \\\n+          \"Truncate non control-flow bytecode when tracing bytecode\")       \\\n+                                                                            \\\n@@ -1420,1 +1423,1 @@\n-          range(1*M, 3*G)                                                   \\\n+          range(1*M, LP64_ONLY(4*G) NOT_LP64(max_uintx))                    \\\n@@ -1449,5 +1452,0 @@\n-  product(bool, ShrinkHeapInSteps, true,                                    \\\n-          \"When disabled, informs the GC to shrink the java heap directly\"  \\\n-          \" to the target size at the next full GC rather than requiring\"   \\\n-          \" smaller steps during multiple full GCs.\")                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1864,0 +1864,3 @@\n+  \/\/ enable interp_only_mode for virtual or carrier thread if it has pending bit\n+  JvmtiThreadState::process_pending_interp_only(this);\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1200,1 +1200,1 @@\n-    if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+    if (thread_oop->is_a(vmClasses::BaseVirtualThread_klass())) {\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -1050,1 +1051,1 @@\n-    if (!UseSharedSpaces) {\n+    if (!CDSConfig::is_using_archive()) {\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -726,1 +726,0 @@\n-  void set_bytes_written(julong bytes_written) { _bytes_written = bytes_written; }\n@@ -732,2 +731,0 @@\n-  void set_compressor(AbstractCompressor* p)   { _compressor = p; }\n-  int get_fd() const                           { return _writer->get_fd(); }\n@@ -737,0 +734,7 @@\n+\n+private:\n+  \/\/ internals for DumpMerger\n+  friend class DumpMerger;\n+  void set_bytes_written(julong bytes_written) { _bytes_written = bytes_written; }\n+  int get_fd() const                           { return _writer->get_fd(); }\n+  void set_compressor(AbstractCompressor* p)   { _compressor = p; }\n@@ -2636,3 +2640,5 @@\n-  char read_buf[4096];\n-  while ((cnt = segment_fs.read(read_buf, 1, 4096)) != 0) {\n-    _writer->write_raw(read_buf, cnt);\n+\n+  \/\/ Use _writer buffer for reading.\n+  while ((cnt = segment_fs.read(_writer->buffer(), 1, _writer->buffer_size())) != 0) {\n+    _writer->set_position(cnt);\n+    _writer->flush();\n@@ -2642,1 +2648,0 @@\n-  _writer->flush();\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  E first() const {\n+  E& first() {\n@@ -164,1 +164,1 @@\n-  E top() const {\n+  E const& first() const {\n@@ -166,1 +166,15 @@\n-    return _data[_len-1];\n+    return _data[0];\n+  }\n+\n+  E& top() {\n+    assert(_len > 0, \"empty\");\n+    return _data[_len - 1];\n+  }\n+\n+  E const& top() const {\n+    assert(_len > 0, \"empty\");\n+    return _data[_len - 1];\n+  }\n+\n+  E& last() {\n+    return top();\n@@ -169,1 +183,1 @@\n-  E last() const {\n+  E const& last() const {\n@@ -416,1 +430,1 @@\n-  E at_grow(int i, const E& fill = E()) {\n+  E& at_grow(int i, const E& fill = E()) {\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n@@ -352,2 +353,5 @@\n-        return MethodHandleDesc.ofMethod(STATIC, owner, name, MethodTypeDesc.of(returnType, paramTypes)\n-                                                                            .insertParameterTypes(0, INDY_BOOTSTRAP_ARGS));\n+        int prefixLen = INDY_BOOTSTRAP_ARGS.length;\n+        ClassDesc[] fullParamTypes = new ClassDesc[paramTypes.length + prefixLen];\n+        System.arraycopy(INDY_BOOTSTRAP_ARGS, 0, fullParamTypes, 0, prefixLen);\n+        System.arraycopy(paramTypes, 0, fullParamTypes, prefixLen, paramTypes.length);\n+        return MethodHandleDesc.ofMethod(STATIC, owner, name, MethodTypeDescImpl.ofTrusted(returnType, fullParamTypes));\n@@ -373,2 +377,5 @@\n-        return MethodHandleDesc.ofMethod(STATIC, owner, name, MethodTypeDesc.of(returnType, paramTypes)\n-                                                                            .insertParameterTypes(0, CONDY_BOOTSTRAP_ARGS));\n+        int prefixLen = CONDY_BOOTSTRAP_ARGS.length;\n+        ClassDesc[] fullParamTypes = new ClassDesc[paramTypes.length + prefixLen];\n+        System.arraycopy(CONDY_BOOTSTRAP_ARGS, 0, fullParamTypes, 0, prefixLen);\n+        System.arraycopy(paramTypes, 0, fullParamTypes, prefixLen, paramTypes.length);\n+        return MethodHandleDesc.ofMethod(STATIC, owner, name, MethodTypeDescImpl.ofTrusted(returnType, fullParamTypes));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-    void checkForTypeAlias(Class<?> refc) {\n+    void ensureTypeVisible(Class<?> refc) {\n@@ -829,1 +829,1 @@\n-            if (VerifyAccess.isTypeVisible(type, refc))  return;\n+            if (VerifyAccess.ensureTypeVisible(type, refc))  return;\n@@ -837,1 +837,1 @@\n-            if (VerifyAccess.isTypeVisible(type, refc))  return;\n+            if (VerifyAccess.ensureTypeVisible(type, refc))  return;\n@@ -979,1 +979,1 @@\n-                m.checkForTypeAlias(m.getDeclaringClass());\n+                m.ensureTypeVisible(m.getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    \/\/\/ MemberName support\n+    \/\/--- MemberName support\n@@ -56,1 +56,1 @@\n-    \/\/\/ Field layout queries parallel to jdk.internal.misc.Unsafe:\n+    \/\/--- Field layout queries parallel to jdk.internal.misc.Unsafe:\n@@ -62,1 +62,1 @@\n-    \/\/\/ CallSite support\n+    \/\/--- CallSite support\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-    \/\/\/\/ Method handle creation from ordinary methods.\n+    \/\/--- Method handle creation from ordinary methods.\n@@ -3753,1 +3753,1 @@\n-        \/\/\/ Helper methods, all package-private.\n+        \/\/--- Helper methods, all package-private.\n@@ -4646,1 +4646,1 @@\n-    \/\/\/ method handle invocation (reflective style)\n+    \/\/--- method handle invocation (reflective style)\n@@ -4829,1 +4829,1 @@\n-     \/\/\/ method handle modification (creation from other method handles)\n+     \/\/--- method handle modification (creation from other method handles)\n@@ -7926,0 +7926,2 @@\n+     *\n+     * @since 17\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1132,1 +1132,1 @@\n-    \/\/\/ Queries which have to do with the bytecode architecture\n+    \/\/--- Queries which have to do with the bytecode architecture\n@@ -1301,1 +1301,1 @@\n-    \/\/\/ Serialization.\n+    \/\/--- Serialization.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,2 +396,2 @@\n-     * Clears this reference object.  Invoking this method will not cause this\n-     * object to be enqueued.\n+     * Clears this reference object. Invoking this method does not enqueue this\n+     * object, and the garbage collector will not clear or enqueue this object.\n@@ -399,2 +399,10 @@\n-     * <p> This method is invoked only by Java code; when the garbage collector\n-     * clears references it does so directly, without invoking this method.\n+     * <p>When the garbage collector or the {@link #enqueue()} method clear\n+     * references they do so directly, without invoking this method.\n+     *\n+     * @apiNote\n+     * There is a potential race condition with the garbage collector. When this\n+     * method is called, the garbage collector may already be in the process of\n+     * (or already completed) clearing and\/or enqueueing this reference.\n+     * Avoid this race by ensuring the referent remains strongly reachable until\n+     * after the call to clear(), using {@link #reachabilityFence(Object)} if\n+     * necessary.\n@@ -478,2 +486,21 @@\n-     * Clears this reference object and adds it to the queue with which\n-     * it is registered, if any.\n+     * Clears this reference object, then attempts to add it to the queue with\n+     * which it is registered, if any.\n+     *\n+     * <p>If this reference is registered with a queue but not yet enqueued,\n+     * the reference is added to the queue; this method is\n+     * <b><i>successful<\/i><\/b> and returns true.\n+     * If this reference is not registered with a queue, or was already enqueued\n+     * (by the garbage collector, or a previous call to {@code enqueue}), this\n+     * method is <b><i>unsuccessful<\/i><\/b> and returns false.\n+     *\n+     * <p>{@linkplain java.lang.ref##MemoryConsistency Memory consistency effects}:\n+     * Actions in a thread prior to a <b><i>successful<\/i><\/b> call to {@code enqueue}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the reference is removed from the queue by {@link ReferenceQueue#poll}\n+     * or {@link ReferenceQueue#remove}. <b><i>Unsuccessful<\/i><\/b> calls to\n+     * {@code enqueue} have no specified memory consistency effects.\n+     *\n+     * <p> When this method clears references it does so directly, without\n+     * invoking the {@link #clear()} method. When the garbage collector clears\n+     * and enqueues references it does so directly, without invoking the\n+     * {@link #clear()} method or this method.\n@@ -481,2 +508,5 @@\n-     * <p> This method is invoked only by Java code; when the garbage collector\n-     * enqueues references it does so directly, without invoking this method.\n+     * @apiNote\n+     * Use of this method allows the registered queue's\n+     * {@link ReferenceQueue#poll} and {@link ReferenceQueue#remove} methods\n+     * to return this reference even though the referent may still be strongly\n+     * reachable.\n@@ -522,4 +552,5 @@\n-     * Ensures that the object referenced by the given reference remains\n-     * <a href=\"package-summary.html#reachability\"><em>strongly reachable<\/em><\/a>,\n-     * regardless of any prior actions of the program that might otherwise cause\n-     * the object to become unreachable; thus, the referenced object is not\n+     * Ensures that the given object remains\n+     * <a href=\"package-summary.html#reachability\"><em>strongly reachable<\/em><\/a>.\n+     * This reachability is assured regardless of any optimizing transformations\n+     * the virtual machine may perform that might otherwise allow the object to\n+     * become unreachable (see JLS {@jls 12.6.1}). Thus, the given object is not\n@@ -527,2 +558,5 @@\n-     * this method.  Invocation of this method does not itself initiate garbage\n-     * collection or finalization.\n+     * this method. References to the given object will not be cleared (or\n+     * enqueued, if applicable) by the garbage collector until after invocation\n+     * of this method.\n+     * Invocation of this method does not itself initiate reference processing,\n+     * garbage collection, or finalization.\n@@ -533,9 +567,9 @@\n-     * triggering garbage collection.  This method is designed for use in\n-     * uncommon situations of premature finalization where using\n-     * {@code synchronized} blocks or methods, or using other synchronization\n-     * facilities are not possible or do not provide the desired control.  This\n-     * method is applicable only when reclamation may have visible effects,\n-     * which is possible for objects with finalizers (See Section {@jls 12.6}\n-     * of <cite>The Java Language Specification<\/cite>) that\n-     * are implemented in ways that rely on ordering control for\n-     * correctness.\n+     * triggering garbage collection.  This method is applicable only\n+     * when reclamation may have visible effects,\n+     * such as for objects that use finalizers or {@link Cleaner}, or code that\n+     * performs {@linkplain java.lang.ref reference processing}.\n+     *\n+     * <p>{@linkplain java.lang.ref##MemoryConsistency Memory consistency effects}:\n+     * Actions in a thread prior to calling {@code reachabilityFence(x)}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the garbage collector clears any reference to {@code x}.\n@@ -544,6 +578,20 @@\n-     * Finalization may occur whenever the virtual machine detects that no\n-     * reference to an object will ever be stored in the heap: The garbage\n-     * collector may reclaim an object even if the fields of that object are\n-     * still in use, so long as the object has otherwise become unreachable.\n-     * This may have surprising and undesirable effects in cases such as the\n-     * following example in which the bookkeeping associated with a class is\n+     * Reference processing or finalization can occur after an object becomes\n+     * unreachable. An object can become unreachable when the virtual machine\n+     * detects that there is no further need for the object (other than for\n+     * running a finalizer). In the course of optimization, the virtual machine\n+     * can reorder operations of an object's methods such that the object\n+     * becomes unneeded earlier than might naively be expected &mdash;\n+     * including while a method of the object is still running. For instance,\n+     * the VM can move the loading of <em>values<\/em> from the object's fields\n+     * to occur earlier. The object itself is then no longer needed and becomes\n+     * unreachable, and the method can continue running using the obtained values.\n+     * This may have surprising and undesirable effects when using a Cleaner or\n+     * finalizer for cleanup: there is a race between the\n+     * program thread running the method, and the cleanup thread running the\n+     * Cleaner or finalizer. The cleanup thread could free a\n+     * resource, followed by the program thread (still running the method)\n+     * attempting to access the now-already-freed resource.\n+     * Use of {@code reachabilityFence} can prevent this race by ensuring that the\n+     * object remains strongly reachable.\n+     * <p>\n+     * The following is an example in which the bookkeeping associated with a class is\n@@ -553,1 +601,1 @@\n-     * {@code ExternalResource} has been performed; in particular here, to\n+     * {@code ExternalResource} has been performed; specifically, to\n@@ -558,1 +606,1 @@\n-     * <pre> {@code\n+     * {@snippet :\n@@ -564,1 +612,1 @@\n-     *     myIndex = ...\n+     *     this.myIndex = ...\n@@ -569,1 +617,1 @@\n-     *     externalResourceArray[myIndex] = null;\n+     *     externalResourceArray[this.myIndex] = null;\n@@ -575,1 +623,1 @@\n-     *       int i = myIndex;\n+     *       int i = this.myIndex; \/\/ last use of 'this' Resource in action()\n@@ -584,1 +632,2 @@\n-     * }}<\/pre>\n+     * }\n+     * }\n@@ -586,1 +635,1 @@\n-     * Here, the invocation of {@code reachabilityFence} is nonintuitively\n+     * The invocation of {@code reachabilityFence} is\n@@ -590,1 +639,1 @@\n-     * object.  This might be the case if, for example a usage in a user program\n+     * object.  This might be the case if, for example, a usage in a user program\n@@ -592,22 +641,5 @@\n-     * reference to this {@code Resource}.  While probably overkill here,\n-     * {@code reachabilityFence} is placed in a {@code finally} block to ensure\n-     * that it is invoked across all paths in the method.  In a method with more\n-     * complex control paths, you might need further precautions to ensure that\n-     * {@code reachabilityFence} is encountered along all of them.\n-     *\n-     * <p> It is sometimes possible to better encapsulate use of\n-     * {@code reachabilityFence}.  Continuing the above example, if it were\n-     * acceptable for the call to method {@code update} to proceed even if the\n-     * finalizer had already executed (nulling out slot), then you could\n-     * localize use of {@code reachabilityFence}:\n-     *\n-     * <pre> {@code\n-     * public void action2() {\n-     *   \/\/ ...\n-     *   Resource.update(getExternalResource());\n-     * }\n-     * private ExternalResource getExternalResource() {\n-     *   ExternalResource ext = externalResourceArray[myIndex];\n-     *   Reference.reachabilityFence(this);\n-     *   return ext;\n-     * }}<\/pre>\n+     * reference to this {@code Resource}.\n+     * The {@code reachabilityFence} call is placed in a {@code finally} block to\n+     * ensure that it is invoked across all paths in the method. A more complex\n+     * method might need further precautions to ensure that\n+     * {@code reachabilityFence} is encountered along all code paths.\n@@ -623,1 +655,1 @@\n-     * remains a better option in cases where this approach is not as efficient,\n+     * remains a better option in cases where synchronization is not as efficient,\n@@ -626,1 +658,2 @@\n-     * @param ref the reference. If {@code null}, this method has no effect.\n+     * @param ref the reference to the object to keep strongly reachable. If\n+     * {@code null}, this method has no effect.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":94,"deletions":61,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -859,0 +859,2 @@\n+            if (target == m) return;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -29,7 +30,1 @@\n-import java.lang.classfile.constantpool.*;\n-import sun.security.action.GetBooleanAction;\n-\n-import java.io.IOException;\n-import static java.lang.classfile.ClassFile.*;\n-import java.lang.classfile.attribute.StackMapFrameInfo;\n-import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.constantpool.*;\n@@ -38,1 +33,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n@@ -43,1 +37,0 @@\n-import java.util.Arrays;\n@@ -49,1 +42,12 @@\n-import java.util.function.IntFunction;\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ClassDescImpl;\n+import sun.security.action.GetBooleanAction;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.constant.ConstantDescs;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n@@ -60,0 +64,3 @@\n+    private static final ClassFile CF_CONTEXT =\n+            ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+\n@@ -61,10 +68,9 @@\n-            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n-            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n-            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n-            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n-            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n-            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n-            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n-            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n-            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n-            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+            CD_Class_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n+            CD_IllegalAccessException = ClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n+            CD_InvocationHandler = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n+            CD_Method = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n+            CD_NoSuchMethodError = ClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n+            CD_NoSuchMethodException = ClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n+            CD_Object_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n+            CD_Proxy = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n+            CD_UndeclaredThrowableException = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n@@ -73,12 +79,11 @@\n-            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n-            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n-            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n-            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n-            MTD_Class = MethodTypeDesc.of(CD_Class),\n-            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n-            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n-            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n-            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n-            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n-            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n-            MTD_String = MethodTypeDesc.of(CD_String);\n+            MTD_boolean = MethodTypeDescImpl.ofValidated(CD_boolean),\n+            MTD_void_InvocationHandler = MethodTypeDescImpl.ofValidated(CD_void, CD_InvocationHandler),\n+            MTD_void_String = MethodTypeDescImpl.ofValidated(CD_void, CD_String),\n+            MTD_void_Throwable = MethodTypeDescImpl.ofValidated(CD_void, CD_Throwable),\n+            MTD_Class = MethodTypeDescImpl.ofValidated(CD_Class),\n+            MTD_Class_array = MethodTypeDescImpl.ofValidated(CD_Class_array),\n+            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, ConstantDescs.CD_String, CD_Class_array),\n+            MTD_MethodHandles$Lookup = MethodTypeDescImpl.ofValidated(CD_MethodHandles_Lookup),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDescImpl.ofValidated(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDescImpl.ofValidated(CD_Object, CD_Object, CD_Method, CD_Object_array),\n+            MTD_String = MethodTypeDescImpl.ofValidated(CD_String);\n@@ -93,1 +98,1 @@\n-    private static final String handlerFieldName = \"h\";\n+    private static final String NAME_HANDLER_FIELD = \"h\";\n@@ -99,1 +104,1 @@\n-    private static final boolean saveGeneratedFiles =\n+    private static final boolean SAVE_GENERATED_FILES =\n@@ -105,35 +110,3 @@\n-    private static final ProxyMethod hashCodeMethod;\n-    private static final ProxyMethod equalsMethod;\n-    private static final ProxyMethod toStringMethod;\n-\n-    private static final ClassModel TEMPLATE;\n-\n-    private static final ClassEntry CE_Class;\n-    private static final ClassEntry CE_ClassNotFoundException;\n-    private static final ClassEntry CE_NoClassDefFoundError;\n-    private static final ClassEntry CE_NoSuchMethodError;\n-    private static final ClassEntry CE_NoSuchMethodException;\n-    private static final ClassEntry CE_Object;\n-    private static final ClassEntry CE_Throwable;\n-    private static final ClassEntry CE_UndeclaredThrowableException;\n-\n-    private static final FieldRefEntry FRE_Proxy_h;\n-\n-    private static final InterfaceMethodRefEntry IMRE_InvocationHandler_invoke;\n-\n-    private static final MethodRefEntry MRE_Class_forName;\n-    private static final MethodRefEntry MRE_Class_getClassLoader;\n-    private static final MethodRefEntry MRE_Class_getMethod;\n-    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n-    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n-    private static final MethodRefEntry MRE_Throwable_getMessage;\n-    private static final MethodRefEntry MRE_UndeclaredThrowableException_init;\n-\n-    private static final Utf8Entry UE_Method;\n-\n-    private static final List<StackMapFrameInfo.VerificationTypeInfo> THROWABLE_STACK;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T extends PoolEntry> T entryByIndex(int index) {\n-        return (T) TEMPLATE.constantPool().entryByIndex(index);\n-    }\n+    private static final ProxyMethod HASH_CODE_METHOD;\n+    private static final ProxyMethod EQUALS_METHOD;\n+    private static final ProxyMethod TO_STRING_METHOD;\n@@ -142,65 +115,3 @@\n-        \/\/ static template ClassModel holds pre-defined constant pool entries\n-        \/\/ proxy transformed from the template shares the template constant pool\n-        \/\/ each direct use of the template pool entry is significantly faster\n-        var cc = ClassFile.of();\n-        var ei = new int[21];\n-        TEMPLATE = cc.parse(cc.build(CD_Proxy, clb -> {\n-            clb.withSuperclass(CD_Proxy);\n-            generateConstructor(clb);\n-            generateLookupAccessor(clb);\n-            var cp = clb.constantPool();\n-\n-            ei[0] = cp.classEntry(CD_Class).index();\n-            ei[1] = cp.classEntry(CD_ClassNotFoundException).index();\n-            ei[2] = cp.classEntry(CD_NoClassDefFoundError).index();\n-            ei[3] = cp.classEntry(CD_NoSuchMethodError).index();\n-            ei[4] = cp.classEntry(CD_NoSuchMethodException).index();\n-            ei[5] = cp.classEntry(CD_Object).index();\n-            ei[6] = cp.classEntry(CD_Throwable).index();\n-            ei[7] = cp.classEntry(CD_UndeclaredThrowableException).index();\n-\n-            ei[8] = cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler).index();\n-\n-            ei[9] = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray).index();\n-\n-            ei[10] = cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader).index();\n-            ei[11] = cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader).index();\n-            ei[12] = cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray).index();\n-            ei[13] = cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String).index();\n-            ei[14] = cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String).index();\n-            ei[15] = cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String).index();\n-            ei[16] = cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable).index();\n-\n-            ei[17] = cp.utf8Entry(CD_Method).index();\n-\n-            ei[18] = cp.utf8Entry(\"m0\").index();\n-            ei[19] = cp.utf8Entry(\"m1\").index();\n-            ei[20] = cp.utf8Entry(\"m2\").index();\n-        }));\n-\n-        CE_Class = entryByIndex(ei[0]);\n-        CE_ClassNotFoundException = entryByIndex(ei[1]);\n-        CE_NoClassDefFoundError = entryByIndex(ei[2]);\n-        CE_NoSuchMethodError = entryByIndex(ei[3]);\n-        CE_NoSuchMethodException = entryByIndex(ei[4]);\n-        CE_Object = entryByIndex(ei[5]);\n-        CE_Throwable = entryByIndex(ei[6]);\n-        CE_UndeclaredThrowableException = entryByIndex(ei[7]);\n-\n-        FRE_Proxy_h = entryByIndex(ei[8]);\n-\n-        IMRE_InvocationHandler_invoke = entryByIndex(ei[9]);\n-\n-        MRE_Class_forName = entryByIndex(ei[10]);\n-        MRE_Class_getClassLoader = entryByIndex(ei[11]);\n-        MRE_Class_getMethod = entryByIndex(ei[12]);\n-        MRE_NoClassDefFoundError_init = entryByIndex(ei[13]);\n-        MRE_NoSuchMethodError_init = entryByIndex(ei[14]);\n-        MRE_Throwable_getMessage = entryByIndex(ei[15]);\n-        MRE_UndeclaredThrowableException_init = entryByIndex(ei[16]);\n-\n-        UE_Method = entryByIndex(ei[17]);\n-\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), entryByIndex(ei[18]));\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), entryByIndex(ei[19]));\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), entryByIndex(ei[20]));\n+            HASH_CODE_METHOD = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n+            EQUALS_METHOD = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n+            TO_STRING_METHOD = new ProxyMethod(Object.class.getMethod(\"toString\"));\n@@ -211,2 +122,0 @@\n-\n-        THROWABLE_STACK = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CE_Throwable));\n@@ -215,4 +124,8 @@\n-    \/**\n-     * Classfile context\n-     *\/\n-    private final ClassFile classfileContext;\n+    private final List<StackMapFrameInfo.VerificationTypeInfo> throwableStack;\n+    private final NameAndTypeEntry exInit;\n+    private final ClassEntry object, proxy, ute;\n+    private final FieldRefEntry handlerField;\n+    private final InterfaceMethodRefEntry invoke;\n+    private final MethodRefEntry uteInit;\n+    private final DirectMethodHandleDesc bsm;\n+\n@@ -243,6 +156,0 @@\n-    \/**\n-     * Ordinal of next ProxyMethod object added to proxyMethods.\n-     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n-     *\/\n-    private int proxyMethodCount = 3;\n-\n@@ -258,6 +165,2 @@\n-        this.classfileContext = ClassFile.of(\n-                ClassFile.StackMapsOption.DROP_STACK_MAPS,\n-                ClassFile.ClassHierarchyResolverOption.of(\n-                        ClassHierarchyResolver.ofClassLoading(loader).cached()));\n-        this.cp = ConstantPoolBuilder.of(TEMPLATE);\n-        this.classEntry = cp.classEntry(ClassDesc.of(className));\n+        this.cp = ConstantPoolBuilder.of();\n+        this.classEntry = cp.classEntry(ClassDescImpl.ofValidatedBinaryName(className));\n@@ -266,0 +169,9 @@\n+        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_Throwable)));\n+        this.exInit = cp.nameAndTypeEntry(INIT_NAME, MTD_void_String);\n+        this.object = cp.classEntry(CD_Object);\n+        this.proxy = cp.classEntry(CD_Proxy);\n+        this.handlerField = cp.fieldRefEntry(proxy, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n+        this.invoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+        this.ute = cp.classEntry(CD_UndeclaredThrowableException);\n+        this.uteInit = cp.methodRefEntry(ute, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n+        this.bsm = ConstantDescs.ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String, CD_MethodType);\n@@ -284,1 +196,1 @@\n-        if (saveGeneratedFiles) {\n+        if (SAVE_GENERATED_FILES) {\n@@ -315,4 +227,4 @@\n-    private static ClassEntry[] toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n-        var ces = new ClassEntry[types.size()];\n-        for (int i = 0; i < ces.length; i++)\n-            ces[i] = cp.classEntry(cp.utf8Entry(types.get(i).getName().replace('.', '\/')));\n+    private static List<ClassEntry> toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n+        var ces = new ArrayList<ClassEntry>(types.size());\n+        for (var t : types)\n+            ces.add(cp.classEntry(ClassDescImpl.ofValidatedBinaryName(t.getName())));\n@@ -538,3 +450,3 @@\n-        addProxyMethod(hashCodeMethod);\n-        addProxyMethod(equalsMethod);\n-        addProxyMethod(toStringMethod);\n+        addProxyMethod(HASH_CODE_METHOD);\n+        addProxyMethod(EQUALS_METHOD);\n+        addProxyMethod(TO_STRING_METHOD);\n@@ -548,1 +460,1 @@\n-                    addProxyMethod(m, intf, cp);\n+                    addProxyMethod(m, intf);\n@@ -561,2 +473,2 @@\n-        return classfileContext.build(classEntry, cp, clb -> {\n-            TEMPLATE.forEach(clb);\n+        return CF_CONTEXT.build(classEntry, cp, clb -> {\n+            clb.withSuperclass(proxy);\n@@ -565,0 +477,1 @@\n+            generateConstructor(clb);\n@@ -568,4 +481,1 @@\n-                    \/\/ add static field for the Method object\n-                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-\n-                    pm.generateMethod(clb, classEntry);\n+                    pm.generateMethod(this, clb);\n@@ -576,1 +486,2 @@\n-            generateStaticInitializer(clb);\n+            generateBootstrapMethod(clb);\n+            generateLookupAccessor(clb);\n@@ -593,1 +504,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n+    private void addProxyMethod(Method m, Class<?> fromClass) {\n@@ -618,2 +529,1 @@\n-                exceptionTypes, fromClass,\n-                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n+                exceptionTypes, fromClass));\n@@ -637,1 +547,1 @@\n-    private static void generateConstructor(ClassBuilder clb) {\n+    private void generateConstructor(ClassBuilder clb) {\n@@ -639,3 +549,3 @@\n-               .aload(cob.receiverSlot())\n-               .aload(cob.parameterSlot(0))\n-               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n+               .aload(0)\n+               .aload(1)\n+               .invokespecial(cp.methodRefEntry(proxy, cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n@@ -646,1 +556,1 @@\n-     * Generate the static initializer method for the proxy class.\n+     * Generate CONDY bootstrap method for the proxy class to retrieve {@link Method} instances.\n@@ -648,17 +558,12 @@\n-    private void generateStaticInitializer(ClassBuilder clb) {\n-        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n-            \/\/ Put ClassLoader at local variable index 0, used by\n-            \/\/ Class.forName(String, boolean, ClassLoader) calls\n-            cob.ldc(classEntry)\n-               .invokevirtual(MRE_Class_getClassLoader)\n-               .astore(0);\n-            var ts = cob.newBoundLabel();\n-            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-                for (ProxyMethod pm : sigmethods) {\n-                    pm.codeFieldInitialization(cob, classEntry);\n-                }\n-            }\n-            cob.return_();\n-            var c1 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n-               .new_(CE_NoSuchMethodError)\n+    private void generateBootstrapMethod(ClassBuilder clb) {\n+        clb.withMethodBody(bsm.methodName(), bsm.invocationType(), ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC, cob -> {\n+            cob.aload(3) \/\/interface Class\n+               .aload(4) \/\/interface method name String\n+               .aload(5) \/\/interface MethodType\n+               .invokevirtual(CD_MethodType, \"parameterArray\", MTD_Class_array)\n+               .invokevirtual(ConstantDescs.CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n+               .areturn();\n+            Label failLabel = cob.newBoundLabel();\n+            ClassEntry nsme = cp.classEntry(CD_NoSuchMethodError);\n+            cob.exceptionCatch(cob.startLabel(), failLabel, failLabel, CD_NoSuchMethodException)\n+               .new_(nsme)\n@@ -667,10 +572,2 @@\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoSuchMethodError_init)\n-               .athrow();\n-            var c2 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n-               .new_(CE_NoClassDefFoundError)\n-               .dup_x1()\n-               .swap()\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoClassDefFoundError_init)\n+               .invokevirtual(cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String))\n+               .invokespecial(cp.methodRefEntry(nsme, exInit))\n@@ -679,2 +576,1 @@\n-                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n-                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                       StackMapFrameInfo.of(failLabel, List.of(), throwableStack))));\n@@ -689,1 +585,1 @@\n-    private static void generateLookupAccessor(ClassBuilder clb) {\n+    private void generateLookupAccessor(ClassBuilder clb) {\n@@ -694,17 +590,25 @@\n-                        .withCode(cob -> cob\n-                            .block(blockBuilder -> blockBuilder\n-                                    .aload(cob.parameterSlot(0))\n-                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n-                                    .ldc(CD_Proxy)\n-                                    .if_acmpne(blockBuilder.breakLabel())\n-                                    .aload(cob.parameterSlot(0))\n-                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n-                                    .ifeq(blockBuilder.breakLabel())\n-                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n-                                    .areturn())\n-                            .new_(CD_IllegalAccessException)\n-                            .dup()\n-                            .aload(cob.parameterSlot(0))\n-                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n-                            .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n-                            .athrow()));\n+                        .withCode(cob -> {\n+                            Label failLabel = cob.newLabel();\n+                            ClassEntry mhl = cp.classEntry(CD_MethodHandles_Lookup);\n+                            ClassEntry iae = cp.classEntry(CD_IllegalAccessException);\n+                            cob.aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"lookupClass\", MTD_Class)))\n+                               .ldc(proxy)\n+                               .if_acmpne(failLabel)\n+                               .aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"hasFullPrivilegeAccess\", MTD_boolean)))\n+                               .ifeq(failLabel)\n+                               .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                               .areturn()\n+                               .labelBinding(failLabel)\n+                               .new_(iae)\n+                               .dup()\n+                               .aload(cob.parameterSlot(0))\n+                               .invokevirtual(cp.methodRefEntry(mhl, cp.nameAndTypeEntry(\"toString\", MTD_String)))\n+                               .invokespecial(cp.methodRefEntry(iae, exInit))\n+                               .athrow()\n+                               .with(StackMapTableAttribute.of(List.of(\n+                                       StackMapFrameInfo.of(failLabel,\n+                                               List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(mhl)),\n+                                               List.of()))));\n+                        }));\n@@ -725,1 +629,0 @@\n-        private final Utf8Entry methodFieldName;\n@@ -730,1 +633,1 @@\n-                            Class<?> fromClass, Utf8Entry methodFieldName) {\n+                            Class<?> fromClass) {\n@@ -737,1 +640,0 @@\n-            this.methodFieldName = methodFieldName;\n@@ -746,1 +648,1 @@\n-        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n+        private ProxyMethod(Method method) {\n@@ -749,1 +651,1 @@\n-                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass());\n@@ -755,4 +657,7 @@\n-        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n-            var cp = clb.constantPool();\n-            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n-                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        private void generateMethod(ProxyGenerator pg, ClassBuilder clb) {\n+            var cp = pg.cp;\n+            var pTypes = new ClassDesc[parameterTypes.length];\n+            for (int i = 0; i < pTypes.length; i++) {\n+                pTypes[i] = toClassDesc(parameterTypes[i]);\n+            }\n+            MethodTypeDesc desc = MethodTypeDescImpl.ofTrusted(toClassDesc(returnType), pTypes);\n@@ -765,5 +670,7 @@\n-                        cob.aload(cob.receiverSlot())\n-                           .getfield(FRE_Proxy_h)\n-                           .aload(cob.receiverSlot())\n-                           .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n-\n+                        cob.aload(0)\n+                           .getfield(pg.handlerField)\n+                           .aload(0)\n+                           .ldc(DynamicConstantDesc.of(pg.bsm,\n+                                toClassDesc(fromClass),\n+                                method.getName(),\n+                                desc));\n@@ -773,1 +680,1 @@\n-                               .anewarray(CE_Object);\n+                               .anewarray(pg.object);\n@@ -784,1 +691,1 @@\n-                        cob.invokeinterface(IMRE_InvocationHandler_invoke);\n+                        cob.invokeinterface(pg.invoke);\n@@ -800,1 +707,1 @@\n-                               .new_(CE_UndeclaredThrowableException)\n+                               .new_(pg.ute)\n@@ -803,1 +710,1 @@\n-                               .invokespecial(MRE_UndeclaredThrowableException_init)\n+                               .invokespecial(pg.uteInit)\n@@ -806,2 +713,2 @@\n-                                    StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n-                                    StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                                       StackMapFrameInfo.of(c1, List.of(), pg.throwableStack),\n+                                       StackMapFrameInfo.of(c2, List.of(), pg.throwableStack))));\n@@ -822,1 +729,1 @@\n-                cob.invokestatic(prim.wrapperMethodRef);\n+                cob.invokestatic(prim.wrapperMethodRef(cob.constantPool()));\n@@ -838,1 +745,1 @@\n-                   .invokevirtual(prim.unwrapMethodRef)\n+                   .invokevirtual(prim.unwrapMethodRef(cob.constantPool()))\n@@ -846,48 +753,0 @@\n-        \/**\n-         * Generate code for initializing the static field that stores\n-         * the Method object for this proxy method. A class loader is\n-         * anticipated at local variable index 0.\n-         *\/\n-        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n-            var cp = cob.constantPool();\n-            codeClassForName(cob, fromClass);\n-\n-            cob.ldc(method.getName())\n-               .loadConstant(parameterTypes.length)\n-               .anewarray(CE_Class);\n-\n-            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n-            for (int i = 0; i < parameterTypes.length; i++) {\n-                cob.dup()\n-                   .loadConstant(i);\n-                if (parameterTypes[i].isPrimitive()) {\n-                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    cob.getstatic(prim.typeFieldRef);\n-                } else {\n-                    codeClassForName(cob, parameterTypes[i]);\n-                }\n-                cob.aastore();\n-            }\n-            \/\/ lookup the method\n-            cob.invokevirtual(MRE_Class_getMethod)\n-               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n-        }\n-\n-        \/*\n-         * =============== Code Generation Utility Methods ===============\n-         *\/\n-\n-        \/**\n-         * Generate code to invoke the Class.forName with the name of the given\n-         * class to get its Class object at runtime.  The code is written to\n-         * the supplied stream.  Note that the code generated by this method\n-         * may cause the checked ClassNotFoundException to be thrown. A class\n-         * loader is anticipated at local variable index 0.\n-         *\/\n-        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n-            cob.ldc(cl.getName())\n-               .iconst_0() \/\/ false\n-               .aload(0)\/\/ classLoader\n-               .invokestatic(MRE_Class_forName);\n-        }\n-\n@@ -900,1 +759,0 @@\n-    private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -917,1 +775,1 @@\n-         * CP entry of corresponding wrapper class\n+         * wrapper class\n@@ -919,1 +777,1 @@\n-        private final ClassEntry wrapperClass;\n+        private final ClassDesc wrapperClass;\n@@ -921,1 +779,1 @@\n-         * CP entry for wrapper class \"valueOf\" factory method\n+         * wrapper factory method type\n@@ -923,1 +781,1 @@\n-        private final MethodRefEntry wrapperMethodRef;\n+        private final MethodTypeDesc wrapperMethodType;\n@@ -925,1 +783,1 @@\n-         * CP entry of wrapper class method for retrieving primitive value\n+         * wrapper class method name for retrieving primitive value\n@@ -927,1 +785,1 @@\n-        private final MethodRefEntry unwrapMethodRef;\n+        private final String unwrapMethodName;\n@@ -929,1 +787,1 @@\n-         * CP entry of wrapper class TYPE field\n+         * wrapper class method type for retrieving primitive value\n@@ -931,1 +789,1 @@\n-        private final FieldRefEntry typeFieldRef;\n+        private final MethodTypeDesc unwrapMethodType;\n@@ -935,4 +793,4 @@\n-            this.wrapperClass = CP.classEntry(wrapperClass);\n-            this.wrapperMethodRef = CP.methodRefEntry(wrapperClass, \"valueOf\", MethodTypeDesc.of(wrapperClass, baseType));\n-            this.unwrapMethodRef = CP.methodRefEntry(wrapperClass, primitiveClass.getName() + \"Value\", MethodTypeDesc.of(baseType));\n-            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+            this.wrapperClass = wrapperClass;\n+            this.wrapperMethodType = MethodTypeDescImpl.ofValidated(wrapperClass, baseType);\n+            this.unwrapMethodName = primitiveClass.getName() + \"Value\";\n+            this.unwrapMethodType = MethodTypeDescImpl.ofValidated(baseType);\n@@ -953,0 +811,8 @@\n+\n+        public MethodRefEntry wrapperMethodRef(ConstantPoolBuilder cp) {\n+            return cp.methodRefEntry(wrapperClass, \"valueOf\", wrapperMethodType);\n+        }\n+\n+        public MethodRefEntry unwrapMethodRef(ConstantPoolBuilder cp) {\n+            return cp.methodRefEntry(wrapperClass, unwrapMethodName, unwrapMethodType);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":173,"deletions":307,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4368,5 +4368,1 @@\n-        return switch (a.length) {\n-            case 0 -> 1;\n-            case 1 -> 31 + a[0];\n-            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_INT);\n-        };\n+        return ArraysSupport.hashCode(a, 0, a.length, 1);\n@@ -4395,5 +4391,1 @@\n-        return switch (a.length) {\n-            case 0 -> 1;\n-            case 1 -> 31 + (int)a[0];\n-            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_SHORT);\n-        };\n+        return ArraysSupport.hashCode(a, 0, a.length, 1);\n@@ -4422,5 +4414,1 @@\n-        return switch (a.length) {\n-            case 0 -> 1;\n-            case 1 -> 31 + (int)a[0];\n-            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_CHAR);\n-        };\n+        return ArraysSupport.hashCode(a, 0, a.length, 1);\n@@ -4449,5 +4437,1 @@\n-        return switch (a.length) {\n-            case 0 -> 1;\n-            case 1 -> 31 + (int)a[0];\n-            default -> ArraysSupport.vectorizedHashCode(a, 0, a.length, 1, ArraysSupport.T_BYTE);\n-        };\n+        return ArraysSupport.hashCode(a, 0, a.length, 1);\n@@ -4559,1 +4543,1 @@\n-        if (a == null)\n+        if (a == null) {\n@@ -4561,7 +4545,2 @@\n-\n-        int result = 1;\n-\n-        for (Object element : a)\n-            result = 31 * result + Objects.hashCode(element);\n-\n-        return result;\n+        }\n+        return ArraysSupport.hashCode(a, 0, a.length, 1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":8,"deletions":29,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    final ClassReader classReader;\n+    final ClassReaderImpl classReader;\n@@ -59,1 +59,1 @@\n-        this.classReader = classReader;\n+        this.classReader = (ClassReaderImpl)classReader;\n@@ -635,1 +635,1 @@\n-                            (Utf8Entry) classReader.readEntryOrNull(p + 4));\n+                            classReader.readEntryOrNull(p + 4, Utf8Entry.class));\n@@ -774,9 +774,3 @@\n-                    ClassEntry innerClass = classReader.readClassEntry(p); \/\/ TODO FIXME\n-                    int outerClassIndex = classReader.readU2(p + 2);\n-                    ClassEntry outerClass = outerClassIndex == 0\n-                            ? null\n-                            : (ClassEntry) classReader.entryByIndex(outerClassIndex);\n-                    int innerNameIndex = classReader.readU2(p + 4);\n-                    Utf8Entry innerName = innerNameIndex == 0\n-                            ? null\n-                            : (Utf8Entry) classReader.entryByIndex(innerNameIndex);\n+                    ClassEntry innerClass = classReader.readClassEntry(p);\n+                    var outerClass = classReader.readEntryOrNull(p + 2, ClassEntry.class);\n+                    var innerName = classReader.readEntryOrNull(p + 4, Utf8Entry.class);\n@@ -806,1 +800,1 @@\n-            return Optional.ofNullable((NameAndTypeEntry) classReader.readEntryOrNull(payloadStart + 2));\n+            return Optional.ofNullable(classReader.readEntryOrNull(payloadStart + 2, NameAndTypeEntry.class));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.ArrayList;\n@@ -38,1 +39,0 @@\n-import java.util.Objects;\n@@ -78,1 +78,1 @@\n-    public static final class ListNodeImpl extends AbstractList<Node> implements ListNode {\n+    public static sealed class ListNodeImpl extends AbstractList<Node> implements ListNode {\n@@ -82,1 +82,1 @@\n-        private final Node[] nodes;\n+        protected final List<Node> nodes;\n@@ -87,1 +87,7 @@\n-            this.nodes = nodes.toArray(Node[]::new);\n+            this.nodes = nodes.toList();\n+        }\n+\n+        protected ListNodeImpl(Style style, ConstantDesc name, List<Node> nodes) {\n+            this.style = style;\n+            this.name = name;\n+            this.nodes = nodes;\n@@ -106,2 +112,1 @@\n-            Objects.checkIndex(index, nodes.length);\n-            return nodes[index];\n+            return nodes.get(index);\n@@ -112,1 +117,1 @@\n-            return nodes.length;\n+            return nodes.size();\n@@ -118,0 +123,6 @@\n+        private static final class PrivateListNodeImpl extends ListNodeImpl {\n+            PrivateListNodeImpl(Style style, ConstantDesc name, Node... n) {\n+                super(style, name, new ArrayList<>(List.of(n)));\n+            }\n+        }\n+\n@@ -201,3 +212,13 @@\n-            for (var n : nodes)\n-                if (n != null && map.put(n.name(), n) != null)\n-                    throw new AssertionError(\"Double entry of \" + n.name() + \" into \" + name);\n+            for (var n : nodes) {\n+                if (n != null) {\n+                    var prev = map.putIfAbsent(n.name(), n);\n+                    if (prev != null) {\n+                        \/\/nodes with duplicite keys are joined into a list\n+                        if (prev instanceof PrivateListNodeImpl list) {\n+                            list.nodes.add(n);\n+                        } else {\n+                            map.put(n.name(), new PrivateListNodeImpl(style, n.name(), prev, n));\n+                        }\n+                    }\n+                }\n+            }\n@@ -981,1 +1002,1 @@\n-                            .map(rc -> new MapNodeImpl(BLOCK, \"record\")\n+                            .map(rc -> new MapNodeImpl(BLOCK, \"component\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -129,4 +129,4 @@\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        ClassDesc constant = (ClassDesc) o;\n-        return descriptor.equals(constant.descriptorString());\n+        if (o instanceof ClassDescImpl constant) {\n+            return descriptor.equals(constant.descriptor);\n+        }\n+        return false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassDescImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -160,0 +160,3 @@\n+            \/\/ common case fast-path\n+            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))\n+                continue;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        @JEP(number=464, title=\"Scoped Values\", status=\"Second Preview\")\n+        @JEP(number=481, title=\"Scoped Values\", status=\"Third Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-    \/\/\/ peek and poke operations\n-    \/\/\/ (compilers should optimize these to memory ops)\n+    \/\/--- peek and poke operations\n+    \/\/ (compilers should optimize these to memory ops)\n@@ -549,1 +549,1 @@\n-    \/\/\/ helper methods for validating various types of objects\/values\n+    \/\/--- helper methods for validating various types of objects\/values\n@@ -710,1 +710,1 @@\n-    \/\/\/ wrappers for malloc, realloc, free:\n+    \/\/--- wrappers for malloc, realloc, free:\n@@ -1161,1 +1161,1 @@\n-    \/\/\/ random queries\n+    \/\/--- random queries\n@@ -1452,1 +1452,1 @@\n-    \/\/\/ random trusted operations from JNI:\n+    \/\/--- random trusted operations from JNI:\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-    public static boolean isTypeVisible(Class<?> type, Class<?> refc) {\n+    public static boolean ensureTypeVisible(Class<?> type, Class<?> refc) {\n@@ -288,6 +288,8 @@\n-        if (typeLoader == null && type.getName().startsWith(\"java.\")) {\n-            \/\/ Note:  The API for actually loading classes, ClassLoader.defineClass,\n-            \/\/ guarantees that classes with names beginning \"java.\" cannot be aliased,\n-            \/\/ because class loaders cannot load them directly.\n-            return true;\n-        }\n+\n+        \/\/ The API for actually loading classes, ClassLoader.defineClass,\n+        \/\/ guarantees that classes with names beginning \"java.\" cannot be aliased,\n+        \/\/ because class loaders cannot load them directly. However, it is beneficial\n+        \/\/ for JIT-compilers to ensure all signature classes are loaded.\n+        \/\/ JVM doesn't install any loader contraints when performing MemberName resolution,\n+        \/\/ so eagerly resolving signature classes is a way to match what JVM achieves\n+        \/\/ with loader constraints during method resolution for invoke bytecodes.\n@@ -342,2 +344,2 @@\n-    public static boolean isTypeVisible(java.lang.invoke.MethodType type, Class<?> refc) {\n-        if (!isTypeVisible(type.returnType(), refc)) {\n+    public static boolean ensureTypeVisible(java.lang.invoke.MethodType type, Class<?> refc) {\n+        if (!ensureTypeVisible(type.returnType(), refc)) {\n@@ -347,1 +349,1 @@\n-            if (!isTypeVisible(type.parameterType(n), refc)) {\n+            if (!ensureTypeVisible(type.parameterType(n), refc)) {\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+    public final Type restrictedInternalType;\n@@ -625,0 +626,1 @@\n+        restrictedInternalType = enterSyntheticAnnotation(\"jdk.internal.javac.Restricted+Annotation\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1182,0 +1182,9 @@\n+\n+        @Override\n+        public void visitErroneous(JCErroneous tree) {\n+            if (tree.errs != null) {\n+                for (JCTree err : tree.errs) {\n+                    scan(err);\n+                }\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4254,0 +4254,4 @@\n+        if (tree.var.isImplicitlyTyped()) {\n+            setSyntheticVariableType(tree.var, type == Type.noType ? syms.errType\n+                                                                   : type);\n+        }\n@@ -5270,1 +5274,8 @@\n-        Type underlyingType = attribType(tree.underlyingType, env);\n+        Type underlyingType =\n+                attribTree(tree.underlyingType, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n+        if (underlyingType.hasTag(PACKAGE)) {\n+            \/\/ Type annotations are not admissible on packages, but we handle packages here to\n+            \/\/ report better diagnostics later in validateAnnotatedType.\n+            result = tree.type = underlyingType;\n+            return;\n+        }\n@@ -5308,0 +5319,2 @@\n+\n+        annotate.flush();\n@@ -5882,6 +5895,4 @@\n-                        if (at.getAnnotations().size() == 1) {\n-                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));\n-                        } else {\n-                            ListBuffer<Attribute.Compound> comps = new ListBuffer<>();\n-                            for (JCAnnotation an : at.getAnnotations()) {\n-                                comps.add(an.attribute);\n+                        ListBuffer<Attribute.TypeCompound> onlyTypeAnnotationsBuf = new ListBuffer<>();\n+                        for (JCAnnotation an : at.getAnnotations()) {\n+                            if (chk.isTypeAnnotation(an, false)) {\n+                                onlyTypeAnnotationsBuf.add((Attribute.TypeCompound) an.attribute);\n@@ -5889,1 +5900,10 @@\n-                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));\n+                        }\n+                        List<Attribute.TypeCompound> onlyTypeAnnotations = onlyTypeAnnotationsBuf.toList();\n+                        if (!onlyTypeAnnotations.isEmpty()) {\n+                            Fragment annotationFragment = onlyTypeAnnotations.size() == 1 ?\n+                                    Fragments.TypeAnnotation1(onlyTypeAnnotations.head) :\n+                                    Fragments.TypeAnnotation(onlyTypeAnnotations);\n+                            JCDiagnostic.AnnotatedType annotatedType = new JCDiagnostic.AnnotatedType(\n+                                    type.stripMetadata().annotatedType(onlyTypeAnnotations));\n+                            log.error(at.underlyingType.pos(), Errors.TypeAnnotationInadmissible(annotationFragment,\n+                                    type.tsym.owner, annotatedType));\n@@ -6057,0 +6077,13 @@\n+        @Override\n+        public void visitRecordPattern(JCRecordPattern that) {\n+            initTypeIfNeeded(that);\n+            if (that.record == null) {\n+                that.record = new ClassSymbol(0, TreeInfo.name(that.deconstructor),\n+                                              that.type, syms.noSymbol);\n+            }\n+            if (that.fullComponentTypes == null) {\n+                that.fullComponentTypes = List.nil();\n+            }\n+            super.visitRecordPattern(that);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -604,1 +604,13 @@\n-                outer = new ClassType(outer, sigToTypes('>'), t, List.nil()) {\n+                List<Type> actuals = sigToTypes('>');\n+                List<Type> formals = ((ClassType)t.type.tsym.type).typarams_field;\n+                if (formals != null) {\n+                    if (actuals.isEmpty())\n+                        actuals = formals;\n+                }\n+                \/* actualsCp is final as it will be captured by the inner class below. We could avoid defining\n+                 * this additional local variable and depend on field ClassType::typarams_field which `actuals` is\n+                 * assigned to but then we would have a dependendy on the internal representation of ClassType which\n+                 * could change in the future\n+                 *\/\n+                final List<Type> actualsCp = actuals;\n+                outer = new ClassType(outer, actuals, t, List.nil()) {\n@@ -606,0 +618,1 @@\n+                        boolean typeArgsSet = false;\n@@ -635,1 +648,21 @@\n-                    };\n+\n+                        @Override\n+                        public List<Type> getTypeArguments() {\n+                            if (!typeArgsSet) {\n+                                typeArgsSet = true;\n+                                List<Type> formalsCp = ((ClassType)t.type.tsym.type).typarams_field;\n+                                if (formalsCp != null && !formalsCp.isEmpty()) {\n+                                    if (actualsCp.length() == formalsCp.length()) {\n+                                        List<Type> a = actualsCp;\n+                                        List<Type> f = formalsCp;\n+                                        while (a.nonEmpty()) {\n+                                            a.head = a.head.withTypeVar(f.head);\n+                                            a = a.tail;\n+                                            f = f.tail;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            return super.getTypeArguments();\n+                        }\n+                };\n@@ -1532,1 +1565,1 @@\n-            } else if (proxy.type.tsym.flatName() == syms.restrictedType.tsym.flatName()) {\n+            } else if (proxy.type.tsym.flatName() == syms.restrictedInternalType.tsym.flatName()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -577,1 +577,2 @@\n-    illegal fall-through to a pattern\n+    illegal fall-through to a pattern\\n\\\n+    (the previous case label is missing a break)\n@@ -580,1 +581,2 @@\n-    illegal fall-through from a pattern\n+    illegal fall-through from a pattern\\n\\\n+    (the current case label is missing a break)\n@@ -3268,1 +3270,5 @@\n-# TODO 308: make a better error message\n+# 0: fragment, 1: symbol, 2: annotated-type\n+compiler.err.type.annotation.inadmissible=\\\n+    {0} not expected here\\n\\\n+    (to annotate a qualified type, write {1}.{2})\n+\n@@ -3270,2 +3276,2 @@\n-compiler.err.cant.type.annotate.scoping.1=\\\n-    scoping construct cannot be annotated with type-use annotation: {0}\n+compiler.misc.type.annotation.1=\\\n+    type annotation {0} is\n@@ -3273,3 +3279,2 @@\n-# TODO 308: make a better error message\n-compiler.err.cant.type.annotate.scoping=\\\n-    scoping construct cannot be annotated with type-use annotations: {0}\n+compiler.misc.type.annotation=\\\n+    type annotations {0} are\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -273,2 +273,0 @@\n-    exports jdk.internal.shellsupport.doc to\n-        jdk.jshell;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.classfile.ClassHierarchyResolver;\n@@ -253,0 +254,11 @@\n+\n+        if (options.verify) {\n+            var vErrors = VERIFIER.verify(classModel);\n+            if (!vErrors.isEmpty()) {\n+                println();\n+                for (var ve : vErrors) {\n+                    println(ve.getMessage());\n+                }\n+                errorReported = true;\n+            }\n+        }\n@@ -257,0 +269,9 @@\n+    private static final ClassFile VERIFIER = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(\n+            ClassHierarchyResolver.defaultResolver().orElse(new ClassHierarchyResolver() {\n+                @Override\n+                public ClassHierarchyResolver.ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+                    \/\/ mark all unresolved classes as interfaces to exclude them from assignability verification\n+                    return ClassHierarchyInfo.ofInterface();\n+                }\n+            })));\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-    \/\/\/ peek and poke operations\n-    \/\/\/ (compilers should optimize these to memory ops)\n+    \/\/| peek and poke operations\n+    \/\/| (compilers should optimize these to memory ops)\n@@ -651,1 +651,1 @@\n-    \/\/\/ wrappers for malloc, realloc, free:\n+    \/\/| wrappers for malloc, realloc, free:\n@@ -861,1 +861,1 @@\n-    \/\/\/ random queries\n+    \/\/| random queries\n@@ -1192,1 +1192,1 @@\n-    \/\/\/ random trusted operations from JNI:\n+    \/\/| random trusted operations from JNI:\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+serviceability\/jvmti\/vthread\/CarrierThreadEventNotification\/CarrierThreadEventNotification.java 8333681 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  gtest\/WindowsProcessorGroups.java\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-run-inline\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::run*,*TestPartialPeel*::test*\n+ *                   -XX:CompileCommand=inline,*TestPartialPeelAtUnsignedTestsNegativeLimit::test*\n+ *                   -XX:CompileCommand=dontinline,*TestPartialPeelAtUnsignedTestsNegativeLimit::check\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-compile-test\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8332920\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ *          Only run this test with C2 since it is time-consuming and only tests a C2 issue.\n+ * @run main compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import java.util.Random;\n+\n+import static java.lang.Integer.*;\n+\n+public class TestPartialPeelAtUnsignedTestsNegativeLimit {\n+    static int iFld = 10000;\n+    static int iterations = 0;\n+    static int iFld2;\n+    static boolean flag;\n+    final static Random RANDOM = new Random();\n+\n+    public static void main(String[] args) {\n+        compareUnsigned(3, 3); \/\/ Load Integer class for -Xcomp\n+        for (int i = 0; i < 2; i++) {\n+            if (!originalTest()) {\n+                throw new RuntimeException(\"originalTest() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; i++) {\n+            \/\/ For profiling\n+            iFld = -1;\n+            originalTestVariation1();\n+\n+            \/\/ Actual run\n+            iFld = MAX_VALUE - 100_000;\n+            if (!originalTestVariation1()) {\n+                throw new RuntimeException(\"originalTestVariation1() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; ++i) {\n+            \/\/ For profiling\n+            iFld = MAX_VALUE;\n+            originalTestVariation2();\n+\n+            \/\/ Actual run\n+            iFld = MIN_VALUE + 100000;\n+            if (!originalTestVariation2()) {\n+                throw new RuntimeException(\"originalTestVariation2() failed\");\n+            }\n+        }\n+\n+        runWhileLTIncr();\n+        runWhileLTDecr();\n+    }\n+\n+    \/\/ Originally reported simplified regression test with 2 variations (see below).\n+    public static boolean originalTest() {\n+        for (int i = MAX_VALUE - 50_000; compareUnsigned(i, -1) < 0; i++) {\n+            if (compareUnsigned(MIN_VALUE, i) < 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation1() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1) < 0; ++i) { \/\/ i <u -1\n+\n+            if (i >= Integer.MIN_VALUE + 1 && i <= 100) { \/\/ Transformed to unsigned test.\n+                return true;\n+            }\n+            a *= 23;\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation2() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1000) < 0; i--) { \/\/ i <u -1\n+            if (compareUnsigned(MAX_VALUE - 20, i) > 0) {\n+                return true;\n+            }\n+            a = i;\n+        }\n+        System.out.println(a);\n+        return false;\n+    }\n+\n+\n+    public static void testWhileLTIncr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            \/\/ <Peeled Section>\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (flag) {\n+            }\n+\n+            iFld2++;\n+\n+            \/\/ Loop exit test i >=u limit (i.e. \"while (i <u limit)\") to partial peel with.\n+            \/\/ insert_cmpi_loop_exit() changes this exit condition into a signed and an unsigned test:\n+            \/\/   i >= limit && i >=u limit\n+            \/\/ where the signed condition can be used as proper loop exit condition for a counted loop\n+            \/\/ (we cannot use an unsigned counted loop exit condition).\n+            \/\/\n+            \/\/ After Partial Peeling, we have:\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/ Loop:\n+            \/\/   if (i >=u limit) goto Exit\n+            \/\/   ...\n+            \/\/   i++;\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/   goto Loop\n+            \/\/ Exit:\n+            \/\/   ...\n+            \/\/\n+            \/\/ If init = MAX_VALUE and limit = MIN_VALUE:\n+            \/\/   i >= limit\n+            \/\/   MAX_VALUE >= MIN_VALUE\n+            \/\/ which is true where\n+            \/\/   i >=u limit\n+            \/\/   MAX_VALUE >=u MIN_VALUE\n+            \/\/   MAX_VALUE >=u (uint)(MAX_INT + 1)\n+            \/\/ is false and we wrongly never enter the loop even though we should have.\n+            \/\/ This results in a wrong execution.\n+            if (compareUnsigned(i, limit) >= 0) {\n+                return;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            \/\/ <Unpeeled Section>\n+            iterations++;\n+            i++;\n+        }\n+    }\n+\n+    \/\/ Same as testWhileLTIncr() but with decrement instead.\n+    public static void testWhileLTDecr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            if (flag) {\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (compareUnsigned(i, limit) >= 0) { \/\/ While (i <u limit)\n+                return;\n+            }\n+\n+            iterations++;\n+            i--;\n+        }\n+    }\n+\n+    public static void runWhileLTIncr() {\n+        \/\/ Currently works:\n+        testWhileLTIncr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTIncr(-1, 1);\n+        check(0);\n+        testWhileLTIncr(0, 0);\n+        check(0);\n+        checkIncrWithRandom(0, 0); \/\/ Sanity check this method.\n+        flag = !flag; \/\/ Change profiling\n+        testWhileLTIncr(MAX_VALUE - 2000, MAX_VALUE);\n+        check(2000);\n+        testWhileLTIncr(MAX_VALUE - 1990, MAX_VALUE);\n+        check(1990);\n+        testWhileLTIncr(MAX_VALUE - 1, MAX_VALUE);\n+        check(1);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 2000);\n+        check(2000);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1990);\n+        check(1990);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1);\n+        check(1);\n+\n+        flag = !flag;\n+        \/\/ Overflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE);\n+        check(1);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE + 2000);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE + 2000);\n+        check(4001);\n+\n+        \/\/ Random values\n+        int init = RANDOM.nextInt(0, MAX_VALUE);\n+        int limit = RANDOM.nextInt(MIN_VALUE, 0);\n+        testWhileLTIncr(init, limit);\n+        checkIncrWithRandom(init, limit);\n+    }\n+\n+    public static void runWhileLTDecr() {\n+        \/\/ Currently works:\n+        testWhileLTDecr(1, -1);\n+        check(2);\n+        testWhileLTDecr(-1, 1);\n+        check(0);\n+        testWhileLTDecr(0, 0);\n+        check(0);\n+        checkDecrWithRandom(0, 0); \/\/ Sanity check this method.\n+        flag = !flag;\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MIN_VALUE, 0);\n+        check(0);\n+        testWhileLTDecr(MIN_VALUE, 1);\n+        check(0);\n+        flag = !flag;\n+\n+        \/\/ Underflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTDecr(MIN_VALUE, -1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, -2000);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, MIN_VALUE + 1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -1);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -2000);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, MIN_VALUE + 2001);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+\n+        \/\/ Random values\n+        int r1 = RANDOM.nextInt(MIN_VALUE, 0);\n+        int r2 = RANDOM.nextInt(MIN_VALUE, 0);\n+        int init = Math.min(r1, r2);\n+        int limit = Math.max(r1, r2);\n+        testWhileLTDecr(init, limit);\n+        checkDecrWithRandom(init, limit);\n+    }\n+\n+    static void check(int expectedIterations) {\n+        if (expectedIterations != iterations) {\n+            throw new RuntimeException(\"Expected \" + expectedIterations + \" iterations but only got \" + iterations);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+\n+    static void checkIncrWithRandom(long init, long limit) {\n+        long expectedIterations = ((long)(MAX_VALUE) - init) + (limit - (long)MIN_VALUE) + 1;\n+        if ((int)expectedIterations != iterations) {\n+            String error = \"Expected %d iterations but only got %d, init: %d, limit: %d\"\n+                            .formatted(expectedIterations, iterations, init, limit);\n+            throw new RuntimeException(error);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+\n+    static void checkDecrWithRandom(long init, long limit) {\n+        long expectedIterations = init + MIN_VALUE + MAX_VALUE + 2;\n+        if (init == limit) {\n+            expectedIterations = 0;\n+        }\n+        if ((int)expectedIterations != iterations) {\n+            String error = \"Expected %d iterations but only got %d, init: %d, limit: %d\"\n+                    .formatted(expectedIterations, iterations, init, limit);\n+            throw new RuntimeException(error);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelAtUnsignedTestsNegativeLimit.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -627,1 +627,1 @@\n-sun\/security\/pkcs11\/sslecc\/ClientJSSEServerJSSE.java            8316183 linux-ppc64le\n+sun\/security\/pkcs11\/sslecc\/ClientJSSEServerJSSE.java            8316183,8333317 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,5 +60,0 @@\n-tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotatePackages.java      8057679    generic-all    clarify error messages trying to annotate scoping\n-tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateScoping.java       8057679    generic-all    clarify error messages trying to annotate scoping\n-tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateStaticClass2.java  8057679,8057683    generic-all    clarify error messages and improve ordering of errors with type annotations\n-tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateStaticClass3.java  8057679,8057683    generic-all    clarify error messages and improve ordering of errors with type annotations\n-tools\/javac\/annotations\/typeAnnotations\/newlocations\/RepeatingTypeAnnotations.java 8057683 generic-all    improve ordering of errors with type annotations\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -223,0 +223,4 @@\n+\n+# Pending removal\n+compiler.note.implicit.annotation.processing\n+compiler.warn.proc.use.proc.or.implicit\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}