{"files":[{"patch":"@@ -16079,1 +16079,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16083,1 +16083,1 @@\n-  effect(TEMP tmp, TEMP tmp2);\n+  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n@@ -16086,1 +16086,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $tmp,$tmp2\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp,$tmp2,$tmp3\" %}\n@@ -16089,1 +16089,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+    __ fast_lock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16095,1 +16095,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16099,1 +16099,1 @@\n-  effect(TEMP tmp, TEMP tmp2);\n+  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n@@ -16102,1 +16102,1 @@\n-  format %{ \"fastunlock $object,$box\\t! kills $tmp, $tmp2\" %}\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp, $tmp2, $tmp3\" %}\n@@ -16105,1 +16105,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1916,0 +1916,2 @@\n+  void vpmadd52luq(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmadd52luq(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -1918,0 +1920,2 @@\n+  void vpmadd52huq(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len);\n+  void vpmadd52huq(XMMRegister dst, XMMRegister src1, Address src2, int vector_len);\n@@ -2012,0 +2016,2 @@\n+  void vpunpcklqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n@@ -2021,0 +2027,1 @@\n+  void vpunpckhqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -10163,0 +10163,11 @@\n+void MacroAssembler::vpor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::vpor(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vpor(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1866,0 +1866,3 @@\n+  using Assembler::vpor;\n+  void vpor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -456,0 +456,21 @@\n+  \/\/Poly305 AVX2 implementation\n+  void poly1305_process_blocks_avx2(const Register input, const Register length,\n+    const Register a0, const Register a1, const Register a2,\n+    const Register r0, const Register r1, const Register c1);\n+  void poly1305_msg_mul_reduce_vec4_avx2(const XMMRegister A0, const XMMRegister A1, const XMMRegister A2,\n+                                   const Address R0, const Address R1, const Address R2,\n+                                   const Address R1P, const Address R2P,\n+                                   const XMMRegister P0L, const XMMRegister P0H,\n+                                   const XMMRegister P1L, const XMMRegister P1H,\n+                                   const XMMRegister P2L, const XMMRegister P2H,\n+                                   const XMMRegister YTMP1, const XMMRegister YTMP2,\n+                                   const XMMRegister YTMP3, const XMMRegister YTMP4,\n+                                   const XMMRegister YTMP5, const XMMRegister YTMP6,\n+                                   const Register input, const Register length, const Register rscratch);\n+  void poly1305_mul_reduce_vec4_avx2(const XMMRegister A0, const XMMRegister A1, const XMMRegister A2,\n+                               const XMMRegister R0, const XMMRegister R1, const XMMRegister R2,\n+                               const XMMRegister R1P, const XMMRegister R2P,\n+                               const XMMRegister P0L, const XMMRegister P0H,\n+                               const XMMRegister P1L, const XMMRegister P1H,\n+                               const XMMRegister P2L, const XMMRegister P2H,\n+                               const XMMRegister YTMP1, const Register rscratch);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-\n+    \/\/ ECX = 0\n@@ -306,0 +306,7 @@\n+    \/\/ ECX = 1\n+    __ movl(rax, 7);\n+    __ movl(rcx, 1);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_ecx1_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+\n@@ -961,1 +968,1 @@\n-  if (UseAVX < 2)\n+  if (UseAVX < 2) {\n@@ -963,0 +970,2 @@\n+    _features &= ~CPU_AVX_IFMA;\n+  }\n@@ -992,0 +1001,1 @@\n+      _features &= ~CPU_AVX_IFMA;\n@@ -1348,1 +1358,1 @@\n-  if (supports_avx512ifma() && supports_avx512vlbw() && MaxVectorSize >= 64) {\n+  if ((supports_avx512ifma() && supports_avx512vlbw()) || supports_avxifma())  {\n@@ -2939,1 +2949,1 @@\n-    if (sef_cpuid7_ebx.bits.avx2 != 0)\n+    if (sef_cpuid7_ebx.bits.avx2 != 0) {\n@@ -2941,0 +2951,3 @@\n+      if (sef_cpuid7_ecx1_eax.bits.avx_ifma != 0)\n+        result |= CPU_AVX_IFMA;\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3911,0 +3911,3 @@\n+    if ((UseAVX == 0) && ($dst$$XMMRegister != $src$$XMMRegister)) {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -3916,11 +3919,0 @@\n-instruct roundD_mem(legRegD dst, memory src, immU8 rmode) %{\n-  match(Set dst (RoundDoubleMode (LoadD src) rmode));\n-  format %{ \"roundsd $dst,$src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    assert(UseSSE >= 4, \"required\");\n-    __ roundsd($dst$$XMMRegister, $src$$Address, $rmode$$constant);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,1 @@\n+#ifdef ASSERT\n@@ -213,0 +214,1 @@\n+#endif\n@@ -1532,0 +1534,1 @@\n+#ifdef ASSERT\n@@ -1533,0 +1536,1 @@\n+#endif\n@@ -1538,9 +1542,1 @@\n-\n-Instruction* LIRGenerator::instruction_for_opr(LIR_Opr opr) {\n-  if (opr->is_virtual()) {\n-    return instruction_for_vreg(opr->vreg_number());\n-  }\n-  return nullptr;\n-}\n-\n-\n+#ifdef ASSERT\n@@ -1553,1 +1549,1 @@\n-\n+#endif\n@@ -3075,0 +3071,1 @@\n+#ifdef ASSERT\n@@ -3076,0 +3073,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,0 +169,1 @@\n+#ifdef ASSERT\n@@ -170,0 +171,1 @@\n+#endif\n@@ -229,0 +231,1 @@\n+#ifdef ASSERT\n@@ -232,0 +235,1 @@\n+#endif\n@@ -532,0 +536,1 @@\n+#ifdef ASSERT\n@@ -533,1 +538,1 @@\n-  Instruction* instruction_for_opr(LIR_Opr opr);\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+GrowableArrayCHeap<int, mtClassShared>* ArchiveHeapWriter::_source_objs_order;\n@@ -75,0 +76,1 @@\n+static int _num_native_ptrs = 0;\n@@ -87,0 +89,1 @@\n+    _source_objs_order = new GrowableArrayCHeap<int, mtClassShared>(10000);\n@@ -94,0 +97,1 @@\n+  _source_objs_order->append(_source_objs->length());\n@@ -229,0 +233,43 @@\n+static int oop_sorting_rank(oop o) {\n+  bool has_o_ptr = HeapShared::has_oop_pointers(o);\n+  bool has_n_ptr = HeapShared::has_native_pointers(o);\n+\n+  if (!has_o_ptr) {\n+    if (!has_n_ptr) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  } else {\n+    if (has_n_ptr) {\n+      return 2;\n+    } else {\n+      return 3;\n+    }\n+  }\n+}\n+\n+\/\/ The goal is to sort the objects in increasing order of:\n+\/\/ - objects that have no pointers\n+\/\/ - objects that have only native pointers\n+\/\/ - objects that have both native and oop pointers\n+\/\/ - objects that have only oop pointers\n+int ArchiveHeapWriter::compare_objs_by_oop_fields(int* a, int* b) {\n+  oop oa = _source_objs->at(*a);\n+  oop ob = _source_objs->at(*b);\n+\n+  int rank_a = oop_sorting_rank(oa);\n+  int rank_b = oop_sorting_rank(ob);\n+\n+  if (rank_a != rank_b) {\n+    return rank_a - rank_b;\n+  } else {\n+    \/\/ If they are the same rank, sort them by their position in the _source_objs array\n+    return *a - *b;\n+  }\n+}\n+\n+void ArchiveHeapWriter::sort_source_objs() {\n+  _source_objs_order->sort(compare_objs_by_oop_fields);\n+}\n+\n@@ -230,2 +277,4 @@\n-  for (int i = 0; i < _source_objs->length(); i++) {\n-    oop src_obj = _source_objs->at(i);\n+  sort_source_objs();\n+  for (int i = 0; i < _source_objs_order->length(); i++) {\n+    int src_obj_index = _source_objs_order->at(i);\n+    oop src_obj = _source_objs->at(src_obj_index);\n@@ -242,2 +291,2 @@\n-  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots\",\n-                _buffer_used, _source_objs->length() + 1, roots->length());\n+  log_info(cds)(\"Size of heap region = \" SIZE_FORMAT \" bytes, %d objects, %d roots, %d native ptrs\",\n+                _buffer_used, _source_objs->length() + 1, roots->length(), _num_native_ptrs);\n@@ -515,0 +564,11 @@\n+static void log_bitmap_usage(const char* which, BitMap* bitmap, size_t total_bits) {\n+  \/\/ The whole heap is covered by total_bits, but there are only non-zero bits within [start ... end).\n+  size_t start = bitmap->find_first_set_bit(0);\n+  size_t end = bitmap->size();\n+  log_info(cds)(\"%s = \" SIZE_FORMAT_W(7) \" ... \" SIZE_FORMAT_W(7) \" (%3zu%% ... %3zu%% = %3zu%%)\", which,\n+                start, end,\n+                start * 100 \/ total_bits,\n+                end * 100 \/ total_bits,\n+                (end - start) * 100 \/ total_bits);\n+}\n+\n@@ -522,2 +582,6 @@\n-  auto iterator = [&] (oop src_obj, HeapShared::CachedOopInfo& info) {\n-    oop requested_obj = requested_obj_from_buffer_offset(info.buffer_offset());\n+  for (int i = 0; i < _source_objs_order->length(); i++) {\n+    int src_obj_index = _source_objs_order->at(i);\n+    oop src_obj = _source_objs->at(src_obj_index);\n+    HeapShared::CachedOopInfo* info = HeapShared::archived_object_cache()->get(src_obj);\n+    assert(info != nullptr, \"must be\");\n+    oop requested_obj = requested_obj_from_buffer_offset(info->buffer_offset());\n@@ -525,1 +589,1 @@\n-    address buffered_obj = offset_to_buffered_address<address>(info.buffer_offset());\n+    address buffered_obj = offset_to_buffered_address<address>(info->buffer_offset());\n@@ -529,1 +593,0 @@\n-  HeapShared::archived_object_cache()->iterate_all(iterator);\n@@ -545,0 +608,4 @@\n+\n+  size_t total_bytes = (size_t)_buffer->length();\n+  log_bitmap_usage(\"oopmap\", heap_info->oopmap(), total_bytes \/ (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop)));\n+  log_bitmap_usage(\"ptrmap\", heap_info->ptrmap(), total_bytes \/ sizeof(address));\n@@ -554,0 +621,2 @@\n+    HeapShared::set_has_native_pointers(src_obj);\n+    _num_native_ptrs ++;\n@@ -568,0 +637,7 @@\n+  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n+  size_t start_pos = FileMapInfo::current_info()->heap_ptrmap_start_pos();\n+  if (idx < start_pos) {\n+    return false;\n+  } else {\n+    idx -= start_pos;\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":85,"deletions":9,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/classListWriter.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -40,6 +42,3 @@\n-\n-\/\/ The ability to dump the FMG depends on many factors checked by\n-\/\/ is_dumping_full_module_graph(), but can be unconditionally disabled by\n-\/\/ _dumping_full_module_graph_disabled. (Ditto for loading the FMG).\n-bool CDSConfig::_dumping_full_module_graph_disabled = false;\n-bool CDSConfig::_loading_full_module_graph_disabled = false;\n+bool CDSConfig::_is_using_optimized_module_handling = true;\n+bool CDSConfig::_is_dumping_full_module_graph = true;\n+bool CDSConfig::_is_using_full_module_graph = true;\n@@ -59,0 +58,9 @@\n+int CDSConfig::get_status() {\n+  assert(Universe::is_fully_initialized(), \"status is finalized only after Universe is initialized\");\n+  return (is_dumping_archive()              ? IS_DUMPING_ARCHIVE : 0) |\n+         (is_dumping_static_archive()       ? IS_DUMPING_STATIC_ARCHIVE : 0) |\n+         (is_logging_lambda_form_invokers() ? IS_LOGGING_LAMBDA_FORM_INVOKERS : 0) |\n+         (is_using_archive()                ? IS_USING_ARCHIVE : 0);\n+}\n+\n+\n@@ -74,0 +82,4 @@\n+\n+  if (!is_dumping_heap()) {\n+    _is_dumping_full_module_graph = false;\n+  }\n@@ -241,1 +253,1 @@\n-    MetaspaceShared::disable_optimized_module_handling();\n+    stop_using_optimized_module_handling();\n@@ -247,2 +259,2 @@\n-    disable_loading_full_module_graph();\n-    disable_dumping_full_module_graph();\n+    stop_dumping_full_module_graph();\n+    stop_using_full_module_graph();\n@@ -385,0 +397,14 @@\n+bool CDSConfig::is_using_archive() {\n+  return UseSharedSpaces; \/\/ TODO: UseSharedSpaces will be eventually replaced by CDSConfig::is_using_archive()\n+}\n+\n+bool CDSConfig::is_logging_lambda_form_invokers() {\n+  return ClassListWriter::is_enabled() || is_dumping_dynamic_archive();\n+}\n+\n+void CDSConfig::stop_using_optimized_module_handling() {\n+  _is_using_optimized_module_handling = false;\n+  _is_dumping_full_module_graph = false; \/\/ This requires is_using_optimized_module_handling()\n+  _is_using_full_module_graph = false; \/\/ This requires is_using_optimized_module_handling()\n+}\n+\n@@ -395,4 +421,2 @@\n-bool CDSConfig::is_dumping_full_module_graph() {\n-  if (!_dumping_full_module_graph_disabled &&\n-      is_dumping_heap() &&\n-      MetaspaceShared::use_optimized_module_handling()) {\n+bool CDSConfig::is_using_full_module_graph() {\n+  if (ClassLoaderDataShared::is_full_module_graph_loaded()) {\n@@ -400,6 +424,2 @@\n-  } else {\n-    return false;\n-}\n-bool CDSConfig::is_loading_full_module_graph() {\n-  if (ClassLoaderDataShared::is_full_module_graph_loaded()) {\n-    return true;\n+  if (!_is_using_full_module_graph) {\n+    return false;\n@@ -410,4 +430,1 @@\n-  if (!_loading_full_module_graph_disabled &&\n-      UseSharedSpaces &&\n-      ArchiveHeapLoader::can_use() &&\n-      MetaspaceShared::use_optimized_module_handling()) {\n+  if (UseSharedSpaces && ArchiveHeapLoader::can_use()) {\n@@ -419,0 +436,1 @@\n+    _is_using_full_module_graph = false;\n@@ -423,3 +441,3 @@\n-void CDSConfig::disable_dumping_full_module_graph(const char* reason) {\n-  if (!_dumping_full_module_graph_disabled) {\n-    _dumping_full_module_graph_disabled = true;\n+void CDSConfig::stop_dumping_full_module_graph(const char* reason) {\n+  if (_is_dumping_full_module_graph) {\n+    _is_dumping_full_module_graph = false;\n@@ -432,1 +450,1 @@\n-void CDSConfig::disable_loading_full_module_graph(const char* reason) {\n+void CDSConfig::stop_using_full_module_graph(const char* reason) {\n@@ -434,2 +452,2 @@\n-  if (!_loading_full_module_graph_disabled) {\n-    _loading_full_module_graph_disabled = true;\n+  if (_is_using_full_module_graph) {\n+    _is_using_full_module_graph = false;\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":47,"deletions":29,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -36,2 +36,3 @@\n-  static bool _dumping_full_module_graph_disabled;\n-  static bool _loading_full_module_graph_disabled;\n+  static bool _is_using_optimized_module_handling;\n+  static bool _is_dumping_full_module_graph;\n+  static bool _is_using_full_module_graph;\n@@ -42,3 +43,3 @@\n-  static char*  _default_archive_path;\n-  static char*  _static_archive_path;\n-  static char*  _dynamic_archive_path;\n+  static char* _default_archive_path;\n+  static char* _static_archive_path;\n+  static char* _dynamic_archive_path;\n@@ -54,0 +55,7 @@\n+  \/\/ Used by jdk.internal.misc.CDS.getCDSConfigStatus();\n+  static const int IS_DUMPING_ARCHIVE              = 1 << 0;\n+  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 1;\n+  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 2;\n+  static const int IS_USING_ARCHIVE                = 1 << 3;\n+  static int get_status() NOT_CDS_RETURN_(0);\n+\n@@ -65,6 +73,14 @@\n-  \/\/ Basic CDS features\n-  static bool      is_dumping_archive()                      { return is_dumping_static_archive() || is_dumping_dynamic_archive(); }\n-  static bool      is_dumping_static_archive()               { return CDS_ONLY(_is_dumping_static_archive) NOT_CDS(false); }\n-  static void  enable_dumping_static_archive()               { CDS_ONLY(_is_dumping_static_archive = true); }\n-  static bool      is_dumping_dynamic_archive()              { return CDS_ONLY(_is_dumping_dynamic_archive) NOT_CDS(false); }\n-  static void  enable_dumping_dynamic_archive()              { CDS_ONLY(_is_dumping_dynamic_archive = true); }\n+  \/\/ --- Basic CDS features\n+\n+  \/\/ archive(s) in general\n+  static bool is_dumping_archive()                           { return is_dumping_static_archive() || is_dumping_dynamic_archive(); }\n+  static bool is_using_archive()                             NOT_CDS_RETURN_(false);\n+  static int num_archives(const char* archive_path)          NOT_CDS_RETURN_(0);\n+\n+  \/\/ static_archive\n+  static bool is_dumping_static_archive()                    { return CDS_ONLY(_is_dumping_static_archive) NOT_CDS(false); }\n+  static void enable_dumping_static_archive()                { CDS_ONLY(_is_dumping_static_archive = true); }\n+\n+  \/\/ dynamic_archive\n+  static bool is_dumping_dynamic_archive()                   { return CDS_ONLY(_is_dumping_dynamic_archive) NOT_CDS(false); }\n+  static void enable_dumping_dynamic_archive()               { CDS_ONLY(_is_dumping_dynamic_archive = true); }\n@@ -73,1 +89,8 @@\n-  \/\/ Archive paths\n+  \/\/ optimized_module_handling -- can we skip some expensive operations related to modules?\n+  static bool is_using_optimized_module_handling()           { return CDS_ONLY(_is_using_optimized_module_handling) NOT_CDS(false); }\n+  static void stop_using_optimized_module_handling()         NOT_CDS_RETURN;\n+\n+  static bool is_logging_lambda_form_invokers()              NOT_CDS_RETURN_(false);\n+\n+  \/\/ archive_path\n+\n@@ -75,1 +98,1 @@\n-  static char* default_archive_path()                         NOT_CDS_RETURN_(nullptr);\n+  static char* default_archive_path()                        NOT_CDS_RETURN_(nullptr);\n@@ -81,1 +104,3 @@\n-  static int num_archives(const char* archive_path)          NOT_CDS_RETURN_(0);\n+  \/\/ --- Archived java objects\n+\n+  static bool   is_dumping_heap()                            NOT_CDS_JAVA_HEAP_RETURN_(false);\n@@ -83,0 +108,5 @@\n+  \/\/ full_module_graph (requires optimized_module_handling)\n+  static bool is_dumping_full_module_graph()                 { return CDS_ONLY(_is_dumping_full_module_graph) NOT_CDS(false); }\n+  static bool is_using_full_module_graph()                   NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void stop_dumping_full_module_graph(const char* reason = nullptr) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void stop_using_full_module_graph(const char* reason = nullptr) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -84,6 +114,1 @@\n-  \/\/ CDS archived heap\n-  static bool      is_dumping_heap()                         NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  static void disable_dumping_full_module_graph(const char* reason = nullptr) NOT_CDS_JAVA_HEAP_RETURN;\n-  static bool      is_dumping_full_module_graph()            NOT_CDS_JAVA_HEAP_RETURN_(false);\n-  static void disable_loading_full_module_graph(const char* reason = nullptr) NOT_CDS_JAVA_HEAP_RETURN;\n-  static bool      is_loading_full_module_graph()            NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_valhalla_preview();\n@@ -91,1 +116,0 @@\n-  static bool      is_valhalla_preview();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":45,"deletions":21,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  _use_optimized_module_handling = MetaspaceShared::use_optimized_module_handling();\n+  _use_optimized_module_handling = CDSConfig::is_using_optimized_module_handling();\n@@ -358,0 +358,2 @@\n+  st->print_cr(\"- _heap_oopmap_start_pos:         \" SIZE_FORMAT, _heap_oopmap_start_pos);\n+  st->print_cr(\"- _heap_ptrmap_start_pos:         \" SIZE_FORMAT, _heap_ptrmap_start_pos);\n@@ -1640,0 +1642,19 @@\n+\/\/ The start of the archived heap has many primitive arrays (String\n+\/\/ bodies) that are not marked by the oop\/ptr maps. So we must have\n+\/\/ lots of leading zeros.\n+size_t FileMapInfo::remove_bitmap_leading_zeros(CHeapBitMap* map) {\n+  size_t old_zeros = map->find_first_set_bit(0);\n+  size_t old_size = map->size_in_bytes();\n+\n+  \/\/ Slice and resize bitmap\n+  map->truncate(old_zeros, map->size());\n+\n+  DEBUG_ONLY(\n+    size_t new_zeros = map->find_first_set_bit(0);\n+    assert(new_zeros == 0, \"Should have removed leading zeros\");\n+  )\n+\n+  assert(map->size_in_bytes() < old_size, \"Map size should have decreased\");\n+  return old_zeros;\n+}\n+\n@@ -1645,0 +1666,7 @@\n+    \/\/ Remove leading zeros\n+    size_t removed_oop_zeros = remove_bitmap_leading_zeros(heap_info->oopmap());\n+    size_t removed_ptr_zeros = remove_bitmap_leading_zeros(heap_info->ptrmap());\n+\n+    header()->set_heap_oopmap_start_pos(removed_oop_zeros);\n+    header()->set_heap_ptrmap_start_pos(removed_ptr_zeros);\n+\n@@ -2052,1 +2080,1 @@\n-    CDSConfig::disable_loading_full_module_graph();\n+    CDSConfig::stop_using_full_module_graph();\n@@ -2486,1 +2514,1 @@\n-    MetaspaceShared::disable_optimized_module_handling();\n+    CDSConfig::stop_using_optimized_module_handling();\n@@ -2492,1 +2520,1 @@\n-    CDSConfig::disable_loading_full_module_graph(\"archive was created without full module graph\");\n+    CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -262,0 +262,2 @@\n+  size_t _heap_oopmap_start_pos;        \/\/ The first bit in the oopmap corresponds to this position in the heap.\n+  size_t _heap_ptrmap_start_pos;        \/\/ The first bit in the ptrmap corresponds to this position in the heap.\n@@ -303,0 +305,2 @@\n+  size_t heap_oopmap_start_pos()           const { return _heap_oopmap_start_pos;}\n+  size_t heap_ptrmap_start_pos()           const { return _heap_ptrmap_start_pos;}\n@@ -315,0 +319,2 @@\n+  void set_heap_oopmap_start_pos(size_t n)       { _heap_oopmap_start_pos = n; }\n+  void set_heap_ptrmap_start_pos(size_t n)       { _heap_ptrmap_start_pos = n; }\n@@ -416,0 +422,2 @@\n+  size_t  heap_oopmap_start_pos() const { return header()->heap_oopmap_start_pos(); }\n+  size_t  heap_ptrmap_start_pos() const { return header()->heap_ptrmap_start_pos(); }\n@@ -472,0 +480,1 @@\n+  size_t remove_bitmap_leading_zeros(CHeapBitMap* map);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-    CachedOopInfo info = make_cached_oop_info();\n+    CachedOopInfo info = make_cached_oop_info(obj);\n@@ -442,0 +442,18 @@\n+bool HeapShared::has_oop_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  return info->has_oop_pointers();\n+}\n+\n+bool HeapShared::has_native_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  return info->has_native_pointers();\n+}\n+\n+void HeapShared::set_has_native_pointers(oop src_obj) {\n+  CachedOopInfo* info = archived_object_cache()->get(src_obj);\n+  assert(info != nullptr, \"must be\");\n+  info->set_has_native_pointers();\n+}\n+\n@@ -977,1 +995,1 @@\n-    if (record->is_full_module_graph() && !CDSConfig::is_loading_full_module_graph()) {\n+    if (record->is_full_module_graph() && !CDSConfig::is_using_full_module_graph()) {\n@@ -1143,1 +1161,16 @@\n-HeapShared::CachedOopInfo HeapShared::make_cached_oop_info() {\n+\/\/ Checks if an oop has any non-null oop fields\n+class PointsToOopsChecker : public BasicOopIterateClosure {\n+  bool _result;\n+\n+  template <class T> void check(T *p) {\n+    _result |= (HeapAccess<>::oop_load(p) != nullptr);\n+  }\n+\n+public:\n+  PointsToOopsChecker() : _result(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool result() { return _result; }\n+};\n+\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop obj) {\n@@ -1146,1 +1179,3 @@\n-  return CachedOopInfo(referrer);\n+  PointsToOopsChecker points_to_oops_checker;\n+  obj->oop_iterate(&points_to_oops_checker);\n+  return CachedOopInfo(referrer, points_to_oops_checker.result());\n@@ -1444,0 +1479,1 @@\n+    const char* test_class_name = ArchiveHeapTestClass;\n@@ -1446,0 +1482,1 @@\n+    const char* test_class_name = \"\"; \/\/ avoid C++ printf checks warnings.\n@@ -1449,1 +1486,1 @@\n-      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", test_class_name);\n@@ -1475,1 +1512,1 @@\n-        st.print(\"ArchiveHeapTestClass %s is not in unnamed module\", ArchiveHeapTestClass);\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed module\", test_class_name);\n@@ -1482,1 +1519,1 @@\n-        st.print(\"ArchiveHeapTestClass %s is not in unnamed package\", ArchiveHeapTestClass);\n+        st.print(\"ArchiveHeapTestClass %s is not in unnamed package\", test_class_name);\n@@ -1497,1 +1534,1 @@\n-      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", ArchiveHeapTestClass);\n+      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", test_class_name);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -789,1 +789,1 @@\n-      CDSConfig::disable_dumping_full_module_graph();\n+      CDSConfig::stop_dumping_full_module_graph();\n@@ -1185,2 +1185,2 @@\n-    log_info(cds)(\"initial optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"initial full module graph: %s\", CDSConfig::is_loading_full_module_graph() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"initial full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -411,3 +411,0 @@\n-  \/\/ To call this, one must have the MultiArray_lock held, but the _klasses list still has lock free reads.\n-  assert_locked_or_safepoint(MultiArray_lock);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-    assert(CDSConfig::is_loading_full_module_graph(), \"must be\");\n+    assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n@@ -159,1 +159,1 @@\n-    assert(CDSConfig::is_loading_full_module_graph(), \"must be\");\n+    assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n@@ -970,1 +970,1 @@\n-  if (MetaspaceShared::use_optimized_module_handling()) {\n+  if (CDSConfig::is_using_optimized_module_handling()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-      REGION_IDX_FORMAT \" \" PTR_FORMAT \" \"\n+      REGION_IDX_FORMAT \" \"\n@@ -263,1 +263,1 @@\n-      i, p2i(c->data_location()), dci, p2i(c->destination()),\n+      i, dci, p2i(c->destination()),\n@@ -498,6 +498,0 @@\n-void ParallelCompactData::clear()\n-{\n-  memset(_region_data, 0, _region_vspace->committed_size());\n-  memset(_block_data, 0, _block_vspace->committed_size());\n-}\n-\n@@ -544,1 +538,0 @@\n-    _region_data[cur_region].set_data_location(addr);\n@@ -738,1 +731,0 @@\n-      _region_data[cur_region].set_data_location(region_to_addr(cur_region));\n@@ -902,1 +894,1 @@\n-  const idx_t end_bit = _mark_bitmap.align_range_end(_mark_bitmap.addr_to_bit(top));\n+  const idx_t end_bit = _mark_bitmap.addr_to_bit(top);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -203,8 +203,2 @@\n-JNIEXPORT jboolean JNICALL\n-JVM_IsCDSDumpingEnabled(JNIEnv* env);\n-\n-JNIEXPORT jboolean JNICALL\n-JVM_IsSharingEnabled(JNIEnv* env);\n-\n-JNIEXPORT jboolean JNICALL\n-JVM_IsDumpingClassList(JNIEnv* env);\n+JNIEXPORT jint JNICALL\n+JVM_GetCDSConfigStatus();\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,17 +154,10 @@\n-    ResourceMark rm(THREAD);\n-    {\n-      \/\/ Ensure atomic creation of higher dimensions\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if another thread beat us\n-      if (higher_dimension() == nullptr) {\n-\n-        \/\/ Create multi-dim klass object and link them together\n-        ObjArrayKlass* ak =\n-          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n-                                                 false, CHECK_NULL);\n-        ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(ak);\n-        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n+    \/\/ Ensure atomic creation of higher dimensions\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n+\n+    if (higher_dimension() == nullptr) {\n+      \/\/ Create multi-dim klass object and link them together\n+      ObjArrayKlass* ak =\n+      ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, CHECK_NULL);\n+      \/\/ use 'release' to pair with lock-free load\n+      release_set_higher_dimension(ak);\n+      assert(ak->lower_dimension() == this, \"lower dimension mismatch\");\n@@ -174,1 +167,2 @@\n-  ObjArrayKlass *ak = higher_dimension();\n+  ObjArrayKlass* ak = higher_dimension();\n+  assert(ak != nullptr, \"should be set\");\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-    \/\/   JVM_CONSTANT_String (normal and pseudo)\n+    \/\/   JVM_CONSTANT_String\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  assert(MultiArray_lock->holds_lock(THREAD), \"must hold lock after bootstrapping\");\n@@ -109,2 +110,1 @@\n-    super_klass = element_klass->array_klass_or_null();\n-    bool supers_exist = super_klass != nullptr;\n+    super_klass = element_klass->array_klass(CHECK_NULL);\n@@ -116,19 +116,1 @@\n-      if (elem_super->array_klass_or_null() == nullptr) {\n-        supers_exist = false;\n-        break;\n-      }\n-    }\n-    if (!supers_exist) {\n-      \/\/ Oops.  Not allocated yet.  Back out, allocate it, and retry.\n-      Klass* ek = nullptr;\n-      {\n-        MutexUnlocker mu(MultiArray_lock);\n-        super_klass = element_klass->array_klass(CHECK_NULL);\n-        for( int i = element_supers->length()-1; i >= 0; i-- ) {\n-          Klass* elem_super = element_supers->at(i);\n-          elem_super->array_klass(CHECK_NULL);\n-        }\n-        \/\/ Now retry from the beginning\n-        ek = element_klass->value_array_klass(CHECK_NULL);\n-      }  \/\/ re-lock\n-      return FlatArrayKlass::cast(ek);\n+      elem_super->array_klass(CHECK_NULL);\n@@ -136,0 +118,1 @@\n+   \/\/ Fall through because inheritance is acyclic and we hold the global recursive lock to allocate all the arrays.\n@@ -344,56 +327,0 @@\n-\n-ArrayKlass* FlatArrayKlass::array_klass(int n, TRAPS) {\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-\n-    ResourceMark rm(THREAD);\n-    {\n-      \/\/ Ensure atomic creation of higher dimensions\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if another thread beat us\n-      if (higher_dimension() == nullptr) {\n-\n-        \/\/ Create multi-dim klass object and link them together\n-        ObjArrayKlass* ak = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, CHECK_NULL);\n-        ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(ak);\n-        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n-    }\n-  }\n-\n-  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());\n-  JavaThread::cast(THREAD)->check_possible_safepoint();\n-  return ak->array_klass(n, THREAD);\n-}\n-\n-ArrayKlass* FlatArrayKlass::array_klass_or_null(int n) {\n-\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());\n-  return ak->array_klass_or_null(n);\n-}\n-\n-ArrayKlass* FlatArrayKlass::array_klass(TRAPS) {\n-  return array_klass(dimension() +  1, THREAD);\n-}\n-\n-ArrayKlass* FlatArrayKlass::array_klass_or_null() {\n-  return array_klass_or_null(dimension() +  1);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":4,"deletions":77,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-  \/\/ Returns the ObjArrayKlass for n'th dimension.\n-  virtual ArrayKlass* array_klass(int n, TRAPS);\n-  virtual ArrayKlass* array_klass_or_null(int n);\n-\n-  \/\/ Returns the array class with this class as element type.\n-  virtual ArrayKlass* array_klass(TRAPS);\n-  virtual ArrayKlass* array_klass_or_null();\n-\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -188,17 +188,11 @@\n-    ResourceMark rm(THREAD);\n-    JavaThread *jt = JavaThread::cast(THREAD);\n-    {\n-      \/\/ Atomic creation of array_klasses\n-      MutexLocker ma(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if update has already taken place\n-      if (value_array_klasses() == nullptr) {\n-        ArrayKlass* k;\n-        if (flat_array()) {\n-          k = FlatArrayKlass::allocate_klass(this, CHECK_NULL);\n-        } else {\n-          k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, CHECK_NULL);\n-\n-        }\n-        \/\/ use 'release' to pair with lock-free load\n-        Atomic::release_store(adr_value_array_klasses(), k);\n+    \/\/ Atomic creation of array_klasses\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n+\n+    \/\/ Check if update has already taken place\n+    if (value_array_klasses() == nullptr) {\n+      ArrayKlass* k;\n+      if (flat_array()) {\n+        k = FlatArrayKlass::allocate_klass(this, CHECK_NULL);\n+      } else {\n+        k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, CHECK_NULL);\n+\n@@ -206,0 +200,2 @@\n+      \/\/ use 'release' to pair with lock-free load\n+      Atomic::release_store(adr_value_array_klasses(), k);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1772,13 +1772,9 @@\n-    ResourceMark rm(THREAD);\n-    JavaThread *jt = THREAD;\n-    {\n-      \/\/ Atomic creation of array_klasses\n-      MutexLocker ma(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if update has already taken place\n-      if (array_klasses() == nullptr) {\n-        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this,\n-                                                                  false, CHECK_NULL);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_array_klasses(k);\n-      }\n+\n+    \/\/ Recursively lock array allocation\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n+\n+    \/\/ Check if another thread created the array klass while we were waiting for the lock.\n+    if (array_klasses() == nullptr) {\n+      ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, false, CHECK_NULL);\n+      \/\/ use 'release' to pair with lock-free load\n+      release_set_array_klasses(k);\n@@ -1787,0 +1783,1 @@\n+\n@@ -1789,0 +1786,1 @@\n+  assert(ak != nullptr, \"should be set\");\n@@ -2945,1 +2943,1 @@\n-             CDSConfig::is_loading_full_module_graph() &&\n+             CDSConfig::is_using_full_module_graph() &&\n@@ -3006,1 +3004,1 @@\n-    MutexLocker ml(MultiArray_lock);\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n@@ -3278,1 +3276,1 @@\n-    if (CDSConfig::is_loading_full_module_graph() && _package_entry == pkg_entry) {\n+    if (CDSConfig::is_using_full_module_graph() && _package_entry == pkg_entry) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    assert(MultiArray_lock->holds_lock(THREAD), \"must hold lock after bootstrapping\");\n@@ -71,0 +72,2 @@\n+      \/\/ Also, see if the element has secondary supertypes.\n+      \/\/ We need an array type for each before creating this array type.\n@@ -72,1 +75,1 @@\n-        super_klass = element_klass->array_klass_or_null();\n+        super_klass = element_klass->array_klass(CHECK_NULL);\n@@ -74,1 +77,1 @@\n-        super_klass = element_super->array_klass_or_null();\n+        super_klass = element_super->array_klass(CHECK_NULL);\n@@ -76,4 +79,1 @@\n-      bool supers_exist = super_klass != nullptr;\n-      \/\/ Also, see if the element has secondary supertypes.\n-      \/\/ We need an array type for each.\n-      for( int i = element_supers->length()-1; i >= 0; i-- ) {\n+      for (int i = element_supers->length() - 1; i >= 0; i--) {\n@@ -82,32 +82,1 @@\n-        if (elem_super->array_klass_or_null() == nullptr) {\n-          supers_exist = false;\n-          break;\n-        }\n-      }\n-      if (null_free) {\n-        if (element_klass->array_klass_or_null() == nullptr) {\n-          supers_exist = false;\n-        }\n-      }\n-      if (!supers_exist) {\n-        \/\/ Oops.  Not allocated yet.  Back out, allocate it, and retry.\n-        Klass* ek = nullptr;\n-        {\n-          MutexUnlocker mu(MultiArray_lock);\n-          if (null_free) {\n-            element_klass->array_klass(CHECK_NULL);\n-          } else {\n-            element_super->array_klass(CHECK_NULL);\n-          }\n-          for( int i = element_supers->length()-1; i >= 0; i-- ) {\n-            Klass* elem_super = element_supers->at(i);\n-            elem_super->array_klass(CHECK_NULL);\n-          }\n-          \/\/ Now retry from the beginning\n-          if (null_free) {\n-            ek = InlineKlass::cast(element_klass)->value_array_klass(CHECK_NULL);\n-          } else {\n-            ek = element_klass->array_klass(n, CHECK_NULL);\n-          }\n-        }  \/\/ re-lock\n-        return ObjArrayKlass::cast(ek);\n+        elem_super->array_klass(CHECK_NULL);\n@@ -115,0 +84,1 @@\n+      \/\/ Fall through because inheritance is acyclic and we hold the global recursive lock to allocate all the arrays.\n@@ -159,0 +129,4 @@\n+  if (element_klass->is_array_klass()) {\n+    set_lower_dimension(ArrayKlass::cast(element_klass));\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":13,"deletions":39,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1349,1 +1349,1 @@\n-  void set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  void set_ctrl_of_nodes_with_same_ctrl(Node* start_node, ProjNode* old_uncommon_proj, Node* new_uncommon_proj);\n@@ -1351,5 +1351,3 @@\n-  Node* clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n-  Dict clone_nodes(const Node_List& list_to_clone);\n-  void rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl, const Node_List& nodes_with_same_ctrl,\n-                                   const Dict& old_new_mapping);\n-  void rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping, const Node* next);\n+  Node* clone_nodes_with_same_ctrl(Node* start_node, ProjNode* old_uncommon_proj, Node* new_uncommon_proj);\n+  void fix_cloned_data_node_controls(const ProjNode* orig, Node* new_uncommon_proj,\n+                                     const OrigToNewHashtable& orig_to_clone);\n@@ -1892,0 +1890,38 @@\n+\/\/ Class to clone a data node graph by taking a list of data nodes. This is done in 2 steps:\n+\/\/   1. Clone the data nodes\n+\/\/   2. Fix the cloned data inputs pointing to the old nodes to the cloned inputs by using an old->new mapping.\n+class DataNodeGraph : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+  const Unique_Node_List& _data_nodes;\n+  OrigToNewHashtable _orig_to_new;\n+\n+ public:\n+  DataNodeGraph(const Unique_Node_List& data_nodes, PhaseIdealLoop* phase)\n+      : _phase(phase),\n+        _data_nodes(data_nodes),\n+        \/\/ Use 107 as best guess which is the first resize value in ResizeableResourceHashtable::large_table_sizes.\n+        _orig_to_new(107, MaxNodeLimit)\n+  {\n+#ifdef ASSERT\n+    for (uint i = 0; i < data_nodes.size(); i++) {\n+      assert(!data_nodes[i]->is_CFG(), \"only data nodes\");\n+    }\n+#endif\n+  }\n+  NONCOPYABLE(DataNodeGraph);\n+\n+ private:\n+  void clone(Node* node, Node* new_ctrl);\n+  void clone_data_nodes(Node* new_ctrl);\n+  void rewire_clones_to_cloned_inputs();\n+\n+ public:\n+  \/\/ Clone the provided data node collection and rewire the clones in such a way to create an identical graph copy.\n+  \/\/ Set 'new_ctrl' as ctrl for the cloned nodes.\n+  const OrigToNewHashtable& clone(Node* new_ctrl) {\n+    assert(_orig_to_new.number_of_entries() == 0, \"should not call this method twice in a row\");\n+    clone_data_nodes(new_ctrl);\n+    rewire_clones_to_cloned_inputs();\n+    return _orig_to_new;\n+  }\n+};\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -4678,0 +4678,28 @@\n+\n+void DataNodeGraph::clone_data_nodes(Node* new_ctrl) {\n+  for (uint i = 0; i < _data_nodes.size(); i++) {\n+    clone(_data_nodes[i], new_ctrl);\n+  }\n+}\n+\n+\/\/ Clone the given node and set it up properly. Set `new_ctrl` as ctrl.\n+void DataNodeGraph::clone(Node* node, Node* new_ctrl) {\n+  Node* clone = node->clone();\n+  _phase->igvn().register_new_node_with_optimizer(clone);\n+  _orig_to_new.put(node, clone);\n+  _phase->set_ctrl(clone, new_ctrl);\n+}\n+\n+\/\/ Rewire the data inputs of all (unprocessed) cloned nodes, whose inputs are still pointing to the same inputs as their\n+\/\/ corresponding orig nodes, to the newly cloned inputs to create a separate cloned graph.\n+void DataNodeGraph::rewire_clones_to_cloned_inputs() {\n+  _orig_to_new.iterate_all([&](Node* node, Node* clone) {\n+    for (uint i = 1; i < node->req(); i++) {\n+      Node** cloned_input = _orig_to_new.get(node->in(i));\n+      if (cloned_input != nullptr) {\n+        \/\/ Input was also cloned -> rewire clone to the cloned input.\n+        _phase->igvn().replace_input_of(clone, i, *cloned_input);\n+      }\n+    }\n+  });\n+}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -214,0 +214,2 @@\n+typedef ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-    ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> clones(hash_table_size, hash_table_size);\n+    OrigToNewHashtable clones(hash_table_size, hash_table_size);\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3807,8 +3807,0 @@\n-JVM_LEAF(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n-  return CDSConfig::is_dumping_archive();\n-JVM_END\n-\n-JVM_LEAF(jboolean, JVM_IsSharingEnabled(JNIEnv* env))\n-  return UseSharedSpaces;\n-JVM_END\n-\n@@ -3838,6 +3830,2 @@\n-JVM_LEAF(jboolean, JVM_IsDumpingClassList(JNIEnv *env))\n-#if INCLUDE_CDS\n-  return ClassListWriter::is_enabled() || CDSConfig::is_dumping_dynamic_archive();\n-#else\n-  return false;\n-#endif \/\/ INCLUDE_CDS\n+JVM_ENTRY_NO_ENV(jint, JVM_GetCDSConfigStatus())\n+  return CDSConfig::get_status();\n@@ -3848,1 +3836,1 @@\n-  assert(ClassListWriter::is_enabled() || CDSConfig::is_dumping_dynamic_archive(),  \"Should be set and open or do dynamic dump\");\n+  assert(CDSConfig::is_logging_lambda_form_invokers(), \"sanity\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -871,6 +871,1 @@\n-\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    *thread_state_ptr = JvmtiEnvBase::get_vthread_state(thread_oop, java_thread);\n-  } else {\n-    *thread_state_ptr = JvmtiEnvBase::get_thread_state(thread_oop, java_thread);\n-  }\n+  *thread_state_ptr = JvmtiEnvBase::get_thread_or_vthread_state(thread_oop, java_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,4 +107,0 @@\n-    \/\/ To get a consistent list of classes we need MultiArray_lock to ensure\n-    \/\/ array classes aren't created.\n-    MutexLocker ma(MultiArray_lock);\n-\n@@ -127,2 +123,3 @@\n-    \/\/ array classes aren't created during this walk.\n-    MutexLocker ma(MultiArray_lock);\n+    \/\/ array classes aren't created by another thread during this walk. This walks through the\n+    \/\/ InstanceKlass::_array_klasses links.\n+    RecursiveLocker ma(MultiArray_lock, Thread::current());\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1664,0 +1664,1 @@\n+  intptr_t* fp = nullptr;\n@@ -1674,0 +1675,12 @@\n+      if (*fv.description == '#' && isdigit(fv.description[1])) {\n+        \/\/ The fv.description string starting with a '#' is the line for the\n+        \/\/ saved frame pointer eg. \"#10 method java.lang.invoke.LambdaForm...\"\n+        \/\/ basicaly means frame 10.\n+        fp = fv.location;\n+      }\n+      \/\/ To print a fp-relative value:\n+      \/\/   1. The content of *fv.location must be such that we think it's a\n+      \/\/      fp-relative number, i.e [-100..100].\n+      \/\/   2. We must have found the frame pointer.\n+      \/\/   3. The line can not be the line for the saved frame pointer.\n+      \/\/   4. Recognize it as being part of the \"fixed frame\".\n@@ -1675,0 +1688,1 @@\n+          && fp != nullptr && *fv.description != '#'\n@@ -1683,1 +1697,2 @@\n-        st->print_cr(\" \" INTPTR_FORMAT \": %18d %s\", p2i(fv.location), (int)*fv.location, fv.description);\n+        st->print_cr(\" \" INTPTR_FORMAT \": \" INTPTR_FORMAT \" %-32s (relativized: fp%+d)\",\n+                     p2i(fv.location), p2i(&fp[*fv.location]), fv.description, (int)*fv.location);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"prims\/jvmtiEnvBase.hpp\"\n@@ -1185,1 +1186,2 @@\n-\/\/ Get count Java threads that are waiting to enter the specified monitor.\n+#if INCLUDE_JVMTI\n+\/\/ Get count of Java threads that are waiting to enter or re-enter the specified monitor.\n@@ -1189,0 +1191,1 @@\n+  assert(Thread::current()->is_VM_thread(), \"Must be the VM thread\");\n@@ -1198,1 +1201,8 @@\n-    if (pending == monitor) {             \/\/ found a match\n+    address waiting = (address)p->current_waiting_monitor();\n+    oop thread_oop = JvmtiEnvBase::get_vthread_or_thread_oop(p);\n+    bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+    jint state = is_virtual ? JvmtiEnvBase::get_vthread_state(thread_oop, p)\n+                            : JvmtiEnvBase::get_thread_state(thread_oop, p);\n+    if (pending == monitor || (waiting == monitor &&\n+        (state & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER))\n+    ) { \/\/ found a match\n@@ -1206,1 +1216,1 @@\n-\n+#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -160,1 +160,0 @@\n-  static_assert(sizeof(NULL) == sizeof(char*), \"NULL must be same size as pointer\");\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -619,7 +619,0 @@\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ Utility macros for compilers\n-\/\/ used to silence compiler warnings\n-\n-#define Unused_Variable(var) var\n-\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2463,0 +2463,3 @@\n+            public boolean addEnableNativeAccess(ModuleLayer layer, String name) {\n+                return layer.addEnableNativeAccess(name);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,1 @@\n-            if (CDS.isSharingEnabled()) {\n+            if (CDS.isUsingArchive()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -273,0 +273,6 @@\n+    \/**\n+     * Updates module named {@code name} in layer {@code layer} to allow access to restricted methods.\n+     * Returns true iff the given module exists in the given layer.\n+     *\/\n+    boolean addEnableNativeAccess(ModuleLayer layer, String name);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4240,87 +4240,0 @@\n-\n-    \/\/ The following deprecated methods are used by JSR 166.\n-\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object getObject(Object o, long offset) {\n-        return getReference(o, offset);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object getObjectVolatile(Object o, long offset) {\n-        return getReferenceVolatile(o, offset);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object getObjectAcquire(Object o, long offset) {\n-        return getReferenceAcquire(o, offset);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object getObjectOpaque(Object o, long offset) {\n-        return getReferenceOpaque(o, offset);\n-    }\n-\n-\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final void putObject(Object o, long offset, Object x) {\n-        putReference(o, offset, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final void putObjectVolatile(Object o, long offset, Object x) {\n-        putReferenceVolatile(o, offset, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final void putObjectOpaque(Object o, long offset, Object x) {\n-        putReferenceOpaque(o, offset, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final void putObjectRelease(Object o, long offset, Object x) {\n-        putReferenceRelease(o, offset, x);\n-    }\n-\n-\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object getAndSetObject(Object o, long offset, Object newValue) {\n-        return getAndSetReference(o, offset, newValue);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object getAndSetObjectAcquire(Object o, long offset, Object newValue) {\n-        return getAndSetReferenceAcquire(o, offset, newValue);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object getAndSetObjectRelease(Object o, long offset, Object newValue) {\n-        return getAndSetReferenceRelease(o, offset, newValue);\n-    }\n-\n-\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final boolean compareAndSetObject(Object o, long offset, Object expected, Object x) {\n-        return compareAndSetReference(o, offset, expected, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object compareAndExchangeObject(Object o, long offset, Object expected, Object x) {\n-        return compareAndExchangeReference(o, offset, expected, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object compareAndExchangeObjectAcquire(Object o, long offset, Object expected, Object x) {\n-        return compareAndExchangeReferenceAcquire(o, offset, expected, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final Object compareAndExchangeObjectRelease(Object o, long offset, Object expected, Object x) {\n-        return compareAndExchangeReferenceRelease(o, offset, expected, x);\n-    }\n-\n-\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final boolean weakCompareAndSetObject(Object o, long offset, Object expected, Object x) {\n-        return weakCompareAndSetReference(o, offset, expected, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final boolean weakCompareAndSetObjectAcquire(Object o, long offset, Object expected, Object x) {\n-        return weakCompareAndSetReferenceAcquire(o, offset, expected, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final boolean weakCompareAndSetObjectPlain(Object o, long offset, Object expected, Object x) {\n-        return weakCompareAndSetReferencePlain(o, offset, expected, x);\n-    }\n-    @Deprecated(since=\"12\", forRemoval=true)\n-    public final boolean weakCompareAndSetObjectRelease(Object o, long offset, Object expected, Object x) {\n-        return weakCompareAndSetReferenceRelease(o, offset, expected, x);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-runtime\/CompressedOops\/CompressedClassPointers.java 8322943 aix-ppc64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -434,1 +434,2 @@\n- -runtime\/signal\n+ -runtime\/signal \\\n+ -runtime\/stack\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -60,1 +58,0 @@\n-import java.util.stream.Collectors;\n@@ -538,4 +535,3 @@\n-                .run(Task.Expect.FAIL)\n-                .getOutputLines(Task.OutputKind.STDERR);\n-        log = log.stream().filter(s->!s.matches(\"^Picked up .*JAVA.*OPTIONS:.*\")).collect(Collectors.toList());\n-        checkEqual(\"stderr\", log, List.of(\"error: --enable-preview must be used with --source\"));\n+                .run(Task.Expect.SUCCESS)\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+        checkEqual(\"stdout\", log, List.of(\"Hello World! []\"));\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"}]}