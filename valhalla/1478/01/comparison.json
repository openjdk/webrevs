{"files":[{"patch":"@@ -280,1 +280,1 @@\n-uint InlineTypeNode::add_fields_to_safepoint(Unique_Node_List& worklist, Node_List& null_markers, SafePointNode* sfpt) {\n+uint InlineTypeNode::add_fields_to_safepoint(Unique_Node_List& worklist, SafePointNode* sfpt) {\n@@ -286,1 +286,1 @@\n-      cnt += vt->add_fields_to_safepoint(worklist, null_markers, sfpt);\n+      cnt += vt->add_fields_to_safepoint(worklist, sfpt);\n@@ -288,1 +288,2 @@\n-        null_markers.push(vt->get_is_init());\n+        \/\/ The null marker of a flat field is added right after we scalarize that field\n+        sfpt->add_req(vt->get_is_init());\n@@ -311,12 +312,2 @@\n-  const TypeInt* tinit = igvn->type(get_is_init())->isa_int();\n-  if (tinit != nullptr && !tinit->is_con(1)) {\n-    sfpt->add_req(get_is_init());\n-  } else {\n-    sfpt->add_req(igvn->C->top());\n-  }\n-  Node_List null_markers;\n-  uint nfields = add_fields_to_safepoint(worklist, null_markers, sfpt);\n-  \/\/ Add null markers after the field values\n-  for (uint i = 0; i < null_markers.size(); ++i) {\n-    sfpt->add_req(null_markers.at(i));\n-  }\n+  sfpt->add_req(get_is_init());\n+  uint nfields = add_fields_to_safepoint(worklist, sfpt);\n@@ -1609,1 +1600,1 @@\n-  vt->set_is_init(gvn, false);\n+  vt->set_is_init(gvn, gvn.intcon(0));\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  uint add_fields_to_safepoint(Unique_Node_List& worklist, Node_List& null_markers, SafePointNode* sfpt);\n+  uint add_fields_to_safepoint(Unique_Node_List& worklist, SafePointNode* sfpt);\n@@ -109,1 +109,2 @@\n-  void  set_is_init(PhaseGVN& gvn, bool init = true) { set_req_X(IsInit, gvn.intcon(init ? 1 : 0), &gvn); }\n+  void  set_is_init(PhaseGVN& gvn, Node* init) { set_req_X(IsInit, init, &gvn); }\n+  void  set_is_init(PhaseGVN& gvn) { set_is_init(gvn, gvn.intcon(1)); }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciInstanceKlass.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -591,3 +593,15 @@\n-Node* PhaseMacroExpand::inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc) {\n-  \/\/ Subtract the offset of the first field to account for the missing oop header\n-  offset -= vk->payload_offset();\n+Node* PhaseMacroExpand::inline_type_from_mem(ciInlineKlass* vk, const TypeAryPtr* elem_adr_type, int elem_idx, int offset_in_element, bool null_free, AllocateNode* alloc, SafePointNode* sfpt) {\n+  auto report_failure = [&](int field_offset_in_element) {\n+#ifndef PRODUCT\n+    if (PrintEliminateAllocations) {\n+      ciInlineKlass* elem_klass = elem_adr_type->elem()->inline_klass();\n+      int offset = field_offset_in_element + elem_klass->payload_offset();\n+      ciField* flattened_field = elem_klass->get_field_by_offset(offset, false);\n+      assert(flattened_field != nullptr, \"must have a field of type %s at offset %d\", elem_klass->name()->as_utf8(), offset);\n+      tty->print(\"=== At SafePoint node %d can't find value of field [%s] of array element [%d]\", sfpt->_idx, flattened_field->name()->as_utf8(), elem_idx);\n+      tty->print(\", which prevents elimination of: \");\n+      alloc->dump();\n+    }\n+#endif \/\/ PRODUCT\n+  };\n+\n@@ -595,1 +609,1 @@\n-  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk);\n+  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk, false);\n@@ -597,0 +611,14 @@\n+  if (null_free) {\n+    vt->set_is_init(_igvn);\n+  } else {\n+    int nm_offset_in_element = offset_in_element + vk->null_marker_offset_in_payload();\n+    const TypeAryPtr* nm_adr_type = elem_adr_type->with_field_offset(nm_offset_in_element);\n+    Node* nm_value = value_from_mem(sfpt->memory(), sfpt->control(), T_BOOLEAN, TypeInt::BOOL, nm_adr_type, alloc);\n+    if (nm_value != nullptr) {\n+      vt->set_is_init(_igvn, nm_value);\n+    } else {\n+      report_failure(nm_offset_in_element);\n+      return nullptr;\n+    }\n+  }\n+\n@@ -599,2 +627,2 @@\n-    int field_offset = offset + vt->field_offset(i);\n-    Node* value = nullptr;\n+    int field_offset_in_element = offset_in_element + vt->field_offset(i) - vk->payload_offset();\n+    Node* field_value = nullptr;\n@@ -602,6 +630,1 @@\n-      \/\/ TODO 8350865 Fix this\n-      \/\/ assert(vt->field_is_null_free(i), \"Unexpected nullable flat field\");\n-      if (!vt->field_is_null_free(i)) {\n-        return nullptr;\n-      }\n-      value = inline_type_from_mem(mem, ctl, field_type->as_inline_klass(), adr_type, field_offset, alloc);\n+      field_value = inline_type_from_mem(field_type->as_inline_klass(), elem_adr_type, elem_idx, field_offset_in_element, vt->field_is_null_free(i), alloc, sfpt);\n@@ -616,3 +639,5 @@\n-      adr_type = adr_type->with_field_offset(field_offset);\n-      value = value_from_mem(mem, ctl, bt, ft, adr_type, alloc);\n-      if (value != nullptr && ft->isa_narrowoop()) {\n+      const TypeAryPtr* field_adr_type = elem_adr_type->with_field_offset(field_offset_in_element);\n+      field_value = value_from_mem(sfpt->memory(), sfpt->control(), bt, ft, field_adr_type, alloc);\n+      if (field_value == nullptr) {\n+        report_failure(field_offset_in_element);\n+      } else if (ft->isa_narrowoop()) {\n@@ -620,4 +645,4 @@\n-        if (value->is_EncodeP()) {\n-          value = value->in(1);\n-        } else if (!value->is_InlineType()) {\n-          value = transform_later(new DecodeNNode(value, value->get_ptr_type()));\n+        if (field_value->is_EncodeP()) {\n+          field_value = field_value->in(1);\n+        } else if (!field_value->is_InlineType()) {\n+          field_value = transform_later(new DecodeNNode(field_value, field_value->get_ptr_type()));\n@@ -627,2 +652,2 @@\n-    if (value != nullptr) {\n-      vt->set_field_value(i, value);\n+    if (field_value != nullptr) {\n+      vt->set_field_value(i, field_value);\n@@ -630,1 +655,0 @@\n-      \/\/ We might have reached the TrackedInitializationLimit\n@@ -854,1 +878,143 @@\n-SafePointScalarObjectNode* PhaseMacroExpand::create_scalarized_object_description(AllocateNode *alloc, SafePointNode* sfpt,\n+void PhaseMacroExpand::process_field_value_at_safepoint(const Type* field_type, Node* field_val, SafePointNode* sfpt, Unique_Node_List* value_worklist) {\n+  if (UseCompressedOops && field_type->isa_narrowoop()) {\n+    \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n+    \/\/ to be able scalar replace the allocation.\n+    if (field_val->is_EncodeP()) {\n+      field_val = field_val->in(1);\n+    } else if (!field_val->is_InlineType()) {\n+      field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n+    }\n+  }\n+\n+  \/\/ Keep track of inline types to scalarize them later\n+  if (field_val->is_InlineType()) {\n+    value_worklist->push(field_val);\n+  } else if (field_val->is_Phi()) {\n+    PhiNode* phi = field_val->as_Phi();\n+    \/\/ Eagerly replace inline type phis now since we could be removing an inline type allocation where we must\n+    \/\/ scalarize all its fields in safepoints.\n+    field_val = phi->try_push_inline_types_down(&_igvn, true);\n+    if (field_val->is_InlineType()) {\n+      value_worklist->push(field_val);\n+    }\n+  }\n+  sfpt->add_req(field_val);\n+}\n+\n+bool PhaseMacroExpand::add_array_elems_to_safepoint(AllocateNode* alloc, const TypeAryPtr* array_type, SafePointNode* sfpt, Unique_Node_List* value_worklist) {\n+  const Type* elem_type = array_type->elem();\n+  BasicType basic_elem_type = elem_type->array_element_basic_type();\n+\n+  intptr_t elem_size;\n+  if (array_type->is_flat()) {\n+    elem_size = array_type->flat_elem_size();\n+  } else {\n+    elem_size = type2aelembytes(basic_elem_type);\n+  }\n+\n+  int n_elems = alloc->in(AllocateNode::ALength)->get_int();\n+  for (int elem_idx = 0; elem_idx < n_elems; elem_idx++) {\n+    intptr_t elem_offset = arrayOopDesc::base_offset_in_bytes(basic_elem_type) + elem_idx * elem_size;\n+    const TypeAryPtr* elem_adr_type = array_type->with_offset(elem_offset);\n+    Node* elem_val;\n+    if (array_type->is_flat()) {\n+      ciInlineKlass* elem_klass = elem_type->inline_klass();\n+      assert(elem_klass->maybe_flat_in_array(), \"must be flat in array\");\n+      elem_val = inline_type_from_mem(elem_klass, elem_adr_type, elem_idx, 0, array_type->is_null_free(), alloc, sfpt);\n+    } else {\n+      elem_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, elem_type, elem_adr_type, alloc);\n+#ifndef PRODUCT\n+      if (PrintEliminateAllocations && elem_val == nullptr) {\n+        tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\", sfpt->_idx, elem_idx);\n+        tty->print(\", which prevents elimination of: \");\n+        alloc->dump();\n+      }\n+#endif \/\/ PRODUCT\n+    }\n+    if (elem_val == nullptr) {\n+      return false;\n+    }\n+\n+    process_field_value_at_safepoint(elem_type, elem_val, sfpt, value_worklist);\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ Recursively adds all flattened fields of a type 'iklass' inside 'base' to 'sfpt'.\n+\/\/ 'offset_minus_header' refers to the offset of the payload of 'iklass' inside 'base' minus the\n+\/\/ payload offset of 'iklass'. If 'base' is of type 'iklass' then 'offset_minus_header' == 0.\n+bool PhaseMacroExpand::add_inst_fields_to_safepoint(ciInstanceKlass* iklass, AllocateNode* alloc, Node* base, int offset_minus_header, SafePointNode* sfpt, Unique_Node_List* value_worklist) {\n+  const TypeInstPtr* base_type = _igvn.type(base)->is_instptr();\n+  auto report_failure = [&](int offset) {\n+#ifndef PRODUCT\n+    if (PrintEliminateAllocations) {\n+      ciInstanceKlass* base_klass = base_type->instance_klass();\n+      ciField* flattened_field = base_klass->get_field_by_offset(offset, false);\n+      assert(flattened_field != nullptr, \"must have a field of type %s at offset %d\", base_klass->name()->as_utf8(), offset);\n+      tty->print(\"=== At SafePoint node %d can't find value of field: \", sfpt->_idx);\n+      flattened_field->print();\n+      int field_idx = C->alias_type(flattened_field)->index();\n+      tty->print(\" (alias_idx=%d)\", field_idx);\n+      tty->print(\", which prevents elimination of: \");\n+      base->dump();\n+    }\n+#endif \/\/ PRODUCT\n+  };\n+\n+  for (int i = 0; i < iklass->nof_declared_nonstatic_fields(); i++) {\n+    ciField* field = iklass->declared_nonstatic_field_at(i);\n+    if (field->is_flat()) {\n+      ciInlineKlass* fvk = field->type()->as_inline_klass();\n+      int field_offset_minus_header = offset_minus_header + field->offset_in_bytes() - fvk->payload_offset();\n+      bool success = add_inst_fields_to_safepoint(fvk, alloc, base, field_offset_minus_header, sfpt, value_worklist);\n+      if (!success) {\n+        return false;\n+      }\n+\n+      \/\/ The null marker of a field is added right after we scalarize that field\n+      if (!field->is_null_free()) {\n+        int nm_offset = offset_minus_header + field->null_marker_offset();\n+        Node* null_marker = value_from_mem(sfpt->memory(), sfpt->control(), T_BOOLEAN, TypeInt::BOOL, base_type->with_offset(nm_offset), alloc);\n+        if (null_marker == nullptr) {\n+          report_failure(nm_offset);\n+          return false;\n+        }\n+        process_field_value_at_safepoint(TypeInt::BOOL, null_marker, sfpt, value_worklist);\n+      }\n+\n+      continue;\n+    }\n+\n+    int offset = offset_minus_header + field->offset_in_bytes();\n+    ciType* elem_type = field->type();\n+    BasicType basic_elem_type = field->layout_type();\n+\n+    const Type* field_type;\n+    if (is_reference_type(basic_elem_type)) {\n+      if (!elem_type->is_loaded()) {\n+        field_type = TypeInstPtr::BOTTOM;\n+      } else {\n+        field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n+      }\n+      if (UseCompressedOops) {\n+        field_type = field_type->make_narrowoop();\n+        basic_elem_type = T_NARROWOOP;\n+      }\n+    } else {\n+      field_type = Type::get_const_basic_type(basic_elem_type);\n+    }\n+\n+    const TypeInstPtr* field_addr_type = base_type->add_offset(offset)->isa_instptr();\n+    Node* field_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, field_type, field_addr_type, alloc);\n+    if (field_val == nullptr) {\n+      report_failure(offset);\n+      return false;\n+    }\n+    process_field_value_at_safepoint(field_type, field_val, sfpt, value_worklist);\n+  }\n+\n+  return true;\n+}\n+\n+SafePointScalarObjectNode* PhaseMacroExpand::create_scalarized_object_description(AllocateNode* alloc, SafePointNode* sfpt,\n@@ -860,2 +1026,0 @@\n-  BasicType basic_elem_type  = T_ILLEGAL;\n-  const Type* field_type     = nullptr;\n@@ -864,2 +1028,0 @@\n-  int array_base             = 0;\n-  int element_size           = 0;\n@@ -871,0 +1033,1 @@\n+  uint before_sfpt_req = sfpt->req();\n@@ -883,8 +1046,0 @@\n-      basic_elem_type = res_type->is_aryptr()->elem()->array_element_basic_type();\n-      array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n-      element_size = type2aelembytes(basic_elem_type);\n-      field_type = res_type->is_aryptr()->elem();\n-      if (res_type->is_flat()) {\n-        \/\/ Flat inline type array\n-        element_size = res_type->is_aryptr()->flat_elem_size();\n-      }\n@@ -908,84 +1063,4 @@\n-  \/\/ Scan object's fields adding an input to the safepoint for each field.\n-  for (int j = 0; j < nfields; j++) {\n-    intptr_t offset;\n-    ciField* field = nullptr;\n-    if (iklass != nullptr) {\n-      field = iklass->nonstatic_field_at(j);\n-      offset = field->offset_in_bytes();\n-      ciType* elem_type = field->type();\n-      basic_elem_type = field->layout_type();\n-      assert(!field->is_flat(), \"flat inline type fields should not have safepoint uses\");\n-\n-      ciField* flat_field = iklass->get_non_flat_field_by_offset(offset);\n-      if (flat_field != nullptr && flat_field->is_flat() && !flat_field->is_null_free()) {\n-        \/\/ TODO 8353432 Add support for nullable, flat fields in non-value class holders\n-        \/\/ Below code only iterates over the flat representation and therefore misses to\n-        \/\/ add null markers like we do in InlineTypeNode::add_fields_to_safepoint for value\n-        \/\/ class holders.\n-        _igvn._worklist.push(sfpt);\n-        return nullptr;\n-      }\n-\n-      \/\/ The next code is taken from Parse::do_get_xxx().\n-      if (is_reference_type(basic_elem_type)) {\n-        if (!elem_type->is_loaded()) {\n-          field_type = TypeInstPtr::BOTTOM;\n-        } else if (field != nullptr && field->is_static_constant()) {\n-          ciObject* con = field->constant_value().as_object();\n-          \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-          \/\/ and may yield a vacuous result if the field is of interface type.\n-          field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n-          assert(field_type != nullptr, \"field singleton type must be consistent\");\n-        } else {\n-          field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n-        }\n-        if (UseCompressedOops) {\n-          field_type = field_type->make_narrowoop();\n-          basic_elem_type = T_NARROWOOP;\n-        }\n-      } else {\n-        field_type = Type::get_const_basic_type(basic_elem_type);\n-      }\n-    } else {\n-      offset = array_base + j * (intptr_t)element_size;\n-    }\n-\n-    Node* field_val = nullptr;\n-    const TypeOopPtr* field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n-    if (res_type->is_flat()) {\n-      ciInlineKlass* inline_klass = res_type->is_aryptr()->elem()->inline_klass();\n-      assert(inline_klass->maybe_flat_in_array(), \"must be flat in array\");\n-      field_val = inline_type_from_mem(sfpt->memory(), sfpt->control(), inline_klass, field_addr_type->isa_aryptr(), 0, alloc);\n-    } else {\n-      field_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, field_type, field_addr_type, alloc);\n-    }\n-\n-    \/\/ We weren't able to find a value for this field,\n-    \/\/ give up on eliminating this allocation.\n-    if (field_val == nullptr) {\n-      uint last = sfpt->req() - 1;\n-      for (int k = 0;  k < j; k++) {\n-        sfpt->del_req(last--);\n-      }\n-      _igvn._worklist.push(sfpt);\n-\n-#ifndef PRODUCT\n-      if (PrintEliminateAllocations) {\n-        if (field != nullptr) {\n-          tty->print(\"=== At SafePoint node %d can't find value of field: \", sfpt->_idx);\n-          field->print();\n-          int field_idx = C->get_alias_index(field_addr_type);\n-          tty->print(\" (alias_idx=%d)\", field_idx);\n-        } else { \/\/ Array's element\n-          tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\", sfpt->_idx, j);\n-        }\n-        tty->print(\", which prevents elimination of: \");\n-        if (res == nullptr)\n-          alloc->dump();\n-        else\n-          res->dump();\n-      }\n-#endif\n-\n-      return nullptr;\n-    }\n+  if (res == nullptr) {\n+    sfpt->jvms()->set_endoff(sfpt->req());\n+    return sobj;\n+  }\n@@ -993,9 +1068,6 @@\n-    if (UseCompressedOops && field_type->isa_narrowoop()) {\n-      \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n-      \/\/ to be able scalar replace the allocation.\n-      if (field_val->is_EncodeP()) {\n-        field_val = field_val->in(1);\n-      } else if (!field_val->is_InlineType()) {\n-        field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n-      }\n-    }\n+  bool success;\n+  if (iklass == nullptr) {\n+    success = add_array_elems_to_safepoint(alloc, res_type->is_aryptr(), sfpt, value_worklist);\n+  } else {\n+    success = add_inst_fields_to_safepoint(iklass, alloc, res, 0, sfpt, value_worklist);\n+  }\n@@ -1003,11 +1075,4 @@\n-    \/\/ Keep track of inline types to scalarize them later\n-    if (field_val->is_InlineType()) {\n-      value_worklist->push(field_val);\n-    } else if (field_val->is_Phi()) {\n-      PhiNode* phi = field_val->as_Phi();\n-      \/\/ Eagerly replace inline type phis now since we could be removing an inline type allocation where we must\n-      \/\/ scalarize all its fields in safepoints.\n-      field_val = phi->try_push_inline_types_down(&_igvn, true);\n-      if (field_val->is_InlineType()) {\n-        value_worklist->push(field_val);\n-      }\n+  \/\/ We weren't able to find a value for this field, remove all the fields added to the safepoint\n+  if (!success) {\n+    for (uint i = sfpt->req() - 1; i >= before_sfpt_req; i--) {\n+      sfpt->del_req(i);\n@@ -1015,1 +1080,2 @@\n-    sfpt->add_req(field_val);\n+    _igvn._worklist.push(sfpt);\n+    return nullptr;\n@@ -1019,1 +1085,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":206,"deletions":141,"binary":false,"changes":347,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+#include \"ci\/ciInstanceKlass.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/node.hpp\"\n@@ -95,3 +98,7 @@\n-  Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);\n-  Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);\n-  Node* inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc);\n+\n+  void process_field_value_at_safepoint(const Type* field_type, Node* field_val, SafePointNode* sfpt, Unique_Node_List* value_worklist);\n+  bool add_array_elems_to_safepoint(AllocateNode* alloc, const TypeAryPtr* array_type, SafePointNode* sfpt, Unique_Node_List* value_worklist);\n+  bool add_inst_fields_to_safepoint(ciInstanceKlass* iklass, AllocateNode* alloc, Node* base, int offset_minus_header, SafePointNode* sfpt, Unique_Node_List* value_worklist);\n+  Node* value_from_mem(Node* mem, Node* ctl, BasicType ft, const Type* ftype, const TypeOopPtr* adr_t, AllocateNode* alloc);\n+  Node* value_from_mem_phi(Node* mem, BasicType ft, const Type* ftype, const TypeOopPtr* adr_t, AllocateNode* alloc, Node_Stack* value_phis, int level);\n+  Node* inline_type_from_mem(ciInlineKlass* vk, const TypeAryPtr* elem_adr_type, int elem_idx, int offset_in_element, bool null_free, AllocateNode* alloc, SafePointNode* sfpt);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1546,2 +1546,3 @@\n-\/\/ Restore fields of an eliminated instance object employing the same field order used by the compiler.\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, GrowableArray<int>* null_marker_offsets, TRAPS) {\n+\/\/ Restore fields of an eliminated instance object employing the same field order used by the\n+\/\/ compiler when it scalarizes an object at safepoints.\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, TRAPS) {\n@@ -1551,7 +1552,0 @@\n-  \/\/ Keep track of null marker offset for flat fields\n-  bool set_null_markers = false;\n-  if (null_marker_offsets == nullptr) {\n-    set_null_markers = true;\n-    null_marker_offsets = new GrowableArray<int>();\n-  }\n-\n@@ -1567,1 +1561,1 @@\n-      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, null_marker_offsets, CHECK_0);\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, CHECK_0);\n@@ -1569,0 +1563,2 @@\n+        ScopeValue* scope_field = sv->field_at(svIndex);\n+        StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n@@ -1570,1 +1566,2 @@\n-        null_marker_offsets->append(nm_offset);\n+        obj->bool_field_put(nm_offset, value->get_jint() & 1);\n+        svIndex++;\n@@ -1574,0 +1571,1 @@\n+\n@@ -1649,9 +1647,1 @@\n-  if (set_null_markers) {\n-    \/\/ The null marker values come after all the field values in the debug info\n-    assert(null_marker_offsets->length() == (sv->field_size() - svIndex), \"Missing null marker(s) in debug info\");\n-    for (int i = 0; i < null_marker_offsets->length(); ++i) {\n-      int offset = null_marker_offsets->at(i);\n-      jbyte is_init = (jbyte)StackValue::create_stack_value(fr, reg_map, sv->field_at(svIndex++))->get_jint();\n-      obj->byte_field_put(offset, is_init);\n-    }\n-  }\n+\n@@ -1671,1 +1661,1 @@\n-    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, nullptr, CHECK);\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, CHECK);\n@@ -1720,1 +1710,1 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, nullptr, CHECK);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-    \/\/ TODO 8353432\n-    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = IRNode.ALLOC)\n+    @IR(failOn = IRNode.ALLOC)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -171,2 +171,1 @@\n-    \/\/ TODO 8357061\n-    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n+    @IR(failOn = {ALLOC, STORE})\n@@ -220,2 +219,1 @@\n-    \/\/ TODO 8357061\n-    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n+    @IR(failOn = {ALLOC, STORE})\n@@ -531,2 +529,1 @@\n-    \/\/ TODO 8357061\n-    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"true\"},\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n@@ -534,1 +531,1 @@\n-    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"false\"},\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}