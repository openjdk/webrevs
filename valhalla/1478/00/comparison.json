{"files":[{"patch":"@@ -276,1 +276,1 @@\n-uint InlineTypeNode::add_fields_to_safepoint(Unique_Node_List& worklist, Node_List& null_markers, SafePointNode* sfpt) {\n+uint InlineTypeNode::add_fields_to_safepoint(Unique_Node_List& worklist, SafePointNode* sfpt) {\n@@ -282,1 +282,1 @@\n-      cnt += vt->add_fields_to_safepoint(worklist, null_markers, sfpt);\n+      cnt += vt->add_fields_to_safepoint(worklist, sfpt);\n@@ -284,1 +284,2 @@\n-        null_markers.push(vt->get_is_init());\n+        \/\/ The null marker of a flat field is added right after we scalarize that field\n+        sfpt->add_req(vt->get_is_init());\n@@ -307,12 +308,2 @@\n-  const TypeInt* tinit = igvn->type(get_is_init())->isa_int();\n-  if (tinit != nullptr && !tinit->is_con(1)) {\n-    sfpt->add_req(get_is_init());\n-  } else {\n-    sfpt->add_req(igvn->C->top());\n-  }\n-  Node_List null_markers;\n-  uint nfields = add_fields_to_safepoint(worklist, null_markers, sfpt);\n-  \/\/ Add null markers after the field values\n-  for (uint i = 0; i < null_markers.size(); ++i) {\n-    sfpt->add_req(null_markers.at(i));\n-  }\n+  sfpt->add_req(get_is_init());\n+  uint nfields = add_fields_to_safepoint(worklist, sfpt);\n@@ -1672,1 +1663,1 @@\n-  vt->set_is_init(gvn, false);\n+  vt->set_is_init(gvn, gvn.intcon(0));\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  uint add_fields_to_safepoint(Unique_Node_List& worklist, Node_List& null_markers, SafePointNode* sfpt);\n+  uint add_fields_to_safepoint(Unique_Node_List& worklist, SafePointNode* sfpt);\n@@ -103,1 +103,2 @@\n-  void  set_is_init(PhaseGVN& gvn, bool init = true) { set_req_X(IsInit, gvn.intcon(init ? 1 : 0), &gvn); }\n+  void  set_is_init(PhaseGVN& gvn, Node* init) { set_req_X(IsInit, init, &gvn); }\n+  void  set_is_init(PhaseGVN& gvn) { set_is_init(gvn, gvn.intcon(1)); }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciInstanceKlass.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -591,3 +593,1 @@\n-Node* PhaseMacroExpand::inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc) {\n-  \/\/ Subtract the offset of the first field to account for the missing oop header\n-  offset -= vk->payload_offset();\n+Node* PhaseMacroExpand::inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* elem_adr_type, int offset_in_element, bool null_free, AllocateNode* alloc) {\n@@ -595,1 +595,1 @@\n-  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk);\n+  InlineTypeNode* vt = InlineTypeNode::make_uninitialized(_igvn, vk, false);\n@@ -597,0 +597,9 @@\n+  if (null_free) {\n+    vt->set_is_init(_igvn);\n+  } else {\n+    int nm_offset_in_element = offset_in_element + vk->null_marker_offset_in_payload();\n+    const TypeAryPtr* nm_adr_type = elem_adr_type->with_field_offset(nm_offset_in_element);\n+    Node* value = value_from_mem(mem, ctl, T_BOOLEAN, TypeInt::BOOL, nm_adr_type, alloc);\n+    vt->set_is_init(_igvn, value);\n+  }\n+\n@@ -599,1 +608,1 @@\n-    int field_offset = offset + vt->field_offset(i);\n+    int field_offset_in_element = offset_in_element + vt->field_offset(i) - vk->payload_offset();\n@@ -602,6 +611,1 @@\n-      \/\/ TODO 8350865 Fix this\n-      \/\/ assert(vt->field_is_null_free(i), \"Unexpected nullable flat field\");\n-      if (!vt->field_is_null_free(i)) {\n-        return nullptr;\n-      }\n-      value = inline_type_from_mem(mem, ctl, field_type->as_inline_klass(), adr_type, field_offset, alloc);\n+      value = inline_type_from_mem(mem, ctl, field_type->as_inline_klass(), elem_adr_type, field_offset_in_element, vt->field_is_null_free(i), alloc);\n@@ -616,2 +620,2 @@\n-      adr_type = adr_type->with_field_offset(field_offset);\n-      value = value_from_mem(mem, ctl, bt, ft, adr_type, alloc);\n+      const TypeAryPtr* field_adr_type = elem_adr_type->with_field_offset(field_offset_in_element);\n+      value = value_from_mem(mem, ctl, bt, ft, field_adr_type, alloc);\n@@ -854,1 +858,103 @@\n-SafePointScalarObjectNode* PhaseMacroExpand::create_scalarized_object_description(AllocateNode *alloc, SafePointNode* sfpt,\n+void PhaseMacroExpand::process_field_value_at_safepoint(const Type* field_type, Node* field_val, SafePointNode* sfpt, Unique_Node_List* value_worklist) {\n+  if (UseCompressedOops && field_type->isa_narrowoop()) {\n+    \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n+    \/\/ to be able scalar replace the allocation.\n+    if (field_val->is_EncodeP()) {\n+      field_val = field_val->in(1);\n+    } else if (!field_val->is_InlineType()) {\n+      field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n+    }\n+  }\n+\n+  \/\/ Keep track of inline types to scalarize them later\n+  if (field_val->is_InlineType()) {\n+    value_worklist->push(field_val);\n+  } else if (field_val->is_Phi()) {\n+    PhiNode* phi = field_val->as_Phi();\n+    \/\/ Eagerly replace inline type phis now since we could be removing an inline type allocation where we must\n+    \/\/ scalarize all its fields in safepoints.\n+    field_val = phi->try_push_inline_types_down(&_igvn, true);\n+    if (field_val->is_InlineType()) {\n+      value_worklist->push(field_val);\n+    }\n+  }\n+  sfpt->add_req(field_val);\n+}\n+\n+\/\/ Recursively adds all flattened fields of a type 'iklass' inside 'base' to 'sfpt'.\n+\/\/ 'offset_minus_header' refers to the offset of the payload of 'iklass' inside 'base' minus the\n+\/\/ payload offset of 'iklass'. If 'base' is of type 'iklass' then 'offset_minus_header' == 0.\n+bool PhaseMacroExpand::add_inst_fields_to_safepoint(ciInstanceKlass* iklass, AllocateNode* alloc, Node* base, int offset_minus_header, SafePointNode* sfpt, Unique_Node_List* value_worklist) {\n+  const TypeInstPtr* base_type = _igvn.type(base)->is_instptr();\n+  auto report_failure = [&](int offset) {\n+#ifndef PRODUCT\n+    if (PrintEliminateAllocations) {\n+      ciInstanceKlass* base_klass = base_type->instance_klass();\n+      ciField* flattened_field = base_klass->get_field_by_offset(offset, false);\n+      assert(flattened_field != nullptr, \"must have a field of type %s at offset %d\", base_klass->name()->as_utf8(), offset);\n+      tty->print(\"=== At SafePoint node %d can't find value of field: \", sfpt->_idx);\n+      flattened_field->print();\n+      int field_idx = C->alias_type(flattened_field)->index();\n+      tty->print(\" (alias_idx=%d)\", field_idx);\n+      tty->print(\", which prevents elimination of: \");\n+      base->dump();\n+    }\n+#endif \/\/ PRODUCT\n+  };\n+\n+  for (int i = 0; i < iklass->nof_declared_nonstatic_fields(); i++) {\n+    ciField* field = iklass->declared_nonstatic_field_at(i);\n+    if (field->is_flat()) {\n+      ciInlineKlass* fvk = field->type()->as_inline_klass();\n+      int field_offset_minus_header = offset_minus_header + field->offset_in_bytes() - fvk->payload_offset();\n+      bool success = add_inst_fields_to_safepoint(fvk, alloc, base, field_offset_minus_header, sfpt, value_worklist);\n+      if (!success) {\n+        return false;\n+      }\n+\n+      \/\/ The null marker of a field is added right after we scalarize that field\n+      if (!field->is_null_free()) {\n+        int nm_offset = offset_minus_header + field->null_marker_offset();\n+        Node* null_marker = value_from_mem(sfpt->memory(), sfpt->control(), T_BOOLEAN, TypeInt::BOOL, base_type->with_offset(nm_offset), alloc);\n+        if (null_marker == nullptr) {\n+          report_failure(nm_offset);\n+          return false;\n+        }\n+        process_field_value_at_safepoint(TypeInt::BOOL, null_marker, sfpt, value_worklist);\n+      }\n+\n+      continue;\n+    }\n+\n+    int offset = offset_minus_header + field->offset_in_bytes();\n+    ciType* elem_type = field->type();\n+    BasicType basic_elem_type = field->layout_type();\n+\n+    const Type* field_type;\n+    if (is_reference_type(basic_elem_type)) {\n+      if (!elem_type->is_loaded()) {\n+        field_type = TypeInstPtr::BOTTOM;\n+      } else {\n+        field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n+      }\n+      if (UseCompressedOops) {\n+        field_type = field_type->make_narrowoop();\n+        basic_elem_type = T_NARROWOOP;\n+      }\n+    } else {\n+      field_type = Type::get_const_basic_type(basic_elem_type);\n+    }\n+\n+    const TypeInstPtr* field_addr_type = base_type->add_offset(offset)->isa_instptr();\n+    Node* field_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, field_type, field_addr_type, alloc);\n+    if (field_val == nullptr) {\n+      report_failure(offset);\n+      return false;\n+    }\n+    process_field_value_at_safepoint(field_type, field_val, sfpt, value_worklist);\n+  }\n+\n+  return true;\n+}\n+\n+SafePointScalarObjectNode* PhaseMacroExpand::create_scalarized_object_description(AllocateNode* alloc, SafePointNode* sfpt,\n@@ -860,2 +966,0 @@\n-  BasicType basic_elem_type  = T_ILLEGAL;\n-  const Type* field_type     = nullptr;\n@@ -864,2 +968,0 @@\n-  int array_base             = 0;\n-  int element_size           = 0;\n@@ -871,0 +973,1 @@\n+  uint before_sfpt_req = sfpt->req();\n@@ -883,8 +986,0 @@\n-      basic_elem_type = res_type->is_aryptr()->elem()->array_element_basic_type();\n-      array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n-      element_size = type2aelembytes(basic_elem_type);\n-      field_type = res_type->is_aryptr()->elem();\n-      if (res_type->is_flat()) {\n-        \/\/ Flat inline type array\n-        element_size = res_type->is_aryptr()->flat_elem_size();\n-      }\n@@ -908,20 +1003,4 @@\n-  \/\/ Scan object's fields adding an input to the safepoint for each field.\n-  for (int j = 0; j < nfields; j++) {\n-    intptr_t offset;\n-    ciField* field = nullptr;\n-    if (iklass != nullptr) {\n-      field = iklass->nonstatic_field_at(j);\n-      offset = field->offset_in_bytes();\n-      ciType* elem_type = field->type();\n-      basic_elem_type = field->layout_type();\n-      assert(!field->is_flat(), \"flat inline type fields should not have safepoint uses\");\n-\n-      ciField* flat_field = iklass->get_non_flat_field_by_offset(offset);\n-      if (flat_field != nullptr && flat_field->is_flat() && !flat_field->is_null_free()) {\n-        \/\/ TODO 8353432 Add support for nullable, flat fields in non-value class holders\n-        \/\/ Below code only iterates over the flat representation and therefore misses to\n-        \/\/ add null markers like we do in InlineTypeNode::add_fields_to_safepoint for value\n-        \/\/ class holders.\n-        _igvn._worklist.push(sfpt);\n-        return nullptr;\n-      }\n+  if (res == nullptr) {\n+    sfpt->jvms()->set_endoff(sfpt->req());\n+    return sobj;\n+  }\n@@ -929,17 +1008,9 @@\n-      \/\/ The next code is taken from Parse::do_get_xxx().\n-      if (is_reference_type(basic_elem_type)) {\n-        if (!elem_type->is_loaded()) {\n-          field_type = TypeInstPtr::BOTTOM;\n-        } else if (field != nullptr && field->is_static_constant()) {\n-          ciObject* con = field->constant_value().as_object();\n-          \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-          \/\/ and may yield a vacuous result if the field is of interface type.\n-          field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n-          assert(field_type != nullptr, \"field singleton type must be consistent\");\n-        } else {\n-          field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n-        }\n-        if (UseCompressedOops) {\n-          field_type = field_type->make_narrowoop();\n-          basic_elem_type = T_NARROWOOP;\n-        }\n+  bool success = true;\n+  if (iklass == nullptr) {\n+    for (int i = 0; i < nfields; i++) {\n+      const TypeAryPtr* res_array_type = res_type->is_aryptr();\n+      BasicType basic_elem_type = res_type->is_aryptr()->elem()->array_element_basic_type();\n+\n+      intptr_t elem_size;\n+      if (res_array_type->is_flat()) {\n+        elem_size = res_array_type->flat_elem_size();\n@@ -947,1 +1018,1 @@\n-        field_type = Type::get_const_basic_type(basic_elem_type);\n+        elem_size = type2aelembytes(basic_elem_type);\n@@ -949,13 +1020,1 @@\n-    } else {\n-      offset = array_base + j * (intptr_t)element_size;\n-    }\n-\n-    Node* field_val = nullptr;\n-    const TypeOopPtr* field_addr_type = res_type->add_offset(offset)->isa_oopptr();\n-    if (res_type->is_flat()) {\n-      ciInlineKlass* inline_klass = res_type->is_aryptr()->elem()->inline_klass();\n-      assert(inline_klass->maybe_flat_in_array(), \"must be flat in array\");\n-      field_val = inline_type_from_mem(sfpt->memory(), sfpt->control(), inline_klass, field_addr_type->isa_aryptr(), 0, alloc);\n-    } else {\n-      field_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, field_type, field_addr_type, alloc);\n-    }\n+      intptr_t elem_offset = arrayOopDesc::base_offset_in_bytes(basic_elem_type) + i * elem_size;\n@@ -963,6 +1022,9 @@\n-    \/\/ We weren't able to find a value for this field,\n-    \/\/ give up on eliminating this allocation.\n-    if (field_val == nullptr) {\n-      uint last = sfpt->req() - 1;\n-      for (int k = 0;  k < j; k++) {\n-        sfpt->del_req(last--);\n+      Node* field_val;\n+      if (res_array_type->is_flat()) {\n+        ciInlineKlass* elem_klass = res_array_type->elem()->inline_klass();\n+        assert(elem_klass->maybe_flat_in_array(), \"must be flat in array\");\n+        const TypeAryPtr* elem_adr_type = res_array_type->with_offset(elem_offset);\n+        field_val = inline_type_from_mem(sfpt->memory(), sfpt->control(), elem_klass, elem_adr_type, 0, res_array_type->is_null_free(), alloc);\n+      } else {\n+        const TypeAryPtr* field_addr_type = res_type->with_offset(elem_offset)->is_aryptr();\n+        field_val = value_from_mem(sfpt->memory(), sfpt->control(), basic_elem_type, res_array_type->elem(), field_addr_type, alloc);\n@@ -970,2 +1032,1 @@\n-      _igvn._worklist.push(sfpt);\n-\n+      if (field_val == nullptr) {\n@@ -973,11 +1034,3 @@\n-      if (PrintEliminateAllocations) {\n-        if (field != nullptr) {\n-          tty->print(\"=== At SafePoint node %d can't find value of field: \", sfpt->_idx);\n-          field->print();\n-          int field_idx = C->get_alias_index(field_addr_type);\n-          tty->print(\" (alias_idx=%d)\", field_idx);\n-        } else { \/\/ Array's element\n-          tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\", sfpt->_idx, j);\n-        }\n-        tty->print(\", which prevents elimination of: \");\n-        if (res == nullptr)\n+        if (PrintEliminateAllocations) {\n+          tty->print(\"=== At SafePoint node %d can't find value of array element [%d]\", sfpt->_idx, i);\n+          tty->print(\", which prevents elimination of: \");\n@@ -985,3 +1038,1 @@\n-        else\n-          res->dump();\n-      }\n+        }\n@@ -989,11 +1040,2 @@\n-\n-      return nullptr;\n-    }\n-\n-    if (UseCompressedOops && field_type->isa_narrowoop()) {\n-      \/\/ Enable \"DecodeN(EncodeP(Allocate)) --> Allocate\" transformation\n-      \/\/ to be able scalar replace the allocation.\n-      if (field_val->is_EncodeP()) {\n-        field_val = field_val->in(1);\n-      } else if (!field_val->is_InlineType()) {\n-        field_val = transform_later(new DecodeNNode(field_val, field_val->get_ptr_type()));\n+        success = false;\n+        break;\n@@ -1001,0 +1043,2 @@\n+\n+      process_field_value_at_safepoint(res_array_type->elem(), field_val, sfpt, value_worklist);\n@@ -1002,0 +1046,3 @@\n+  } else {\n+    success = add_inst_fields_to_safepoint(iklass, alloc, res, 0, sfpt, value_worklist);\n+  }\n@@ -1003,11 +1050,4 @@\n-    \/\/ Keep track of inline types to scalarize them later\n-    if (field_val->is_InlineType()) {\n-      value_worklist->push(field_val);\n-    } else if (field_val->is_Phi()) {\n-      PhiNode* phi = field_val->as_Phi();\n-      \/\/ Eagerly replace inline type phis now since we could be removing an inline type allocation where we must\n-      \/\/ scalarize all its fields in safepoints.\n-      field_val = phi->try_push_inline_types_down(&_igvn, true);\n-      if (field_val->is_InlineType()) {\n-        value_worklist->push(field_val);\n-      }\n+  \/\/ We weren't able to find a value for this field, remove all the fields added to the safepoint\n+  if (!success) {\n+    for (uint i = sfpt->req() - 1; i >= before_sfpt_req; i--) {\n+      sfpt->del_req(i);\n@@ -1015,1 +1055,2 @@\n-    sfpt->add_req(field_val);\n+    _igvn._worklist.push(sfpt);\n+    return nullptr;\n@@ -1019,1 +1060,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":163,"deletions":123,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+#include \"ci\/ciInstanceKlass.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/node.hpp\"\n@@ -95,0 +98,3 @@\n+\n+  void process_field_value_at_safepoint(const Type* field_type, Node* field_val, SafePointNode* sfpt, Unique_Node_List* value_worklist);\n+  bool add_inst_fields_to_safepoint(ciInstanceKlass* iklass, AllocateNode* alloc, Node* base, int offset_minus_header, SafePointNode* sfpt, Unique_Node_List* value_worklist);\n@@ -97,1 +103,1 @@\n-  Node* inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* adr_type, int offset, AllocateNode* alloc);\n+  Node* inline_type_from_mem(Node* mem, Node* ctl, ciInlineKlass* vk, const TypeAryPtr* elem_adr_type, int offset_in_element, bool null_free, AllocateNode* alloc);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3862,0 +3862,1 @@\n+        BasicType field_bt;\n@@ -3863,3 +3864,7 @@\n-        assert(field != nullptr, \"missing field\");\n-        BasicType bt = field->layout_type();\n-        _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(bt);\n+        if (field != nullptr) {\n+          field_bt = field->layout_type();\n+        } else {\n+          assert(field_offset.get() == vk->null_marker_offset_in_payload(), \"no field or null marker of %s at offset %d\", vk->name()->as_utf8(), foffset);\n+          field_bt = T_BOOLEAN;\n+        }\n+        _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(field_bt);\\\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1546,2 +1546,3 @@\n-\/\/ Restore fields of an eliminated instance object employing the same field order used by the compiler.\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, GrowableArray<int>* null_marker_offsets, TRAPS) {\n+\/\/ Restore fields of an eliminated instance object employing the same field order used by the\n+\/\/ compiler when it scalarizes an object at safepoints.\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, TRAPS) {\n@@ -1551,7 +1552,0 @@\n-  \/\/ Keep track of null marker offset for flat fields\n-  bool set_null_markers = false;\n-  if (null_marker_offsets == nullptr) {\n-    set_null_markers = true;\n-    null_marker_offsets = new GrowableArray<int>();\n-  }\n-\n@@ -1567,1 +1561,1 @@\n-      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, null_marker_offsets, CHECK_0);\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, CHECK_0);\n@@ -1569,0 +1563,2 @@\n+        ScopeValue* scope_field = sv->field_at(svIndex);\n+        StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n@@ -1570,1 +1566,2 @@\n-        null_marker_offsets->append(nm_offset);\n+        obj->bool_field_put(nm_offset, value->get_jint() & 1);\n+        svIndex++;\n@@ -1574,0 +1571,1 @@\n+\n@@ -1649,9 +1647,1 @@\n-  if (set_null_markers) {\n-    \/\/ The null marker values come after all the field values in the debug info\n-    assert(null_marker_offsets->length() == (sv->field_size() - svIndex), \"Missing null marker(s) in debug info\");\n-    for (int i = 0; i < null_marker_offsets->length(); ++i) {\n-      int offset = null_marker_offsets->at(i);\n-      jbyte is_init = (jbyte)StackValue::create_stack_value(fr, reg_map, sv->field_at(svIndex++))->get_jint();\n-      obj->byte_field_put(offset, is_init);\n-    }\n-  }\n+\n@@ -1671,1 +1661,1 @@\n-    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, nullptr, CHECK);\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, CHECK);\n@@ -1720,1 +1710,1 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, nullptr, CHECK);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-    \/\/ TODO 8353432\n-    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = IRNode.ALLOC)\n+    @IR(failOn = IRNode.ALLOC)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -171,2 +171,1 @@\n-    \/\/ TODO 8357061\n-    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n+    @IR(failOn = {ALLOC, STORE})\n@@ -220,2 +219,1 @@\n-    \/\/ TODO 8357061\n-    @IR(applyIf = {\"UseAtomicValueFlattening\", \"false\"}, failOn = {ALLOC, STORE})\n+    @IR(failOn = {ALLOC, STORE})\n@@ -531,2 +529,1 @@\n-    \/\/ TODO 8357061\n-    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"true\"},\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n@@ -534,1 +531,1 @@\n-    @IR(applyIfAnd = {\"UseAtomicValueFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"false\"},\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}