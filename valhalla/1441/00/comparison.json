{"files":[{"patch":"@@ -925,0 +925,1 @@\n+        _igvn._worklist.push(sfpt);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -141,0 +141,4 @@\n+          bool is_null_free = array_type->is_null_free() || !UseNullableValueFlattening;\n+          if (is_null_free) {\n+            inline_type = cast_not_null(inline_type);\n+          }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2287,1 +2287,1 @@\n-  fields[TypeFunc::Parms] = TypeInstPtr::NOTNULL;\n+  fields[TypeFunc::Parms] = TypeInstPtr::BOTTOM;\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2529,1 +2529,2 @@\n-    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+    \/\/ TODO 8355382 The optimization only applies to null-free, flat arrays\n+    @IR(applyIfAnd = {\"UseArrayFlattening\", \"true\", \"UseNullableValueFlattening\", \"false\"},\n@@ -2536,2 +2537,2 @@\n-              for (int k = 0; k < 2; k++) {\n-              }\n+                for (int k = 0; k < 2; k++) {\n+                }\n@@ -2540,1 +2541,0 @@\n-\n@@ -2564,2 +2564,1 @@\n-        Object v = (NonValueClass)array[0];\n-        return v;\n+        return (NonValueClass)array[0];\n@@ -2598,1 +2597,2 @@\n-    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+    \/\/ TODO 8355382 The optimization only applies to null-free, flat arrays\n+    @IR(applyIfAnd = {\"UseArrayFlattening\", \"true\", \"UseNullableValueFlattening\", \"false\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3296,0 +3296,44 @@\n+\n+    static Object oFld = null;\n+\n+    static value class MyValue126  {\n+        int x;\n+\n+        MyValue126(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    \/\/ Test that result of access to unknown flat array is not marked as null-free\n+    @Test\n+    public void test126(Object[] array, int i) {\n+        oFld = array[i];\n+    }\n+\n+    @Run(test = \"test126\")\n+    @Warmup(0)\n+    public void test126_verifier() {\n+        MyValue126[] array = (MyValue126[]) ValueClass.newNullableAtomicArray(MyValue126.class, 2);\n+        array[1] = new MyValue126(rI);\n+        test126(array, 1);\n+        Asserts.assertEquals(oFld, new MyValue126(rI));\n+        test126(array, 0);\n+        Asserts.assertEquals(oFld, null);\n+    }\n+\n+    \/\/ Same as test126 but different failure mode\n+    @Test\n+    public void test127(Object[] array, int i) {\n+        oFld = (MyValue126)array[i];\n+    }\n+\n+    @Run(test = \"test127\")\n+    @Warmup(0)\n+    public void test127_verifier() {\n+        MyValue126[] array = (MyValue126[]) ValueClass.newNullableAtomicArray(MyValue126.class, 2);\n+        array[1] = new MyValue126(rI);\n+        test127(array, 1);\n+        Asserts.assertEquals(oFld, new MyValue126(rI));\n+        test127(array, 0);\n+        Asserts.assertEquals(oFld, null);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"}]}