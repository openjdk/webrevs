{"files":[{"patch":"@@ -152,1 +152,0 @@\n-  JVM_EXCLUDE_PATTERNS += gc\/x\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1029,4 +1029,1 @@\n-    if (!(UseZGC && !ZGenerational)) {\n-      \/\/ Load barrier has not yet been applied, so ZGC can't verify the oop here\n-      __ verify_oop(dest->as_register());\n-    }\n+    __ verify_oop(dest->as_register());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-  \/\/ Check if the entry lists are empty.\n+  \/\/ Check if the entry lists are empty (EntryList first - by convention).\n@@ -569,1 +569,1 @@\n-    \/\/ Check if the entry lists are empty.\n+    \/\/ Check if the entry lists are empty (EntryList first - by convention).\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-define_pd_global(uintx, CodeCacheSegmentSize,    64 COMPILER1_AND_COMPILER2_PRESENT(+64)); \/\/ Tiered compilation has large code-entry alignment.\n+define_pd_global(uintx, CodeCacheSegmentSize,    64);\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,3 +218,2 @@\n-  {\n-    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0);\n-    \/\/ Trigger dtrace event for fastpath\n+  if (DTraceMethodProbes) {\n+      \/\/ Trigger dtrace event for fastpath\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4942,17 +4942,0 @@\n-SkipIfEqual::SkipIfEqual(\n-    MacroAssembler* masm, const bool* flag_addr, bool value) {\n-  _masm = masm;\n-  uint64_t offset;\n-  _masm->adrp(rscratch1, ExternalAddress((address)flag_addr), offset);\n-  _masm->ldrb(rscratch1, Address(rscratch1, offset));\n-  if (value) {\n-    _masm->cbnzw(rscratch1, _label);\n-  } else {\n-    _masm->cbzw(rscratch1, _label);\n-  }\n-}\n-\n-SkipIfEqual::~SkipIfEqual() {\n-  _masm->bind(_label);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1738,18 +1738,0 @@\n-\/**\n- * class SkipIfEqual:\n- *\n- * Instantiating this class will result in assembly code being output that will\n- * jump around any code emitted between the creation of the instance and it's\n- * automatic destruction at the end of a scope block, depending on the value of\n- * the flag passed to the constructor, which will be checked at run-time.\n- *\/\n-class SkipIfEqual {\n- private:\n-  MacroAssembler* _masm;\n-  Label _label;\n-\n- public:\n-   SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);\n-   ~SkipIfEqual();\n-};\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1393,1 +1393,3 @@\n-      if (shift)  __ lsr(r15, r15, shift);\n+      if (shift > 0) {\n+        __ lsr(r15, r15, shift);\n+      }\n@@ -1421,3 +1423,9 @@\n-    \/\/ We have a count of units and some trailing bytes.  Adjust the\n-    \/\/ count and do a bulk copy of words.\n-    __ lsr(r15, count, exact_log2(wordSize\/granularity));\n+    \/\/ We have a count of units and some trailing bytes. Adjust the\n+    \/\/ count and do a bulk copy of words. If the shift is zero\n+    \/\/ perform a move instead to benefit from zero latency moves.\n+    int shift = exact_log2(wordSize\/granularity);\n+    if (shift > 0) {\n+      __ lsr(r15, count, shift);\n+    } else {\n+      __ mov(r15, count);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,3 +136,14 @@\n-  { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n-    int monitor_offset = BytesPerWord * method()->max_locals() +\n-      (2 * BytesPerWord) * (number_of_locks - 1);\n+  {\n+    assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n+\n+    const int locals_space = BytesPerWord * method()->max_locals();\n+    int monitor_offset = locals_space + (2 * BytesPerWord) * (number_of_locks - 1);\n+    bool use_OSR_bias = false;\n+\n+    if (!Assembler::is_simm16(monitor_offset + BytesPerWord) && number_of_locks > 0) {\n+      \/\/ Offsets too large for ld instructions. Use bias.\n+      __ add_const_optimized(OSR_buf, OSR_buf, locals_space);\n+      monitor_offset -= locals_space;\n+      use_OSR_bias = true;\n+    }\n+\n@@ -160,1 +171,1 @@\n-      __ std(R0, ml.disp(), ml.base());\n+      __ std(R0, ml);\n@@ -162,1 +173,6 @@\n-      __ std(R0, mo.disp(), mo.base());\n+      __ std(R0, mo);\n+    }\n+\n+    if (use_OSR_bias) {\n+      \/\/ Restore.\n+      __ sub_const_optimized(OSR_buf, OSR_buf, locals_space);\n@@ -588,1 +604,1 @@\n-        __ std(R0, addr.disp(), addr.base());\n+        __ std(R0, addr);\n@@ -612,1 +628,1 @@\n-        __ std(R0, addr.disp(), addr.base());\n+        __ std(R0, addr);\n@@ -880,1 +896,1 @@\n-      __ stw(src_reg, addr.disp(), addr.base());\n+      __ stw(src_reg, addr);\n@@ -887,1 +903,1 @@\n-      __ std(src_reg, addr.disp(), addr.base());\n+      __ std(src_reg, addr);\n@@ -893,1 +909,1 @@\n-      __ std(src_reg, addr.disp(), addr.base());\n+      __ std(src_reg, addr);\n@@ -901,1 +917,1 @@\n-      __ std(src_reg, addr.disp(), addr.base());\n+      __ std(src_reg, addr);\n@@ -1077,2 +1093,2 @@\n-      __ lwz(tmp, from.disp(), from.base());\n-      __ stw(tmp, to.disp(), to.base());\n+      __ lwz(tmp, from);\n+      __ stw(tmp, to);\n@@ -1085,2 +1101,2 @@\n-      __ ld(tmp, from.disp(), from.base());\n-      __ std(tmp, to.disp(), to.base());\n+      __ ld(tmp, from);\n+      __ std(tmp, to);\n@@ -1093,2 +1109,2 @@\n-      __ ld(tmp, from.disp(), from.base());\n-      __ std(tmp, to.disp(), to.base());\n+      __ ld(tmp, from);\n+      __ std(tmp, to);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":33,"deletions":17,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -134,3 +134,13 @@\n-  { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n-    int monitor_offset = BytesPerWord * method()->max_locals() +\n-      (2 * BytesPerWord) * (number_of_locks - 1);\n+  {\n+    assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n+\n+    const int locals_space = BytesPerWord * method() -> max_locals();\n+    int monitor_offset = locals_space + (2 * BytesPerWord) * (number_of_locks - 1);\n+    bool large_offset = !Immediate::is_simm20(monitor_offset + BytesPerWord) && number_of_locks > 0;\n+\n+    if (large_offset) {\n+      \/\/ z_lg can only handle displacement upto 20bit signed binary integer\n+      __ z_algfi(OSR_buf, locals_space);\n+      monitor_offset -= locals_space;\n+    }\n+\n@@ -150,0 +160,4 @@\n+\n+    if (large_offset) {\n+      __ z_slgfi(OSR_buf, locals_space);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2134,12 +2134,0 @@\n-\n-#if 0\n-  \/\/ Dtrace currently not supported on z\/Architecture.\n-  {\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n-    push(state);\n-    get_method(c_rarg1);\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),\n-                 r15_thread, c_rarg1);\n-    pop(state);\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1373,4 +1373,1 @@\n-    if (!(UseZGC && !ZGenerational)) {\n-      \/\/ Load barrier has not yet been applied, so ZGC can't verify the oop here\n-      __ verify_oop(dest->as_register());\n-    }\n+    __ verify_oop(dest->as_register());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -509,3 +509,3 @@\n-  \/\/ Check if the entry lists are empty.\n-  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+  \/\/ Check if the entry lists are empty (EntryList first - by convention).\n+  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n@@ -838,3 +838,3 @@\n-    \/\/ Check if the entry lists are empty.\n-    movptr(reg_rax, cxq_address);\n-    orptr(reg_rax, EntryList_address);\n+    \/\/ Check if the entry lists are empty (EntryList first - by convention).\n+    movptr(reg_rax, EntryList_address);\n+    orptr(reg_rax, cxq_address);\n@@ -869,0 +869,1 @@\n+  Label zf_bad_zero;\n@@ -870,1 +871,1 @@\n-  stop(\"Fast Unlock ZF != 1\");\n+  jmp(zf_bad_zero);\n@@ -879,1 +880,1 @@\n-  jccb(Assembler::notZero, zf_correct);\n+  jcc(Assembler::notZero, zf_correct);\n@@ -881,0 +882,2 @@\n+  bind(zf_bad_zero);\n+  stop(\"Fast Unlock ZF != 1\");\n@@ -968,0 +971,66 @@\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, Address src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vpuminmaxq(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  \/\/ T1 = -1\n+  vpcmpeqq(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  \/\/ T1 = -1 << 63\n+  vpsllq(xtmp1, xtmp1, 63, vlen_enc);\n+  \/\/ Convert SRC2 to signed value i.e. T2 = T1 + SRC2\n+  vpaddq(xtmp2, xtmp1, src2, vlen_enc);\n+  \/\/ Convert SRC1 to signed value i.e. T1 = T1 + SRC1\n+  vpaddq(xtmp1, xtmp1, src1, vlen_enc);\n+  \/\/ Mask = T2 > T1\n+  vpcmpgtq(xtmp1, xtmp2, xtmp1, vlen_enc);\n+  if (opcode == Op_UMaxV) {\n+    \/\/ Res = Mask ? Src2 : Src1\n+    vpblendvb(dst, src1, src2, xtmp1, vlen_enc);\n+  } else {\n+    \/\/ Res = Mask ? Src1 : Src2\n+    vpblendvb(dst, src2, src1, xtmp1, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpuminmax(int opcode, BasicType elem_bt, XMMRegister dst,\n+                                  XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  assert(opcode == Op_UMinV || opcode == Op_UMaxV, \"sanity\");\n+  if (opcode == Op_UMinV) {\n+    switch(elem_bt) {\n+      case T_BYTE:  vpminub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpminuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpminud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpminuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  } else {\n+    assert(opcode == Op_UMaxV, \"required\");\n+    switch(elem_bt) {\n+      case T_BYTE:  vpmaxub(dst, src1, src2, vlen_enc); break;\n+      case T_SHORT: vpmaxuw(dst, src1, src2, vlen_enc); break;\n+      case T_INT:   vpmaxud(dst, src1, src2, vlen_enc); break;\n+      case T_LONG:  evpmaxuq(dst, k0, src1, src2, false, vlen_enc); break;\n+      default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+    }\n+  }\n+}\n+\n@@ -2391,0 +2460,4 @@\n+void C2_MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  MacroAssembler::evmovdqu(type, kmask, dst, src, merge, vector_len);\n+}\n+\n@@ -2689,1 +2762,0 @@\n-  assert(UseAVX >= 2, \"required\");\n@@ -4663,1 +4735,120 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               XMMRegister src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                      XMMRegister src1, XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                        XMMRegister src1, XMMRegister src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                               Address src2, bool is_unsigned, bool merge, int vlen_enc) {\n+  if (is_unsigned) {\n+    evmasked_saturating_unsigned_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  } else {\n+    evmasked_saturating_signed_op(ideal_opc, elem_bt, mask, dst, src1, src2, merge, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                      XMMRegister src1, Address src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddsw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubsw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst,\n+                                                        XMMRegister src1, Address src2, bool merge, int vlen_enc) {\n+  switch (elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusb(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusb(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        evpaddusw(dst, mask, src1, src2, merge, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        evpsubusw(dst, mask, src1, src2, merge, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n@@ -4753,0 +4944,4 @@\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4760,1 +4955,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -4813,0 +5009,4 @@\n+    case Op_UMaxV:\n+      evpmaxu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n+    case Op_UMinV:\n+      evpminu(eType, dst, mask, src1, src2, merge, vlen_enc); break;\n@@ -4820,1 +5020,2 @@\n-      fatal(\"Unsupported masked operation\"); break;\n+      fatal(\"Unsupported operation  %s\", NodeClassNames[ideal_opc]);\n+      break;\n@@ -6508,0 +6709,363 @@\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_sub_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                              XMMRegister src2, KRegister ktmp, int vlen_enc) {\n+  \/\/ For unsigned subtraction, overflow happens when magnitude of second input is greater than first input.\n+  \/\/ overflow_mask = Inp1 <u Inp2\n+  evpcmpu(elem_bt, ktmp,  src2, src1, Assembler::lt, vlen_enc);\n+  \/\/ Res = overflow_mask ? Zero : INP1 - INP2 (non-commutative and non-associative)\n+  evmasked_op(elem_bt == T_INT ? Op_SubVI : Op_SubVL, elem_bt, ktmp, dst, src1, src2, false, vlen_enc, false);\n+}\n+\n+void C2_MacroAssembler::vector_sub_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                              XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc) {\n+  \/\/ Emulate unsigned comparison using signed comparison\n+  \/\/ Mask = Inp1 <u Inp2 => Inp1 + MIN_VALUE < Inp2 + MIN_VALUE\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc, true);\n+  vpadd(elem_bt, xtmp2, src1, xtmp1, vlen_enc);\n+  vpadd(elem_bt, xtmp1, src2, xtmp1, vlen_enc);\n+\n+  vpcmpgt(elem_bt, xtmp2, xtmp1, xtmp2, vlen_enc);\n+\n+  \/\/ Res = INP1 - INP2 (non-commutative and non-associative)\n+  vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ Res = Mask ? Zero : Res\n+  vpxor(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpblendvb(dst, dst, xtmp1, xtmp2, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::vector_add_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                               XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp, int vlen_enc) {\n+  \/\/ Unsigned values ranges comprise of only +ve numbers, thus there exist only an upper bound saturation.\n+  \/\/ overflow_mask = (SRC1 + SRC2) <u (SRC1 | SRC2)\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ T1 = SRC1 | SRC2\n+  vpor(xtmp1, src1, src2, vlen_enc);\n+  \/\/ Max_Unsigned = -1\n+  vpternlogd(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+  \/\/ Unsigned compare:  Mask = Res <u T1\n+  evpcmpu(elem_bt, ktmp, dst, xtmp1, Assembler::lt, vlen_enc);\n+  \/\/ res  = Mask ? Max_Unsigned : Res\n+  evpblend(elem_bt, dst, ktmp,  dst, xtmp2, true, vlen_enc);\n+}\n+\n+\/\/\n+\/\/ Section 2-13 Hacker's Delight list following overflow detection check for saturating\n+\/\/ unsigned addition operation.\n+\/\/    overflow_mask = ((a & b) | ((a | b) & ~( a + b))) >>> 31 == 1\n+\/\/\n+\/\/ We empirically determined its semantic equivalence to following reduced expression\n+\/\/    overflow_mask =  (a + b) <u (a | b)\n+\/\/\n+\/\/ and also verified it though Alive2 solver.\n+\/\/ (https:\/\/alive2.llvm.org\/ce\/z\/XDQ7dY)\n+\/\/\n+\n+void C2_MacroAssembler::vector_add_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                                              XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, int vlen_enc) {\n+  \/\/ Res = Signed Add INP1, INP2\n+  vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+  \/\/ Compute T1 = INP1 | INP2\n+  vpor(xtmp3, src1, src2, vlen_enc);\n+  \/\/ T1 = Minimum signed value.\n+  vpgenmin_value(elem_bt, xtmp2, xtmp1, vlen_enc, true);\n+  \/\/ Convert T1 to signed value, T1 = T1 + MIN_VALUE\n+  vpadd(elem_bt, xtmp3, xtmp3, xtmp2, vlen_enc);\n+  \/\/ Convert Res to signed value, Res<s> = Res + MIN_VALUE\n+  vpadd(elem_bt, xtmp2, xtmp2, dst, vlen_enc);\n+  \/\/ Compute overflow detection mask = Res<1> <s T1\n+  if (elem_bt == T_INT) {\n+    vpcmpgtd(xtmp3, xtmp3, xtmp2, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_LONG, \"\");\n+    vpcmpgtq(xtmp3, xtmp3, xtmp2, vlen_enc);\n+  }\n+  vpblendvb(dst, dst, xtmp1, xtmp3, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovq2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogq(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    evpsraq(xtmp1, src, 63, vlen_enc);\n+    evpcmpeqq(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                      int vlen_enc, bool xtmp2_hold_M1) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evpmovd2m(ktmp, src, vlen_enc);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    if (!xtmp2_hold_M1) {\n+      vpternlogd(xtmp2, 0xff, xtmp2, xtmp2, vlen_enc);\n+    }\n+    vpsrad(xtmp1, src, 31, vlen_enc);\n+    Assembler::evpcmpeqd(ktmp, k0, xtmp1, xtmp2, vlen_enc);\n+  }\n+}\n+\n+\n+void C2_MacroAssembler::vpsign_extend_dq(BasicType elem_bt, XMMRegister dst, XMMRegister src, int vlen_enc) {\n+  if (elem_bt == T_LONG) {\n+    if (VM_Version::supports_evex()) {\n+      evpsraq(dst, src, 63, vlen_enc);\n+    } else {\n+      vpsrad(dst, src, 31, vlen_enc);\n+      vpshufd(dst, dst, 0xF5, vlen_enc);\n+    }\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpsrad(dst, src, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmax_value(BasicType elem_bt, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (elem_bt == T_LONG) {\n+    vpsrlq(dst, allones, 1, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpsrld(dst, allones, 1, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpgenmin_value(BasicType elem_bt, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones) {\n+  if (compute_allones) {\n+    if (vlen_enc == Assembler::AVX_512bit) {\n+      vpternlogd(allones, 0xff, allones, allones, vlen_enc);\n+    } else {\n+      vpcmpeqq(allones, allones, allones, vlen_enc);\n+    }\n+  }\n+  if (elem_bt == T_LONG) {\n+    vpsllq(dst, allones, 63, vlen_enc);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    vpslld(dst, allones, 31, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::evpcmpu(BasicType elem_bt, KRegister kmask,  XMMRegister src1, XMMRegister src2,\n+                                Assembler::ComparisonPredicate cond, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_LONG:  evpcmpuq(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_INT:   evpcmpud(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_SHORT: evpcmpuw(kmask, src1, src2, cond, vlen_enc); break;\n+    case T_BYTE:  evpcmpub(kmask, src1, src2, cond, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpgt(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case  T_LONG:  vpcmpgtq(dst, src1, src2, vlen_enc); break;\n+    case  T_INT:   vpcmpgtd(dst, src1, src2, vlen_enc); break;\n+    case  T_SHORT: vpcmpgtw(dst, src1, src2, vlen_enc); break;\n+    case  T_BYTE:  vpcmpgtb(dst, src1, src2, vlen_enc); break;\n+    default: fatal(\"Unsupported type %s\", type2name(elem_bt)); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evpmov_vec_to_mask(BasicType elem_bt, KRegister ktmp, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1) {\n+  if (elem_bt == T_LONG) {\n+    evpmovq2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  } else {\n+    assert(elem_bt == T_INT, \"\");\n+    evpmovd2m_emu(ktmp, src, xtmp1, xtmp2, vlen_enc, xtmp2_hold_M1);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_addsub_dq_saturating_evex(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                         XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                         KRegister ktmp1, KRegister ktmp2, int vlen_enc) {\n+  assert(elem_bt == T_INT || elem_bt == T_LONG, \"\");\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (ideal_opc == Op_SaturatingAddV) {\n+    \/\/ res = src1 + src2\n+    vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(ideal_opc == Op_SaturatingSubV, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Compute overflow detection mask.\n+  evpmov_vec_to_mask(elem_bt, ktmp1, xtmp2, xtmp2, xtmp1, vlen_enc);\n+  \/\/ Note: xtmp1 hold -1 in all its lanes after above call.\n+\n+  \/\/ Compute mask based on first input polarity.\n+  evpmov_vec_to_mask(elem_bt, ktmp2, src1, xtmp2, xtmp1, vlen_enc, true);\n+\n+  vpgenmax_value(elem_bt, xtmp2, xtmp1, vlen_enc, true);\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose a vector of saturating (MAX\/MIN) values, where lanes corresponding to\n+  \/\/ set bits in first input polarity mask holds a min value.\n+  evpblend(elem_bt, xtmp2, ktmp2, xtmp2, xtmp1, true, vlen_enc);\n+  \/\/ Blend destination lanes with saturated values using overflow detection mask.\n+  evpblend(elem_bt, dst, ktmp1, dst, xtmp2, true, vlen_enc);\n+}\n+\n+\n+void C2_MacroAssembler::vector_addsub_dq_saturating_avx(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                        XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                        XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc) {\n+  assert(elem_bt == T_INT || elem_bt == T_LONG, \"\");\n+  \/\/ Addition\/Subtraction happens over two's compliment representation of numbers and is agnostic to signed'ness.\n+  \/\/ Overflow detection based on Hacker's delight section 2-13.\n+  if (ideal_opc == Op_SaturatingAddV) {\n+    \/\/ res = src1 + src2\n+    vpadd(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs if result polarity does not comply with equivalent polarity inputs.\n+    \/\/ overflow = (((res ^ src1) & (res ^ src2)) >>> 31(I)\/63(L)) == 1\n+    vpxor(xtmp1, dst, src1, vlen_enc);\n+    vpxor(xtmp2, dst, src2, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  } else {\n+    assert(ideal_opc == Op_SaturatingSubV, \"\");\n+    \/\/ res = src1 - src2\n+    vpsub(elem_bt, dst, src1, src2, vlen_enc);\n+    \/\/ Overflow occurs when both inputs have opposite polarity and\n+    \/\/ result polarity does not comply with first input polarity.\n+    \/\/ overflow = ((src1 ^ src2) & (res ^ src1) >>> 31(I)\/63(L)) == 1;\n+    vpxor(xtmp1, src1, src2, vlen_enc);\n+    vpxor(xtmp2, dst, src1, vlen_enc);\n+    vpand(xtmp2, xtmp1, xtmp2, vlen_enc);\n+  }\n+\n+  \/\/ Sign-extend to compute overflow detection mask.\n+  vpsign_extend_dq(elem_bt, xtmp3, xtmp2, vlen_enc);\n+\n+  vpcmpeqd(xtmp1, xtmp1, xtmp1, vlen_enc);\n+  vpgenmax_value(elem_bt, xtmp2, xtmp1, vlen_enc);\n+  vpgenmin_value(elem_bt, xtmp1, xtmp1, vlen_enc);\n+\n+  \/\/ Compose saturating min\/max vector using first input polarity mask.\n+  vpsign_extend_dq(elem_bt, xtmp4, src1, vlen_enc);\n+  vpblendvb(xtmp1, xtmp2, xtmp1, xtmp4, vlen_enc);\n+\n+  \/\/ Blend result with saturating vector using overflow detection mask.\n+  vpblendvb(dst, dst, xtmp1, xtmp3, vlen_enc);\n+}\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddsw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubsw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusb(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusb(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    case T_SHORT:\n+      if (ideal_opc == Op_SaturatingAddV) {\n+        vpaddusw(dst, src1, src2, vlen_enc);\n+      } else {\n+        assert(ideal_opc == Op_SaturatingSubV, \"\");\n+        vpsubusw(dst, src1, src2, vlen_enc);\n+      }\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n+\n@@ -6534,0 +7098,16 @@\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    vector_saturating_unsigned_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  } else {\n+    vector_saturating_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_saturating_op(int ideal_opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc) {\n+  if (is_unsigned) {\n+    vector_saturating_unsigned_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  } else {\n+    vector_saturating_op(ideal_opc, elem_bt, dst, src1, src2, vlen_enc);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":592,"deletions":12,"binary":false,"changes":604,"status":"modified"},{"patch":"@@ -60,0 +60,8 @@\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                int vlen_enc);\n+\n+  void vpuminmax(int opcode, BasicType elem_bt,\n+                XMMRegister dst, XMMRegister src1, Address src2,\n+                int vlen_enc);\n+\n@@ -64,0 +72,3 @@\n+\n+  void vpuminmaxq(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n@@ -109,0 +120,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -509,0 +521,64 @@\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, bool is_unsigned, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, bool is_unsigned, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void vector_saturating_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void vector_saturating_unsigned_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void vector_saturating_unsigned_op(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, Address src2, int vlen_enc);\n+\n+  void vector_sub_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, KRegister ktmp, int vlen_enc);\n+\n+  void vector_sub_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                             XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc);\n+\n+  void vector_add_dq_saturating_unsigned_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                              XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp, int vlen_enc);\n+\n+  void vector_add_dq_saturating_unsigned_avx(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                             XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, int vlen_enc);\n+\n+  void vector_addsub_dq_saturating_avx(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, int vlen_enc);\n+\n+  void vector_addsub_dq_saturating_evex(int opc, BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                                        XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, int vlen_enc);\n+\n+  void evpmovd2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evpmovq2m_emu(KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void vpsign_extend_dq(BasicType etype, XMMRegister dst, XMMRegister src, int vlen_enc);\n+\n+  void vpgenmin_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void vpgenmax_value(BasicType etype, XMMRegister dst, XMMRegister allones, int vlen_enc, bool compute_allones = false);\n+\n+  void evpcmpu(BasicType etype, KRegister kmask,  XMMRegister src1, XMMRegister src2, Assembler::ComparisonPredicate cond, int vlen_enc);\n+\n+  void vpcmpgt(BasicType etype, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n+  void evpmov_vec_to_mask(BasicType etype, KRegister ktmp, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                          int vlen_enc, bool xtmp2_hold_M1 = false);\n+\n+  void evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool is_unsigned, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, XMMRegister src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_signed_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1, Address src2,\n+                              bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       XMMRegister src2, bool merge, int vlen_enc);\n+\n+  void evmasked_saturating_unsigned_op(int ideal_opc, BasicType elem_bt, KRegister mask, XMMRegister dst, XMMRegister src1,\n+                                       Address src2, bool merge, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1191,2 +1191,1 @@\n-  {\n-    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0, rscratch1);\n+  if (DTraceMethodProbes) {\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -10097,0 +10097,24 @@\n+void MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evmovdqub(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evmovdquw(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evmovdqul(dst, kmask, src, merge, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evmovdquq(dst, kmask, src, merge, vector_len);\n+      break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type));\n+      break;\n+  }\n+}\n+\n@@ -10288,0 +10312,60 @@\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpminub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpminuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpminud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpminuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n+void MacroAssembler::evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+    case T_BYTE:\n+      evpmaxub(dst, mask, nds, src, merge, vector_len); break;\n+    case T_SHORT:\n+      evpmaxuw(dst, mask, nds, src, merge, vector_len); break;\n+    case T_INT:\n+      evpmaxud(dst, mask, nds, src, merge, vector_len); break;\n+    case T_LONG:\n+      evpmaxuq(dst, mask, nds, src, merge, vector_len); break;\n+    default:\n+      fatal(\"Unexpected type argument %s\", type2name(type)); break;\n+  }\n+}\n+\n@@ -10996,11 +11080,0 @@\n-SkipIfEqual::SkipIfEqual(\n-    MacroAssembler* masm, const bool* flag_addr, bool value, Register rscratch) {\n-  _masm = masm;\n-  _masm->cmp8(ExternalAddress((address)flag_addr), value, rscratch);\n-  _masm->jcc(Assembler::equal, _label);\n-}\n-\n-SkipIfEqual::~SkipIfEqual() {\n-  _masm->bind(_label);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":84,"deletions":11,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -1348,0 +1348,1 @@\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, XMMRegister src, bool merge, int vector_len);\n@@ -1361,0 +1362,1 @@\n+  void evmovdquw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquw(dst, src, vector_len); }\n@@ -1571,0 +1573,2 @@\n+  void vpmuldq(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vpmuldq(dst, nds, src, vector_len); }\n+\n@@ -1580,0 +1584,3 @@\n+  void evpsrad(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);\n+  void evpsrad(XMMRegister dst, XMMRegister nds, int         shift, int vector_len);\n+\n@@ -1583,0 +1590,1 @@\n+  using Assembler::evpsllw;\n@@ -1627,0 +1635,1 @@\n+  using Assembler::evpsraw;\n@@ -1634,0 +1643,1 @@\n+  using Assembler::evpsrad;\n@@ -1655,0 +1665,5 @@\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, XMMRegister src, bool merge, int vector_len);\n+  void evpminu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+  void evpmaxu(BasicType type, XMMRegister dst, KRegister mask, XMMRegister nds, Address src, bool merge, int vector_len);\n+\n@@ -2243,18 +2258,0 @@\n-\/**\n- * class SkipIfEqual:\n- *\n- * Instantiating this class will result in assembly code being output that will\n- * jump around any code emitted between the creation of the instance and it's\n- * automatic destruction at the end of a scope block, depending on the value of\n- * the flag passed to the constructor, which will be checked at run-time.\n- *\/\n-class SkipIfEqual {\n- private:\n-  MacroAssembler* _masm;\n-  Label _label;\n-\n- public:\n-   SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value, Register rscratch);\n-   ~SkipIfEqual();\n-};\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -4205,0 +4205,2 @@\n+  generate_sha3_stubs();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -500,0 +500,4 @@\n+  \/\/ SHA3 stubs\n+  void generate_sha3_stubs();\n+  address generate_sha3_implCompress(bool multiBlock, const char *name);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1319,3 +1319,10 @@\n-  if (UseSHA3Intrinsics) {\n-    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n+#ifdef _LP64\n+  if (supports_evex() && supports_avx512bw()) {\n+      if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+          UseSHA3Intrinsics = true;\n+      }\n+  } else\n+#endif\n+   if (UseSHA3Intrinsics) {\n+      warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n+      FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1768,0 +1768,6 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n+      if (UseAVX == 0) {\n+        return false;\n+      }\n+      break;\n@@ -1938,0 +1944,9 @@\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (UseAVX < 1) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      if (is_subword_type(bt) && size_in_bits == 512 && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n@@ -2128,0 +2143,2 @@\n+    case Op_UMinV:\n+    case Op_UMaxV:\n@@ -2135,0 +2152,9 @@\n+    case Op_SaturatingAddV:\n+    case Op_SaturatingSubV:\n+      if (!is_subword_type(bt)) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 || !VM_Version::supports_avx512bw()) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      return true;\n@@ -6528,0 +6554,74 @@\n+\/\/ ------------------------------ Unsigned vector Min\/Max ----------------------\n+\n+instruct vector_uminmax_reg(vec dst, vec a, vec b) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_LONG);\n+  match(Set dst (UMinV a b));\n+  match(Set dst (UMaxV a b));\n+  format %{ \"vector_uminmax $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_mem(vec dst, vec a, memory b) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_element_basic_type(n) != T_LONG);\n+  match(Set dst (UMinV a (LoadVector b)));\n+  match(Set dst (UMaxV a (LoadVector b)));\n+  format %{ \"vector_uminmax $dst,$a,$b\\t!\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(elem_bt), \"\");\n+    __ vpuminmax(opcode, elem_bt, $dst$$XMMRegister, $a$$XMMRegister, $b$$Address, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmaxq_reg(vec dst, vec a, vec b, vec xtmp1, vec xtmp2) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (UMinV a b));\n+  match(Set dst (UMaxV a b));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_uminmaxq $dst,$a,$b\\t! using xtmp1 and xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpuminmaxq(opcode, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_reg_masked(vec dst, vec src1, vec src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 src2) mask));\n+  match(Set dst (UMaxV (Binary src1 src2) mask));\n+  format %{ \"vector_uminmax_masked $dst, $src1, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_uminmax_mem_masked(vec dst, vec src1, memory src2, kReg mask) %{\n+  match(Set dst (UMinV (Binary src1 (LoadVector src2)) mask));\n+  match(Set dst (UMaxV (Binary src1 (LoadVector src2)) mask));\n+  format %{ \"vector_uminmax_masked $dst, $dst, $src2, $mask\\t! umin\/max masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $src1$$XMMRegister, $src2$$Address, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -10520,0 +10620,230 @@\n+instruct vector_addsub_saturating_subword_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  format %{ \"vector_addsub_saturating_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$XMMRegister, false, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_addsub_saturating_unsigned_subword_reg(vec dst, vec src1, vec src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  format %{ \"vector_addsub_saturating_unsigned_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_addsub_saturating_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2);\n+  format %{ \"vector_addsub_saturating_evex $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_addsub_dq_saturating_evex(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                                        $src1$$XMMRegister, $src2$$XMMRegister,\n+                                        $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                                        $ktmp1$$KRegister, $ktmp2$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_addsub_saturating_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4);\n+  format %{ \"vector_addsub_saturating_avx $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_addsub_dq_saturating_avx(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister, $src1$$XMMRegister,\n+                                       $src2$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                                       $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_add_saturating_unsigned_reg_evex(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, kReg ktmp)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingAddV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp);\n+  format %{ \"vector_add_saturating_unsigned_evex $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2 and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_add_dq_saturating_unsigned_evex(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                              $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_add_saturating_unsigned_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2, vec xtmp3)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingAddV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3);\n+  format %{ \"vector_add_saturating_unsigned_avx $dst, $src1, $src2 \\t! using $xtmp1, $xtmp2 and $xtmp3 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_add_dq_saturating_unsigned_avx(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sub_saturating_unsigned_reg_evex(vec dst, vec src1, vec src2, kReg ktmp)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            (Matcher::vector_length_in_bytes(n) == 64 || VM_Version::supports_avx512vl()));\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP ktmp);\n+  format %{ \"vector_sub_saturating_unsigned_evex $dst, $src1, $src2 \\t! using $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_sub_dq_saturating_unsigned_evex(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister,\n+                                              $src2$$XMMRegister, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_sub_saturating_unsigned_reg_avx(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2)\n+%{\n+  predicate(!is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned() &&\n+            Matcher::vector_length_in_bytes(n) <= 32 && !VM_Version::supports_avx512vl());\n+  match(Set dst (SaturatingSubV src1 src2));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_sub_saturating_unsigned_avx $dst, $src1, $src2 \\t! using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_sub_dq_saturating_unsigned_avx(elem_bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister,\n+                                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_addsub_saturating_subword_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubV src1 (LoadVector src2)));\n+  format %{ \"vector_addsub_saturating_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$Address, false, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_addsub_saturating_unsigned_subword_mem(vec dst, vec src1, memory src2)\n+%{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV src1 (LoadVector src2)));\n+  match(Set dst (SaturatingSubV src1 (LoadVector src2)));\n+  format %{ \"vector_addsub_saturating_unsigned_subword $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_saturating_op(this->ideal_Opcode(), elem_bt, $dst$$XMMRegister,\n+                            $src1$$XMMRegister, $src2$$Address, true, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vector_addsub_saturating_subword_masked_reg(vec dst, vec src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst src) mask));\n+  match(Set dst (SaturatingSubV (Binary dst src) mask));\n+  format %{ \"vector_addsub_saturating_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$XMMRegister, false, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_addsub_saturating_unsigned_subword_masked_reg(vec dst, vec src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst src) mask));\n+  match(Set dst (SaturatingSubV (Binary dst src) mask));\n+  format %{ \"vector_addsub_saturating_unsigned_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$XMMRegister, true, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_addsub_saturating_subword_masked_mem(vec dst, memory src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && !n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubV (Binary dst (LoadVector src)) mask));\n+  format %{ \"vector_addsub_saturating_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$Address, false, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vector_addsub_saturating_unsigned_subword_masked_mem(vec dst, memory src, kReg mask) %{\n+  predicate(is_subword_type(Matcher::vector_element_basic_type(n)) &&\n+            n->is_SaturatingVector() && n->as_SaturatingVector()->is_unsigned());\n+  match(Set dst (SaturatingAddV (Binary dst (LoadVector src)) mask));\n+  match(Set dst (SaturatingSubV (Binary dst (LoadVector src)) mask));\n+  format %{ \"vector_addsub_saturating_unsigned_subword_masked $dst, $mask, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    __ evmasked_saturating_op(this->ideal_Opcode(), elem_bt, $mask$$KRegister, $dst$$XMMRegister,\n+                              $dst$$XMMRegister, $src$$Address, true, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":330,"deletions":0,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -3961,2 +3961,2 @@\n-    \"OrI\",\"OrL\",\n-    \"XorI\",\"XorL\"\n+    \"OrI\",\"OrL\", \"XorI\",\"XorL\",\n+    \"UMax\",\"UMin\"\n@@ -3969,1 +3969,1 @@\n-    \"MaxV\", \"MinV\"\n+    \"MaxV\", \"MinV\", \"UMax\",\"UMin\"\n@@ -4343,1 +4343,1 @@\n-    \"MaxV\", \"MinV\",\n+    \"MaxV\", \"MinV\", \"UMinV\", \"UMaxV\",\n@@ -4366,1 +4366,1 @@\n-    \"CountLeadingZerosV\", \"CountTrailingZerosV\", \"SignumVF\", \"SignumVD\",\n+    \"CountLeadingZerosV\", \"CountTrailingZerosV\", \"SignumVF\", \"SignumVD\", \"SaturatingAddV\", \"SaturatingSubV\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2129,2 +2129,1 @@\n-        \/\/ TODO - remove implicit knowledge of G1\n-        log_info(cds)(\"Cannot use CDS heap data. UseG1GC is required for -XX:-UseCompressedOops\");\n+        log_info(cds)(\"Cannot use CDS heap data. Selected GC not compatible -XX:-UseCompressedOops\");\n@@ -2210,1 +2209,1 @@\n-  assert(ArchiveHeapLoader::can_map(), \"cannot be used by ArchiveHeapLoader::can_load() mode\");\n+  assert(ArchiveHeapLoader::can_use(), \"GC must support mapping or loading\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1606,0 +1606,2 @@\n+  assert(this->task() != nullptr, \"task must not be null\");\n+\n@@ -1626,3 +1628,1 @@\n-  if (this->task() != nullptr) {\n-    dump_compile_data(out);\n-  }\n+  dump_compile_data(out);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -420,17 +420,0 @@\n-#ifdef ASSERT\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {\n-  ResourceMark rm(THREAD);\n-  fatal(msg, _class_name->as_C_string());\n-}\n-\n-void ClassFileParser::report_assert_property_failure(const char* msg,\n-                                                     int index,\n-                                                     TRAPS) const {\n-  ResourceMark rm(THREAD);\n-  fatal(msg, index, _class_name->as_C_string());\n-}\n-PRAGMA_DIAG_POP\n-#endif\n-\n@@ -471,1 +454,1 @@\n-        check_property(valid_klass_reference_at(klass_ref_index),\n+        guarantee_property(valid_klass_reference_at(klass_ref_index),\n@@ -474,1 +457,1 @@\n-        check_property(valid_cp_range(name_and_type_ref_index, length) &&\n+        guarantee_property(valid_cp_range(name_and_type_ref_index, length) &&\n@@ -491,1 +474,1 @@\n-        check_property(\n+        guarantee_property(\n@@ -501,1 +484,1 @@\n-        check_property(valid_symbol_at(name_ref_index),\n+        guarantee_property(valid_symbol_at(name_ref_index),\n@@ -504,1 +487,1 @@\n-        check_property(valid_symbol_at(signature_ref_index),\n+        guarantee_property(valid_symbol_at(signature_ref_index),\n@@ -518,1 +501,1 @@\n-        check_property(valid_symbol_at(class_index),\n+        guarantee_property(valid_symbol_at(class_index),\n@@ -529,1 +512,1 @@\n-        check_property(valid_symbol_at(string_index),\n+        guarantee_property(valid_symbol_at(string_index),\n@@ -538,1 +521,1 @@\n-        check_property(valid_cp_range(ref_index, length),\n+        guarantee_property(valid_cp_range(ref_index, length),\n@@ -549,1 +532,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -557,1 +540,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -565,1 +548,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -573,1 +556,1 @@\n-            check_property(\n+            guarantee_property(\n@@ -591,1 +574,1 @@\n-        check_property(valid_symbol_at(ref_index),\n+        guarantee_property(valid_symbol_at(ref_index),\n@@ -600,1 +583,1 @@\n-        check_property(valid_cp_range(name_and_type_ref_index, length) &&\n+        guarantee_property(valid_cp_range(name_and_type_ref_index, length) &&\n@@ -615,1 +598,1 @@\n-        check_property(valid_cp_range(name_and_type_ref_index, length) &&\n+        guarantee_property(valid_cp_range(name_and_type_ref_index, length) &&\n@@ -856,1 +839,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -948,0 +931,1 @@\n+    _method_JvmtiHideEvents,\n@@ -1263,4 +1247,4 @@\n-    check_property(valid_symbol_at(attribute_name_index),\n-                   \"Invalid field attribute index %u in class file %s\",\n-                   attribute_name_index,\n-                   CHECK);\n+    guarantee_property(valid_symbol_at(attribute_name_index),\n+                       \"Invalid field attribute index %u in class file %s\",\n+                       attribute_name_index,\n+                       CHECK);\n@@ -1275,1 +1259,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -1432,1 +1416,1 @@\n-    check_property(valid_symbol_at(name_index),\n+    guarantee_property(valid_symbol_at(name_index),\n@@ -1439,1 +1423,1 @@\n-    check_property(valid_symbol_at(signature_index),\n+    guarantee_property(valid_symbol_at(signature_index),\n@@ -1657,1 +1641,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -1847,1 +1831,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -1906,0 +1890,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_JvmtiHideEvents_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_JvmtiHideEvents;\n+    }\n@@ -2005,0 +1994,2 @@\n+  if (has_annotation(_method_JvmtiHideEvents))\n+    m->set_jvmti_hide_events();\n@@ -2210,1 +2201,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -2317,1 +2308,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -2392,4 +2383,4 @@\n-        check_property(valid_symbol_at(code_attribute_name_index),\n-                       \"Invalid code attribute name index %u in class file %s\",\n-                       code_attribute_name_index,\n-                       CHECK_NULL);\n+        guarantee_property(valid_symbol_at(code_attribute_name_index),\n+                           \"Invalid code attribute name index %u in class file %s\",\n+                           code_attribute_name_index,\n+                           CHECK_NULL);\n@@ -2884,1 +2875,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -2898,1 +2889,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -3045,1 +3036,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3051,1 +3042,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3065,1 +3056,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3153,1 +3144,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3186,1 +3177,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -3219,1 +3210,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -3278,1 +3269,1 @@\n-    check_property(valid_symbol_at(name_index),\n+    guarantee_property(valid_symbol_at(name_index),\n@@ -3285,1 +3276,1 @@\n-    check_property(valid_symbol_at(descriptor_index),\n+    guarantee_property(valid_symbol_at(descriptor_index),\n@@ -3308,1 +3299,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -3406,1 +3397,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -3464,1 +3455,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3481,1 +3472,1 @@\n-      check_property(\n+      guarantee_property(\n@@ -3547,1 +3538,1 @@\n-    check_property(\n+    guarantee_property(\n@@ -3659,1 +3650,1 @@\n-        check_property(valid_klass_reference_at(enclosing_method_class_index),\n+        guarantee_property(valid_klass_reference_at(enclosing_method_class_index),\n@@ -3726,1 +3717,1 @@\n-          check_property(\n+          guarantee_property(\n@@ -3958,1 +3949,1 @@\n-    check_property(_class_name == vmSymbols::java_lang_Object(),\n+    guarantee_property(_class_name == vmSymbols::java_lang_Object(),\n@@ -3962,4 +3953,4 @@\n-    check_property(valid_klass_reference_at(super_class_index),\n-                   \"Invalid superclass index %u in class file %s\",\n-                   super_class_index,\n-                   CHECK_NULL);\n+    guarantee_property(valid_klass_reference_at(super_class_index),\n+                       \"Invalid superclass index %u in class file %s\",\n+                       super_class_index,\n+                       CHECK_NULL);\n@@ -4258,20 +4249,0 @@\n-    \/\/ If the loader is not the boot loader then throw an exception if its\n-    \/\/ superclass is in package jdk.internal.reflect and its loader is not a\n-    \/\/ special reflection class loader\n-    if (!this_klass->class_loader_data()->is_the_null_class_loader_data()) {\n-      PackageEntry* super_package = super->package();\n-      if (super_package != nullptr &&\n-          super_package->name()->fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &&\n-          !java_lang_ClassLoader::is_reflection_class_loader(this_klass->class_loader())) {\n-        ResourceMark rm(THREAD);\n-        Exceptions::fthrow(\n-          THREAD_AND_LOCATION,\n-          vmSymbols::java_lang_IllegalAccessError(),\n-          \"class %s loaded by %s cannot access jdk\/internal\/reflect superclass %s\",\n-          this_klass->external_name(),\n-          this_klass->class_loader_data()->loader_name_and_id(),\n-          super->external_name());\n-        return;\n-      }\n-    }\n-\n@@ -5392,1 +5363,1 @@\n-  Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));\n+  Handle clh = Handle(THREAD, cl);\n@@ -5862,1 +5833,1 @@\n-  check_property(\n+  guarantee_property(\n@@ -6057,1 +6028,1 @@\n-    check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),\n+    guarantee_property(_local_interfaces == Universe::the_empty_instance_klass_array(),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":64,"deletions":93,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -415,38 +415,0 @@\n-  void report_assert_property_failure(const char* msg, TRAPS) const PRODUCT_RETURN;\n-  void report_assert_property_failure(const char* msg, int index, TRAPS) const PRODUCT_RETURN;\n-\n-  inline void assert_property(bool b, const char* msg, TRAPS) const {\n-#ifdef ASSERT\n-    if (!b) {\n-      report_assert_property_failure(msg, THREAD);\n-    }\n-#endif\n-  }\n-\n-  inline void assert_property(bool b, const char* msg, int index, TRAPS) const {\n-#ifdef ASSERT\n-    if (!b) {\n-      report_assert_property_failure(msg, index, THREAD);\n-    }\n-#endif\n-  }\n-\n-  inline void check_property(bool property,\n-                             const char* msg,\n-                             int index,\n-                             TRAPS) const {\n-    if (_need_verify) {\n-      guarantee_property(property, msg, index, CHECK);\n-    } else {\n-      assert_property(property, msg, index, CHECK);\n-    }\n-  }\n-\n-  inline void check_property(bool property, const char* msg, TRAPS) const {\n-    if (_need_verify) {\n-      guarantee_property(property, msg, CHECK);\n-    } else {\n-      assert_property(property, msg, CHECK);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -660,2 +660,0 @@\n-  } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-    size = 1;  \/\/ there's only one class in relection class loader and no initiated classes\n@@ -831,2 +829,0 @@\n-      } else if (class_loader()->is_a(vmClasses::reflect_DelegatingClassLoader_klass())) {\n-        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4784,3 +4784,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  loader = non_reflection_class_loader(loader);\n-\n@@ -4795,23 +4792,0 @@\n-\/\/ Return true if this is one of the class loaders associated with\n-\/\/ the generated bytecodes for serialization constructor returned\n-\/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {\n-  if (loader != nullptr) {\n-    Klass* delegating_cl_class = vmClasses::reflect_DelegatingClassLoader_klass();\n-    \/\/ This might be null in non-1.4 JDKs\n-    return (delegating_cl_class != nullptr && loader->is_a(delegating_cl_class));\n-  }\n-  return false;\n-}\n-\n-oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {\n-  \/\/ See whether this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for reflection, and if so, \"magically\"\n-  \/\/ delegate to its parent to prevent class loading from occurring\n-  \/\/ in places where applications using reflection didn't expect it.\n-  if (is_reflection_class_loader(loader)) {\n-    return parent(loader);\n-  }\n-  return loader;\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1509,8 +1509,0 @@\n-  \/\/ Return true if this is one of the class loaders associated with\n-  \/\/ the generated bytecodes for serialization constructor returned\n-  \/\/ by sun.reflect.ReflectionFactory::newConstructorForSerialization\n-  static bool is_reflection_class_loader(oop loader);\n-\n-  \/\/ Fix for 4474172\n-  static oop  non_reflection_class_loader(oop loader);\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -605,2 +605,0 @@\n-  \/\/ Fix for 4474172; see evaluation for more details\n-  class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));\n@@ -772,6 +770,1 @@\n-  \/\/ The result of this call should be consistent with the result\n-  \/\/ of the call to resolve_instance_class_or_null().\n-  \/\/ See evaluation 6790209 and 4474172 for more details.\n-  oop class_loader_oop = java_lang_ClassLoader::non_reflection_class_loader(class_loader());\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader_oop);\n-\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -279,4 +279,0 @@\n-  Klass* refl_serialization_ctor_klass = vmClasses::reflect_SerializationConstructorAccessorImpl_klass();\n-\n-  bool is_reflect_accessor = refl_serialization_ctor_klass != nullptr &&\n-                                klass->is_subtype_of(refl_serialization_ctor_klass);\n@@ -299,6 +295,1 @@\n-    !(klass->is_shared() && klass->is_rewritten()) &&\n-\n-    \/\/ As of the fix for 4486457 we disable verification for all of the\n-    \/\/ dynamically-generated bytecodes associated with\n-    \/\/ jdk\/internal\/reflect\/SerializationConstructorAccessor.\n-    (!is_reflect_accessor));\n+    !(klass->is_shared() && klass->is_rewritten()));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-  do_klass(reflect_DelegatingClassLoader_klass,         reflect_DelegatingClassLoader                         ) \\\n@@ -114,1 +113,0 @@\n-  do_klass(reflect_SerializationConstructorAccessorImpl_klass,           reflect_SerializationConstructorAccessorImpl ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-  template(reflect_DelegatingClassLoader,             \"jdk\/internal\/reflect\/DelegatingClassLoader\")   \\\n@@ -275,1 +274,0 @@\n-  template(reflect_SerializationConstructorAccessorImpl,             \"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\") \\\n@@ -315,0 +313,1 @@\n+  template(jdk_internal_vm_annotation_JvmtiHideEvents_signature,       \"Ljdk\/internal\/vm\/annotation\/JvmtiHideEvents;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1206,7 +1206,1 @@\n-    \/\/ Disable verification for the dynamically-generated reflection bytecodes\n-    \/\/ for serialization constructor accessor.\n-    bool is_reflect = klass_to_check->is_subclass_of(\n-                        vmClasses::reflect_SerializationConstructorAccessorImpl_klass());\n-\n-    if (!is_reflect &&\n-        !klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n+    if (!klass_to_check->is_same_or_direct_interface(resolved_klass)) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+  guarantee(CompressedKlassPointers::is_encodable(klass), \"klass cannot be compressed: %s\", klass->external_name());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"gc\/x\/xBarrierSetRuntime.hpp\"\n@@ -839,9 +838,0 @@\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_field_preloaded))                      \\\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded))                 \\\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded))              \\\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded))                 \\\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded))            \\\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded))         \\\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::load_barrier_on_oop_array))                                \\\n-  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, XBarrierSetRuntime::clone))                                                    \\\n-                                                                                                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+   flag(jvmti_hide_events         , 1 << 26) \\\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -763,0 +763,3 @@\n+  bool jvmti_hide_events() const { return constMethod()->jvmti_hide_events(); }\n+  void set_jvmti_hide_events() { constMethod()->set_jvmti_hide_events(); }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-void oopDesc::obj_field_put_raw(int offset, oop value)                { assert(!(UseZGC && ZGenerational), \"Generational ZGC must use store barriers\");\n+void oopDesc::obj_field_put_raw(int offset, oop value)                { assert(!UseZGC, \"ZGC must use store barriers\");\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-macro(Opaque4)\n+macro(OpaqueNotNull)\n@@ -276,0 +276,1 @@\n+macro(OpaqueTemplateAssertionPredicate)\n@@ -333,0 +334,2 @@\n+macro(SaturatingAddV)\n+macro(SaturatingSubV)\n@@ -440,0 +443,2 @@\n+macro(UMinV)\n+macro(UMaxV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-  if (dead->Opcode() == Op_Opaque4) {\n+  if (dead->is_OpaqueTemplateAssertionPredicate()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -379,1 +379,2 @@\n-  GrowableArray<Node*>  _template_assertion_predicate_opaqs; \/\/ List of Opaque4 nodes for Template Assertion Predicates.\n+  \/\/ List of OpaqueTemplateAssertionPredicateNode nodes for Template Assertion Predicates.\n+  GrowableArray<Node*>  _template_assertion_predicate_opaqs;\n@@ -792,1 +793,1 @@\n-           \"duplicate entry in template assertion predicate opaque4 list\");\n+           \"Duplicate entry in Template Assertion Predicate OpaqueTemplateAssertionPredicate list\");\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -589,3 +589,1 @@\n-          \/\/ We may have Opaque4 node between If and Bool nodes.\n-          \/\/ Bail out in such case - we need to preserve Opaque4 for correct\n-          \/\/ processing predicates after loop opts.\n+          \/\/ We may have an OpaqueNotNull node between If and Bool nodes. Bail out in such case.\n@@ -597,0 +595,2 @@\n+          } else {\n+            assert(iff->in(1)->is_OpaqueNotNull(), \"must be OpaqueNotNull\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1524,1 +1524,1 @@\n-\/\/ an Opaque4 node that will cause the check to be removed after loop\n+\/\/ an OpaqueNotNull node that will cause the check to be removed after loop\n@@ -1532,3 +1532,3 @@\n-  Node *tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));\n-  Node* opaq = _gvn.transform(new Opaque4Node(C, tst, intcon(1)));\n-  IfNode *iff = new IfNode(control(), opaq, PROB_MAX, COUNT_UNKNOWN);\n+  Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));\n+  Node* opaq = _gvn.transform(new OpaqueNotNullNode(C, tst));\n+  IfNode* iff = new IfNode(control(), opaq, PROB_MAX, COUNT_UNKNOWN);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -960,0 +960,1 @@\n+ public:\n@@ -962,2 +963,3 @@\n-  static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);\n-  static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);\n+ private:\n+  DEBUG_ONLY(static void count_opaque_loop_nodes(Node* n, uint& init, uint& stride);)\n+  DEBUG_ONLY(static bool assertion_predicate_has_loop_opaque_node(IfNode* iff);)\n@@ -968,3 +970,3 @@\n-  void initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block, LoopNode* outer_loop_head,\n-                                                       int dd_outer_loop_head, Node* init, Node* stride,\n-                                                       IdealLoopTree* outer_loop, uint idx_before_clone,\n+  void initialize_assertion_predicates_for_peeled_loop(CountedLoopNode* peeled_loop_head,\n+                                                       CountedLoopNode* remaining_loop_head,\n+                                                       uint first_node_index_in_cloned_loop_body,\n@@ -972,0 +974,2 @@\n+  void create_assertion_predicates_at_loop(CountedLoopNode* source_loop_head, CountedLoopNode* target_loop_head,\n+                                           const NodeInLoopBody& _node_in_loop_body);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -801,4 +801,3 @@\n-  if (bol->is_Opaque4()) {\n-    \/\/ Ignore Template Assertion Predicates with Opaque4 nodes.\n-    assert(assertion_predicate_has_loop_opaque_node(iff),\n-           \"must be Template Assertion Predicate, non-null-check with Opaque4 cannot form a diamond with Halt\");\n+  if (bol->is_OpaqueTemplateAssertionPredicate()) {\n+    \/\/ Ignore Template Assertion Predicates with OpaqueTemplateAssertionPredicate nodes.\n+    assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n@@ -1877,1 +1876,1 @@\n-      !n->is_Opaque4() &&\n+      !n->is_OpaqueNotNull() &&\n@@ -1879,0 +1878,1 @@\n+      !n->is_OpaqueTemplateAssertionPredicate() &&\n@@ -2120,4 +2120,5 @@\n-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop() &&\n-      u_loop->_head->is_CountedLoop() && u_loop->_head->as_CountedLoop()->is_main_loop() &&\n-      n_loop->_next == get_loop(u_loop->_head->as_CountedLoop()->skip_strip_mined())) {\n-    return false;\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return false;\n+    }\n@@ -2195,2 +2196,2 @@\n-      assert(b->is_Bool() || b->is_Opaque4() || b->is_OpaqueInitializedAssertionPredicate(),\n-             \"bool, non-null check with Opaque4 node or Initialized Assertion Predicate with its Opaque node\");\n+      assert(b->is_Bool() || b->is_OpaqueNotNull() || b->is_OpaqueInitializedAssertionPredicate(),\n+             \"bool, non-null check with OpaqueNotNull or Initialized Assertion Predicate with its Opaque node\");\n@@ -2202,1 +2203,1 @@\n-  if (n->is_Opaque4() || n->is_OpaqueInitializedAssertionPredicate()) {\n+  if (n->is_OpaqueNotNull() || n->is_OpaqueInitializedAssertionPredicate()) {\n@@ -2384,1 +2385,3 @@\n-      if (use->is_If() || use->is_CMove() || use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate() ||\n+      assert(!use->is_OpaqueTemplateAssertionPredicate(),\n+             \"should not clone a Template Assertion Predicate which should be removed once it's useless\");\n+      if (use->is_If() || use->is_CMove() || use->is_OpaqueNotNull() || use->is_OpaqueInitializedAssertionPredicate() ||\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2938,1 +2938,1 @@\n-               n->is_Opaque4()             ||\n+               n->is_OpaqueNotNull()       ||\n@@ -2993,7 +2993,4 @@\n-      } else if (n->is_Opaque4()) {\n-        \/\/ With Opaque4 nodes, the expectation is that the test of input 1\n-        \/\/ is always equal to the constant value of input 2. So we can\n-        \/\/ remove the Opaque4 and replace it by input 2. In debug builds,\n-        \/\/ leave the non constant test in instead to sanity check that it\n-        \/\/ never fails (if it does, that subgraph was constructed so, at\n-        \/\/ runtime, a Halt node is executed).\n+      } else if (n->is_OpaqueNotNull()) {\n+        \/\/ Tests with OpaqueNotNull nodes are implicitly known to be true. Replace the node with true. In debug builds,\n+        \/\/ we leave the test in the graph to have an additional sanity check at runtime. If the test fails (i.e. a bug),\n+        \/\/ we will execute a Halt node.\n@@ -3003,1 +3000,1 @@\n-        _igvn.replace_node(n, n->in(2));\n+        _igvn.replace_node(n, _igvn.intcon(1));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-  if (is_Opaque4()) {\n+  if (is_OpaqueTemplateAssertionPredicate()) {\n@@ -2780,3 +2780,1 @@\n-  if (i < _max) {\n-    return; \/\/ No need to grow\n-  }\n+  assert(i >= _max, \"Should have been checked before, use maybe_grow?\");\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-class Opaque4Node;\n+class OpaqueNotNullNode;\n@@ -146,0 +146,1 @@\n+class OpaqueTemplateAssertionPredicateNode;\n@@ -174,0 +175,1 @@\n+class SaturatingVectorNode;\n@@ -750,0 +752,1 @@\n+        DEFINE_CLASS_ID(SaturatingVector, Vector, 9)\n@@ -808,1 +811,1 @@\n-    DEFINE_CLASS_ID(Opaque4,  Node, 17)\n+    DEFINE_CLASS_ID(OpaqueNotNull,  Node, 17)\n@@ -810,3 +813,4 @@\n-    DEFINE_CLASS_ID(Move,     Node, 19)\n-    DEFINE_CLASS_ID(LShift,   Node, 20)\n-    DEFINE_CLASS_ID(Neg,      Node, 21)\n+    DEFINE_CLASS_ID(OpaqueTemplateAssertionPredicate,  Node, 19)\n+    DEFINE_CLASS_ID(Move,     Node, 20)\n+    DEFINE_CLASS_ID(LShift,   Node, 21)\n+    DEFINE_CLASS_ID(Neg,      Node, 22)\n@@ -986,1 +990,1 @@\n-  DEFINE_CLASS_QUERY(Opaque4)\n+  DEFINE_CLASS_QUERY(OpaqueNotNull)\n@@ -988,0 +992,1 @@\n+  DEFINE_CLASS_QUERY(OpaqueTemplateAssertionPredicate)\n@@ -1024,0 +1029,1 @@\n+  DEFINE_CLASS_QUERY(SaturatingVector)\n@@ -1624,1 +1630,8 @@\n-  void   grow( uint i );        \/\/ Grow array node to fit\n+  \/\/ Grow array to required capacity\n+  void maybe_grow(uint i) {\n+    if (i >= _max) {\n+      grow(i);\n+    }\n+  }\n+  void grow(uint i);\n+\n@@ -1642,1 +1655,1 @@\n-  void map( uint i, Node *n ) { grow(i); _nodes[i] = n; }\n+  void map( uint i, Node *n ) { maybe_grow(i); _nodes[i] = n; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -326,1 +326,2 @@\n-            if (use->is_Opaque4() || use->is_OpaqueInitializedAssertionPredicate()) {\n+            if (use->is_OpaqueNotNull() || use->is_OpaqueTemplateAssertionPredicate() ||\n+                use->is_OpaqueInitializedAssertionPredicate()) {\n@@ -355,2 +356,3 @@\n-              \/\/ Uses are either IfNodes, CMoves, Opaque4, or OpaqueInitializedAssertionPredicates\n-              if (u->is_Opaque4() || u->is_OpaqueInitializedAssertionPredicate()) {\n+              \/\/ Uses are either IfNodes, CMoves, OpaqueNotNull, or Opaque*AssertionPredicate\n+              if (u->is_OpaqueNotNull() || u->is_OpaqueTemplateAssertionPredicate() ||\n+                  u->is_OpaqueInitializedAssertionPredicate()) {\n@@ -425,2 +427,3 @@\n-    Opaque4Node* opaque4_node = template_assertion_predicate->in(1)->as_Opaque4();\n-    TemplateAssertionExpression template_assertion_expression(opaque4_node);\n+    OpaqueTemplateAssertionPredicateNode* opaque_node =\n+        template_assertion_predicate->in(1)->as_OpaqueTemplateAssertionPredicate();\n+    TemplateAssertionExpression template_assertion_expression(opaque_node);\n@@ -428,2 +431,2 @@\n-    Opaque4Node* cloned_opaque4_node = template_assertion_expression.clone(new_ctrl, this);\n-    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque4_node);\n+    OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(new_ctrl, this);\n+    igvn().replace_input_of(template_assertion_predicate, 1, cloned_opaque_node);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3392,4 +3392,1 @@\n-      \/\/ Skip reflection related frames\n-      if (!ik->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-        return JNIHandles::make_local(THREAD, loader);\n-      }\n+      return JNIHandles::make_local(THREAD, loader);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1472,1 +1472,1 @@\n-    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+    guarantee(status == JNI_OK && !env->ExceptionCheck(),\n@@ -1476,1 +1476,1 @@\n-    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+    guarantee(status == JNI_OK && !env->ExceptionCheck(),\n@@ -1480,1 +1480,1 @@\n-    guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+    guarantee(status == JNI_OK && !env->ExceptionCheck(),\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -830,1 +830,1 @@\n-  if (env->ExceptionOccurred()) {\n+  if (env->ExceptionCheck()) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,5 +432,1 @@\n-    if (ZGenerational) {\n-      return ZHeap::heap()->is_old(to_zaddress(p));\n-    } else {\n-      return Universe::heap()->is_in(p);\n-    }\n+    return ZHeap::heap()->is_old(to_zaddress(p));\n@@ -1759,1 +1755,1 @@\n-  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ReflectionMetaspaceType : Metaspace::StandardMetaspaceType;\n+  const Metaspace::MetaspaceType type = is_micro ? Metaspace::ClassMirrorHolderMetaspaceType : Metaspace::StandardMetaspaceType;\n@@ -2270,2 +2266,1 @@\n-  return HeapShared::can_write()\n-      && ArchiveHeapLoader::can_use(); \/\/ work-around JDK-8341371\n+  return HeapShared::can_write();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -509,1 +509,0 @@\n-  { \"ZGenerational\",                JDK_Version::jdk(23), JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -525,1 +524,1 @@\n-\n+  { \"ZGenerational\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -458,6 +458,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (vmClasses::reflect_SerializationConstructorAccessorImpl_klass_is_loaded() &&\n-      current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return ACCESS_OK;\n-  }\n@@ -668,6 +662,0 @@\n-  \/\/ Allow all accesses from jdk\/internal\/reflect\/SerializationConstructorAccessorImpl subclasses to\n-  \/\/ succeed trivially.\n-  if (current_class->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -79,2 +79,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Boolean> TYPE = (Class<Boolean>) Class.getPrimitiveClass(\"boolean\");\n+    public static final Class<Boolean> TYPE = Class.getPrimitiveClass(\"boolean\");\n@@ -257,2 +256,2 @@\n-        if (obj instanceof Boolean) {\n-            return value == ((Boolean)obj).booleanValue();\n+        if (obj instanceof Boolean b) {\n+            return value == b.booleanValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Byte>     TYPE = (Class<Byte>) Class.getPrimitiveClass(\"byte\");\n+    public static final Class<Byte> TYPE = Class.getPrimitiveClass(\"byte\");\n@@ -482,2 +481,2 @@\n-        if (obj instanceof Byte) {\n-            return value == ((Byte)obj).byteValue();\n+        if (obj instanceof Byte b) {\n+            return value == b.byteValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -236,2 +236,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Character> TYPE = (Class<Character>) Class.getPrimitiveClass(\"char\");\n+    public static final Class<Character> TYPE = Class.getPrimitiveClass(\"char\");\n@@ -9071,2 +9070,2 @@\n-        if (obj instanceof Character) {\n-            return value == ((Character)obj).charValue();\n+        if (obj instanceof Character c) {\n+            return value == c.charValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3331,2 +3331,2 @@\n-     * Return the Virtual Machine's Class object for the named\n-     * primitive type.\n+     * Returns the Class object for the named primitive type. Type parameter T\n+     * avoids redundant casts for trusted code.\n@@ -3334,1 +3334,1 @@\n-    static native Class<?> getPrimitiveClass(String name);\n+    static native <T> Class<T> getPrimitiveClass(String name);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -464,2 +464,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Double>   TYPE = (Class<Double>) Class.getPrimitiveClass(\"double\");\n+    public static final Class<Double> TYPE = Class.getPrimitiveClass(\"double\");\n@@ -1263,3 +1262,2 @@\n-        return (obj instanceof Double)\n-               && (doubleToLongBits(((Double)obj).value) ==\n-                      doubleToLongBits(value));\n+        return (obj instanceof Double d) &&\n+            (doubleToLongBits(d.value) == doubleToLongBits(value));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -180,2 +180,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Float> TYPE = (Class<Float>) Class.getPrimitiveClass(\"float\");\n+    public static final Class<Float> TYPE = Class.getPrimitiveClass(\"float\");\n@@ -895,2 +894,2 @@\n-        return (obj instanceof Float)\n-               && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));\n+        return (obj instanceof Float f) &&\n+            (floatToIntBits(f.value) == floatToIntBits(value));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,2 +100,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Integer>  TYPE = (Class<Integer>) Class.getPrimitiveClass(\"int\");\n+    public static final Class<Integer> TYPE = Class.getPrimitiveClass(\"int\");\n@@ -1153,2 +1152,2 @@\n-        if (obj instanceof Integer) {\n-            return value == ((Integer)obj).intValue();\n+        if (obj instanceof Integer i) {\n+            return value == i.intValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,2 +100,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Long>     TYPE = (Class<Long>) Class.getPrimitiveClass(\"long\");\n+    public static final Class<Long> TYPE = Class.getPrimitiveClass(\"long\");\n@@ -1251,2 +1250,2 @@\n-        if (obj instanceof Long) {\n-            return value == ((Long)obj).longValue();\n+        if (obj instanceof Long ell) {\n+            return value == ell.longValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static final Class<Short>    TYPE = (Class<Short>) Class.getPrimitiveClass(\"short\");\n+    public static final Class<Short> TYPE = Class.getPrimitiveClass(\"short\");\n@@ -488,2 +487,2 @@\n-        if (obj instanceof Short) {\n-            return value == ((Short)obj).shortValue();\n+        if (obj instanceof Short s) {\n+            return value == s.shortValue();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -151,2 +151,1 @@\n-     * {@link Console#charset()} if the {@code Console} exists,\n-     * <a href=\"#stdout.encoding\">stdout.encoding<\/a> otherwise.\n+     * {@link ##stdout.encoding stdout.encoding}.\n@@ -172,2 +171,1 @@\n-     * @see     Console#charset()\n-     * @see     <a href=\"#stdout.encoding\">stdout.encoding<\/a>\n+     * @see     ##stdout.encoding stdout.encoding\n@@ -189,2 +187,1 @@\n-     * equivalent to {@link Console#charset()} if the {@code Console}\n-     * exists, <a href=\"#stderr.encoding\">stderr.encoding<\/a> otherwise.\n+     * equivalent to {@link ##stderr.encoding stderr.encoding}.\n@@ -192,2 +189,1 @@\n-     * @see     Console#charset()\n-     * @see     <a href=\"#stderr.encoding\">stderr.encoding<\/a>\n+     * @see     ##stderr.encoding stderr.encoding\n@@ -792,1 +788,2 @@\n-     *     <td>Character encoding name for {@link System#out System.out}.\n+     *     <td>Character encoding name for {@link System#out System.out} and\n+     *     {@link System#console() System.console()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -65,1 +66,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n@@ -68,1 +68,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -169,1 +168,1 @@\n-        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n+        lambdaClassEntry = pool.classEntry(ConstantUtils.internalNameToDesc(lambdaClassName));\n@@ -426,3 +425,3 @@\n-        private static final ClassDesc CD_SerializedLambda = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n-        private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n-        private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final ClassDesc CD_SerializedLambda = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n@@ -437,1 +436,1 @@\n-        static final ClassDesc CD_NotSerializableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final ClassDesc CD_NotSerializableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n@@ -440,1 +439,1 @@\n-                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ConstantUtils.CD_Object_array);\n@@ -643,1 +642,1 @@\n-        return cls.isHidden() ? null : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+        return cls.isHidden() ? null : ConstantUtils.referenceClassDesc(cls.descriptorString());\n@@ -648,1 +647,1 @@\n-                                 : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+                                 : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -308,4 +308,0 @@\n-        COLLECT(\"collect\"),\n-        CONVERT(\"convert\"),\n-        SPREAD(\"spread\"),\n-        FIELD(\"field\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -31,1 +33,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -57,1 +58,0 @@\n-import java.util.Set;\n@@ -70,1 +70,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n@@ -1041,1 +1040,1 @@\n-        private static final ClassDesc CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+        private static final ClassDesc CD_Object_array = ConstantUtils.CD_Object_array;\n@@ -1270,1 +1269,1 @@\n-            return ClassFile.of().build(ReferenceClassDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n+            return ClassFile.of().build(ClassOrInterfaceDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -44,1 +46,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -67,12 +68,12 @@\n-            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n-            CD_Class_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n-            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n-            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n-            CD_IllegalAccessException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n-            CD_InvocationHandler = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n-            CD_Method = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n-            CD_NoSuchMethodError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n-            CD_NoSuchMethodException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n-            CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n-            CD_Proxy = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n-            CD_UndeclaredThrowableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n+            CD_ClassLoader = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n+            CD_Class_array = CD_Class.arrayType(),\n+            CD_ClassNotFoundException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n+            CD_IllegalAccessException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n+            CD_InvocationHandler = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n+            CD_Method = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n+            CD_NoSuchMethodError = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n+            CD_NoSuchMethodException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n+            CD_Object_array = ConstantUtils.CD_Object_array,\n+            CD_Proxy = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n+            CD_UndeclaredThrowableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-import jdk.internal.constant.MethodTypeDescImpl;\n-import jdk.internal.constant.ReferenceClassDescImpl;\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -54,0 +53,1 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n@@ -85,2 +85,2 @@\n-    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final ClassDesc CD_BiPredicate = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -587,1 +587,1 @@\n-                            cb.invokestatic(referenceClassDesc(ExactConversionsSupport.class),\n+                            cb.invokestatic(ConstantUtils.referenceClassDesc(ExactConversionsSupport.class),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,3 +67,0 @@\n-        \/\/ not used, but required for interim javac to not warn.\n-        VIRTUAL_THREADS,\n-        FOREIGN,\n@@ -73,2 +70,3 @@\n-        @JEP(number=459, title=\"String Templates\", status=\"Second Preview\")\n-        STRING_TEMPLATES,\n+        \/\/ while building the interim javac, the ClassReader will produce a warning when loading a class\n+        \/\/ keeping the constant of a feature that has been integrated or dropped, serves the purpose of muting such warnings.\n+        \/\/---\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -347,10 +347,2 @@\n-        ConstructorAccessor acc;\n-        if (useOldSerializableConstructor()) {\n-            acc = new SerializationConstructorAccessorGenerator().\n-                                generateSerializationConstructor(cl,\n-                                                                 constructorToCall.getParameterTypes(),\n-                                                                 constructorToCall.getModifiers(),\n-                                                                 constructorToCall.getDeclaringClass());\n-        } else {\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n-        }\n+        ConstructorAccessor acc = MethodHandleAccessorFactory\n+                .newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -520,4 +512,0 @@\n-    static boolean useOldSerializableConstructor() {\n-        return config().useOldSerializableConstructor;\n-    }\n-\n@@ -540,1 +528,0 @@\n-                                                            false,  \/\/ useOldSerializeableConstructor\n@@ -555,1 +542,0 @@\n-                          boolean useOldSerializableConstructor,\n@@ -579,2 +565,0 @@\n-        boolean useOldSerializableConstructor =\n-            \"true\".equals(props.getProperty(\"jdk.reflect.useOldSerializableConstructor\"));\n@@ -584,1 +568,1 @@\n-        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, disableSerialConstructorChecks);\n+        return new Config(useNativeAccessorOnly, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Type.UnknownType;\n@@ -419,3 +418,0 @@\n-        \/\/ Create the unknown type\n-        unknownType = new UnknownType();\n-\n@@ -494,2 +490,2 @@\n-        unknownSymbol.members_field = new Scope.ErrorScope(unknownSymbol);\n-        unknownSymbol.type = unknownType;\n+        \/\/ Create the unknown type\n+        unknownType = new ErrorType(unknownSymbol, Type.noType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-            sb.append(getAnnotationMirrors());\n+            sb.append(getAnnotationMirrors().toString(\" \"));\n@@ -2435,24 +2435,0 @@\n-    public static class UnknownType extends Type {\n-\n-        public UnknownType() {\n-            \/\/ Unknown is a synthesized internal type, so it cannot be\n-            \/\/ annotated.\n-            super(null, List.nil());\n-        }\n-\n-        @Override\n-        public TypeTag getTag() {\n-            return UNKNOWN;\n-        }\n-\n-        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-        public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n-            return v.visitUnknown(this, p);\n-        }\n-\n-        @Override\n-        public boolean isPartial() {\n-            return true;\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1224,1 +1224,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -1474,1 +1474,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -2438,1 +2438,1 @@\n-                             NONE, ERROR, UNKNOWN, UNDETVAR, UNINITIALIZED_THIS,\n+                             NONE, ERROR, UNDETVAR, UNINITIALIZED_THIS,\n@@ -3344,0 +3344,4 @@\n+    \/* this class won't substitute all types for example UndetVars are never substituted, this is\n+     * by design as UndetVars are used locally during inference and shouldn't escape from inference routines,\n+     * some specialized applications could need a tailored solution\n+     *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -581,3 +581,1 @@\n-                println(\"Code:\");\n-                codeWriter.writeInstrs(code);\n-                codeWriter.writeExceptionTable(code);\n+                codeWriter.writeMinimal(code);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,5 +30,1 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8276539   generic-all\n-serviceability\/sa\/CDSJMapClstats.java                         8276539   generic-all\n-serviceability\/sa\/ClhsdbJhisto.java                           8276539   generic-all\n-serviceability\/sa\/ClhsdbJstackWithConcurrentLock.java         8276539   generic-all\n-serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java      8276539   generic-all\n+# Quiet all SA tests\n@@ -36,3 +32,85 @@\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core                8284045   generic-all\n-serviceability\/sa\/TestJmapCore.java                           8268283,8270202   generic-all\n-serviceability\/sa\/TestJmapCoreMetaspace.java                  8268636   generic-all\n+resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8307393   generic-all\n+serviceability\/sa\/CDSJMapClstats.java                         8307393   generic-all\n+serviceability\/sa\/ClhsdbAttach.java                           8307393   generic-all\n+serviceability\/sa\/ClhsdbAttachDifferentJVMs.java              8307393   generic-all\n+serviceability\/sa\/ClhsdbCDSCore.java                          8307393   generic-all\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java                8307393   generic-all\n+serviceability\/sa\/ClhsdbClasses.java                          8307393   generic-all\n+serviceability\/sa\/ClhsdbDumpclass.java                        8307393   generic-all\n+serviceability\/sa\/ClhsdbDumpheap.java                         8307393   generic-all\n+serviceability\/sa\/ClhsdbField.java                            8307393   generic-all\n+serviceability\/sa\/ClhsdbFindPC.java#apa                       8307393   generic-all\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core             8307393   generic-all\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-process          8307393   generic-all\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core                8307393   generic-all\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-process             8307393   generic-all\n+serviceability\/sa\/ClhsdbFlags.java                            8307393   generic-all\n+serviceability\/sa\/ClhsdbHistory.java                          8307393   generic-all\n+serviceability\/sa\/ClhsdbInspect.java                          8307393   generic-all\n+serviceability\/sa\/ClhsdbJdis.java                             8307393   generic-all\n+serviceability\/sa\/ClhsdbJhisto.java                           8307393   generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id0                       8307393   generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id1                       8307393   generic-all\n+serviceability\/sa\/ClhsdbJstackWithConcurrentLock.java         8307393   generic-all\n+serviceability\/sa\/ClhsdbJstackXcompStress.java                8307393   generic-all\n+serviceability\/sa\/ClhsdbLauncher.java                         8307393   generic-all\n+serviceability\/sa\/ClhsdbLongConstant.java                     8307393   generic-all\n+serviceability\/sa\/ClhsdbPmap.java                             8307393   generic-all\n+serviceability\/sa\/ClhsdbPmap.java#core                        8307393   generic-all\n+serviceability\/sa\/ClhsdbPmap.java#process                     8307393   generic-all\n+serviceability\/sa\/ClhsdbPrintAll.java                         8307393   generic-all\n+serviceability\/sa\/ClhsdbPrintAs.java                          8307393   generic-all\n+serviceability\/sa\/ClhsdbPrintStatics.java                     8307393   generic-all\n+serviceability\/sa\/ClhsdbPstack.java#core                      8307393   generic-all\n+serviceability\/sa\/ClhsdbPstack.java#process                   8307393   generic-all\n+serviceability\/sa\/ClhsdbScanOops.java                         8307393   generic-all\n+serviceability\/sa\/ClhsdbSource.java                           8307393   generic-all\n+serviceability\/sa\/ClhsdbSymbol.java                           8307393   generic-all\n+serviceability\/sa\/ClhsdbThread.java                           8307393   generic-all\n+serviceability\/sa\/ClhsdbThreadContext.java                    8307393   generic-all\n+serviceability\/sa\/ClhsdbVmStructsDump.java                    8307393   generic-all\n+serviceability\/sa\/ClhsdbWhere.java                            8307393   generic-all\n+serviceability\/sa\/DeadlockDetectionTest.java                  8307393   generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java                    8307393   generic-all\n+serviceability\/sa\/LingeredAppSysProps.java                    8307393   generic-all\n+serviceability\/sa\/LingeredAppWithDefaultMethods.java          8307393   generic-all\n+serviceability\/sa\/LingeredAppWithEnum.java                    8307393   generic-all\n+serviceability\/sa\/LingeredAppWithInterface.java               8307393   generic-all\n+serviceability\/sa\/LingeredAppWithInvokeDynamic.java           8307393   generic-all\n+serviceability\/sa\/LingeredAppWithLock.java                    8307393   generic-all\n+serviceability\/sa\/LingeredAppWithNativeMethod.java            8307393   generic-all\n+serviceability\/sa\/LingeredAppWithRecComputation.java          8307393   generic-all\n+serviceability\/sa\/TestClassDump.java                          8307393   generic-all\n+serviceability\/sa\/TestClhsdbJstackLock.java                   8307393   generic-all\n+serviceability\/sa\/TestCpoolForInvokeDynamic.java              8307393   generic-all\n+serviceability\/sa\/TestDefaultMethods.java                     8307393   generic-all\n+serviceability\/sa\/TestG1HeapRegion.java                       8307393   generic-all\n+serviceability\/sa\/TestHeapDumpForInvokeDynamic.java           8307393   generic-all\n+serviceability\/sa\/TestInstanceKlassSize.java                  8307393   generic-all\n+serviceability\/sa\/TestInstanceKlassSizeForInterface.java      8307393   generic-all\n+serviceability\/sa\/TestIntConstant.java                        8307393   generic-all\n+serviceability\/sa\/TestJhsdbJstackLineNumbers.java             8307393   generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java                    8307393   generic-all\n+serviceability\/sa\/TestJhsdbJstackMixed.java                   8307393   generic-all\n+serviceability\/sa\/TestJhsdbJstackUpcall.java                  8307393   generic-all\n+serviceability\/sa\/TestJmapCore.java                           8307393   generic-all\n+serviceability\/sa\/TestJmapCoreMetaspace.java                  8307393   generic-all\n+serviceability\/sa\/TestObjectAlignment.java                    8307393   generic-all\n+serviceability\/sa\/TestObjectMonitorIterate.java               8307393   generic-all\n+serviceability\/sa\/TestPrintMdo.java                           8307393   generic-all\n+serviceability\/sa\/TestRevPtrsForInvokeDynamic.java            8307393   generic-all\n+serviceability\/sa\/TestSysProps.java                           8307393   generic-all\n+serviceability\/sa\/TestType.java                               8307393   generic-all\n+serviceability\/sa\/TestUniverse.java                           8307393   generic-all\n+serviceability\/sa\/UniqueVtableTest.java                       8307393   generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapProc.java      8307393   generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java      8307393   generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbAttachToDebugServer.java     8307393   generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbTestConnectArgument.java     8307393   generic-all\n+serviceability\/sa\/ClhsdbTestAllocationMerge.java              8307393   generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java             8307393   generic-all\n+serviceability\/sa\/sadebugd\/DebugdUtils.java                   8307393   generic-all\n+serviceability\/sa\/sadebugd\/DisableRegistryTest.java           8307393   generic-all\n+serviceability\/sa\/sadebugd\/PmapOnDebugdTest.java              8307393   generic-all\n+serviceability\/sa\/sadebugd\/RunCommandOnServerTest.java        8307393   generic-all\n+serviceability\/sa\/sadebugd\/SADebugDTest.java                  8307393   generic-all\n@@ -40,5 +118,1 @@\n-serviceability\/sa\/TestJhsdbJstackMixed.java                   8248912   generic-all\n-serviceability\/sa\/ClhsdbPstack.java#process                   8248912   generic-all\n-serviceability\/sa\/ClhsdbPstack.java#core                      8248912   generic-all\n-\n-serviceability\/sa\/TestSysProps.java                           8302055   generic-all\n+vmTestbase\/gc\/gctests\/MemoryEaterMT\/MemoryEaterMT.java        8289582   windows-x64\n@@ -46,1 +120,8 @@\n-serviceability\/sa\/TestHeapDumpForInvokeDynamic.java           8315646   generic-all\n+# Valhalla...\n+compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java      8346466   generic-all\n+compiler\/valhalla\/inlinetypes\/TestArrays.java                 8341848   generic-all\n+compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java     8341848   generic-all\n+compiler\/valhalla\/inlinetypes\/TestIntrinsics.java             8341849   generic-all\n+compiler\/valhalla\/inlinetypes\/TestLWorld.java                 8341848   generic-all\n+compiler\/valhalla\/inlinetypes\/TestNullableArrays.java         8341850   generic-all\n+compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeArray.java   8341848 generic-all\n@@ -48,1 +129,1 @@\n-vmTestbase\/gc\/gctests\/MemoryEaterMT\/MemoryEaterMT.java        8289582   windows-x64\n+compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java 8341947   generic-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":96,"deletions":15,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-compiler\/vectorapi\/VectorRebracket128Test.java#ZSinglegen 8330538 generic-all\n-compiler\/vectorapi\/VectorRebracket128Test.java#ZGenerational 8330538 generic-all\n+compiler\/vectorapi\/VectorRebracket128Test.java#Z 8330538 generic-all\n@@ -98,2 +97,1 @@\n-gc\/TestAlwaysPreTouchBehavior.java#ZGenerational 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#ZSinglegen 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#Z 8334513 generic-all\n@@ -110,0 +108,1 @@\n+runtime\/Monitor\/SyncOnValueBasedClassTest.java 8340995 linux-s390x\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  -compiler\/valhalla\/inlinetypes\/TestWrongFlatArrayCopyStubWithZGC.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @requires vm.gc.ZGenerational\n+ * @requires vm.gc.Z\n@@ -46,1 +46,1 @@\n- * @requires vm.gc.ZGenerational & (vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\")\n+ * @requires vm.gc.Z & (vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\")\n@@ -102,1 +102,1 @@\n-        test.addFlags(\"-XX:+UseZGC\", \"-XX:+ZGenerational\", \"-XX:+UnlockExperimentalVMOptions\",\n+        test.addFlags(\"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @requires vm.gc.ZGenerational\n+ * @requires vm.gc.Z\n@@ -58,2 +58,1 @@\n-        TestFramework.runWithFlags(\"-XX:+UseZGC\", \"-XX:+ZGenerational\",\n-                                   \"-XX:LoopUnrollLimit=24\");\n+        TestFramework.runWithFlags(\"-XX:+UseZGC\", \"-XX:LoopUnrollLimit=24\");\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCUnrolling.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.gc.ZSinglegen\n@@ -33,1 +32,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseZGC -XX:-ZGenerational\n+ * @run main\/othervm -Xbatch -XX:+UseZGC\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWrongFlatArrayCopyStubWithZGC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews -XX:InlineFieldMaxFlatSize=160\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:InlineFieldMaxFlatSize=160\n@@ -121,18 +121,1 @@\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews -XX:InlineFieldMaxFlatSize=160\n- *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   runtime.valhalla.inlinetypes.InlineOops\n- *\/\n-\n-\/**\n- * @test id=ZGen\n- * @requires vm.gc.Z & vm.opt.final.ZGenerational\n- * @summary Test embedding oops into Inline types\n- * @modules java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n- * @enablePreview\n- * @compile Person.java InlineOops.java\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -XX:+ZGenerational -Xmx128m\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews -XX:InlineFieldMaxFlatSize=160\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:InlineFieldMaxFlatSize=160\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+java\/io\/IO\/IO.java                                              8337935 linux-ppc64le\n@@ -591,1 +592,1 @@\n-java\/nio\/Buffer\/LimitDirectMemory.java                          8340728 generic-all\n+java\/nio\/Buffer\/LimitDirectMemory.java                          8342849 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -326,11 +326,0 @@\n-\n-        \/\/ Special handling for ZGC modes\n-        var vmGCZ = vmGCProperty.test(GC.Z);\n-        var genZ = WB.getBooleanVMFlag(\"ZGenerational\");\n-        var genZIsDefault = WB.isDefaultVMFlag(\"ZGenerational\");\n-        \/\/ vm.gc.ZGenerational=true means:\n-        \/\/    vm.gc.Z is true and ZGenerational is either explicitly true, or default\n-        map.put(\"vm.gc.ZGenerational\", () -> \"\" + (vmGCZ && (genZ || genZIsDefault)));\n-        \/\/ vm.gc.ZSinglegen=true means:\n-        \/\/    vm.gc.Z is true and ZGenerational is either explicitly false, or default\n-        map.put(\"vm.gc.ZSinglegen\", () -> \"\" + (vmGCZ && (!genZ || genZIsDefault)));\n@@ -392,1 +381,0 @@\n-        vmOptFinalFlag(map, \"ZGenerational\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}