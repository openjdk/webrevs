{"files":[{"patch":"@@ -2766,0 +2766,11 @@\n+#ifdef ASSERT\n+bool PhiNode::can_push_inline_types_down(PhaseGVN* phase) {\n+  if (!can_be_inline_type()) {\n+    return false;\n+  }\n+\n+  ciInlineKlass* inline_klass;\n+  return can_push_inline_types_down(phase, true, inline_klass);\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -265,0 +265,1 @@\n+  DEBUG_ONLY(bool can_push_inline_types_down(PhaseGVN* phase);)\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -570,2 +571,1 @@\n-    \/\/ TODO 8315003 Re-enable\n-    } else if (use->is_CastPP() && false) {\n+    } else if (use->is_CastPP()) {\n@@ -589,1 +589,5 @@\n-          if (iff->Opcode() == Op_If && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp()) {\n+          \/\/ We may have Opaque4 node between If and Bool nodes.\n+          \/\/ Bail out in such case - we need to preserve Opaque4 for correct\n+          \/\/ processing predicates after loop opts.\n+          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n+          if (can_reduce) {\n@@ -592,1 +596,3 @@\n-            if ((opc == Op_CmpP || opc == Op_CmpN) && !can_reduce_cmp(n, iff_cmp)) {\n+            can_reduce = (opc == Op_CmpP || opc == Op_CmpN) && can_reduce_cmp(n, iff_cmp);\n+          }\n+          if (!can_reduce) {\n@@ -594,6 +600,3 @@\n-              if (TraceReduceAllocationMerges) {\n-                tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n-                n->dump(5);\n-              }\n-#endif\n-              return false;\n+            if (TraceReduceAllocationMerges) {\n+              tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n+              n->dump(5);\n@@ -601,0 +604,2 @@\n+#endif\n+            return false;\n@@ -1253,4 +1258,5 @@\n-      SafePointScalarObjectNode* sobj = mexp.create_scalarized_object_description(alloc, sfpt, &value_worklist);\n-      \/\/ TODO 8315003 Remove this bailout\n-      if (value_worklist.size() != 0) {\n-        return false;\n+#ifdef ASSERT\n+      const Type* res_type = alloc->result_cast()->bottom_type();\n+      if (res_type->is_inlinetypeptr() && !Compile::current()->has_circular_inline_type()) {\n+        PhiNode* phi = ophi->as_Phi();\n+        assert(!ophi->as_Phi()->can_push_inline_types_down(_igvn), \"missed earlier scalarization opportunity\");\n@@ -1258,0 +1264,2 @@\n+#endif\n+      SafePointScalarObjectNode* sobj = mexp.create_scalarized_object_description(alloc, sfpt, &value_worklist);\n@@ -1259,0 +1267,1 @@\n+        _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n@@ -1269,0 +1278,9 @@\n+\n+      \/\/ Scalarize inline types that were added to the safepoint.\n+      \/\/ Don't allow linking a constant oop (if available) for flat array elements\n+      \/\/ because Deoptimization::reassign_flat_array_elements needs field values.\n+      const bool allow_oop = !merge_t->is_flat();\n+      for (uint j = 0; j < value_worklist.size(); ++j) {\n+        InlineTypeNode* vt = value_worklist.at(j)->as_InlineType();\n+        vt->make_scalar_in_safepoints(_igvn, allow_oop);\n+      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -869,2 +869,0 @@\n-      \/\/ TODO 8315003 This starts to fail after JDK-8316991. Fix and re-enable.\n-      \/\/ assert(C->has_circular_inline_type(), \"non-circular inline types should have been replaced earlier\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java 8315003 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8315003\n+ * @summary Test that removing allocation merges of non-value and value object at EA is working properly.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @run main compiler.valhalla.inlinetypes.TestAllocationMergeAndFolding\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+public class TestAllocationMergeAndFolding {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        InlineTypes.getFramework()\n+                .addScenarios(InlineTypes.DEFAULT_SCENARIOS)\n+                .addScenarios(new Scenario(6, \"--enable-preview\", \"-XX:-UseCompressedOops\"))\n+                .addScenarios(new Scenario(7, \"--enable-preview\", \"-XX:+UseCompressedOops\"))\n+                .start();\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ALLOC)\n+    static int test(boolean flag) {\n+        Object o;\n+        if (flag) {\n+            o = new V(34);\n+        } else {\n+            o = new Object();\n+        }\n+        dontInline(); \/\/ Not inlined and thus we have a safepoint where keep phi(o) = [V, Object].\n+\n+        \/\/ 'o' escapes as store to 'f'. However, 'f' does not escape and can be removed. As a result, we can also remove\n+        \/\/ the allocations in both branches with EA after JDK-8287061. Since V has an inline type field v2, we put it\n+        \/\/ on a list to scalarize it as well. The improved allocation merge was disabled in Valhalla but is now enabled\n+        \/\/ and fixed with JDK-8315003.\n+        Foo f = new Foo(o);\n+        return f.i;\n+    }\n+\n+    @DontInline\n+    static void dontInline() {\n+    }\n+\n+    @Run(test = \"test\")\n+    static void run() {\n+        test(RANDOM.nextBoolean());\n+    }\n+\n+    static class Foo {\n+        Object o;\n+        int i;\n+\n+        Foo(Object o) {\n+            this.o = o;\n+        }\n+    }\n+\n+    static value class V {\n+        int i;\n+        V2 v2;\n+\n+        V(int i) {\n+            this.i = i;\n+            this.v2 = new V2();\n+        }\n+    }\n+\n+    static value class V2 {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -290,2 +290,0 @@\n-    \/\/ TODO 8315003 Re-enable\n-    \/*\n@@ -322,1 +320,0 @@\n-    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}