{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,17 @@\n+ * Defines the header and version information for jimage files.\n+ *\n+ * <p>Version number changes must be synced in a single change across all code\n+ * which reads\/writes jimage files, and code which tries to open a jimage file\n+ * with an unexpected version should fail.\n+ *\n+ * <p>Known jimage file code which needs updating on version change:\n+ * <ul>\n+ *     <li>src\/java.base\/share\/native\/libjimage\/imageFile.hpp\n+ * <\/ul>\n+ *\n+ * <p>Version history:\n+ * <ul>\n+ *     <li>{@code 1.0}: Original version.\n+ *     <li>{@code 1.1}: Change package entry flags to support preview mode.\n+ * <\/ul>\n+ *\n@@ -42,1 +59,1 @@\n-    public static final int MINOR_VERSION = 0;\n+    public static final int MINOR_VERSION = 1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageHeader.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -436,1 +436,1 @@\n-        MINOR_VERSION = 0\n+        MINOR_VERSION = 1\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Comparator;\n@@ -39,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -42,1 +44,0 @@\n- *\n@@ -47,1 +48,1 @@\n-        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+        return path.startsWith(\"\/packages\/\") || path.startsWith(\"\/modules\/\");\n@@ -53,1 +54,2 @@\n-    private static class Node {\n+    \/\/ Visible for testing only.\n+    static class Node {\n@@ -98,1 +100,2 @@\n-    private static final class ResourceNode extends Node {\n+    \/\/ Visible for testing only.\n+    static final class ResourceNode extends Node {\n@@ -105,1 +108,62 @@\n-    private static class PackageNode extends Node {\n+    \/**\n+     * A 2nd level package directory, {@code \"\/packages\/<package-name>\"}.\n+     *\n+     * <p>While package paths can exist within many modules, for each package\n+     * there is at most one module in which that package has resources.\n+     *\n+     * <p>For example, the package path {@code java\/util} exists in both the\n+     * {@code java.base} and {@code java.logging} modules. This means both\n+     * {@code \"\/packages\/java.util\/java.base\"} and\n+     * {@code \"\/packages\/java.util\/java.logging\"} will exist, but only\n+     * {@code \"java.base\"} entry will be marked as non-empty.\n+     *\n+     * <p>For preview mode however, a package that's empty in non-preview mode\n+     * can be non-empty in preview mode. Furthermore, packages which only exist\n+     * in preview mode (empty or not) need to be ignored in non-preview mode.\n+     *\n+     * <p>To account for this, the following flags are used for each module\n+     * entry in a package node:\n+     * <ul>\n+     *     <li>{@code HAS_NORMAL_CONTENT}: Packages with resources in normal\n+     *     mode. At most one entry will have this flag set.\n+     *     <li>{@code HAS_PREVIEW_CONTENT}: Packages with resources in preview\n+     *     mode. At most one entry will have this flag set.\n+     *     <li>{@code IS_PREVIEW_ONLY}: This is set for packages, empty\n+     *     or not, which exist only in preview mode.\n+     * <\/ul>\n+     *\n+     * <p>While there are 8 combinations of these 3 flags, some will never\n+     * occur (e.g. {@code HAS_NORMAL_CONTENT + IS_PREVIEW_ONLY}).\n+     *\n+     * <p>Package node entries are ordered such that:\n+     * <ul>\n+     *    <li>The unique entry marked as having content will be listed first\n+     *    (if it exists), regardless of any other flags.\n+     *    <li>Remaining empty entries are grouped, with preview-only entries\n+     *    listed at the end.\n+     *    <li>Within each group, entries are ordered by package name.\n+     * <\/ul>\n+     *\n+     * <p>When processing entries in normal (non preview) mode, entries marked\n+     * with {@code IS_PREVIEW_ONLY} must be ignored. If, after filtering, there\n+     * are no entries left, then the entire package must be ignored.\n+     *\n+     * <p>After this, in either mode, check the content flag(s) of the first\n+     * entry to determine if that module contains resources for the package.\n+     *\n+     * <p>If all entries are marked with {@code IS_PREVIEW_ONLY}\n+     *\/\n+    \/\/ Visible for testing only.\n+    static class PackageNode extends Node {\n+        private static final Comparator<PackageReference> ORDER_BY_FLAG =\n+                Comparator.comparing(PackageReference::isEmpty)\n+                        .thenComparing(PackageReference::isPreviewOnly)\n+                        .thenComparing(PackageReference::name);\n+\n+        \/** If set, the associated module has content in normal (non preview) mode. *\/\n+        private static final int PKG_FLAG_HAS_NORMAL_CONTENT = 0x1;\n+        \/** If set, the associated module has content in preview mode. *\/\n+        private static final int PKG_FLAG_HAS_PREVIEW_CONTENT = 0x2;\n+        \/** If set, this package only exists in preview mode. *\/\n+        private static final int PKG_FLAG_IS_PREVIEW_ONLY = 0x4;\n+\n@@ -108,1 +172,1 @@\n-         * more modules. A package with classes exist in only one module.\n+         * more modules. A package with content exists in only one module.\n@@ -111,1 +175,0 @@\n-\n@@ -113,1 +176,1 @@\n-            private final boolean isEmpty;\n+            private final int flags;\n@@ -115,1 +178,1 @@\n-            PackageReference(String name, boolean isEmpty) {\n+            PackageReference(String name, int flags) {\n@@ -117,1 +180,13 @@\n-                this.isEmpty = isEmpty;\n+                this.flags = flags;\n+            }\n+\n+            String name() {return name;}\n+\n+            int flags() {return flags;}\n+\n+            boolean isEmpty() {\n+                return (flags & (PKG_FLAG_HAS_NORMAL_CONTENT | PKG_FLAG_HAS_PREVIEW_CONTENT)) == 0;\n+            }\n+\n+            boolean isPreviewOnly() {\n+                return (flags & (PKG_FLAG_IS_PREVIEW_ONLY)) != 0;\n@@ -122,1 +197,5 @@\n-                return name + \"[empty:\" + isEmpty + \"]\";\n+                return String.format(\"%s [has_normal_content=%s, has_preview_content=%s, is_preview_only=%s]\",\n+                        name(),\n+                        (flags() & PKG_FLAG_HAS_NORMAL_CONTENT) != 0,\n+                        (flags() & PKG_FLAG_HAS_PREVIEW_CONTENT) != 0,\n+                        isPreviewOnly());\n@@ -126,1 +205,2 @@\n-        private final Map<String, PackageReference> references = new TreeMap<>();\n+        \/\/ Outside this class, callers should access via modules() \/ moduleCount().\n+        private final Map<String, PackageReference> unsortedReferences = new HashMap<>();\n@@ -132,4 +212,15 @@\n-        private void addReference(String name, boolean isEmpty) {\n-            PackageReference ref = references.get(name);\n-            if (ref == null || ref.isEmpty) {\n-                references.put(name, new PackageReference(name, isEmpty));\n+        private void addNormalReference(String moduleName, boolean hasContent) {\n+            if (unsortedReferences.containsKey(moduleName)) {\n+                throw new IllegalStateException(\"Reference already exists: \" + moduleName);\n+            }\n+            int flags = hasContent ? PKG_FLAG_HAS_NORMAL_CONTENT : 0;\n+            unsortedReferences.put(moduleName, new PackageReference(moduleName, flags));\n+        }\n+\n+        private void addOrUpdatePreviewReference(String moduleName, boolean hasContent) {\n+            PackageReference existingRef = unsortedReferences.get(moduleName);\n+            int flags = hasContent ? PKG_FLAG_HAS_PREVIEW_CONTENT : 0;\n+            if (existingRef == null) {\n+                flags |= PKG_FLAG_IS_PREVIEW_ONLY;\n+            } else {\n+                flags |= existingRef.flags();\n@@ -137,0 +228,11 @@\n+            \/\/ It is possible (but not worth checking for) that these flags are the same\n+            \/\/ as the existing reference (e.g. updating with an empty preview package).\n+            unsortedReferences.put(moduleName, new PackageReference(moduleName, flags));\n+        }\n+\n+        int moduleCount() {\n+            return unsortedReferences.size();\n+        }\n+\n+        Stream<PackageReference> modules() {\n+            return unsortedReferences.values().stream().sorted(ORDER_BY_FLAG);\n@@ -140,10 +242,3 @@\n-            boolean exists = false;\n-            for (PackageReference ref : references.values()) {\n-                if (!ref.isEmpty) {\n-                    if (exists) {\n-                        throw new RuntimeException(\"Multiple modules to contain package \"\n-                                + getName());\n-                    } else {\n-                        exists = true;\n-                    }\n-                }\n+            \/\/ If there's a module for which this package has content, it should be first and unique.\n+            if (modules().skip(1).anyMatch(ref -> !ref.isEmpty())) {\n+                throw new RuntimeException(\"Multiple modules to contain package \" + getName());\n@@ -157,1 +252,5 @@\n-    private static final class Tree {\n+    \/\/ Visible for testing only.\n+    static final class Tree {\n+        \/\/ When a package name is made for a path with preview resources, it\n+        \/\/ ends up with this prefix ('\/' become '.' during conversion).\n+        private static final String PREVIEW_PACKAGE_PREFIX = \"META-INF.preview.\";\n@@ -162,1 +261,0 @@\n-        private Node modules;\n@@ -165,1 +263,2 @@\n-        private Tree(List<String> paths) {\n+        \/\/ Visible for testing only.\n+        Tree(List<String> paths) {\n@@ -172,1 +271,1 @@\n-            modules = new Node(\"modules\", root);\n+            Node modules = new Node(\"modules\", root);\n@@ -176,0 +275,1 @@\n+            Map<String, Set<String>> moduleToPreviewPackage = new TreeMap<>();\n@@ -177,0 +277,1 @@\n+            Map<String, Set<String>> previewPackageToModule = new TreeMap<>();\n@@ -213,5 +314,6 @@\n-                                if (pkg != null && !pkg.startsWith(\"META-INF\")) {\n-                                    Set<String> pkgs = moduleToPackage.get(module);\n-                                    if (pkgs == null) {\n-                                        pkgs = new TreeSet<>();\n-                                        moduleToPackage.put(module, pkgs);\n+                                if (pkg != null) {\n+                                    if (!pkg.startsWith(\"META-INF\")) {\n+                                        moduleToPackage.computeIfAbsent(module, k -> new TreeSet<>()).add(pkg);\n+                                    } else if (pkg.startsWith(PREVIEW_PACKAGE_PREFIX)) {\n+                                        pkg = pkg.substring(PREVIEW_PACKAGE_PREFIX.length());\n+                                        moduleToPreviewPackage.computeIfAbsent(module, k -> new TreeSet<>()).add(pkg);\n@@ -219,1 +321,0 @@\n-                                    pkgs.add(pkg);\n@@ -225,5 +326,6 @@\n-                                if (pkg != null && !pkg.startsWith(\"META-INF\")) {\n-                                    Set<String> mods = packageToModule.get(pkg);\n-                                    if (mods == null) {\n-                                        mods = new TreeSet<>();\n-                                        packageToModule.put(pkg, mods);\n+                                if (pkg != null) {\n+                                    if (!pkg.startsWith(\"META-INF\")) {\n+                                        packageToModule.computeIfAbsent(pkg, k -> new TreeSet<>()).add(module);\n+                                    } else if (pkg.startsWith(PREVIEW_PACKAGE_PREFIX)) {\n+                                        pkg = pkg.substring(PREVIEW_PACKAGE_PREFIX.length());\n+                                        previewPackageToModule.computeIfAbsent(pkg, k -> new TreeSet<>()).add(module);\n@@ -231,1 +333,0 @@\n-                                    mods.add(module);\n@@ -241,11 +342,1 @@\n-            \/\/ The subset of package nodes that have some content.\n-            \/\/ These packages exist only in a single module.\n-            for (Map.Entry<String, Set<String>> entry : moduleToPackage.entrySet()) {\n-                for (String pkg : entry.getValue()) {\n-                    PackageNode pkgNode = new PackageNode(pkg, packages);\n-                    pkgNode.addReference(entry.getKey(), false);\n-                    directAccess.put(pkgNode.getPath(), pkgNode);\n-                }\n-            }\n-\n-            \/\/ All packages\n+            \/\/ Add all normal mode packages first.\n@@ -253,4 +344,6 @@\n-                \/\/ Do we already have a package node?\n-                PackageNode pkgNode = (PackageNode) packages.getChildren(entry.getKey());\n-                if (pkgNode == null) {\n-                    pkgNode = new PackageNode(entry.getKey(), packages);\n+                String pkgName = entry.getKey();\n+                PackageNode pkgNode = getPackageNode(pkgName);\n+                for (String module : entry.getValue()) {\n+                    boolean hasContent = moduleToPackage.containsKey(module)\n+                            && moduleToPackage.get(module).contains(pkgName);\n+                    pkgNode.addNormalReference(module, hasContent);\n@@ -258,0 +351,5 @@\n+            }\n+            \/\/ Then add or update for preview mode.\n+            for (Map.Entry<String, Set<String>> entry : previewPackageToModule.entrySet()) {\n+                String pkgName = entry.getKey();\n+                PackageNode pkgNode = getPackageNode(pkgName);\n@@ -259,1 +357,3 @@\n-                    pkgNode.addReference(module, true);\n+                    boolean hasContent = moduleToPreviewPackage.containsKey(module)\n+                            && moduleToPreviewPackage.get(module).contains(pkgName);\n+                    pkgNode.addOrUpdatePreviewReference(module, hasContent);\n@@ -261,1 +361,0 @@\n-                directAccess.put(pkgNode.getPath(), pkgNode);\n@@ -263,1 +362,2 @@\n-            \/\/ Validate that the packages are well formed.\n+\n+            \/\/ Validate that the packages are well-formed.\n@@ -270,1 +370,12 @@\n-        public String toResourceName(Node node) {\n+        private PackageNode getPackageNode(String pkgName) {\n+            PackageNode pkgNode = (PackageNode) packages.getChildren(pkgName);\n+            if (pkgNode == null) {\n+                pkgNode = new PackageNode(pkgName, packages);\n+                if (directAccess.put(pkgNode.getPath(), pkgNode) != null) {\n+                    throw new IllegalStateException(\"Package nodes must only be added once: \" + pkgNode);\n+                }\n+            }\n+            return pkgNode;\n+        }\n+\n+        private String toResourceName(Node node) {\n@@ -277,1 +388,1 @@\n-        public String getModule(Node node) {\n+        private String getModule(Node node) {\n@@ -293,1 +404,1 @@\n-        public String toPackageName(Node node) {\n+        private String toPackageName(Node node) {\n@@ -306,1 +417,1 @@\n-        public String removeRadical(Node node) {\n+        private String removeRadical(Node node) {\n@@ -343,1 +454,1 @@\n-                int size = pkgNode.references.size() * 8;\n+                int size = pkgNode.moduleCount() * 8;\n@@ -383,1 +494,1 @@\n-                int size = pkgNode.references.size() * 8;\n+                int size = pkgNode.moduleCount() * 8;\n@@ -386,2 +497,2 @@\n-                for (PackageNode.PackageReference mod : pkgNode.references.values()) {\n-                    buff.putInt(mod.isEmpty ? 1 : 0);\n+                pkgNode.modules().forEach(mod -> {\n+                    buff.putInt(mod.flags);\n@@ -389,1 +500,1 @@\n-                }\n+                });\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageResourcesTree.java","additions":180,"deletions":69,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Whitebox tests for ImageResourcesTree.\n+ * @modules jdk.jlink\/jdk.tools.jlink.internal\n+ * @build jdk.jlink\/jdk.tools.jlink.internal.ImageResourcesTreeTest\n+ * @run junit\/othervm jdk.jlink\/jdk.tools.jlink.internal.ImageResourcesTreeTest\n+ *\/\n+public class ImageResourcesTreeTestDriver {}\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/ImageResourcesTreeTestDriver.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+modules = \\\n+    jdk.jlink\/jdk.tools.jlink.internal\n+bootclasspath.dirs=.\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/TEST.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.tools.jlink.internal;\n+\n+import jdk.tools.jlink.internal.ImageResourcesTree.Node;\n+import jdk.tools.jlink.internal.ImageResourcesTree.PackageNode;\n+import jdk.tools.jlink.internal.ImageResourcesTree.PackageNode.PackageReference;\n+import jdk.tools.jlink.internal.ImageResourcesTree.ResourceNode;\n+import jdk.tools.jlink.internal.ImageResourcesTree.Tree;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class ImageResourcesTreeTest {\n+\n+    private static final String MODULES_PREFIX = \"\/modules\/\";\n+    private static final String PACKAGES_PREFIX = \"\/packages\/\";\n+\n+    \/\/ Package entry flags copied from ImageResourcesTree.\n+    private static final int PKG_FLAG_HAS_NORMAL_CONTENT = 0x1;\n+    private static final int PKG_FLAG_HAS_PREVIEW_CONTENT = 0x2;\n+    private static final int PKG_FLAG_IS_PREVIEW_ONLY = 0x4;\n+\n+    @Test\n+    public void directoryNodes() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/java\/util\/SomeOtherClass.class\",\n+                \"\/java.base\/java\/util\/resource.txt\",\n+                \"\/java.logging\/java\/util\/logging\/LoggingClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/OtherLoggingClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        \/\/ All paths from the root (but not the root itself).\n+        assertTrue(nodes.containsKey(\"\/modules\"));\n+        assertTrue(nodes.containsKey(\"\/modules\/java.base\"));\n+        assertTrue(nodes.containsKey(\"\/modules\/java.base\/java\"));\n+        assertTrue(nodes.containsKey(\"\/modules\/java.base\/java\/util\"));\n+        assertFalse(nodes.containsKey(\"\/\"));\n+\n+        \/\/ Check for mismatched modules.\n+        assertTrue(nodes.containsKey(\"\/modules\/java.logging\/java\/util\/logging\"));\n+        assertFalse(nodes.containsKey(\"\/modules\/java.base\/java\/util\/logging\"));\n+\n+        Set<String> dirPaths = nodes.keySet().stream()\n+                .filter(p -> p.startsWith(MODULES_PREFIX))\n+                .collect(Collectors.toSet());\n+        for (String path : dirPaths) {\n+            Node dir = nodes.get(path);\n+            assertFalse(dir instanceof ResourceNode, \"Unexpected resource: \" + dir);\n+            assertEquals(path, dir.getPath());\n+            assertTrue(path.endsWith(\"\/\" + dir.getName()), \"Unexpected directory name: \" + dir);\n+        }\n+    }\n+\n+    @Test\n+    public void resourceNodes() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/java\/util\/SomeOtherClass.class\",\n+                \"\/java.base\/java\/util\/resource.txt\",\n+                \"\/java.logging\/java\/util\/logging\/LoggingClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/OtherLoggingClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        \/\/ This map *does not* contain the resources, only the \"directory\" nodes.\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        assertContainsResources(\n+                nodes.get(\"\/modules\/java.base\/java\/util\"),\n+                \"SomeClass.class\", \"SomeOtherClass.class\", \"resource.txt\");\n+\n+        assertContainsResources(\n+                nodes.get(\"\/modules\/java.logging\/java\/util\/logging\"),\n+                \"LoggingClass.class\", \"OtherLoggingClass.class\");\n+    }\n+\n+    @Test\n+    public void expectedPackages() {\n+        \/\/ Paths are only to resources. Packages are inferred.\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+        Node packages = nodes.get(\"\/packages\");\n+        List<String> pkgNames = nodes.keySet().stream()\n+                .filter(p -> p.startsWith(PACKAGES_PREFIX))\n+                .map(p -> p.substring(PACKAGES_PREFIX.length()))\n+                .sorted()\n+                .toList();\n+\n+        assertEquals(List.of(\"java\", \"java.util\", \"java.util.logging\"), pkgNames);\n+        for (String pkgName : pkgNames) {\n+            PackageNode pkgNode = assertInstanceOf(PackageNode.class, packages.getChildren(pkgName));\n+            assertSame(nodes.get(PACKAGES_PREFIX + pkgNode.getName()), pkgNode);\n+        }\n+    }\n+\n+    @Test\n+    public void expectedPackageEntries() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+        PackageNode pkgUtil = getPackageNode(nodes, \"java.util\");\n+        assertEquals(2, pkgUtil.moduleCount());\n+        List<PackageReference> modRefs = pkgUtil.modules().toList();\n+\n+        List<String> modNames = modRefs.stream().map(PackageReference::name).toList();\n+        assertEquals(List.of(\"java.base\", \"java.logging\"), modNames);\n+\n+        PackageReference baseRef = modRefs.get(0);\n+        assertNonEmptyRef(baseRef, \"java.base\");\n+        assertEquals(PKG_FLAG_HAS_NORMAL_CONTENT, baseRef.flags());\n+\n+        PackageReference loggingRef = modRefs.get(1);\n+        assertEmptyRef(loggingRef, \"java.logging\");\n+        assertEquals(0, loggingRef.flags());\n+    }\n+\n+    @Test\n+    public void expectedPackageEntries_withPreviewResources() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/java\/util\/OtherClass.class\",\n+                \"\/java.base\/META-INF\/preview\/java\/util\/OtherClass.class\",\n+                \"\/java.logging\/java\/util\/logging\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+        PackageNode pkgUtil = getPackageNode(nodes, \"java.util\");\n+        List<PackageReference> modRefs = pkgUtil.modules().toList();\n+\n+        PackageReference baseRef = modRefs.get(0);\n+        assertNonEmptyRef(baseRef, \"java.base\");\n+        assertEquals(PKG_FLAG_HAS_NORMAL_CONTENT | PKG_FLAG_HAS_PREVIEW_CONTENT, baseRef.flags());\n+    }\n+\n+    @Test\n+    public void expectedPackageEntries_withPreviewOnlyPackages() {\n+        List<String> paths = List.of(\n+                \"\/java.base\/java\/util\/SomeClass.class\",\n+                \"\/java.base\/META-INF\/preview\/java\/util\/preview\/only\/PreviewClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        \/\/ Preview only package (with content).\n+        PackageNode nonEmptyPkg = getPackageNode(nodes, \"java.util.preview.only\");\n+        PackageReference nonEmptyRef = nonEmptyPkg.modules().findFirst().orElseThrow();\n+        assertNonEmptyPreviewOnlyRef(nonEmptyRef, \"java.base\");\n+        assertEquals(PKG_FLAG_IS_PREVIEW_ONLY | PKG_FLAG_HAS_PREVIEW_CONTENT, nonEmptyRef.flags());\n+\n+        \/\/ Preview only packages can be empty.\n+        PackageNode emptyPkg = getPackageNode(nodes, \"java.util.preview\");\n+        PackageReference emptyRef = emptyPkg.modules().findFirst().orElseThrow();\n+        assertEmptyPreviewOnlyRef(emptyRef, \"java.base\");\n+        assertEquals(PKG_FLAG_IS_PREVIEW_ONLY, emptyRef.flags());\n+    }\n+\n+    @Test\n+    public void expectedPackageEntries_sharedPackage() {\n+        \/\/ Resource in many modules define the same package (java.shared).\n+        \/\/ However, the package \"java.shared\" only has content in one module.\n+        \/\/ Order of test data is shuffled to show reordering in entry list.\n+        \/\/ \"java.preview\" would sort before after \"java.resource\" if it were\n+        \/\/ only sorted by name, but the preview flag has precedence.\n+        \/\/ Expect: content -> resource{1..6} -> preview{7..8}\n+        List<String> paths = List.of(\n+                \"\/java.resource1\/java\/shared\/one\/SomeClass.class\",\n+                \"\/java.preview7\/META-INF\/preview\/java\/shared\/foo\/SomeClass.class\",\n+                \"\/java.resource3\/java\/shared\/three\/SomeClass.class\",\n+                \"\/java.resource6\/java\/shared\/six\/SomeClass.class\",\n+                \"\/java.preview8\/META-INF\/preview\/java\/shared\/bar\/SomeClass.class\",\n+                \"\/java.resource5\/java\/shared\/five\/SomeClass.class\",\n+                \"\/java.content\/java\/shared\/MainPackageClass.class\",\n+                \"\/java.resource2\/java\/shared\/two\/SomeClass.class\",\n+                \"\/java.resource4\/java\/shared\/four\/SomeClass.class\");\n+\n+        Tree tree = new Tree(paths);\n+        Map<String, Node> nodes = tree.getMap();\n+\n+        \/\/ Preview only package (with content).\n+        PackageNode sharedPkg = getPackageNode(nodes, \"java.shared\");\n+        assertEquals(9, sharedPkg.moduleCount());\n+\n+        List<PackageReference> refs = sharedPkg.modules().toList();\n+        assertNonEmptyRef(refs.getFirst(), \"java.content\");\n+        assertEquals(PKG_FLAG_HAS_NORMAL_CONTENT, refs.getFirst().flags());\n+\n+        \/\/ Empty non-preview refs after non-empty ref.\n+        int idx = 1;\n+        for (PackageReference emptyRef : refs.subList(1, 7)) {\n+            assertEmptyRef(emptyRef, \"java.resource\" + idx++);\n+            assertEquals(0, emptyRef.flags());\n+        }\n+        \/\/ Empty preview-only refs last.\n+        for (PackageReference emptyRef : refs.subList(7, 9)) {\n+            assertEmptyPreviewOnlyRef(emptyRef, \"java.preview\" + idx++);\n+            assertEquals(PKG_FLAG_IS_PREVIEW_ONLY, emptyRef.flags());\n+        }\n+    }\n+\n+    static PackageNode getPackageNode(Map<String, Node> nodes, String pkgName) {\n+        return assertInstanceOf(PackageNode.class, nodes.get(PACKAGES_PREFIX + pkgName));\n+    }\n+\n+    static void assertContainsResources(Node dirNode, String... resourceNames) {\n+        for (String name : resourceNames) {\n+            Node node = assertInstanceOf(ResourceNode.class, dirNode.getChildren(name));\n+            assertEquals(name, node.getName());\n+            assertEquals(dirNode.getPath() + \"\/\" + name, node.getPath());\n+        }\n+    }\n+\n+    static void assertNonEmptyRef(PackageReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertFalse(ref.isEmpty(), \"Expected non-empty reference: \" + ref);\n+        assertFalse(ref.isPreviewOnly(), \"Expected not preview-only: \" + ref);\n+    }\n+\n+    static void assertEmptyRef(PackageReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertTrue(ref.isEmpty(), \"Expected empty reference: \" + ref);\n+        assertFalse(ref.isPreviewOnly(), \"Expected not preview-only: \" + ref);\n+    }\n+\n+    static void assertNonEmptyPreviewOnlyRef(PackageReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertFalse(ref.isEmpty(), \"Expected empty reference: \" + ref);\n+        assertTrue(ref.isPreviewOnly(), \"Expected preview-only: \" + ref);\n+    }\n+\n+    static void assertEmptyPreviewOnlyRef(PackageReference ref, String modName) {\n+        assertEquals(modName, ref.name(), \"Unexpected module name: \" + ref);\n+        assertTrue(ref.isEmpty(), \"Expected empty reference: \" + ref);\n+        assertTrue(ref.isPreviewOnly(), \"Expected preview-only: \" + ref);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/whitebox\/jdk.jlink\/jdk\/tools\/jlink\/internal\/ImageResourcesTreeTest.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"}]}