{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -1494,0 +1495,1 @@\n+     * The {@code AccessFlags} may depend on the class file format version of the class.\n@@ -1523,4 +1525,8 @@\n-        return AccessFlag.maskToAccessFlags((location == AccessFlag.Location.CLASS) ?\n-                                            getClassAccessFlagsRaw() & (~0x800) :\n-                                            getModifiers() & (~0x800), \/\/ suppress unspecified bit\n-                                            location);\n+        int accessFlags = (location == AccessFlag.Location.CLASS) ?\n+                getClassAccessFlagsRaw() : getModifiers();\n+        var cffv = ClassFileFormatVersion.fromMajor(getClassFileVersion() & 0xffff);\n+        if (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0) {\n+            \/\/ Ignore unspecified (0x800) access flag for current version\n+            accessFlags &= ~0x0800;\n+        }\n+        return AccessFlag.maskToAccessFlags(accessFlags, location, cffv);\n@@ -4862,1 +4868,2 @@\n-    private int getClassFileVersion() {\n+    \/* package-private *\/\n+    int getClassFileVersion() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -2676,0 +2677,4 @@\n+\n+            public int classFileFormatVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.misc.ValhallaFeatures;\n+\n@@ -188,0 +190,3 @@\n+     * For class file versions up to Valhalla or if Valhalla is not enabled,\n+     * {@code 0x0020} access flag bit is {@linkplain #SUPER SUPER access flag}; otherwise,\n+     * the {@code 0x0020} access flag bit is {@linkplain #IDENTITY IDENTITY access flag}.\n@@ -189,1 +194,9 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS_SUPER_VALHALLA,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+            @Override\n+            public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                return (cffv.compareTo(ClassFileFormatVersion.RELEASE_21) >= 0 &&\n+                        ValhallaFeatures.isEnabled()) ?\n+                        Location.SET_CLASS_SUPER_VALHALLA :\n+                        Location.SET_CLASS;}\n+        }),\n@@ -197,1 +210,9 @@\n-    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_INNER_CLASS, null),\n+    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_IDENTITY_VALHALLA,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+                @Override\n+                public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_21) >= 0 &&\n+                            ValhallaFeatures.isEnabled()) ?\n+                            Location.SET_CLASS_IDENTITY_VALHALLA :\n+                            Location.EMPTY_SET;}\n+            }),\n@@ -262,0 +283,1 @@\n+\n@@ -504,1 +526,1 @@\n-     * positions not support for the location in question\n+     * positions not supported for the location in question\n@@ -508,1 +530,0 @@\n-        int unmatchedFlags = mask;\n@@ -511,1 +532,1 @@\n-            if ((mask &  accessMask) != 0) {\n+            if ((mask & accessMask) != 0) {\n@@ -513,1 +534,4 @@\n-                unmatchedFlags = unmatchedFlags & ~accessMask;\n+                mask = mask & ~accessMask;\n+                if (mask == 0) {\n+                    break;      \/\/ no more mask bits\n+                }\n@@ -516,1 +540,1 @@\n-        if (unmatchedFlags != 0) {\n+        if (mask != 0) {\n@@ -518,1 +542,1 @@\n-                                               Integer.toHexString(unmatchedFlags) +\n+                                               Integer.toHexString(mask) +\n@@ -524,0 +548,36 @@\n+    \/**\n+     * {@return an unmodifiable set of access flags for the given mask value\n+     * appropriate for the location in question}\n+     *\n+     * @param mask bit mask of access flags\n+     * @param location context to interpret mask value\n+     * @param cffv the class file format version\n+     * @throws IllegalArgumentException if the mask contains bit\n+     * positions not supported for the location in question\n+     *\/\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location,\n+                                                    ClassFileFormatVersion cffv) {\n+        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n+        for (var accessFlag : AccessFlag.values()) {\n+            int accessMask = accessFlag.mask();\n+            if ((mask & accessMask) != 0) {\n+                var locations = accessFlag.locations(cffv);\n+                if (locations.contains(location)) {\n+                    result.add(accessFlag);\n+                    mask = mask & ~accessMask;\n+                    if (mask == 0) {\n+                        break;      \/\/ no more mask bits\n+                    }\n+                }\n+            }\n+        }\n+        if (mask != 0) {\n+            throw new IllegalArgumentException(\"Unmatched bit position 0x\" +\n+                                               Integer.toHexString(mask) +\n+                                               \" for location \" + location +\n+                                               \" for class file format version \" + cffv);\n+        }\n+        return Collections.unmodifiableSet(result);\n+    }\n+\n+\n@@ -610,0 +670,4 @@\n+        private static final Set<Location> SET_CLASS_SUPER_VALHALLA =\n+                ValhallaFeatures.isEnabled() ? EMPTY_SET : SET_CLASS_INNER_CLASS;\n+        private static final Set<Location> SET_CLASS_IDENTITY_VALHALLA =\n+                ValhallaFeatures.isEnabled() ? SET_CLASS_INNER_CLASS : EMPTY_SET;\n@@ -642,1 +706,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER, IDENTITY, VALUE,\n+                                Set.of(PUBLIC, FINAL, IDENTITY, VALUE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":73,"deletions":9,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+     * The {@code AccessFlags} may depend on the class file format version of the class.\n@@ -224,0 +225,2 @@\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n@@ -225,1 +228,2 @@\n-                                            AccessFlag.Location.METHOD);\n+                                            AccessFlag.Location.METHOD,\n+                                            cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -219,0 +219,2 @@\n+     * The {@code AccessFlags} may depend on the class file format version of the class.\n+     *\n@@ -225,1 +227,5 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD);\n+        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n+        var cffv = ClassFileFormatVersion.fromMajor(major);\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                AccessFlag.Location.FIELD,\n+                cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -586,0 +587,5 @@\n+    \/**\n+     * Returns the class file format version of the class.\n+     *\/\n+    int classFileFormatVersion(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER, IDENTITY]\")\n+@ExpectedClassFlags(\"[PUBLIC, FINAL, IDENTITY]\")\n@@ -257,1 +257,1 @@\n-@ExpectedClassFlags(\"[SUPER, IDENTITY, INTERFACE, ABSTRACT]\")\n+@ExpectedClassFlags(\"[IDENTITY, INTERFACE, ABSTRACT]\")\n@@ -263,1 +263,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, IDENTITY, ENUM]\")\n+@ExpectedClassFlags(\"[FINAL, IDENTITY, ENUM]\")\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * SUPER        invariant\n+ * SUPER        step\n@@ -90,1 +90,1 @@\n-            Set.of(SUPER, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n+            Set.of(SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n@@ -118,0 +118,4 @@\n+            new StepFunctionTC(SUPER,\n+                               Set.of(AccessFlag.Location.CLASS),\n+                               ClassFileFormatVersion.RELEASE_21),\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}