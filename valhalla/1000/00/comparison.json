{"files":[{"patch":"@@ -2404,4 +2404,0 @@\n-      \/\/ TODO 8325106 TestLWorld::test118 will fail with -DWarmup=10000 -DVerifyIR=false\n-      \/\/ because Parse::do_acmp uses Parse::do_if with custom ctrl_taken which puts uncommon traps on some paths and sets the next_bci incorrectly\n-      \/\/ It also seems that TestOptimizeUnstableIf is not working. It still passes, even if this optimization is turned off.\n-      if (jvms->should_reexecute()) continue;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-  void    do_if(BoolTest::mask btest, Node* c, bool new_path = false, Node** ctrl_taken = nullptr);\n+  void    do_if(BoolTest::mask btest, Node* c, bool can_trap = true, bool new_path = false, Node** ctrl_taken = nullptr);\n@@ -577,1 +577,1 @@\n-  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path);\n+  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path, bool can_trap = true);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1795,1 +1795,1 @@\n-void Parse::do_if(BoolTest::mask btest, Node* c, bool new_path, Node** ctrl_taken) {\n+void Parse::do_if(BoolTest::mask btest, Node* c, bool can_trap, bool new_path, Node** ctrl_taken) {\n@@ -1884,1 +1884,1 @@\n-      adjust_map_after_if(taken_btest, c, prob, branch_block);\n+      adjust_map_after_if(taken_btest, c, prob, branch_block, can_trap);\n@@ -1909,1 +1909,1 @@\n-    adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);\n+    adjust_map_after_if(untaken_btest, c, untaken_prob, next_block, can_trap);\n@@ -2112,0 +2112,9 @@\n+\n+  \/\/ Don't add traps to unstable if branches because additional checks are required to\n+  \/\/ decide if the operands are equal\/substitutable and we therefore shouldn't prune\n+  \/\/ branches for one if based on the profiling of the acmp branches.\n+  \/\/ Also, OptimizeUnstableIf would set an incorrect re-rexecution state because it\n+  \/\/ assumes that there is a 1-1 mapping between the if and the acmp branches and that\n+  \/\/ hitting a trap means that we will take the corresponding acmp branch on re-execution.\n+  const bool can_trap = true;\n+\n@@ -2114,1 +2123,1 @@\n-    do_if(btest, cmp, true);\n+    do_if(btest, cmp, !can_trap, true);\n@@ -2116,0 +2125,1 @@\n+      \/\/ Pointers are equal, operands must be equal\n@@ -2124,2 +2134,2 @@\n-      jvms()->set_should_reexecute(true);\n-      do_if(btest, cmp, false, &is_not_equal);\n+      \/\/ Pointers are not equal, but more checks are needed to determine if the operands are (not) substitutable\n+      do_if(btest, cmp, !can_trap, false, &is_not_equal);\n@@ -2265,0 +2275,1 @@\n+  \/\/ This is the last check, do_if can emit traps now.\n@@ -2269,1 +2280,1 @@\n-    do_if(btest, subst_cmp);\n+    do_if(btest, subst_cmp, can_trap);\n@@ -2276,1 +2287,1 @@\n-    do_if(btest, subst_cmp, false, &ctl);\n+    do_if(btest, subst_cmp, can_trap, false, &ctl);\n@@ -2332,1 +2343,1 @@\n-void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {\n+void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path, bool can_trap) {\n@@ -2344,1 +2355,1 @@\n-  if (path_is_suitable_for_uncommon_trap(prob)) {\n+  if (can_trap && path_is_suitable_for_uncommon_trap(prob)) {\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @summary Test that deoptimization at unstable ifs in acmp works as expected.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+EnableValhalla TestAcmpWithUnstableIf\n+ * @run main\/othervm -XX:+EnableValhalla -XX:CompileCommand=compileonly,TestAcmpWithUnstableIf::test* -Xbatch TestAcmpWithUnstableIf\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestAcmpWithUnstableIf {\n+\n+    public static final int     EQUAL = Utils.getRandomInstance().nextInt();\n+    public static final int NOT_EQUAL = Utils.getRandomInstance().nextInt();\n+\n+    static value class MyValue {\n+        int x;\n+\n+        public MyValue(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    public static int test1(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 == val2) {\n+            return resEqual;\n+        }\n+        return resNotEqual;\n+    }\n+\n+    public static int test2(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 == val2) {\n+            return resEqual;\n+        }\n+        return resNotEqual;\n+    }\n+\n+    public static int test3(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 == val2) {\n+            return resEqual;\n+        }\n+        return resNotEqual;\n+    }\n+\n+    public static int test4(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 == val2) {\n+            return resEqual;\n+        }\n+        return resNotEqual;\n+    }\n+\n+    public static int test5(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 != val2) {\n+            return resNotEqual;\n+        }\n+        return resEqual;\n+    }\n+\n+    public static int test6(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 != val2) {\n+            return resNotEqual;\n+        }\n+        return resEqual;\n+    }\n+\n+    public static int test7(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 != val2) {\n+            return resNotEqual;\n+        }\n+        return resEqual;\n+    }\n+\n+    public static int test8(MyValue val1, MyValue val2, int resEqual, int resNotEqual) {\n+        if (val1 != val2) {\n+            return resNotEqual;\n+        }\n+        return resEqual;\n+    }\n+\n+    public static void main(String[] args) {\n+        MyValue val = new MyValue(EQUAL);\n+        MyValue val_copy = new MyValue(EQUAL);\n+        MyValue val_diff = new MyValue(EQUAL + 1);\n+\n+        \/\/ Warmup\n+        for (int i = 0; i < 50_000; ++i) {\n+            \/\/ Equal arguments, same oop\n+            Asserts.assertEquals(test1(val, val, EQUAL, NOT_EQUAL), EQUAL);\n+            Asserts.assertEquals(test5(val, val, EQUAL, NOT_EQUAL), EQUAL);\n+\n+            \/\/ Equal arguments, different oop\n+            Asserts.assertEquals(test2(val, val_copy, EQUAL, NOT_EQUAL), EQUAL);\n+            Asserts.assertEquals(test6(val, val_copy, EQUAL, NOT_EQUAL), EQUAL);\n+\n+            \/\/ Different arguments\n+            Asserts.assertEquals(test3(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+            Asserts.assertEquals(test4(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+\n+            Asserts.assertEquals(test7(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+            Asserts.assertEquals(test8(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+        }\n+\n+        \/\/ Now trigger deoptimization\n+\n+        \/\/ Different arguments\n+        Asserts.assertEquals(test1(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+        Asserts.assertEquals(test2(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+\n+        Asserts.assertEquals(test5(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+        Asserts.assertEquals(test6(val, val_diff, EQUAL, NOT_EQUAL), NOT_EQUAL);\n+\n+        \/\/ Equal arguments, same oop\n+        Asserts.assertEquals(test3(val, val, EQUAL, NOT_EQUAL), EQUAL);\n+        Asserts.assertEquals(test7(val, val, EQUAL, NOT_EQUAL), EQUAL);\n+\n+        \/\/ Equal arguments, different oop\n+        Asserts.assertEquals(test4(val, val_copy, EQUAL, NOT_EQUAL), EQUAL);\n+        Asserts.assertEquals(test8(val, val_copy, EQUAL, NOT_EQUAL), EQUAL);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestAcmpWithUnstableIf.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -589,1 +589,1 @@\n-    @IR(failOn = {SUBSTITUTABILITY_TEST})\n+    @IR(counts = {IRNode.UNSTABLE_IF_TRAP, \" = 1\"})\n@@ -1039,1 +1039,1 @@\n-        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+        counts = {CLASS_CHECK_TRAP, \"= 2\"})\n@@ -1041,1 +1041,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {SUBSTITUTABILITY_TEST, \"= 2\"})\n@@ -1064,1 +1064,0 @@\n-\n@@ -1068,1 +1067,1 @@\n-        counts = {CLASS_CHECK_TRAP, \"= 1\"})\n+        counts = {CLASS_CHECK_TRAP, \"= 2\"})\n@@ -1070,1 +1069,1 @@\n-        counts = {SUBSTITUTABILITY_TEST, \"= 1\"})\n+        counts = {SUBSTITUTABILITY_TEST, \"= 2\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+                   .addFlags(\"-XX:CompileCommand=inline,java.lang.invoke.MethodHandleImpl::*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}