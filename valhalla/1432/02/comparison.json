{"files":[{"patch":"@@ -251,1 +251,1 @@\n-  if (frame_type == ASSERT_UNSET_FIELDS) {\n+  if (frame_type == EARLY_LARVAL) {\n@@ -282,1 +282,13 @@\n-    return nullptr;\n+    \/\/ Continue reading frame data\n+    if (at_end()) {\n+      _prev_frame->verifier()->verify_error(\n+        ErrorContext::bad_strict_fields(_prev_frame->offset(), _prev_frame),\n+        \"Early larval frame must be followed by a base frame\");\n+    }\n+\n+    frame_type = _stream->get_u1(CHECK_NULL);\n+    if (frame_type == EARLY_LARVAL) {\n+      _prev_frame->verifier()->verify_error(\n+        ErrorContext::bad_strict_fields(_prev_frame->offset(), _prev_frame),\n+        \"Early larval frame must be followed by a base frame\");\n+    }\n@@ -284,0 +296,1 @@\n+\n@@ -343,1 +356,1 @@\n-  if (frame_type < ASSERT_UNSET_FIELDS) {\n+  if (frame_type < EARLY_LARVAL) {\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-    ASSERT_UNSET_FIELDS = 246,\n+    EARLY_LARVAL = 246,\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -493,0 +493,3 @@\n+    case STRICT_FIELDS_MISMATCH:\n+      ss->print(\"Current frame's strict instance fields not compatible with stackmap.\");\n+      break;\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-     * @see <a href=\"https:\/\/cr.openjdk.org\/~dlsmith\/jep401\/jep401-20241108\/specs\/value-objects-jvms.html\">Specs<\/a>\n+     * @see <a href=\"https:\/\/cr.openjdk.org\/~dlsmith\/jep401\/jep401-20250409\/specs\/strict-fields-jvms.html\">Specs<\/a>\n@@ -108,0 +108,3 @@\n+     * @throws IllegalArgumentException if unset fields has entries but no\n+     * {@link SimpleVerificationTypeInfo#UNINITIALIZED_THIS uninitializedThis}\n+     * is present in {@code locals}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-     * The access flag {@code ACC_STRICT}, with a mask\n+     * The access flag {@code ACC_STRICT_INIT}, with a mask\n@@ -379,1 +379,1 @@\n-    STRICT_FIELD(Modifier.STRICT, false,\n+    STRICT_INIT(Modifier.STRICT, false,\n@@ -388,6 +388,1 @@\n-            }) {\n-        @Override\n-        public String toString() {\n-            return \"STRICT\";\n-        }\n-    },\n+            }),\n@@ -733,1 +728,1 @@\n-                                            TRANSIENT, SYNTHETIC, ENUM, STRICT_FIELD) :\n+                                            TRANSIENT, SYNTHETIC, ENUM, STRICT_INIT) :\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -209,1 +209,2 @@\n-                entries = new StackMapDecoder(classReader, payloadStart, ctx, StackMapDecoder.initFrameLocals(method)).entries();\n+                entries = new StackMapDecoder(classReader, payloadStart, ctx, StackMapDecoder.initFrameLocals(method),\n+                        StackMapDecoder.initFrameUnsets(method)).entries();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-                    case 246 -> {\n+                    case StackMapDecoder.EARLY_LARVAL -> {\n@@ -298,1 +298,2 @@\n-                        continue; \/\/ do not move bci\/create label\n+                        i--; \/\/ one more enclosed frame\n+                        continue;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -40,0 +41,1 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -52,0 +54,1 @@\n+import static java.lang.classfile.ClassFile.ACC_STRICT;\n@@ -58,1 +61,1 @@\n-                    ASSERT_UNSET_FIELDS = 246,\n+                    EARLY_LARVAL = 246,\n@@ -61,1 +64,1 @@\n-    private static final int RESERVED_TAGS_UPPER_LIMIT = ASSERT_UNSET_FIELDS; \/\/ not inclusive\n+    private static final int BASE_FRAMES_UPPER_LIMIT = SAME_LOCALS_1_STACK_ITEM_EXTENDED; \/\/ not inclusive\n@@ -68,0 +71,1 @@\n+    private final List<NameAndTypeEntry> initFrameUnsets;\n@@ -70,1 +74,2 @@\n-    StackMapDecoder(ClassReader classReader, int pos, LabelContext ctx, List<VerificationTypeInfo> initFrameLocals) {\n+    StackMapDecoder(ClassReader classReader, int pos, LabelContext ctx, List<VerificationTypeInfo> initFrameLocals,\n+                    List<NameAndTypeEntry> initFrameUnsets) {\n@@ -75,0 +80,1 @@\n+        this.initFrameUnsets = initFrameUnsets;\n@@ -111,0 +117,27 @@\n+    static List<NameAndTypeEntry> initFrameUnsets(MethodModel method) {\n+        return initFrameUnsets(method.parent().orElseThrow(),\n+                method.methodName());\n+    }\n+\n+    private static List<NameAndTypeEntry> initFrameUnsets(ClassModel clazz, Utf8Entry methodName) {\n+        if (!methodName.equalsString(ConstantDescs.INIT_NAME))\n+            return List.of();\n+        var l = new ArrayList<NameAndTypeEntry>(clazz.fields().size());\n+        for (var field : clazz.fields()) {\n+            if ((field.flags().flagsMask() & (ACC_STATIC | ACC_STRICT)) == ACC_STRICT) { \/\/ instance strict\n+                l.add(TemporaryConstantPool.INSTANCE.nameAndTypeEntry(field.fieldName(), field.fieldType()));\n+            }\n+        }\n+        return List.copyOf(l);\n+    }\n+\n+    private static List<NameAndTypeEntry> initFrameUnsets(MethodInfo mi, WritableField.UnsetField[] unsets) {\n+        if (!mi.methodName().equalsString(ConstantDescs.INIT_NAME))\n+            return List.of();\n+        var l = new ArrayList<NameAndTypeEntry>(unsets.length);\n+        for (var field : unsets) {\n+            l.add(TemporaryConstantPool.INSTANCE.nameAndTypeEntry(field.name(), field.type()));\n+        }\n+        return List.copyOf(l);\n+    }\n+\n@@ -119,0 +152,1 @@\n+        var prevUnsets = initFrameUnsets(mi, buf.getStrictInstanceFields());\n@@ -134,1 +168,1 @@\n-            writeFrame(buf, offset - prevOffset - 1, prevLocals, fr);\n+            writeFrame(buf, offset - prevOffset - 1, prevLocals, prevUnsets, fr);\n@@ -137,0 +171,11 @@\n+            prevUnsets = fr.unsetFields();\n+        }\n+    }\n+\n+    \/\/ In sync with StackMapGenerator::needsLarvalFrame\n+    private static boolean needsLarvalFrameForTransition(List<NameAndTypeEntry> prevUnsets, StackMapFrameInfo fr) {\n+        if (prevUnsets.equals(fr.unsetFields()))\n+            return false;\n+        if (!fr.locals().contains(SimpleVerificationTypeInfo.UNINITIALIZED_THIS)) {\n+            assert fr.unsetFields().isEmpty() : fr; \/\/ should be checked in StackMapFrameInfo constructor\n+            return false;\n@@ -138,0 +183,1 @@\n+        return true;\n@@ -140,1 +186,1 @@\n-    private static void writeFrame(BufWriterImpl out, int offsetDelta, List<VerificationTypeInfo> prevLocals, StackMapFrameInfo fr) {\n+    private static void writeFrame(BufWriterImpl out, int offsetDelta, List<VerificationTypeInfo> prevLocals, List<NameAndTypeEntry> prevUnsets, StackMapFrameInfo fr) {\n@@ -142,0 +188,6 @@\n+        \/\/ enclosing frames\n+        if (needsLarvalFrameForTransition(prevUnsets, fr)) {\n+            out.writeU1(EARLY_LARVAL);\n+            Util.writeListIndices(out, fr.unsetFields());\n+        }\n+        \/\/ base frame\n@@ -206,1 +258,1 @@\n-        List<NameAndTypeEntry> unsetFields = List.of();\n+        List<NameAndTypeEntry> unsetFields = initFrameUnsets;\n@@ -208,7 +260,11 @@\n-        int len = u2();\n-        var entries = new ArrayList<StackMapFrameInfo>(len);\n-        List<List<NameAndTypeEntry>> deferredUnsetFields = new ArrayList<>();\n-        for (int ei = 0; ei < len; ei++) {\n-            var oldLocals = locals;\n-            var oldStack = stack;\n-            int frameType = classReader.readU1(p++);\n+        var entries = new StackMapFrameInfo[u2()];\n+        for (int ei = 0; ei < entries.length; ei++) {\n+            int actualFrameType = classReader.readU1(p++);\n+            int frameType = actualFrameType; \/\/ effective frame type for parsing\n+            \/\/ enclosing frames handling\n+            if (frameType == EARLY_LARVAL) {\n+                unsetFields = readEntryList(p, NameAndTypeEntry.class);\n+                p += 2 + unsetFields.size() * 2;\n+                frameType = classReader.readU1(p++);\n+            }\n+            \/\/ base frame handling\n@@ -222,8 +278,2 @@\n-                if (frameType < RESERVED_TAGS_UPPER_LIMIT)\n-                    throw new IllegalArgumentException(\"Invalid stackmap frame type: \" + frameType);\n-                if (frameType == ASSERT_UNSET_FIELDS) {\n-                    unsetFields = readEntryList(p, NameAndTypeEntry.class);\n-                    p += 2 + unsetFields.size() * 2;\n-                    deferredUnsetFields.add(unsetFields);\n-                    continue; \/\/ defer entry until we can get the bci\n-                }\n+                if (frameType < BASE_FRAMES_UPPER_LIMIT)\n+                    throw new IllegalArgumentException(\"Invalid base frame type: \" + frameType);\n@@ -256,9 +306,3 @@\n-            Label label = ctx.getLabel(bci);\n-            if (!deferredUnsetFields.isEmpty()) {\n-                \/\/ technically we only have one assert at once, just in case\n-                \/\/ of duplicate asserts...\n-                for (var deferredList : deferredUnsetFields) {\n-                    entries.add(new StackMapFrameImpl(ASSERT_UNSET_FIELDS,\n-                                label, oldLocals, oldStack, deferredList));\n-                }\n-                deferredUnsetFields.clear();\n+            if (actualFrameType != EARLY_LARVAL && !unsetFields.isEmpty() && !locals.contains(SimpleVerificationTypeInfo.UNINITIALIZED_THIS)) {\n+                \/\/ clear unsets post larval\n+                unsetFields = List.of();\n@@ -266,4 +310,5 @@\n-            entries.add(new StackMapFrameImpl(frameType,\n-                        label,\n-                        locals,\n-                        stack));\n+            entries[ei] = new StackMapFrameImpl(actualFrameType,\n+                    ctx.getLabel(bci),\n+                    locals,\n+                    stack,\n+                    unsetFields);\n@@ -271,1 +316,1 @@\n-        return List.copyOf(entries);\n+        return List.of(entries);\n@@ -350,0 +395,10 @@\n+\n+            uninitializedThisCheck:\n+            if (!unsetFields.isEmpty()) {\n+                for (var local : locals) {\n+                    if (local == SimpleVerificationTypeInfo.UNINITIALIZED_THIS) {\n+                        break uninitializedThisCheck;\n+                    }\n+                }\n+                throw new IllegalArgumentException(\"unset fields requires uninitializedThis in locals\");\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":90,"deletions":35,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -399,0 +399,3 @@\n+                if (framesCount != (char) framesCount) {\n+                    throw generatorError(\"Too many frames: \" + framesCount);\n+                }\n@@ -400,1 +403,0 @@\n-                int extraFrameCount = 0;\n@@ -407,1 +409,1 @@\n-                    extraFrameCount += fr.writeTo(b, prevFrame, cp);\n+                    fr.writeTo(b, prevFrame, cp);\n@@ -410,7 +412,0 @@\n-                if (extraFrameCount > 0) {\n-                    int size = framesCount + extraFrameCount;\n-                    if (size != (char) size) {\n-                        throw generatorError(\"Too many frames: \" + size);\n-                    }\n-                    b.patchU2(countPos, size);\n-                }\n@@ -998,1 +993,4 @@\n-            return (dirty ? \"frame* @\" : \"frame @\") + offset + \" with locals \" + (locals == null ? \"[]\" : Arrays.asList(locals).subList(0, localsSize)) + \" and stack \" + (stack == null ? \"[]\" : Arrays.asList(stack).subList(0, stackSize));\n+            return (dirty ? \"frame* @\" : \"frame @\") + offset +\n+                    \" with locals \" + (locals == null ? \"[]\" : Arrays.asList(locals).subList(0, localsSize)) +\n+                    \" and stack \" + (stack == null ? \"[]\" : Arrays.asList(stack).subList(0, stackSize)) +\n+                    \" and unset fields \" + (unsetFields == null ? \"[]\" : Arrays.asList(unsetFields).subList(0, unsetFieldsSize));\n@@ -1263,1 +1261,1 @@\n-            if (!UnsetField.mismatches(myUnsets, myUnsetSize, targetUnsets, targetUnsetSize)) {\n+            if (UnsetField.matches(myUnsets, myUnsetSize, targetUnsets, targetUnsetSize)) {\n@@ -1321,0 +1319,10 @@\n+        boolean hasUninitializedThis() {\n+            int size = this.localsSize;\n+            var localVars = this.locals;\n+            for (int i = 0; i < size; i++) {\n+                if (localVars[i] == Type.UNITIALIZED_THIS_TYPE)\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n@@ -1326,6 +1334,15 @@\n-        int writeTo(BufWriterImpl out, Frame prevFrame, ConstantPoolBuilder cp) {\n-            int extraFrames = 0;\n-            if (UnsetField.mismatches(unsetFields, unsetFieldsSize, prevFrame.unsetFields, prevFrame.unsetFieldsSize)) {\n-                \/\/ Emit unset_fields frame\n-                out.writeU1U2(StackMapDecoder.ASSERT_UNSET_FIELDS, unsetFieldsSize);\n-                var array = unsetFields;\n+        \/\/ In sync with StackMapDecoder::needsLarvalFrameForTransition\n+        private boolean needsLarvalFrame(Frame prevFrame) {\n+            if (UnsetField.matches(unsetFields, unsetFieldsSize, prevFrame.unsetFields, prevFrame.unsetFieldsSize))\n+                return false;\n+            if (!hasUninitializedThis()) {\n+                assert unsetFieldsSize == 0 : this; \/\/ Should have been handled by processInvokeInstructions\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        void writeTo(BufWriterImpl out, Frame prevFrame, ConstantPoolBuilder cp) {\n+            \/\/ enclosing frames\n+            if (needsLarvalFrame(prevFrame)) {\n+                out.writeU1U2(StackMapDecoder.EARLY_LARVAL, unsetFieldsSize);\n@@ -1333,1 +1350,1 @@\n-                    var f = array[i];\n+                    var f = unsetFields[i];\n@@ -1336,1 +1353,0 @@\n-                extraFrames++;\n@@ -1338,0 +1354,1 @@\n+            \/\/ base frame\n@@ -1351,1 +1368,1 @@\n-                    return extraFrames;\n+                    return;\n@@ -1360,1 +1377,1 @@\n-                return extraFrames;\n+                return;\n@@ -1367,1 +1384,0 @@\n-            return extraFrames;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":38,"deletions":22,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.constantpool.ConstantPool;\n@@ -84,1 +83,1 @@\n-        public static boolean mismatches(UnsetField[] one, int sizeOne, UnsetField[] two, int sizeTwo) {\n+        public static boolean matches(UnsetField[] one, int sizeOne, UnsetField[] two, int sizeTwo) {\n@@ -86,1 +85,1 @@\n-                return true;\n+                return false;\n@@ -89,1 +88,1 @@\n-                    return true;\n+                    return false;\n@@ -92,1 +91,1 @@\n-            return false;\n+            return true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/WritableField.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                        ASSERT_UNSET_FIELDS = 246,\n+                        EARLY_LARVAL = 246,\n@@ -166,1 +166,1 @@\n-        private static final int RESERVED_TAGS_UPPER_LIMIT = ASSERT_UNSET_FIELDS; \/\/ not inclusive\n+        private static final int RESERVED_TAGS_UPPER_LIMIT = EARLY_LARVAL; \/\/ not inclusive\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    static final int ASSERT_UNSET_FIELDS = 246;\n+    static final int EARLY_LARVAL = 246;\n@@ -1267,1 +1267,1 @@\n-                StackMapTableEntry frame = code.stackMapTableBuffer[i];\n+                StackMapTableFrame frame = code.stackMapTableBuffer[i];\n@@ -1333,2 +1333,2 @@\n-    abstract static class StackMapTableEntry {\n-        abstract int getEntryType();\n+    abstract static class StackMapTableFrame {\n+        abstract int getFrameType();\n@@ -1337,1 +1337,1 @@\n-        StackMapTableEntry(int pc) {\n+        StackMapTableFrame(int pc) {\n@@ -1342,3 +1342,3 @@\n-            int entryType = getEntryType();\n-            writer.databuf.appendByte(entryType);\n-            if (writer.debugstackmap) System.out.println(\" frame_type=\" + entryType + \" bytecode offset \" + pc);\n+            int frameType = getFrameType();\n+            writer.databuf.appendByte(frameType);\n+            if (writer.debugstackmap) System.out.println(\" frame_type=\" + frameType + \" bytecode offset \" + pc);\n@@ -1347,1 +1347,1 @@\n-        static class SameFrame extends StackMapTableEntry {\n+        static class SameFrame extends StackMapTableFrame {\n@@ -1353,1 +1353,1 @@\n-            int getEntryType() {\n+            int getFrameType() {\n@@ -1359,1 +1359,1 @@\n-                if (getEntryType() == SAME_FRAME_EXTENDED) {\n+                if (getFrameType() == SAME_FRAME_EXTENDED) {\n@@ -1368,1 +1368,1 @@\n-        static class SameLocals1StackItemFrame extends StackMapTableEntry {\n+        static class SameLocals1StackItemFrame extends StackMapTableFrame {\n@@ -1376,1 +1376,1 @@\n-            int getEntryType() {\n+            int getFrameType() {\n@@ -1384,1 +1384,1 @@\n-                if (getEntryType() == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n+                if (getFrameType() == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n@@ -1397,1 +1397,1 @@\n-        static class ChopFrame extends StackMapTableEntry {\n+        static class ChopFrame extends StackMapTableFrame {\n@@ -1405,1 +1405,1 @@\n-            int getEntryType() { return frameType; }\n+            int getFrameType() { return frameType; }\n@@ -1416,1 +1416,1 @@\n-        static class AppendFrame extends StackMapTableEntry {\n+        static class AppendFrame extends StackMapTableFrame {\n@@ -1426,1 +1426,1 @@\n-            int getEntryType() { return frameType; }\n+            int getFrameType() { return frameType; }\n@@ -1441,1 +1441,1 @@\n-        static class FullFrame extends StackMapTableEntry {\n+        static class FullFrame extends StackMapTableFrame {\n@@ -1451,1 +1451,1 @@\n-            int getEntryType() { return FULL_FRAME; }\n+            int getFrameType() { return FULL_FRAME; }\n@@ -1475,1 +1475,2 @@\n-        static class AssertUnsetFields extends StackMapTableEntry {\n+        static class EarlyLarvalFrame extends StackMapTableFrame {\n+            final StackMapTableFrame base;\n@@ -1478,3 +1479,5 @@\n-            AssertUnsetFields(int pc, Set<VarSymbol> unsetFields) {\n-                super(pc);\n-                this.unsetFields = unsetFields;\n+            EarlyLarvalFrame(StackMapTableFrame base, Set<VarSymbol> unsetFields) {\n+                super(base.pc);\n+                Assert.check(!(base instanceof EarlyLarvalFrame));\n+                this.base = base;\n+                this.unsetFields = unsetFields == null ? Set.of() : unsetFields;\n@@ -1483,1 +1486,1 @@\n-            int getEntryType() { return ASSERT_UNSET_FIELDS; }\n+            int getFrameType() { return EARLY_LARVAL; }\n@@ -1490,1 +1493,1 @@\n-                    System.out.println(\"    # writing: AssertUnsetFields stackmap entry with \" + unsetFields.size() + \" fields\");\n+                    System.out.println(\"    # writing: EarlyLarval stackmap frame with \" + unsetFields.size() + \" fields\");\n@@ -1499,0 +1502,1 @@\n+                base.write(writer);\n@@ -1504,1 +1508,1 @@\n-        static StackMapTableEntry getInstance(Code.StackMapFrame this_frame,\n+        static StackMapTableFrame getInstance(Code.StackMapFrame this_frame,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableEntry;\n+import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableFrame;\n@@ -197,1 +197,1 @@\n-    boolean generateAssertUnsetFieldsFrame;\n+    boolean generateEarlyLarvalFrame;\n@@ -212,1 +212,1 @@\n-                boolean generateAssertUnsetFieldsFrame) {\n+                boolean generateEarlyLarvalFrame) {\n@@ -234,1 +234,1 @@\n-        this.generateAssertUnsetFieldsFrame = generateAssertUnsetFieldsFrame;\n+        this.generateEarlyLarvalFrame = generateEarlyLarvalFrame;\n@@ -1238,1 +1238,1 @@\n-    StackMapTableEntry[] stackMapTableBuffer = null;\n+    StackMapTableFrame[] stackMapTableBuffer = null;\n@@ -1327,0 +1327,1 @@\n+        boolean hasUninitalizedThis = false;\n@@ -1332,1 +1333,1 @@\n-                if (!(vtype instanceof UninitializedType))\n+                if (!(vtype instanceof UninitializedType)) {\n@@ -1334,0 +1335,3 @@\n+                } else if (vtype.hasTag(TypeTag.UNINITIALIZED_THIS)) {\n+                    hasUninitalizedThis = true;\n+                }\n@@ -1360,1 +1364,2 @@\n-        boolean generateAssertUnsetFieldsEntry = unsetFieldsAtPC != null && generateAssertUnsetFieldsFrame && !lastFrame.unsetFields.equals(unsetFieldsAtPC) ;\n+        boolean encloseWithEarlyLarvalFrame = unsetFieldsAtPC != null && generateEarlyLarvalFrame && hasUninitalizedThis\n+                && !lastFrame.unsetFields.equals(unsetFieldsAtPC);\n@@ -1363,1 +1368,1 @@\n-            stackMapTableBuffer = new StackMapTableEntry[20];\n+            stackMapTableBuffer = new StackMapTableFrame[20];\n@@ -1367,1 +1372,1 @@\n-                                    stackMapBufferSize + (generateAssertUnsetFieldsEntry ? 1 : 0));\n+                                    stackMapBufferSize);\n@@ -1370,2 +1375,3 @@\n-        if (generateAssertUnsetFieldsEntry) {\n-            stackMapTableBuffer[stackMapBufferSize++] = new StackMapTableEntry.AssertUnsetFields(pc, unsetFieldsAtPC);\n+        StackMapTableFrame tableFrame = StackMapTableFrame.getInstance(frame, lastFrame, types, pc);\n+        if (encloseWithEarlyLarvalFrame) {\n+            tableFrame = new StackMapTableFrame.EarlyLarvalFrame(tableFrame, unsetFieldsAtPC);\n@@ -1376,2 +1382,1 @@\n-        stackMapTableBuffer[stackMapBufferSize++] =\n-                StackMapTableEntry.getInstance(frame, lastFrame, types, pc);\n+        stackMapTableBuffer[stackMapBufferSize++] = tableFrame;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        generateAssertUnsetFieldsFrame = options.isSet(\"generateAssertUnsetFieldsFrame\");\n+        generateEarlyLarvalFrame = options.isSet(\"generateEarlyLarvalFrame\");\n@@ -148,1 +148,1 @@\n-    private boolean generateAssertUnsetFieldsFrame;\n+    private boolean generateEarlyLarvalFrame;\n@@ -1081,1 +1081,1 @@\n-                                        generateAssertUnsetFieldsFrame);\n+                                        generateEarlyLarvalFrame);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-                        int offsetDelta = frameType != 246 ? lr.labelToBci(frame.target()) - lastOffset - 1 : 0;\n+                        int offsetDelta = lr.labelToBci(frame.target()) - lastOffset - 1;\n@@ -575,1 +575,1 @@\n-                                printHeader(frameType, \"\/* assert_unset_fields *\/\");\n+                                printHeader(frameType, \"\/* early_larval *\/\");\n@@ -584,0 +584,6 @@\n+                                    \/\/ temporary: print the nested contents of early larval\n+                                    indent(+1);\n+                                    println(\"offset_delta = \" + offsetDelta);\n+                                    printMap(\"locals\", frame.locals(), lr);\n+                                    printMap(\"stack\", frame.stack(), lr);\n+                                    indent(-1);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-            if (!m.unsetFields().isEmpty()) {\n+            if (m.locals().contains(StackMapFrameInfo.SimpleVerificationTypeInfo.UNINITIALIZED_THIS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/StackMapWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateAssertUnsetFieldsFrame -XDnoLocalProxyVars StrictFinalInstanceFieldsTest.java\n+ * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateEarlyLarvalFrame -XDnoLocalProxyVars StrictFinalInstanceFieldsTest.java\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFinalInstanceFieldsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -39,0 +41,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n@@ -40,0 +44,1 @@\n+import java.util.Set;\n@@ -46,2 +51,1 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -55,0 +59,2 @@\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n@@ -71,1 +77,1 @@\n-        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        runtimeVerify(className, classBytes);\n@@ -75,7 +81,7 @@\n-        assertEquals(2 * 2, stackMaps.entries().size()); \/\/ if -> else, then -> end of if + asserts\n-        var elseAssertFrame = stackMaps.entries().get(0); \/\/ else jump from if\n-        assertEquals(246, elseAssertFrame.frameType());\n-        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseAssertFrame.unsetFields());\n-        var mergedAssertFrame = stackMaps.entries().get(2); \/\/ then jump to join else\n-        assertEquals(246, mergedAssertFrame.frameType());\n-        assertEquals(List.of(), mergedAssertFrame.unsetFields());\n+        assertEquals(2, stackMaps.entries().size(), \"if -> else, then -> end\");\n+        var elseFrame = stackMaps.entries().get(0);\n+        assertEquals(246, elseFrame.frameType(), \"if -> else\");\n+        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseFrame.unsetFields());\n+        var mergedFrame = stackMaps.entries().get(1);\n+        assertEquals(246, mergedFrame.frameType(), \"then -> merge\");\n+        assertEquals(List.of(), mergedFrame.unsetFields());\n@@ -89,0 +95,2 @@\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n@@ -109,1 +117,1 @@\n-        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        \/\/ runtimeVerify(className, classBytes); \/\/ TODO VM fix branching\n@@ -113,4 +121,7 @@\n-        assertEquals(2 + 1, stackMaps.entries().size()); \/\/ if -> else, then -> end of if, just one assert\n-        var assertFrame = stackMaps.entries().get(0); \/\/ else jump from if\n-        assertEquals(246, assertFrame.frameType());\n-        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), assertFrame.unsetFields());\n+        assertEquals(2, stackMaps.entries().size(), \"if -> else, then -> end\");\n+        var elseFrame = stackMaps.entries().get(0);\n+        assertEquals(246, elseFrame.frameType(), \"if -> else\");\n+        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseFrame.unsetFields());\n+        var mergedFrame = stackMaps.entries().get(1);\n+        assertNotEquals(246, mergedFrame.frameType(), \"then -> end, no redundant larval\");\n+        assertEquals(elseFrame.unsetFields(), mergedFrame.unsetFields(), \"larval carries over in parsing\");\n@@ -119,0 +130,1 @@\n+    \/\/ Also tests no larval_frame after ctor call\n@@ -125,0 +137,2 @@\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n@@ -153,1 +167,1 @@\n-        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        runtimeVerify(className, classBytes);\n@@ -155,1 +169,1 @@\n-        var ctorModel = classModel.methods().stream()\n+        var delegatingCtorModel = classModel.methods().stream()\n@@ -158,5 +172,7 @@\n-        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n-        assertEquals(2 + 1, stackMaps.entries().size()); \/\/ assert empty, if -> else, then -> end of if\n-        var assertFrame = stackMaps.entries().get(0); \/\/ assert empty for if -> else\n-        assertEquals(246, assertFrame.frameType());\n-        assertEquals(List.of(), assertFrame.unsetFields());\n+        var stackMaps = delegatingCtorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2, stackMaps.entries().size(), \"if -> else, then -> merge\");\n+        var elseFrame = stackMaps.entries().get(0);\n+        assertNotEquals(246, elseFrame.frameType(), \"if -> else, no uninitializedThis, no larval frame needed to clear unset\");\n+        assertEquals(List.of(), elseFrame.unsetFields(), \"cleared by constructor call\");\n+        var mergeFrame = stackMaps.entries().get(1);\n+        assertNotEquals(246, mergeFrame.frameType(), \"then -> merge\");\n@@ -170,0 +186,2 @@\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n@@ -191,1 +209,1 @@\n-        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        runtimeVerify(className, classBytes);\n@@ -195,1 +213,9 @@\n-        assertEquals(2, stackMaps.entries().size(), () -> stackMaps.entries().toString()); \/\/ no assert frames\n+        assertEquals(2, stackMaps.entries().size(), () -> stackMaps.entries().toString());\n+        var elseFrame = stackMaps.entries().get(0);\n+        var mergeFrame = stackMaps.entries().get(1);\n+        assertNotEquals(246, elseFrame.frameType(), \"if -> else, no redundant larval frames\");\n+        assertNotEquals(246, mergeFrame.frameType(), \"then -> merge, no redundant larval frames\");\n+        var cpb = ConstantPoolBuilder.of();\n+        assertEquals(Set.of(cpb.nameAndTypeEntry(\"fsf\", CD_int), cpb.nameAndTypeEntry(\"fs\", CD_int)),\n+                Set.copyOf(elseFrame.unsetFields()), \"retains initial unsets\");\n+        assertEquals(elseFrame.unsetFields(), mergeFrame.unsetFields(), \"no unset change\");\n@@ -203,0 +229,2 @@\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n@@ -214,1 +242,1 @@\n-                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void) \/\/ unset not clear here\n@@ -218,0 +246,1 @@\n+    \/\/ Ensures stack maps are updated when fields are transformed to be strict\n@@ -222,0 +251,1 @@\n+        \/\/ this class has no strict\n@@ -223,0 +253,2 @@\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n@@ -248,1 +280,58 @@\n-        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        runtimeVerify(className, classBytes);\n+        var classModel = ClassFile.of().parse(classBytes);\n+        var ctorModel = classModel.methods().getFirst();\n+        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2, stackMaps.entries().size(), \"if -> else, then -> merge\");\n+        var elseFrame = stackMaps.entries().get(0);\n+        assertEquals(246, elseFrame.frameType(), \"if -> else\");\n+        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseFrame.unsetFields());\n+        var mergedFrame = stackMaps.entries().get(1);\n+        assertEquals(246, mergedFrame.frameType(), \"then -> merge\");\n+        assertEquals(List.of(), mergedFrame.unsetFields());\n+    }\n+\n+    @Test\n+    void explicitWriteFramesTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        var classBytes = ClassFile.of(StackMapsOption.DROP_STACK_MAPS).build(classDesc, clb -> clb\n+                .withVersion(latestMajorVersion(), PREVIEW_MINOR_VERSION)\n+                .withFlags(ACC_PUBLIC | ACC_IDENTITY)\n+                .withField(\"fs\", CD_int, ACC_STRICT)\n+                .withField(\"fsf\", CD_int, ACC_STRICT | ACC_FINAL)\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> {\n+                    var frames = new ArrayList<StackMapFrameInfo>();\n+                    cob.aload(0)\n+                       .iconst_0()\n+                       .ifThenElse(thb -> thb\n+                               .iconst_3()\n+                               .putfield(classDesc, \"fsf\", CD_int), elb -> {\n+                           \/\/ jump to else - fs, fsf unset\n+                           frames.add(StackMapFrameInfo.of(elb.startLabel(),\n+                                   List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.UNINITIALIZED_THIS),\n+                                   List.of(),\n+                                   List.of(elb.constantPool().nameAndTypeEntry(\"fs\", CD_int),\n+                                           elb.constantPool().nameAndTypeEntry(\"fsf\", CD_int))));\n+                           elb.iconst_2()\n+                              .putfield(classDesc, \"fsf\", CD_int);\n+                       });\n+                    \/\/ merge - fs unset\n+                    frames.add(StackMapFrameInfo.of(cob.newBoundLabel(),\n+                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.UNINITIALIZED_THIS),\n+                            List.of(),\n+                            List.of(cob.constantPool().nameAndTypeEntry(\"fs\", CD_int))));\n+                    cob.aload(0)\n+                       .iconst_5()\n+                       .putfield(classDesc, \"fs\", CD_int)\n+                       .aload(0)\n+                       .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                       .iconst_1()\n+                       .ifThen(thb -> thb.iconst_3().pop());\n+                    \/\/ post larval - no uninitializedThis, empty unsets\n+                    frames.add(StackMapFrameInfo.of(cob.newBoundLabel(),\n+                            List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(classDesc)),\n+                            List.of()));\n+                    cob.return_()\n+                       .with(StackMapTableAttribute.of(frames));\n+                }));\n+        \/\/ runtimeVerify(className, classBytes); \/\/ TODO VM fix\n@@ -252,7 +341,22 @@\n-        assertEquals(2 * 2, stackMaps.entries().size()); \/\/ if -> else, then -> end of if + asserts\n-        var elseAssertFrame = stackMaps.entries().get(0); \/\/ else jump from if\n-        assertEquals(246, elseAssertFrame.frameType());\n-        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseAssertFrame.unsetFields());\n-        var mergedAssertFrame = stackMaps.entries().get(2); \/\/ then jump to join else\n-        assertEquals(246, mergedAssertFrame.frameType());\n-        assertEquals(List.of(), mergedAssertFrame.unsetFields());\n+        assertEquals(3, stackMaps.entries().size(), \"if -> else, then -> end, post larval\");\n+        var elseFrame = stackMaps.entries().get(0);\n+        assertEquals(List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.UNINITIALIZED_THIS), elseFrame.locals());\n+        \/\/ frame type for else may or may not be 246... no unset field changes but may have reorders\n+        assertEquals(2, elseFrame.unsetFields().size(), \"if -> else\");\n+        var cpb = ConstantPoolBuilder.of();\n+        assertEquals(Set.of(cpb.nameAndTypeEntry(\"fs\", CD_int), cpb.nameAndTypeEntry(\"fsf\", CD_int)),\n+                Set.copyOf(elseFrame.unsetFields()));\n+        var mergedFrame = stackMaps.entries().get(1);\n+        assertEquals(List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.UNINITIALIZED_THIS), mergedFrame.locals());\n+        assertEquals(246, mergedFrame.frameType(), \"then -> merge\");\n+        assertEquals(List.of(cpb.nameAndTypeEntry(\"fs\", CD_int)), mergedFrame.unsetFields());\n+        var postLarvalFrame = stackMaps.entries().get(2);\n+        assertNotEquals(246, postLarvalFrame.frameType(), \"postLarval\"); \/\/ no larval frame here\n+        assertEquals(List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(classDesc)), postLarvalFrame.locals());\n+        assertEquals(List.of(), postLarvalFrame.unsetFields());\n+    }\n+\n+    private static void runtimeVerify(String className, byte[] classBytes) {\n+        var clazz = assertDoesNotThrow(() -> ByteCodeLoader.load(className, classBytes));\n+        var lookup = assertDoesNotThrow(() -> MethodHandles.privateLookupIn(clazz, MethodHandles.lookup()));\n+        assertDoesNotThrow(() -> lookup.ensureInitialized(clazz)); \/\/ forces verification\n","filename":"test\/jdk\/jdk\/classfile\/StrictStackMapsTest.java","additions":137,"deletions":33,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @enablePreview\n@@ -37,1 +38,0 @@\n- *     jdk.jdeps\/com.sun.tools.classfile\n@@ -44,0 +44,8 @@\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -45,0 +53,1 @@\n+import java.util.Locale;\n@@ -49,15 +58,0 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_NameAndType_info;\n-import com.sun.tools.classfile.ConstantPool.CPRefInfo;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.StackMapTable_attribute;\n-\n@@ -652,2 +646,2 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    Assert.check((classFile.access_flags.flags & Flags.ACC_IDENTITY) != 0);\n+                    var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                    Assert.check(classFile.flags().has(AccessFlag.IDENTITY));\n@@ -697,2 +691,2 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                Assert.check(classFile.access_flags.is(Flags.ACC_IDENTITY));\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                Assert.check(classFile.flags().has(AccessFlag.IDENTITY));\n@@ -710,2 +704,2 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                switch (classFile.getName()) {\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                switch (classFile.thisClass().asInternalName()) {\n@@ -713,1 +707,1 @@\n-                        Assert.check((classFile.access_flags.flags & (Flags.FINAL)) != 0);\n+                        Assert.check((classFile.flags().flagsMask() & (Flags.FINAL)) != 0);\n@@ -716,1 +710,1 @@\n-                        Assert.check((classFile.access_flags.flags & (Flags.ABSTRACT)) != 0);\n+                        Assert.check((classFile.flags().flagsMask() & (Flags.ABSTRACT)) != 0);\n@@ -743,5 +737,5 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Field field : classFile.fields) {\n-                    if (!field.access_flags.is(Flags.STATIC)) {\n-                        Set<String> fieldFlags = field.access_flags.getFieldFlags();\n-                        Assert.check(fieldFlags.size() == 2 && fieldFlags.contains(\"ACC_FINAL\") && fieldFlags.contains(\"ACC_STRICT\"));\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                for (var field : classFile.fields()) {\n+                    if (!field.flags().has(AccessFlag.STATIC)) {\n+                        Set<AccessFlag> fieldFlags = field.flags().flags();\n+                        Assert.check(fieldFlags.size() == 2 && fieldFlags.contains(AccessFlag.FINAL) && fieldFlags.contains(AccessFlag.STRICT_INIT));\n@@ -774,5 +768,6 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    for (Field field : classFile.fields) {\n-                        if (!field.access_flags.is(Flags.STATIC)) {\n-                            Set<String> fieldFlags = field.access_flags.getFieldFlags();\n-                            Assert.check(fieldFlags.contains(\"ACC_STRICT\"));\n+                    var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                    Assert.check(classFile.flags().has(AccessFlag.IDENTITY));\n+                    for (var field : classFile.fields()) {\n+                        if (!field.flags().has(AccessFlag.STATIC)) {\n+                            Set<AccessFlag> fieldFlags = field.flags().flags();\n+                            Assert.check(fieldFlags.contains(AccessFlag.STRICT_INIT));\n@@ -836,2 +831,2 @@\n-            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,return,\";\n-            String expectedCodeSequenceRecord = \"aload_0,iload_1,putfield,aload_0,invokespecial,return,\";\n+            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,return\";\n+            String expectedCodeSequenceRecord = \"aload_0,iload_1,putfield,aload_0,invokespecial,return\";\n@@ -840,15 +835,18 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                        Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                        String foundCodeSequence = \"\";\n-                        for (Instruction inst: code.getInstructions()) {\n-                            foundCodeSequence += inst.getMnemonic() + \",\";\n-                        }\n-                        if (!data.isRecord) {\n-                            Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n-                        } else {\n-                            Assert.check(expectedCodeSequenceRecord.equals(foundCodeSequence));\n-                        }\n-                    }\n-                }\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                classFile.methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(ConstantDescs.INIT_NAME))\n+                        .map(mm -> mm.findAttribute(Attributes.code()).orElseThrow())\n+                        .forEach(code -> {\n+                            List<String> mnemonics = new ArrayList<>();\n+                            for (var coe : code) {\n+                                if (coe instanceof Instruction inst) {\n+                                    mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n+                                }\n+                            }\n+                            var foundCodeSequence = String.join(\",\", mnemonics);\n+                            if (!data.isRecord) {\n+                                Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n+                            } else {\n+                                Assert.check(expectedCodeSequenceRecord.equals(foundCodeSequence));\n+                            }\n+                        });\n@@ -868,13 +866,18 @@\n-        String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,iconst_0,putfield,aload_0,invokespecial,getstatic,iconst_0,invokevirtual,return,\";\n-        File dir = assertOK(true, source);\n-        for (final File fileEntry : dir.listFiles()) {\n-            ClassFile classFile = ClassFile.read(fileEntry);\n-            for (Method method : classFile.methods) {\n-                if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                    String foundCodeSequence = \"\";\n-                    for (Instruction inst: code.getInstructions()) {\n-                        foundCodeSequence += inst.getMnemonic() + \",\";\n-                    }\n-                    Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n-                }\n+        {\n+            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,iconst_0,putfield,aload_0,invokespecial,getstatic,iconst_0,invokevirtual,return\";\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                classFile.methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(ConstantDescs.INIT_NAME))\n+                        .map(mm -> mm.findAttribute(Attributes.code()).orElseThrow())\n+                        .forEach(code -> {\n+                            List<String> mnemonics = new ArrayList<>();\n+                            for (var coe : code) {\n+                                if (coe instanceof Instruction inst) {\n+                                    mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n+                                }\n+                            }\n+                            var foundCodeSequence = String.join(\",\", mnemonics);\n+                            Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n+                        });\n@@ -1055,1 +1058,1 @@\n-            expectedCodeSequence = \"aload_0,new,dup,invokespecial,putfield,aload_0,invokespecial,return,\";\n+            var expectedCodeSequence = \"aload_0,new,dup,invokespecial,putfield,aload_0,invokespecial,return\";\n@@ -1057,1 +1060,1 @@\n-                dir = assertOK(true, src);\n+                File dir = assertOK(true, src);\n@@ -1059,8 +1062,10 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    if (classFile.getName().equals(\"Test\")) {\n-                        for (Method method : classFile.methods) {\n-                            if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                                Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                                String foundCodeSequence = \"\";\n-                                for (Instruction inst: code.getInstructions()) {\n-                                    foundCodeSequence += inst.getMnemonic() + \",\";\n+                    var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                    if (classFile.thisClass().name().equalsString(\"Test\")) {\n+                        for (var method : classFile.methods()) {\n+                            if (method.methodName().equalsString(\"<init>\")) {\n+                                var code = method.findAttribute(Attributes.code()).orElseThrow();\n+                                List<String> mnemonics = new ArrayList<>();\n+                                for (var coe : code) {\n+                                    if (coe instanceof Instruction inst) {\n+                                        mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n+                                    }\n@@ -1068,0 +1073,1 @@\n+                                var foundCodeSequence = String.join(\",\", mnemonics);\n@@ -1155,13 +1161,13 @@\n-        dir = assertOK(true, source);\n-        File fileEntry = dir.listFiles()[0];\n-        ClassFile classFile = ClassFile.read(fileEntry);\n-        expectedCodeSequence = \"putfield i,putfield y,\";\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                String foundCodeSequence = \"\";\n-                for (Instruction inst: code.getInstructions()) {\n-                    if (inst.getMnemonic().equals(\"putfield\")) {\n-                        CPRefInfo refInfo = (CPRefInfo)classFile.constant_pool.get(inst.getShort(1));\n-                        CONSTANT_NameAndType_info nameAndType = refInfo.getNameAndTypeInfo();\n-                        foundCodeSequence += inst.getMnemonic() + \" \" + nameAndType.getName() + \",\";\n+        {\n+            File dir = assertOK(true, source);\n+            File fileEntry = dir.listFiles()[0];\n+            var expectedCodeSequence = \"putfield i,putfield y\";\n+            var classFile = ClassFile.of().parse(fileEntry.toPath());\n+            for (var method : classFile.methods()) {\n+                if (method.methodName().equalsString(\"<init>\")) {\n+                    var code = method.findAttribute(Attributes.code()).orElseThrow();\n+                    List<String> mnemonics = new ArrayList<>();\n+                    for (var coe : code) {\n+                        if (coe instanceof FieldInstruction inst && inst.opcode() == Opcode.PUTFIELD) {\n+                            mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT) + \" \" + inst.name());\n+                        }\n@@ -1169,0 +1175,2 @@\n+                    var foundCodeSequence = String.join(\",\", mnemonics);\n+                    Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n@@ -1170,1 +1178,0 @@\n-                Assert.check(foundCodeSequence.equals(expectedCodeSequence), foundCodeSequence);\n@@ -1193,17 +1200,10 @@\n-        ClassFile classFile = ClassFile.read(fileEntry);\n-        String expectedCodeSequenceThisCallingConst = \"aload_0,iconst_0,invokespecial,return,\";\n-        String expectedCodeSequenceNonThisCallingConst = \"aload_0,iload_1,putfield,aload_0,invokespecial,return,\";\n-        for (Method method : classFile.methods) {\n-            if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                if (method.descriptor.getParameterCount(classFile.constant_pool) == 0) {\n-                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                    String foundCodeSequence = \"\";\n-                    for (Instruction inst: code.getInstructions()) {\n-                        foundCodeSequence += inst.getMnemonic() + \",\";\n-                    }\n-                    Assert.check(expectedCodeSequenceThisCallingConst.equals(foundCodeSequence));\n-                } else {\n-                    Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                    String foundCodeSequence = \"\";\n-                    for (Instruction inst: code.getInstructions()) {\n-                        foundCodeSequence += inst.getMnemonic() + \",\";\n+        String expectedCodeSequenceThisCallingConst = \"aload_0,iconst_0,invokespecial,return\";\n+        String expectedCodeSequenceNonThisCallingConst = \"aload_0,iload_1,putfield,aload_0,invokespecial,return\";\n+        var classFile = ClassFile.of().parse(fileEntry.toPath());\n+        for (var method : classFile.methods()) {\n+            if (method.methodName().equalsString(\"<init>\")) {\n+                var code = method.findAttribute(Attributes.code()).orElseThrow();\n+                List<String> mnemonics = new ArrayList<>();\n+                for (var coe : code) {\n+                    if (coe instanceof Instruction inst) {\n+                        mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n@@ -1211,1 +1211,0 @@\n-                    Assert.check(expectedCodeSequenceNonThisCallingConst.equals(foundCodeSequence));\n@@ -1213,0 +1212,4 @@\n+                var foundCodeSequence = String.join(\",\", mnemonics);\n+                var expected = method.methodTypeSymbol().parameterCount() == 0 ?\n+                        expectedCodeSequenceThisCallingConst : expectedCodeSequenceNonThisCallingConst;\n+                Assert.check(expected.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n@@ -1453,1 +1456,1 @@\n-                    \"-XDgenerateAssertUnsetFieldsFrame\",\n+                    \"-XDgenerateEarlyLarvalFrame\",\n@@ -1455,0 +1458,1 @@\n+                    \"-XDdebug.stackmap\",\n@@ -1470,1 +1474,1 @@\n-                                    if (a) { \/\/ assert_unset_fields {x, y}\n+                                    if (a) { \/\/ early_larval {x, y}\n@@ -1472,1 +1476,1 @@\n-                                        if (b) { \/\/ assert_unset_fields {y}\n+                                        if (b) { \/\/ early_larval {y}\n@@ -1474,1 +1478,1 @@\n-                                        } else { \/\/ assert_unset_fields {y}\n+                                        } else { \/\/ early_larval {y}\n@@ -1477,1 +1481,1 @@\n-                                    } else { \/\/ assert_unset_fields {x, y}\n+                                    } else { \/\/ early_larval {x, y}\n@@ -1485,1 +1489,1 @@\n-                            new int[] {246, 21, 246, 7, 246, 9},\n+                            new int[] {246, 246, 246},\n@@ -1511,1 +1515,1 @@\n-                            new int[] {20, 12, 246, 10},\n+                            new int[] {20, 12, 246},\n@@ -1514,0 +1518,28 @@\n+                    ),\n+                    new Data(\n+                            \"\"\"\n+                            import jdk.internal.vm.annotation.Strict;\n+                            class Test {\n+                                @Strict\n+                                final int x;\n+                                @Strict\n+                                final int y;\n+                                Test(int n) {\n+                                    if (n % 3 == 0) {\n+                                        x = n \/ 3;\n+                                    } else { \/\/ no unset change\n+                                        x = n + 2;\n+                                    } \/\/ early_larval {y}\n+                                    y = n >>> 3;\n+                                    super();\n+                                    if ((char) n != n) {\n+                                        n -= 5;\n+                                    } \/\/ no uninitializedThis - automatically cleared unsets\n+                                    Math.abs(n);\n+                                }\n+                            }\n+                            \"\"\",\n+                            \/\/ here we expect only one, none for the post-larval frame\n+                            new int[] {16, 246, 255},\n+                            \/\/ stating that y is unset when if-else finishes\n+                            new String[][] { new String[] {\"y:I\"} }\n@@ -1518,5 +1550,6 @@\n-                    ClassFile classFile = ClassFile.read(fileEntry);\n-                    for (Method method : classFile.methods) {\n-                        if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                            Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                            StackMapTable_attribute stackMapTable = (StackMapTable_attribute)code.attributes.get(\"StackMapTable\");\n+                    var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                    for (var method : classFile.methods()) {\n+                        if (method.methodName().equalsString(ConstantDescs.INIT_NAME)) {\n+                            var code = method.findAttribute(Attributes.code()).orElseThrow();\n+                            var stackMapTable = code.findAttribute(Attributes.stackMapTable()).orElseThrow();\n+                            Assert.check(data.expectedFrameTypes().length == stackMapTable.entries().size(), \"unexpected stackmap length\");\n@@ -1524,1 +1557,0 @@\n-                            Assert.check(data.expectedFrameTypes().length == stackMapTable.entries.length, \"unexpected stackmap length\");\n@@ -1526,5 +1558,4 @@\n-                            for (StackMapTable_attribute.stack_map_entry entry : stackMapTable.entries) {\n-                                Assert.check(data.expectedFrameTypes()[entryIndex++] == entry.entry_type, \"expected \" + data.expectedFrameTypes()[entryIndex - 1] + \" found \" + entry.entry_type);\n-                                if (entry.entry_type == 246) {\n-                                    StackMapTable_attribute.assert_unset_fields auf = (StackMapTable_attribute.assert_unset_fields)entry;\n-                                    Assert.check(data.expectedUnsetFields()[expectedUnsetFieldsIndex].length == auf.number_of_unset_fields);\n+                            for (var entry : stackMapTable.entries()) {\n+                                Assert.check(data.expectedFrameTypes()[entryIndex++] == entry.frameType(), \"expected \" + data.expectedFrameTypes()[entryIndex - 1] + \" found \" + entry.frameType());\n+                                if (entry.frameType() == 246) {\n+                                    Assert.check(data.expectedUnsetFields()[expectedUnsetFieldsIndex].length == entry.unsetFields().size());\n@@ -1532,3 +1563,2 @@\n-                                    for (int i : auf.unset_fields) {\n-                                        String unsetStr = classFile.constant_pool.getNameAndTypeInfo(i).getName() + \":\" +\n-                                                classFile.constant_pool.getNameAndTypeInfo(i).getType();\n+                                    for (var nat : entry.unsetFields()) {\n+                                        String unsetStr = nat.name() + \":\" + nat.type();\n@@ -1549,33 +1579,0 @@\n-    private File findClassFileOrFail(File dir, String name) {\n-        for (final File fileEntry : dir.listFiles()) {\n-            if (fileEntry.getName().equals(name)) {\n-                return fileEntry;\n-            }\n-        }\n-        throw new AssertionError(\"file not found\");\n-    }\n-\n-    private Attribute findAttributeOrFail(Attributes attributes, Class<? extends Attribute> attrClass, int numberOfAttributes) {\n-        int attrCount = 0;\n-        Attribute result = null;\n-        for (Attribute attribute : attributes) {\n-            if (attribute.getClass() == attrClass) {\n-                attrCount++;\n-                if (result == null) {\n-                    result = attribute;\n-                }\n-            }\n-        }\n-        if (attrCount == 0) throw new AssertionError(\"attribute not found\");\n-        if (attrCount != numberOfAttributes) throw new AssertionError(\"incorrect number of attributes found\");\n-        return result;\n-    }\n-\n-    private void checkAttributeNotPresent(Attributes attributes, Class<? extends Attribute> attrClass) {\n-        for (Attribute attribute : attributes) {\n-            if (attribute.getClass() == attrClass) {\n-                throw new AssertionError(\"attribute found\");\n-            }\n-        }\n-    }\n-\n@@ -1624,1 +1621,0 @@\n-                ClassFile classFile = ClassFile.read(fileEntry);\n@@ -1626,7 +1622,10 @@\n-                        \"aload_0,invokespecial,getstatic,aload_0,getfield,invokevirtual,return,\";\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n-                        Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n-                        String foundCodeSequence = \"\";\n-                        for (Instruction inst: code.getInstructions()) {\n-                            foundCodeSequence += inst.getMnemonic() + \",\";\n+                        \"aload_0,invokespecial,getstatic,aload_0,getfield,invokevirtual,return\";\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                for (var method : classFile.methods()) {\n+                    if (method.methodName().equalsString(\"<init>\")) {\n+                        var code = method.findAttribute(Attributes.code()).orElseThrow();\n+                        List<String> mnemonics = new ArrayList<>();\n+                        for (var coe : code) {\n+                            if (coe instanceof Instruction inst) {\n+                                mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n+                            }\n@@ -1634,0 +1633,1 @@\n+                        var foundCodeSequence = String.join(\",\", mnemonics);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":168,"deletions":168,"binary":false,"changes":336,"status":"modified"}]}