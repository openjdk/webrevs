{"files":[{"patch":"@@ -379,0 +379,30 @@\n+UNSAFE_ENTRY(jint, Unsafe_ArrayLayout(JNIEnv *env, jobject unsafe, jclass c)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n+  if (!k->is_flatArray_klass()) {\n+    return LayoutKind::REFERENCE;\n+  } else {\n+    return (jint)FlatArrayKlass::cast(k)->layout_kind();\n+  }\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jint, Unsafe_FieldLayout(JNIEnv *env, jobject unsafe, jobject field)) {\n+  assert(field != nullptr, \"field must not be null\");\n+\n+  oop reflected   = JNIHandles::resolve_non_null(field);\n+  oop mirror      = java_lang_reflect_Field::clazz(reflected);\n+  Klass* k        = java_lang_Class::as_Klass(mirror);\n+  int slot        = java_lang_reflect_Field::slot(reflected);\n+  int modifiers   = java_lang_reflect_Field::modifiers(reflected);\n+\n+  if ((modifiers & JVM_ACC_STATIC) != 0) {\n+    return (jint)LayoutKind::REFERENCE; \/\/ static fields are never flat\n+  } else {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->field_is_flat(slot)) {\n+      return (jint)ik->inline_layout_info(slot).kind();\n+    } else {\n+      return (jint)LayoutKind::REFERENCE;\n+    }\n+  }\n+} UNSAFE_END\n+\n@@ -413,0 +443,15 @@\n+UNSAFE_ENTRY(jobject, Unsafe_GetFlatValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint layoutKind, jclass vc)) {\n+  assert(layoutKind != LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n+  oop base = JNIHandles::resolve(obj);\n+  if (base == nullptr) {\n+    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n+  }\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  LayoutKind lk = (LayoutKind)layoutKind;\n+  Handle base_h(THREAD, base);\n+  oop v = vk->read_payload_from_addr(base_h(), offset, lk, CHECK_NULL);\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n@@ -435,0 +480,15 @@\n+UNSAFE_ENTRY(void, Unsafe_PutFlatValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint layoutKind, jclass vc, jobject value)) {\n+  assert(layoutKind != LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n+  oop base = JNIHandles::resolve(obj);\n+  if (base == nullptr) {\n+    THROW(vmSymbols::java_lang_NullPointerException());\n+  }\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert(!base->is_inline_type() || base->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  LayoutKind lk = (LayoutKind)layoutKind;\n+  oop v = JNIHandles::resolve(value);\n+  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, lk, true, CHECK);\n+} UNSAFE_END\n+\n@@ -1052,6 +1112,10 @@\n-    {CC \"isFlatArray\", CC \"(\" CLS \")Z\",                   FN_PTR(Unsafe_IsFlatArray)},\n-    {CC \"isFlatField0\", CC \"(\" OBJ \")Z\",                  FN_PTR(Unsafe_IsFlatField)},\n-    {CC \"hasNullMarker0\"   , CC \"(\" OBJ \")Z\",                    FN_PTR(Unsafe_HasNullMarker)},\n-    {CC \"nullMarkerOffset0\", CC \"(\" OBJ \")I\",                    FN_PTR(Unsafe_NullMarkerOffset)},\n-    {CC \"getValue\",         CC \"(\" OBJ \"J\" CLS \")\" OBJ,   FN_PTR(Unsafe_GetValue)},\n-    {CC \"putValue\",         CC \"(\" OBJ \"J\" CLS OBJ \")V\",  FN_PTR(Unsafe_PutValue)},\n+    {CC \"isFlatArray\",          CC \"(\" CLS \")Z\",          FN_PTR(Unsafe_IsFlatArray)},\n+    {CC \"isFlatField0\",         CC \"(\" OBJ \")Z\",          FN_PTR(Unsafe_IsFlatField)},\n+    {CC \"hasNullMarker0\",       CC \"(\" OBJ \")Z\",          FN_PTR(Unsafe_HasNullMarker)},\n+    {CC \"nullMarkerOffset0\",    CC \"(\" OBJ \")I\",          FN_PTR(Unsafe_NullMarkerOffset)},\n+    {CC \"arrayLayout0\",         CC \"(\" OBJ \")I\",          FN_PTR(Unsafe_ArrayLayout)},\n+    {CC \"fieldLayout0\",         CC \"(\" OBJ \")I\",          FN_PTR(Unsafe_FieldLayout)},\n+    {CC \"getValue\",             CC \"(\" OBJ \"J\" CLS \")\" OBJ, FN_PTR(Unsafe_GetValue)},\n+    {CC \"getFlatValue\",         CC \"(\" OBJ \"JI\" CLS \")\" OBJ, FN_PTR(Unsafe_GetFlatValue)},\n+    {CC \"putValue\",             CC \"(\" OBJ \"J\" CLS OBJ \")V\", FN_PTR(Unsafe_PutValue)},\n+    {CC \"putFlatValue\",         CC \"(\" OBJ \"JI\" CLS OBJ \")V\", FN_PTR(Unsafe_PutFlatValue)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":70,"deletions":6,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-     public boolean hasNullMarker(Field f) {\n+    public boolean hasNullMarker(Field f) {\n@@ -205,1 +205,1 @@\n-     }\n+    }\n@@ -207,1 +207,1 @@\n-     private native boolean hasNullMarker0(Object o);\n+    private native boolean hasNullMarker0(Object o);\n@@ -209,3 +209,3 @@\n-     \/* Returns the offset of the null marker of the field,\n-      * or -1 if the field doesn't have a null marker\n-      *\/\n+    \/* Returns the offset of the null marker of the field,\n+    * or -1 if the field doesn't have a null marker\n+    *\/\n@@ -213,1 +213,1 @@\n-     public int nullMarkerOffset(Field f) {\n+    public int nullMarkerOffset(Field f) {\n@@ -218,1 +218,17 @@\n-     }\n+    }\n+\n+    private native int nullMarkerOffset0(Object o);\n+\n+    \/* Reports the kind of layout used for an element in the storage\n+     * allocation of the given array. Do not expect to perform any logic\n+     * or layout control with this value, it is just an opaque token\n+     * used for performance reasons.\n+     *\/\n+    public int arrayLayout(Class<?> arrayClass) {\n+        if (arrayClass == null) {\n+            throw new NullPointerException();\n+        }\n+        return arrayLayout0(arrayClass);\n+    }\n+\n+    private native int arrayLayout0(Object o);\n@@ -220,1 +236,14 @@\n-     private native int nullMarkerOffset0(Object o);\n+\n+    \/* Reports the kind of layout used for a given field in the storage\n+     * allocation of its class.  Do not expect to perform any logic\n+     * or layout control with this value, it is just an opaque token\n+     * used for performance reasons.\n+     *\/\n+    public int fieldLayout(Field f) {\n+        if (f == null) {\n+            throw new NullPointerException();\n+        }\n+            return fieldLayout0(f);\n+    }\n+\n+    private native int fieldLayout0(Object o);\n@@ -273,0 +302,23 @@\n+    \/**\n+     * Fetches a value of type {@code <V>} from a given Java variable.\n+     * More specifically, fetches a field or array element within the given\n+     * {@code o} object at the given offset, or (if {@code o} is null)\n+     * from the memory address whose numerical value is the given offset.\n+     *\n+     * @param o Java heap object in which the variable resides, if any, else\n+     *        null\n+     * @param offset indication of where the variable resides in a Java heap\n+     *        object, if any, else a memory address locating the variable\n+     *        statically\n+     * @param layoutKind opaque value used by the VM to know the layout\n+     *        the field or array element. This value must be retrieved with\n+     *        {@link #fieldLayout} or {@link #arrayLayout}.\n+     * @param valueType value type\n+     * @param <V> the type of a value\n+     * @return the value fetched from the indicated Java variable\n+     * @throws RuntimeException No defined exceptions are thrown, not even\n+     *         {@link NullPointerException}\n+     *\/\n+    public native <V> V getFlatValue(Object o, long offset, int layoutKind, Class<?> valueType);\n+\n+\n@@ -293,0 +345,23 @@\n+    \/**\n+     * Stores the given value into a given Java variable.\n+     *\n+     * Unless the reference {@code o} being stored is either null\n+     * or matches the field type, the results are undefined.\n+     *\n+     * @param o Java heap object in which the variable resides, if any, else\n+     *        null\n+     * @param offset indication of where the variable resides in a Java heap\n+     *        object, if any, else a memory address locating the variable\n+     *        statically\n+     * @param layoutKind opaque value used by the VM to know the layout\n+     *        the field or array element. This value must be retrieved with\n+     *        {@link #fieldLayout} or {@link #arrayLayout}.\n+     * @param valueType value type\n+     * @param v the value to store into the indicated Java variable\n+     * @param <V> the type of a value\n+     * @throws RuntimeException No defined exceptions are thrown, not even\n+     *         {@link NullPointerException}\n+     *\/\n+    public native <V> void putFlatValue(Object o, long offset, int layoutKind, Class<?> valueType, V v);\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":84,"deletions":9,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-    \/\/ Testing of nullable flat field supports in Unsafe.getValue()\/Unsafe.putValue()\n+    \/\/ Testing of nullable flat field supports in Unsafe.getFlatValue()\/Unsafe.putValue()\n@@ -256,0 +256,45 @@\n+    public static void testNullableFlatFields2() throws Throwable {\n+        Container1 c = new Container1();\n+        Class<?> cc = Container1.class;\n+        Field field = cc.getDeclaredField(\"value\");\n+        Class<?> fc = TestValue1.class;\n+        long offset = U.objectFieldOffset(field);\n+        int layoutKind = U.fieldLayout(field);\n+        if (!U.isFlatField(field)) return; \/\/ Field not flattened (due to VM flags?), test doesn't apply\n+        \/\/ Initial value of the field must be null\n+        Asserts.assertNull(U.getFlatValue(c, offset, layoutKind, fc));\n+        \/\/ Writing all zero value to the field, field must become non-null\n+        TestValue1 val0 = new TestValue1((short)0, (short)0);\n+        U.putFlatValue(c, offset, layoutKind, fc, val0);\n+        TestValue1 rval = U.getFlatValue(c, offset, layoutKind, fc);\n+        Asserts.assertNotNull(rval);\n+        Asserts.assertEQ((short)0, rval.s0);\n+        Asserts.assertEQ((short)0, rval.s1);\n+        Asserts.assertEQ((short)0, c.value.s0);\n+        Asserts.assertEQ((short)0, c.value.s1);\n+        \/\/ Writing null to the field, field must become null again\n+        U.putFlatValue(c, offset, layoutKind, fc, null);\n+        Asserts.assertNull(U.getFlatValue(c, offset, layoutKind, fc));\n+        Asserts.assertNull(c.value);\n+        \/\/ Writing non zero value to the field\n+        TestValue1 val1 = new TestValue1((short)-1, (short)-2);\n+        U.putFlatValue(c, offset, layoutKind, fc, val1);\n+        rval = U.getFlatValue(c, offset, layoutKind, fc);\n+        Asserts.assertNotNull(rval);\n+        Asserts.assertNotNull(c.value);\n+        Asserts.assertEQ((short)-1, rval.s0);\n+        Asserts.assertEQ((short)-2, rval.s1);\n+        Asserts.assertEQ((short)-1, c.value.s0);\n+        Asserts.assertEQ((short)-2, c.value.s1);\n+        \/\/ Writing a different non zero value\n+        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)3);\n+        U.putFlatValue(c, offset, layoutKind, fc, val2);\n+        rval = U.getFlatValue(c, offset, layoutKind, fc);\n+        Asserts.assertNotNull(rval);\n+        Asserts.assertNotNull(c.value);\n+        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n+        Asserts.assertEQ((short)3, rval.s1);\n+        Asserts.assertEQ(Short.MAX_VALUE, c.value.s0);\n+        Asserts.assertEQ((short)3, rval.s1);\n+    }\n+\n@@ -311,0 +356,56 @@\n+    \/\/ Testing of nullable flat arrays supports in Unsafe.getFlatValue()\/Unsafe.putFlatValue()\n+    public static void testNullableFlatArrays2() throws Throwable {\n+        final int ARRAY_LENGTH = 10;\n+        TestValue1[] array = (TestValue1[])ValueClass.newNullableAtomicArray(TestValue1.class, ARRAY_LENGTH);\n+        long baseOffset = U.arrayBaseOffset(array.getClass());\n+        int scaleIndex = U.arrayIndexScale(array.getClass());\n+        int layoutKind = U.arrayLayout(array.getClass());\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            Asserts.assertNull(U.getFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class));\n+        }\n+        TestValue1 val = new TestValue1((short)0, (short)0);\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 == 0) {\n+                U.putFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class, val );\n+            }\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 == 0) {\n+                Asserts.assertNotNull(U.getFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class));\n+                Asserts.assertNotNull(array[i]);\n+            } else {\n+                Asserts.assertNull(U.getFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class));\n+                Asserts.assertNull(array[i]);\n+            }\n+        }\n+        TestValue1 val2 = new TestValue1((short)Short.MAX_VALUE, (short)Short.MIN_VALUE);\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 != 0) {\n+                U.putFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class, val2 );\n+            } else {\n+                U.putFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class, null );\n+            }\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            if (i % 2 != 0) {\n+                TestValue1 rval = U.getFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class);\n+                Asserts.assertNotNull(rval);\n+                Asserts.assertEQ(val2.s0, rval.s0);\n+                Asserts.assertEQ(val2.s1, rval.s1);\n+                Asserts.assertNotNull(array[i]);\n+                Asserts.assertEQ(val2.s0, array[i].s0);\n+                Asserts.assertEQ(val2.s1, array[i].s1);\n+            } else {\n+                Asserts.assertNull(U.getFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class));\n+                Asserts.assertNull(array[i]);\n+            }\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            U.putFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class, null );\n+        }\n+        for (int i = 0; i < ARRAY_LENGTH; i++) {\n+            Asserts.assertNull(U.getFlatValue(array, baseOffset + i * scaleIndex, layoutKind, TestValue1.class));\n+            Asserts.assertNull(array[i]);\n+        }\n+    }\n+\n@@ -315,0 +416,1 @@\n+        testNullableFlatFields2();\n@@ -316,0 +418,1 @@\n+        testNullableFlatArrays2();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":104,"deletions":1,"binary":false,"changes":105,"status":"modified"}]}