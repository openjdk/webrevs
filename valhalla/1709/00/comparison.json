{"files":[{"patch":"@@ -1059,1 +1059,0 @@\n-        \/\/ TODO 8370341 Wouldn't this fail for arrays?\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1414,1 +1414,0 @@\n-  \/\/ TODO 8370341 For a direct pointer comparison, we need the refined array klass pointer\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1253,1 +1253,0 @@\n-        \/\/ TODO 8370341 Wouldn't this fail for arrays?\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4175,1 +4175,0 @@\n-  \/\/ TODO 8370341 For a direct pointer comparison, we need the refined array klass pointer\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2300,1 +2300,1 @@\n-  Value element;\n+  Value element = nullptr;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool null_free, bool atomic, bool vm_type) {\n+ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool null_free, bool atomic, bool refined_type) {\n@@ -108,1 +108,1 @@\n-    return ciObjArrayKlass::make(element_type->as_klass(), vm_type, null_free, atomic);\n+    return ciObjArrayKlass::make(element_type->as_klass(), refined_type, null_free, atomic);\n@@ -133,0 +133,4 @@\n+\n+ArrayKlass::ArrayProperties ciArrayKlass::properties() const {\n+  GUARDED_VM_ENTRY(return ArrayKlass::cast(get_Klass())->properties();)\n+}\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/arrayKlass.hpp\"\n@@ -61,1 +62,1 @@\n-  static ciArrayKlass* make(ciType* klass, bool null_free = false, bool atomic = false, bool vm_type = false);\n+  static ciArrayKlass* make(ciType* klass, bool null_free = false, bool atomic = false, bool refined_type = false);\n@@ -68,0 +69,2 @@\n+\n+  ArrayKlass::ArrayProperties properties() const;\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  BasicType bt;\n+  BasicType bt = T_ILLEGAL;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-ciArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool vm_type, bool null_free, bool atomic) {\n+ciArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n@@ -148,1 +148,1 @@\n-    if (vm_type) {\n+    if (refined_type) {\n@@ -181,2 +181,2 @@\n-ciArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool vm_type, bool null_free, bool atomic) {\n-  GUARDED_VM_ENTRY(return make_impl(element_klass, vm_type, null_free, atomic);)\n+ciArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n+  GUARDED_VM_ENTRY(return make_impl(element_klass, refined_type, null_free, atomic);)\n@@ -188,1 +188,1 @@\n-    klass = ciObjArrayKlass::make(klass, \/* vm_type = *\/ false);\n+    klass = ciObjArrayKlass::make(klass, \/* refined_type = *\/ false);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  static ciArrayKlass* make_impl(ciKlass* element_klass, bool vm_type = false, bool null_free = false, bool atomic = true);\n+  static ciArrayKlass* make_impl(ciKlass* element_klass, bool refined_type = false, bool null_free = false, bool atomic = true);\n@@ -71,1 +71,1 @@\n-  static ciArrayKlass* make(ciKlass* element_klass, bool vm_type = true, bool null_free = false, bool atomic = true);\n+  static ciArrayKlass* make(ciKlass* element_klass, bool refined_type = true, bool null_free = false, bool atomic = true);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+  static ByteSize properties_offset() { return byte_offset_of(ArrayKlass, _properties); }\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1572,1 +1572,1 @@\n-        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_flat(), tk->is_null_free(), tk->is_atomic(), tk->is_aryklassptr()->is_vm_type());\n+        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_flat(), tk->is_null_free(), tk->is_atomic(), tk->is_aryklassptr()->is_refined_type());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2918,1 +2918,2 @@\n-    vm_superklass = gvn.makecon(klass_ptr_type->is_aryklassptr()->refined_array_klass_ptr());\n+    assert(!klass_ptr_type->is_aryklassptr()->is_refined_type(), \"Unexpected refined array klass pointer\");\n+    vm_superklass = gvn.makecon(klass_ptr_type->is_aryklassptr()->cast_to_refined_array_klass_ptr());\n@@ -3038,1 +3039,1 @@\n-          klass_t = klass_t->is_aryklassptr()->refined_array_klass_ptr();\n+          klass_t = klass_t->is_aryklassptr()->cast_to_refined_array_klass_ptr();\n@@ -3176,1 +3177,1 @@\n-    tklass = tklass->is_aryklassptr()->refined_array_klass_ptr();\n+    tklass = tklass->is_aryklassptr()->cast_to_refined_array_klass_ptr();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4495,9 +4495,0 @@\n-    p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n-    null_ctl = top();\n-    kls = null_check_oop(kls, &null_ctl);\n-    if (null_ctl != top()) {\n-      \/\/ If the guard is taken, Object.superClass is null (both klass and mirror).\n-      region->add_req(null_ctl);\n-      phi   ->add_req(null());\n-    }\n@@ -4505,1 +4496,12 @@\n-      query_value = load_mirror_from_klass(kls);\n+      p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));\n+      kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n+      null_ctl = top();\n+      kls = null_check_oop(kls, &null_ctl);\n+      if (null_ctl != top()) {\n+        \/\/ If the guard is taken, Object.superClass is null (both klass and mirror).\n+        region->add_req(null_ctl);\n+        phi   ->add_req(null());\n+      }\n+      if (!stopped()) {\n+        query_value = load_mirror_from_klass(kls);\n+      }\n@@ -4896,0 +4898,24 @@\n+\/\/ Load the non-refined array klass from an ObjArrayKlass.\n+Node* LibraryCallKit::load_non_refined_array_klass(Node* klass_node) {\n+  const TypeAryKlassPtr* ary_klass_ptr = _gvn.type(klass_node)->isa_aryklassptr();\n+  if (ary_klass_ptr != nullptr && ary_klass_ptr->klass_is_exact()) {\n+    return _gvn.makecon(ary_klass_ptr->cast_to_refined_array_klass_ptr(false));\n+  }\n+\n+  RegionNode* region = new RegionNode(2);\n+  Node* phi = new PhiNode(region, TypeInstKlassPtr::OBJECT);\n+\n+  generate_typeArray_guard(klass_node, region);\n+  if (region->req() == 3) {\n+    phi->add_req(klass_node);\n+  }\n+  Node* super_adr = basic_plus_adr(klass_node, in_bytes(Klass::super_offset()));\n+  Node* super_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), super_adr, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT));\n+\n+  region->init_req(1, control());\n+  phi->init_req(1, super_klass);\n+\n+  set_control(_gvn.transform(region));\n+  return _gvn.transform(phi);\n+}\n+\n@@ -5060,1 +5086,1 @@\n-    klass_node = load_default_refined_array_klass(klass_node, \/* type_array_guard= *\/ false);\n+    Node* refined_klass_node = load_default_refined_array_klass(klass_node, \/* type_array_guard= *\/ false);\n@@ -5066,2 +5092,2 @@\n-      Node* cast = new CastPPNode(control(), klass_node, akls);\n-      klass_node = _gvn.transform(cast);\n+      Node* cast = new CastPPNode(control(), refined_klass_node, akls);\n+      refined_klass_node = _gvn.transform(cast);\n@@ -5101,1 +5127,1 @@\n-          generate_fair_guard(flat_array_test(klass_node, \/* flat = *\/ false), bailout);\n+          generate_fair_guard(flat_array_test(refined_klass_node, \/* flat = *\/ false), bailout);\n@@ -5119,1 +5145,1 @@\n-        generate_fair_guard(flat_array_test(klass_node), bailout);\n+        generate_fair_guard(flat_array_test(refined_klass_node), bailout);\n@@ -5183,1 +5209,1 @@\n-        newcopy = new_array(klass_node, length, 0);  \/\/ no arguments to push\n+        newcopy = new_array(refined_klass_node, length, 0);  \/\/ no arguments to push\n@@ -6655,0 +6681,1 @@\n+    Node* refined_dest_klass = dest_klass;\n@@ -6656,0 +6683,1 @@\n+      dest_klass = load_non_refined_array_klass(refined_dest_klass);\n@@ -6660,1 +6688,17 @@\n-    \/\/ TODO 8350865 Fix below logic. Also handle atomicity.\n+    \/\/ TODO 8350865 Improve this. What about atomicity? Make sure this is always folded for type arrays.\n+    \/\/ If destination is null-restricted, source must be null-restricted as well: src_null_restricted || !dst_null_restricted\n+    Node* src_klass = load_object_klass(src);\n+    Node* adr_prop_src = basic_plus_adr(src_klass, in_bytes(ArrayKlass::properties_offset()));\n+    Node* prop_src = _gvn.transform(LoadNode::make(_gvn, control(), immutable_memory(), adr_prop_src, TypeRawPtr::BOTTOM, TypeInt::INT, T_INT, MemNode::unordered));\n+    Node* adr_prop_dest = basic_plus_adr(refined_dest_klass, in_bytes(ArrayKlass::properties_offset()));\n+    Node* prop_dest = _gvn.transform(LoadNode::make(_gvn, control(), immutable_memory(), adr_prop_dest, TypeRawPtr::BOTTOM, TypeInt::INT, T_INT, MemNode::unordered));\n+\n+    prop_dest = _gvn.transform(new XorINode(prop_dest, intcon(ArrayKlass::ArrayProperties::NULL_RESTRICTED)));\n+    prop_src = _gvn.transform(new OrINode(prop_dest, prop_src));\n+    prop_src = _gvn.transform(new AndINode(prop_src, intcon(ArrayKlass::ArrayProperties::NULL_RESTRICTED)));\n+\n+    Node* chk = _gvn.transform(new CmpINode(prop_src, intcon(ArrayKlass::ArrayProperties::NULL_RESTRICTED)));\n+    Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::ne));\n+    generate_fair_guard(tst, slow_region);\n+\n+    \/\/ TODO 8350865 This is too strong\n@@ -6664,31 +6708,0 @@\n-    const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)->is_klassptr();\n-    const Type* toop = dest_klass_t->cast_to_exactness(false)->as_instance_type();\n-    src = _gvn.transform(new CheckCastPPNode(control(), src, toop));\n-    src_type = _gvn.type(src);\n-    top_src  = src_type->isa_aryptr();\n-\n-    \/\/ Handle flat inline type arrays (null-free arrays are handled by the subtype check above)\n-    if (!stopped() && UseArrayFlattening) {\n-      \/\/ If dest is flat, src must be flat as well (guaranteed by src <: dest check). Handle flat src here.\n-      assert(top_dest == nullptr || !top_dest->is_flat() || top_src->is_flat(), \"src array must be flat\");\n-      if (top_src != nullptr && top_src->is_flat()) {\n-        \/\/ Src is flat, check that dest is flat as well\n-        if (top_dest != nullptr && !top_dest->is_flat()) {\n-          generate_fair_guard(flat_array_test(dest_klass, \/* flat = *\/ false), slow_region);\n-          \/\/ Since dest is flat and src <: dest, dest must have the same type as src.\n-          top_dest = top_src->cast_to_exactness(false);\n-          assert(top_dest->is_flat(), \"dest must be flat\");\n-          dest = _gvn.transform(new CheckCastPPNode(control(), dest, top_dest));\n-        }\n-      } else if (top_src == nullptr || !top_src->is_not_flat()) {\n-        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n-        \/\/ TODO 8251971: Optimize for the case when src\/dest are later found to be both flat.\n-        assert(top_dest == nullptr || !top_dest->is_flat(), \"dest array must not be flat\");\n-        generate_fair_guard(flat_array_test(src), slow_region);\n-        if (top_src != nullptr) {\n-          top_src = top_src->cast_to_not_flat();\n-          src = _gvn.transform(new CheckCastPPNode(control(), src, top_src));\n-        }\n-      }\n-    }\n-\n@@ -6702,0 +6715,4 @@\n+\n+    const TypeKlassPtr* dest_klass_t = _gvn.type(refined_dest_klass)->is_klassptr();\n+    const Type* toop = dest_klass_t->cast_to_exactness(false)->as_instance_type();\n+    src = _gvn.transform(new CheckCastPPNode(control(), src, toop));\n@@ -6709,0 +6726,3 @@\n+  Node* dest_klass = load_object_klass(dest);\n+  dest_klass = load_non_refined_array_klass(dest_klass);\n+\n@@ -6713,1 +6733,1 @@\n-                                          load_object_klass(src), load_object_klass(dest),\n+                                          load_object_klass(src), dest_klass,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":69,"deletions":49,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+  Node* load_non_refined_array_klass(Node* klass_node);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2209,1 +2209,1 @@\n-         ary_klass_t->is_vm_type(), \"Must be a refined array klass\");\n+         ary_klass_t->is_refined_type(), \"Must be a refined array klass\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1581,1 +1581,1 @@\n-    \/\/ TODO 8350865 Fix below logic. Also handle atomicity.\n+    \/\/ TODO 8350865 This is too strong\n@@ -1583,1 +1583,1 @@\n-    if (!(top_src->is_flat() && top_dest->is_flat())) {\n+    if (!(top_src->is_flat() && top_dest->is_flat() && top_src->is_null_free() == top_dest->is_null_free())) {\n@@ -1586,15 +1586,1 @@\n-    }\n-\n-    \/\/ Handle inline type arrays\n-    if (!top_src->is_flat()) {\n-      if (UseArrayFlattening && !top_src->is_not_flat()) {\n-        \/\/ Src might be flat and dest might not be flat. Go to the slow path if src is flat.\n-        generate_flat_array_guard(&ctrl, src, merge_mem, slow_region);\n-      }\n-      if (EnableValhalla) {\n-        \/\/ No validation. The subtype check emitted at macro expansion time will not go to the slow\n-        \/\/ path but call checkcast_arraycopy which can not handle flat\/null-free inline type arrays.\n-        generate_null_free_array_guard(&ctrl, dest, merge_mem, slow_region);\n-      }\n-    } else {\n-      assert(top_dest->is_flat(), \"dest array must be flat\");\n+      generate_null_free_array_guard(&ctrl, dest, merge_mem, slow_region);\n@@ -1608,1 +1594,2 @@\n-  if (top_src->is_flat() && top_dest->is_flat()) {\n+  if (top_src->is_flat() && top_dest->is_flat() &&\n+      top_src->is_null_free() == top_dest->is_null_free()) {\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2322,1 +2322,5 @@\n-        return tkls->is_aryklassptr()->refined_array_klass_ptr();\n+        return tkls->is_aryklassptr()->cast_to_refined_array_klass_ptr();\n+      }\n+      if (klass->is_array_klass() && tkls->offset() == in_bytes(ObjArrayKlass::properties_offset())) {\n+        assert(klass->is_type_array_klass() || tkls->is_aryklassptr()->is_refined_type(), \"Must be a refined array klass pointer\");\n+        return TypeInt::make(klass->as_array_klass()->properties());\n@@ -2669,1 +2673,1 @@\n-    return res->refined_array_klass_ptr();\n+    return res->cast_to_refined_array_klass_ptr();\n@@ -2687,0 +2691,7 @@\n+    if (tkls->isa_aryklassptr() != nullptr && tkls->klass_is_exact() &&\n+        !tkls->exact_klass()->is_type_array_klass() &&\n+        tkls->offset() == in_bytes(Klass::super_offset())) {\n+      \/\/ We are loading the super klass of a refined array klass, return the non-refined klass pointer\n+      assert(tkls->is_aryklassptr()->is_refined_type(), \"Must be a refined array klass pointer\");\n+      return tkls->is_aryklassptr()->cast_to_refined_array_klass_ptr(false);\n+    }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-  array_klass_type = array_klass_type->refined_array_klass_ptr();\n+  array_klass_type = array_klass_type->cast_to_refined_array_klass_ptr();\n@@ -396,1 +396,1 @@\n-  array_klass_type = array_klass_type->refined_array_klass_ptr();\n+  array_klass_type = array_klass_type->cast_to_refined_array_klass_ptr();\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-      extak = extak->refined_array_klass_ptr();\n+      extak = extak->cast_to_refined_array_klass_ptr();\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1332,1 +1332,1 @@\n-      set_req_X(2, phase->makecon(t2->is_aryklassptr()->refined_array_klass_ptr()), phase);\n+      set_req_X(2, phase->makecon(t2->is_aryklassptr()->cast_to_refined_array_klass_ptr()), phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,2 +132,1 @@\n-  \/\/ TODO 8370341 fails with TestArrayCopyAsLoadsStores\n-  \/\/ assert(verify(phase), \"missing Value() optimization\");\n+  assert(verify(phase), \"missing Value() optimization\");\n@@ -156,1 +155,2 @@\n-  Node* cmp = phase->transform(new CmpPNode(subklass, in(SuperKlass)));\n+  Node* cmp_orig = new CmpPNode(subklass, in(SuperKlass));\n+  Node* cmp = phase->transform(cmp_orig);\n@@ -169,0 +169,1 @@\n+    tty->print_cr(\"VS.\\n\");\n@@ -170,2 +171,2 @@\n-    subklass->dump(2); tty->cr();\n-    tty->print_cr(\"==============================\");\n+    cmp_orig->dump(2); tty->cr();\n+    tty->print_cr(\"==============================\\n\");\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5492,0 +5492,1 @@\n+          ptr = NotNull;\n@@ -5511,0 +5512,1 @@\n+          ptr = NotNull;\n@@ -6426,1 +6428,1 @@\n-        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free(), tp->is_atomic(), tp->is_vm_type());\n+        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free(), tp->is_atomic(), tp->is_refined_type());\n@@ -6445,1 +6447,1 @@\n-          return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free(), tp->is_atomic(), tp->is_vm_type());\n+          return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free(), tp->is_atomic(), tp->is_refined_type());\n@@ -6595,2 +6597,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type) {\n-  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset, not_flat, not_null_free, flat, null_free, atomic, vm_type))->hashcons();\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type) {\n+  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type))->hashcons();\n@@ -6599,1 +6601,1 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type) {\n@@ -6604,1 +6606,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free, atomic, vm_type);\n+    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n@@ -6612,1 +6614,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, vm_type);\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n@@ -6619,1 +6621,1 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool vm_type) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool refined_type) {\n@@ -6631,1 +6633,1 @@\n-  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, flat, null_free, atomic, vm_type);\n+  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n@@ -6634,2 +6636,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling, bool vm_type) {\n-  return TypeAryKlassPtr::make(Constant, klass, Offset(0), interface_handling, vm_type);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling, bool refined_type) {\n+  return TypeAryKlassPtr::make(Constant, klass, Offset(0), interface_handling, refined_type);\n@@ -6638,4 +6640,3 @@\n-\/\/ Get the refined array klass ptr\n-\/\/ TODO 8370341 We should also evaluate if we can get rid of the _vm_type and if we should split ciObjArrayKlass into ciRefArrayKlass and ciFlatArrayKlass like the runtime now does.\n-const TypeAryKlassPtr* TypeAryKlassPtr::refined_array_klass_ptr() const {\n-  if (!klass_is_exact() || !exact_klass()->is_obj_array_klass()) {\n+\/\/ Get the (non-)refined array klass ptr\n+const TypeAryKlassPtr* TypeAryKlassPtr::cast_to_refined_array_klass_ptr(bool refined) const {\n+  if ((refined == is_refined_type()) || !klass_is_exact() || (!exact_klass()->is_obj_array_klass() && !exact_klass()->is_flat_array_klass())) {\n@@ -6648,2 +6649,2 @@\n-  ciKlass* array_klass = ciArrayKlass::make(eklass, eklass->is_inlinetype() ? is_null_free() : false, eklass->is_inlinetype() ? is_atomic() : true, true);\n-  return make(_ptr, array_klass, Offset(0), trust_interfaces, true);\n+  ciKlass* array_klass = ciArrayKlass::make(eklass, eklass->is_inlinetype() ? is_null_free() : false, eklass->is_inlinetype() ? is_atomic() : true, refined);\n+  return make(_ptr, array_klass, Offset(0), trust_interfaces, refined);\n@@ -6663,1 +6664,1 @@\n-    _vm_type == p->_vm_type &&\n+    _refined_type == p->_refined_type &&\n@@ -6671,1 +6672,1 @@\n-      (uint)(_not_null_free ? 44 : 0) + (uint)(_flat ? 45 : 0) + (uint)(_null_free ? 46 : 0)  + (uint)(_atomic ? 47 : 0) + (uint)(_vm_type ? 48 : 0);\n+      (uint)(_not_null_free ? 44 : 0) + (uint)(_flat ? 45 : 0) + (uint)(_null_free ? 46 : 0)  + (uint)(_atomic ? 47 : 0) + (uint)(_refined_type ? 48 : 0);\n@@ -6765,1 +6766,1 @@\n-  return make(_ptr, elem(), klass(), xadd_offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _vm_type);\n+  return make(_ptr, elem(), klass(), xadd_offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _refined_type);\n@@ -6769,1 +6770,1 @@\n-  return make(_ptr, elem(), klass(), Offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _vm_type);\n+  return make(_ptr, elem(), klass(), Offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _refined_type);\n@@ -6776,1 +6777,1 @@\n-  return make(ptr, elem(), _klass, _offset, is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _vm_type);\n+  return make(ptr, elem(), _klass, _offset, is_not_flat(), is_not_null_free(), _flat, _null_free, _atomic, _refined_type);\n@@ -6824,1 +6825,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _flat, _null_free, _atomic, _vm_type);\n+  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _flat, _null_free, _atomic, _refined_type);\n@@ -6889,1 +6890,1 @@\n-      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_vm_type());\n+      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_refined_type());\n@@ -6937,1 +6938,1 @@\n-    bool vm_type = _vm_type && tap->_vm_type;\n+    bool refined_type = _refined_type && tap->_refined_type;\n@@ -6942,1 +6943,1 @@\n-      vm_type = false;\n+      refined_type = false;\n@@ -6948,1 +6949,1 @@\n-        vm_type = _vm_type;\n+        refined_type = _refined_type;\n@@ -6953,1 +6954,1 @@\n-        vm_type = tap->_vm_type;\n+        refined_type = tap->_refined_type;\n@@ -6958,1 +6959,6 @@\n-        vm_type = _vm_type || tap->_vm_type;\n+        refined_type = _refined_type || tap->_refined_type;\n+      } else if (res_xk && _refined_type != tap->_refined_type) {\n+        \/\/ This can happen if the phi emitted by LibraryCallKit::load_default_refined_array_klass\/load_non_refined_array_klass\n+        \/\/ is processed before the typeArray guard is folded. Both inputs are constant but the input corresponding to the\n+        \/\/ typeArray will go away. Don't constant fold it yet but wait for the control input to collapse.\n+        ptr = PTR::NotNull;\n@@ -6961,6 +6967,1 @@\n-    if (res_xk && _vm_type != tap->_vm_type) {\n-      \/\/ This can happen if the phi emitted by LibraryCallKit::load_default_refined_array_klass is folded\n-      \/\/ before the typeArray guard is folded. Keep the information that this is a refined klass pointer.\n-      vm_type = true;\n-    }\n-    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, flat, null_free, atomic, vm_type);\n+    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, flat, null_free, atomic, refined_type);\n@@ -6984,1 +6985,1 @@\n-        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_vm_type());\n+        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_refined_type());\n@@ -7004,1 +7005,1 @@\n-          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_vm_type());\n+          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free(), is_atomic(), is_refined_type());\n@@ -7145,1 +7146,1 @@\n-  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_flat(), dual_null_free(), dual_atomic(), _vm_type);\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_flat(), dual_null_free(), dual_atomic(), _refined_type);\n@@ -7155,1 +7156,1 @@\n-    k = ciArrayKlass::make(k, k->is_inlinetype() ? is_null_free() : false, k->is_inlinetype() ? is_atomic() : true, _vm_type);\n+    k = ciArrayKlass::make(k, k->is_inlinetype() ? is_null_free() : false, k->is_inlinetype() ? is_atomic() : true, _refined_type);\n@@ -7205,1 +7206,1 @@\n-  if (_vm_type) st->print(\":vm_type\");\n+  if (_refined_type) st->print(\":refined_type\");\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":41,"deletions":40,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2063,1 +2063,1 @@\n-  const bool _vm_type;\n+  const bool _refined_type;\n@@ -2066,2 +2066,2 @@\n-  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, Offset offset, bool not_flat, int not_null_free, bool flat, bool null_free, bool atomic, bool vm_type)\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, _array_interfaces, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _flat(flat), _null_free(null_free), _atomic(atomic), _vm_type(vm_type) {\n+  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, Offset offset, bool not_flat, int not_null_free, bool flat, bool null_free, bool atomic, bool refined_type)\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, _array_interfaces, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _flat(flat), _null_free(null_free), _atomic(atomic), _refined_type(refined_type) {\n@@ -2106,1 +2106,1 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type = false);\n@@ -2114,3 +2114,3 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool vm_type = false);\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool vm_type = false);\n-  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling, bool vm_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free, bool atomic, bool refined_type = false);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool refined_type = false);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling, bool refined_type = false);\n@@ -2118,1 +2118,1 @@\n-  const TypeAryKlassPtr* refined_array_klass_ptr() const;\n+  const TypeAryKlassPtr* cast_to_refined_array_klass_ptr(bool refined = true) const;\n@@ -2147,1 +2147,1 @@\n-  bool is_vm_type()       const { return _vm_type; }\n+  bool is_refined_type()  const { return _refined_type; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,696 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Test correctness of arraycopy intrinsic.\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestArrayCopy\n+ *\/\n+\n+\/*\n+ * @test id=NoTraps\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=0 -XX:PerMethodTrapLimit=0\n+ *                   compiler.valhalla.inlinetypes.TestArrayCopy\n+ *\/\n+\n+\/*\n+ * @test id=AlwaysIncrementalInline\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   compiler.valhalla.inlinetypes.TestArrayCopy\n+ *\/\n+\n+\/*\n+ * @test id=NoArrayFlattening\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -Xbatch -XX:-UseArrayFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayCopy\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+public class TestArrayCopy {\n+    static final Random RAND = Utils.getRandomInstance();\n+    static final int LEN = RAND.nextInt(10) + 1;\n+\n+    @LooselyConsistentValue\n+    static value class MyInt {\n+        int i = RAND.nextInt(10); \/\/ No need to check all values but the all-zero value is important\n+    }\n+\n+    static Object[] getSrc1(int len) {\n+        MyInt[] src = new MyInt[len];\n+        src[0] = new MyInt();\n+        return src;\n+    }\n+\n+    static Object[] getDst1(int len) {\n+        return new MyInt[len];\n+    }\n+\n+    static void test1(int len) {\n+        Object[] src = getSrc1(len);\n+        Object[] dst = getDst1(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc2(int len) {\n+        MyInt[] src = new MyInt[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static Object[] getDst2(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test2(int len) {\n+        Object[] src = getSrc2(len);\n+        Object[] dst = getDst2(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc2NoInit(int len) {\n+        MyInt[] src = new MyInt[len];\n+        \/\/ Last element not initialized\n+        for (int i = 0; i < len - 1; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static void test2NoInit(int len) {\n+        Object[] src = getSrc2NoInit(len);\n+        Object[] dst = getDst2(len);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, len);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static Object[] getSrc3(int len) {\n+        MyInt[] src = new MyInt[len];\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static Object[] getDst3(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test3(int len) {\n+        Object[] src = getSrc3(len);\n+        Object[] dst = getDst3(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc3NoInit(int len) {\n+        MyInt[] src = new MyInt[len];\n+        \/\/ Last element not initialized\n+        for (int i = 0; i < len - 1; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static void test3NoInit(int len) {\n+        Object[] src = getSrc3NoInit(len);\n+        Object[] dst = getDst3(len);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, len);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static Object[] getSrc4(int len) {\n+        MyInt[] src = new MyInt[len];\n+        src[0] = new MyInt();\n+        return src;\n+    }\n+\n+    static Object[] getDst4(int len) {\n+        return ValueClass.newNullableAtomicArray(MyInt.class, len);\n+    }\n+\n+    static void test4(int len) {\n+        Object[] src = getSrc4(len);\n+        Object[] dst = getDst4(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc5(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst5(int len) {\n+        return new MyInt[len];\n+    }\n+\n+    static void test5(int len) {\n+        Object[] src = getSrc5(len);\n+        Object[] dst = getDst5(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc6(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst6(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test6(int len) {\n+        Object[] src = getSrc6(len);\n+        Object[] dst = getDst6(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc7(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst7(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test7(int len) {\n+        Object[] src = getSrc7(len);\n+        Object[] dst = getDst7(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc8(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst8(int len) {\n+        return ValueClass.newNullableAtomicArray(MyInt.class, len);\n+    }\n+\n+    static void test8(int len) {\n+        Object[] src = getSrc8(len);\n+        Object[] dst = getDst8(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc9(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst9(int len) {\n+        return new MyInt[len];\n+    }\n+\n+    static void test9(int len) {\n+        Object[] src = getSrc9(len);\n+        Object[] dst = getDst9(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc10(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst10(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test10(int len) {\n+        Object[] src = getSrc10(len);\n+        Object[] dst = getDst10(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc11(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst11(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test11(int len) {\n+        Object[] src = getSrc11(len);\n+        Object[] dst = getDst11(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc12(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static Object[] getDst12(int len) {\n+        return ValueClass.newNullableAtomicArray(MyInt.class, len);\n+    }\n+\n+    static void test12(int len) {\n+        Object[] src = getSrc12(len);\n+        Object[] dst = getDst12(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc13(int len) {\n+        MyInt[] src = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, len);\n+        src[0] = new MyInt();\n+        return src;\n+    }\n+\n+    static Object[] getDst13(int len) {\n+        return new MyInt[len];\n+    }\n+\n+    static void test13(int len) {\n+        Object[] src = getSrc13(len);\n+        Object[] dst = getDst13(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc14(int len) {\n+        MyInt[] src = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, len);\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static Object[] getDst14(int len) {\n+        return ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test14(int len) {\n+        Object[] src = getSrc14(len);\n+        Object[] dst = getDst14(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc14NoInit(int len) {\n+        MyInt[] src = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, len);\n+        \/\/ Last element not initialized\n+        for (int i = 0; i < len - 1; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static void test14NoInit(int len) {\n+        Object[] src = getSrc14NoInit(len);\n+        Object[] dst = getDst14(len);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, len);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static Object[] getSrc15(int len) {\n+        MyInt[] src = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, len);\n+        for (int i = 0; i < len; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static Object[] getDst15(int len) {\n+        return ValueClass.newNullRestrictedAtomicArray(MyInt.class, len, new MyInt());\n+    }\n+\n+    static void test15(int len) {\n+        Object[] src = getSrc15(len);\n+        Object[] dst = getDst15(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static Object[] getSrc15NoInit(int len) {\n+        MyInt[] src = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, len);\n+        \/\/ Last element not initialized\n+        for (int i = 0; i < len - 1; ++i) {\n+            src[i] = new MyInt();\n+        }\n+        return src;\n+    }\n+\n+    static void test15NoInit(int len) {\n+        Object[] src = getSrc15NoInit(len);\n+        Object[] dst = getDst15(len);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, len);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static Object[] getSrc16(int len) {\n+        MyInt[] src = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, len);\n+        src[0] = new MyInt();\n+        return src;\n+    }\n+\n+    static Object[] getDst16(int len) {\n+        return ValueClass.newNullableAtomicArray(MyInt.class, len);\n+    }\n+\n+    static void test16(int len) {\n+        Object[] src = getSrc16(len);\n+        Object[] dst = getDst16(len);\n+        System.arraycopy(src, 0, dst, 0, len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen1() {\n+        Object[] src = getSrc1(LEN);\n+        Object[] dst = getDst1(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen2() {\n+        Object[] src = getSrc2(LEN);\n+        Object[] dst = getDst2(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen2NoInit() {\n+        Object[] src = getSrc2NoInit(LEN);\n+        Object[] dst = getDst2(LEN);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, LEN);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static void testConstantLen3() {\n+        Object[] src = getSrc3(LEN);\n+        Object[] dst = getDst3(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen3NoInit() {\n+        Object[] src = getSrc3NoInit(LEN);\n+        Object[] dst = getDst3(LEN);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, LEN);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static void testConstantLen4() {\n+        Object[] src = getSrc4(LEN);\n+        Object[] dst = getDst4(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen5() {\n+        Object[] src = getSrc5(LEN);\n+        Object[] dst = getDst5(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen6() {\n+        Object[] src = getSrc6(LEN);\n+        Object[] dst = getDst6(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen7() {\n+        Object[] src = getSrc7(LEN);\n+        Object[] dst = getDst7(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen8() {\n+        Object[] src = getSrc8(LEN);\n+        Object[] dst = getDst8(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen9() {\n+        Object[] src = getSrc9(LEN);\n+        Object[] dst = getDst9(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen10() {\n+        Object[] src = getSrc10(LEN);\n+        Object[] dst = getDst10(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen11() {\n+        Object[] src = getSrc11(LEN);\n+        Object[] dst = getDst11(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen12() {\n+        Object[] src = getSrc12(LEN);\n+        Object[] dst = getDst12(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen13() {\n+        Object[] src = getSrc13(LEN);\n+        Object[] dst = getDst13(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen14() {\n+        Object[] src = getSrc14(LEN);\n+        Object[] dst = getDst14(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen14NoInit() {\n+        Object[] src = getSrc14NoInit(LEN);\n+        Object[] dst = getDst14(LEN);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, LEN);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static void testConstantLen15() {\n+        Object[] src = getSrc15(LEN);\n+        Object[] dst = getDst15(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    static void testConstantLen15NoInit() {\n+        Object[] src = getSrc15NoInit(LEN);\n+        Object[] dst = getDst15(LEN);\n+        try {\n+            System.arraycopy(src, 0, dst, 0, LEN);\n+            throw new RuntimeException(\"No NullPointerException thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static void testConstantLen16() {\n+        Object[] src = getSrc16(LEN);\n+        Object[] dst = getDst16(LEN);\n+        System.arraycopy(src, 0, dst, 0, LEN);\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(src[i], dst[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            int len = (i % 10) + 1;\n+            test1(len);\n+            test2(len);\n+            test2NoInit(len);\n+            test3(len);\n+            test3NoInit(len);\n+            test4(len);\n+            test5(len);\n+            test6(len);\n+            test7(len);\n+            test8(len);\n+            test9(len);\n+            test10(len);\n+            test11(len);\n+            test12(len);\n+            test13(len);\n+            test14(len);\n+            test14NoInit(len);\n+            test15(len);\n+            test15NoInit(len);\n+            test16(len);\n+\n+            testConstantLen1();\n+            testConstantLen2();\n+            testConstantLen2NoInit();\n+            testConstantLen3();\n+            testConstantLen3NoInit();\n+            testConstantLen4();\n+            testConstantLen5();\n+            testConstantLen6();\n+            testConstantLen7();\n+            testConstantLen8();\n+            testConstantLen9();\n+            testConstantLen10();\n+            testConstantLen11();\n+            testConstantLen12();\n+            testConstantLen13();\n+            testConstantLen14();\n+            testConstantLen14NoInit();\n+            testConstantLen15();\n+            testConstantLen15NoInit();\n+            testConstantLen16();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayCopy.java","additions":696,"deletions":0,"binary":false,"changes":696,"status":"added"},{"patch":"@@ -69,1 +69,0 @@\n- * @enablePreview\n@@ -82,1 +81,0 @@\n- * @enablePreview\n@@ -95,1 +93,0 @@\n- * @enablePreview\n@@ -108,1 +105,0 @@\n- * @enablePreview\n@@ -121,1 +117,0 @@\n- * @enablePreview\n@@ -134,1 +129,0 @@\n- * @enablePreview\n@@ -147,1 +141,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+\/*\n+ * @test\n+ * @summary Test correctness of the isInstance intrinsic with deep class hierarchies.\n+ * @run main\/othervm -Xbatch compiler.valhalla.inlinetypes.TestIsInstance\n+ *\/\n+\n+public class TestIsInstance {\n+    static interface MyInterface {\n+    }\n+\n+    static class MyClass0 implements MyInterface {\n+    }\n+\n+    static class MyClass1 extends MyClass0 {\n+    }\n+\n+    static class MyClass2 extends MyClass1 {\n+    }\n+\n+    static class MyClass3 extends MyClass2 {\n+    }\n+\n+    static class MyClass4 extends MyClass3 {\n+    }\n+\n+    static class MyClass5 extends MyClass4 {\n+    }\n+\n+    static class MyClass6 extends MyClass5 {\n+    }\n+\n+    static class MyClass7 extends MyClass6 {\n+    }\n+\n+    static class MyClass8 extends MyClass7 {\n+    }\n+\n+    static class MyClass9 extends MyClass8 {\n+    }\n+\n+    static class MyClass10 extends MyClass9 {\n+    }\n+\n+    public static void check(Object obj, Class<?> clazz, boolean expected) {\n+        if (expected != clazz.isInstance(obj)) {\n+            throw new RuntimeException(\"Unexpected result: \" + clazz + \".isInstance(\" + obj.getClass() + \") should return \" + expected);\n+        }\n+        \/\/ Also try a cast\n+        try {\n+            clazz.cast(obj);\n+        } catch (ClassCastException e) {\n+            if (expected) {\n+                throw new RuntimeException(\"Unexpected ClassCastException\", e);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Class<?>[] classes = new Class<?>[] {\n+            Object.class, MyInterface.class, MyClass0.class, MyClass1.class, MyClass2.class, MyClass3.class, MyClass4.class,\n+            MyClass5.class, MyClass6.class, MyClass7.class, MyClass8.class, MyClass9.class, MyClass10.class, Integer.class };\n+\n+        Class<?>[] arrayClasses = new Class<?>[] {\n+            java.lang.Cloneable.class, java.io.Serializable.class, Object.class, Object[].class,\n+            MyInterface[].class, MyClass0[].class, MyClass1[].class, MyClass2[].class, MyClass3[].class, MyClass4[].class,\n+            MyClass5[].class, MyClass6[].class, MyClass7[].class, MyClass8[].class, MyClass9[].class, MyClass10[].class, Integer[].class };\n+\n+        Class<?>[] multiDimArrayClasses = new Class<?>[] {\n+            java.lang.Cloneable.class, java.lang.Cloneable[].class, java.io.Serializable.class, java.io.Serializable[].class, Object.class, Object[].class, Object[].class,\n+            MyInterface[][].class, MyClass0[][].class, MyClass1[][].class, MyClass2[][].class, MyClass3[][].class, MyClass4[][].class,\n+            MyClass5[][].class, MyClass6[][].class, MyClass7[][].class, MyClass8[][].class, MyClass9[][].class, MyClass10[][].class, Integer[][].class };\n+\n+        for (int i = 0; i < 1000; ++i) {\n+            for (int j = 0; j < classes.length; ++j) {\n+                check(new MyClass0(), classes[j], j <= 2);\n+                check(new MyClass1(), classes[j], j <= 3);\n+                check(new MyClass2(), classes[j], j <= 4);\n+                check(new MyClass3(), classes[j], j <= 5);\n+                check(new MyClass4(), classes[j], j <= 6);\n+                check(new MyClass5(), classes[j], j <= 7);\n+                check(new MyClass6(), classes[j], j <= 8);\n+                check(new MyClass7(), classes[j], j <= 9);\n+                check(new MyClass8(), classes[j], j <= 10);\n+                check(new MyClass9(), classes[j], j <= 11);\n+                check(new MyClass10(), classes[j], j <= 12);\n+\n+                check(new MyInterface[0], arrayClasses[j], j <= 4);\n+                check(new MyClass0[0], arrayClasses[j], j <= 5);\n+                check(new MyClass1[0], arrayClasses[j], j <= 6);\n+                check(new MyClass2[0], arrayClasses[j], j <= 7);\n+                check(new MyClass3[0], arrayClasses[j], j <= 8);\n+                check(new MyClass4[0], arrayClasses[j], j <= 9);\n+                check(new MyClass5[0], arrayClasses[j], j <= 10);\n+                check(new MyClass6[0], arrayClasses[j], j <= 11);\n+                check(new MyClass7[0], arrayClasses[j], j <= 12);\n+                check(new MyClass8[0], arrayClasses[j], j <= 13);\n+                check(new MyClass9[0], arrayClasses[j], j <= 14);\n+                check(new MyClass10[0], arrayClasses[j], j <= 15);\n+\n+                check(new MyInterface[0][0], multiDimArrayClasses[j], j <= 7);\n+                check(new MyClass0[0][0], multiDimArrayClasses[j], j <= 8);\n+                check(new MyClass1[0][0], multiDimArrayClasses[j], j <= 9);\n+                check(new MyClass2[0][0], multiDimArrayClasses[j], j <= 10);\n+                check(new MyClass3[0][0], multiDimArrayClasses[j], j <= 11);\n+                check(new MyClass4[0][0], multiDimArrayClasses[j], j <= 12);\n+                check(new MyClass5[0][0], multiDimArrayClasses[j], j <= 13);\n+                check(new MyClass6[0][0], multiDimArrayClasses[j], j <= 14);\n+                check(new MyClass7[0][0], multiDimArrayClasses[j], j <= 15);\n+                check(new MyClass8[0][0], multiDimArrayClasses[j], j <= 16);\n+                check(new MyClass9[0][0], multiDimArrayClasses[j], j <= 17);\n+                check(new MyClass10[0][0], multiDimArrayClasses[j], j <= 18);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIsInstance.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -600,1 +600,1 @@\n-        MyValue1[]  va2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] va2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -663,2 +663,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -666,1 +666,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -668,1 +668,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -707,2 +707,2 @@\n-        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n-        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -710,1 +710,1 @@\n-        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -712,1 +712,1 @@\n-        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n@@ -753,1 +753,1 @@\n-        MyValue1[]  src2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] src2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -811,2 +811,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -814,1 +814,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -816,1 +816,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n@@ -854,2 +854,2 @@\n-        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n-        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -857,1 +857,1 @@\n-        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -859,1 +859,1 @@\n-        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n@@ -893,2 +893,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -896,1 +896,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -898,1 +898,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -932,2 +932,2 @@\n-        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n-        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -935,1 +935,1 @@\n-        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -937,1 +937,1 @@\n-        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n@@ -2531,1 +2531,1 @@\n-        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2547,1 +2547,1 @@\n-        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n@@ -2561,1 +2561,1 @@\n-        MyValue1[]  dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.internal.misc.Unsafe;\n+import jdk.test.whitebox.WhiteBox;\n@@ -32,0 +32,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -37,2 +38,0 @@\n-\/\/ Tiered compilation runs:\n-\n@@ -42,1 +41,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -49,1 +48,4 @@\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n@@ -57,1 +59,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -64,1 +66,4 @@\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n@@ -73,1 +78,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -80,1 +85,4 @@\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n@@ -89,1 +97,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -96,1 +104,4 @@\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n@@ -106,1 +117,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -113,3 +124,6 @@\n- * @run main\/othervm\/timeout=1000 -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n- *                                -Xcomp -XX:-TieredCompilation\n- *                                compiler.valhalla.inlinetypes.TestTearing\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ *                   -Xcomp -XX:-TieredCompilation\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n@@ -121,1 +135,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -128,1 +142,4 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -136,1 +153,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -143,1 +160,4 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -152,1 +172,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -159,1 +179,4 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -168,1 +191,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @requires vm.compMode != \"Xint\" & vm.flavor == \"server\"\n@@ -175,1 +198,4 @@\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -182,138 +208,0 @@\n-\n-\/\/ C1 only runs:\n-\n-\/*\n- * @test id=c1-no-flattening\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-no-flattening-AII\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-no-flattening-di\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-no-flattening-di-AII\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-xcomp\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm\/timeout=1000 -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n- *                                -Xcomp -XX:-TieredCompilation\n- *                                compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-flattening\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-flattening-AII\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-flattening-di\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n-\/*\n- * @test id=c1-flattening-di-AII\n- * @requires vm.compMode != \"Xint\" & (vm.opt.TieredStopAtLevel != null & vm.opt.TieredStopAtLevel < 4)\n- * @summary Detect tearing on flat accesses and buffering. These runs use a much smaller loop limit to avoid timeouts\n- *          with C1 only.\n- * @library \/testlibrary \/test\/lib \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestTearing C1\n- *\/\n-\n@@ -362,0 +250,8 @@\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final boolean SLOW_CONFIGURATION =\n+        (WHITE_BOX.getIntxVMFlag(\"TieredStopAtLevel\").intValue() < 4) ||\n+         WHITE_BOX.getBooleanVMFlag(\"SafepointALot\") ||\n+         WHITE_BOX.getBooleanVMFlag(\"DeoptimizeALot\") ||\n+         WHITE_BOX.getBooleanVMFlag(\"DeoptimizeNMethodBarriersALot\") ||\n+        !WHITE_BOX.getBooleanVMFlag(\"UseTLAB\");\n+\n@@ -516,2 +412,2 @@\n-        if (args.length > 0) {\n-            Asserts.assertTrue(args[0].equals(\"C1\"));\n+        if (SLOW_CONFIGURATION) {\n+            \/\/ Lower the number of iterations in slow configurations\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTearing.java","additions":59,"deletions":163,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -777,0 +777,5 @@\n+        \/\/ TODO 8367258\n+        if (WHITE_BOX.getBooleanVMFlag(\"SafepointALot\") || WHITE_BOX.getBooleanVMFlag(\"DeoptimizeALot\") || WHITE_BOX.getBooleanVMFlag(\"DeoptimizeNMethodBarriersALot\")) {\n+            return;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestVirtualThreads.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}