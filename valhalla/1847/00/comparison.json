{"files":[{"patch":"@@ -834,0 +834,10 @@\n+    public JCExpression qualident(boolean allowAnnos, int newmode) {\n+        int prevmode = mode;\n+        setMode(newmode);\n+        try {\n+            return qualident(allowAnnos);\n+        } finally {\n+            setMode(prevmode);\n+        }\n+    }\n+\n@@ -839,0 +849,4 @@\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            checkNullRestrictionLocation(BAD_BANG_LOCATION_QUALIDENT);\n+            nextToken();\n+        }\n@@ -850,0 +864,4 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                checkNullRestrictionLocation(BAD_BANG_LOCATION_QUALIDENT);\n+                nextToken();\n+            }\n@@ -1617,3 +1635,4 @@\n-                    checkNullRestrictionLocation();\n-                    selectTypeMode();\n-                    setNullMarker(t);\n+                    if (checkNullRestrictionLocation()) {\n+                        selectTypeMode();\n+                        setNullMarker(t);\n+                    }\n@@ -1898,3 +1917,4 @@\n-                checkNullRestrictionLocation();\n-                setNullMarker(t);\n-                selectTypeMode();\n+                if (checkNullRestrictionLocation()) {\n+                    setNullMarker(t);\n+                    selectTypeMode();\n+                }\n@@ -2147,1 +2167,2 @@\n-                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN) ||\n+                            allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, AMP)) {\n@@ -2181,1 +2202,2 @@\n-                            peekToken(lookahead, RBRACKET, AMP)) {\n+                            peekToken(lookahead, RBRACKET, AMP) ||\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, AMP))) {\n@@ -2211,1 +2233,2 @@\n-                                peekToken(lookahead, AMP)) {\n+                                peekToken(lookahead, AMP) ||\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, AMP))) {\n@@ -2273,0 +2296,1 @@\n+    protected Predicate<TokenKind> BAD_BANG_LOCATION_QUALIDENT = t -> t == MONKEYS_AT || t == DOT || t == LPAREN;\n@@ -2633,1 +2657,1 @@\n-    void checkNullRestrictionLocation() {\n+    boolean checkNullRestrictionLocation() {\n@@ -2637,0 +2661,1 @@\n+            return false;\n@@ -2638,1 +2663,1 @@\n-            checkNullRestrictonAllowed();\n+            return checkNullRestrictonAllowed();\n@@ -2642,1 +2667,11 @@\n-    void checkNullRestrictonAllowed() {\n+    boolean checkNullRestrictionLocation(Predicate<TokenKind> badLocationFilter) {\n+        Assert.check(EMOTIONAL_QUALIFIER.test(token.kind));\n+        if (peekToken(badLocationFilter)) {\n+            unsupportedNullRestriction();\n+            return false;\n+        } else {\n+            return checkNullRestrictonAllowed();\n+        }\n+    }\n+\n+    boolean checkNullRestrictonAllowed() {\n@@ -2646,0 +2681,1 @@\n+            return false;\n@@ -2647,0 +2683,1 @@\n+        return true;\n@@ -2653,0 +2690,7 @@\n+    void skipUnsupportedNullRestriction() {\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            unsupportedNullRestriction();\n+            nextToken();\n+        }\n+    }\n+\n@@ -2764,1 +2808,1 @@\n-        JCExpression t = qualident(true);\n+        JCExpression t = qualident(true, TYPE | ALLOW_BANGS);\n@@ -3441,1 +3485,1 @@\n-        catchTypes.add(parseType());\n+        catchTypes.add(parseType(TYPE | ALLOW_BANGS));\n@@ -3446,1 +3490,1 @@\n-            catchTypes.add(parseType());\n+            catchTypes.add(parseType(TYPE | ALLOW_BANGS));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":59,"deletions":15,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @enablePreview\n+ * @summary smoke test for negative parser test for null restrictions\n+ * @compile\/fail\/ref=NullRestrictionNegParserTest.out -XDrawDiagnostics NullRestrictionNegParserTest.java\n+ *\/\n+\n+class NullRestrictionNegParserTest {\n+    static class Foo extends Bar! { } \/\/ not valid, superclass\n+    static class Foo implements Bar! { } \/\/ not valid, superinterface\n+\n+    class Foo<X extends String!> { } \/\/ not valid, type-param bound\n+    <X extends String!> void foo() { } \/\/ not valid, type-param bound\n+\n+    void foo() throws Error! { } \/\/ not valid, throws type\n+\n+    void testNew() {\n+        new Foo!(); \/\/ bad, class creation expression\n+    }\n+\n+    void testNewArray() {\n+        var z = new Foo![2]; \/\/ ok\n+        var y = new Foo![2]!; \/\/ bad, bang can't appear at the end\n+        var x = new Foo![2][][][]!; \/\/ bad, bang can't appear at the end\n+        var x = new Foo![2][]![][]!; \/\/ bad, bang can't appear in the middle or at the end\n+        var x = new Foo![2][1][1][1]!; \/\/ bad, bang can't appear at the end\n+        var x = new Foo![2][1]![1][1]!; \/\/ bad, bang can't appear at the end\n+        var x = new Bar!.Foo![2][1]![1][1]!; \/\/ bad, bang can't appear at the end, and bad qualifier\n+    }\n+\n+    void testNoBangInQualifiedTypeNames() {\n+        a!.x x = \"\"; \/\/ bad, bang before '.'\n+        a!.b!.x x = \"\"; \/\/ bad, bang before '.'\n+        a!.m(); \/\/ bad, bang before '.'\n+        a.b!.m(); \/\/ bad, bang before '.'\n+    }\n+\n+    static class TestConstructor {\n+        TestConstructor!() { } \/\/ bad, no bang in constructor type\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionNegParserTest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+NullRestrictionNegParserTest.java:9:33: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:10:36: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:12:31: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:13:22: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:15:28: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:18:16: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:23:28: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:24:34: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:25:30: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:25:35: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:26:37: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:27:31: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:27:38: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:28:24: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:28:36: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:28:43: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:32:10: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:33:10: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:33:13: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:34:10: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:35:12: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:39:24: compiler.err.unsupported.null.restriction\n+22 errors\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionNegParserTest.out","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for null restriction parsing\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build combo.ComboTestHelper\n+\n+ * @run main NullRestrictionParserTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask.Result;\n+import combo.ComboTestHelper;\n+\n+public class NullRestrictionParserTest extends ComboInstance<NullRestrictionParserTest> {\n+\n+    enum AnnoKind implements ComboParameter {\n+        ANNO(\"@A \"),\n+        NO_ANNO(\"\");\n+\n+        final String annoTemplate;\n+\n+        AnnoKind(String annoTemplate) {\n+            this.annoTemplate = annoTemplate;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return annoTemplate;\n+        }\n+    }\n+\n+    enum TypeKind implements ComboParameter {\n+        STRING(\"#{ANNO}String\", 0),\n+        NN_STRING(\"#{ANNO}String!\", 0),\n+        STRING_ARR(\"#{ANNO}String[]\", 0),\n+        STRING_NN_ARR(\"#{ANNO}String[]!\", 0),\n+        NN_STRING_ARR(\"#{ANNO}String![]\", 1),\n+        NN_STRING_NN_ARR(\"#{ANNO}String![]!\", 1),\n+        STRING_ARR_ARR(\"#{ANNO}String[][]\", 0),\n+        STRING_NN_ARR_ARR(\"#{ANNO}String[]![]\", 1),\n+        STRING_NN_ARR_NN_ARR(\"#{ANNO}String[]![]!\", 1),\n+        NN_STRING_ARR_ARR(\"#{ANNO}String![]!\", 1),\n+        NN_STRING_NN_ARR_ARR(\"#{ANNO}String![]![]\", 2),\n+        NN_STRING_NN_ARR_NN_ARR(\"#{ANNO}String![]![]!\", 2);\n+\n+\n+        final String typeTemplate;\n+        final int errors;\n+\n+        TypeKind(String typeTemplate, int errors) {\n+            this.typeTemplate = typeTemplate;\n+            this.errors = errors;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return typeTemplate;\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<NullRestrictionParserTest>()\n+                .withDimension(\"ANNO\", (x, ak) -> x.ak = ak, AnnoKind.values())\n+                .withDimension(\"TYPE\", (x, tk) -> x.tk = tk, TypeKind.values())\n+                .run(NullRestrictionParserTest::new);\n+    }\n+\n+    AnnoKind ak;\n+    TypeKind tk;\n+\n+    static final String TEMPLATE = \"\"\"\n+            import java.lang.annotation.ElementType;\n+            import java.lang.annotation.Target;\n+\n+            class Test {\n+\n+                @Target(ElementType.TYPE_USE)\n+                @interface A {}\n+\n+                #{TYPE} restype() { throw new AssertionError(); }\n+                void argtype(#{TYPE} arg) { throw new AssertionError(); }\n+                void final_argtype(final #{TYPE} arg) { throw new AssertionError(); }\n+                void varargtype(#{TYPE}... args) { throw new AssertionError(); }\n+\n+                #{TYPE} field;\n+\n+                void testLocal() {\n+                    #{TYPE} local;\n+                    final #{TYPE} local;\n+                }\n+\n+                void testCast(Object o) {\n+                    var x = (#{TYPE})o;\n+                }\n+\n+                void testIntersectionCast(Object o) {\n+                    var x = (#{TYPE} & #{TYPE})o;\n+                }\n+\n+                void testInstanceof(Object o) {\n+                    var x = o instanceof #{TYPE};\n+                    var x = o instanceof #{TYPE} p;\n+                }\n+\n+                void testSwitch(Object o) {\n+                    switch (o) {\n+                        case #{TYPE} p -> { }\n+                        default -> { }\n+                    };\n+                }\n+\n+                void testCatch() {\n+                    try {\n+                        foo();\n+                    } catch (#{TYPE} t) { }\n+                }\n+\n+                void testMultiCatch() {\n+                    try {\n+                        foo();\n+                    } catch (#{TYPE} | #{TYPE} t) { }\n+                }\n+            }\n+            \"\"\";\n+\n+    static final int num_types;\n+\n+    static {\n+        int occurrences = 0;\n+        int start = -1;\n+        while (start + 1 < TEMPLATE.length() && (start = TEMPLATE.indexOf(\"#{TYPE}\", start + 1)) != -1) {\n+            occurrences++;\n+        }\n+        num_types = occurrences;\n+    }\n+\n+    @Override\n+    public void doWork() throws IOException {\n+        newCompilationTask()\n+                .withOptions(List.of(\"--enable-preview\", \"--release\", \"26\"))\n+                .withSourceFromTemplate(TEMPLATE)\n+                .parse(this::check);\n+    }\n+\n+    void check(Result<?> res) {\n+        int expectedErrors = tk.errors * num_types;\n+\n+        var errors = res.diagnosticsForKey(\"compiler.err.unsupported.null.restriction\");\n+\n+        if (expectedErrors != errors.length()) {\n+            fail(\"invalid diagnostics for source:\\n\" +\n+                    res.compilationInfo() +\n+                    \"\\nFound error: \" + errors +\n+                    \"\\nExpected error: \" + expectedErrors);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionParserTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -1,198 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @summary Smoke test for parsing of bang types\n- * @compile NullabilityParsingBangTest.java\n- *\/\n-\n-import java.util.function.*;\n-\n-class NullabilityParsingBangTest {\n-    static value class Point { public implicit Point(); }\n-    static value class Shape { public implicit Shape(); }\n-    \/\/ fields\n-    Point! o2 = new Point();\n-\n-    \/\/ method parameters\n-    void m2(Point! o) { }\n-\n-    \/\/ method returns\n-    Point! m2() { return new Point(); }\n-\n-    \/\/ locals\n-    void testLocals() {\n-        Point! o2;\n-    }\n-\n-    \/\/ generics - field\n-    Consumer<Point!> co2;\n-\n-    \/\/ generics - method param\n-    void m4(Consumer<Point!> co) { }\n-\n-    \/\/ generics - method return\n-    Consumer<Point!> m4() { return null; }\n-\n-    \/\/ generics - local\n-    void testGenericLocals() {\n-        Consumer<Point!> co2;\n-    }\n-\n-    \/\/ lambdas\n-    void testLambdas() {\n-        Consumer<Point!> co2 = (Point! co) -> {};\n-    }\n-\n-    void testGenericLambdas() {\n-        Consumer<Consumer<Point!>> co2 = (Consumer<Point!> co) -> {};\n-        Consumer<Function<Point!, Point!>> co3 = (Function<Point!, Point!> co) -> {};\n-        Consumer<Consumer<Consumer<Consumer<Point!>>>> co6 = (Consumer<Consumer<Consumer<Point!>>> co) -> {};\n-    }\n-\n-    \/\/ type test patterns\n-\n-    void testTypeTestPatterns(Object o) {\n-        switch (o) {\n-            case Point! i -> throw new AssertionError();\n-            case Shape! s -> throw new AssertionError();\n-            default -> throw new AssertionError();\n-        }\n-    }\n-\n-    sealed interface I<X> {}\n-    final class A implements I<Point> { }\n-\n-    void genericTypeTestPatterns(A o) {\n-        switch (o) {\n-            case I<Point!> i -> { }\n-        }\n-    }\n-\n-    sealed interface I2<X> {}\n-    final class A2 implements I2<I<Point>> { }\n-\n-    void genericTypeTestPatterns(A2 o) {\n-        switch (o) {\n-            case I2<I<Point!>> i -> { }\n-        }\n-    }\n-\n-    sealed interface I3<X> {}\n-    final class A3 implements I3<I2<I<Point>>> { }\n-\n-    void genericTypeTestPatterns(A3 o) {\n-        switch (o) {\n-            case I3<I2<I<Point!>>> i -> { }\n-        }\n-    }\n-\n-    \/\/ record patterns\n-\n-    record R(A a) { }\n-\n-    void genericRecordPatterns(R o) {\n-        switch (o) {\n-            case R!(I<Point!> i) -> { }\n-        }\n-    }\n-\n-    record R2(A2 a2) { }\n-\n-    void genericRecordPatterns(R2 o) {\n-        switch (o) {\n-            case R2!(I2<I<Point!>> i) -> { }\n-        }\n-    }\n-\n-    record R3(A3 a3) { }\n-\n-    void genericRecordPatterns(R3 o) {\n-        switch (o) {\n-            case R3!(I3<I2<I<Point!>>> i) -> { }\n-        }\n-    }\n-\n-    \/\/ instanceof\/cast\n-\n-    void testInstanceOf(Object o) {\n-        boolean r2 = o instanceof Point!;\n-    }\n-\n-    void testInstanceRecord(R r) {\n-        boolean r2 = r instanceof R(I<Point!> i);\n-    }\n-\n-    void testCast(Object o) {\n-        Point! s2 = (Point!)o;\n-    }\n-\n-    void testGenericCast(A a) {\n-        I<Point!> i2 = (I<Point!>)a;\n-    }\n-\n-    void testGenericCast2(A a) {\n-        I<Point!> i2 = (I<Point!>)a;\n-    }\n-\n-    \/\/ arrays\n-\n-    Point![]![]![]! oarr = {{{new Point()}}};\n-    Function<Point![]![]!, Function<Point![]![]!, Point![]![]!>>[][] garr;\n-\n-    void mBad1(Object o) {\n-        Point s1 = o instanceof Point ? (Point)o : null;\n-        Point s2 = o instanceof Point! ? (Point)o : null;\n-    }\n-\n-    void mBad2(Object o) {\n-        Point s1 = o instanceof Point ? null : null;\n-        Point s2 = o instanceof Point! ? null : null;\n-    }\n-\n-    void testPatternRule(Object o) {\n-        switch (o) {\n-            case Point! s -> { }\n-                default -> { }\n-        }\n-    }\n-\n-    void testPatternCol(Object o) {\n-        switch (o) {\n-            case Point! s: { }\n-            default: { }\n-        }\n-    }\n-\n-    void testInstanceOfAndInfix1(Object a, boolean b) {\n-        boolean x2 = a instanceof Point! && b;\n-    }\n-\n-    void testInstanceOfAndInfix2(Object a, boolean b) {\n-        boolean x2 = a instanceof Point! s && b;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingBangTest.java","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,199 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @summary Smoke test for parsing of bang types\n- * @compile NullabilityParsingQuesTest.java\n- *\/\n-\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-class NullabilityParsingQuesTest {\n-    static value class Point { public implicit Point(); }\n-    static value class Shape { public implicit Shape(); }\n-    \/\/ fields\n-    Point? o2;\n-\n-    \/\/ method parameters\n-    void m2(Point? o) { }\n-\n-    \/\/ method returns\n-    Point? m2() { return new Point(); }\n-\n-    \/\/ locals\n-    void testLocals() {\n-        Point? o2;\n-    }\n-\n-    \/\/ generics - field\n-    Consumer<Point?> co2;\n-\n-    \/\/ generics - method param\n-    void m4(Consumer<Point?> co) { }\n-\n-    \/\/ generics - method return\n-    Consumer<Point?> m4() { return null; }\n-\n-    \/\/ generics - local\n-    void testGenericLocals() {\n-        Consumer<Point?> co2;\n-    }\n-\n-    \/\/ lambdas\n-    void testLambdas() {\n-        Consumer<Point?> co2 = (Point? co) -> {};\n-    }\n-\n-    void testGenericLambdas() {\n-        Consumer<Consumer<Point?>> co2 = (Consumer<Point?> co) -> {};\n-        Consumer<Function<Point?, Point?>> co3 = (Function<Point?, Point?> co) -> {};\n-        Consumer<Consumer<Consumer<Consumer<Point?>>>> co6 = (Consumer<Consumer<Consumer<Point?>>> co) -> {};\n-    }\n-\n-    \/\/ type test patterns\n-\n-    void testTypeTestPatterns(Object o) {\n-        switch (o) {\n-            case Point? i -> throw new AssertionError();\n-            case Shape? s -> throw new AssertionError();\n-            default -> throw new AssertionError();\n-        }\n-    }\n-\n-    sealed interface I<X> {}\n-    final class A implements I<Point> { }\n-\n-    void genericTypeTestPatterns(A o) {\n-        switch (o) {\n-            case I<Point?> i -> { }\n-        }\n-    }\n-\n-    sealed interface I2<X> {}\n-    final class A2 implements I2<I<Point>> { }\n-\n-    void genericTypeTestPatterns(A2 o) {\n-        switch (o) {\n-            case I2<I<Point?>> i -> { }\n-        }\n-    }\n-\n-    sealed interface I3<X> {}\n-    final class A3 implements I3<I2<I<Point>>> { }\n-\n-    void genericTypeTestPatterns(A3 o) {\n-        switch (o) {\n-            case I3<I2<I<Point?>>> i -> { }\n-        }\n-    }\n-\n-    \/\/ record patterns\n-\n-    record R(A a) { }\n-\n-    void genericRecordPatterns(R o) {\n-        switch (o) {\n-            case R?(I<Point?> i) -> { }\n-        }\n-    }\n-\n-    record R2(A2 a2) { }\n-\n-    void genericRecordPatterns(R2 o) {\n-        switch (o) {\n-            case R2?(I2<I<Point?>> i) -> { }\n-        }\n-    }\n-\n-    record R3(A3 a3) { }\n-\n-    void genericRecordPatterns(R3 o) {\n-        switch (o) {\n-            case R3?(I3<I2<I<Point?>>> i) -> { }\n-        }\n-    }\n-\n-    \/\/ instanceof\/cast\n-\n-    void testInstanceOf(Object o) {\n-        boolean r2 = o instanceof Point?;\n-    }\n-\n-    void testInstanceRecord(R r) {\n-        boolean r2 = r instanceof R(I<Point?> i);\n-    }\n-\n-    void testCast(Object o) {\n-        Point? s2 = (Point?)o;\n-    }\n-\n-    void testGenericCast(A a) {\n-        I<Point?> i2 = (I<Point?>)a;\n-    }\n-\n-    void testGenericCast2(A a) {\n-        I<Point?> i2 = (I<Point?>)a;\n-    }\n-\n-    \/\/ arrays\n-\n-    Point?[]?[]?[]? oarr;\n-    Function<Point?[]?[]?, Function<Point?[]?[]?, Point?[]?[]?>>[][] garr;\n-\n-    void mBad1(Object o) {\n-        Point s1 = o instanceof Point ? (Point)o : null;\n-        Point s2 = o instanceof Point? ? (Point)o : null;\n-    }\n-\n-    void mBad2(Object o) {\n-        Point s1 = o instanceof Point ? null : null;\n-        Point s2 = o instanceof Point? ? null : null;\n-    }\n-\n-    void testPatternRule(Object o) {\n-        switch (o) {\n-            case Point? s -> { }\n-                default -> { }\n-        }\n-    }\n-\n-    void testPatternCol(Object o) {\n-        switch (o) {\n-            case Point? s: { }\n-            default: { }\n-        }\n-    }\n-\n-    void testInstanceOfAndInfix1(Object a, boolean b) {\n-        boolean x2 = a instanceof Point? && b;\n-    }\n-\n-    void testInstanceOfAndInfix2(Object a, boolean b) {\n-        boolean x2 = a instanceof Point? s && b;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingQuesTest.java","additions":0,"deletions":199,"binary":false,"changes":199,"status":"deleted"}]}