{"files":[{"patch":"@@ -185,0 +185,1 @@\n+JVM_NewNullRestrictedArray\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -876,1 +876,0 @@\n-                                       bool* const is_declared_atomic,\n@@ -993,0 +992,3 @@\n+    _jdk_internal_ImplicitlyConstructible,\n+    _jdk_internal_LooselyConsistentValue,\n+    _jdk_internal_NullRestricted,\n@@ -1546,0 +1548,2 @@\n+    bool is_null_restricted = false;\n+\n@@ -1565,0 +1569,10 @@\n+        if (parsed_annotations.has_annotation(AnnotationCollector::_jdk_internal_NullRestricted)) {\n+          if (!Signature::has_envelope(sig)) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s with signature %s (primitive types can never be null)\",\n+              name->as_C_string(), sig->as_C_string());\n+          }\n+          is_null_restricted = true;\n+        }\n@@ -1596,1 +1610,1 @@\n-    if (type == T_PRIMITIVE_OBJECT) fieldFlags.update_null_free_inline_type(true);\n+    if (type == T_PRIMITIVE_OBJECT || is_null_restricted) fieldFlags.update_null_free_inline_type(true);\n@@ -2070,0 +2084,12 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ImplicitlyConstructible_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_ImplicitlyConstructible;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_LooselyConsistentValue_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_LooselyConsistentValue;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NullRestricted_signature): {\n+      if (_location != _in_field)   break; \/\/ only allow for fields\n+      return _jdk_internal_NullRestricted;\n+    }\n@@ -5063,0 +5089,10 @@\n+bool ClassFileParser::is_class_in_preload_attribute(Symbol *klass) {\n+  if (_preload_classes == nullptr) return false;\n+  for (int i = 0; i < _preload_classes->length(); i++) {\n+        \/\/ if (_cp->tag_at(_preload_classes->at(i)).is_klass()) continue;\n+        Symbol* class_name = _cp->klass_at_noresolve(_preload_classes->at(i));\n+        if (class_name == klass) return true;\n+  }\n+  return false;\n+}\n+\n@@ -5664,3 +5700,0 @@\n-  if (_is_declared_atomic) {\n-    ik->set_is_declared_atomic();\n-  }\n@@ -5668,0 +5701,6 @@\n+  if (_must_be_atomic) {\n+    ik->set_must_be_atomic();\n+  }\n+  if (_is_implicitly_constructible) {\n+    ik->set_is_implicitly_constructible();\n+  }\n@@ -5940,1 +5979,2 @@\n-  _is_declared_atomic(false),\n+  _must_be_atomic(true),\n+  _is_implicitly_constructible(false),\n@@ -5943,0 +5983,2 @@\n+  _has_loosely_consistent_annotation(false),\n+  _has_implicitly_constructible_annotation(false),\n@@ -6268,1 +6310,0 @@\n-                   &_is_declared_atomic,\n@@ -6407,2 +6448,11 @@\n-    if (_super_klass->is_declared_atomic()) {\n-      _is_declared_atomic = true;\n+\n+    if (EnableValhalla && _access_flags.is_value_class()) {\n+      const InstanceKlass* k = _super_klass;\n+      int inherited_fields= 0;\n+      while (k != nullptr) {\n+        inherited_fields += k->total_fields_count();\n+        k = k->super() == nullptr ? nullptr :  InstanceKlass::cast(k->super());\n+      }\n+      if (inherited_fields > 0) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Value classes don't support inherited fields yet\");\n+      }\n@@ -6412,5 +6462,34 @@\n-  if (*ForceNonTearable != '\\0') {\n-    \/\/ Allow a command line switch to force the same atomicity property:\n-    const char* class_name_str = _class_name->as_C_string();\n-    if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n-      _is_declared_atomic = true;\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && !_access_flags.is_value_class()) {\n+    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n+          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.LooselyConsistentValue, because it is not a value class\",\n+                  _class_name->as_klass_external_name()));\n+  }\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_ImplicitlyConstructible) && !_access_flags.is_value_class()) {\n+    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n+          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.ImplicitlyConstructible, because it is not a value class\",\n+                  _class_name->as_klass_external_name()));\n+  }\n+\n+  \/\/ Determining is the class allows tearing or not (default is not)\n+  \/\/ Test might need extensions when field inheritance is added for value classes\n+  if (EnableValhalla && _access_flags.is_value_class()) {\n+    if (_access_flags.is_primitive_class()) {\n+      _must_be_atomic = false;             \/\/ old semantic, primitive classes are always non-atomic\n+      _is_implicitly_constructible = true; \/\/ old semantic, primitive classes are always implicitly constructible\n+    } else {\n+      if (_super_klass != nullptr  \/\/ not j.l.Object\n+               && _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+               && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+        _must_be_atomic = false;\n+      }\n+      if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)) {\n+        _is_implicitly_constructible = true;\n+      }\n+    }\n+    \/\/ Apply VM options override\n+    if (*ForceNonTearable != '\\0') {\n+      \/\/ Allow a command line switch to force the same atomicity property:\n+      const char* class_name_str = _class_name->as_C_string();\n+      if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+        _must_be_atomic = true;\n+      }\n@@ -6462,3 +6541,0 @@\n-      if (InstanceKlass::cast(interf)->is_declared_atomic()) {\n-        _is_declared_atomic = true;\n-      }\n@@ -6503,1 +6579,0 @@\n-\n@@ -6512,1 +6587,0 @@\n-\n@@ -6522,4 +6596,4 @@\n-            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                      err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n-                      _class_name->as_C_string(),\n-                      InstanceKlass::cast(klass)->external_name()));\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                    _class_name->as_C_string(),\n+                    InstanceKlass::cast(klass)->external_name()));\n@@ -6528,0 +6602,19 @@\n+      } else {\n+        if (sig != _class_name && is_class_in_preload_attribute(sig)) {\n+          oop loader = loader_data()->class_loader();\n+          Klass* klass = SystemDictionary::resolve_or_null(sig, Handle(THREAD, loader), _protection_domain, THREAD);\n+          if (HAS_PENDING_EXCEPTION) {\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+          \/\/ Should we verify that klass is a value class? What the PreLoad attribute spec says about that?\n+          if (klass != nullptr) {\n+            if (klass->is_inline_klass()) {\n+              _inline_type_field_klasses->at_put(fieldinfo.index(), InlineKlass::cast(klass));\n+              log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute\", sig->as_C_string(), _class_name->as_C_string());\n+            } else {\n+              log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute but loaded class is not a value class\", sig->as_C_string(), _class_name->as_C_string());\n+            }\n+          } else {\n+            log_warning(class, preload)(\"Preloading of class %s during linking of class %s (Preload attribute) failed\", sig->as_C_string(), _class_name->as_C_string());\n+          }\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":116,"deletions":23,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -210,1 +210,2 @@\n-  bool _is_declared_atomic;\n+  bool _must_be_atomic;\n+  bool _is_implicitly_constructible;\n@@ -213,0 +214,2 @@\n+  bool _has_loosely_consistent_annotation;\n+  bool _has_implicitly_constructible_annotation;\n@@ -261,1 +264,0 @@\n-                        bool* is_declared_atomic,\n@@ -622,0 +624,2 @@\n+  bool is_class_in_preload_attribute(Symbol *klass);\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -556,0 +556,2 @@\n+  _atomic_field_count(0),\n+  _fields_size_sum(0),\n@@ -562,1 +564,1 @@\n-  _atomic_field_count(0)\n+  _nullable_atomic_flat_candidate(false)\n@@ -596,1 +598,1 @@\n-void FieldLayoutBuilder::regular_field_sorting() {\n+void FieldLayoutBuilder::regular_field_sorting(TRAPS) {\n@@ -644,0 +646,9 @@\n+          \/\/ Check below is performed for non-static fields, it should be performed for static fields too but at this stage,\n+          \/\/ it is not guaranteed that the klass of the static field has been loaded, so the test for static fields is delayed\n+          \/\/ until the linking phase\n+          Klass* klass =  _inline_type_field_klasses->at(idx);\n+          assert(klass != nullptr, \"Sanity check\");\n+          InlineKlass* vk = InlineKlass::cast(klass);\n+          if (!vk->is_implicitly_constructible()) {\n+            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n+          }\n@@ -648,4 +659,0 @@\n-          JavaThread* THREAD = JavaThread::current();\n-          Klass* klass =  _inline_type_field_klasses->at(idx);\n-          assert(klass != nullptr, \"Sanity check\");\n-          InlineKlass* vk = InlineKlass::cast(klass);\n@@ -654,1 +661,1 @@\n-          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+          bool too_atomic_to_flatten = vk->must_be_atomic() || AlwaysAtomicAccesses;\n@@ -745,4 +752,3 @@\n-          \/\/ Flattening decision to be taken here\n-          \/\/ This code assumes all verifications have already been performed\n-          \/\/ (field's type has been loaded and it is an inline klass)\n-          JavaThread* THREAD = JavaThread::current();\n+          \/\/ Check below is performed for non-static fields, it should be performed for static fields too but at this stage,\n+          \/\/ it is not guaranteed that the klass of the static field has been loaded, so the test for static fields is delayed\n+          \/\/ until the linking phase\n@@ -752,0 +758,6 @@\n+          if (!vk->is_implicitly_constructible()) {\n+            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Null restricted fields with a non-implicitly constructible class are not supported\");\n+          }\n+          \/\/ Flattening decision to be taken here\n+          \/\/ This code assumes all verifications have already been performed\n+          \/\/ (field's type has been loaded and it is an inline klass)\n@@ -754,1 +766,1 @@\n-          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+          bool too_atomic_to_flatten = vk->must_be_atomic() || AlwaysAtomicAccesses;\n@@ -807,1 +819,1 @@\n-void FieldLayoutBuilder::compute_regular_layout() {\n+void FieldLayoutBuilder::compute_regular_layout(TRAPS) {\n@@ -810,1 +822,1 @@\n-  regular_field_sorting();\n+  regular_field_sorting(CHECK);\n@@ -1003,1 +1015,1 @@\n-    compute_regular_layout();\n+    compute_regular_layout(CHECK);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -257,0 +257,2 @@\n+  int _atomic_field_count;\n+  int _fields_size_sum;\n@@ -263,1 +265,1 @@\n-  int _atomic_field_count;\n+  bool _nullable_atomic_flat_candidate;\n@@ -288,1 +290,1 @@\n-  void compute_regular_layout();\n+  void compute_regular_layout(TRAPS);\n@@ -295,1 +297,1 @@\n-  void regular_field_sorting();\n+  void regular_field_sorting(TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -269,0 +269,3 @@\n+  template(jdk_internal_vm_annotation_ImplicitlyConstructible_signature,     \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\") \\\n+  template(jdk_internal_vm_annotation_LooselyConsistentValue_signature,      \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\") \\\n+  template(jdk_internal_vm_annotation_NullRestricted_signature,              \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1135,0 +1135,3 @@\n+JNIEXPORT jarray JNICALL\n+JVM_NewNullRestrictedArray(JNIEnv *env, jclass elmClass, jint len);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  if (is_declared_atomic() && !is_naturally_atomic()) {\n+  if (must_be_atomic() && !is_naturally_atomic()) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-  bool is_atomic() { return is_naturally_atomic() || is_declared_atomic(); }\n+  bool is_atomic() { return is_naturally_atomic() || must_be_atomic(); }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,0 +983,29 @@\n+\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+      if (fs.is_null_free_inline_type() && fs.access_flags().is_static()) {\n+        Symbol* sig = fs.signature();\n+        oop loader = class_loader();\n+        oop protection_domain = this->protection_domain();\n+        Klass* klass = SystemDictionary::resolve_or_fail(sig,\n+                                                        Handle(THREAD, loader), Handle(THREAD, protection_domain), true,\n+                                                        CHECK_false);\n+        if (klass == nullptr) {\n+          THROW_(vmSymbols::java_lang_LinkageError(), false);\n+        }\n+        if (!klass->is_inline_klass()) {\n+          Exceptions::fthrow(\n+            THREAD_AND_LOCATION,\n+            vmSymbols::java_lang_IncompatibleClassChangeError(),\n+            \"class %s is not an inline type\",\n+            klass->external_name());\n+        }\n+        InstanceKlass* ik = InstanceKlass::cast(klass);\n+        if (!ik->is_implicitly_constructible()) {\n+          Exceptions::fthrow(\n+            THREAD_AND_LOCATION,\n+            vmSymbols::java_lang_IncompatibleClassChangeError(),\n+            \"class %s is not implicitly constructible and it is used in a null restricted static field (not supported)\",\n+            klass->external_name());\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -377,2 +377,2 @@\n-  bool is_declared_atomic() const { return _misc_flags.is_declared_atomic(); }\n-  void set_is_declared_atomic()   { _misc_flags.set_is_declared_atomic(true); }\n+  bool must_be_atomic() const { return _misc_flags.must_be_atomic(); }\n+  void set_must_be_atomic()   { _misc_flags.set_must_be_atomic(true); }\n@@ -386,0 +386,3 @@\n+  bool is_implicitly_constructible() const { return _misc_flags.is_implicitly_constructible(); }\n+  void set_is_implicitly_constructible()   { _misc_flags.set_is_implicitly_constructible(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    flag(is_declared_atomic                 , 1 << 18) \/* Listed -XX:ForceNonTearable=clist option *\/ \\\n+    flag(must_be_atomic                     , 1 << 18) \/* doesn't allow tearing *\/ \\\n@@ -63,1 +63,3 @@\n-    flag(carries_identity_modifier          , 1 << 20) \/* the class or one of its super types has the ACC_IDENTITY modifier *\/\n+    flag(carries_identity_modifier          , 1 << 20) \/* the class or one of its super types has the ACC_IDENTITY modifier *\/ \\\n+    flag(has_loosely_consistent_annotation  , 1 << 21) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n+    flag(is_implicitly_constructible        , 1 << 22) \/* the class has the ImplicitlyConstrutible annotation *\/\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -427,0 +427,18 @@\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedArray(JNIEnv *env, jclass elmClass, jint len))\n+  if (len < 0) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Array length is negative\");\n+  }\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  if (!klass->is_value_class()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not a value class\");\n+  }\n+  InstanceKlass* ik = InstanceKlass::cast(klass);\n+  if (!ik->is_implicitly_constructible()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not annotated with @ImplicitlyConstructible\");\n+  }\n+  oop array = oopFactory::new_valueArray(ik, len, CHECK_NULL);\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -498,0 +498,16 @@\n+\n+    \/**\n+     * Allocate an array of a value class type with components that behave in\n+     * the same way as a {@link jdk.internal.vm.annotation.NullRestricted}\n+     * field.\n+     * <p>\n+     * Because these behaviors are not specified by Java SE, arrays created with\n+     * this method should only be used by internal JDK code for experimental\n+     * purposes and should not affect user-observable outcomes.\n+     *\n+     * @throws IllegalArgumentException if {@code componentType} is not a\n+     *         value class type or is not annotated with\n+     *         {@link jdk.internal.vm.annotation.ImplicitlyConstructible}\n+     *\/\n+    public static native Object[] newNullRestrictedArray(Class<?> componentType,\n+                                                         int length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * An implicitly-constructible value class is a class that authorizes the JVM\n+ * to create its <em>zero instance<\/em>, where all instance fields are set to\n+ * their default values (0, {@code null}, etc.), without any code execution.\n+ * Any superclasses other than {@code Object} are also expected to be marked\n+ * {@code @ImplicitlyConstructible}.\n+ * <p>\n+ * The HotSpot VM depends on this annotation being present to properly\n+ * initialize {@link NullRestricted} fields and arrays of a value class type.\n+ * <p>\n+ * Because these behaviors are not specified by Java SE, this annotation should\n+ * only be used by internal JDK code for experimental purposes and should not\n+ * affect user-observable outcomes.\n+ *\/\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface ImplicitlyConstructible {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/ImplicitlyConstructible.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * A loosely-consistent value class is a class that is willing to tolerate\n+ * data corruption when fields or arrays storing instances of the class are\n+ * updated under race. Specifically, a value object read from such a field may\n+ * contain combinations of field values that were never set by a previous\n+ * constructor invocation.\n+ * <p>\n+ * Users of a class with this annotation take responsibility for ensuring the\n+ * integrity of their data by avoiding race conditions.\n+ * <p>\n+ * The HotSpot VM uses this annotation to enable non-atomic strategies for\n+ * reading and writing to flattened fields and arrays of the annotated class's\n+ * type.\n+ * <p>\n+ * Because these behaviors are not specified by Java SE, this annotation should\n+ * only be used by internal JDK code for experimental purposes and should not\n+ * affect user-observable outcomes.\n+ *\/\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface LooselyConsistentValue {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/LooselyConsistentValue.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * A null-restricted field is a field that does not store {@code null}.\n+ * The type of the field is expected to be a value class type with the\n+ * {@link ImplicitlyConstructible} annotation. The initial value of the field\n+ * is the zero instance of the given class, and attempts to write {@code null}\n+ * to the field will throw an exception.\n+ * <p>\n+ * The HotSpot VM uses this annotation to enable flattened encodings for the\n+ * field that would otherwise be impossible.\n+ * <p>\n+ * Because these behaviors are not specified by Java SE, this annotation should\n+ * only be used by internal JDK classes for experimental purposes and should not\n+ * affect user-observable outcomes.\n+ *\/\n+@Target(ElementType.FIELD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface NullRestricted {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/NullRestricted.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -58,0 +58,6 @@\n+\n+JNIEXPORT jarray JNICALL\n+Java_jdk_internal_misc_VM_newNullRestrictedArray(JNIEnv *env, jclass cls, jclass elmClass, jint len)\n+{\n+    return JVM_NewNullRestrictedArray(env, elmClass, len);\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/native\/libjava\/VM.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,363 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Field;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+\n+\n+\/*\n+ * @test\n+ * @summary Test of ImplicitlyConstructible, NullRestricted and LooselyConsistentValue annotations\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED AnnotationsTests.java\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XX:+EnableValhalla -XX:+EnablePrimitiveClasses AnnotationsTests\n+ *\/\n+\n+\n+ public class AnnotationsTests {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) {\n+        AnnotationsTests tests = new AnnotationsTests();\n+        Class c = tests.getClass();\n+        for (Method m : c.getDeclaredMethods()) {\n+          if (m.getName().startsWith(\"test_\")) {\n+            try {\n+              System.out.println(\"Running \" + m.getName());\n+              m.invoke(tests);\n+            } catch (Throwable t) {\n+              t.printStackTrace();\n+              throw new RuntimeException(t);\n+            }\n+          }\n+        }\n+    }\n+\n+    static class BadClass0 {\n+      @NullRestricted\n+      String s;\n+    }\n+\n+    \/\/ Test detection of illegal usage of NullRestricted on an identity field\n+    void test_0() {\n+      Throwable exception = null;\n+      try {\n+          BadClass0 bc = new BadClass0();\n+      } catch (IncompatibleClassChangeError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Failed to detect illegal use of @NullRestricted\");\n+    }\n+\n+    \/\/ Test detection of mismatch between a @NullRestricted field and its class that is not @ImplicitlyConstructible\n+    static value class ValueClass1 {\n+      int i = 0;\n+      int j = 0;\n+    }\n+\n+    static class BadClass1 {\n+      @NullRestricted\n+      ValueClass1 vc;\n+    }\n+\n+    void test_1() {\n+      Throwable exception = null;\n+      try {\n+          BadClass1 tc = new BadClass1();\n+      } catch (IncompatibleClassChangeError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Failed to detect illegal use of @NullRestricted\");\n+    }\n+\n+    \/\/ Test a valid @NullRestricted field with a class that is @ImplicitlyConstructible\n+    @ImplicitlyConstructible\n+    static value class ValueClass2 {\n+      int i = 0;\n+      int j = 0;\n+    }\n+\n+    static class GoodClass2 {\n+      @NullRestricted\n+      ValueClass2 vc;\n+    }\n+\n+    void test_2() {\n+      Throwable exception = null;\n+      try {\n+          GoodClass2 tc = new GoodClass2();\n+      } catch (IncompatibleClassChangeError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNull(exception, \"Unexpected exception: \" + exception);\n+    }\n+\n+    \/\/ Invalid usage of @ImplicitlyConstructible on an identity class\n+    @ImplicitlyConstructible\n+    static class BadClass3 {\n+\n+    }\n+\n+    void test_3() {\n+      Throwable exception = null;\n+      try {\n+          BadClass3 tc = new BadClass3();\n+      } catch (ClassFormatError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Failed to detect illegal use of @ImplicitlyConstructible\");\n+    }\n+\n+    \/\/ Test invalid usage of @LooselyConsistentValue on an identity class\n+    @LooselyConsistentValue\n+    static class BadClass4 {\n+\n+    }\n+\n+    void test_4() {\n+      Throwable exception = null;\n+      try {\n+          BadClass4 tc = new BadClass4();\n+      } catch (ClassFormatError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Failed to detect illegal use of @LooselyConsistentValue\");\n+    }\n+\n+    \/\/ Test field flattening of @NullRestricted annotated fields\n+\n+    @ImplicitlyConstructible\n+    static value class ValueClass5 {\n+      int i = 0;\n+    }\n+\n+    static class GoodClass5 {\n+      ValueClass5 f0 = new ValueClass5();\n+\n+      @NullRestricted\n+      ValueClass5 f1 = new ValueClass5();\n+    }\n+\n+    void test_5() {\n+      Throwable exception = null;\n+      try {\n+          GoodClass5 vc = new GoodClass5();\n+          Field f0 = vc.getClass().getDeclaredField(\"f0\");\n+          Asserts.assertFalse(UNSAFE.isFlattened(f0), \"Unexpected flat field\");\n+          Field f1 = vc.getClass().getDeclaredField(\"f1\");\n+          Asserts.assertTrue(UNSAFE.isFlattened(f1), \"Flat field expected, but field is not flat\");\n+      } catch (IncompatibleClassChangeError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      } catch(NoSuchFieldException e) {\n+        Asserts.fail(\"Test error\");\n+      }\n+      Asserts.assertNull(exception, \"Unexpected exception: \" + exception);\n+    }\n+\n+\n+    \/\/ Test detection\/handling of circularity\n+\n+    @ImplicitlyConstructible\n+    static value class ValueClass6a {\n+      @NullRestricted\n+      ValueClass6b val = new ValueClass6b();\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class ValueClass6b {\n+      @NullRestricted\n+      ValueClass6a val = new ValueClass6a();\n+    }\n+\n+    static class BadClass6 {\n+      @NullRestricted\n+      ValueClass6a val = new ValueClass6a();\n+    }\n+\n+    void test_6() {\n+      Throwable exception = null;\n+      try {\n+          BadClass6 bc = new BadClass6();\n+      } catch (ClassCircularityError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Failed to detect circularity\");\n+    }\n+\n+    \/\/ Test null restricted static field\n+    @ImplicitlyConstructible\n+    static value class ValueClass7 {\n+      int i = 0;\n+    }\n+\n+    static class GoodClass7 {\n+      @NullRestricted\n+      static ValueClass7 sval;\n+    }\n+\n+    void test_7() {\n+      Throwable exception = null;\n+      try {\n+          ValueClass7 val = GoodClass7.sval;\n+          Asserts.assertNotNull(val, \"Unexpected null value\");\n+      } catch (Throwable e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNull(exception, \"Unexpected exception: \" + exception);\n+    }\n+\n+    \/\/ Test circularity on static fields\n+    @ImplicitlyConstructible\n+    static value class ValueClass8 {\n+      @NullRestricted\n+      static ValueClass8 sval;\n+    }\n+\n+    void test_8() {\n+      Throwable exception = null;\n+      try {\n+          ValueClass8 val = ValueClass8.sval;\n+          Asserts.assertNotNull(val, \"Unexpected null value\");\n+      } catch (Throwable e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNull(exception, \"Unexpected exception: \" + exception);\n+    }\n+\n+    \/\/ Test that writing null to a @NullRestricted non-static field throws an exception\n+    @ImplicitlyConstructible\n+    static value class ValueClass9 {\n+      int i = 0;\n+    }\n+\n+    static class GoodClass9 {\n+      @NullRestricted\n+      ValueClass9 val = new ValueClass9();\n+    }\n+\n+    void test_9() {\n+      Throwable exception = null;\n+      try {\n+        GoodClass9 gc = new GoodClass9();\n+        gc.val = null;\n+      } catch(NullPointerException e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Expected NullPointerException not received\");\n+    }\n+\n+    \/\/ Test that writing null to a @NullRestricted static field throws an exception\n+    @ImplicitlyConstructible\n+    static value class ValueClass10 {\n+      @NullRestricted\n+      static ValueClass10 sval;\n+    }\n+\n+    void test_10() {\n+      Throwable exception = null;\n+      try {\n+        ValueClass10.sval = null;\n+      } catch(NullPointerException e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Expected NullPointerException not received\");\n+    }\n+\n+    \/\/ Test uninitialized static null restricted field with a class not implicitly constructible\n+    static value class ValueClass11 {\n+      int i = 0;\n+      int j = 0;\n+    }\n+\n+    static class BadClass11 {\n+      @NullRestricted\n+      static ValueClass11 val;\n+    }\n+\n+    void test_11() {\n+      Throwable exception = null;\n+      try {\n+        ValueClass11 val = BadClass11.val;\n+        System.out.println(val);\n+      } catch(IncompatibleClassChangeError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Expected IncompatibleClassChangerError not received\");\n+    }\n+\n+    \/\/ Test illegal use of @NullRestricted on a primitive field\n+    static class BadClass12 {\n+      @NullRestricted\n+      int i;\n+    }\n+    void test_12() {\n+      Throwable exception = null;\n+      try {\n+        BadClass12 val = new BadClass12();\n+        System.out.println(val);\n+      } catch(ClassFormatError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Expected ClassFormatError not received\");\n+    }\n+\n+    \/\/ Test illegal use of @NullRestricted on an array field\n+    static class BadClass13 {\n+      @NullRestricted\n+      int Integer[];\n+    }\n+    void test_13() {\n+      Throwable exception = null;\n+      try {\n+        BadClass13 val = new BadClass13();\n+        System.out.println(val);\n+      } catch(ClassFormatError e) {\n+        exception = e;\n+        System.out.println(\"Received \" + e);\n+      }\n+      Asserts.assertNotNull(exception, \"Expected ClassFormatError not received\");\n+    }\n+\n+ }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/AnnotationsTests.java","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"},{"patch":"@@ -26,0 +26,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -31,2 +34,2 @@\n- * @compile -XDenablePrimitiveClasses CircularityTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.CircularityTest\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED CircularityTest.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.CircularityTest\n@@ -39,2 +42,4 @@\n-\n-    static primitive class A {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class A {\n+        @NullRestricted\n@@ -42,0 +47,1 @@\n+        @NullRestricted\n@@ -46,1 +52,3 @@\n-    static primitive class B {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class B {\n@@ -53,1 +61,3 @@\n-    static primitive class C {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class C {\n@@ -60,1 +70,4 @@\n-    static primitive class D {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class D {\n+        @NullRestricted\n@@ -71,1 +84,4 @@\n-    static primitive class E {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class E {\n+        @NullRestricted\n@@ -73,0 +89,1 @@\n+        @NullRestricted\n@@ -77,1 +94,3 @@\n-    static primitive class F {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class F {\n@@ -84,1 +103,4 @@\n-    static primitive class G {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class G {\n+        @NullRestricted\n@@ -89,1 +111,3 @@\n-    static primitive class H {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class H {\n@@ -99,1 +123,4 @@\n-    static primitive class I {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class I {\n+        @NullRestricted\n@@ -101,0 +128,1 @@\n+        @NullRestricted\n@@ -105,1 +133,3 @@\n-    static primitive class J {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class J {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CircularityTest.java","additions":43,"deletions":13,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -31,2 +35,2 @@\n-* @compile -XDenablePrimitiveClasses ClassInitializationFailuresTest.java\n-* @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.ClassInitializationFailuresTest\n+* @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED ClassInitializationFailuresTest.java\n+* @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED runtime.valhalla.inlinetypes.ClassInitializationFailuresTest\n@@ -38,1 +42,3 @@\n-    static primitive class BadOne {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class BadOne {\n@@ -47,1 +53,4 @@\n-    static primitive class TestClass1 {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TestClass1 {\n+        @NullRestricted\n@@ -83,1 +92,3 @@\n-    static primitive class BadTwo {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class BadTwo {\n@@ -92,1 +103,3 @@\n-    static primitive class BadThree {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class BadThree {\n@@ -106,1 +119,1 @@\n-            BadTwo[] array = new BadTwo[10];\n+            BadTwo[] array = (BadTwo[])VM.newNullRestrictedArray(BadTwo.class, 10);\n@@ -114,1 +127,1 @@\n-            BadTwo[] array = new BadTwo[10];\n+            BadTwo[] array = (BadTwo[])VM.newNullRestrictedArray(BadTwo.class, 10);\n@@ -121,0 +134,2 @@\n+        \/\/ Transition model (annotations and array factory) doesn't permit multi-dimentional arrays tests\n+        \/\/ Disabling those tests for now\n@@ -122,16 +137,16 @@\n-        try {\n-            BadThree[][] array = new BadThree[10][20];\n-        } catch(Throwable t) {\n-            e = t;\n-        }\n-        Asserts.assertNotNull(e, \"Error should have been thrown\");\n-        Asserts.assertTrue(e.getClass() == ExceptionInInitializerError.class, \" Must be an ExceptionInInitializerError\");\n-        \/\/ Second attempt because it doesn't fail the same way\n-        try {\n-            BadThree[][][] array = new BadThree[10][30][10];\n-        } catch(Throwable t) {\n-            e = t;\n-        }\n-        Asserts.assertNotNull(e, \"Error should have been thrown\");\n-        Asserts.assertTrue(e.getClass() == NoClassDefFoundError.class, \"Must be a NoClassDefFoundError\");\n-        Asserts.assertTrue(e.getCause().getClass() == ExceptionInInitializerError.class, \"Must be an ExceptionInInitializerError\");\n+        \/\/ try {\n+        \/\/     BadThree[][] array = new BadThree[10][20];\n+        \/\/ } catch(Throwable t) {\n+        \/\/     e = t;\n+        \/\/ }\n+        \/\/ Asserts.assertNotNull(e, \"Error should have been thrown\");\n+        \/\/ Asserts.assertTrue(e.getClass() == ExceptionInInitializerError.class, \" Must be an ExceptionInInitializerError\");\n+        \/\/ \/\/ Second attempt because it doesn't fail the same way\n+        \/\/ try {\n+        \/\/     BadThree[][][] array = new BadThree[10][30][10];\n+        \/\/ } catch(Throwable t) {\n+        \/\/     e = t;\n+        \/\/ }\n+        \/\/ Asserts.assertNotNull(e, \"Error should have been thrown\");\n+        \/\/ Asserts.assertTrue(e.getClass() == NoClassDefFoundError.class, \"Must be a NoClassDefFoundError\");\n+        \/\/ Asserts.assertTrue(e.getCause().getClass() == ExceptionInInitializerError.class, \"Must be an ExceptionInInitializerError\");\n@@ -140,1 +155,3 @@\n-    static primitive class BadFour {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class BadFour {\n@@ -144,1 +161,1 @@\n-            array = new BadFour[10];\n+            array = (BadFour[])VM.newNullRestrictedArray(BadFour.class, 10);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ClassInitializationFailuresTest.java","additions":43,"deletions":26,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -34,2 +37,2 @@\n- * @compile -XDenablePrimitiveClasses ClassPrintLayoutDcmd.java Point.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.ClassPrintLayoutDcmd\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED ClassPrintLayoutDcmd.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.ClassPrintLayoutDcmd\n@@ -38,3 +41,16 @@\n-public primitive class ClassPrintLayoutDcmd {\n-    static primitive class Line {\n-        Point p1, p2;\n+public value class ClassPrintLayoutDcmd {\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Point {\n+        int i = 0;\n+        int j = 0;\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Line {\n+        @NullRestricted\n+        Point p1;\n+        @NullRestricted\n+        Point p2;\n@@ -42,1 +58,1 @@\n-            this.p1 = this.p2 = new Point(0, 1);\n+            this.p1 = this.p2 = new Point();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ClassPrintLayoutDcmd.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -32,4 +35,3 @@\n- * @compile -XDenablePrimitiveClasses Point.java JumboInline.java FlattenableSemanticTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=64 runtime.valhalla.inlinetypes.FlattenableSemanticTest\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.FlattenableSemanticTest\n- * \/\/ debug: -XX:+PrintInlineLayout -XX:-ShowMessageBoxOnError\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED FlattenableSemanticTest.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=64 --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.FlattenableSemanticTest\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.FlattenableSemanticTest\n@@ -39,1 +41,34 @@\n-    static Point.ref nfsp;\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class Point {\n+        final int x = 0;\n+        final int y = 0;\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    public value class JumboInline {\n+        final long l0 = 0;\n+        final long l1 = 1;\n+        final long l2 = 2;\n+        final long l3 = 3;\n+        final long l4 = 4;\n+        final long l5 = 5;\n+        final long l6 = 6;\n+        final long l7 = 7;\n+        final long l8 = 8;\n+        final long l9 = 9;\n+        final long l10 = 10;\n+        final long l11 = 11;\n+        final long l12 = 12;\n+        final long l13 = 13;\n+        final long l14 = 14;\n+        final long l15 = 15;\n+        final long l16 = 16;\n+        final long l17 = 17;\n+        final long l18 = 18;\n+        final long l19 = 19;\n+    }\n+\n+    static Point nfsp;\n+    @NullRestricted\n@@ -42,1 +77,2 @@\n-    Point.ref nfip;\n+    Point nfip;\n+    @NullRestricted\n@@ -45,1 +81,2 @@\n-    static JumboInline.ref nfsj;\n+    static JumboInline nfsj;\n+    @NullRestricted\n@@ -48,1 +85,2 @@\n-    JumboInline.ref nfij;\n+    JumboInline nfij;\n+    @NullRestricted\n@@ -77,1 +115,1 @@\n-            nfsp = (Point.ref)getNull();\n+            nfsp = (Point)getNull();\n@@ -86,1 +124,1 @@\n-            nfsj = (JumboInline.ref)getNull();\n+            nfsj = (JumboInline)getNull();\n@@ -95,1 +133,1 @@\n-            test.nfip = (Point.ref)getNull();\n+            test.nfip = (Point)getNull();\n@@ -104,1 +142,1 @@\n-            test.nfij = (JumboInline.ref)getNull();\n+            test.nfij = (JumboInline)getNull();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlattenableSemanticTest.java","additions":50,"deletions":12,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\n+import jdk.test.lib.Asserts;\n+import java.lang.reflect.Method;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test of VM.newNullRestrictedArray API\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED NullRestrictedArrayTest.java\n+ * @run main\/othervm --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED -XX:+EnableValhalla -XX:+EnablePrimitiveClasses NullRestrictedArrayTest\n+ *\/\n+\n+\n+public class NullRestrictedArrayTest {\n+\n+  private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+\n+  public static void main(String[] args) {\n+      NullRestrictedArrayTest tests = new NullRestrictedArrayTest();\n+      Class c = tests.getClass();\n+      for (Method m : c.getDeclaredMethods()) {\n+        if (m.getName().startsWith(\"test_\")) {\n+          try {\n+            System.out.println(\"Running \" + m.getName());\n+            m.invoke(tests);\n+          } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw new RuntimeException(t);\n+          }\n+        }\n+      }\n+  }\n+\n+  \/\/ Test illegal attempt to create a null restricted array with an identity class\n+  public void test_0() {\n+      Throwable exception = null;\n+      try {\n+        VM.newNullRestrictedArray(String.class, 4);\n+      } catch (IllegalArgumentException e) {\n+        System.out.println(\"Received: \" + e);\n+        exception = e;\n+      }\n+      Asserts.assertNotNull(exception, \"Expected IllegalArgumentException not received\");\n+  }\n+\n+  \/\/ Test illegal array length\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class ValueClass1 {\n+    int i = 0;\n+    int j = 0;\n+  }\n+\n+  public void test_1() {\n+      Throwable exception = null;\n+      try {\n+        VM.newNullRestrictedArray(ValueClass1.class, -1);\n+      } catch (IllegalArgumentException e) {\n+        System.out.println(\"Received: \" + e);\n+        exception = e;\n+      }\n+      Asserts.assertNotNull(exception, \"Expected IllegalArgumentException not received\");\n+  }\n+\n+  \/\/ Test illegal attempt to create a null restricted array with a value class not annotated with @ImplicitlyConstructible\n+  static value class ValueClass2 {\n+    int i = 0;\n+    int j = 0;\n+  }\n+\n+  public void test_2() {\n+      Throwable exception = null;\n+      try {\n+        VM.newNullRestrictedArray(ValueClass2.class, 8);\n+      } catch (IllegalArgumentException e) {\n+        System.out.println(\"Received: \" + e);\n+        exception = e;\n+      }\n+      Asserts.assertNotNull(exception, \"Expected IllegalArgumentException not received\");\n+  }\n+\n+  \/\/ Test valid creation of a flat array\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class ValueClass3 {\n+    int i = 0;\n+    int j = 0;\n+  }\n+\n+  public void test_3() {\n+      Throwable exception = null;\n+      try {\n+        Object array = VM.newNullRestrictedArray(ValueClass3.class, 8);\n+        Asserts.assertTrue(UNSAFE.isFlattenedArray(array.getClass()), \"Expecting flat array but array is not flat\");\n+      } catch (Throwable e) {\n+        System.out.println(\"Received: \" + e);\n+        exception = e;\n+      }\n+      Asserts.assertNull(exception, \"Unexpected exception: \" + exception);\n+  }\n+\n+  \/\/ Test that elements are not null\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+\n+  static value class ValueClass4 {\n+    int i = 0;\n+    int j = 0;\n+  }\n+\n+  public void test_4() {\n+      Throwable exception = null;\n+      try {\n+        Object[] array = VM.newNullRestrictedArray(ValueClass4.class, 8);\n+        Asserts.assertNotNull(array[1], \"Expecting non null element but null found instead\");\n+      } catch (Throwable e) {\n+        System.out.println(\"Received: \" + e);\n+        exception = e;\n+      }\n+      Asserts.assertNull(exception, \"Unexpected exception: \" + exception);\n+  }\n+\n+  \/\/ Test that writing null to a null restricted array throws an exception\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class ValueClass5 {\n+    int i = 0;\n+    int j = 0;\n+  }\n+\n+  public void test_5() {\n+      Throwable exception = null;\n+      try {\n+        Object[] array = VM.newNullRestrictedArray(ValueClass4.class, 8);\n+        array[1] = null;\n+      } catch (NullPointerException e) {\n+        System.out.println(\"Received: \" + e);\n+        exception = e;\n+      }\n+      Asserts.assertNotNull(exception, \"Expected NullPointerException not received\");\n+  }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullRestrictedArrayTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -26,0 +26,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -31,2 +34,2 @@\n- * @compile -XDenablePrimitiveClasses StaticFieldsTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses runtime.valhalla.inlinetypes.StaticFieldsTest\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED StaticFieldsTest.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.StaticFieldsTest\n@@ -41,1 +44,4 @@\n-    static primitive class ClassA {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ClassA {\n+        @NullRestricted\n@@ -50,1 +56,4 @@\n-    static primitive class ClassB {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ClassB {\n+        @NullRestricted\n@@ -62,1 +71,4 @@\n-    static primitive class ClassC {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ClassC {\n+        @NullRestricted\n@@ -76,1 +88,4 @@\n-    static primitive class ClassD {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ClassD {\n+        @NullRestricted\n@@ -89,1 +104,4 @@\n-    static primitive class ClassE {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ClassE {\n+        @NullRestricted\n@@ -105,1 +123,4 @@\n-    static primitive class ClassF {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ClassF {\n+        @NullRestricted\n@@ -119,0 +140,2 @@\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n@@ -120,0 +143,1 @@\n+        @NullRestricted\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/StaticFieldsTest.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * @compile -XDenablePrimitiveClasses VolatileTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=128 runtime.valhalla.inlinetypes.VolatileTest\n+ * @compile -XDenablePrimitiveClasses --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED VolatileTest.java\n+ * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=128 --add-exports java.base\/jdk.internal.vm.annotation=ALL-UNNAMED runtime.valhalla.inlinetypes.VolatileTest\n@@ -36,0 +36,3 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -43,1 +46,3 @@\n-    static primitive class MyValue {\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class MyValue {\n@@ -49,0 +54,1 @@\n+        @NullRestricted\n@@ -50,0 +56,1 @@\n+        @NullRestricted\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/VolatileTest.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"}]}