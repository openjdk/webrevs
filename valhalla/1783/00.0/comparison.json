{"files":[{"patch":"@@ -1384,1 +1384,0 @@\n-    __ ldr(rscratch2, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1149,3 +1149,1 @@\n-    __ la(t, unsatisfied);\n-    __ load_long_misaligned(t1, Address(t, 0), t0, 2); \/\/ 2 bytes aligned, but not 4 or 8\n-\n+    __ la(t1, unsatisfied);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-\/\/ The following are offsets from buffer_bottom()\n+bool AOTMappedHeapWriter::_is_writing_deterministic_heap = false;\n@@ -77,1 +77,1 @@\n-      size_t,    \/\/ offset of a filler from ArchiveHeapWriter::buffer_bottom()\n+      size_t,    \/\/ offset of a filler from AOTMappedHeapWriter::buffer_bottom()\n@@ -99,0 +99,39 @@\n+\n+    if (CDSConfig::old_cds_flags_used()) {\n+      \/\/ With the old CDS workflow, we can guatantee determninistic output: given\n+      \/\/ the same classlist file, we can generate the same static CDS archive.\n+      \/\/ To ensure determinism, we always use the same compressed oop encoding\n+      \/\/ (zero-based, no shift). See set_requested_address_range().\n+      _is_writing_deterministic_heap = true;\n+    } else {\n+      \/\/ Determninistic output is not supported by the new AOT workflow, so\n+      \/\/ we don't force the (zero-based, no shift) encoding. This way, it is more\n+      \/\/ likely that we can avoid oop relocation in the production run.\n+      _is_writing_deterministic_heap = false;\n+    }\n+  }\n+}\n+\n+\/\/ For AOTMappedHeapWriter::narrow_oop_{mode, base, shift}(), see comments\n+\/\/ in AOTMappedHeapWriter::set_requested_address_range(),\n+CompressedOops::Mode AOTMappedHeapWriter::narrow_oop_mode() {\n+  if (is_writing_deterministic_heap()) {\n+    return CompressedOops::UnscaledNarrowOop;\n+  } else {\n+    return CompressedOops::mode();\n+  }\n+}\n+\n+address AOTMappedHeapWriter::narrow_oop_base() {\n+  if (is_writing_deterministic_heap()) {\n+    return (address)0;\n+  } else {\n+    return CompressedOops::base();\n+  }\n+}\n+\n+int AOTMappedHeapWriter::narrow_oop_shift() {\n+  if (is_writing_deterministic_heap()) {\n+    return 0;\n+  } else {\n+    return CompressedOops::shift();\n@@ -119,1 +158,1 @@\n-  set_requested_address(heap_info);\n+  set_requested_address_range(heap_info);\n@@ -540,1 +579,24 @@\n-void AOTMappedHeapWriter::set_requested_address(ArchiveMappedHeapInfo* info) {\n+\/\/ Set the range [_requested_bottom, _requested_top), the requested address range of all\n+\/\/ the archived heap objects in the production run.\n+\/\/\n+\/\/ (1) UseCompressedOops == true && !is_writing_deterministic_heap()\n+\/\/\n+\/\/     The archived objects are stored using the COOPS encoding of the assembly phase.\n+\/\/     We pick a range within the heap used by the assembly phase.\n+\/\/\n+\/\/     In the production run, if different COOPS encodings are used:\n+\/\/         - The heap contents needs to be relocated.\n+\/\/\n+\/\/ (2) UseCompressedOops == true && is_writing_deterministic_heap()\n+\/\/\n+\/\/     We always use zero-based, zero-shift encoding. _requested_top is aligned to 0x10000000.\n+\/\/\n+\/\/ (3) UseCompressedOops == false:\n+\/\/\n+\/\/     In the production run, the heap range is usually picked (randomly) by the OS, so we\n+\/\/     will almost always need to perform relocation, regardless of how we pick the requested\n+\/\/     address range.\n+\/\/\n+\/\/     So we just hard code it to NOCOOPS_REQUESTED_BASE.\n+\/\/\n+void AOTMappedHeapWriter::set_requested_address_range(ArchiveMappedHeapInfo* info) {\n@@ -547,1 +609,19 @@\n-    if (UseG1GC) {\n+    if (is_writing_deterministic_heap()) {\n+      \/\/ Pick a heap range so that requested addresses can be encoded with zero-base\/no shift.\n+      \/\/ We align the requested bottom to at least 1 MB: if the production run uses G1 with a small\n+      \/\/ heap (e.g., -Xmx256m), it's likely that we can map the archived objects at the\n+      \/\/ requested location to avoid relocation.\n+      \/\/\n+      \/\/ For other collectors or larger heaps, relocation is unavoidable, but is usually\n+      \/\/ quite cheap. If you really want to avoid relocation, use the AOT workflow instead.\n+      address heap_end = (address)0x100000000;\n+      size_t alignment = MAX2(MIN_GC_REGION_ALIGNMENT, 1024 * 1024);\n+      if (align_up(heap_region_byte_size, alignment) >= (size_t)heap_end) {\n+        log_error(aot, heap)(\"cached heap space is too large: %zu bytes\", heap_region_byte_size);\n+        AOTMetaspace::unrecoverable_writing_error();\n+      }\n+      _requested_bottom = align_down(heap_end - heap_region_byte_size, alignment);\n+    } else if (UseG1GC) {\n+      \/\/ For G1, pick the range at the top of the current heap. If the exact same heap sizes\n+      \/\/ are used in the production run, it's likely that we can map the archived objects\n+      \/\/ at the requested location to avoid relocation.\n@@ -616,1 +696,8 @@\n-  store_requested_oop_in_buffer<T>(field_addr_in_buffer, request_referent);\n+  if (UseCompressedOops && is_writing_deterministic_heap()) {\n+    \/\/ We use zero-based, 0-shift encoding, so the narrowOop is just the lower\n+    \/\/ 32 bits of request_referent\n+    intptr_t addr = cast_from_oop<intptr_t>(request_referent);\n+    *((narrowOop*)field_addr_in_buffer) = checked_cast<narrowOop>(addr);\n+  } else {\n+    store_requested_oop_in_buffer<T>(field_addr_in_buffer, request_referent);\n+  }\n@@ -924,3 +1011,3 @@\n-  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)AOTMappedHeapWriter::NOCOOPS_REQUESTED_BASE;\n-  address requested_start = UseCompressedOops ? buffered_addr_to_requested_addr(buffer_start) : requested_base;\n-  int requested_shift =  CompressedOops::shift();\n+  address requested_base = UseCompressedOops ? AOTMappedHeapWriter::narrow_oop_base() : (address)AOTMappedHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_start = UseCompressedOops ? AOTMappedHeapWriter::buffered_addr_to_requested_addr(buffer_start) : requested_base;\n+  int requested_shift = AOTMappedHeapWriter::narrow_oop_shift();\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapWriter.cpp","additions":96,"deletions":9,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+FileMapInfo* AOTMetaspace::_output_mapinfo = nullptr;\n@@ -327,0 +328,18 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    \/\/ We are in the AOT training run. User code is executed.\n+    \/\/\n+    \/\/ On Windows, if the user code closes System.out and we open the AOT config file for output\n+    \/\/ only at VM exit, we might get back the same file HANDLE as stdout, and the AOT config\n+    \/\/ file may get corrupted by UL logs. By opening early, we ensure that the output\n+    \/\/ HANDLE is different than stdout so we can avoid such corruption.\n+    open_output_mapinfo();\n+  } else {\n+    \/\/ No need for the above as we won't execute any user code.\n+  }\n+}\n+\n+void AOTMetaspace::open_output_mapinfo() {\n+  const char* static_archive = CDSConfig::output_archive_path();\n+  assert(static_archive != nullptr, \"sanity\");\n+  _output_mapinfo = new FileMapInfo(static_archive, true);\n+  _output_mapinfo->open_as_output();\n@@ -660,2 +679,2 @@\n-  VM_PopulateDumpSharedSpace(StaticArchiveBuilder& b) :\n-    VM_Operation(), _mapped_heap_info(), _streamed_heap_info(), _map_info(nullptr), _builder(b) {}\n+  VM_PopulateDumpSharedSpace(StaticArchiveBuilder& b, FileMapInfo* map_info) :\n+    VM_Operation(), _mapped_heap_info(), _streamed_heap_info(), _map_info(map_info), _builder(b) {}\n@@ -668,1 +687,0 @@\n-  FileMapInfo* map_info() const { return _map_info; }\n@@ -800,6 +818,0 @@\n-  if (CDSConfig::is_dumping_final_static_archive()) {\n-    FileMapInfo::free_current_info(); \/\/ FIXME: should not free current info\n-  }\n-  const char* static_archive = CDSConfig::output_archive_path();\n-  assert(static_archive != nullptr, \"sanity\");\n-  _map_info = new FileMapInfo(static_archive, true);\n@@ -1143,1 +1155,8 @@\n-  VM_PopulateDumpSharedSpace op(builder);\n+  if (!CDSConfig::is_dumping_preimage_static_archive()) {\n+    if (CDSConfig::is_dumping_final_static_archive()) {\n+      FileMapInfo::free_current_info(); \/\/ FIXME: should not free current info\n+    }\n+    open_output_mapinfo();\n+  }\n+\n+  VM_PopulateDumpSharedSpace op(builder, _output_mapinfo);\n@@ -1157,1 +1176,3 @@\n-  bool status = write_static_archive(&builder, op.map_info(), op.mapped_heap_info(), op.streamed_heap_info());\n+  bool status = write_static_archive(&builder, _output_mapinfo, op.mapped_heap_info(), op.streamed_heap_info());\n+  assert(!_output_mapinfo->is_open(), \"Must be closed already\");\n+  _output_mapinfo = nullptr;\n@@ -1178,2 +1199,0 @@\n-\n-  map_info->open_as_output();\n@@ -1183,0 +1202,1 @@\n+  map_info->prepare_for_writing();\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -550,1 +550,1 @@\n-      vm_exit_during_initialization(\"At least one of AOTCacheOutput and AOTConfiguration must be specified when using -XX:AOTMode=record\");\n+    vm_exit_during_initialization(\"At least one of AOTCacheOutput and AOTConfiguration must be specified when using -XX:AOTMode=record\");\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,0 +356,1 @@\n+  dynamic_info->prepare_for_writing();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -286,3 +287,3 @@\n-    _narrow_oop_mode = CompressedOops::mode();\n-    _narrow_oop_base = CompressedOops::base();\n-    _narrow_oop_shift = CompressedOops::shift();\n+    _narrow_oop_mode = AOTMappedHeapWriter::narrow_oop_mode();\n+    _narrow_oop_base = AOTMappedHeapWriter::narrow_oop_base();\n+    _narrow_oop_shift = AOTMappedHeapWriter::narrow_oop_shift();\n@@ -290,0 +291,1 @@\n+#endif\n@@ -853,0 +855,1 @@\n+}\n@@ -854,0 +857,1 @@\n+void FileMapInfo::prepare_for_writing() {\n@@ -987,1 +991,1 @@\n-        mapping_offset = (size_t)((address)requested_base - CompressedOops::base());\n+        mapping_offset = (size_t)((address)requested_base - AOTMappedHeapWriter::narrow_oop_base());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  FileMapInfo(const char* full_apth, bool is_static);\n+  FileMapInfo(const char* full_path, bool is_static);\n@@ -406,0 +406,1 @@\n+  void  prepare_for_writing();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -634,3 +634,2 @@\n-\/\/ return the \"scratch\" version that represents the same type T.\n-\/\/ Note that if java_mirror will be returned if it's already a\n-\/\/ scratch mirror.\n+\/\/ return the \"scratch\" version that represents the same type T. Note\n+\/\/ that java_mirror will be returned if the mirror is already a scratch mirror.\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -282,3 +282,0 @@\n-  if (holder->name() == ciSymbols::java_lang_System())\n-    \/\/ Never trust strangely unstable finals:  System.out, etc.\n-    return false;\n@@ -299,3 +296,0 @@\n-  \/\/ Trust final fields in all boxed classes\n-  if (holder->is_box_klass())\n-    return true;\n@@ -305,3 +299,0 @@\n-  \/\/ Trust final fields in String\n-  if (holder->name() == ciSymbols::java_lang_String())\n-    return true;\n@@ -345,11 +336,1 @@\n-      assert(vmClasses::System_klass() != nullptr, \"Check once per vm\");\n-      if (k == vmClasses::System_klass()) {\n-        \/\/ Check offsets for case 2: System.in, System.out, or System.err\n-        if (_offset == java_lang_System::in_offset()  ||\n-            _offset == java_lang_System::out_offset() ||\n-            _offset == java_lang_System::err_offset()) {\n-          _is_constant = false;\n-          return;\n-        }\n-      }\n-      _is_constant = true;\n+      _is_constant = !fd->is_mutable_static_final();\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -689,1 +689,1 @@\n-    return !has_subklass() && (nof_implementors() == 0);\n+    return !has_subklass() && (!is_interface() || nof_implementors() == 0);\n@@ -703,0 +703,1 @@\n+  assert(is_interface(), \"required\");\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -290,0 +290,1 @@\n+    assert(is_interface(), \"must be\");\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1267,4 +1267,1 @@\n-\n-    \/\/ create the init_lock\n-    typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));\n-    set_init_lock(mirror(), r);\n+    assert(init_lock(mirror()) != nullptr, \"allocated during AOT assembly\");\n@@ -1366,5 +1363,0 @@\n-void java_lang_Class::set_reflection_data(oop java_class, oop reflection_data) {\n-  assert(_reflectionData_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_reflectionData_offset, reflection_data);\n-}\n-\n@@ -1519,1 +1511,0 @@\n-\n@@ -1627,5 +1618,0 @@\n-int java_lang_Class::raw_access_flags(oop the_class_mirror) {\n-  assert(_raw_access_flags_offset != 0, \"offsets should have been initialized\");\n-  return the_class_mirror->char_field(_raw_access_flags_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -280,0 +280,6 @@\n+\n+  static void set_modifiers(oop java_class, u2 value);\n+  static void set_raw_access_flags(oop java_class, u2 value);\n+  static void set_is_primitive(oop java_class);\n+  static void release_set_array_klass(oop java_class, Klass* klass);\n+\n@@ -314,1 +320,0 @@\n-  static void set_is_primitive(oop java_class);\n@@ -317,2 +322,1 @@\n-  \/\/ JVM_NewArray support\n-  static void release_set_array_klass(oop java_class, Klass* klass);\n+\n@@ -339,1 +343,0 @@\n-  static void set_reflection_data(oop java_class, oop reflection_data);\n@@ -352,4 +355,0 @@\n-  static void set_modifiers(oop java_class, u2 value);\n-\n-  static int raw_access_flags(oop java_class);\n-  static void set_raw_access_flags(oop java_class, u2 value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -357,3 +357,1 @@\n-  \/\/ Perform a collection of the heap; intended for use in implementing\n-  \/\/ \"System.gc\".  This probably implies as full a collection as the\n-  \/\/ \"CollectedHeap\" supports.\n+  \/\/ Perform a collection of the heap of a type depending on the given cause.\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/new.hpp\"\n@@ -33,2 +34,0 @@\n-\n-#include <new>\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -562,9 +562,8 @@\n-    if (CDSConfig::is_using_archive() &&\n-        HeapShared::is_archived_heap_in_use() &&\n-        _basic_type_mirrors[T_INT].resolve() != nullptr) {\n-      \/\/ check that all basic type mirrors are mapped also\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        if (!is_reference_type((BasicType)i)) {\n-          oop m = _basic_type_mirrors[i].resolve();\n-          assert(m != nullptr, \"archived mirrors should not be null\");\n-        }\n+  if (CDSConfig::is_using_archive() &&\n+      HeapShared::is_archived_heap_in_use() &&\n+      _basic_type_mirrors[T_INT].resolve() != nullptr) {\n+    \/\/ check that all basic type mirrors are mapped also\n+    for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+      if (!is_reference_type((BasicType)i)) {\n+        oop m = _basic_type_mirrors[i].resolve();\n+        assert(m != nullptr, \"archived mirrors should not be null\");\n@@ -572,2 +571,3 @@\n-    } else\n-      \/\/ _basic_type_mirrors[T_INT], etc, are null if not using an archived heap\n+    }\n+  } else\n+    \/\/ _basic_type_mirrors[T_INT], etc, are null if not using an archived heap\n@@ -575,8 +575,6 @@\n-    {\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        BasicType bt = (BasicType)i;\n-        if (!is_reference_type(bt)) {\n-          oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n-          _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n-        }\n-        CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n+  {\n+    for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+      BasicType bt = (BasicType)i;\n+      if (!is_reference_type(bt)) {\n+        oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+        _basic_type_mirrors[i] = OopHandle(vm_global(), m);\n@@ -584,0 +582,1 @@\n+      CDS_JAVA_HEAP_ONLY(_archived_basic_type_mirror_indices[i] = -1);\n@@ -585,3 +584,4 @@\n-    if (CDSConfig::is_dumping_heap()) {\n-      HeapShared::init_scratch_objects_for_basic_type_mirrors(CHECK);\n-    }\n+  }\n+  if (CDSConfig::is_dumping_heap()) {\n+    HeapShared::init_scratch_objects_for_basic_type_mirrors(CHECK);\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3129,1 +3129,1 @@\n-  if (AOTMetaspace::in_aot_cache(this)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache(this)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -31,0 +32,8 @@\n+static_assert(std::is_trivially_copyable_v<ResolvedFieldEntry>);\n+\n+\/\/ Detect inadvertently introduced trailing padding.\n+class ResolvedFieldEntryWithExtra : public ResolvedFieldEntry {\n+  u1 _extra_field;\n+};\n+static_assert(sizeof(ResolvedFieldEntryWithExtra) > sizeof(ResolvedFieldEntry));\n+\n@@ -63,3 +72,1 @@\n-  u2 saved_cpool_index = _cpool_index;\n-  memset(this, 0, sizeof(*this));\n-  _cpool_index = saved_cpool_index;\n+  *this = ResolvedFieldEntry(_cpool_index);\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+\/\/ The explicit paddings are necessary for generating deterministic CDS archives. They prevent\n+\/\/ the C++ compiler from potentially inserting random values in unused gaps.\n+\n@@ -57,11 +60,3 @@\n-\n-  void copy_from(const ResolvedFieldEntry& other) {\n-    _field_holder = other._field_holder;\n-    _field_offset = other._field_offset;\n-    _field_index = other._field_index;\n-    _cpool_index = other._cpool_index;\n-    _tos_state = other._tos_state;\n-    _flags = other._flags;\n-    _get_code = other._get_code;\n-    _put_code = other._put_code;\n-  }\n+#ifdef _LP64\n+  u4 _padding;\n+#endif\n@@ -78,1 +73,5 @@\n-    _put_code(0) {}\n+    _put_code(0)\n+#ifdef _LP64\n+    , _padding(0)\n+#endif\n+    {}\n@@ -83,37 +82,0 @@\n-  \/\/ Notes on copy constructor, copy assignment operator, and copy_from().\n-  \/\/ These are necessary for generating deterministic CDS archives.\n-  \/\/\n-  \/\/ We have some unused padding on 64-bit platforms (4 bytes at the tail end).\n-  \/\/\n-  \/\/ When ResolvedFieldEntries in a ConstantPoolCache are allocated from the metaspace,\n-  \/\/ their entire content (including the padding) is filled with zeros. They are\n-  \/\/ then initialized with initialize_resolved_entries_array() in cpCache.cpp from a\n-  \/\/ GrowableArray.\n-  \/\/\n-  \/\/ The GrowableArray is initialized in rewriter.cpp, using ResolvedFieldEntries that\n-  \/\/ are originally allocated from the C++ stack. Functions like GrowableArray::expand_to()\n-  \/\/ will also allocate ResolvedFieldEntries from the stack. These may have random bits\n-  \/\/ in the padding as the C++ compiler is allowed to leave the padding in uninitialized\n-  \/\/ states.\n-  \/\/\n-  \/\/ If we use the default copy constructor and\/or default copy assignment operator,\n-  \/\/ the random padding will be copied into the GrowableArray, from there\n-  \/\/ to the ConstantPoolCache, and eventually to the CDS archive. As a result, the\n-  \/\/ CDS archive will contain random bits, causing failures in\n-  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java (usually on Windows).\n-  \/\/\n-  \/\/ By using copy_from(), we can prevent the random padding from being copied,\n-  \/\/ ensuring that the ResolvedFieldEntries in a ConstantPoolCache (and thus the\n-  \/\/ CDS archive) will have all zeros in the padding.\n-\n-  \/\/ Copy constructor\n-  ResolvedFieldEntry(const ResolvedFieldEntry& other) {\n-    copy_from(other);\n-  }\n-\n-  \/\/ Copy assignment operator\n-  ResolvedFieldEntry& operator=(const ResolvedFieldEntry& other) {\n-    copy_from(other);\n-    return *this;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":11,"deletions":49,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"utilities\/macros.hpp\"\n@@ -865,11 +863,13 @@\n-\/\/ As an optimization, choose optimum vector size for copy length known at compile time.\n-int ArrayCopyNode::get_partial_inline_vector_lane_count(BasicType type, int const_len) {\n-  int lane_count = ArrayOperationPartialInlineSize\/type2aelembytes(type);\n-  if (const_len > 0) {\n-    int size_in_bytes = const_len * type2aelembytes(type);\n-    if (size_in_bytes <= 16)\n-      lane_count = 16\/type2aelembytes(type);\n-    else if (size_in_bytes > 16 && size_in_bytes <= 32)\n-      lane_count = 32\/type2aelembytes(type);\n-  }\n-  return lane_count;\n+\/\/ As an optimization, choose the optimal vector size for bounded copy length\n+int ArrayCopyNode::get_partial_inline_vector_lane_count(BasicType type, jlong max_len) {\n+  assert(max_len > 0, JLONG_FORMAT, max_len);\n+  \/\/ We only care whether max_size_in_bytes is not larger than 32, we also want to avoid\n+  \/\/ multiplication overflow, so clamp max_len to [0, 64]\n+  int max_size_in_bytes = MIN2<jlong>(max_len, 64) * type2aelembytes(type);\n+  if (ArrayOperationPartialInlineSize > 16 && max_size_in_bytes <= 16) {\n+    return 16 \/ type2aelembytes(type);\n+  } else if (ArrayOperationPartialInlineSize > 32 && max_size_in_bytes <= 32) {\n+    return 32 \/ type2aelembytes(type);\n+  } else {\n+    return ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n+  }\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-  static int get_partial_inline_vector_lane_count(BasicType type, int const_len);\n+  static int get_partial_inline_vector_lane_count(BasicType type, jlong max_len);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,4 +161,3 @@\n-  const bool is_virtual_or_interface = (bytecode == Bytecodes::_invokevirtual) ||\n-                                       (bytecode == Bytecodes::_invokeinterface) ||\n-                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual) ||\n-                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\n+  const bool is_virtual = (bytecode == Bytecodes::_invokevirtual) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual);\n+  const bool is_interface = (bytecode == Bytecodes::_invokeinterface) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\n+  const bool is_virtual_or_interface = is_virtual || is_interface;\n@@ -417,3 +416,12 @@\n-    if (call_does_dispatch && bytecode == Bytecodes::_invokeinterface) {\n-      ciInstanceKlass* declared_interface =\n-          caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n+    if (call_does_dispatch && is_interface) {\n+      ciInstanceKlass* declared_interface = nullptr;\n+      if (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface) {\n+        \/\/ MemberName doesn't keep information about resolved interface class (REFC) once\n+        \/\/ resolution is over, but resolved method holder (DECC) can be used as a\n+        \/\/ conservative approximation.\n+        declared_interface = callee->holder();\n+      } else {\n+        assert(!orig_callee->is_method_handle_intrinsic(), \"not allowed\");\n+        declared_interface = caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n+      }\n+      assert(declared_interface->is_interface(), \"required\");\n@@ -425,2 +433,1 @@\n-        assert(check_access, \"required\");\n-            callee->find_monomorphic_target(caller->holder(), declared_interface, singleton);\n+            callee->find_monomorphic_target(caller->holder(), declared_interface, singleton, check_access);\n@@ -450,1 +457,1 @@\n-    } \/\/ call_does_dispatch && bytecode == Bytecodes::_invokeinterface\n+    } \/\/ call_does_dispatch && is_interface\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+  NOT_PRODUCT(if (C->should_print_igv(\/* Any level *\/ 1)) C->igv_printer()->set_congraph(congraph);)\n@@ -124,0 +125,1 @@\n+  NOT_PRODUCT(if (C->should_print_igv(\/* Any level *\/ 1)) C->igv_printer()->set_congraph(nullptr);)\n@@ -131,0 +133,2 @@\n+\n+  C->print_method(PHASE_AFTER_EA, 2);\n@@ -296,0 +300,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_INITIAL_CONGRAPH, 4);\n+\n@@ -306,0 +312,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_COMPLETE_CONGRAPH, 4);\n+\n@@ -327,0 +335,1 @@\n+    _compile->print_method(PHASE_EA_ADJUST_SCALAR_REPLACEABLE_ITER, 6, n);\n@@ -365,0 +374,1 @@\n+  _compile->print_method(PHASE_EA_AFTER_PROPAGATE_NSR, 4);\n@@ -402,0 +412,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_GRAPH_OPTIMIZATION, 4);\n+\n@@ -413,1 +425,0 @@\n-    C->print_method(PHASE_AFTER_EA, 2);\n@@ -436,0 +447,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES, 4);\n+\n@@ -477,0 +490,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_REDUCE_PHI_ON_SAFEPOINTS, 4);\n+\n@@ -1343,0 +1358,2 @@\n+  _compile->print_method(PHASE_EA_BEFORE_PHI_REDUCTION, 5, ophi);\n+\n@@ -1348,0 +1365,1 @@\n+    _compile->print_method(PHASE_EA_AFTER_PHI_CASTPP_REDUCTION, 6, castpps.at(i));\n@@ -1355,0 +1373,1 @@\n+      _compile->print_method(PHASE_EA_AFTER_PHI_ADDP_REDUCTION, 6, use);\n@@ -1357,0 +1376,1 @@\n+      _compile->print_method(PHASE_EA_AFTER_PHI_CMP_REDUCTION, 6, use);\n@@ -2515,0 +2535,1 @@\n+      _compile->print_method(PHASE_EA_COMPLETE_CONNECTION_GRAPH_ITER, 5);\n@@ -2588,1 +2609,2 @@\n-                                               GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist) {\n+                                               GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist,\n+                                               bool print_method) {\n@@ -2648,0 +2670,3 @@\n+      if (print_method) {\n+        _compile->print_method(PHASE_EA_CONNECTION_GRAPH_PROPAGATE_ITER, 6, e->ideal_node());\n+      }\n@@ -3245,0 +3270,1 @@\n+        _compile->print_method(PHASE_EA_PROPAGATE_NSR_ITER, 5, jobj->ideal_node());\n@@ -3267,1 +3293,1 @@\n-  find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist);\n+  find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist, \/*print_method=*\/ false);\n@@ -4902,0 +4928,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES_1, 5);\n+\n@@ -5109,0 +5137,2 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES_3, 5);\n+\n@@ -5177,0 +5207,1 @@\n+  _compile->print_method(PHASE_EA_AFTER_SPLIT_UNIQUE_TYPES_4, 5);\n@@ -5199,0 +5230,4 @@\n+const char* PointsToNode::esc_name() const {\n+  return esc_names[(int)escape_state()];\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/idealGraphPrinter.hpp\"\n@@ -238,0 +239,1 @@\n+  const char* esc_name() const;\n@@ -324,0 +326,1 @@\n+  friend class IdealGraphPrinter;\n@@ -470,1 +473,2 @@\n-                                GrowableArray<JavaObjectNode*>& non_escaped_worklist);\n+                                GrowableArray<JavaObjectNode*>& non_escaped_worklist,\n+                                bool print_method = true);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1383,1 +1383,1 @@\n-  IdealLoopTree *get_loop( Node *n ) const {\n+  IdealLoopTree* get_loop(const Node* n) const {\n@@ -1393,2 +1393,8 @@\n-  int is_member( const IdealLoopTree *loop, Node *n ) const {\n-    return loop->is_member(get_loop(n)); }\n+  bool is_member(const IdealLoopTree* loop, const Node* n) const {\n+    return loop->is_member(get_loop(n));\n+  }\n+\n+  \/\/ is the control for 'n' a (nested) member of 'loop'?\n+  bool ctrl_is_member(const IdealLoopTree* loop, const Node* n) {\n+    return is_member(loop, get_ctrl(n));\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -647,1 +647,1 @@\n-        if (is_member(n_loop,get_ctrl(V))) {\n+        if (ctrl_is_member(n_loop, V)) {\n@@ -651,1 +651,1 @@\n-        if (!is_member(n_loop,get_ctrl(I))) {\n+        if (!ctrl_is_member(n_loop, I)) {\n@@ -951,2 +951,0 @@\n-    IdealLoopTree* address_loop = get_loop(get_ctrl(address));\n-    IdealLoopTree* value_loop = get_loop(get_ctrl(value));\n@@ -971,2 +969,2 @@\n-    if (!n_loop->is_member(address_loop) &&\n-        !n_loop->is_member(value_loop) &&\n+    if (!ctrl_is_member(n_loop, address) &&\n+        !ctrl_is_member(n_loop, value) &&\n@@ -1035,2 +1033,1 @@\n-      IdealLoopTree* address_loop = get_loop(get_ctrl(address));\n-      if (!n_loop->is_member(address_loop)) {\n+      if (!ctrl_is_member(n_loop, address)) {\n@@ -1044,2 +1041,1 @@\n-            IdealLoopTree *u_loop = get_loop(get_ctrl(u));\n-            if (!n_loop->is_member(u_loop)) {\n+            if (!ctrl_is_member(n_loop, u)) {\n@@ -2013,1 +2009,1 @@\n-              if (in != nullptr && n_loop->is_member(get_loop(get_ctrl(in)))) {\n+              if (in != nullptr && ctrl_is_member(n_loop, in)) {\n@@ -2549,5 +2545,3 @@\n-      Node* c = phase->get_ctrl(u);\n-      IdealLoopTree* u_loop = phase->get_loop(c);\n-      assert(!loop->is_member(u_loop) || !loop->_body.contains(u), \"can be in outer loop or out of both loops only\");\n-      if (!loop->is_member(u_loop)) {\n-        if (outer_loop->is_member(u_loop)) {\n+      assert(!phase->ctrl_is_member(loop, u) || !loop->_body.contains(u), \"can be in outer loop or out of both loops only\");\n+      if (!phase->ctrl_is_member(loop, u)) {\n+        if (phase->ctrl_is_member(outer_loop, u)) {\n@@ -3032,1 +3026,1 @@\n-  if (is_member(get_loop(iff), get_ctrl(cmp->in(2)))) {\n+  if (ctrl_is_member(get_loop(iff), cmp->in(2))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2201,2 +2201,1 @@\n-      \/\/ Address is aligned to execute prefetch to the beginning of cache line size\n-      \/\/ (it is important when BIS instruction is used on SPARC as prefetch).\n+      \/\/ Address is aligned to execute prefetch to the beginning of cache line size.\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -217,3 +217,1 @@\n-  const TypePtr *src_adr_type = _igvn.type(src_start)->isa_ptr();\n-  Node* inline_block = nullptr;\n-  Node* stub_block = nullptr;\n+  int inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n@@ -221,7 +219,4 @@\n-  int const_len = -1;\n-  const TypeInt* lty = nullptr;\n-  uint shift  = exact_log2(type2aelembytes(type));\n-  if (length->Opcode() == Op_ConvI2L) {\n-    lty = _igvn.type(length->in(1))->isa_int();\n-  } else  {\n-    lty = _igvn.type(length)->isa_int();\n+  const TypeLong* length_type = _igvn.type(length)->isa_long();\n+  if (length_type == nullptr) {\n+    assert(_igvn.type(length) == Type::TOP, \"\");\n+    return;\n@@ -229,2 +224,5 @@\n-  if (lty && lty->is_con()) {\n-    const_len = lty->get_con() << shift;\n+\n+  const TypeLong* inline_range = TypeLong::make(0, inline_limit, Type::WidenMin);\n+  if (length_type->join(inline_range) == Type::TOP) {\n+    \/\/ The ranges do not intersect, the inline check will surely fail\n+    return;\n@@ -233,5 +231,3 @@\n-  \/\/ Return if copy length is greater than partial inline size limit or\n-  \/\/ target does not supports masked load\/stores.\n-  int lane_count = ArrayCopyNode::get_partial_inline_vector_lane_count(type, const_len);\n-  if ( const_len > ArrayOperationPartialInlineSize ||\n-      !Matcher::match_rule_supported_vector(Op_LoadVectorMasked, lane_count, type)  ||\n+  \/\/ Return if the target does not supports masked load\/stores.\n+  int lane_count = ArrayCopyNode::get_partial_inline_vector_lane_count(type, length_type->_hi);\n+  if (!Matcher::match_rule_supported_vector(Op_LoadVectorMasked, lane_count, type)  ||\n@@ -243,7 +239,1 @@\n-  int inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n-  Node* casted_length = new CastLLNode(*ctrl, length, TypeLong::make(0, inline_limit, Type::WidenMin));\n-  transform_later(casted_length);\n-  Node* copy_bytes = new LShiftXNode(length, intcon(shift));\n-  transform_later(copy_bytes);\n-\n-  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayOperationPartialInlineSize));\n+  Node* cmp_le = new CmpULNode(length, longcon(inline_limit));\n@@ -253,2 +243,2 @@\n-  inline_block  = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n-  stub_block = *ctrl;\n+  Node* inline_block = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n+  Node* stub_block = *ctrl;\n@@ -256,0 +246,2 @@\n+  Node* casted_length = new CastLLNode(inline_block, length, inline_range, ConstraintCastNode::RegularDependency);\n+  transform_later(casted_length);\n@@ -259,1 +251,1 @@\n-  unsigned vec_size = lane_count *  type2aelembytes(type);\n+  unsigned vec_size = lane_count * type2aelembytes(type);\n@@ -264,0 +256,1 @@\n+  const TypePtr* src_adr_type = _igvn.type(src_start)->isa_ptr();\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2167,5 +2167,1 @@\n-  \/\/ If we are loading from a freshly-allocated object, produce a zero,\n-  \/\/ if the load is provably beyond the header of the object.\n-  \/\/ (Also allow a variable load from a fresh array to produce zero.)\n-  const TypeOopPtr* tinst = tp->isa_oopptr();\n-  bool is_instance = (tinst != nullptr) && tinst->is_known_instance_field();\n+  \/\/ If load can see a previous constant store, use that.\n@@ -2397,7 +2393,10 @@\n-  bool is_vect = (_type->isa_vect() != nullptr);\n-  if (is_instance && !is_vect) {\n-    \/\/ If we have an instance type and our memory input is the\n-    \/\/ programs's initial memory state, there is no matching store,\n-    \/\/ so just return a zero of the appropriate type -\n-    \/\/ except if it is vectorized - then we have no zero constant.\n-    Node *mem = in(MemNode::Memory);\n+  \/\/ If we are loading from a freshly-allocated object\/array, produce a zero.\n+  \/\/ Things to check:\n+  \/\/   1. Load is beyond the header: headers are not guaranteed to be zero\n+  \/\/   2. Load is not vectorized: vectors have no zero constant\n+  \/\/   3. Load has no matching store, i.e. the input is the initial memory state\n+  const TypeOopPtr* tinst = tp->isa_oopptr();\n+  bool is_not_header = (tinst != nullptr) && tinst->is_known_instance_field();\n+  bool is_not_vect = (_type->isa_vect() == nullptr);\n+  if (is_not_header && is_not_vect) {\n+    Node* mem = in(MemNode::Memory);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1222,1 +1222,1 @@\n-  } else if (this->is_Load() || this->is_DecodeN() || this->is_Phi()) {\n+  } else if ((this->is_Load() || this->is_DecodeN() || this->is_Phi()) && n->Opcode() == Op_MemBarAcquire) {\n@@ -1224,1 +1224,4 @@\n-    return n->Opcode() == Op_MemBarAcquire;\n+    return true;\n+  } else if (this->is_Load() && n->is_Move()) {\n+    \/\/ Condition for MoveX2Y (LoadX mem) => LoadY mem\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2631,0 +2631,10 @@\n+  \/\/ Check for \"abs(0-x)\" into \"abs(x)\" conversion\n+  if (use->is_Sub()) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == Op_AbsD || u->Opcode() == Op_AbsF ||\n+          u->Opcode() == Op_AbsL || u->Opcode() == Op_AbsI) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,0 +53,17 @@\n+  flags(EA_AFTER_INITIAL_CONGRAPH,          \"EA: 1. Intial Connection Graph\") \\\n+  flags(EA_CONNECTION_GRAPH_PROPAGATE_ITER, \"EA: 2. Connection Graph Propagate Iter\") \\\n+  flags(EA_COMPLETE_CONNECTION_GRAPH_ITER,  \"EA: 2. Complete Connection Graph Iter\") \\\n+  flags(EA_AFTER_COMPLETE_CONGRAPH,         \"EA: 2. Complete Connection Graph\") \\\n+  flags(EA_ADJUST_SCALAR_REPLACEABLE_ITER,  \"EA: 3. Adjust scalar_replaceable State Iter\") \\\n+  flags(EA_PROPAGATE_NSR_ITER,              \"EA: 3. Propagate NSR Iter\") \\\n+  flags(EA_AFTER_PROPAGATE_NSR,             \"EA: 3. Propagate NSR\") \\\n+  flags(EA_AFTER_GRAPH_OPTIMIZATION,        \"EA: 4. After Graph Optimization\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES_1,      \"EA: 5. After split_unique_types Phase 1\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES_3,      \"EA: 5. After split_unique_types Phase 3\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES_4,      \"EA: 5. After split_unique_types Phase 4\") \\\n+  flags(EA_AFTER_SPLIT_UNIQUE_TYPES,        \"EA: 5. After split_unique_types\") \\\n+  flags(EA_AFTER_REDUCE_PHI_ON_SAFEPOINTS,  \"EA: 6. After reduce_phi_on_safepoints\") \\\n+  flags(EA_BEFORE_PHI_REDUCTION,            \"EA: 5. Before Phi Reduction\") \\\n+  flags(EA_AFTER_PHI_CASTPP_REDUCTION,      \"EA: 5. Phi -> CastPP Reduction\") \\\n+  flags(EA_AFTER_PHI_ADDP_REDUCTION,        \"EA: 5. Phi -> AddP Reduction\") \\\n+  flags(EA_AFTER_PHI_CMP_REDUCTION,         \"EA: 5. Phi -> Cmp Reduction\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1915,0 +1915,26 @@\n+static void log_debug_if_final_static_field(JavaThread* current, const char* func_name, InstanceKlass* ik, int offset) {\n+  if (log_is_enabled(Debug, jni)) {\n+    fieldDescriptor fd;\n+    bool found = ik->find_field_from_offset(offset, true, &fd);\n+    assert(found, \"bad field offset\");\n+    assert(fd.is_static(), \"static\/instance mismatch\");\n+    if (fd.is_final() && !fd.is_mutable_static_final()) {\n+      ResourceMark rm(current);\n+      log_debug(jni)(\"%s mutated final static field %s.%s\", func_name, ik->external_name(), fd.name()->as_C_string());\n+    }\n+  }\n+}\n+\n+static void log_debug_if_final_instance_field(JavaThread* current, const char* func_name, InstanceKlass* ik, int offset) {\n+  if (log_is_enabled(Debug, jni)) {\n+    fieldDescriptor fd;\n+    bool found = ik->find_field_from_offset(offset, false, &fd);\n+    assert(found, \"bad field offset\");\n+    assert(!fd.is_static(), \"static\/instance mismatch\");\n+    if (fd.is_final()) {\n+      ResourceMark rm(current);\n+      log_debug(jni)(\"%s mutated final instance field %s.%s\", func_name, ik->external_name(), fd.name()->as_C_string());\n+    }\n+  }\n+}\n+\n@@ -1948,0 +1974,1 @@\n+  log_debug_if_final_instance_field(thread, \"SetObjectField\", InstanceKlass::cast(k), offset);\n@@ -1970,0 +1997,1 @@\n+  log_debug_if_final_instance_field(thread, \"Set<Type>Field\", InstanceKlass::cast(k), offset); \\\n@@ -2141,0 +2169,1 @@\n+  log_debug_if_final_static_field(THREAD, \"SetStaticObjectField\", id->holder(), id->offset());\n@@ -2162,0 +2191,1 @@\n+  log_debug_if_final_static_field(THREAD, \"SetStatic<Type>Field\", id->holder(), id->offset()); \\\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype)\n+checkStaticFieldID(JavaThread* thr, jfieldID fid, jclass cls, int ftype, bool setter)\n@@ -261,0 +261,8 @@\n+\n+  \/* check if setting a final field *\/\n+  if (setter && fd.is_final() && !fd.is_mutable_static_final()) {\n+    ResourceMark rm(thr);\n+    stringStream ss;\n+    ss.print(\"SetStatic<Type>Field called to mutate final static field %s.%s\", k_oop->external_name(), fd.name()->as_C_string());\n+    ReportJNIWarning(thr, ss.as_string());\n+  }\n@@ -264,1 +272,1 @@\n-checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype)\n+checkInstanceFieldID(JavaThread* thr, jfieldID fid, jobject obj, int ftype, bool setter)\n@@ -290,2 +298,1 @@\n-  if (!InstanceKlass::cast(k_oop)->find_field_from_offset(offset,\n-                                                              false, &fd))\n+  if (!InstanceKlass::cast(k_oop)->find_field_from_offset(offset, false, &fd))\n@@ -298,0 +305,8 @@\n+\n+  \/* check if setting a final field *\/\n+  if (setter && fd.is_final()) {\n+    ResourceMark rm(thr);\n+    stringStream ss;\n+    ss.print(\"Set<Type>Field called to mutate final instance field %s.%s\", k_oop->external_name(), fd.name()->as_C_string());\n+    ReportJNIWarning(thr, ss.as_string());\n+  }\n@@ -1207,1 +1222,1 @@\n-      checkInstanceFieldID(thr, fieldID, obj, FieldType); \\\n+      checkInstanceFieldID(thr, fieldID, obj, FieldType, false); \\\n@@ -1232,1 +1247,1 @@\n-      checkInstanceFieldID(thr, fieldID, obj, FieldType); \\\n+      checkInstanceFieldID(thr, fieldID, obj, FieldType, true); \\\n@@ -1398,1 +1413,1 @@\n-      checkStaticFieldID(thr, fieldID, clazz, FieldType); \\\n+      checkStaticFieldID(thr, fieldID, clazz, FieldType, false); \\\n@@ -1426,1 +1441,1 @@\n-      checkStaticFieldID(thr, fieldID, clazz, FieldType); \\\n+      checkStaticFieldID(thr, fieldID, clazz, FieldType, true); \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2535,0 +2535,33 @@\n+\/\/ A supporting closure used to process ClassLoaderData roots.\n+class CLDRootsClosure: public OopClosure {\n+private:\n+  bool _continue;\n+public:\n+  CLDRootsClosure(): _continue(true) {}\n+\n+  inline bool stopped() {\n+    return !_continue;\n+  }\n+\n+  void do_oop(oop* obj_p) {\n+    if (stopped()) {\n+      return;\n+    }\n+\n+    oop o = NativeAccess<AS_NO_KEEPALIVE>::oop_load(obj_p);\n+    \/\/ ignore null\n+    if (o == nullptr) {\n+      return;\n+    }\n+\n+    jvmtiHeapReferenceKind kind = JVMTI_HEAP_REFERENCE_OTHER;\n+    if (o->klass() == vmClasses::Class_klass()) {\n+      kind = JVMTI_HEAP_REFERENCE_SYSTEM_CLASS;\n+    }\n+\n+    \/\/ invoke the callback\n+    _continue = CallbackInvoker::report_simple_root(kind, o);\n+  }\n+  virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }\n+};\n+\n@@ -3163,2 +3196,2 @@\n-  blk.set_kind(JVMTI_HEAP_REFERENCE_SYSTEM_CLASS);\n-  CLDToOopClosure cld_closure(&blk, ClassLoaderData::_claim_none);\n+  CLDRootsClosure cld_roots_closure;\n+  CLDToOopClosure cld_closure(&cld_roots_closure, ClassLoaderData::_claim_none);\n@@ -3166,1 +3199,1 @@\n-  if (blk.stopped()) {\n+  if (cld_roots_closure.stopped()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2700,1 +2700,7 @@\n-  LINUX_ONLY(return (jlong)os::Linux::host_swap();)\n+#ifdef LINUX\n+  physical_memory_size_type swap_val = 0;\n+  if (!os::Linux::host_swap(swap_val)) {\n+    return -1; \/\/ treat as unlimited\n+  }\n+  return static_cast<jlong>(swap_val);\n+#endif\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -322,0 +322,4 @@\n+#define ENABLE_FINAL_FIELD_MUTATION \"enable.final.field.mutation\"\n+#define ENABLE_FINAL_FIELD_MUTATION_LEN 27\n+#define ILLEGAL_FINAL_FIELD_MUTATION \"illegal.final.field.mutation\"\n+#define ILLEGAL_FINAL_FIELD_MUTATION_LEN 28\n@@ -348,1 +352,3 @@\n-        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN)) {\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n+        matches_property_suffix(property_suffix, ENABLE_FINAL_FIELD_MUTATION, ENABLE_FINAL_FIELD_MUTATION_LEN) ||\n+        matches_property_suffix(property_suffix, ILLEGAL_FINAL_FIELD_MUTATION, ILLEGAL_FINAL_FIELD_MUTATION_LEN)) {\n@@ -547,1 +553,1 @@\n-  { \"UseCompressedClassPointers\",   JDK_Version::jdk(25),  JDK_Version::jdk(26), JDK_Version::undefined() },\n+  { \"UseCompressedClassPointers\",   JDK_Version::jdk(25),  JDK_Version::jdk(27), JDK_Version::undefined() },\n@@ -1824,0 +1830,1 @@\n+static unsigned int enable_final_field_mutation = 0;\n@@ -2372,0 +2379,13 @@\n+    } else if (match_option(option, \"--enable-final-field-mutation=\", &tail)) {\n+      if (!create_numbered_module_property(\"jdk.module.enable.final.field.mutation\", tail, enable_final_field_mutation++)) {\n+        return JNI_ENOMEM;\n+      }\n+    } else if (match_option(option, \"--illegal-final-field-mutation=\", &tail)) {\n+      if (strcmp(tail, \"allow\") == 0 || strcmp(tail, \"warn\") == 0 || strcmp(tail, \"debug\") == 0 || strcmp(tail, \"deny\") == 0) {\n+        PropertyList_unique_add(&_system_properties, \"jdk.module.illegal.final.field.mutation\", tail,\n+                                AddProperty, WriteableProperty, InternalProperty);\n+      } else {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"Value specified to --illegal-final-field-mutation not recognized: '%s'\\n\", tail);\n+        return JNI_ERR;\n+      }\n@@ -2566,0 +2586,3 @@\n+      if (match_option(option, \"-Xmaxjitcodesize\", &tail)) {\n+        warning(\"Option -Xmaxjitcodesize was deprecated in JDK 26 and will likely be removed in a future release.\");\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -51,0 +51,10 @@\n+bool fieldDescriptor::is_mutable_static_final() const {\n+  InstanceKlass* ik = field_holder();\n+  \/\/ write protected fields (JLS 17.5.4)\n+  if (is_final() && is_static() && ik == vmClasses::System_klass() &&\n+      (offset() == java_lang_System::in_offset() || offset() == java_lang_System::out_offset() || offset() == java_lang_System::err_offset())) {\n+   return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,0 +109,2 @@\n+  bool is_mutable_static_final()  const;\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  template(CollectForCodeCacheAllocation)         \\\n@@ -72,4 +71,0 @@\n-  template(XMarkStart)                            \\\n-  template(XMarkEnd)                              \\\n-  template(XRelocateStart)                        \\\n-  template(XVerify)                               \\\n@@ -118,1 +113,0 @@\n-  template(JvmtiPostObjectFree)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -355,1 +355,0 @@\n-     static_field(ThreadLocalAllocBuffer,      _reserve_for_allocation_prefetch,              int)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1391,0 +1391,8 @@\n+\/\/ This provides a workaround for static_assert(false) in discarded or\n+\/\/ otherwise uninstantiated places.  Instead use\n+\/\/   static_assert(DependentAlwaysFalse<T>, \"...\")\n+\/\/ See http:\/\/wg21.link\/p2593r1. Some, but not all, compiler versions we're\n+\/\/ using have implemented that change as a DR:\n+\/\/ https:\/\/cplusplus.github.io\/CWG\/issues\/2518.html\n+template<typename T> inline constexpr bool DependentAlwaysFalse = false;\n+\n@@ -1395,0 +1403,21 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Forbid using the global allocator by HotSpot code.\n+\/\/\n+\/\/ This is a subset of allocator and deallocator functions. These are\n+\/\/ implicitly declared in all translation units, without needing to include\n+\/\/ <new>; see C++17 6.7.4. This isn't even the full set of those; implicit\n+\/\/ declarations involving std::align_val_t are not covered here, since that\n+\/\/ type is defined in <new>.  A translation unit that doesn't include <new> is\n+\/\/ still likely to include this file.  See cppstdlib\/new.hpp for more details.\n+#ifndef HOTSPOT_GTEST\n+\n+[[deprecated]] void* operator new(std::size_t);\n+[[deprecated]] void operator delete(void*) noexcept;\n+[[deprecated]] void operator delete(void*, std::size_t) noexcept;\n+\n+[[deprecated]] void* operator new[](std::size_t);\n+[[deprecated]] void operator delete[](void*) noexcept;\n+[[deprecated]] void operator delete[](void*, std::size_t) noexcept;\n+\n+#endif \/\/ HOTSPOT_GTEST\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n- * Character information is based on the Unicode Standard, version 16.0.\n+ * Character information is based on the Unicode Standard, version 17.0.\n@@ -80,0 +80,2 @@\n+ * <tr><th scope=\"row\" style=\"text-align:left\">Java SE 26<\/th>\n+ *     <td>Unicode 17.0<\/td><\/tr>\n@@ -758,1 +760,1 @@\n-        private static final int NUM_ENTITIES = 782;\n+        private static final int NUM_ENTITIES = 804;\n@@ -3728,0 +3730,79 @@\n+        \/**\n+         * Constant for the \"Sidetic\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock SIDETIC =\n+            new UnicodeBlock(\"SIDETIC\");\n+\n+        \/**\n+         * Constant for the \"Sharada Supplement\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock SHARADA_SUPPLEMENT =\n+            new UnicodeBlock(\"SHARADA_SUPPLEMENT\",\n+                \"SHARADA SUPPLEMENT\",\n+                \"SHARADASUPPLEMENT\");\n+\n+        \/**\n+         * Constant for the \"Tolong Siki\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock TOLONG_SIKI =\n+            new UnicodeBlock(\"TOLONG_SIKI\",\n+                \"TOLONG SIKI\",\n+                \"TOLONGSIKI\");\n+\n+        \/**\n+         * Constant for the \"Beria Erfe\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock BERIA_ERFE =\n+            new UnicodeBlock(\"BERIA_ERFE\",\n+                \"BERIA ERFE\",\n+                \"BERIAERFE\");\n+\n+        \/**\n+         * Constant for the \"Tangut Components Supplement\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock TANGUT_COMPONENTS_SUPPLEMENT =\n+            new UnicodeBlock(\"TANGUT_COMPONENTS_SUPPLEMENT\",\n+                \"TANGUT COMPONENTS SUPPLEMENT\",\n+                \"TANGUTCOMPONENTSSUPPLEMENT\");\n+\n+        \/**\n+         * Constant for the \"Miscellaneous Symbols Supplement\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock MISCELLANEOUS_SYMBOLS_SUPPLEMENT =\n+            new UnicodeBlock(\"MISCELLANEOUS_SYMBOLS_SUPPLEMENT\",\n+                \"MISCELLANEOUS SYMBOLS SUPPLEMENT\",\n+                \"MISCELLANEOUSSYMBOLSSUPPLEMENT\");\n+\n+        \/**\n+         * Constant for the \"Tai Yo\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock TAI_YO =\n+            new UnicodeBlock(\"TAI_YO\",\n+                \"TAI YO\",\n+                \"TAIYO\");\n+\n+        \/**\n+         * Constant for the \"CJK Unified Ideographs Extension J\" Unicode\n+         * character block.\n+         * @since 26\n+         *\/\n+        public static final UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_J =\n+            new UnicodeBlock(\"CJK_UNIFIED_IDEOGRAPHS_EXTENSION_J\",\n+                \"CJK UNIFIED IDEOGRAPHS EXTENSION J\",\n+                \"CJKUNIFIEDIDEOGRAPHSEXTENSIONJ\");\n+\n+\n@@ -3929,1 +4010,2 @@\n-            0x10940,  \/\/               unassigned\n+            0x10940,  \/\/ 10940..1095F; Sidetic\n+            0x10960,  \/\/               unassigned\n@@ -3990,1 +4072,2 @@\n-            0x11B60,  \/\/               unassigned\n+            0x11B60,  \/\/ 11B60..11B7F; Sharada Supplement\n+            0x11B80,  \/\/               unassigned\n@@ -3997,1 +4080,2 @@\n-            0x11DB0,  \/\/               unassigned\n+            0x11DB0,  \/\/ 11DB0..11DEF; Tolong Siki\n+            0x11DF0,  \/\/               unassigned\n@@ -4024,1 +4108,2 @@\n-            0x16EA0,  \/\/               unassigned\n+            0x16EA0,  \/\/ 16EA0..16EDF; Beria Erfe\n+            0x16EE0,  \/\/               unassigned\n@@ -4032,1 +4117,2 @@\n-            0x18D80,  \/\/               unassigned\n+            0x18D80,  \/\/ 18D80..18DFF; Tangut Components Supplement\n+            0x18E00,  \/\/               unassigned\n@@ -4043,1 +4129,1 @@\n-            0x1CEC0,  \/\/               unassigned\n+            0x1CEC0,  \/\/ 1CEC0..1CEFF; Miscellaneous Symbols Supplement\n@@ -4071,0 +4157,2 @@\n+            0x1E6C0,  \/\/ 1E6C0..1E6FF; Tai Yo\n+            0x1E700,  \/\/               unassigned\n@@ -4111,1 +4199,2 @@\n-            0x323B0,  \/\/               unassigned\n+            0x323B0,  \/\/ 323B0..3347F; CJK Unified Ideographs Extension J\n+            0x33480,  \/\/               unassigned\n@@ -4321,0 +4410,1 @@\n+            SIDETIC,\n@@ -4382,0 +4472,1 @@\n+            SHARADA_SUPPLEMENT,\n@@ -4389,0 +4480,1 @@\n+            TOLONG_SIKI,\n@@ -4416,0 +4508,1 @@\n+            BERIA_ERFE,\n@@ -4424,0 +4517,1 @@\n+            TANGUT_COMPONENTS_SUPPLEMENT,\n@@ -4435,1 +4529,1 @@\n-            null,\n+            MISCELLANEOUS_SYMBOLS_SUPPLEMENT,\n@@ -4463,0 +4557,2 @@\n+            TAI_YO,\n+            null,\n@@ -4503,0 +4599,1 @@\n+            CJK_UNIFIED_IDEOGRAPHS_EXTENSION_J,\n@@ -5560,0 +5657,24 @@\n+        \/**\n+         * Unicode script \"Sidetic\".\n+         * @since 26\n+         *\/\n+        SIDETIC,\n+\n+        \/**\n+         * Unicode script \"Tolong Siki\".\n+         * @since 26\n+         *\/\n+        TOLONG_SIKI,\n+\n+        \/**\n+         * Unicode script \"Beria Erfe\".\n+         * @since 26\n+         *\/\n+        BERIA_ERFE,\n+\n+        \/**\n+         * Unicode script \"Tai Yo\".\n+         * @since 26\n+         *\/\n+        TAI_YO,\n+\n@@ -5661,3 +5782,1 @@\n-            0x0870,   \/\/ 0870..088E; ARABIC\n-            0x088F,   \/\/ 088F      ; UNKNOWN\n-            0x0890,   \/\/ 0890..0891; ARABIC\n+            0x0870,   \/\/ 0870..0891; ARABIC\n@@ -5838,2 +5957,2 @@\n-            0x0C5B,   \/\/ 0C5B..0C5C; UNKNOWN\n-            0x0C5D,   \/\/ 0C5D      ; TELUGU\n+            0x0C5B,   \/\/ 0C5B      ; UNKNOWN\n+            0x0C5C,   \/\/ 0C5C..0C5D; TELUGU\n@@ -5863,2 +5982,2 @@\n-            0x0CD7,   \/\/ 0CD7..0CDC; UNKNOWN\n-            0x0CDD,   \/\/ 0CDD..0CDE; KANNADA\n+            0x0CD7,   \/\/ 0CD7..0CDB; UNKNOWN\n+            0x0CDC,   \/\/ 0CDC..0CDE; KANNADA\n@@ -6075,2 +6194,4 @@\n-            0x1AB0,   \/\/ 1AB0..1ACE; INHERITED\n-            0x1ACF,   \/\/ 1ACF..1AFF; UNKNOWN\n+            0x1AB0,   \/\/ 1AB0..1ADD; INHERITED\n+            0x1ADE,   \/\/ 1ADE..1ADF; UNKNOWN\n+            0x1AE0,   \/\/ 1AE0..1AEB; INHERITED\n+            0x1AEC,   \/\/ 1AEC..1AFF; UNKNOWN\n@@ -6168,2 +6289,2 @@\n-            0x20A0,   \/\/ 20A0..20C0; COMMON\n-            0x20C1,   \/\/ 20C1..20CF; UNKNOWN\n+            0x20A0,   \/\/ 20A0..20C1; COMMON\n+            0x20C2,   \/\/ 20C2..20CF; UNKNOWN\n@@ -6192,3 +6313,1 @@\n-            0x2B76,   \/\/ 2B76..2B95; COMMON\n-            0x2B96,   \/\/ 2B96      ; UNKNOWN\n-            0x2B97,   \/\/ 2B97..2BFF; COMMON\n+            0x2B76,   \/\/ 2B76..2BFF; COMMON\n@@ -6295,9 +6414,3 @@\n-            0xA78B,   \/\/ A78B..A7CD; LATIN\n-            0xA7CE,   \/\/ A7CE..A7CF; UNKNOWN\n-            0xA7D0,   \/\/ A7D0..A7D1; LATIN\n-            0xA7D2,   \/\/ A7D2      ; UNKNOWN\n-            0xA7D3,   \/\/ A7D3      ; LATIN\n-            0xA7D4,   \/\/ A7D4      ; UNKNOWN\n-            0xA7D5,   \/\/ A7D5..A7DC; LATIN\n-            0xA7DD,   \/\/ A7DD..A7F1; UNKNOWN\n-            0xA7F2,   \/\/ A7F2..A7FF; LATIN\n+            0xA78B,   \/\/ A78B..A7DC; LATIN\n+            0xA7DD,   \/\/ A7DD..A7F0; UNKNOWN\n+            0xA7F1,   \/\/ A7F1..A7FF; LATIN\n@@ -6391,3 +6504,1 @@\n-            0xFB50,   \/\/ FB50..FBC2; ARABIC\n-            0xFBC3,   \/\/ FBC3..FBD2; UNKNOWN\n-            0xFBD3,   \/\/ FBD3..FD3D; ARABIC\n+            0xFB50,   \/\/ FB50..FD3D; ARABIC\n@@ -6395,5 +6506,1 @@\n-            0xFD40,   \/\/ FD40..FD8F; ARABIC\n-            0xFD90,   \/\/ FD90..FD91; UNKNOWN\n-            0xFD92,   \/\/ FD92..FDC7; ARABIC\n-            0xFDC8,   \/\/ FDC8..FDCE; UNKNOWN\n-            0xFDCF,   \/\/ FDCF      ; ARABIC\n+            0xFD40,   \/\/ FD40..FDCF; ARABIC\n@@ -6568,1 +6675,2 @@\n-            0x10940,  \/\/ 10940..1097F; UNKNOWN\n+            0x10940,  \/\/ 10940..10959; SIDETIC\n+            0x1095A,  \/\/ 1095A..1097F; UNKNOWN\n@@ -6638,3 +6746,5 @@\n-            0x10EC2,  \/\/ 10EC2..10EC4; ARABIC\n-            0x10EC5,  \/\/ 10EC5..10EFB; UNKNOWN\n-            0x10EFC,  \/\/ 10EFC..10EFF; ARABIC\n+            0x10EC2,  \/\/ 10EC2..10EC7; ARABIC\n+            0x10EC8,  \/\/ 10EC8..10ECF; UNKNOWN\n+            0x10ED0,  \/\/ 10ED0..10ED8; ARABIC\n+            0x10ED9,  \/\/ 10ED9..10EF9; UNKNOWN\n+            0x10EFA,  \/\/ 10EFA..10EFF; ARABIC\n@@ -6810,1 +6920,3 @@\n-            0x11B0A,  \/\/ 11B0A..11BBF; UNKNOWN\n+            0x11B0A,  \/\/ 11B0A..11B5F; UNKNOWN\n+            0x11B60,  \/\/ 11B60..11B67; SHARADA\n+            0x11B68,  \/\/ 11B68..11BBF; UNKNOWN\n@@ -6854,1 +6966,5 @@\n-            0x11DAA,  \/\/ 11DAA..11EDF; UNKNOWN\n+            0x11DAA,  \/\/ 11DAA..11DAF; UNKNOWN\n+            0x11DB0,  \/\/ 11DB0..11DDB; TOLONG_SIKI\n+            0x11DDC,  \/\/ 11DDC..11DDF; UNKNOWN\n+            0x11DE0,  \/\/ 11DE0..11DE9; TOLONG_SIKI\n+            0x11DEA,  \/\/ 11DEA..11EDF; UNKNOWN\n@@ -6914,1 +7030,5 @@\n-            0x16E9B,  \/\/ 16E9B..16EFF; UNKNOWN\n+            0x16E9B,  \/\/ 16E9B..16E9F; UNKNOWN\n+            0x16EA0,  \/\/ 16EA0..16EB8; BERIA_ERFE\n+            0x16EB9,  \/\/ 16EB9..16EBA; UNKNOWN\n+            0x16EBB,  \/\/ 16EBB..16ED3; BERIA_ERFE\n+            0x16ED4,  \/\/ 16ED4..16EFF; UNKNOWN\n@@ -6926,5 +7046,3 @@\n-            0x16FF0,  \/\/ 16FF0..16FF1; HAN\n-            0x16FF2,  \/\/ 16FF2..16FFF; UNKNOWN\n-            0x17000,  \/\/ 17000..187F7; TANGUT\n-            0x187F8,  \/\/ 187F8..187FF; UNKNOWN\n-            0x18800,  \/\/ 18800..18AFF; TANGUT\n+            0x16FF0,  \/\/ 16FF0..16FF6; HAN\n+            0x16FF7,  \/\/ 16FF7..16FFF; UNKNOWN\n+            0x17000,  \/\/ 17000..18AFF; TANGUT\n@@ -6934,2 +7052,4 @@\n-            0x18D00,  \/\/ 18D00..18D08; TANGUT\n-            0x18D09,  \/\/ 18D09..1AFEF; UNKNOWN\n+            0x18D00,  \/\/ 18D00..18D1E; TANGUT\n+            0x18D1F,  \/\/ 18D1F..18D7F; UNKNOWN\n+            0x18D80,  \/\/ 18D80..18DF2; TANGUT\n+            0x18DF3,  \/\/ 18DF3..1AFEF; UNKNOWN\n@@ -6967,2 +7087,2 @@\n-            0x1CC00,  \/\/ 1CC00..1CCF9; COMMON\n-            0x1CCFA,  \/\/ 1CCFA..1CCFF; UNKNOWN\n+            0x1CC00,  \/\/ 1CC00..1CCFC; COMMON\n+            0x1CCFD,  \/\/ 1CCFD..1CCFF; UNKNOWN\n@@ -6970,1 +7090,5 @@\n-            0x1CEB4,  \/\/ 1CEB4..1CEFF; UNKNOWN\n+            0x1CEB4,  \/\/ 1CEB4..1CEB9; UNKNOWN\n+            0x1CEBA,  \/\/ 1CEBA..1CED0; COMMON\n+            0x1CED1,  \/\/ 1CED1..1CEDF; UNKNOWN\n+            0x1CEE0,  \/\/ 1CEE0..1CEF0; COMMON\n+            0x1CEF1,  \/\/ 1CEF1..1CEFF; UNKNOWN\n@@ -7085,1 +7209,7 @@\n-            0x1E600,  \/\/ 1E600..1E7DF; UNKNOWN\n+            0x1E600,  \/\/ 1E600..1E6BF; UNKNOWN\n+            0x1E6C0,  \/\/ 1E6C0..1E6DE; TAI_YO\n+            0x1E6DF,  \/\/ 1E6DF       ; UNKNOWN\n+            0x1E6E0,  \/\/ 1E6E0..1E6F5; TAI_YO\n+            0x1E6F6,  \/\/ 1E6F6..1E6FD; UNKNOWN\n+            0x1E6FE,  \/\/ 1E6FE..1E6FF; TAI_YO\n+            0x1E700,  \/\/ 1E700..1E7DF; UNKNOWN\n@@ -7202,2 +7332,2 @@\n-            0x1F300,  \/\/ 1F300..1F6D7; COMMON\n-            0x1F6D8,  \/\/ 1F6D8..1F6DB; UNKNOWN\n+            0x1F300,  \/\/ 1F300..1F6D8; COMMON\n+            0x1F6D9,  \/\/ 1F6D9..1F6DB; UNKNOWN\n@@ -7208,3 +7338,1 @@\n-            0x1F700,  \/\/ 1F700..1F776; COMMON\n-            0x1F777,  \/\/ 1F777..1F77A; UNKNOWN\n-            0x1F77B,  \/\/ 1F77B..1F7D9; COMMON\n+            0x1F700,  \/\/ 1F700..1F7D9; COMMON\n@@ -7229,3 +7357,5 @@\n-            0x1F8C2,  \/\/ 1F8C2..1F8FF; UNKNOWN\n-            0x1F900,  \/\/ 1F900..1FA53; COMMON\n-            0x1FA54,  \/\/ 1FA54..1FA5F; UNKNOWN\n+            0x1F8C2,  \/\/ 1F8C2..1F8CF; UNKNOWN\n+            0x1F8D0,  \/\/ 1F8D0..1F8D8; COMMON\n+            0x1F8D9,  \/\/ 1F8D9..1F8FF; UNKNOWN\n+            0x1F900,  \/\/ 1F900..1FA57; COMMON\n+            0x1FA58,  \/\/ 1FA58..1FA5F; UNKNOWN\n@@ -7236,5 +7366,7 @@\n-            0x1FA80,  \/\/ 1FA80..1FA89; COMMON\n-            0x1FA8A,  \/\/ 1FA8A..1FA8E; UNKNOWN\n-            0x1FA8F,  \/\/ 1FA8F..1FAC6; COMMON\n-            0x1FAC7,  \/\/ 1FAC7..1FACD; UNKNOWN\n-            0x1FACE,  \/\/ 1FACE..1FADC; COMMON\n+            0x1FA80,  \/\/ 1FA80..1FA8A; COMMON\n+            0x1FA8B,  \/\/ 1FA8B..1FA8D; UNKNOWN\n+            0x1FA8E,  \/\/ 1FA8E..1FAC6; COMMON\n+            0x1FAC7,  \/\/ 1FAC7       ; UNKNOWN\n+            0x1FAC8,  \/\/ 1FAC8       ; COMMON\n+            0x1FAC9,  \/\/ 1FAC9..1FACC; UNKNOWN\n+            0x1FACD,  \/\/ 1FACD..1FADC; COMMON\n@@ -7242,3 +7374,3 @@\n-            0x1FADF,  \/\/ 1FADF..1FAE9; COMMON\n-            0x1FAEA,  \/\/ 1FAEA..1FAEF; UNKNOWN\n-            0x1FAF0,  \/\/ 1FAF0..1FAF8; COMMON\n+            0x1FADF,  \/\/ 1FADF..1FAEA; COMMON\n+            0x1FAEB,  \/\/ 1FAEB..1FAEE; UNKNOWN\n+            0x1FAEF,  \/\/ 1FAEF..1FAF8; COMMON\n@@ -7248,2 +7380,2 @@\n-            0x1FB94,  \/\/ 1FB94..1FBF9; COMMON\n-            0x1FBFA,  \/\/ 1FBFA..1FFFF; UNKNOWN\n+            0x1FB94,  \/\/ 1FB94..1FBFA; COMMON\n+            0x1FBFB,  \/\/ 1FBFB..1FFFF; UNKNOWN\n@@ -7252,3 +7384,1 @@\n-            0x2A700,  \/\/ 2A700..2B739; HAN\n-            0x2B73A,  \/\/ 2B73A..2B73F; UNKNOWN\n-            0x2B740,  \/\/ 2B740..2B81D; HAN\n+            0x2A700,  \/\/ 2A700..2B81D; HAN\n@@ -7256,2 +7386,2 @@\n-            0x2B820,  \/\/ 2B820..2CEA1; HAN\n-            0x2CEA2,  \/\/ 2CEA2..2CEAF; UNKNOWN\n+            0x2B820,  \/\/ 2B820..2CEAD; HAN\n+            0x2CEAE,  \/\/ 2CEAE..2CEAF; UNKNOWN\n@@ -7266,2 +7396,2 @@\n-            0x31350,  \/\/ 31350..323AF; HAN\n-            0x323B0,  \/\/ 323B0..E0000; UNKNOWN\n+            0x31350,  \/\/ 31350..33479; HAN\n+            0x3347A,  \/\/ 3347A..E0000; UNKNOWN\n@@ -7372,3 +7502,1 @@\n-            ARABIC,                   \/\/ 0870..088E\n-            UNKNOWN,                  \/\/ 088F\n-            ARABIC,                   \/\/ 0890..0891\n+            ARABIC,                   \/\/ 0870..0891\n@@ -7549,2 +7677,2 @@\n-            UNKNOWN,                  \/\/ 0C5B..0C5C\n-            TELUGU,                   \/\/ 0C5D\n+            UNKNOWN,                  \/\/ 0C5B\n+            TELUGU,                   \/\/ 0C5C..0C5D\n@@ -7574,2 +7702,2 @@\n-            UNKNOWN,                  \/\/ 0CD7..0CDC\n-            KANNADA,                  \/\/ 0CDD..0CDE\n+            UNKNOWN,                  \/\/ 0CD7..0CDB\n+            KANNADA,                  \/\/ 0CDC..0CDE\n@@ -7786,2 +7914,4 @@\n-            INHERITED,                \/\/ 1AB0..1ACE\n-            UNKNOWN,                  \/\/ 1ACF..1AFF\n+            INHERITED,                \/\/ 1AB0..1ADD\n+            UNKNOWN,                  \/\/ 1ADE..1ADF\n+            INHERITED,                \/\/ 1AE0..1AEB\n+            UNKNOWN,                  \/\/ 1AEC..1AFF\n@@ -7879,2 +8009,2 @@\n-            COMMON,                   \/\/ 20A0..20C0\n-            UNKNOWN,                  \/\/ 20C1..20CF\n+            COMMON,                   \/\/ 20A0..20C1\n+            UNKNOWN,                  \/\/ 20C2..20CF\n@@ -7903,3 +8033,1 @@\n-            COMMON,                   \/\/ 2B76..2B95\n-            UNKNOWN,                  \/\/ 2B96\n-            COMMON,                   \/\/ 2B97..2BFF\n+            COMMON,                   \/\/ 2B76..2BFF\n@@ -8006,9 +8134,3 @@\n-            LATIN,                    \/\/ A78B..A7CD\n-            UNKNOWN,                  \/\/ A7CE..A7CF\n-            LATIN,                    \/\/ A7D0..A7D1\n-            UNKNOWN,                  \/\/ A7D2\n-            LATIN,                    \/\/ A7D3\n-            UNKNOWN,                  \/\/ A7D4\n-            LATIN,                    \/\/ A7D5..A7DC\n-            UNKNOWN,                  \/\/ A7DD..A7F1\n-            LATIN,                    \/\/ A7F2..A7FF\n+            LATIN,                    \/\/ A78B..A7DC\n+            UNKNOWN,                  \/\/ A7DD..A7F0\n+            LATIN,                    \/\/ A7F1..A7FF\n@@ -8102,3 +8224,1 @@\n-            ARABIC,                   \/\/ FB50..FBC2\n-            UNKNOWN,                  \/\/ FBC3..FBD2\n-            ARABIC,                   \/\/ FBD3..FD3D\n+            ARABIC,                   \/\/ FB50..FD3D\n@@ -8106,5 +8226,1 @@\n-            ARABIC,                   \/\/ FD40..FD8F\n-            UNKNOWN,                  \/\/ FD90..FD91\n-            ARABIC,                   \/\/ FD92..FDC7\n-            UNKNOWN,                  \/\/ FDC8..FDCE\n-            ARABIC,                   \/\/ FDCF\n+            ARABIC,                   \/\/ FD40..FDCF\n@@ -8279,1 +8395,2 @@\n-            UNKNOWN,                  \/\/ 10940..1097F\n+            SIDETIC,                  \/\/ 10940..10959\n+            UNKNOWN,                  \/\/ 1095A..1097F\n@@ -8349,3 +8466,5 @@\n-            ARABIC,                   \/\/ 10EC2..10EC4\n-            UNKNOWN,                  \/\/ 10EC5..10EFB\n-            ARABIC,                   \/\/ 10EFC..10EFF\n+            ARABIC,                   \/\/ 10EC2..10EC7\n+            UNKNOWN,                  \/\/ 10EC8..10ECF\n+            ARABIC,                   \/\/ 10ED0..10ED8\n+            UNKNOWN,                  \/\/ 10ED9..10EF9\n+            ARABIC,                   \/\/ 10EFA..10EFF\n@@ -8521,1 +8640,3 @@\n-            UNKNOWN,                  \/\/ 11B0A..11BBF\n+            UNKNOWN,                  \/\/ 11B0A..11B5F\n+            SHARADA,                  \/\/ 11B60..11B67\n+            UNKNOWN,                  \/\/ 11B68..11BBF\n@@ -8565,1 +8686,5 @@\n-            UNKNOWN,                  \/\/ 11DAA..11EDF\n+            UNKNOWN,                  \/\/ 11DAA..11DAF\n+            TOLONG_SIKI,              \/\/ 11DB0..11DDB\n+            UNKNOWN,                  \/\/ 11DDC..11DDF\n+            TOLONG_SIKI,              \/\/ 11DE0..11DE9\n+            UNKNOWN,                  \/\/ 11DEA..11EDF\n@@ -8625,1 +8750,5 @@\n-            UNKNOWN,                  \/\/ 16E9B..16EFF\n+            UNKNOWN,                  \/\/ 16E9B..16E9F\n+            BERIA_ERFE,               \/\/ 16EA0..16EB8\n+            UNKNOWN,                  \/\/ 16EB9..16EBA\n+            BERIA_ERFE,               \/\/ 16EBB..16ED3\n+            UNKNOWN,                  \/\/ 16ED4..16EFF\n@@ -8637,5 +8766,3 @@\n-            HAN,                      \/\/ 16FF0..16FF1\n-            UNKNOWN,                  \/\/ 16FF2..16FFF\n-            TANGUT,                   \/\/ 17000..187F7\n-            UNKNOWN,                  \/\/ 187F8..187FF\n-            TANGUT,                   \/\/ 18800..18AFF\n+            HAN,                      \/\/ 16FF0..16FF6\n+            UNKNOWN,                  \/\/ 16FF7..16FFF\n+            TANGUT,                   \/\/ 17000..18AFF\n@@ -8645,2 +8772,4 @@\n-            TANGUT,                   \/\/ 18D00..18D08\n-            UNKNOWN,                  \/\/ 18D09..1AFEF\n+            TANGUT,                   \/\/ 18D00..18D1E\n+            UNKNOWN,                  \/\/ 18D1F..18D7F\n+            TANGUT,                   \/\/ 18D80..18DF2\n+            UNKNOWN,                  \/\/ 18DF3..1AFEF\n@@ -8678,2 +8807,2 @@\n-            COMMON,                   \/\/ 1CC00..1CCF9\n-            UNKNOWN,                  \/\/ 1CCFA..1CCFF\n+            COMMON,                   \/\/ 1CC00..1CCFC\n+            UNKNOWN,                  \/\/ 1CCFD..1CCFF\n@@ -8681,1 +8810,5 @@\n-            UNKNOWN,                  \/\/ 1CEB4..1CEFF\n+            UNKNOWN,                  \/\/ 1CEB4..1CEB9\n+            COMMON,                   \/\/ 1CEBA..1CED0\n+            UNKNOWN,                  \/\/ 1CED1..1CEDF\n+            COMMON,                   \/\/ 1CEE0..1CEF0\n+            UNKNOWN,                  \/\/ 1CEF1..1CEFF\n@@ -8796,1 +8929,7 @@\n-            UNKNOWN,                  \/\/ 1E600..1E7DF\n+            UNKNOWN,                  \/\/ 1E600..1E6BF\n+            TAI_YO,                   \/\/ 1E6C0..1E6DE\n+            UNKNOWN,                  \/\/ 1E6DF\n+            TAI_YO,                   \/\/ 1E6E0..1E6F5\n+            UNKNOWN,                  \/\/ 1E6F6..1E6FD\n+            TAI_YO,                   \/\/ 1E6FE..1E6FF\n+            UNKNOWN,                  \/\/ 1E700..1E7DF\n@@ -8913,2 +9052,2 @@\n-            COMMON,                   \/\/ 1F300..1F6D7\n-            UNKNOWN,                  \/\/ 1F6D8..1F6DB\n+            COMMON,                   \/\/ 1F300..1F6D8\n+            UNKNOWN,                  \/\/ 1F6D9..1F6DB\n@@ -8919,3 +9058,1 @@\n-            COMMON,                   \/\/ 1F700..1F776\n-            UNKNOWN,                  \/\/ 1F777..1F77A\n-            COMMON,                   \/\/ 1F77B..1F7D9\n+            COMMON,                   \/\/ 1F700..1F7D9\n@@ -8940,3 +9077,5 @@\n-            UNKNOWN,                  \/\/ 1F8C2..1F8FF\n-            COMMON,                   \/\/ 1F900..1FA53\n-            UNKNOWN,                  \/\/ 1FA54..1FA5F\n+            UNKNOWN,                  \/\/ 1F8C2..1F8CF\n+            COMMON,                   \/\/ 1F8D0..1F8D8\n+            UNKNOWN,                  \/\/ 1F8D9..1F8FF\n+            COMMON,                   \/\/ 1F900..1FA57\n+            UNKNOWN,                  \/\/ 1FA58..1FA5F\n@@ -8947,5 +9086,7 @@\n-            COMMON,                   \/\/ 1FA80..1FA89\n-            UNKNOWN,                  \/\/ 1FA8A..1FA8E\n-            COMMON,                   \/\/ 1FA8F..1FAC6\n-            UNKNOWN,                  \/\/ 1FAC7..1FACD\n-            COMMON,                   \/\/ 1FACE..1FADC\n+            COMMON,                   \/\/ 1FA80..1FA8A\n+            UNKNOWN,                  \/\/ 1FA8B..1FA8D\n+            COMMON,                   \/\/ 1FA8E..1FAC6\n+            UNKNOWN,                  \/\/ 1FAC7\n+            COMMON,                   \/\/ 1FAC8\n+            UNKNOWN,                  \/\/ 1FAC9..1FACC\n+            COMMON,                   \/\/ 1FACD..1FADC\n@@ -8953,3 +9094,3 @@\n-            COMMON,                   \/\/ 1FADF..1FAE9\n-            UNKNOWN,                  \/\/ 1FAEA..1FAEF\n-            COMMON,                   \/\/ 1FAF0..1FAF8\n+            COMMON,                   \/\/ 1FADF..1FAEA\n+            UNKNOWN,                  \/\/ 1FAEB..1FAEE\n+            COMMON,                   \/\/ 1FAEF..1FAF8\n@@ -8959,2 +9100,2 @@\n-            COMMON,                   \/\/ 1FB94..1FBF9\n-            UNKNOWN,                  \/\/ 1FBFA..1FFFF\n+            COMMON,                   \/\/ 1FB94..1FBFA\n+            UNKNOWN,                  \/\/ 1FBFB..1FFFF\n@@ -8963,3 +9104,1 @@\n-            HAN,                      \/\/ 2A700..2B739\n-            UNKNOWN,                  \/\/ 2B73A..2B73F\n-            HAN,                      \/\/ 2B740..2B81D\n+            HAN,                      \/\/ 2A700..2B81D\n@@ -8967,2 +9106,2 @@\n-            HAN,                      \/\/ 2B820..2CEA1\n-            UNKNOWN,                  \/\/ 2CEA2..2CEAF\n+            HAN,                      \/\/ 2B820..2CEAD\n+            UNKNOWN,                  \/\/ 2CEAE..2CEAF\n@@ -8977,2 +9116,2 @@\n-            HAN,                      \/\/ 31350..323AF\n-            UNKNOWN,                  \/\/ 323B0..E0000\n+            HAN,                      \/\/ 31350..33479\n+            UNKNOWN,                  \/\/ 3347A..E0000\n@@ -9002,0 +9141,1 @@\n+            aliases.put(\"BERF\", BERIA_ERFE);\n@@ -9120,0 +9260,1 @@\n+            aliases.put(\"SIDT\", SIDETIC);\n@@ -9137,0 +9278,1 @@\n+            aliases.put(\"TAYO\", TAI_YO);\n@@ -9146,0 +9288,1 @@\n+            aliases.put(\"TOLS\", TOLONG_SIKI);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":301,"deletions":158,"binary":false,"changes":459,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-import static java.lang.String.LATIN1;\n-import static java.lang.String.UTF16;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-import static java.lang.String.LATIN1;\n-import static java.lang.String.UTF16;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2115,2 +2115,2 @@\n-            public Module addEnableNativeAccess(Module m) {\n-                return m.implAddEnableNativeAccess();\n+            public void addEnableNativeAccess(Module m) {\n+                m.implAddEnableNativeAccess();\n@@ -2122,1 +2122,1 @@\n-                Module.implAddEnableNativeAccessToAllUnnamed();\n+                Module.addEnableNativeAccessToAllUnnamed();\n@@ -2127,0 +2127,15 @@\n+            public boolean isStaticallyExported(Module m, String pn, Module other) {\n+                return m.isStaticallyExported(pn, other);\n+            }\n+            public boolean isStaticallyOpened(Module m, String pn, Module other) {\n+                return m.isStaticallyOpened(pn, other);\n+            }\n+            public boolean isFinalMutationEnabled(Module m) {\n+                return m.isFinalMutationEnabled();\n+            }\n+            public boolean tryEnableFinalMutation(Module m) {\n+                return m.tryEnableFinalMutation();\n+            }\n+            public void addEnableFinalMutationToAllUnnamed() {\n+                Module.addEnableFinalMutationToAllUnnamed();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3437,0 +3437,1 @@\n+         * @see <a href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/doc-files\/MutationMethods.html\">Mutation methods<\/a>\n@@ -3443,0 +3444,2 @@\n+            @SuppressWarnings(\"deprecation\")\n+            boolean isAccessible = f.isAccessible();\n@@ -3450,0 +3453,4 @@\n+                \/\/ check if write access to final field allowed\n+                if (!field.isStatic() && isAccessible) {\n+                    SharedSecrets.getJavaLangReflectAccess().checkAllowedToUnreflectFinalSetter(lookupClass, f);\n+                }\n@@ -3454,2 +3461,1 @@\n-            @SuppressWarnings(\"deprecation\")\n-            Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;\n+            Lookup lookup = isAccessible ? IMPL_LOOKUP : this;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -241,2 +241,4 @@\n-        for (Field f : receiverType.getDeclaredFields()) {\n-            if (Modifier.isStatic(f.getModifiers())) continue;\n+        \/\/ The receiver may be a referenced class different from the declaring class\n+        for (var declaringClass = receiverType; declaringClass != null; declaringClass = declaringClass.getSuperclass()) {\n+            for (Field f : declaringClass.getDeclaredFields()) {\n+                if (Modifier.isStatic(f.getModifiers())) continue;\n@@ -244,3 +246,4 @@\n-            if (offset == UNSAFE.objectFieldOffset(f)) {\n-                assert f.getType() == fieldType;\n-                return f;\n+                if (offset == UNSAFE.objectFieldOffset(f)) {\n+                    assert f.getType() == fieldType;\n+                    return f;\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,0 +73,4 @@\n+        \/\/ The parameter arrays are trusted and the same for a root and all leaf\n+        \/\/ copies. Thus, == on arrays is more useful than == on Executable.\n+        if (params1 == params2)\n+            return true;\n@@ -431,1 +435,1 @@\n-            out[i] = new Parameter(\"arg\" + i, 0, this, i);\n+            out[i] = new Parameter(null, 0, this, i);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import java.lang.annotation.Annotation;\n+import java.net.URL;\n+import java.security.CodeSource;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Objects;\n@@ -29,0 +35,5 @@\n+import jdk.internal.event.FinalFieldMutationEvent;\n+import jdk.internal.loader.ClassLoaders;\n+import jdk.internal.misc.VM;\n+import jdk.internal.module.ModuleBootstrap;\n+import jdk.internal.module.Modules;\n@@ -38,4 +49,0 @@\n-import java.lang.annotation.Annotation;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.Objects;\n@@ -168,0 +175,21 @@\n+     * {@inheritDoc}\n+     *\n+     * <p>If this reflected object represents a non-final field, and this method is\n+     * used to enable access, then both <em>{@linkplain #get(Object) read}<\/em>\n+     * and <em>{@linkplain #set(Object, Object) write}<\/em> access to the field\n+     * are enabled.\n+     *\n+     * <p>If this reflected object represents a <em>non-modifiable<\/em> final field\n+     * then enabling access only enables read access. Any attempt to {@linkplain\n+     * #set(Object, Object) set} the field value throws an {@code\n+     * IllegalAccessException}. The following fields are non-modifiable:\n+     * <ul>\n+     * <li>static final fields declared in any class or interface<\/li>\n+     * <li>final fields declared in a {@linkplain Class#isRecord() record}<\/li>\n+     * <li>final fields declared in a {@linkplain Class#isHidden() hidden class}<\/li>\n+     * <\/ul>\n+     * <p>If this reflected object represents a non-static final field in a class that\n+     * is not a record class or hidden class, then enabling access will enable read\n+     * access. Whether write access is allowed or not is checked when attempting to\n+     * {@linkplain #set(Object, Object) set} the field value.\n+     *\n@@ -767,2 +795,4 @@\n-     * <p>If the underlying field is final, this {@code Field} object has\n-     * <em>write<\/em> access if and only if the following conditions are met:\n+     * <p>If the underlying field is final, this {@code Field} object has <em>write<\/em>\n+     * access if and only if all of the following conditions are true, where {@code D} is\n+     * the field's {@linkplain #getDeclaringClass() declaring class}:\n+     *\n@@ -770,9 +800,17 @@\n-     * <li>{@link #setAccessible(boolean) setAccessible(true)} has succeeded for\n-     *     this {@code Field} object;<\/li>\n-     * <li>the field is non-static; and<\/li>\n-     * <li>the field's declaring class is not a {@linkplain Class#isHidden()\n-     *     hidden class};<\/li>\n-     * <li>the field's declaring class is not a {@linkplain Class#isValue()\n-     *     value class}; and<\/li>\n-     * <li>the field's declaring class is not a {@linkplain Class#isRecord()\n-     *     record class}.<\/li>\n+     * <li>{@link #setAccessible(boolean) setAccessible(true)} has succeeded for this\n+     *     {@code Field} object.<\/li>\n+     * <li><a href=\"doc-files\/MutationMethods.html\">final field mutation is enabled<\/a>\n+     *     for the caller's module.<\/li>\n+     * <li> At least one of the following conditions holds:\n+     *     <ol type=\"a\">\n+     *     <li> {@code D} and the caller class are in the same module.<\/li>\n+     *     <li> The field is {@code public} and {@code D} is {@code public} in a package\n+     *     that the module containing {@code D} exports to at least the caller's module.<\/li>\n+     *     <li> {@code D} is in a package that is {@linkplain Module#isOpen(String, Module)\n+     *     open} to the caller's module.<\/li>\n+     *     <\/ol>\n+     * <\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isRecord() record class}.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isHidden() hidden class}.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isValue() value class}.<\/li>\n+     * <li>The field is non-static.<\/li>\n@@ -780,1 +818,31 @@\n-     * If any of the above checks is not met, this method throws an\n+     *\n+     * <p>If any of the above conditions is not met, this method throws an\n+     * {@code IllegalAccessException}.\n+     *\n+     * <p>These conditions are more restrictive than the conditions specified by {@link\n+     * #setAccessible(boolean)} to suppress access checks. In particular, updating a\n+     * module to export or open a package cannot be used to allow <em>write<\/em> access\n+     * to final fields with the {@code set} methods defined by {@code Field}.\n+     * Condition (b) is not met if the module containing {@code D} has been updated with\n+     * {@linkplain Module#addExports(String, Module) addExports} to export the package to\n+     * the caller's module. Condition (c) is not met if the module containing {@code D}\n+     * has been updated with {@linkplain Module#addOpens(String, Module) addOpens} to open\n+     * the package to the caller's module.\n+     *\n+     * <p>This method may be called by <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">\n+     * JNI code<\/a> with no caller class on the stack. In that case, and when the\n+     * underlying field is final, this {@code Field} object has <em>write<\/em> access\n+     * if and only if all of the following conditions are true, where {@code D} is the\n+     * field's {@linkplain #getDeclaringClass() declaring class}:\n+     *\n+     * <ul>\n+     * <li>{@code setAccessible(true)} has succeeded for this {@code Field} object.<\/li>\n+     * <li>final field mutation is enabled for the unnamed module.<\/li>\n+     * <li>The field is {@code public} and {@code D} is {@code public} in a package that\n+     *     is {@linkplain Module#isExported(String) exported} to all modules.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isRecord() record class}.<\/li>\n+     * <li>{@code D} is not a {@linkplain Class#isHidden() hidden class}.<\/li>\n+     * <li>The field is non-static.<\/li>\n+     * <\/ul>\n+     *\n+     * <p>If any of the above conditions is not met, this method throws an\n@@ -825,0 +893,2 @@\n+     *\n+     * @see <a href=\"doc-files\/MutationMethods.html\">Mutation methods<\/a>\n@@ -835,0 +905,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.set(obj, value);\n@@ -836,1 +912,1 @@\n-            getOverrideFieldAccessor().set(obj, value);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.set(obj, value));\n@@ -874,0 +950,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setBoolean(obj, z);\n@@ -875,1 +957,1 @@\n-            getOverrideFieldAccessor().setBoolean(obj, z);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setBoolean(obj, z));\n@@ -913,0 +995,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setByte(obj, b);\n@@ -914,1 +1002,1 @@\n-            getOverrideFieldAccessor().setByte(obj, b);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setByte(obj, b));\n@@ -952,0 +1040,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setChar(obj, c);\n@@ -953,1 +1047,1 @@\n-            getOverrideFieldAccessor().setChar(obj, c);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setChar(obj, c));\n@@ -991,0 +1085,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setShort(obj, s);\n@@ -992,1 +1092,1 @@\n-            getOverrideFieldAccessor().setShort(obj, s);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setShort(obj, s));\n@@ -1030,0 +1130,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setInt(obj, i);\n@@ -1031,1 +1137,1 @@\n-            getOverrideFieldAccessor().setInt(obj, i);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setInt(obj, i));\n@@ -1069,0 +1175,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setLong(obj, l);\n@@ -1070,1 +1182,1 @@\n-            getOverrideFieldAccessor().setLong(obj, l);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setLong(obj, l));\n@@ -1108,0 +1220,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setFloat(obj, f);\n@@ -1109,1 +1227,1 @@\n-            getOverrideFieldAccessor().setFloat(obj, f);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setFloat(obj, f));\n@@ -1147,0 +1265,6 @@\n+            return;\n+        }\n+\n+        FieldAccessor fa = getOverrideFieldAccessor();\n+        if (!Modifier.isFinal(modifiers)) {\n+            fa.setDouble(obj, d);\n@@ -1148,1 +1272,1 @@\n-            getOverrideFieldAccessor().setDouble(obj, d);\n+            setFinal(Reflection.getCallerClass(), obj, () -> fa.setDouble(obj, d));\n@@ -1318,1 +1442,240 @@\n-}\n+    }\n+\n+    \/**\n+     * A function that sets a field to a value.\n+     *\/\n+    @FunctionalInterface\n+    private interface FieldSetter {\n+        void setFieldValue() throws IllegalAccessException;\n+    }\n+\n+    \/**\n+     * Attempts to set a final field.\n+     *\/\n+    private void setFinal(Class<?> caller, Object obj, FieldSetter setter) throws IllegalAccessException {\n+        if (obj != null && isFinalInstanceInNormalClass()) {\n+            preSetFinal(caller, false);\n+            setter.setFieldValue();\n+            postSetFinal(caller, false);\n+        } else {\n+            \/\/ throws IllegalAccessException if static, or field in record or hidden class\n+            setter.setFieldValue();\n+        }\n+    }\n+\n+    \/**\n+     * Return true if this field is a final instance field in a normal class (not a\n+     * record class or hidden class),\n+     *\/\n+    private boolean isFinalInstanceInNormalClass() {\n+        return Modifier.isFinal(modifiers)\n+                && !Modifier.isStatic(modifiers)\n+                && !clazz.isRecord()\n+                && !clazz.isHidden();\n+    }\n+\n+    \/**\n+     * Check that the caller is allowed to unreflect for mutation a final instance field\n+     * in a normal class.\n+     * @throws IllegalAccessException if not allowed\n+     *\/\n+    void checkAllowedToUnreflectFinalSetter(Class<?> caller) throws IllegalAccessException {\n+        Objects.requireNonNull(caller);\n+        preSetFinal(caller, true);\n+        postSetFinal(caller, true);\n+    }\n+\n+    \/**\n+     * Invoke before attempting to mutate, or unreflect for mutation, a final instance\n+     * field in a normal class.\n+     * @throws IllegalAccessException if not allowed\n+     *\/\n+    private void preSetFinal(Class<?> caller, boolean unreflect) throws IllegalAccessException {\n+        assert isFinalInstanceInNormalClass();\n+\n+        if (caller != null) {\n+            \/\/ check if declaring class in package that is open to caller, or public field\n+            \/\/ and declaring class is public in package exported to caller\n+            if (!isFinalDeeplyAccessible(caller)) {\n+                throw new IllegalAccessException(notAccessibleToCallerMessage(caller, unreflect));\n+            }\n+        } else {\n+            \/\/ no java caller, only allowed if field is public in exported package\n+            if (!Reflection.verifyPublicMemberAccess(clazz, modifiers)) {\n+                throw new IllegalAccessException(notAccessibleToNoCallerMessage(unreflect));\n+            }\n+        }\n+\n+        \/\/ check if field mutation is enabled for caller module or illegal final field\n+        \/\/ mutation is allowed\n+        var mode = ModuleBootstrap.illegalFinalFieldMutation();\n+        if (mode == ModuleBootstrap.IllegalFinalFieldMutation.DENY\n+                && !Modules.isFinalMutationEnabled(moduleToCheck(caller))) {\n+            throw new IllegalAccessException(callerNotAllowedToMutateMessage(caller, unreflect));\n+        }\n+    }\n+\n+    \/**\n+     * Invoke after mutating a final instance field, or when unreflecting a final instance\n+     * field for mutation, to print a warning and record a JFR event.\n+     *\/\n+    private void postSetFinal(Class<?> caller, boolean unreflect) {\n+        assert isFinalInstanceInNormalClass();\n+\n+        var mode = ModuleBootstrap.illegalFinalFieldMutation();\n+        if (mode == ModuleBootstrap.IllegalFinalFieldMutation.WARN) {\n+            \/\/ first mutation prints warning\n+            Module moduleToCheck = moduleToCheck(caller);\n+            if (Modules.tryEnableFinalMutation(moduleToCheck)) {\n+                String warningMsg = finalFieldMutationWarning(caller, unreflect);\n+                String targetModule = (caller != null && moduleToCheck.isNamed())\n+                        ? moduleToCheck.getName()\n+                        : \"ALL-UNNAMED\";\n+                VM.initialErr().printf(\"\"\"\n+                        WARNING: %s\n+                        WARNING: Use --enable-final-field-mutation=%s to avoid a warning\n+                        WARNING: Mutating final fields will be blocked in a future release unless final field mutation is enabled\n+                        \"\"\", warningMsg, targetModule);\n+            }\n+        } else if (mode == ModuleBootstrap.IllegalFinalFieldMutation.DEBUG) {\n+            \/\/ print warning and stack trace\n+            var sb = new StringBuilder(finalFieldMutationWarning(caller, unreflect));\n+            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)\n+                    .forEach(sf -> {\n+                        sb.append(System.lineSeparator()).append(\"\\tat \" + sf);\n+                    });\n+            VM.initialErr().println(sb);\n+        }\n+\n+        \/\/ record JFR event\n+        FinalFieldMutationEvent.offer(getDeclaringClass(), getName());\n+    }\n+\n+    \/**\n+     * Returns true if this final field is \"deeply accessible\" to the caller.\n+     * The field is deeply accessible if declaring class is in a package that is open\n+     * to the caller's module, or the field is public in a public class that is exported\n+     * to the caller's module.\n+     *\n+     * Updates to the module of the declaring class at runtime with {@code Module.addExports}\n+     * or {@code Module.addOpens} have no impact on the result of this method.\n+     *\/\n+    private boolean isFinalDeeplyAccessible(Class<?> caller) {\n+        assert isFinalInstanceInNormalClass();\n+\n+        \/\/ all fields in unnamed modules are deeply accessible\n+        Module declaringModule = clazz.getModule();\n+        if (!declaringModule.isNamed()) return true;\n+\n+        \/\/ all fields in the caller's module are deeply accessible\n+        Module callerModule = caller.getModule();\n+        if (callerModule == declaringModule) return true;\n+\n+        \/\/ public field, public class, package exported to caller's module\n+        String pn = clazz.getPackageName();\n+        if (Modifier.isPublic(modifiers)\n+                && Modifier.isPublic(clazz.getModifiers())\n+                && Modules.isStaticallyExported(declaringModule, pn, callerModule)) {\n+            return true;\n+        }\n+\n+        \/\/ package open to caller's module\n+        return Modules.isStaticallyOpened(declaringModule, pn, callerModule);\n+    }\n+\n+    \/**\n+     * Returns the Module to use for access checks with the given caller.\n+     *\/\n+    private Module moduleToCheck(Class<?> caller) {\n+        if (caller != null) {\n+            return caller.getModule();\n+        } else {\n+            \/\/ no java caller, only allowed if field is public in exported package\n+            return ClassLoaders.appClassLoader().getUnnamedModule();\n+        }\n+    }\n+\n+    \/**\n+     * Returns the warning message to print when this final field is mutated by\n+     * the given possibly-null caller.\n+     *\/\n+    private String finalFieldMutationWarning(Class<?> caller, boolean unreflect) {\n+        assert Modifier.isFinal(modifiers);\n+        String source;\n+        if (caller != null) {\n+            source = caller + \" in \" + caller.getModule();\n+            CodeSource cs = caller.getProtectionDomain().getCodeSource();\n+            if (cs != null) {\n+                URL url = cs.getLocation();\n+                if (url != null) {\n+                    source += \" (\" + url + \")\";\n+                }\n+            }\n+        } else {\n+            source = \"JNI attached thread with no caller frame\";\n+        }\n+        return String.format(\"Final field %s in %s has been %s by %s\",\n+                name,\n+                clazz,\n+                (unreflect) ? \"unreflected for mutation\" : \"mutated reflectively\",\n+                source);\n+    }\n+\n+    \/**\n+     * Returns the message for an IllegalAccessException when a final field cannot be\n+     * mutated because the declaring class is in a package that is not \"deeply accessible\"\n+     * to the caller.\n+     *\/\n+    private String notAccessibleToCallerMessage(Class<?> caller, boolean unreflect) {\n+        String exportsOrOpens = Modifier.isPublic(modifiers)\n+                && Modifier.isPublic(clazz.getModifiers()) ? \"exports\" : \"opens\";\n+        return String.format(\"%s, %s does not explicitly \\\"%s\\\" package %s to %s\",\n+                cannotSetFieldMessage(caller, unreflect),\n+                clazz.getModule(),\n+                exportsOrOpens,\n+                clazz.getPackageName(),\n+                caller.getModule());\n+    }\n+\n+    \/**\n+     * Returns the exception message for the IllegalAccessException when this\n+     * final field cannot be mutated because the caller module is not allowed\n+     * to mutate final fields.\n+     *\/\n+    private String callerNotAllowedToMutateMessage(Class<?> caller, boolean unreflect) {\n+        if (caller != null) {\n+            return String.format(\"%s, %s is not allowed to mutate final fields\",\n+                    cannotSetFieldMessage(caller, unreflect),\n+                    caller.getModule());\n+        } else {\n+            return notAccessibleToNoCallerMessage(unreflect);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the message for an IllegalAccessException when a field is not\n+     * accessible to a JNI attached thread.\n+     *\/\n+    private String notAccessibleToNoCallerMessage(boolean unreflect) {\n+        return cannotSetFieldMessage(\"JNI attached thread with no caller frame cannot\", unreflect);\n+    }\n+\n+    \/**\n+     * Returns a message to indicate that the caller cannot set\/unreflect this final field.\n+     *\/\n+    private String cannotSetFieldMessage(Class<?> caller, boolean unreflect) {\n+        return cannotSetFieldMessage(caller + \" (in \" + caller.getModule() + \") cannot\", unreflect);\n+    }\n+\n+    \/**\n+     * Returns a message to indicate that a field cannot be set\/unreflected.\n+     *\/\n+    private String cannotSetFieldMessage(String prefix, boolean unreflect) {\n+        if (unreflect) {\n+            return prefix + \" unreflect final field \" + clazz.getName() + \".\" + name\n+                    + \" (in \" + clazz.getModule() + \") for mutation\";\n+        } else {\n+            return prefix + \" set final field \" + clazz.getName() + \".\" + name\n+                    + \" (in \" + clazz.getModule() + \")\";\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":389,"deletions":26,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,5 @@\n+\n+    @Override\n+    public void checkAllowedToUnreflectFinalSetter(Class<?> caller, Field f) throws IllegalAccessException {\n+        f.checkAllowedToUnreflectFinalSetter(caller);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -780,1 +780,1 @@\n-    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.isUnconditionallyExactTypeBased\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+import java.io.ObjectStreamField;\n+import java.io.Serial;\n@@ -153,0 +155,16 @@\n+    \/**\n+     * For backward compatibility of the serialized {@code LocalDate.class} object,\n+     * explicitly declare the types of the serialized fields as defined in Java SE 8.\n+     * Instances of {@code LocalDate} are serialized using the dedicated\n+     * serialized form by {@code writeReplace}.\n+     * @serialField year int The year.\n+     * @serialField month short The month-of-year.\n+     * @serialField day short The day-of-month.\n+     *\/\n+    @Serial\n+    private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"year\", int.class),\n+            new ObjectStreamField(\"month\", short.class),\n+            new ObjectStreamField(\"day\", short.class)\n+    };\n+\n@@ -189,1 +207,1 @@\n-    private final int year;\n+    private final transient int year;\n@@ -193,1 +211,1 @@\n-    private final short month;\n+    private final transient byte month;\n@@ -197,1 +215,1 @@\n-    private final short day;\n+    private final transient byte day;\n@@ -501,2 +519,2 @@\n-        this.month = (short) month;\n-        this.day = (short) dayOfMonth;\n+        this.month = (byte) month;\n+        this.day = (byte) dayOfMonth;\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+import java.io.ObjectStreamField;\n+import java.io.Serial;\n@@ -144,0 +146,14 @@\n+\n+    \/**\n+     * For backward compatibility of the serialized {@code MonthDay.class} object,\n+     * explicitly declare the types of the serialized fields as defined in Java SE 8.\n+     * Instances of {@code MonthDay} are serialized using the dedicated\n+     * serialized form by {@code writeReplace}.\n+     * @serialField month int The month-of-year.\n+     * @serialField day int The day-of-month.\n+     *\/\n+    @Serial\n+    private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"month\", int.class),\n+            new ObjectStreamField(\"day\", int.class)\n+    };\n@@ -155,1 +171,1 @@\n-     * @serial The month-of-year, not null.\n+     * @serial The month-of-year.\n@@ -157,1 +173,1 @@\n-    private final int month;\n+    private final transient byte month;\n@@ -161,1 +177,1 @@\n-    private final int day;\n+    private final transient byte day;\n@@ -330,2 +346,2 @@\n-        this.month = month;\n-        this.day = dayOfMonth;\n+        this.month = (byte) month;\n+        this.day = (byte) dayOfMonth;\n","filename":"src\/java.base\/share\/classes\/java\/time\/MonthDay.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+import java.io.ObjectStreamField;\n+import java.io.Serial;\n@@ -148,0 +150,14 @@\n+\n+    \/**\n+     * For backward compatibility of the serialized {@code YearMonth.class} object,\n+     * explicitly declare the types of the serialized fields as defined in Java SE 8.\n+     * Instances of {@code YearMonth} are serialized using the dedicated\n+     * serialized form by {@code writeReplace}.\n+     * @serialField year int The year.\n+     * @serialField month int The month-of-year.\n+     *\/\n+    @java.io.Serial\n+    private static final ObjectStreamField[] serialPersistentFields = {\n+            new ObjectStreamField(\"year\", int.class),\n+            new ObjectStreamField(\"month\", int.class),\n+    };\n@@ -160,1 +176,1 @@\n-    private final int year;\n+    private final transient int year;\n@@ -162,1 +178,1 @@\n-     * @serial The month-of-year, not null.\n+     * @serial The month-of-year..\n@@ -164,1 +180,1 @@\n-    private final int month;\n+    private final transient byte month;\n@@ -317,1 +333,1 @@\n-        this.month = month;\n+        this.month = (byte) month;\n","filename":"src\/java.base\/share\/classes\/java\/time\/YearMonth.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-    private final transient int monthOfYear;\n+    private final transient byte monthOfYear;\n@@ -152,1 +152,1 @@\n-    private final transient int dayOfMonth;\n+    private final transient byte dayOfMonth;\n@@ -284,2 +284,2 @@\n-        this.monthOfYear = monthOfYear;\n-        this.dayOfMonth = dayOfMonth;\n+        this.monthOfYear = (byte) monthOfYear;\n+        this.dayOfMonth = (byte) dayOfMonth;\n@@ -298,2 +298,2 @@\n-        this.monthOfYear = dateInfo[1];\n-        this.dayOfMonth = dateInfo[2];\n+        this.monthOfYear = (byte) dateInfo[1];\n+        this.dayOfMonth = (byte) dateInfo[2];\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahDate.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -27,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -80,0 +83,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/util\/Optional.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-     * This method is the same as m1.addReads(m2) but without a permission check.\n+     * This method is the same as m1.addReads(m2) but without a caller check.\n@@ -263,1 +263,1 @@\n-    Module addEnableNativeAccess(Module m);\n+    void addEnableNativeAccess(Module m);\n@@ -266,2 +266,2 @@\n-     * Updates module named {@code name} in layer {@code layer} to allow access to restricted methods.\n-     * Returns true iff the given module exists in the given layer.\n+     * Updates module named {@code name} in layer {@code layer} to allow access to\n+     * restricted methods. Returns true iff the given module exists in the given layer.\n@@ -277,1 +277,2 @@\n-     * Ensure that the given module has native access. If not, warn or throw exception depending on the configuration.\n+     * Ensure that the given module has native access. If not, warn or throw exception\n+     * depending on the configuration.\n@@ -286,0 +287,25 @@\n+    \/**\n+     * Enable code in all unnamed modules to mutate final instance fields.\n+     *\/\n+    void addEnableFinalMutationToAllUnnamed();\n+\n+    \/**\n+     * Enable code in a given module to mutate final instance fields.\n+     *\/\n+    boolean tryEnableFinalMutation(Module m);\n+\n+    \/**\n+     * Return true if code in a given module is allowed to mutate final instance fields.\n+     *\/\n+    boolean isFinalMutationEnabled(Module m);\n+\n+    \/**\n+     * Return true if a given module has statically exported the given package to a given other module.\n+     *\/\n+    boolean isStaticallyExported(Module module, String pn, Module other);\n+\n+    \/**\n+     * Return true if a given module has statically opened the given package to a given other module.\n+     *\/\n+    boolean isStaticallyOpened(Module module, String pn, Module other);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,6 @@\n+\n+    \/**\n+     * Check that the caller is allowed to unreflect for mutation a final instance field\n+     * in a class that is not a record or hidden class.\n+     *\/\n+    void checkAllowedToUnreflectFinalSetter(Class<?> caller, Field f) throws IllegalAccessException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -90,3 +90,4 @@\n-        @JEP(number = 502, title = \"Stable Values\", status = \"Preview\")\n-        STABLE_VALUES,\n-        @JEP(number=470, title=\"PEM Encodings of Cryptographic Objects\", status=\"Preview\")\n+        @JEP(number = 526, title = \"Lazy Constants\", status = \"Second Preview\")\n+        LAZY_CONSTANTS,\n+        @JEP(number=524, title=\"PEM Encodings of Cryptographic Objects\",\n+            status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -267,1 +267,0 @@\n-        java.net.http,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -3988,1 +3989,1 @@\n-    private List<Type> closureMin(List<Type> cl) {\n+    public List<Type> closureMin(List<Type> cl) {\n@@ -5113,2 +5114,3 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n-    \/** Check unconditionality between any combination of reference or primitive types.\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditional Exactness\">\n+    \/** Check type-based unconditional exactness between any combination of\n+     *  reference or primitive types according to JLS 5.7.2.\n@@ -5116,6 +5118,8 @@\n-     *  Rules:\n-     *    an identity conversion\n-     *    a widening reference conversion\n-     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n-     *    a boxing conversion\n-     *    a boxing conversion followed by a widening reference conversion\n+     *  The following are unconditionally exact regardless of the input\n+     *  expression:\n+     *\n+     *    - an identity conversion\n+     *    - a widening reference conversion\n+     *    - an exact widening primitive conversion\n+     *    - a boxing conversion\n+     *    - a boxing conversion followed by a widening reference conversion\n@@ -5126,1 +5130,1 @@\n-    public boolean isUnconditionallyExact(Type source, Type target) {\n+    public boolean isUnconditionallyExactTypeBased(Type source, Type target) {\n@@ -5131,3 +5135,12 @@\n-        return target.isPrimitive()\n-                ? isUnconditionallyExactPrimitives(source, target)\n-                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+        if (target.isPrimitive()) {\n+            if (source.isPrimitive() &&\n+                ((source.getTag().isStrictSubRangeOf(target.getTag())) &&\n+                        !((source.hasTag(BYTE) && target.hasTag(CHAR)) ||\n+                          (source.hasTag(INT) && target.hasTag(FLOAT)) ||\n+                          (source.hasTag(LONG) && (target.hasTag(DOUBLE) || target.hasTag(FLOAT)))))) return true;\n+            else {\n+                return false;\n+            }\n+        } else {\n+            return isSubtype(boxedTypeOrType(erasure(source)), target);\n+        }\n@@ -5136,1 +5149,7 @@\n-    \/** Check unconditionality between primitive types.\n+    \/** Check value-based unconditional exactness between any combination of\n+     *  reference or primitive types for the value of a constant expression\n+     *   according to JLS 5.7.2.\n+     *\n+     *  The following can be unconditionally exact if the source primitive is a\n+     *  constant expression and the conversions is exact for that constant\n+     *  expression:\n@@ -5138,4 +5157,72 @@\n-     *  - widening from one integral type to another,\n-     *  - widening from one floating point type to another,\n-     *  - widening from byte, short, or char to a floating point type,\n-     *  - widening from int to double.\n+     *    - a narrowing primitive conversion\n+     *    - a widening and narrowing primitive conversion\n+     *    - a widening primitive conversion that is not exact\n+     *\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExactValueBased(Type source, Type target) {\n+        if (!(source.constValue() instanceof Number value) || !target.getTag().isNumeric()) return false;\n+\n+        switch (source.getTag()) {\n+            case BYTE:\n+                switch (target.getTag()) {\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case CHAR:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                }\n+                break;\n+            case SHORT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case INT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                    case FLOAT:     return ExactConversionsSupport.isIntToFloatExact(value.intValue());\n+                }\n+                break;\n+            case FLOAT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isFloatToByteExact(value.floatValue());\n+                    case CHAR:      return ExactConversionsSupport.isFloatToCharExact(value.floatValue());\n+                    case SHORT:     return ExactConversionsSupport.isFloatToShortExact(value.floatValue());\n+                    case INT:       return ExactConversionsSupport.isFloatToIntExact(value.floatValue());\n+                    case LONG:      return ExactConversionsSupport.isFloatToLongExact(value.floatValue());\n+                }\n+                break;\n+            case LONG:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isLongToByteExact(value.longValue());\n+                    case CHAR:      return ExactConversionsSupport.isLongToCharExact(value.longValue());\n+                    case SHORT:     return ExactConversionsSupport.isLongToShortExact(value.longValue());\n+                    case INT:       return ExactConversionsSupport.isLongToIntExact(value.longValue());\n+                    case FLOAT:     return ExactConversionsSupport.isLongToFloatExact(value.longValue());\n+                    case DOUBLE:    return ExactConversionsSupport.isLongToDoubleExact(value.longValue());\n+                }\n+                break;\n+            case DOUBLE:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isDoubleToByteExact(value.doubleValue());\n+                    case CHAR:      return ExactConversionsSupport.isDoubleToCharExact(value.doubleValue());\n+                    case SHORT:     return ExactConversionsSupport.isDoubleToShortExact(value.doubleValue());\n+                    case INT:       return ExactConversionsSupport.isDoubleToIntExact(value.doubleValue());\n+                    case FLOAT:     return ExactConversionsSupport.isDoubleToFloatExact(value.doubleValue());\n+                    case LONG:      return ExactConversionsSupport.isDoubleToLongExact(value.doubleValue());\n+                }\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    \/** Check both type or value-based unconditional exactness between any\n+     *  combination of reference or primitive types for the value of a constant\n+     *  expression according to JLS 5.7.2.\n@@ -5143,2 +5230,2 @@\n-     *  @param selectorType     Type of selector\n-     *  @param targetType       Target type\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n@@ -5146,7 +5233,3 @@\n-    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n-        return isSameType(selectorType, targetType) ||\n-                (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n-                ((selectorType.getTag().isStrictSubRangeOf(targetType.getTag())) &&\n-                        !((selectorType.hasTag(BYTE) && targetType.hasTag(CHAR)) ||\n-                          (selectorType.hasTag(INT)  && targetType.hasTag(FLOAT)) ||\n-                          (selectorType.hasTag(LONG) && (targetType.hasTag(DOUBLE) || targetType.hasTag(FLOAT)))));\n+    public boolean isUnconditionallyExactCombined(Type currentType, Type testType) {\n+        return isUnconditionallyExactTypeBased(currentType, testType) ||\n+                (currentType.constValue() instanceof Number && isUnconditionallyExactValueBased(currentType, testType));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":110,"deletions":27,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2247,1 +2247,1 @@\n-                                types.isUnconditionallyExact(seltype, patternType);\n+                                types.isUnconditionallyExactTypeBased(seltype, patternType);\n@@ -4387,0 +4387,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, operand);\n@@ -4477,0 +4478,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, right);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Function;\n@@ -170,0 +169,1 @@\n+        allowPrimitivePatterns = preview.isEnabled() && Feature.PRIMITIVE_PATTERNS.allowedInSource(source);\n@@ -195,0 +195,4 @@\n+    \/** Are primitive patterns allowed\n+     *\/\n+    private final boolean allowPrimitivePatterns;\n+\n@@ -4149,0 +4153,31 @@\n+    \/**\n+     *  Check for bit shifts using an out-of-range bit count.\n+     *  @param pos           Position for error reporting.\n+     *  @param operator      The operator for the expression\n+     *  @param operand       The right hand operand for the expression\n+     *\/\n+    void checkOutOfRangeShift(final DiagnosticPosition pos, Symbol operator, Type operand) {\n+        if (operand.constValue() instanceof Number shiftAmount) {\n+            Type targetType;\n+            int maximumShift;\n+            switch (((OperatorSymbol)operator).opcode) {\n+            case ByteCodes.ishl, ByteCodes.ishr, ByteCodes.iushr, ByteCodes.ishll, ByteCodes.ishrl, ByteCodes.iushrl -> {\n+                targetType = syms.intType;\n+                maximumShift = 0x1f;\n+            }\n+            case ByteCodes.lshl, ByteCodes.lshr, ByteCodes.lushr, ByteCodes.lshll, ByteCodes.lshrl, ByteCodes.lushrl -> {\n+                targetType = syms.longType;\n+                maximumShift = 0x3f;\n+            }\n+            default -> {\n+                return;\n+            }\n+            }\n+            long specifiedShift = shiftAmount.longValue();\n+            if (specifiedShift > maximumShift || specifiedShift < -maximumShift) {\n+                int actualShift = (int)specifiedShift & (maximumShift - 1);\n+                log.warning(pos, LintWarnings.BitShiftOutOfRange(targetType, specifiedShift, actualShift));\n+            }\n+        }\n+    }\n+\n@@ -4841,0 +4876,7 @@\n+\n+                    \/\/ an unconditional pattern cannot be followed by any other label\n+                    if (allowPrimitivePatterns && unconditionalCaseLabel == testCaseLabel && unconditionalCaseLabel != label) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                        continue;\n+                    }\n+\n@@ -4842,5 +4884,5 @@\n-                    if (types.isUnconditionallyExact(currentType, testType) &&\n-                        !currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n-                        \/\/the current label is potentially dominated by the existing (test) label, check:\n-                        if (label instanceof JCConstantCaseLabel) {\n-                            dominated |= !(testCaseLabel instanceof JCConstantCaseLabel) &&\n+                    if (!currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+                        \/\/ the current label is potentially dominated by the existing (test) label, check:\n+                        if (types.isUnconditionallyExactCombined(currentType, testType) &&\n+                                label instanceof JCConstantCaseLabel) {\n+                            dominated = !(testCaseLabel instanceof JCConstantCaseLabel) &&\n@@ -4851,2 +4893,1 @@\n-                            dominated = patternDominated(testPatternCaseLabel.pat,\n-                                                         patternCL.pat);\n+                            dominated = patternDominated(testPatternCaseLabel.pat, patternCL.pat);\n@@ -4855,1 +4896,0 @@\n-\n@@ -4875,1 +4915,1 @@\n-            if (!types.isUnconditionallyExact(currentPatternType, existingPatternType)) {\n+            if (!types.isUnconditionallyExactTypeBased(currentPatternType, existingPatternType)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -2856,1 +2855,1 @@\n-            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+            if (types.isUnconditionallyExactTypeBased(tree.expr.type, tree.pattern.type)) {\n@@ -2865,1 +2864,1 @@\n-                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                if (types.isUnconditionallyExactTypeBased(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1890,8 +1890,11 @@\n-                List<Type> intersection = types.intersect(\n-                        t1.hasTag(ARRAY) ?\n-                                List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n-                                types.erasedSupertypes(t1),\n-                        t2.hasTag(ARRAY) ?\n-                                List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n-                                types.erasedSupertypes(t2));\n-                return intersection.head;\n+                List<Type> result = types.closureMin(\n+                        types.intersect(\n+                            t1.hasTag(ARRAY) ?\n+                                    List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n+                                    types.erasedSupertypes(t1),\n+                            t2.hasTag(ARRAY) ?\n+                                    List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n+                                    types.erasedSupertypes(t2)\n+                        )\n+                );\n+                return result.head;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2475,0 +2475,5 @@\n+# 0: type, 1: long, 2: number\n+# lint: lossy-conversions\n+compiler.warn.bit.shift.out.of.range=\\\n+    shifting {0} by {1} bits is equivalent to shifting by {2} bit(s)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-    Warn about possible lossy conversions in compound assignment.\n+    Warn about possible lossy conversions in compound assignment and bit shift operations.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,2 @@\n- * <tr><th scope=\"row\">{@code lossy-conversions}    <td>possible lossy conversions in compound assignment\n+ * <tr><th scope=\"row\">{@code lossy-conversions}    <td>possible lossy conversions in compound assignments or bit shifts\n+ *                                                      (more than \\u00B131 bits for integers or \\u00B163 bits for longs)\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -617,1 +617,1 @@\n-        in compound assignment.\n+        in compound assignment and bit shift operations.\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,2 +78,0 @@\n-compiler\/c2\/TestVerifyConstraintCasts.java 8355574 generic-all\n-\n@@ -133,1 +131,0 @@\n-runtime\/cds\/DeterministicDump.java 8363986 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *          4802647 7123424 8024709 8193128 8327858 8346307 8368178\n+ *          4802647 7123424 8024709 8193128 8327858 8368178 8346307 8371164\n@@ -224,2 +224,2 @@\n-        testEmptyList(StableValue.list(0, i -> i));\n-        testEmptyList(StableValue.list(3, i -> i).subList(0, 0));\n+        testEmptyList(List.ofLazy(0, i -> i));\n+        testEmptyList(List.ofLazy(3, i -> i).subList(0, 0));\n@@ -228,1 +228,1 @@\n-        testListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n+        testListMutatorsAlwaysThrow(List.ofLazy(0, i -> i));\n@@ -231,2 +231,2 @@\n-        testEmptyListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n-        testEmptyListMutatorsAlwaysThrow(StableValue.list(3, i -> i).subList(0, 0));\n+        testEmptyListMutatorsAlwaysThrow(List.ofLazy(0, i -> i));\n+        testEmptyListMutatorsAlwaysThrow(List.ofLazy(3, i -> i).subList(0, 0));\n@@ -255,3 +255,3 @@\n-                StableValue.list(0, i -> i),\n-                StableValue.list(3, i -> i),\n-                StableValue.list(10, i -> i))) {\n+                List.ofLazy(0, i -> i),\n+                List.ofLazy(3, i -> i),\n+                List.ofLazy(10, i -> i))) {\n@@ -369,3 +369,3 @@\n-        testEmptyMap(StableValue.map(Set.of(), k -> k));\n-        testMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n-        testEmptyMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n+        testEmptyMap(Map.ofLazy(Set.of(), k -> k));\n+        testMapMutatorsAlwaysThrow(Map.ofLazy(Set.of(), k -> k));\n+        testEmptyMapMutatorsAlwaysThrow(Map.ofLazy(Set.of(), k -> k));\n@@ -385,3 +385,3 @@\n-                StableValue.map(Set.<Integer>of(), k -> k),\n-                StableValue.map(Set.of(1), k -> k),\n-                StableValue.map(Set.of(1, 2, 3), k -> k))) {\n+                Map.ofLazy(Set.<Integer>of(), k -> k),\n+                Map.ofLazy(Set.of(1), k -> k),\n+                Map.ofLazy(Set.of(1, 2, 3), k -> k))) {\n@@ -891,0 +891,22 @@\n+    private static void testAddAll(Collection<Integer> c) {\n+        clear(c);\n+\n+        \/\/ Test ArrayList source\n+        ArrayList<Integer> arrayListSource = new ArrayList<>();\n+        arrayListSource.add(42);\n+        arrayListSource.add(99);\n+        check(c.addAll(arrayListSource));\n+        equal(c.size(), arrayListSource.size());\n+        check(c.containsAll(arrayListSource));\n+\n+        clear(c);\n+\n+        \/\/ Test non-ArrayList source\n+        LinkedList<Integer> linkedListSource = new LinkedList<>();\n+        linkedListSource.add(77);\n+        linkedListSource.add(88);\n+        check(c.addAll(linkedListSource));\n+        equal(c.size(), linkedListSource.size());\n+        check(c.containsAll(linkedListSource));\n+    }\n+\n@@ -1298,0 +1320,2 @@\n+        testAddAll(c);\n+\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":39,"deletions":15,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+        if (Platform.isDebugBuild()) {\n+            COMPILATION_TIMEOUT = COMPILATION_TIMEOUT * 2;\n+        }\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}