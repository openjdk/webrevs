{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-include gensrc\/GensrcLocaleData.gmk\n@@ -41,4 +40,0 @@\n-# GensrcLocaleData.gmk does not set TARGETS, so we must choose which targets\n-# to include.\n-TARGETS += $(GENSRC_BASELOCALEDATA)\n-\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2726,4 +2726,0 @@\n-      \/* If we get an out-of-range offset it is a bug in the compiler,\n-         so we assert here. *\/\n-      assert(Address::offset_ok_for_immed(addr.offset(), exact_log2(size_in_memory)),\n-             \"c2 compiler bug\");\n@@ -4119,20 +4115,0 @@\n-operand immI_63()\n-%{\n-  predicate(n->get_int() == 63);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_64()\n-%{\n-  predicate(n->get_int() == 64);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4268,22 +4244,0 @@\n-\/\/ 26 bit signed offset -- for pc-relative branches\n-operand immI26()\n-%{\n-  predicate(((-(1 << 25)) <= n->get_int()) && (n->get_int() < (1 << 25)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ 19 bit signed offset -- for pc-relative loads\n-operand immI19()\n-%{\n-  predicate(((-(1 << 18)) <= n->get_int()) && (n->get_int() < (1 << 18)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4312,21 +4266,0 @@\n-\/\/ 12 bit unsigned offset -- for base plus immediate loads\n-operand immIU12()\n-%{\n-  predicate((0 <= n->get_int()) && (n->get_int() < (1 << 12)));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLU12()\n-%{\n-  predicate((0 <= n->get_long()) && (n->get_long() < (1 << 12)));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4597,11 +4530,0 @@\n-\/\/ 64 bit unit increment\n-operand immL_1()\n-%{\n-  predicate(n->get_long() == 1);\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4619,13 +4541,0 @@\n-\/\/ 32 bit offset of pc in thread anchor\n-\n-operand immL_pc_off()\n-%{\n-  predicate(n->get_long() == in_bytes(JavaThread::frame_anchor_offset()) +\n-                             in_bytes(JavaFrameAnchor::last_Java_pc_offset()));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4720,24 +4629,0 @@\n-\/\/ Pointer Immediate Minus One\n-\/\/ this is used when we want to write the current PC to the thread anchor\n-operand immP_M1()\n-%{\n-  predicate(n->get_ptr() == -1);\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Pointer Immediate Minus Two\n-\/\/ this is used when we want to write the current PC to the thread anchor\n-operand immP_M2()\n-%{\n-  predicate(n->get_ptr() == -2);\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5008,22 +4893,0 @@\n-\/\/ Long 64 bit Register R2 only\n-operand iRegL_R2()\n-%{\n-  constraint(ALLOC_IN_RC(r2_reg));\n-  match(RegL);\n-  match(iRegLNoSp);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Long 64 bit Register R3 only\n-operand iRegL_R3()\n-%{\n-  constraint(ALLOC_IN_RC(r3_reg));\n-  match(RegL);\n-  match(iRegLNoSp);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5041,11 +4904,0 @@\n-\/\/ Pointer 64 bit Register FP only\n-operand iRegP_FP()\n-%{\n-  constraint(ALLOC_IN_RC(fp_reg));\n-  match(RegP);\n-  \/\/ match(iRegP);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5110,27 +4962,0 @@\n-operand iRegN_R0()\n-%{\n-  constraint(ALLOC_IN_RC(r0_reg));\n-  match(iRegN);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand iRegN_R2()\n-%{\n-  constraint(ALLOC_IN_RC(r2_reg));\n-  match(iRegN);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand iRegN_R3()\n-%{\n-  constraint(ALLOC_IN_RC(r3_reg));\n-  match(iRegN);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5287,216 +5112,0 @@\n-operand vRegD_V8()\n-%{\n-  constraint(ALLOC_IN_RC(v8_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V9()\n-%{\n-  constraint(ALLOC_IN_RC(v9_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V10()\n-%{\n-  constraint(ALLOC_IN_RC(v10_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V11()\n-%{\n-  constraint(ALLOC_IN_RC(v11_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V12()\n-%{\n-  constraint(ALLOC_IN_RC(v12_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V13()\n-%{\n-  constraint(ALLOC_IN_RC(v13_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V14()\n-%{\n-  constraint(ALLOC_IN_RC(v14_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V15()\n-%{\n-  constraint(ALLOC_IN_RC(v15_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V16()\n-%{\n-  constraint(ALLOC_IN_RC(v16_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V17()\n-%{\n-  constraint(ALLOC_IN_RC(v17_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V18()\n-%{\n-  constraint(ALLOC_IN_RC(v18_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V19()\n-%{\n-  constraint(ALLOC_IN_RC(v19_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V20()\n-%{\n-  constraint(ALLOC_IN_RC(v20_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V21()\n-%{\n-  constraint(ALLOC_IN_RC(v21_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V22()\n-%{\n-  constraint(ALLOC_IN_RC(v22_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V23()\n-%{\n-  constraint(ALLOC_IN_RC(v23_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V24()\n-%{\n-  constraint(ALLOC_IN_RC(v24_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V25()\n-%{\n-  constraint(ALLOC_IN_RC(v25_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V26()\n-%{\n-  constraint(ALLOC_IN_RC(v26_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V27()\n-%{\n-  constraint(ALLOC_IN_RC(v27_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V28()\n-%{\n-  constraint(ALLOC_IN_RC(v28_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V29()\n-%{\n-  constraint(ALLOC_IN_RC(v29_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V30()\n-%{\n-  constraint(ALLOC_IN_RC(v30_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand vRegD_V31()\n-%{\n-  constraint(ALLOC_IN_RC(v31_reg));\n-  match(RegD);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5604,9 +5213,0 @@\n-operand lr_RegP(iRegP reg)\n-%{\n-  constraint(ALLOC_IN_RC(lr_reg)); \/\/ link_reg\n-  match(reg);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -5687,14 +5287,0 @@\n-operand indOffI(iRegP reg, immIOffset off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n@@ -5771,14 +5357,0 @@\n-operand indOffL(iRegP reg, immLoffset off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n@@ -5961,16 +5533,0 @@\n-\n-\/\/ AArch64 opto stubs need to write to the pc slot in the thread anchor\n-operand thread_anchor_pc(thread_RegP reg, immL_pc_off off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":444,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -399,4 +399,4 @@\n-class Decoder : public RelocActions {\n-  virtual reloc_insn adrpMem() { return &Decoder::adrpMem_impl; }\n-  virtual reloc_insn adrpAdd() { return &Decoder::adrpAdd_impl; }\n-  virtual reloc_insn adrpMovk() { return &Decoder::adrpMovk_impl; }\n+class AArch64Decoder : public RelocActions {\n+  virtual reloc_insn adrpMem() { return &AArch64Decoder::adrpMem_impl; }\n+  virtual reloc_insn adrpAdd() { return &AArch64Decoder::adrpAdd_impl; }\n+  virtual reloc_insn adrpMovk() { return &AArch64Decoder::adrpMovk_impl; }\n@@ -405,1 +405,1 @@\n-  Decoder(address insn_addr, uint32_t insn) : RelocActions(insn_addr, insn) {}\n+  AArch64Decoder(address insn_addr, uint32_t insn) : RelocActions(insn_addr, insn) {}\n@@ -501,1 +501,1 @@\n-  Decoder decoder(insn_addr, insn);\n+  AArch64Decoder decoder(insn_addr, insn);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -973,3 +973,0 @@\n-    \/\/ Load markWord from object into header.\n-    ld(header, oopDesc::mark_offset_in_bytes(), object);\n-\n@@ -984,1 +981,1 @@\n-      lightweight_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+      lightweight_lock(object, header, tmp, slow_case);\n@@ -987,0 +984,2 @@\n+      \/\/ Load markWord from object into header.\n+      ld(header, oopDesc::mark_offset_in_bytes(), object);\n@@ -1118,16 +1117,0 @@\n-      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-      \/\/ must handle it.\n-      Register tmp = current_header;\n-      \/\/ First check for lock-stack underflow.\n-      lwz(tmp, in_bytes(JavaThread::lock_stack_top_offset()), R16_thread);\n-      cmplwi(CCR0, tmp, (unsigned)LockStack::start_offset());\n-      ble(CCR0, slow_case);\n-      \/\/ Then check if the top of the lock-stack matches the unlocked object.\n-      addi(tmp, tmp, -oopSize);\n-      ldx(tmp, tmp, R16_thread);\n-      cmpd(CCR0, tmp, object);\n-      bne(CCR0, slow_case);\n-\n-      ld(header, oopDesc::mark_offset_in_bytes(), object);\n-      andi_(R0, header, markWord::monitor_value);\n-      bne(CCR0, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3602,58 +3602,0 @@\n-operand kReg_K1()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K1));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K2()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K2));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K3()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K3));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K4()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K4));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K5()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K5));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K6()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K6));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K7()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K7));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3737,12 +3679,0 @@\n-operand naxRegI() %{\n-  constraint(ALLOC_IN_RC(nax_reg));\n-  match(RegI);\n-  match(eCXRegI);\n-  match(eDXRegI);\n-  match(eSIRegI);\n-  match(eDIRegI);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -3836,25 +3766,0 @@\n-operand naxRegP() %{\n-  constraint(ALLOC_IN_RC(nax_reg));\n-  match(RegP);\n-  match(eBXRegP);\n-  match(eDXRegP);\n-  match(eCXRegP);\n-  match(eSIRegP);\n-  match(eDIRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand nabxRegP() %{\n-  constraint(ALLOC_IN_RC(nabx_reg));\n-  match(RegP);\n-  match(eCXRegP);\n-  match(eDXRegP);\n-  match(eSIRegP);\n-  match(eDIRegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2138,22 +2138,0 @@\n-\/\/ Constant for long shifts\n-operand immI_32()\n-%{\n-  predicate( n->get_int() == 32 );\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Constant for long shifts\n-operand immI_64()\n-%{\n-  predicate( n->get_int() == 64 );\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2314,22 +2292,0 @@\n-\/\/ Long Immediate: the value 10\n-operand immL10()\n-%{\n-  predicate(n->get_long() == 10);\n-  match(ConL);\n-\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-\/\/ Long immediate from 0 to 127.\n-\/\/ Used for a shorter form of long mul by 10.\n-operand immL_127()\n-%{\n-  predicate(0 <= n->get_long() && n->get_long() < 0x80);\n-  match(ConL);\n-\n-  op_cost(10);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -2470,58 +2426,0 @@\n-operand kReg_K1()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K1));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K2()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K2));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K3()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K3));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K4()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K4));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K5()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K5));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-operand kReg_K6()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K6));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n-\/\/ Special Registers\n-operand kReg_K7()\n-%{\n-  constraint(ALLOC_IN_RC(vectmask_reg_K7));\n-  match(RegVectMask);\n-  format %{%}\n-  interface(REG_INTER);\n-%}\n-\n@@ -2675,12 +2573,0 @@\n-operand no_rax_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_no_rax_reg));\n-  match(RegP);\n-  match(rbx_RegP);\n-  match(rsi_RegP);\n-  match(rdi_RegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -2695,11 +2581,0 @@\n-  match(rdi_RegP);\n-\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand no_rax_rbx_RegP()\n-%{\n-  constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));\n-  match(RegP);\n-  match(rsi_RegP);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":125,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-  product(bool, TimeLinearScan, false,                                      \\\n+  develop(bool, TimeLinearScan, false,                                      \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-  _failure_reason = nullptr;\n@@ -254,1 +253,0 @@\n-  _failure_reason = nullptr;\n@@ -1242,1 +1240,1 @@\n-  if (_failure_reason == nullptr) {\n+  if (_failure_reason.get() == nullptr) {\n@@ -1244,1 +1242,1 @@\n-    _failure_reason = reason;\n+    _failure_reason.set(reason);\n@@ -1274,1 +1272,1 @@\n-    _failure_reason = nullptr;\n+    _failure_reason.clear();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/cHeapStringHolder.hpp\"\n@@ -60,1 +61,1 @@\n-  const char*      _failure_reason;\n+  CHeapStringHolder _failure_reason;\n@@ -326,1 +327,1 @@\n-  bool failing() const { return _failure_reason != nullptr; }\n+  bool failing() const { return _failure_reason.get() != nullptr; }\n@@ -329,1 +330,1 @@\n-  const char* failure_reason() const { return _failure_reason; }\n+  const char* failure_reason() const { return _failure_reason.get(); }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2331,1 +2331,3 @@\n-      failure_reason = ci_env.failure_reason();\n+      \/\/ Duplicate the failure reason string, so that it outlives ciEnv\n+      failure_reason = os::strdup(ci_env.failure_reason(), mtCompiler);\n+      failure_reason_on_C_heap = true;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-    \/\/ Keep this code in sync with new_deferred_store_barrier() in runtime.cpp.\n+    \/\/ Keep this code in sync with CardTableBarrierSet::on_slowpath_allocation_exit.\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,2 +116,2 @@\n-size_t G1ParScanThreadState::flush_stats(size_t* surviving_young_words, uint num_workers) {\n-  _rdc_local_qset.flush();\n+size_t G1ParScanThreadState::flush_stats(size_t* surviving_young_words, uint num_workers, BufferNodeList* rdc_buffers) {\n+  *rdc_buffers = _rdc_local_qset.flush();\n@@ -124,1 +124,1 @@\n-     _g1h->gc_tracer_stw()->report_evacuation_failed(_evacuation_failed_info);\n+    _g1h->gc_tracer_stw()->report_evacuation_failed(_evacuation_failed_info);\n@@ -597,1 +597,0 @@\n-\n@@ -608,1 +607,1 @@\n-    size_t copied_bytes = pss->flush_stats(_surviving_young_words_total, _num_workers) * HeapWordSize;\n+    size_t copied_bytes = pss->flush_stats(_surviving_young_words_total, _num_workers, &_rdc_buffers[worker_id]) * HeapWordSize;\n@@ -619,0 +618,5 @@\n+\n+  G1DirtyCardQueueSet& dcq = G1BarrierSet::dirty_card_queue_set();\n+  dcq.merge_bufferlists(rdcqs());\n+  rdcqs()->verify_empty();\n+\n@@ -710,0 +714,1 @@\n+    _rdc_buffers(NEW_C_HEAP_ARRAY(BufferNodeList, num_workers, mtGC)),\n@@ -717,0 +722,1 @@\n+    _rdc_buffers[i] = BufferNodeList();\n@@ -725,0 +731,1 @@\n+  FREE_C_HEAP_ARRAY(BufferNodeList, _rdc_buffers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -531,29 +531,0 @@\n-void ParallelCompactData::add_obj(HeapWord* addr, size_t len)\n-{\n-  const size_t obj_ofs = pointer_delta(addr, _heap_start);\n-  const size_t beg_region = obj_ofs >> Log2RegionSize;\n-  \/\/ end_region is inclusive\n-  const size_t end_region = (obj_ofs + len - 1) >> Log2RegionSize;\n-\n-  if (beg_region == end_region) {\n-    \/\/ All in one region.\n-    _region_data[beg_region].add_live_obj(len);\n-    return;\n-  }\n-\n-  \/\/ First region.\n-  const size_t beg_ofs = region_offset(addr);\n-  _region_data[beg_region].add_live_obj(RegionSize - beg_ofs);\n-\n-  \/\/ Middle regions--completely spanned by this object.\n-  for (size_t region = beg_region + 1; region < end_region; ++region) {\n-    _region_data[region].set_partial_obj_size(RegionSize);\n-    _region_data[region].set_partial_obj_addr(addr);\n-  }\n-\n-  \/\/ Last region.\n-  const size_t end_ofs = region_offset(addr + len - 1);\n-  _region_data[end_region].set_partial_obj_size(end_ofs + 1);\n-  _region_data[end_region].set_partial_obj_addr(addr);\n-}\n-\n@@ -866,1 +837,1 @@\n-bool PSParallelCompact::initialize() {\n+bool PSParallelCompact::initialize_aux_data() {\n@@ -869,5 +840,1 @@\n-\n-  \/\/ Was the old gen get allocated successfully?\n-  if (!heap->old_gen()->is_allocated()) {\n-    return false;\n-  }\n+  assert(mr.byte_size() != 0, \"heap should be reserved\");\n@@ -1052,136 +1019,0 @@\n-HeapWord*\n-PSParallelCompact::compute_dense_prefix_via_density(const SpaceId id,\n-                                                    bool maximum_compaction)\n-{\n-  const size_t region_size = ParallelCompactData::RegionSize;\n-  const ParallelCompactData& sd = summary_data();\n-\n-  const MutableSpace* const space = _space_info[id].space();\n-  HeapWord* const top_aligned_up = sd.region_align_up(space->top());\n-  const RegionData* const beg_cp = sd.addr_to_region_ptr(space->bottom());\n-  const RegionData* const end_cp = sd.addr_to_region_ptr(top_aligned_up);\n-\n-  \/\/ Skip full regions at the beginning of the space--they are necessarily part\n-  \/\/ of the dense prefix.\n-  size_t full_count = 0;\n-  const RegionData* cp;\n-  for (cp = beg_cp; cp < end_cp && cp->data_size() == region_size; ++cp) {\n-    ++full_count;\n-  }\n-\n-  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n-  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n-  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n-  const bool interval_ended = gcs_since_max > HeapMaximumCompactionInterval;\n-  if (maximum_compaction || cp == end_cp || interval_ended) {\n-    _maximum_compaction_gc_num = total_invocations;\n-    return sd.region_to_addr(cp);\n-  }\n-\n-  HeapWord* const new_top = _space_info[id].new_top();\n-  const size_t space_live = pointer_delta(new_top, space->bottom());\n-  const size_t space_used = space->used_in_words();\n-  const size_t space_capacity = space->capacity_in_words();\n-\n-  const double cur_density = double(space_live) \/ space_capacity;\n-  const double deadwood_density =\n-    (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;\n-  const size_t deadwood_goal = size_t(space_capacity * deadwood_density);\n-\n-  log_develop_debug(gc, compaction)(\n-      \"cur_dens=%5.3f dw_dens=%5.3f dw_goal=\" SIZE_FORMAT,\n-      cur_density, deadwood_density, deadwood_goal);\n-  log_develop_debug(gc, compaction)(\n-      \"space_live=\" SIZE_FORMAT \" space_used=\" SIZE_FORMAT \" \"\n-      \"space_cap=\" SIZE_FORMAT,\n-      space_live, space_used,\n-      space_capacity);\n-\n-  \/\/ XXX - Use binary search?\n-  HeapWord* dense_prefix = sd.region_to_addr(cp);\n-  const RegionData* full_cp = cp;\n-  const RegionData* const top_cp = sd.addr_to_region_ptr(space->top() - 1);\n-  while (cp < end_cp) {\n-    HeapWord* region_destination = cp->destination();\n-    const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);\n-\n-    log_develop_trace(gc, compaction)(\n-        \"c#=\" SIZE_FORMAT_W(4) \" dst=\" PTR_FORMAT \" \"\n-        \"dp=\" PTR_FORMAT \" cdw=\" SIZE_FORMAT_W(8),\n-        sd.region(cp), p2i(region_destination),\n-        p2i(dense_prefix), cur_deadwood);\n-\n-    if (cur_deadwood >= deadwood_goal) {\n-      \/\/ Found the region that has the correct amount of deadwood to the left.\n-      \/\/ This typically occurs after crossing a fairly sparse set of regions, so\n-      \/\/ iterate backwards over those sparse regions, looking for the region\n-      \/\/ that has the lowest density of live objects 'to the right.'\n-      size_t space_to_left = sd.region(cp) * region_size;\n-      size_t live_to_left = space_to_left - cur_deadwood;\n-      size_t space_to_right = space_capacity - space_to_left;\n-      size_t live_to_right = space_live - live_to_left;\n-      double density_to_right = double(live_to_right) \/ space_to_right;\n-      while (cp > full_cp) {\n-        --cp;\n-        const size_t prev_region_live_to_right = live_to_right -\n-          cp->data_size();\n-        const size_t prev_region_space_to_right = space_to_right + region_size;\n-        double prev_region_density_to_right =\n-          double(prev_region_live_to_right) \/ prev_region_space_to_right;\n-        if (density_to_right <= prev_region_density_to_right) {\n-          return dense_prefix;\n-        }\n-\n-        log_develop_trace(gc, compaction)(\n-            \"backing up from c=\" SIZE_FORMAT_W(4) \" d2r=%10.8f \"\n-            \"pc_d2r=%10.8f\",\n-            sd.region(cp), density_to_right,\n-            prev_region_density_to_right);\n-\n-        dense_prefix -= region_size;\n-        live_to_right = prev_region_live_to_right;\n-        space_to_right = prev_region_space_to_right;\n-        density_to_right = prev_region_density_to_right;\n-      }\n-      return dense_prefix;\n-    }\n-\n-    dense_prefix += region_size;\n-    ++cp;\n-  }\n-\n-  return dense_prefix;\n-}\n-\n-#ifndef PRODUCT\n-void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,\n-                                                 const SpaceId id,\n-                                                 const bool maximum_compaction,\n-                                                 HeapWord* const addr)\n-{\n-  const size_t region_idx = summary_data().addr_to_region_idx(addr);\n-  RegionData* const cp = summary_data().region(region_idx);\n-  const MutableSpace* const space = _space_info[id].space();\n-  HeapWord* const new_top = _space_info[id].new_top();\n-\n-  const size_t space_live = pointer_delta(new_top, space->bottom());\n-  const size_t dead_to_left = pointer_delta(addr, cp->destination());\n-  const size_t space_cap = space->capacity_in_words();\n-  const double dead_to_left_pct = double(dead_to_left) \/ space_cap;\n-  const size_t live_to_right = new_top - cp->destination();\n-  const size_t dead_to_right = space->top() - addr - live_to_right;\n-\n-  log_develop_debug(gc, compaction)(\n-      \"%s=\" PTR_FORMAT \" dpc=\" SIZE_FORMAT_W(5) \" \"\n-      \"spl=\" SIZE_FORMAT \" \"\n-      \"d2l=\" SIZE_FORMAT \" d2l%%=%6.4f \"\n-      \"d2r=\" SIZE_FORMAT \" l2r=\" SIZE_FORMAT \" \"\n-      \"ratio=%10.8f\",\n-      algorithm, p2i(addr), region_idx,\n-      space_live,\n-      dead_to_left, dead_to_left_pct,\n-      dead_to_right, live_to_right,\n-      double(dead_to_right) \/ live_to_right);\n-}\n-#endif  \/\/ #ifndef PRODUCT\n-\n@@ -1436,2 +1267,11 @@\n-void PSParallelCompact::fill_dense_prefix_end(SpaceId id)\n-{\n+void PSParallelCompact::fill_dense_prefix_end(SpaceId id) {\n+  \/\/ Since both markword and klass takes 1 heap word, the min-obj-size is 2\n+  \/\/ heap words.\n+  \/\/ If min-fill-size decreases to 1, this whole method becomes redundant.\n+  assert(CollectedHeap::min_fill_size() == 2, \"inv\");\n+#ifndef _LP64\n+  \/\/ In 32-bit system, min-obj-alignment is >= 8 bytes, so the gap (if any)\n+  \/\/ right before denses-prefix must be greater than min-fill-size; nothing to\n+  \/\/ do.\n+  return;\n+#endif\n@@ -1439,55 +1279,2 @@\n-  const RegionData* region = _summary_data.addr_to_region_ptr(dense_prefix_end);\n-  const idx_t dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);\n-  if (dead_space_crosses_boundary(region, dense_prefix_bit)) {\n-    \/\/ Only enough dead space is filled so that any remaining dead space to the\n-    \/\/ left is larger than the minimum filler object.  (The remainder is filled\n-    \/\/ during the copy\/update phase.)\n-    \/\/\n-    \/\/ The size of the dead space to the right of the boundary is not a\n-    \/\/ concern, since compaction will be able to use whatever space is\n-    \/\/ available.\n-    \/\/\n-    \/\/ Here '||' is the boundary, 'x' represents a don't care bit and a box\n-    \/\/ surrounds the space to be filled with an object.\n-    \/\/\n-    \/\/ In the 32-bit VM, each bit represents two 32-bit words:\n-    \/\/                              +---+\n-    \/\/ a) beg_bits:  ...  x   x   x | 0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  x   x   x | 0 | ||   0   x  x  ...\n-    \/\/                              +---+\n-    \/\/\n-    \/\/ In the 64-bit VM, each bit represents one 64-bit word:\n-    \/\/                              +------------+\n-    \/\/ b) beg_bits:  ...  x   x   x | 0   ||   0 | x  x  ...\n-    \/\/    end_bits:  ...  x   x   1 | 0   ||   0 | x  x  ...\n-    \/\/                              +------------+\n-    \/\/                          +-------+\n-    \/\/ c) beg_bits:  ...  x   x | 0   0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  x   1 | 0   0 | ||   0   x  x  ...\n-    \/\/                          +-------+\n-    \/\/                      +-----------+\n-    \/\/ d) beg_bits:  ...  x | 0   0   0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  1 | 0   0   0 | ||   0   x  x  ...\n-    \/\/                      +-----------+\n-    \/\/                          +-------+\n-    \/\/ e) beg_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...\n-    \/\/    end_bits:  ...  0   0 | 0   0 | ||   0   x  x  ...\n-    \/\/                          +-------+\n-\n-    \/\/ Initially assume case a, c or e will apply.\n-    size_t obj_len = CollectedHeap::min_fill_size();\n-    HeapWord* obj_beg = dense_prefix_end - obj_len;\n-\n-#ifdef  _LP64\n-    if (MinObjAlignment > 1) { \/\/ object alignment > heap word size\n-      \/\/ Cases a, c or e.\n-    } else if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {\n-      \/\/ Case b above.\n-      obj_beg = dense_prefix_end - 1;\n-    } else if (!_mark_bitmap.is_obj_end(dense_prefix_bit - 3) &&\n-               _mark_bitmap.is_obj_end(dense_prefix_bit - 4)) {\n-      \/\/ Case d above.\n-      obj_beg = dense_prefix_end - 3;\n-      obj_len = 3;\n-    }\n-#endif  \/\/ #ifdef _LP64\n+  RegionData* const region_after_dense_prefix = _summary_data.addr_to_region_ptr(dense_prefix_end);\n+  idx_t const dense_prefix_bit = _mark_bitmap.addr_to_bit(dense_prefix_end);\n@@ -1495,0 +1282,11 @@\n+  if (region_after_dense_prefix->partial_obj_size() != 0 ||\n+      _mark_bitmap.is_obj_beg(dense_prefix_bit)) {\n+    \/\/ The region after the dense prefix starts with live bytes.\n+    return;\n+  }\n+\n+  if (_mark_bitmap.is_obj_end(dense_prefix_bit - 2)) {\n+    \/\/ There is exactly one heap word gap right before the dense prefix end, so we need a filler object.\n+    \/\/ The filler object will extend into the region after the last dense prefix region.\n+    const size_t obj_len = 2; \/\/ min-fill-size\n+    HeapWord* const obj_beg = dense_prefix_end - 1;\n@@ -1497,1 +1295,2 @@\n-    _summary_data.add_obj(obj_beg, obj_len);\n+    _summary_data.addr_to_region_ptr(obj_beg)->add_live_obj(1);\n+    region_after_dense_prefix->set_partial_obj_size(1);\n@@ -1515,9 +1314,0 @@\n-#ifndef PRODUCT\n-    if (log_is_enabled(Debug, gc, compaction)) {\n-      print_dense_prefix_stats(\"ratio\", id, maximum_compaction,\n-                               dense_prefix_end);\n-      HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);\n-      print_dense_prefix_stats(\"density\", id, maximum_compaction, addr);\n-    }\n-#endif  \/\/ #ifndef PRODUCT\n-\n@@ -2555,1 +2345,0 @@\n-  _start_array->update_for_block(addr, addr + cast_to_oop(addr)->size());\n@@ -2580,0 +2369,1 @@\n+  HeapWord* const space_bottom = space(space_id)->bottom();\n@@ -2581,1 +2371,2 @@\n-  if (beg_addr != space(space_id)->bottom()) {\n+  \/\/ Check if it's the first region in this space.\n+  if (beg_addr != space_bottom) {\n@@ -2593,2 +2384,5 @@\n-    } else if (dead_space_crosses_boundary(cp, mbm->addr_to_bit(beg_addr))) {\n-      beg_addr = mbm->find_obj_beg(beg_addr, end_addr);\n+    } else {\n+      idx_t beg_bit = mbm->addr_to_bit(beg_addr);\n+      if (!mbm->is_obj_beg(beg_bit) && !mbm->is_obj_end(beg_bit - 1)) {\n+        beg_addr = mbm->find_obj_beg(beg_addr, end_addr);\n+      }\n@@ -2605,6 +2399,1 @@\n-    ParMarkBitMap::IterationStatus status;\n-    status = mbm->iterate(&update_closure, &fill_closure, beg_addr, end_addr,\n-                          dense_prefix_end);\n-    if (status == ParMarkBitMap::incomplete) {\n-      update_closure.do_addr(update_closure.source());\n-    }\n+    mbm->iterate(&update_closure, &fill_closure, beg_addr, end_addr, dense_prefix_end);\n@@ -2921,19 +2710,0 @@\n-    if (status == ParMarkBitMap::incomplete) {\n-      \/\/ The last obj that starts in the source region does not end in the\n-      \/\/ region.\n-      assert(closure.source() < end_addr, \"sanity\");\n-      HeapWord* const obj_beg = closure.source();\n-      HeapWord* const range_end = MIN2(obj_beg + closure.words_remaining(),\n-                                       src_space_top);\n-      HeapWord* const obj_end = bitmap->find_obj_end(obj_beg, range_end);\n-      if (obj_end < range_end) {\n-        \/\/ The end was found; the entire object will fit.\n-        status = closure.do_addr(obj_beg, bitmap->obj_size(obj_beg, obj_end));\n-        assert(status != ParMarkBitMap::would_overflow, \"sanity\");\n-      } else {\n-        \/\/ The end was not found; the object will not fit.\n-        assert(range_end < src_space_top, \"obj cannot cross space boundary\");\n-        status = ParMarkBitMap::would_overflow;\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":37,"deletions":267,"binary":false,"changes":304,"status":"modified"},{"patch":"@@ -656,1 +656,0 @@\n-                  _failure_reason(nullptr),\n@@ -957,1 +956,0 @@\n-    _failure_reason(nullptr),\n@@ -4916,1 +4914,1 @@\n-  if (_failure_reason == nullptr) {\n+  if (_failure_reason.get() == nullptr) {\n@@ -4918,1 +4916,1 @@\n-    _failure_reason = reason;\n+    _failure_reason.set(reason);\n@@ -5410,0 +5408,1 @@\n+        \/\/  - it is OSR locking region (no Lock node)\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/cHeapStringHolder.hpp\"\n@@ -372,1 +373,1 @@\n-  const char*           _failure_reason;        \/\/ for record_failure\/failing pattern\n+  CHeapStringHolder     _failure_reason;        \/\/ for record_failure\/failing pattern\n@@ -840,2 +841,11 @@\n-  bool        failing() const        { return _env->failing() || _failure_reason != nullptr; }\n-  const char* failure_reason() const { return (_env->failing()) ? _env->failure_reason() : _failure_reason; }\n+\n+  bool        failing() const        {\n+    return _env->failing() ||\n+           _failure_reason.get() != nullptr;\n+  }\n+\n+  const char* failure_reason() const {\n+    return _env->failing() ? _env->failure_reason()\n+                           : _failure_reason.get();\n+  }\n+\n@@ -845,1 +855,4 @@\n-    return (r == _failure_reason) || (r != nullptr && _failure_reason != nullptr && strcmp(r, _failure_reason) == 0);\n+    return (r == _failure_reason.get()) ||\n+           (r != nullptr &&\n+            _failure_reason.get() != nullptr &&\n+            strcmp(r, _failure_reason.get()) == 0);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1034,1 +1034,1 @@\n-        if (failtype->_lo > failtype->_hi) {\n+        if (failtype->empty()) {\n@@ -1042,2 +1042,1 @@\n-    lo = nullptr;\n-    hi = nullptr;\n+    return false;\n@@ -1046,7 +1045,25 @@\n-  if (lo && hi) {\n-    Node* hook = new Node(1);\n-    hook->init_req(0, lo); \/\/ Add a use to lo to prevent him from dying\n-    \/\/ Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))\n-    Node* adjusted_val = igvn->transform(new SubINode(n,  lo));\n-    if (adjusted_lim == nullptr) {\n-      adjusted_lim = igvn->transform(new SubINode(hi, lo));\n+  assert(lo != nullptr && hi != nullptr, \"sanity\");\n+  Node* hook = new Node(lo); \/\/ Add a use to lo to prevent him from dying\n+  \/\/ Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))\n+  Node* adjusted_val = igvn->transform(new SubINode(n,  lo));\n+  if (adjusted_lim == nullptr) {\n+    adjusted_lim = igvn->transform(new SubINode(hi, lo));\n+  }\n+  hook->destruct(igvn);\n+\n+  if (igvn->type(adjusted_lim)->is_int()->_lo < 0 &&\n+      !igvn->C->post_loop_opts_phase()) {\n+    \/\/ If range check elimination applies to this comparison, it includes code to protect from overflows that may\n+    \/\/ cause the main loop to be skipped entirely. Delay this transformation.\n+    \/\/ Example:\n+    \/\/ for (int i = 0; i < limit; i++) {\n+    \/\/   if (i < max_jint && i > min_jint) {...\n+    \/\/ }\n+    \/\/ Comparisons folded as:\n+    \/\/ i - min_jint - 1 <u -2\n+    \/\/ when RC applies, main loop limit becomes:\n+    \/\/ min(limit, max(-2 + min_jint + 1, min_jint))\n+    \/\/ = min(limit, min_jint)\n+    \/\/ = min_jint\n+    if (adjusted_val->outcnt() == 0) {\n+      igvn->remove_dead_node(adjusted_val);\n@@ -1054,26 +1071,2 @@\n-    hook->destruct(igvn);\n-\n-    int lo = igvn->type(adjusted_lim)->is_int()->_lo;\n-    if (lo < 0) {\n-      \/\/ If range check elimination applies to this comparison, it includes code to protect from overflows that may\n-      \/\/ cause the main loop to be skipped entirely. Delay this transformation.\n-      \/\/ Example:\n-      \/\/ for (int i = 0; i < limit; i++) {\n-      \/\/   if (i < max_jint && i > min_jint) {...\n-      \/\/ }\n-      \/\/ Comparisons folded as:\n-      \/\/ i - min_jint - 1 <u -2\n-      \/\/ when RC applies, main loop limit becomes:\n-      \/\/ min(limit, max(-2 + min_jint + 1, min_jint))\n-      \/\/ = min(limit, min_jint)\n-      \/\/ = min_jint\n-      if (!igvn->C->post_loop_opts_phase()) {\n-        if (adjusted_val->outcnt() == 0) {\n-          igvn->remove_dead_node(adjusted_val);\n-        }\n-        if (adjusted_lim->outcnt() == 0) {\n-          igvn->remove_dead_node(adjusted_lim);\n-        }\n-        igvn->C->record_for_post_loop_opts_igvn(this);\n-        return false;\n-      }\n+    if (adjusted_lim->outcnt() == 0) {\n+      igvn->remove_dead_node(adjusted_lim);\n@@ -1081,0 +1074,3 @@\n+    igvn->C->record_for_post_loop_opts_igvn(this);\n+    return false;\n+  }\n@@ -1082,2 +1078,2 @@\n-    Node* newcmp = igvn->transform(new CmpUNode(adjusted_val, adjusted_lim));\n-    Node* newbool = igvn->transform(new BoolNode(newcmp, cond));\n+  Node* newcmp = igvn->transform(new CmpUNode(adjusted_val, adjusted_lim));\n+  Node* newbool = igvn->transform(new BoolNode(newcmp, cond));\n@@ -1085,2 +1081,2 @@\n-    igvn->replace_input_of(dom_iff, 1, igvn->intcon(proj->_con));\n-    igvn->replace_input_of(this, 1, newbool);\n+  igvn->replace_input_of(dom_iff, 1, igvn->intcon(proj->_con));\n+  igvn->replace_input_of(this, 1, newbool);\n@@ -1088,3 +1084,1 @@\n-    return true;\n-  }\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":37,"deletions":43,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    Node *box = new BoxLockNode(next_monitor());\n+    BoxLockNode* osr_box = new BoxLockNode(next_monitor());\n@@ -242,1 +242,11 @@\n-    box = _gvn.transform(box);\n+\n+    \/\/ This OSR locking region is unbalanced because it does not have Lock node:\n+    \/\/ locking was done in Interpreter.\n+    \/\/ This is similar to Coarsened case when Lock node is eliminated\n+    \/\/ and as result the region is marked as Unbalanced.\n+\n+    \/\/ Emulate Coarsened state transition from Regular to Unbalanced.\n+    osr_box->set_coarsened();\n+    osr_box->set_unbalanced();\n+\n+    Node* box = _gvn.transform(osr_box);\n@@ -1925,1 +1935,1 @@\n-              \/\/ BoxLock nodes are not commoning.\n+              \/\/ BoxLock nodes are not commoning when EliminateNestedLocks is on.\n@@ -1930,0 +1940,13 @@\n+              BoxLockNode* old_box = m->as_BoxLock();\n+              if (n->as_BoxLock()->is_unbalanced() && !old_box->is_unbalanced()) {\n+                \/\/ Preserve Unbalanced status.\n+                \/\/\n+                \/\/ `old_box` can have only Regular or Coarsened status\n+                \/\/ because this code is executed only during Parse phase and\n+                \/\/ Incremental Inlining before EA and Macro nodes elimination.\n+                \/\/\n+                \/\/ Incremental Inlining is executed after IGVN optimizations\n+                \/\/ during which BoxLock can be marked as Coarsened.\n+                old_box->set_coarsened(); \/\/ Verifies state\n+                old_box->set_unbalanced();\n+              }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -511,10 +511,0 @@\n-  { \"G1ConcRefinementGreenZone\",    JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n-  { \"G1ConcRefinementYellowZone\",   JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n-  { \"G1ConcRefinementRedZone\",      JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n-  { \"G1ConcRefinementThresholdStep\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n-  { \"G1UseAdaptiveConcRefinement\",  JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n-  { \"G1ConcRefinementServiceIntervalMillis\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n-\n-  { \"G1ConcRSLogCacheSize\",         JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n-  { \"G1ConcRSHotCardLimit\",         JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n-  { \"RefDiscoveryPolicy\",           JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::undefined() },\n@@ -523,0 +513,11 @@\n+  { \"G1ConcRefinementGreenZone\",    JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(24) },\n+  { \"G1ConcRefinementYellowZone\",   JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(24) },\n+  { \"G1ConcRefinementRedZone\",      JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(24) },\n+  { \"G1ConcRefinementThresholdStep\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(24) },\n+  { \"G1UseAdaptiveConcRefinement\",  JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(24) },\n+  { \"G1ConcRefinementServiceIntervalMillis\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(24) },\n+\n+  { \"G1ConcRSLogCacheSize\",         JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::jdk(24) },\n+  { \"G1ConcRSHotCardLimit\",         JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::jdk(24) },\n+  { \"RefDiscoveryPolicy\",           JDK_Version::undefined(), JDK_Version::jdk(21), JDK_Version::jdk(24) },\n+\n@@ -530,0 +531,3 @@\n+  { \"GCLockerEdenExpansionPercent\", JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"NUMAPageScanRate\",             JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"ProcessDistributionStride\",    JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -223,4 +223,0 @@\n-  product(uintx, NUMAPageScanRate, 256,                                     \\\n-          \"Maximum number of pages to include in the page scan procedure\")  \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n@@ -922,7 +918,0 @@\n-  develop(bool, FLSVerifyDictionary, false,                                 \\\n-          \"Do lots of (expensive) FLS dictionary verification\")             \\\n-                                                                            \\\n-  product(uintx, ProcessDistributionStride, 4,                              \\\n-          \"Stride through processors when distributing processes\")          \\\n-          range(0, max_juint)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -729,1 +729,0 @@\n-  nonstatic_field(ciEnv,                       _failure_reason,                               const char*)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+            Objects.requireNonNull(interfaces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,6 +28,3 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import sun.invoke.util.Wrapper;\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n@@ -37,1 +34,6 @@\n-import java.lang.invoke.MethodType;\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -46,2 +48,2 @@\n-\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import java.util.Objects;\n+import java.util.function.IntFunction;\n@@ -56,27 +58,28 @@\n-final class ProxyGenerator extends ClassWriter {\n-    private static final int CLASSFILE_VERSION = ClassFileFormatVersion.latest().major();\n-    private static final String JL_CLASS = \"java\/lang\/Class\";\n-    private static final String JL_OBJECT = \"java\/lang\/Object\";\n-    private static final String JL_THROWABLE = \"java\/lang\/Throwable\";\n-    private static final String JL_CLASS_NOT_FOUND_EX = \"java\/lang\/ClassNotFoundException\";\n-    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n-\n-    private static final String JL_NO_CLASS_DEF_FOUND_ERROR = \"java\/lang\/NoClassDefFoundError\";\n-    private static final String JL_NO_SUCH_METHOD_EX = \"java\/lang\/NoSuchMethodException\";\n-    private static final String JL_NO_SUCH_METHOD_ERROR = \"java\/lang\/NoSuchMethodError\";\n-    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n-    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n-\n-    private static final String JLR_INVOCATION_HANDLER = \"java\/lang\/reflect\/InvocationHandler\";\n-    private static final String JLR_PROXY = \"java\/lang\/reflect\/Proxy\";\n-    private static final String JLR_UNDECLARED_THROWABLE_EX = \"java\/lang\/reflect\/UndeclaredThrowableException\";\n-\n-    private static final String LJL_CLASS = \"Ljava\/lang\/Class;\";\n-    private static final String LJL_CLASSLOADER = \"Ljava\/lang\/ClassLoader;\";\n-    private static final String LJLR_METHOD = \"Ljava\/lang\/reflect\/Method;\";\n-    private static final String LJLR_INVOCATION_HANDLER = \"Ljava\/lang\/reflect\/InvocationHandler;\";\n-\n-    private static final String MJLR_INVOCATIONHANDLER = \"(Ljava\/lang\/reflect\/InvocationHandler;)V\";\n-\n-    private static final String NAME_CTOR = \"<init>\";\n-    private static final String NAME_CLINIT = \"<clinit>\";\n+final class ProxyGenerator {\n+\n+    private static final ClassDesc\n+            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n+            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n+            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n+            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n+            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n+            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n+            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n+            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n+            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n+            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+\n+    private static final MethodTypeDesc\n+            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n+            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n+            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n+            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n+            MTD_Class = MethodTypeDesc.of(CD_Class),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n+            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n+            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n+            MTD_String = MethodTypeDesc.of(CD_String);\n+\n@@ -106,0 +109,32 @@\n+    private static final ClassModel TEMPLATE;\n+\n+    private static final ClassEntry CE_Class;\n+    private static final ClassEntry CE_ClassNotFoundException;\n+    private static final ClassEntry CE_NoClassDefFoundError;\n+    private static final ClassEntry CE_NoSuchMethodError;\n+    private static final ClassEntry CE_NoSuchMethodException;\n+    private static final ClassEntry CE_Object;\n+    private static final ClassEntry CE_Throwable;\n+    private static final ClassEntry CE_UndeclaredThrowableException;\n+\n+    private static final FieldRefEntry FRE_Proxy_h;\n+\n+    private static final InterfaceMethodRefEntry IMRE_InvocationHandler_invoke;\n+\n+    private static final MethodRefEntry MRE_Class_forName;\n+    private static final MethodRefEntry MRE_Class_getClassLoader;\n+    private static final MethodRefEntry MRE_Class_getMethod;\n+    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n+    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n+    private static final MethodRefEntry MRE_Throwable_getMessage;\n+    private static final MethodRefEntry MRE_UndeclaredThrowableException_init;\n+\n+    private static final Utf8Entry UE_Method;\n+\n+    private static final List<StackMapFrameInfo.VerificationTypeInfo> THROWABLE_STACK;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T extends PoolEntry> T entryByIndex(int index) {\n+        return (T) TEMPLATE.constantPool().entryByIndex(index);\n+    }\n+\n@@ -107,0 +142,62 @@\n+        \/\/ static template ClassModel holds pre-defined constant pool entries\n+        \/\/ proxy transformed from the template shares the template constant pool\n+        \/\/ each direct use of the template pool entry is significantly faster\n+        var cc = ClassFile.of();\n+        var ei = new int[21];\n+        TEMPLATE = cc.parse(cc.build(CD_Proxy, clb -> {\n+            clb.withSuperclass(CD_Proxy);\n+            generateConstructor(clb);\n+            generateLookupAccessor(clb);\n+            var cp = clb.constantPool();\n+\n+            ei[0] = cp.classEntry(CD_Class).index();\n+            ei[1] = cp.classEntry(CD_ClassNotFoundException).index();\n+            ei[2] = cp.classEntry(CD_NoClassDefFoundError).index();\n+            ei[3] = cp.classEntry(CD_NoSuchMethodError).index();\n+            ei[4] = cp.classEntry(CD_NoSuchMethodException).index();\n+            ei[5] = cp.classEntry(CD_Object).index();\n+            ei[6] = cp.classEntry(CD_Throwable).index();\n+            ei[7] = cp.classEntry(CD_UndeclaredThrowableException).index();\n+\n+            ei[8] = cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler).index();\n+\n+            ei[9] = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray).index();\n+\n+            ei[10] = cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader).index();\n+            ei[11] = cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader).index();\n+            ei[12] = cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray).index();\n+            ei[13] = cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String).index();\n+            ei[14] = cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String).index();\n+            ei[15] = cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String).index();\n+            ei[16] = cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable).index();\n+\n+            ei[17] = cp.utf8Entry(CD_Method).index();\n+\n+            ei[18] = cp.utf8Entry(\"m0\").index();\n+            ei[19] = cp.utf8Entry(\"m1\").index();\n+            ei[20] = cp.utf8Entry(\"m2\").index();\n+        }));\n+\n+        CE_Class = entryByIndex(ei[0]);\n+        CE_ClassNotFoundException = entryByIndex(ei[1]);\n+        CE_NoClassDefFoundError = entryByIndex(ei[2]);\n+        CE_NoSuchMethodError = entryByIndex(ei[3]);\n+        CE_NoSuchMethodException = entryByIndex(ei[4]);\n+        CE_Object = entryByIndex(ei[5]);\n+        CE_Throwable = entryByIndex(ei[6]);\n+        CE_UndeclaredThrowableException = entryByIndex(ei[7]);\n+\n+        FRE_Proxy_h = entryByIndex(ei[8]);\n+\n+        IMRE_InvocationHandler_invoke = entryByIndex(ei[9]);\n+\n+        MRE_Class_forName = entryByIndex(ei[10]);\n+        MRE_Class_getClassLoader = entryByIndex(ei[11]);\n+        MRE_Class_getMethod = entryByIndex(ei[12]);\n+        MRE_NoClassDefFoundError_init = entryByIndex(ei[13]);\n+        MRE_NoSuchMethodError_init = entryByIndex(ei[14]);\n+        MRE_Throwable_getMessage = entryByIndex(ei[15]);\n+        MRE_UndeclaredThrowableException_init = entryByIndex(ei[16]);\n+\n+        UE_Method = entryByIndex(ei[17]);\n+\n@@ -108,3 +205,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), \"m0\");\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), \"m1\");\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), \"m2\");\n+            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), entryByIndex(ei[18]));\n+            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), entryByIndex(ei[19]));\n+            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), entryByIndex(ei[20]));\n@@ -114,0 +211,2 @@\n+\n+        THROWABLE_STACK = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CE_Throwable));\n@@ -117,1 +216,1 @@\n-     * Class loader\n+     * Classfile context\n@@ -119,1 +218,2 @@\n-    private final ClassLoader loader;\n+    private final ClassFile classfileContext;\n+    private final ConstantPoolBuilder cp;\n@@ -124,1 +224,1 @@\n-    private final String className;\n+    private ClassEntry classEntry;\n@@ -158,3 +258,6 @@\n-        super(ClassWriter.COMPUTE_FRAMES);\n-        this.loader = loader;\n-        this.className = className;\n+        this.classfileContext = ClassFile.of(\n+                ClassFile.StackMapsOption.DROP_STACK_MAPS,\n+                ClassFile.ClassHierarchyResolverOption.of(\n+                        ClassHierarchyResolver.ofClassLoading(loader).cached()));\n+        this.cp = ConstantPoolBuilder.of(TEMPLATE);\n+        this.classEntry = cp.classEntry(ClassDesc.of(className));\n@@ -177,0 +280,1 @@\n+        Objects.requireNonNull(interfaces);\n@@ -188,1 +292,1 @@\n-                                    Path dir = Path.of(dotToSlash(name.substring(0, i)));\n+                                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n@@ -208,5 +312,13 @@\n-     * Return an array of the class and interface names from an array of Classes.\n-     *\n-     * @param classes an array of classes or interfaces\n-     * @return the array of class and interface names; or null if classes is\n-     * null or empty\n+     * {@return the entries of the given type}\n+     * @param types the {@code Class} objects, not primitive types nor array types\n+     *\/\n+    private static ClassEntry[] toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n+        var ces = new ClassEntry[types.size()];\n+        for (int i = 0; i < ces.length; i++)\n+            ces[i] = cp.classEntry(cp.utf8Entry(types.get(i).getName().replace('.', '\/')));\n+        return ces;\n+    }\n+\n+    \/**\n+     * {@return the {@code ClassDesc} of the given type}\n+     * @param type the {@code Class} object\n@@ -214,8 +326,2 @@\n-    private static String[] typeNames(List<Class<?>> classes) {\n-        if (classes == null || classes.size() == 0)\n-            return null;\n-        int size = classes.size();\n-        String[] ifaces = new String[size];\n-        for (int i = 0; i < size; i++)\n-            ifaces[i] = dotToSlash(classes.get(i).getName());\n-        return ifaces;\n+    private static ClassDesc toClassDesc(Class<?> type) {\n+        return ClassDesc.ofDescriptor(type.descriptorString());\n@@ -390,28 +496,0 @@\n-    \/**\n-     * Convert a fully qualified class name that uses '.' as the package\n-     * separator, the external representation used by the Java language\n-     * and APIs, to a fully qualified class name that uses '\/' as the\n-     * package separator, the representation used in the class file\n-     * format (see JVMS section {@jvms 4.2}).\n-     *\/\n-    private static String dotToSlash(String name) {\n-        return name.replace('.', '\/');\n-    }\n-\n-    \/**\n-     * Return the number of abstract \"words\", or consecutive local variable\n-     * indexes, required to contain a value of the given type.  See JVMS\n-     * section {@jvms 3.6.1}.\n-     * <p>\n-     * Note that the original version of the JVMS contained a definition of\n-     * this abstract notion of a \"word\" in section 3.4, but that definition\n-     * was removed for the second edition.\n-     *\/\n-    private static int getWordsPerType(Class<?> type) {\n-        if (type == long.class || type == double.class) {\n-            return 2;\n-        } else {\n-            return 1;\n-        }\n-    }\n-\n@@ -442,11 +520,0 @@\n-    \/**\n-     * Returns the {@link ClassLoader} to be used by the default implementation of {@link\n-     * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\n-     * default.\n-     *\n-     * @return ClassLoader\n-     *\/\n-    protected ClassLoader getClassLoader() {\n-        return loader;\n-    }\n-\n@@ -464,3 +531,0 @@\n-        visit(CLASSFILE_VERSION, accessFlags, dotToSlash(className), null,\n-                JLR_PROXY, typeNames(interfaces));\n-\n@@ -484,1 +548,1 @@\n-                    addProxyMethod(m, intf);\n+                    addProxyMethod(m, intf, cp);\n@@ -497,1 +561,4 @@\n-        generateConstructor();\n+        return classfileContext.build(classEntry, cp, clb -> {\n+            TEMPLATE.forEach(clb);\n+            clb.withFlags(accessFlags);\n+            clb.withInterfaces(toClassEntries(cp, interfaces));\n@@ -499,5 +566,4 @@\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                \/\/ add static field for the Method object\n-                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n-                        LJLR_METHOD, null, null);\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -505,2 +571,3 @@\n-                \/\/ Generate code for proxy method\n-                pm.generateMethod(this, className);\n+                    \/\/ Generate code for proxy method\n+                    pm.generateMethod(clb, classEntry);\n+                }\n@@ -508,4 +575,2 @@\n-        }\n-        generateStaticInitializer();\n-        generateLookupAccessor();\n-        return toByteArray();\n+            generateStaticInitializer(clb);\n+        });\n@@ -528,1 +593,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass) {\n+    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n@@ -554,1 +619,1 @@\n-                \"m\" + proxyMethodCount++));\n+                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n@@ -572,14 +637,6 @@\n-    private void generateConstructor() {\n-        MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, null, null);\n-        ctor.visitParameter(null, 0);\n-        ctor.visitCode();\n-        ctor.visitVarInsn(ALOAD, 0);\n-        ctor.visitVarInsn(ALOAD, 1);\n-        ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, false);\n-        ctor.visitInsn(RETURN);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        ctor.visitMaxs(-1, -1);\n-        ctor.visitEnd();\n+    private static void generateConstructor(ClassBuilder clb) {\n+        clb.withMethodBody(INIT_NAME, MTD_void_InvocationHandler, ACC_PUBLIC, cob -> cob\n+               .aload(cob.receiverSlot())\n+               .aload(cob.parameterSlot(0))\n+               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n+               .return_());\n@@ -591,26 +648,12 @@\n-    private void generateStaticInitializer() {\n-\n-        MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,\n-                \"()V\", null, null);\n-        mv.visitCode();\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_NoMethodHandler = new Label();\n-        Label L_NoClassHandler = new Label();\n-\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,\n-                JL_NO_SUCH_METHOD_EX);\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,\n-                JL_CLASS_NOT_FOUND_EX);\n-\n-        \/\/ Put ClassLoader at local variable index 0, used by\n-        \/\/ Class.forName(String, boolean, ClassLoader) calls\n-        mv.visitLdcInsn(Type.getObjectType(dotToSlash(className)));\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + LJL_CLASSLOADER, false);\n-        mv.visitVarInsn(ASTORE, 0);\n-\n-        mv.visitLabel(L_startBlock);\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                pm.codeFieldInitialization(mv, className);\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(classEntry)\n+               .invokevirtual(MRE_Class_getClassLoader)\n+               .astore(0);\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob, classEntry);\n+                }\n@@ -618,30 +661,21 @@\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(L_endBlock);\n-        \/\/ Generate exception handler\n-\n-        mv.visitLabel(L_NoMethodHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        mv.visitLabel(L_NoClassHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n+               .new_(CE_NoSuchMethodError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoSuchMethodError_init)\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n+               .new_(CE_NoClassDefFoundError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoClassDefFoundError_init)\n+               .athrow()\n+               .with(StackMapTableAttribute.of(List.of(\n+                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+        });\n@@ -655,33 +689,22 @@\n-    private void generateLookupAccessor() {\n-        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n-                new String[] { JL_ILLEGAL_ACCESS_EX });\n-        mv.visitCode();\n-        Label L_illegalAccess = new Label();\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n-                \"()Ljava\/lang\/Class;\", false);\n-        mv.visitLdcInsn(Type.getType(Proxy.class));\n-        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n-                \"()Z\", false);\n-        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n-        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n-                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-\n-        mv.visitLabel(L_illegalAccess);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n-                \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private static void generateLookupAccessor(ClassBuilder clb) {\n+        clb.withMethod(NAME_LOOKUP_ACCESSOR,\n+                MTD_MethodHandles$Lookup_MethodHandles$Lookup,\n+                ACC_PRIVATE | ACC_STATIC,\n+                mb -> mb.with(ExceptionsAttribute.of(List.of(mb.constantPool().classEntry(CD_IllegalAccessException))))\n+                        .withCode(cob -> cob\n+                            .block(blockBuilder -> blockBuilder\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n+                                    .constantInstruction(Opcode.LDC, CD_Proxy)\n+                                    .if_acmpne(blockBuilder.breakLabel())\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n+                                    .ifeq(blockBuilder.breakLabel())\n+                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                                    .areturn())\n+                            .new_(CD_IllegalAccessException)\n+                            .dup()\n+                            .aload(cob.parameterSlot(0))\n+                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n+                            .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n+                            .athrow()));\n@@ -702,1 +725,1 @@\n-        private final String methodFieldName;\n+        private final Utf8Entry methodFieldName;\n@@ -707,1 +730,1 @@\n-                            Class<?> fromClass, String methodFieldName) {\n+                            Class<?> fromClass, Utf8Entry methodFieldName) {\n@@ -723,1 +746,1 @@\n-        private ProxyMethod(Method method, String methodFieldName) {\n+        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n@@ -725,2 +748,2 @@\n-                    method.getSharedParameterTypes(), method.getReturnType(),\n-                    method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedParameterTypes(), method.getReturnType(),\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -732,60 +755,28 @@\n-        private void generateMethod(ClassWriter cw, String className) {\n-            MethodType mt = MethodType.methodType(returnType, parameterTypes);\n-            String desc = mt.toMethodDescriptorString();\n-            int accessFlags = ACC_PUBLIC | ACC_FINAL;\n-            if (method.isVarArgs()) accessFlags |= ACC_VARARGS;\n-\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                    method.getName(), desc, null,\n-                    typeNames(Arrays.asList(exceptionTypes)));\n-\n-            int[] parameterSlot = new int[parameterTypes.length];\n-            int nextSlot = 1;\n-            for (int i = 0; i < parameterSlot.length; i++) {\n-                parameterSlot[i] = nextSlot;\n-                nextSlot += getWordsPerType(parameterTypes[i]);\n-            }\n-\n-            mv.visitCode();\n-            Label L_startBlock = new Label();\n-            Label L_endBlock = new Label();\n-            Label L_RuntimeHandler = new Label();\n-            Label L_ThrowableHandler = new Label();\n-\n-            List<Class<?>> catchList = computeUniqueCatchList(exceptionTypes);\n-            if (catchList.size() > 0) {\n-                for (Class<?> ex : catchList) {\n-                    mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,\n-                            dotToSlash(ex.getName()));\n-                }\n-\n-                mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,\n-                        JL_THROWABLE);\n-            }\n-            mv.visitLabel(L_startBlock);\n-\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,\n-                    LJLR_INVOCATION_HANDLER);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,\n-                    LJLR_METHOD);\n-\n-            if (parameterTypes.length > 0) {\n-                \/\/ Create an array and fill with the parameters converting primitives to wrappers\n-                emitIconstInsn(mv, parameterTypes.length);\n-                mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);\n-                for (int i = 0; i < parameterTypes.length; i++) {\n-                    mv.visitInsn(DUP);\n-                    emitIconstInsn(mv, i);\n-                    codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);\n-                    mv.visitInsn(Opcodes.AASTORE);\n-                }\n-            } else {\n-                mv.visitInsn(Opcodes.ACONST_NULL);\n-            }\n-\n-            mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,\n-                    \"invoke\",\n-                    \"(Ljava\/lang\/Object;Ljava\/lang\/reflect\/Method;\" +\n-                            \"[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", true);\n+        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n+            var cp = clb.constantPool();\n+            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n+                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+            int accessFlags = (method.isVarArgs()) ? ACC_VARARGS | ACC_PUBLIC | ACC_FINAL\n+                                                   : ACC_PUBLIC | ACC_FINAL;\n+            var catchList = computeUniqueCatchList(exceptionTypes);\n+            clb.withMethod(method.getName(), desc, accessFlags, mb ->\n+                  mb.with(ExceptionsAttribute.of(toClassEntries(cp, List.of(exceptionTypes))))\n+                    .withCode(cob -> {\n+                        cob.aload(cob.receiverSlot())\n+                           .getfield(FRE_Proxy_h)\n+                           .aload(cob.receiverSlot())\n+                           .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n+\n+                        if (parameterTypes.length > 0) {\n+                            \/\/ Create an array and fill with the parameters converting primitives to wrappers\n+                            cob.constantInstruction(parameterTypes.length)\n+                               .anewarray(CE_Object);\n+                            for (int i = 0; i < parameterTypes.length; i++) {\n+                                cob.dup()\n+                                   .constantInstruction(i);\n+                                codeWrapArgument(cob, parameterTypes[i], cob.parameterSlot(i));\n+                                cob.aastore();\n+                            }\n+                        } else {\n+                            cob.aconst_null();\n+                        }\n@@ -793,6 +784,1 @@\n-            if (returnType == void.class) {\n-                mv.visitInsn(POP);\n-                mv.visitInsn(RETURN);\n-            } else {\n-                codeUnwrapReturnValue(mv, returnType);\n-            }\n+                        cob.invokeinterface(IMRE_InvocationHandler_invoke);\n@@ -800,17 +786,24 @@\n-            mv.visitLabel(L_endBlock);\n-\n-            \/\/ Generate exception handler\n-            mv.visitLabel(L_RuntimeHandler);\n-            mv.visitInsn(ATHROW);   \/\/ just rethrow the exception\n-\n-            mv.visitLabel(L_ThrowableHandler);\n-            mv.visitVarInsn(ASTORE, 1);\n-            mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);\n-            mv.visitInsn(DUP);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,\n-                    \"<init>\", \"(Ljava\/lang\/Throwable;)V\", false);\n-            mv.visitInsn(ATHROW);\n-            \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n+                        if (returnType == void.class) {\n+                            cob.pop()\n+                               .return_();\n+                        } else {\n+                            codeUnwrapReturnValue(cob, returnType);\n+                        }\n+                        if (!catchList.isEmpty()) {\n+                            var c1 = cob.newBoundLabel();\n+                            for (var exc : catchList) {\n+                                cob.exceptionCatch(cob.startLabel(), c1, c1, toClassDesc(exc));\n+                            }\n+                            cob.athrow();   \/\/ just rethrow the exception\n+                            var c2 = cob.newBoundLabel();\n+                            cob.exceptionCatchAll(cob.startLabel(), c1, c2)\n+                               .new_(CE_UndeclaredThrowableException)\n+                               .dup_x1()\n+                               .swap()\n+                               .invokespecial(MRE_UndeclaredThrowableException_init)\n+                               .athrow()\n+                               .with(StackMapTableAttribute.of(List.of(\n+                                    StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                                    StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                        }\n+                    }));\n@@ -825,1 +818,1 @@\n-        private void codeWrapArgument(MethodVisitor mv, Class<?> type, int slot) {\n+        private void codeWrapArgument(CodeBuilder cob, Class<?> type, int slot) {\n@@ -827,0 +820,1 @@\n+                cob.loadInstruction(TypeKind.from(type).asLoadable(), slot);\n@@ -828,4 +822,1 @@\n-\n-                mv.visitVarInsn(prim.loadOpcode, slot);\n-                mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, \"valueOf\",\n-                        prim.wrapperValueOfDesc, false);\n+                cob.invokestatic(prim.wrapperMethodRef);\n@@ -833,1 +824,1 @@\n-                mv.visitVarInsn(ALOAD, slot);\n+                cob.aload(slot);\n@@ -842,1 +833,1 @@\n-        private void codeUnwrapReturnValue(MethodVisitor mv, Class<?> type) {\n+        private void codeUnwrapReturnValue(CodeBuilder cob, Class<?> type) {\n@@ -846,6 +837,3 @@\n-                mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);\n-                mv.visitMethodInsn(INVOKEVIRTUAL,\n-                        prim.wrapperClassName,\n-                        prim.unwrapMethodName, prim.unwrapMethodDesc, false);\n-\n-                mv.visitInsn(prim.returnOpcode);\n+                cob.checkcast(prim.wrapperClass)\n+                   .invokevirtual(prim.unwrapMethodRef)\n+                   .returnInstruction(TypeKind.from(type).asLoadable());\n@@ -853,2 +841,2 @@\n-                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));\n-                mv.visitInsn(ARETURN);\n+                cob.checkcast(toClassDesc(type))\n+                   .areturn();\n@@ -863,4 +851,3 @@\n-        private void codeFieldInitialization(MethodVisitor mv, String className) {\n-            codeClassForName(mv, fromClass);\n-\n-            mv.visitLdcInsn(method.getName());\n+        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n+            var cp = cob.constantPool();\n+            codeClassForName(cob, fromClass);\n@@ -868,3 +855,3 @@\n-            emitIconstInsn(mv, parameterTypes.length);\n-\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);\n+            cob.ldc(method.getName())\n+               .constantInstruction(parameterTypes.length)\n+               .anewarray(CE_Class);\n@@ -874,3 +861,2 @@\n-                mv.visitInsn(DUP);\n-                emitIconstInsn(mv, i);\n-\n+                cob.dup()\n+                   .constantInstruction(i);\n@@ -878,4 +864,2 @@\n-                    PrimitiveTypeInfo prim =\n-                            PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    mv.visitFieldInsn(GETSTATIC,\n-                            prim.wrapperClassName, \"TYPE\", LJL_CLASS);\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.typeFieldRef);\n@@ -883,1 +867,1 @@\n-                    codeClassForName(mv, parameterTypes[i]);\n+                    codeClassForName(cob, parameterTypes[i]);\n@@ -885,1 +869,1 @@\n-                mv.visitInsn(Opcodes.AASTORE);\n+                cob.aastore();\n@@ -888,9 +872,2 @@\n-            mv.visitMethodInsn(INVOKEVIRTUAL,\n-                    JL_CLASS,\n-                    \"getMethod\",\n-                    \"(Ljava\/lang\/String;[Ljava\/lang\/Class;)Ljava\/lang\/reflect\/Method;\",\n-                    false);\n-\n-            mv.visitFieldInsn(PUTSTATIC,\n-                    dotToSlash(className),\n-                    methodFieldName, LJLR_METHOD);\n+            cob.invokevirtual(MRE_Class_getMethod)\n+               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n@@ -910,27 +887,5 @@\n-        private void codeClassForName(MethodVisitor mv, Class<?> cl) {\n-            mv.visitLdcInsn(cl.getName());\n-            mv.visitInsn(ICONST_0); \/\/ false\n-            mv.visitVarInsn(ALOAD, 0); \/\/ classLoader\n-            mv.visitMethodInsn(INVOKESTATIC,\n-                    JL_CLASS,\n-                    \"forName\",\n-                    \"(Ljava\/lang\/String;Z\" + LJL_CLASSLOADER + \")Ljava\/lang\/Class;\",\n-                    false);\n-        }\n-\n-        \/**\n-         * Visit a bytecode for a constant.\n-         *\n-         * @param mv  The MethodVisitor\n-         * @param cst The constant value\n-         *\/\n-        private void emitIconstInsn(MethodVisitor mv, final int cst) {\n-            if (cst >= -1 && cst <= 5) {\n-                mv.visitInsn(Opcodes.ICONST_0 + cst);\n-            } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-            } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-            } else {\n-                mv.visitLdcInsn(cst);\n-            }\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.ldc(cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(MRE_Class_forName);\n@@ -945,0 +900,1 @@\n+    private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -951,8 +907,8 @@\n-        BYTE(byte.class, ILOAD, IRETURN),\n-        CHAR(char.class, ILOAD, IRETURN),\n-        DOUBLE(double.class, DLOAD, DRETURN),\n-        FLOAT(float.class, FLOAD, FRETURN),\n-        INT(int.class, ILOAD, IRETURN),\n-        LONG(long.class, LLOAD, LRETURN),\n-        SHORT(short.class, ILOAD, IRETURN),\n-        BOOLEAN(boolean.class, ILOAD, IRETURN);\n+        BYTE(byte.class, CD_byte, CD_Byte),\n+        CHAR(char.class, CD_char, CD_Character),\n+        DOUBLE(double.class, CD_double, CD_Double),\n+        FLOAT(float.class, CD_float, CD_Float),\n+        INT(int.class, CD_int, CD_Integer),\n+        LONG(long.class, CD_long, CD_Long),\n+        SHORT(short.class, CD_short, CD_Short),\n+        BOOLEAN(boolean.class, CD_boolean, CD_Boolean);\n@@ -961,9 +917,1 @@\n-         * internal name of corresponding wrapper class\n-         *\/\n-        private final String wrapperClassName;\n-        \/**\n-         * method descriptor for wrapper class \"valueOf\" factory method\n-         *\/\n-        private final String wrapperValueOfDesc;\n-        \/**\n-         * name of wrapper class method for retrieving primitive value\n+         * CP entry of corresponding wrapper class\n@@ -971,1 +919,1 @@\n-        private final String unwrapMethodName;\n+        private final ClassEntry wrapperClass;\n@@ -973,1 +921,1 @@\n-         * descriptor of same method\n+         * CP entry for wrapper class \"valueOf\" factory method\n@@ -975,1 +923,1 @@\n-        private final String unwrapMethodDesc;\n+        private final MethodRefEntry wrapperMethodRef;\n@@ -977,1 +925,1 @@\n-         * Load opcode used by this primitive\n+         * CP entry of wrapper class method for retrieving primitive value\n@@ -979,1 +927,1 @@\n-        private final int loadOpcode;\n+        private final MethodRefEntry unwrapMethodRef;\n@@ -981,1 +929,1 @@\n-         * Return opcode used by this primitive\n+         * CP entry of wrapper class TYPE field\n@@ -983,17 +931,8 @@\n-        private final int returnOpcode;\n-\n-        PrimitiveTypeInfo(Class<?> primitiveClass, int loadOpcode, int returnOpcode) {\n-            assert primitiveClass.isPrimitive();\n-            assert returnOpcode - IRETURN == loadOpcode - ILOAD;\n-\n-            Wrapper wrapper = Wrapper.forPrimitiveType(primitiveClass);\n-            \/\/ single-char BaseType descriptor (see JVMS section 4.3.2)\n-            String baseTypeString = wrapper.basicTypeString();\n-            var wrapperType = wrapper.wrapperType();\n-            wrapperClassName = dotToSlash(wrapperType.getName());\n-            wrapperValueOfDesc =\n-                    \"(\" + baseTypeString + \")\" + wrapperType.descriptorString();\n-            unwrapMethodName = primitiveClass.getName() + \"Value\";\n-            unwrapMethodDesc = \"()\" + baseTypeString;\n-            this.loadOpcode = loadOpcode;\n-            this.returnOpcode = returnOpcode;\n+        private final FieldRefEntry typeFieldRef;\n+\n+        PrimitiveTypeInfo(Class<?> primitiveClass, ClassDesc baseType, ClassDesc wrapperClass) {\n+            assert baseType.isPrimitive();\n+            this.wrapperClass = CP.classEntry(wrapperClass);\n+            this.wrapperMethodRef = CP.methodRefEntry(wrapperClass, \"valueOf\", MethodTypeDesc.of(wrapperClass, baseType));\n+            this.unwrapMethodRef = CP.methodRefEntry(wrapperClass, primitiveClass.getName() + \"Value\", MethodTypeDesc.of(baseType));\n+            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":353,"deletions":414,"binary":false,"changes":767,"status":"modified"},{"patch":"@@ -443,0 +443,26 @@\n+\n+    \/**\n+     * Attempt to add key to map if absent.\n+     *\n+     * @param setMap    {@link ReferencedKeyMap} where interning takes place\n+     * @param key       key to add\n+     *\n+     * @param <T> type of key\n+     *\n+     * @return true if the key was added\n+     *\/\n+    static <T> boolean internAddKey(ReferencedKeyMap<T, ReferenceKey<T>> setMap, T key) {\n+        ReferenceKey<T> entryKey = setMap.entryKey(key);\n+        setMap.removeStaleReferences();\n+        ReferenceKey<T> existing = setMap.map.putIfAbsent(entryKey, entryKey);\n+        if (existing == null) {\n+            return true;\n+        } else {\n+            \/\/ If {@code putIfAbsent} returns non-null then was actually a\n+            \/\/ {@code replace} and older key was used. In that case the new\n+            \/\/ key was not used and the reference marked stale.\n+            entryKey.unused();\n+            return false;\n+        }\n+     }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -695,0 +695,1 @@\n+javax\/swing\/JMenuItem\/ActionListenerCalledTwice\/ActionListenerCalledTwiceTest.java 8316151 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -134,0 +134,6 @@\n+\n+        Long value1 = Long.valueOf(BASE_KEY + 999);\n+        Long value2 = Long.valueOf(BASE_KEY + 999);\n+        assertTrue(set.add(value1), \"key not added\");\n+        assertTrue(!set.add(value1), \"key added after second attempt\");\n+        assertTrue(!set.add(value2), \"key should not have been added\");\n","filename":"test\/jdk\/jdk\/internal\/util\/ReferencedKeyTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}