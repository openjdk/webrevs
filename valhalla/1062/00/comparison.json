{"files":[{"patch":"@@ -589,5 +589,0 @@\n-    \/\/ Do not let stores that initialize this buffer be reordered with a subsequent\n-    \/\/ store that would make this buffer accessible by other threads.\n-    \/\/ TODO 8325106 MemBarRelease vs. MemBarStoreStore\n-    \/\/ TODO 8328704\n-    \/\/ insert_mem_bar(Op_MemBarRelease);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-      \/\/ TODO 8325106 MemBarRelease vs. MemBarStoreStore\n+      \/\/ TODO 8325106 MemBarRelease vs. MemBarStoreStore, see set_alloc_with_final\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -719,0 +719,2 @@\n+      } else if (res_type->is_inlinetypeptr() && use->Opcode() == Op_MemBarRelease) {\n+        \/\/ Inline type buffer allocations are followed by a membar\n@@ -1114,0 +1116,4 @@\n+      } else if (use->Opcode() == Op_MemBarRelease) {\n+        \/\/ Inline type buffer allocations are followed by a membar\n+        assert(inline_alloc, \"Unexpected MemBarRelease\");\n+        use->as_MemBar()->remove(&_igvn);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -986,1 +986,1 @@\n-    return (eliminate_boxing && non_volatile) || is_stable_ary;\n+    return (eliminate_boxing && non_volatile) || is_stable_ary || tp->is_inlinetypeptr();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -934,1 +934,1 @@\n-        ret->init_req(TypeFunc::Parms, vt->get_oop());\n+        ret->init_req(TypeFunc::Parms, vt);\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,0 +289,8 @@\n+\n+      \/\/ Preserve allocation ptr to create precedent edge to it in membar\n+      \/\/ generated on exit from constructor.\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(new_vt->get_oop());\n+      if (alloc != nullptr) {\n+        set_alloc_with_final(new_vt->get_oop());\n+      }\n+      set_wrote_final(true);\n@@ -292,6 +300,0 @@\n-\n-    \/\/ TODO 8325106 needed?\n-    \/\/set_wrote_final(true);\n-    \/\/set_wrote_fields(true);\n-    \/\/set_alloc_with_final(obj);\n-\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1018,0 +1018,28 @@\n+    static value class MyValue41 {\n+        int x;\n+\n+        public MyValue41(int x) {\n+            this.x = x;\n+        }\n+\n+        static MyValue41 make() {\n+            return new MyValue41(0);\n+        }\n+    }\n+\n+    static MyValue41 field41;\n+\n+    \/\/ Test removal of the MemBarRelease following the value buffer initialization\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, ALLOCA, STORE})\n+    public void test41(MyValue41 val) {\n+        field41 = new MyValue41(val.x);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier() {\n+        MyValue41 val = new MyValue41(rI);\n+        test41(val);\n+        Asserts.assertEQ(field41, val);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -155,2 +155,0 @@\n-        \/\/ TODO 8328704 re-enable\n-        \/*\n@@ -166,1 +164,0 @@\n-        *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearing.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}