{"files":[{"patch":"@@ -549,2 +549,2 @@\n-                                    ClassLoader loader,\n-                                    Class<?> caller)\n+                                            ClassLoader loader,\n+                                            Class<?> caller)\n@@ -1428,2 +1428,0 @@\n-     * The modifiers also include the Java Virtual Machine's constants for\n-     * {@code identity class} and {@code value class}.\n@@ -1662,1 +1660,1 @@\n-        boolean isObjectConstructor() { return !isPartial() && ConstantDescs.INIT_NAME.equals(name); }\n+        boolean isConstructor() { return !isPartial() && ConstantDescs.INIT_NAME.equals(name); }\n@@ -1664,2 +1662,1 @@\n-        boolean isMethod() { return !isPartial() && !isObjectConstructor()\n-                                        && !ConstantDescs.CLASS_INIT_NAME.equals(name); }\n+        boolean isMethod() { return !isPartial() && !isConstructor() && !ConstantDescs.CLASS_INIT_NAME.equals(name); }\n@@ -1722,1 +1719,1 @@\n-            if (!enclosingInfo.isObjectConstructor())\n+            if (!enclosingInfo.isConstructor())\n@@ -4658,2 +4655,1 @@\n-        }\n-        if (isHidden()) {\n+        } else if (isHidden()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import jdk.internal.access.SharedSecrets;\n-\n-import java.util.Objects;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,77 +307,0 @@\n-\n-    static boolean verifyUnqualifiedClassName(String name) {\n-        for (int index = 0; index < name.length(); index++) {\n-            char ch = name.charAt(index);\n-            if (ch < 128) {\n-                if (ch == '.' || ch == ';' || ch == '[' ) {\n-                    return false;   \/\/ do not permit '.', ';', or '['\n-                }\n-                if (ch == '\/') {\n-                    \/\/ check for '\/\/' or leading or trailing '\/' which are not legal\n-                    \/\/ unqualified name must not be empty\n-                    if (index == 0 || index + 1 >= name.length() || name.charAt(index + 1) == '\/') {\n-                        return false;\n-                    }\n-                }\n-            } else {\n-                index ++;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Returns the basic type of the given descriptor.  If {@code verifyClassName}\n-     * is true, then this method will validate that the characters at [start, end)\n-     * within the given string describe a valid field type descriptor.\n-     *\n-     * @return the character represents the basic type that the descriptor string\n-     * references\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    static char basicType(String descriptor, int start, int end, boolean verifyClassName) {\n-        int arrayDim = 0;\n-        int index = start;\n-        while (index < end) {\n-            char c = descriptor.charAt(index);\n-            switch (c) {\n-                case JVM_SIGNATURE_VOID:\n-                case JVM_SIGNATURE_BOOLEAN:\n-                case JVM_SIGNATURE_BYTE:\n-                case JVM_SIGNATURE_CHAR:\n-                case JVM_SIGNATURE_SHORT:\n-                case JVM_SIGNATURE_INT:\n-                case JVM_SIGNATURE_FLOAT:\n-                case JVM_SIGNATURE_LONG:\n-                case JVM_SIGNATURE_DOUBLE:\n-                    return c;\n-                case JVM_SIGNATURE_CLASS:\n-                    index++;\n-                    int indexOfSemi = descriptor.indexOf(';', index);\n-                    if (indexOfSemi != -1) {\n-                        if (verifyClassName) {\n-                            String unqualifiedName = descriptor.substring(index, indexOfSemi);\n-                            boolean legal = verifyUnqualifiedClassName(unqualifiedName);\n-                            if (!legal) {\n-                                throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n-                            }\n-                        }\n-                        return c;\n-                    }\n-                    throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n-            }\n-        }\n-        throw new IllegalArgumentException(String.format(\"not a valid type descriptor: %s\", descriptor));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        if (kind == CONSTRUCTOR) {\n+        if (kind == CONSTRUCTOR)\n@@ -68,1 +68,0 @@\n-        }\n@@ -76,1 +75,1 @@\n-            case CONSTRUCTOR   -> validateObjectConstructor(type);\n+            case CONSTRUCTOR   -> validateConstructor(type);\n@@ -106,1 +105,1 @@\n-    private static void validateObjectConstructor(MethodTypeDesc type) {\n+    private static void validateConstructor(MethodTypeDesc type) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -374,3 +374,2 @@\n-                \/\/ primitive types: fromType and toType are types of the same primitive class\n-                \/\/ identity types: fromType should be a superclass of toType.\n-                return !strict || canConvert(fromType, toType);\n+                \/\/ fromType should be a superclass of toType\n+                return !strict || toType.isAssignableFrom(fromType);\n@@ -381,30 +380,0 @@\n-    \/**\n-     * Tests if {@code fromType} can be converted to {@code toType}\n-     * via an identity conversion, via a widening reference conversion or\n-     * via primitive class narrowing and widening conversions.\n-     * <p>\n-     * If {@code fromType} represents a class or interface, this method\n-     * returns {@code true} if {@code toType} is the same as,\n-     * or is a superclass or superinterface of, {@code fromType}.\n-     * <p>\n-     * If {@code fromType} and {@code toType} is of the same primitive class,\n-     * this method returns {@code true}.\n-     * <p>\n-     * Otherwise, this method returns {@code false}.\n-     *\n-     * @param     fromType the {@code Class} object to be converted from\n-     * @param     toType the {@code Class} object to be converted to\n-     * @return    {@code true} if {@code fromType} can be converted to {@code toType}\n-     *\/\n-    private boolean canConvert(Class<?> fromType, Class<?> toType) {\n-        if (toType.isAssignableFrom(fromType)) {\n-            return true;\n-        }\n-\n-        if (fromType.isValue() && toType.isValue()) {\n-            return fromType == toType;\n-        }\n-\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":2,"deletions":33,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isObjectConstructor())\n+            if (!member.getDeclaringClass().isAssignableFrom(refc) || member.isConstructor())\n@@ -130,1 +130,1 @@\n-        if (member.isObjectConstructor())\n+        if (member.isConstructor())\n@@ -135,2 +135,2 @@\n-        assert(ctor.isObjectConstructor()) : ctor;\n-        ctor = ctor.asObjectConstructor();\n+        assert(ctor.isConstructor()) : ctor;\n+        ctor = ctor.asConstructor();\n@@ -637,1 +637,1 @@\n-    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlatValue, boolean isNullRestricted, int ftypeKind) {\n+    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlat, boolean isNullRestricted, int ftypeKind) {\n@@ -640,1 +640,1 @@\n-                + (isFlatValue ? 1 : 0)\n+                + (isFlat ? 1 : 0)\n@@ -647,1 +647,1 @@\n-    static int ftypeKind(Class<?> ftype, boolean isValue) {\n+    static int ftypeKind(Class<?> ftype) {\n@@ -655,1 +655,1 @@\n-            return isValue ? FT_CHECKED_VALUE : FT_CHECKED_REF;\n+            return ftype.isValue() ? FT_CHECKED_VALUE : FT_CHECKED_REF;\n@@ -675,1 +675,1 @@\n-            preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlat(), m.isNullRestricted(), ftype);\n+            preparedFieldLambdaForm(formOp, m.isVolatile(), m.isFlat(), m.isNullRestricted(), ftype);\n@@ -680,1 +680,1 @@\n-        LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isInlineableField(), m.isFlat(), m.isNullRestricted(), ftype);\n+        LambdaForm lform = preparedFieldLambdaForm(formOp, m.isVolatile(), m.isFlat(), m.isNullRestricted(), ftype);\n@@ -689,2 +689,2 @@\n-                                                      boolean isValue, boolean isFlat, boolean isNullRestricted, Class<?> ftype) {\n-        int ftypeKind = ftypeKind(ftype, isValue);\n+                                                      boolean isFlat, boolean isNullRestricted, Class<?> ftype) {\n+        int ftypeKind = ftypeKind(ftype);\n@@ -694,1 +694,1 @@\n-        lform = makePreparedFieldLambdaForm(formOp, isVolatile, isValue, isFlat, isNullRestricted, ftypeKind);\n+        lform = makePreparedFieldLambdaForm(formOp, isVolatile,isFlat, isNullRestricted, ftypeKind);\n@@ -702,1 +702,1 @@\n-                                     boolean isFlatValue, boolean isNullRestricted,\n+                                     boolean isFlat,\n@@ -715,1 +715,1 @@\n-                    case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlat ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n@@ -727,1 +727,1 @@\n-                    case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;\n+                    case OBJECT:  return isFlat ? GET_VALUE : GET_REFERENCE;\n@@ -741,1 +741,1 @@\n-                    case OBJECT:  return isFlatValue ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlat ? PUT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;\n@@ -753,1 +753,1 @@\n-                    case OBJECT:  return isFlatValue ? PUT_VALUE : PUT_REFERENCE;\n+                    case OBJECT:  return isFlat ? PUT_VALUE : PUT_REFERENCE;\n@@ -762,1 +762,1 @@\n-        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, false, ftype);\n+        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);\n@@ -766,1 +766,1 @@\n-                                                          boolean isValue, boolean isFlat,\n+                                                          boolean isFlat,\n@@ -772,1 +772,1 @@\n-        boolean needsZeroInstance = isNullRestricted && isValue && !isFlat;\n+        boolean needsZeroInstance = isNullRestricted && !isFlat;\n@@ -775,1 +775,1 @@\n-        assert(needsCast ? true : ftypeKind(ft, isValue) == ftypeKind);\n+        assert(needsCast ? true : ftypeKind(ft) == ftypeKind);\n@@ -778,1 +778,1 @@\n-        Kind kind = getFieldKind(isGetter, isVolatile, isFlat, isNullRestricted, fw);\n+        Kind kind = getFieldKind(isGetter, isVolatile, isFlat, fw);\n@@ -781,1 +781,1 @@\n-        boolean hasValueTypeArg = isGetter ? isValue : isFlat;\n+        boolean hasValueTypeArg = isGetter ? ftypeKind == FT_CHECKED_VALUE : isFlat;\n@@ -783,2 +783,2 @@\n-            linkerType = isValue ? MethodType.methodType(ft, Object.class, long.class, Class.class)\n-                                 : MethodType.methodType(ft, Object.class, long.class);\n+            linkerType = hasValueTypeArg ? MethodType.methodType(ft, Object.class, long.class, Class.class)\n+                                         : MethodType.methodType(ft, Object.class, long.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-                int ftype = DirectMethodHandle.ftypeKind(wrapper.primitiveType(), true);\n+                int ftype = DirectMethodHandle.ftypeKind(wrapper.primitiveType());\n@@ -399,1 +399,1 @@\n-                        .makePreparedFieldLambdaForm(b, false \/*isVolatile*\/, ftype);\n+                        .makePreparedFieldLambdaForm(b, \/*isVolatile*\/false, ftype);\n@@ -406,1 +406,1 @@\n-                        .makePreparedFieldLambdaForm(b, true \/*isVolatile*\/, ftype);\n+                        .makePreparedFieldLambdaForm(b, \/*isVolatile*\/true, ftype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,10 +112,1 @@\n-        if (member.isObjectConstructor()) {\n-            MethodType methodType = getMethodType();\n-            if (MethodHandleNatives.refKindIsObjectConstructor(refKind) &&\n-                    methodType.returnType() != void.class) {\n-                \/\/ object constructor\n-                throw new IllegalArgumentException(\"object constructor must be of void return type\");\n-            }\n-            return isPublic ? defc.getConstructor(methodType.parameterArray())\n-                            : defc.getDeclaredConstructor(methodType.parameterArray());\n-        } else if (MethodHandleNatives.refKindIsMethod(refKind)) {\n+        if (MethodHandleNatives.refKindIsMethod(refKind)) {\n@@ -126,0 +117,5 @@\n+        } else if (MethodHandleNatives.refKindIsConstructor(refKind)) {\n+            if (isPublic)\n+                return defc.getConstructor(getMethodType().parameterArray());\n+            else\n+                return defc.getDeclaredConstructor(getMethodType().parameterArray());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -962,2 +962,1 @@\n-        if (member.isObjectConstructor())  return false;\n-\n+        if (member.isConstructor())  return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -315,2 +315,1 @@\n-     *         an interface, or if the return type of {@code factoryType} is a value\n-     *         interface, or if {@code implementation} is not a direct method\n+     *         an interface, or if {@code implementation} is not a direct method\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-        if (isObjectConstructor() && getReferenceKind() == REF_newInvokeSpecial)\n+        if (isConstructor() && getReferenceKind() == REF_newInvokeSpecial)\n@@ -250,1 +250,1 @@\n-        } else if (isObjectConstructor()) {\n+        } else if (isConstructor()) {\n@@ -438,9 +438,0 @@\n-    \/** Query whether this member is a field of a primitive class. *\/\n-    public boolean isInlineableField()  {\n-        if (isField()) {\n-            Class<?> type = getFieldType();\n-            return type.isValue();\n-        }\n-        return false;\n-    }\n-\n@@ -448,1 +439,0 @@\n-    static final String VALUE_FACTORY_NAME = \"<vnew>\";  \/\/ the ever-popular\n@@ -455,2 +445,2 @@\n-            IS_METHOD             = MN_IS_METHOD,              \/\/ method (not object constructor)\n-            IS_OBJECT_CONSTRUCTOR = MN_IS_OBJECT_CONSTRUCTOR,  \/\/ object constructor\n+            IS_METHOD             = MN_IS_METHOD,              \/\/ method (not constructor)\n+            IS_CONSTRUCTOR        = MN_IS_CONSTRUCTOR,         \/\/ constructor\n@@ -460,1 +450,1 @@\n-            TRUSTED_FINAL         = MN_TRUSTED_FINAL;    \/\/ trusted final field\n+            TRUSTED_FINAL         = MN_TRUSTED_FINAL;          \/\/ trusted final field\n@@ -463,2 +453,2 @@\n-    static final int ALL_KINDS = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE;\n-    static final int IS_INVOCABLE = IS_METHOD | IS_OBJECT_CONSTRUCTOR;\n+    static final int ALL_KINDS = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE;\n+    static final int IS_INVOCABLE = IS_METHOD | IS_CONSTRUCTOR;\n@@ -475,2 +465,2 @@\n-    public boolean isObjectConstructor() {\n-        return allFlagsSet(IS_OBJECT_CONSTRUCTOR);\n+    public boolean isConstructor() {\n+        return allFlagsSet(IS_CONSTRUCTOR);\n@@ -601,1 +591,1 @@\n-    public MemberName asObjectConstructor() {\n+    public MemberName asConstructor() {\n@@ -638,1 +628,1 @@\n-        if (this.type == null) {\n+        if (this.type == null)\n@@ -640,1 +630,0 @@\n-        }\n@@ -660,1 +649,1 @@\n-        assert(refKind == (isStatic() ? REF_getStatic : REF_getField)) : \" refKind \" + refKind;\n+        assert(refKind == (isStatic() ? REF_getStatic : REF_getField));\n@@ -772,1 +761,1 @@\n-     *  It will be an object constructor if and only if the name is {@code \"<init>\"}.\n+     *  It will be a constructor if and only if the name is {@code \"<init>\"}.\n@@ -778,1 +767,1 @@\n-        int initFlags = CONSTRUCTOR_NAME.equals(name) ? IS_OBJECT_CONSTRUCTOR : IS_METHOD;\n+        int initFlags = CONSTRUCTOR_NAME.equals(name) ? IS_CONSTRUCTOR : IS_METHOD;\n@@ -796,1 +785,1 @@\n-            kindFlags = IS_OBJECT_CONSTRUCTOR;\n+            kindFlags = IS_CONSTRUCTOR;\n@@ -914,1 +903,1 @@\n-        else if (isObjectConstructor())\n+        else if (isConstructor())\n@@ -927,1 +916,1 @@\n-        else if (isObjectConstructor())\n+        else if (isConstructor())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-            MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, \/\/ object constructor\n+            MN_IS_CONSTRUCTOR        = 0x00020000, \/\/ object constructor\n@@ -177,1 +177,1 @@\n-    static boolean refKindIsObjectConstructor(byte refKind) {\n+    static boolean refKindIsConstructor(byte refKind) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.value.ValueClass;\n@@ -709,1 +708,1 @@\n-     * with special names ({@value ConstantDescs#INIT_NAME}, and {@value\n+     * with special names ({@value ConstantDescs#INIT_NAME} and {@value\n@@ -3522,1 +3521,1 @@\n-            assert(ctor.isObjectConstructor());\n+            assert(ctor.isConstructor());\n@@ -3525,1 +3524,1 @@\n-            return lookup.getDirectConstructorNoSecurityManager(c.getDeclaringClass(), ctor);\n+            return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n@@ -3536,1 +3535,1 @@\n-            assert(ctor.isObjectConstructor() && constructorInSuperclass(decl, c));\n+            assert(ctor.isConstructor() && constructorInSuperclass(decl, c));\n@@ -3822,1 +3821,1 @@\n-                throw new NoSuchMethodException(\"illegal method name: \" + name + \" ref kind \" + refKind);\n+                throw new NoSuchMethodException(\"illegal method name: \"+name);\n@@ -3934,1 +3933,1 @@\n-            if (m.isObjectConstructor())\n+            if (m.isConstructor())\n@@ -4243,1 +4242,1 @@\n-            assert(ctor.isObjectConstructor());\n+            assert(ctor.isConstructor());\n@@ -5229,1 +5228,1 @@\n-        MethodType mtype = MethodType.methodType(ptype, ptype);\n+        MethodType mtype = methodType(ptype, ptype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -647,1 +647,1 @@\n-            } else if (MethodHandleNatives.refKindIsObjectConstructor(refKind)) {\n+            } else if (MethodHandleNatives.refKindIsConstructor(refKind)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,3 +229,1 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                AccessFlag.Location.FIELD,\n-                cffv);\n+        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD, cffv);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-                                            String simpleName,\n@@ -269,1 +268,1 @@\n-            MethodHandle emptyRecordCase = MethodHandles.constant(String.class, simpleName + \"[]\");\n+            MethodHandle emptyRecordCase = MethodHandles.constant(String.class, receiverClass.getSimpleName() + \"[]\");\n@@ -290,1 +289,1 @@\n-                    recipe = simpleName + \"[\";\n+                    recipe = receiverClass.getSimpleName() + \"[\";\n@@ -419,1 +418,0 @@\n-        Class<?> receiverType = recordClass;\n@@ -422,1 +420,1 @@\n-            if (mt.parameterType(0) != receiverType) {\n+            if (mt.parameterType(0) != recordClass) {\n@@ -432,1 +430,1 @@\n-            if (getter.type().parameterType(0) != receiverType) {\n+            if (getter.type().parameterType(0) != recordClass) {\n@@ -438,1 +436,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(boolean.class, receiverType, Object.class)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(boolean.class, recordClass, Object.class)))\n@@ -440,1 +438,1 @@\n-                yield makeEquals(receiverType, getterList);\n+                yield makeEquals(recordClass, getterList);\n@@ -443,1 +441,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(int.class, receiverType)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(int.class, recordClass)))\n@@ -445,1 +443,1 @@\n-                yield makeHashCode(receiverType, getterList);\n+                yield makeHashCode(recordClass, getterList);\n@@ -448,1 +446,1 @@\n-                if (methodType != null && !methodType.equals(MethodType.methodType(String.class, receiverType)))\n+                if (methodType != null && !methodType.equals(MethodType.methodType(String.class, recordClass)))\n@@ -453,1 +451,1 @@\n-                yield makeToString(lookup, receiverType, recordClass.getSimpleName(), getters, nameList);\n+                yield makeToString(lookup, recordClass, getters, nameList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Constants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}