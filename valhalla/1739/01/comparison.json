{"files":[{"patch":"@@ -140,2 +140,6 @@\n-      if (type->is_obj_array_klass()) {\n-        \/\/ Due to array covariance, the runtime type might be a flat array.\n+      if (type->is_ref_array_klass()) {\n+        return false;\n+      } else if (type->is_flat_array_klass()) {\n+        return true;\n+      } else if (type->is_obj_array_klass()) {\n+        \/\/ This is the unrefined array type\n@@ -146,2 +150,0 @@\n-      } else if (type->is_flat_array_klass()) {\n-        return true;\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  } else if (is_obj_array_klass()) {\n+  } else {\n@@ -83,2 +83,0 @@\n-  } else {\n-    return as_flat_array_klass()->base_element_klass();\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-class       ciFlatArrayKlass;\n@@ -70,0 +69,2 @@\n+class         ciFlatArrayKlass;\n+class         ciRefArrayKlass;\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -202,0 +202,5 @@\n+  ciObjArrayKlass* get_obj_array_klass(Klass* o) {\n+    if (o == nullptr) return nullptr;\n+    assert(o->is_objArray_klass() && !o->is_flatArray_klass() && !o->is_refArray_klass(), \"must be exact\");\n+    return get_metadata(o)->as_obj_array_klass();\n+  }\n@@ -206,1 +211,1 @@\n-  ciObjArrayKlass* get_obj_array_klass(Klass* o) {\n+  ciRefArrayKlass* get_ref_array_klass(Klass* o) {\n@@ -208,1 +213,1 @@\n-    return get_metadata(o)->as_obj_array_klass();\n+    return get_metadata(o)->as_ref_array_klass();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"ci\/ciFlatArrayKlass.hpp\"\n-#include \"ci\/ciInlineKlass.hpp\"\n-#include \"ci\/ciInstanceKlass.hpp\"\n-#include \"ci\/ciObjArrayKlass.hpp\"\n-#include \"ci\/ciSymbol.hpp\"\n-#include \"ci\/ciUtilities.hpp\"\n-#include \"ci\/ciUtilities.inline.hpp\"\n-#include \"oops\/flatArrayKlass.hpp\"\n-#include \"oops\/inlineKlass.inline.hpp\"\n-\n-\/\/ ciFlatArrayKlass\n-\/\/\n-\/\/ This class represents a Klass* in the HotSpot virtual machine\n-\/\/ whose Klass part is a FlatArrayKlass.\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciFlatArrayKlass::ciFlatArrayKlass\n-\/\/\n-\/\/ Constructor for loaded inline type array klasses.\n-ciFlatArrayKlass::ciFlatArrayKlass(Klass* h_k) : ciArrayKlass(h_k) {\n-  assert(get_Klass()->is_flatArray_klass(), \"wrong type\");\n-  InlineKlass* element_Klass = get_FlatArrayKlass()->element_klass();\n-  _base_element_klass = CURRENT_ENV->get_klass(element_Klass);\n-  assert(_base_element_klass->is_inlinetype(), \"bad base klass\");\n-  if (dimension() == 1) {\n-    _element_klass = _base_element_klass;\n-  } else {\n-    _element_klass = nullptr;\n-  }\n-  if (!ciObjectFactory::is_initialized()) {\n-    assert(_element_klass->is_java_lang_Object(), \"only arrays of object are shared\");\n-  }\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciFlatArrayKlass::element_klass\n-\/\/\n-\/\/ What is the one-level element type of this array?\n-ciKlass* ciFlatArrayKlass::element_klass() {\n-  if (_element_klass == nullptr) {\n-    assert(dimension() > 1, \"_element_klass should not be nullptr\");\n-    assert(is_loaded(), \"FlatArrayKlass must be loaded\");\n-    \/\/ Produce the element klass.\n-    VM_ENTRY_MARK;\n-    Klass* element_Klass = get_FlatArrayKlass()->element_klass();\n-    _element_klass = CURRENT_THREAD_ENV->get_klass(element_Klass);\n-  }\n-  return _element_klass;\n-}\n-\n-ciKlass* ciFlatArrayKlass::exact_klass() {\n-  assert(element_klass()->is_loaded() && element_klass()->as_inline_klass()->exact_klass() != nullptr, \"must have exact klass\");\n-  return this;\n-}\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.cpp","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-#include \"ci\/ciArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -35,1 +36,1 @@\n-class ciFlatArrayKlass : public ciArrayKlass {\n+class ciFlatArrayKlass : public ciObjArrayKlass {\n@@ -39,4 +40,0 @@\n-private:\n-  ciKlass* _element_klass;\n-  ciKlass* _base_element_klass;\n-\n@@ -44,1 +41,3 @@\n-  ciFlatArrayKlass(Klass* h_k);\n+  ciFlatArrayKlass(Klass* k) : ciObjArrayKlass(k) {\n+    assert(k->is_flatArray_klass(), \"wrong type\");\n+  }\n@@ -50,4 +49,1 @@\n-  const char* type_string() { return \"ciFlatArrayKlass\"; }\n-\n-  oop     loader()        { return _base_element_klass->loader(); }\n-  jobject loader_handle() { return _base_element_klass->loader_handle(); }\n+  virtual const char* type_string() override { return \"ciFlatArrayKlass\"; }\n@@ -58,3 +54,0 @@\n-  \/\/ The one-level type of the array elements.\n-  ciKlass* element_klass();\n-\n@@ -64,1 +57,0 @@\n-  int element_byte_size() { return 1 << log2_element_size(); }\n@@ -66,2 +58,1 @@\n-  \/\/ The innermost type of the array elements.\n-  ciKlass* base_element_klass() { return _base_element_klass; }\n+  int element_byte_size() { return 1 << log2_element_size(); }\n@@ -70,1 +61,1 @@\n-  bool is_flat_array_klass() const { return true; }\n+  virtual bool is_flat_array_klass() const override { return true; }\n@@ -72,4 +63,3 @@\n-  virtual ciKlass* exact_klass();\n-\n-  virtual bool can_be_inline_array_klass() {\n-    return true;\n+  virtual ciKlass* exact_klass() override {\n+    assert(element_klass()->as_inline_klass()->exact_klass() != nullptr, \"must have exact klass\");\n+    return this;\n@@ -79,1 +69,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.hpp","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  virtual bool is_flat_array_klass() const  { return false; }\n@@ -62,0 +61,2 @@\n+  virtual bool is_flat_array_klass() const  { return false; }\n+  virtual bool is_ref_array_klass() const   { return false; }\n@@ -99,0 +100,4 @@\n+  ciObjArrayKlass*         as_obj_array_klass() {\n+    assert(is_obj_array_klass(), \"bad cast\");\n+    return (ciObjArrayKlass*)this;\n+  }\n@@ -103,3 +108,3 @@\n-  ciObjArrayKlass*         as_obj_array_klass() {\n-    assert(is_obj_array_klass(), \"bad cast\");\n-    return (ciObjArrayKlass*)this;\n+  ciRefArrayKlass*         as_ref_array_klass() {\n+    assert(is_ref_array_klass(), \"bad cast\");\n+    return (ciRefArrayKlass*)this;\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciRefArrayKlass.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"ci\/ciUtilities.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -71,1 +72,2 @@\n-         _base_element_klass->is_flat_array_klass(), \"bad base klass\");\n+         _base_element_klass->is_flat_array_klass() ||\n+         _base_element_klass->is_ref_array_klass(), \"bad base klass\");\n@@ -138,1 +140,1 @@\n-ciArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n+ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n@@ -148,11 +150,8 @@\n-    if (refined_type) {\n-      ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n-      if (null_free) {\n-        assert(element_klass->is_inlinetype(), \"Only value class arrays can be null free\");\n-        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n-      }\n-      if (!atomic) {\n-        assert(element_klass->is_inlinetype(), \"Only value class arrays can be non-atomic\");\n-        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NON_ATOMIC);\n-      }\n-      array = ObjArrayKlass::cast(array)->klass_with_properties(props, THREAD);\n+    if (!refined_type) {\n+      return CURRENT_THREAD_ENV->get_obj_array_klass(array);\n+    }\n+\n+    ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+    if (null_free) {\n+      assert(element_klass->is_inlinetype(), \"Only value class arrays can be null free\");\n+      props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n@@ -160,0 +159,5 @@\n+    if (!atomic) {\n+      assert(element_klass->is_inlinetype(), \"Only value class arrays can be non-atomic\");\n+      props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+    }\n+    array = ObjArrayKlass::cast(array)->klass_with_properties(props, THREAD);\n@@ -163,1 +167,1 @@\n-      return CURRENT_THREAD_ENV->get_obj_array_klass(array);\n+      return CURRENT_THREAD_ENV->get_ref_array_klass(array);\n@@ -181,1 +185,1 @@\n-ciArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n+ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n@@ -194,17 +198,1 @@\n-  if (!is_loaded()) {\n-    return nullptr;\n-  }\n-  ciType* base = base_element_type();\n-  if (base->is_instance_klass()) {\n-    ciInstanceKlass* ik = base->as_instance_klass();\n-    \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n-    \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n-    if (ik->is_inlinetype() && !is_elem_null_free()) {\n-      return nullptr;\n-    }\n-    if (ik->exact_klass() != nullptr) {\n-      return this;\n-    }\n-  } else if (base->is_primitive_type()) {\n-    return this;\n-  }\n+  \/\/ This cannot be an exact klass because the refined types subtype it\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":21,"deletions":33,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -49,1 +50,1 @@\n-    return (ObjArrayKlass*)get_Klass();\n+    return ObjArrayKlass::cast(get_Klass());\n@@ -52,1 +53,1 @@\n-  static ciArrayKlass* make_impl(ciKlass* element_klass, bool refined_type = false, bool null_free = false, bool atomic = true);\n+  static ciObjArrayKlass* make_impl(ciKlass* element_klass, bool refined_type = false, bool null_free = false, bool atomic = true);\n@@ -71,1 +72,1 @@\n-  static ciArrayKlass* make(ciKlass* element_klass, bool refined_type = true, bool null_free = false, bool atomic = true);\n+  static ciObjArrayKlass* make(ciKlass* element_klass, bool refined_type = true, bool null_free = false, bool atomic = true);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"ci\/ciRefArrayKlass.hpp\"\n@@ -414,4 +415,8 @@\n-    } else if (k->is_flatArray_klass()) {\n-      return new (arena()) ciFlatArrayKlass(k);\n-    } else if (k->is_refArray_klass() || k->is_objArray_klass()) {\n-      return new (arena()) ciObjArrayKlass(k);\n+    } else if (k->is_objArray_klass()) {\n+      if (k->is_flatArray_klass()) {\n+        return new (arena()) ciFlatArrayKlass(k);\n+      } else if (k->is_refArray_klass()) {\n+        return new (arena()) ciRefArrayKlass(k);\n+      } else {\n+        return new (arena()) ciObjArrayKlass(k);\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_CI_CIREFARRAYKLASS_HPP\n+#define SHARE_VM_CI_CIREFARRAYKLASS_HPP\n+\n+#include \"ci\/ciObjArrayKlass.hpp\"\n+\n+\/\/ A ciRefArrayKlass represents the klass of a refined array in which the elements are stored as\n+\/\/ reference\n+class ciRefArrayKlass : public ciObjArrayKlass {\n+private:\n+  CI_PACKAGE_ACCESS\n+  friend class ciEnv;\n+\n+protected:\n+  ciRefArrayKlass(Klass* k) : ciObjArrayKlass(k) {\n+    assert(k->is_refArray_klass(), \"wrong type\");\n+  }\n+\n+  virtual const char* type_string() override { return \"ciRefArrayKlass\"; }\n+\n+public:\n+  virtual bool is_ref_array_klass() const override { return true; }\n+\n+  virtual ciKlass* exact_klass() override {\n+    return this;\n+  }\n+};\n+\n+#endif \/\/ SHARE_VM_CI_CIREFARRAYKLASS_HPP\n","filename":"src\/hotspot\/share\/ci\/ciRefArrayKlass.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -322,1 +322,1 @@\n-    \/\/ When (obj\/flat)Array meets typeArray, we also get Object.\n+    \/\/ When objArray meets typeArray, we also get Object.\n@@ -324,3 +324,2 @@\n-    \/\/ But when (obj\/flat)Array meets (obj\/flat)Array, we look carefully at element types.\n-    if ((k1->is_obj_array_klass() || k1->is_flat_array_klass()) &&\n-        (k2->is_obj_array_klass() || k2->is_flat_array_klass())) {\n+    \/\/ But when objArray meets objArray, we look carefully at element types.\n+    if (k1->is_obj_array_klass() && k2->is_obj_array_klass()) {\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -343,2 +343,1 @@\n-      assert(array->is_obj_array_klass() || array->is_flat_array_klass(),\n-             \"must be a flat or an object array type\");\n+      assert(array->is_obj_array_klass(), \"must be an object array type\");\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -494,8 +494,2 @@\n-      } else if (cik->is_flat_array_klass()) {\n-        ciKlass* cie = cik->as_flat_array_klass()->base_element_klass();\n-        cie->print_name_on(st);\n-        st->print(\"[%d]\", spobj->n_fields());\n-        int ndim = cik->as_array_klass()->dimension() - 1;\n-        while (ndim-- > 0) {\n-          st->print(\"[]\");\n-        }\n+      } else {\n+        assert(false, \"unexpected type %s\", cik->name()->as_utf8());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciArrayKlass.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -39,0 +41,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -56,0 +59,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -1879,3 +1883,12 @@\n-Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* vk, bool is_null_free, bool is_not_null_free, bool is_atomic) {\n-  assert(vk->maybe_flat_in_array(), \"element of type %s cannot be flat in array\", vk->name()->as_utf8());\n-  if (!vk->has_nullable_atomic_layout()) {\n+Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* elem_vk) {\n+  assert(elem_vk->maybe_flat_in_array(), \"no flat array for %s\", elem_vk->name()->as_utf8());\n+  if (!elem_vk->has_atomic_layout() && !elem_vk->has_nullable_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, true, false);\n+  } else if (!elem_vk->has_nullable_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, true, true);\n+  } else if (!elem_vk->has_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+    return cast_to_flat_array_exact(array, elem_vk, false, true);\n+  }\n+\n+  bool is_null_free = false;\n+  if (!elem_vk->has_nullable_atomic_layout()) {\n@@ -1885,8 +1898,0 @@\n-  if (!vk->has_atomic_layout() && !vk->has_non_atomic_layout()) {\n-    \/\/ Element does not have a null-free flat layout, cannot be null-free\n-    is_not_null_free = true;\n-  }\n-  if (is_null_free) {\n-    \/\/ TODO 8350865 Impossible type\n-    is_not_null_free = false;\n-  }\n@@ -1894,4 +1899,9 @@\n-  bool is_exact = is_null_free || is_not_null_free;\n-  ciArrayKlass* array_klass = ciArrayKlass::make(vk, is_null_free, is_atomic, true);\n-  assert(array_klass->is_elem_null_free() == is_null_free, \"inconsistency\");\n-  assert(array_klass->is_elem_atomic() == is_atomic, \"inconsistency\");\n+  ciObjArrayKlass* array_klass = ciObjArrayKlass::make(elem_vk, false);\n+  const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+  arytype = arytype->cast_to_flat(true)->cast_to_null_free(is_null_free);\n+  return _gvn.transform(new CastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n+}\n+\n+Node* GraphKit::cast_to_flat_array_exact(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_atomic) {\n+  assert(is_null_free || is_atomic, \"nullable arrays must be atomic\");\n+  ciObjArrayKlass* array_klass = ciObjArrayKlass::make(elem_vk, true, is_null_free, is_atomic);\n@@ -1899,2 +1909,2 @@\n-  arytype = arytype->cast_to_exactness(is_exact);\n-  arytype = arytype->cast_to_not_null_free(is_not_null_free);\n+  assert(arytype->klass_is_exact(), \"inconsistency\");\n+  assert(arytype->is_flat(), \"inconsistency\");\n@@ -1902,1 +1912,1 @@\n-  assert(arytype->is_not_null_free() == is_not_null_free, \"inconsistency\");\n+  assert(arytype->is_not_null_free() == !is_null_free, \"inconsistency\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n+#include \"ci\/ciInstanceKlass.hpp\"\n@@ -663,1 +665,2 @@\n-  Node* cast_to_flat_array(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_not_null_free, bool is_atomic);\n+  Node* cast_to_flat_array(Node* array, ciInlineKlass* elem_vk);\n+  Node* cast_to_flat_array_exact(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_atomic);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"ci\/ciArrayKlass.hpp\"\n@@ -557,1 +558,1 @@\n-    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* cast = kit->cast_to_flat_array_exact(base, vk, false, true);\n@@ -579,1 +580,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, true);\n@@ -593,1 +594,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, false);\n@@ -1084,1 +1085,1 @@\n-    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* cast = kit->cast_to_flat_array_exact(base, vk, false, true);\n@@ -1106,1 +1107,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, true);\n@@ -1120,1 +1121,1 @@\n-      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* cast = kit->cast_to_flat_array_exact(base, vk, true, false);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2888,1 +2888,1 @@\n-        Node* new_base = cast_to_flat_array(base, value_klass, is_null_free, !is_null_free, is_atomic);\n+        Node* new_base = cast_to_flat_array_exact(base, value_klass, is_null_free, is_atomic);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-          Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n+          Node* flat_array = cast_to_flat_array(array, vk);\n@@ -270,1 +270,1 @@\n-            Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n+            Node* flat_array = cast_to_flat_array(array, vk);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -3608,3 +3610,1 @@\n-      if (klass()->is_obj_array_klass()) {\n-        _is_ptr_to_narrowoop = true;\n-      } else if (klass()->is_flat_array_klass() && field_offset != Offset::top && field_offset != Offset::bottom) {\n+      if (klass()->is_flat_array_klass() && field_offset != Offset::top && field_offset != Offset::bottom) {\n@@ -3623,0 +3623,2 @@\n+      } else if (klass()->is_obj_array_klass()) {\n+        _is_ptr_to_narrowoop = UseCompressedOops;\n@@ -3835,0 +3837,12 @@\n+    bool xk = false;\n+    if (klass->is_flat_array_klass() || klass->is_ref_array_klass()) {\n+      \/\/ Refined types are exact\n+      xk = true;\n+    } else {\n+      \/\/ Try to refine the klass if it only has 1 corresponding refined type\n+      if (etype->klass_is_exact() && !etype->is_inlinetypeptr()) {\n+        klass = ciObjArrayKlass::make(etype->exact_klass());\n+        xk = true;\n+      }\n+    }\n+\n@@ -3846,2 +3860,3 @@\n-    bool not_null_free = not_inline;\n-    bool not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n+    bool not_null_free = not_inline || (xk && !is_null_free);\n+    bool not_flat = !UseArrayFlattening || (xk && !klass->is_flat_array_klass()) || not_inline ||\n+                    (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n@@ -3849,3 +3864,1 @@\n-    \/\/ Even though MyValue is final, [LMyValue is not exact because null-free [LMyValue is a subtype.\n-    bool xk = etype->klass_is_exact() && !etype->is_inlinetypeptr();\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, not_flat, not_null_free, atomic);\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ klass->is_flat_array_klass(), not_flat, not_null_free, atomic);\n@@ -3866,11 +3879,0 @@\n-  } else if (klass->is_flat_array_klass()) {\n-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass(), trust_interfaces);\n-    const bool is_null_free = klass->as_array_klass()->is_elem_null_free();\n-    if (is_null_free) {\n-      etype = etype->join_speculative(NOTNULL)->is_oopptr();\n-    }\n-    bool atomic = klass->as_array_klass()->is_elem_atomic();\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, \/* not_flat= *\/ false, \/* not_null_free= *\/ false, atomic);\n-    const bool exact = is_null_free; \/\/ Only exact if null-free because \"null-free [LMyValue <: null-able [LMyValue\".\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, exact, Offset(0));\n-    return arr;\n@@ -3907,1 +3909,1 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ false,\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ is_flat,\n@@ -3929,17 +3931,0 @@\n-  } else if (klass->is_flat_array_klass()) {\n-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass(), trust_interfaces);\n-    bool is_null_free = o->as_array()->is_null_free();\n-    if (is_null_free) {\n-      etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n-    }\n-    bool is_atomic = o->as_array()->is_atomic();\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ true,\n-                                        \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free, \/* atomic= *\/ is_atomic);\n-    \/\/ We used to pass NotNull in here, asserting that the sub-arrays\n-    \/\/ are all not-null.  This is not true in generally, as code can\n-    \/\/ slam nullptrs down in the subarrays.\n-    if (make_constant) {\n-      return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));\n-    } else {\n-      return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));\n-    }\n@@ -5065,0 +5050,13 @@\n+const TypeAryPtr* TypeAryPtr::cast_to_flat(bool flat) const {\n+  if (flat == is_flat()) {\n+    return this;\n+  }\n+  assert(!flat || !is_not_flat(), \"inconsistency\");\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), flat, is_not_flat(), is_not_null_free(), is_atomic());\n+  const TypeAryPtr* res = make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  if (res->speculative() == res->remove_speculative()) {\n+    return res->remove_speculative();\n+  }\n+  return res;\n+}\n+\n@@ -5081,0 +5079,21 @@\n+const TypeAryPtr* TypeAryPtr::cast_to_null_free(bool null_free) const {\n+  if (null_free == is_null_free()) {\n+    return this;\n+  }\n+  assert(!null_free || !is_not_null_free(), \"inconsistency\");\n+  const Type* elem = this->elem();\n+  const Type* new_elem = elem->make_ptr();\n+  if (null_free) {\n+    new_elem = new_elem->join_speculative(TypePtr::NOTNULL);\n+  } else {\n+    new_elem = new_elem->meet_speculative(TypePtr::NULL_PTR);\n+  }\n+  new_elem = elem->isa_narrowoop() ? new_elem->make_narrowoop() : new_elem;\n+  const TypeAry* new_ary = TypeAry::make(new_elem, size(), is_stable(), is_flat(), is_not_flat(), is_not_null_free(), is_atomic());\n+  const TypeAryPtr* res = make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  if (res->speculative() == res->remove_speculative()) {\n+    return res->remove_speculative();\n+  }\n+  return res;\n+}\n+\n@@ -6602,1 +6621,5 @@\n-  if (k->is_obj_array_klass()) {\n+  if (k->is_flat_array_klass()) {\n+    ciKlass* eklass = k->as_flat_array_klass()->element_klass();\n+    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n+  } else if (k->is_obj_array_klass()) {\n@@ -6611,4 +6634,0 @@\n-  } else if (k->is_flat_array_klass()) {\n-    ciKlass* eklass = k->as_flat_array_klass()->element_klass();\n-    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free, atomic, refined_type);\n@@ -6616,1 +6635,1 @@\n-    ShouldNotReachHere();\n+    assert(false, \"unexpected klass %s\", k->name()->as_utf8());\n@@ -6642,1 +6661,1 @@\n-  if ((refined == is_refined_type()) || !klass_is_exact() || (!exact_klass()->is_obj_array_klass() && !exact_klass()->is_flat_array_klass())) {\n+  if ((refined == is_refined_type()) || !klass_is_exact() || !exact_klass()->is_obj_array_klass()) {\n@@ -6688,1 +6707,1 @@\n-  if (is_flat() && el->is_inlinetypeptr()) {\n+  if (klass_is_exact() && is_flat() && el->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":64,"deletions":45,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -1776,0 +1776,1 @@\n+  const TypeAryPtr* cast_to_flat(bool flat) const;\n@@ -1777,0 +1778,1 @@\n+  const TypeAryPtr* cast_to_null_free(bool null_free) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}