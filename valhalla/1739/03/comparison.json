{"files":[{"patch":"@@ -140,2 +140,6 @@\n-      if (type->is_obj_array_klass()) {\n-        \/\/ Due to array covariance, the runtime type might be a flat array.\n+      if (type->is_ref_array_klass()) {\n+        return false;\n+      } else if (type->is_flat_array_klass()) {\n+        return true;\n+      } else if (type->is_obj_array_klass()) {\n+        \/\/ This is the unrefined array type\n@@ -146,2 +150,0 @@\n-      } else if (type->is_flat_array_klass()) {\n-        return true;\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  } else if (is_obj_array_klass()) {\n+  } else {\n@@ -84,2 +84,0 @@\n-  } else {\n-    return as_flat_array_klass()->base_element_klass();\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-class       ciFlatArrayKlass;\n@@ -70,0 +69,2 @@\n+class         ciFlatArrayKlass;\n+class         ciRefArrayKlass;\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -202,0 +202,5 @@\n+  ciObjArrayKlass* get_obj_array_klass(Klass* o) {\n+    if (o == nullptr) return nullptr;\n+    assert(o->is_objArray_klass() && !o->is_flatArray_klass() && !o->is_refArray_klass(), \"must be exact\");\n+    return get_metadata(o)->as_obj_array_klass();\n+  }\n@@ -206,1 +211,1 @@\n-  ciObjArrayKlass* get_obj_array_klass(Klass* o) {\n+  ciRefArrayKlass* get_ref_array_klass(Klass* o) {\n@@ -208,1 +213,1 @@\n-    return get_metadata(o)->as_obj_array_klass();\n+    return get_metadata(o)->as_ref_array_klass();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"ci\/ciFlatArrayKlass.hpp\"\n-#include \"ci\/ciInlineKlass.hpp\"\n-#include \"ci\/ciInstanceKlass.hpp\"\n-#include \"ci\/ciObjArrayKlass.hpp\"\n-#include \"ci\/ciSymbol.hpp\"\n-#include \"ci\/ciUtilities.hpp\"\n-#include \"ci\/ciUtilities.inline.hpp\"\n-#include \"oops\/flatArrayKlass.hpp\"\n-#include \"oops\/inlineKlass.inline.hpp\"\n-\n-\/\/ ciFlatArrayKlass\n-\/\/\n-\/\/ This class represents a Klass* in the HotSpot virtual machine\n-\/\/ whose Klass part is a FlatArrayKlass.\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciFlatArrayKlass::ciFlatArrayKlass\n-\/\/\n-\/\/ Constructor for loaded inline type array klasses.\n-ciFlatArrayKlass::ciFlatArrayKlass(Klass* h_k) : ciArrayKlass(h_k) {\n-  assert(get_Klass()->is_flatArray_klass(), \"wrong type\");\n-  InlineKlass* element_Klass = get_FlatArrayKlass()->element_klass();\n-  _base_element_klass = CURRENT_ENV->get_klass(element_Klass);\n-  assert(_base_element_klass->is_inlinetype(), \"bad base klass\");\n-  if (dimension() == 1) {\n-    _element_klass = _base_element_klass;\n-  } else {\n-    _element_klass = nullptr;\n-  }\n-  if (!ciObjectFactory::is_initialized()) {\n-    assert(_element_klass->is_java_lang_Object(), \"only arrays of object are shared\");\n-  }\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciFlatArrayKlass::element_klass\n-\/\/\n-\/\/ What is the one-level element type of this array?\n-ciKlass* ciFlatArrayKlass::element_klass() {\n-  if (_element_klass == nullptr) {\n-    assert(dimension() > 1, \"_element_klass should not be nullptr\");\n-    assert(is_loaded(), \"FlatArrayKlass must be loaded\");\n-    \/\/ Produce the element klass.\n-    VM_ENTRY_MARK;\n-    Klass* element_Klass = get_FlatArrayKlass()->element_klass();\n-    _element_klass = CURRENT_THREAD_ENV->get_klass(element_Klass);\n-  }\n-  return _element_klass;\n-}\n-\n-ciKlass* ciFlatArrayKlass::exact_klass() {\n-  assert(element_klass()->is_loaded() && element_klass()->as_inline_klass()->exact_klass() != nullptr, \"must have exact klass\");\n-  return this;\n-}\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.cpp","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-#include \"ci\/ciArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -35,1 +36,1 @@\n-class ciFlatArrayKlass : public ciArrayKlass {\n+class ciFlatArrayKlass : public ciObjArrayKlass {\n@@ -39,4 +40,0 @@\n-private:\n-  ciKlass* _element_klass;\n-  ciKlass* _base_element_klass;\n-\n@@ -44,1 +41,3 @@\n-  ciFlatArrayKlass(Klass* h_k);\n+  ciFlatArrayKlass(Klass* k) : ciObjArrayKlass(k) {\n+    assert(k->is_flatArray_klass(), \"wrong type\");\n+  }\n@@ -50,4 +49,1 @@\n-  const char* type_string() { return \"ciFlatArrayKlass\"; }\n-\n-  oop     loader()        { return _base_element_klass->loader(); }\n-  jobject loader_handle() { return _base_element_klass->loader_handle(); }\n+  virtual const char* type_string() override { return \"ciFlatArrayKlass\"; }\n@@ -58,3 +54,0 @@\n-  \/\/ The one-level type of the array elements.\n-  ciKlass* element_klass();\n-\n@@ -64,1 +57,0 @@\n-  int element_byte_size() { return 1 << log2_element_size(); }\n@@ -66,2 +58,1 @@\n-  \/\/ The innermost type of the array elements.\n-  ciKlass* base_element_klass() { return _base_element_klass; }\n+  int element_byte_size() { return 1 << log2_element_size(); }\n@@ -70,1 +61,1 @@\n-  bool is_flat_array_klass() const { return true; }\n+  virtual bool is_flat_array_klass() const override { return true; }\n@@ -72,4 +63,3 @@\n-  virtual ciKlass* exact_klass();\n-\n-  virtual bool can_be_inline_array_klass() {\n-    return true;\n+  virtual ciKlass* exact_klass() override {\n+    assert(element_klass()->as_inline_klass()->exact_klass() != nullptr, \"must have exact klass\");\n+    return this;\n@@ -79,1 +69,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.hpp","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  virtual bool is_flat_array_klass() const  { return false; }\n@@ -62,0 +61,2 @@\n+  virtual bool is_flat_array_klass() const  { return false; }\n+  virtual bool is_ref_array_klass() const   { return false; }\n@@ -99,0 +100,4 @@\n+  ciObjArrayKlass*         as_obj_array_klass() {\n+    assert(is_obj_array_klass(), \"bad cast\");\n+    return (ciObjArrayKlass*)this;\n+  }\n@@ -103,3 +108,3 @@\n-  ciObjArrayKlass*         as_obj_array_klass() {\n-    assert(is_obj_array_klass(), \"bad cast\");\n-    return (ciObjArrayKlass*)this;\n+  ciRefArrayKlass*         as_ref_array_klass() {\n+    assert(is_ref_array_klass(), \"bad cast\");\n+    return (ciRefArrayKlass*)this;\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciRefArrayKlass.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"ci\/ciUtilities.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -71,1 +72,2 @@\n-         _base_element_klass->is_flat_array_klass(), \"bad base klass\");\n+         _base_element_klass->is_flat_array_klass() ||\n+         _base_element_klass->is_ref_array_klass(), \"bad base klass\");\n@@ -138,1 +140,1 @@\n-ciArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n+ciObjArrayKlass* ciObjArrayKlass::make_impl(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n@@ -148,11 +150,8 @@\n-    if (refined_type) {\n-      ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n-      if (null_free) {\n-        assert(element_klass->is_inlinetype(), \"Only value class arrays can be null free\");\n-        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n-      }\n-      if (!atomic) {\n-        assert(element_klass->is_inlinetype(), \"Only value class arrays can be non-atomic\");\n-        props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NON_ATOMIC);\n-      }\n-      array = ObjArrayKlass::cast(array)->klass_with_properties(props, THREAD);\n+    if (!refined_type) {\n+      return CURRENT_THREAD_ENV->get_obj_array_klass(array);\n+    }\n+\n+    ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+    if (null_free) {\n+      assert(element_klass->is_inlinetype(), \"Only value class arrays can be null free\");\n+      props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n@@ -160,0 +159,5 @@\n+    if (!atomic) {\n+      assert(element_klass->is_inlinetype(), \"Only value class arrays can be non-atomic\");\n+      props = (ArrayKlass::ArrayProperties)(props | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+    }\n+    array = ObjArrayKlass::cast(array)->klass_with_properties(props, THREAD);\n@@ -163,1 +167,1 @@\n-      return CURRENT_THREAD_ENV->get_obj_array_klass(array);\n+      return CURRENT_THREAD_ENV->get_ref_array_klass(array);\n@@ -181,1 +185,1 @@\n-ciArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n+ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, bool refined_type, bool null_free, bool atomic) {\n@@ -194,1 +198,2 @@\n-  return (is_loaded() && is_refined()) ? this : nullptr;\n+  \/\/ This cannot be an exact klass because the refined types subtype it\n+  return nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -49,1 +50,1 @@\n-    return (ObjArrayKlass*)get_Klass();\n+    return ObjArrayKlass::cast(get_Klass());\n@@ -52,1 +53,1 @@\n-  static ciArrayKlass* make_impl(ciKlass* element_klass, bool refined_type = false, bool null_free = false, bool atomic = true);\n+  static ciObjArrayKlass* make_impl(ciKlass* element_klass, bool refined_type = false, bool null_free = false, bool atomic = true);\n@@ -71,1 +72,1 @@\n-  static ciArrayKlass* make(ciKlass* element_klass, bool refined_type = true, bool null_free = false, bool atomic = true);\n+  static ciObjArrayKlass* make(ciKlass* element_klass, bool refined_type = true, bool null_free = false, bool atomic = true);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"ci\/ciRefArrayKlass.hpp\"\n@@ -414,4 +415,8 @@\n-    } else if (k->is_flatArray_klass()) {\n-      return new (arena()) ciFlatArrayKlass(k);\n-    } else if (k->is_refArray_klass() || k->is_objArray_klass()) {\n-      return new (arena()) ciObjArrayKlass(k);\n+    } else if (k->is_objArray_klass()) {\n+      if (k->is_flatArray_klass()) {\n+        return new (arena()) ciFlatArrayKlass(k);\n+      } else if (k->is_refArray_klass()) {\n+        return new (arena()) ciRefArrayKlass(k);\n+      } else {\n+        return new (arena()) ciObjArrayKlass(k);\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_CI_CIREFARRAYKLASS_HPP\n+#define SHARE_VM_CI_CIREFARRAYKLASS_HPP\n+\n+#include \"ci\/ciObjArrayKlass.hpp\"\n+\n+\/\/ A ciRefArrayKlass represents the klass of a refined array in which the elements are stored as\n+\/\/ reference\n+class ciRefArrayKlass : public ciObjArrayKlass {\n+private:\n+  CI_PACKAGE_ACCESS\n+  friend class ciEnv;\n+\n+protected:\n+  ciRefArrayKlass(Klass* k) : ciObjArrayKlass(k) {\n+    assert(k->is_refArray_klass(), \"wrong type\");\n+  }\n+\n+  virtual const char* type_string() override { return \"ciRefArrayKlass\"; }\n+\n+public:\n+  virtual bool is_ref_array_klass() const override { return true; }\n+\n+  virtual ciKlass* exact_klass() override {\n+    return this;\n+  }\n+};\n+\n+#endif \/\/ SHARE_VM_CI_CIREFARRAYKLASS_HPP\n","filename":"src\/hotspot\/share\/ci\/ciRefArrayKlass.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -322,1 +322,1 @@\n-    \/\/ When (obj\/flat)Array meets typeArray, we also get Object.\n+    \/\/ When objArray meets typeArray, we also get Object.\n@@ -324,3 +324,2 @@\n-    \/\/ But when (obj\/flat)Array meets (obj\/flat)Array, we look carefully at element types.\n-    if ((k1->is_obj_array_klass() || k1->is_flat_array_klass()) &&\n-        (k2->is_obj_array_klass() || k2->is_flat_array_klass())) {\n+    \/\/ But when objArray meets objArray, we look carefully at element types.\n+    if (k1->is_obj_array_klass() && k2->is_obj_array_klass()) {\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -343,2 +343,1 @@\n-      assert(array->is_obj_array_klass() || array->is_flat_array_klass(),\n-             \"must be a flat or an object array type\");\n+      assert(array->is_obj_array_klass(), \"must be an object array type\");\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -497,8 +497,2 @@\n-      } else if (cik->is_flat_array_klass()) {\n-        ciKlass* cie = cik->as_flat_array_klass()->base_element_klass();\n-        cie->print_name_on(st);\n-        st->print(\"[%d]\", spobj->n_fields());\n-        int ndim = cik->as_array_klass()->dimension() - 1;\n-        while (ndim-- > 0) {\n-          st->print(\"[]\");\n-        }\n+      } else {\n+        assert(false, \"unexpected type %s\", cik->name()->as_utf8());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3686,3 +3686,1 @@\n-      if (klass()->is_obj_array_klass()) {\n-        _is_ptr_to_narrowoop = true;\n-      } else if (klass()->is_flat_array_klass() && field_offset != Offset::top && field_offset != Offset::bottom) {\n+      if (klass()->is_flat_array_klass() && field_offset != Offset::top && field_offset != Offset::bottom) {\n@@ -3700,1 +3698,3 @@\n-        _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(field_bt);\n+        _is_ptr_to_narrowoop = ::is_reference_type(field_bt);\n+      } else if (klass()->is_obj_array_klass()) {\n+        _is_ptr_to_narrowoop = true;\n@@ -3911,2 +3911,4 @@\n-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ false, try_for_exact, interface_handling);\n-    bool xk = klass->is_loaded() && klass->as_obj_array_klass()->is_refined();\n+    ciObjArrayKlass* array_klass = klass->as_obj_array_klass();\n+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_common(array_klass->element_klass(), \/* klass_change= *\/ false, try_for_exact, interface_handling);\n+    bool xk = array_klass->is_loaded() && array_klass->is_refined();\n+\n@@ -3914,8 +3916,27 @@\n-    const bool is_null_free = xk && klass->as_array_klass()->is_elem_null_free();\n-    if (is_null_free) {\n-      etype = etype->join_speculative(NOTNULL)->is_oopptr();\n-    }\n-    const TypeOopPtr* exact_etype = etype;\n-    if (etype->can_be_inline_type()) {\n-      \/\/ Use exact type if element can be an inline type\n-      exact_etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ true, \/* try_for_exact= *\/ true, interface_handling);\n+    bool flat;\n+    bool not_flat;\n+    bool is_null_free;\n+    bool not_null_free;\n+    bool atomic;\n+    if (xk) {\n+      flat = array_klass->is_flat_array_klass();\n+      not_flat = !flat;\n+      is_null_free = array_klass->is_elem_null_free();\n+      not_null_free = !is_null_free;\n+      atomic = array_klass->is_elem_atomic();\n+\n+      if (is_null_free) {\n+        etype = etype->join_speculative(NOTNULL)->is_oopptr();\n+      }\n+    } else {\n+      const TypeOopPtr* exact_etype = etype;\n+      if (etype->can_be_inline_type()) {\n+        \/\/ Use exact type if element can be an inline type\n+        exact_etype = TypeOopPtr::make_from_klass_common(klass->as_array_klass()->element_klass(), \/* klass_change= *\/ true, \/* try_for_exact= *\/ true, interface_handling);\n+      }\n+\n+      flat = false;\n+      bool not_inline = !exact_etype->can_be_inline_type();\n+      not_null_free = not_inline;\n+      not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n+      atomic = not_flat;\n@@ -3923,5 +3944,2 @@\n-    bool not_inline = !exact_etype->can_be_inline_type();\n-    bool not_null_free = xk ? !is_null_free : not_inline;\n-    bool not_flat = xk || !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->maybe_flat_in_array());\n-    bool atomic = not_flat;\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, not_flat, not_null_free, atomic);\n+\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, flat, not_flat, not_null_free, atomic);\n@@ -3942,10 +3960,0 @@\n-  } else if (klass->is_flat_array_klass()) {\n-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass(), trust_interfaces);\n-    const bool is_null_free = klass->as_array_klass()->is_elem_null_free();\n-    if (is_null_free) {\n-      etype = etype->join_speculative(NOTNULL)->is_oopptr();\n-    }\n-    bool atomic = klass->as_array_klass()->is_elem_atomic();\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true, \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free, atomic);\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, Offset(0));\n-    return arr;\n@@ -3982,1 +3990,1 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ false,\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ is_flat,\n@@ -4004,17 +4012,0 @@\n-  } else if (klass->is_flat_array_klass()) {\n-    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass(), trust_interfaces);\n-    bool is_null_free = o->as_array()->is_null_free();\n-    if (is_null_free) {\n-      etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n-    }\n-    bool is_atomic = o->as_array()->is_atomic();\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ true,\n-                                        \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free, \/* atomic= *\/ is_atomic);\n-    \/\/ We used to pass NotNull in here, asserting that the sub-arrays\n-    \/\/ are all not-null.  This is not true in generally, as code can\n-    \/\/ slam nullptrs down in the subarrays.\n-    if (make_constant) {\n-      return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, Offset(0));\n-    } else {\n-      return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, Offset(0));\n-    }\n@@ -6652,4 +6643,0 @@\n-  } else if (k->is_flat_array_klass()) {\n-    ciKlass* eklass = k->as_flat_array_klass()->element_klass();\n-    etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n-    k = nullptr;\n@@ -6686,1 +6673,1 @@\n-  if ((refined == is_refined_type()) || !klass_is_exact() || (!exact_klass()->is_obj_array_klass() && !exact_klass()->is_flat_array_klass())) {\n+  if ((refined == is_refined_type()) || !klass_is_exact() || !exact_klass()->is_obj_array_klass()) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":39,"deletions":52,"binary":false,"changes":91,"status":"modified"}]}