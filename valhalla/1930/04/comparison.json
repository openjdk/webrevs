{"files":[{"patch":"@@ -100,0 +100,1 @@\n+          --with-native-debug-symbols-level=1\n","filename":".github\/workflows\/build-alpine-linux.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+          --with-native-debug-symbols-level=1\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+          --with-native-debug-symbols-level=1\n","filename":".github\/workflows\/build-linux.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+          --with-native-debug-symbols-level=1\n","filename":".github\/workflows\/build-macos.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,17 @@\n+  UTIL_ARG_WITH(NAME: native-debug-symbols-level, TYPE: string,\n+    DEFAULT: \"\",\n+    RESULT: DEBUG_SYMBOLS_LEVEL,\n+    DESC: [set the native debug symbol level (GCC and Clang only)],\n+    DEFAULT_DESC: [toolchain default])\n+  AC_SUBST(DEBUG_SYMBOLS_LEVEL)\n+\n+  if test \"x${TOOLCHAIN_TYPE}\" = xgcc || \\\n+     test \"x${TOOLCHAIN_TYPE}\" = xclang; then\n+    DEBUG_SYMBOLS_LEVEL_FLAGS=\"-g\"\n+    if test \"x${DEBUG_SYMBOLS_LEVEL}\" != \"x\"; then\n+      DEBUG_SYMBOLS_LEVEL_FLAGS=\"-g${DEBUG_SYMBOLS_LEVEL}\"\n+      FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${DEBUG_SYMBOLS_LEVEL_FLAGS}],\n+          IF_FALSE: AC_MSG_ERROR(\"Debug info level ${DEBUG_SYMBOLS_LEVEL} is not supported\"))\n+    fi\n+  fi\n+\n@@ -96,2 +113,3 @@\n-    CFLAGS_DEBUG_SYMBOLS=\"-g -gdwarf-4\"\n-    ASFLAGS_DEBUG_SYMBOLS=\"-g\"\n+    # Debug info level should follow the debug format to be effective.\n+    CFLAGS_DEBUG_SYMBOLS=\"-gdwarf-4 ${DEBUG_SYMBOLS_LEVEL_FLAGS}\"\n+    ASFLAGS_DEBUG_SYMBOLS=\"${DEBUG_SYMBOLS_LEVEL_FLAGS}\"\n@@ -116,2 +134,3 @@\n-    CFLAGS_DEBUG_SYMBOLS=\"-g ${GDWARF_FLAGS}\"\n-    ASFLAGS_DEBUG_SYMBOLS=\"-g\"\n+    # Debug info level should follow the debug format to be effective.\n+    CFLAGS_DEBUG_SYMBOLS=\"${GDWARF_FLAGS} ${DEBUG_SYMBOLS_LEVEL_FLAGS}\"\n+    ASFLAGS_DEBUG_SYMBOLS=\"${DEBUG_SYMBOLS_LEVEL_FLAGS}\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-EscapeHash = $(subst \\#,\\\\\\#,$(subst \\\\\\#,\\#,$(strip $1)))\n+EscapeHash = $(subst $(HASH),\\$(HASH),$(subst \\$(HASH),$(HASH),$(strip $1)))\n","filename":"make\/common\/Utils.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-                        StubKind.LINT_CATEGORY.format(\"\\\"\" + lintCategory + \"\\\"\"),\n+                        StubKind.LINT_CATEGORY.format(toLintFieldName(lintCategory)),\n@@ -317,1 +317,1 @@\n-                            StubKind.LINT_CATEGORY.format(\"\\\"\" + lintCategory + \"\\\"\"),\n+                            StubKind.LINT_CATEGORY.format(toLintFieldName(lintCategory)),\n@@ -332,0 +332,5 @@\n+    String toLintFieldName(String lintCategory) {\n+        return lintCategory.toUpperCase()\n+                .replaceAll(\"-\", \"_\");\n+    }\n+\n","filename":"make\/langtools\/tools\/propertiesparser\/gen\/ClassGenerator.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  LintCategory.get({0}).get()\n+  LintCategory.{0}\n","filename":"make\/langtools\/tools\/propertiesparser\/resources\/templates.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n-#include <stdlib.h> \/\/ do not reorder\n-#include <stdint.h> \/\/ do not reorder\n-\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -33,0 +31,2 @@\n+#include <stdint.h>\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +26,2 @@\n-#ifndef _IMMEDIATE_H\n-#define _IMMEDIATE_H\n+#ifndef CPU_AARCH64_IMMEDIATE_AARCH64_HPP\n+#define CPU_AARCH64_IMMEDIATE_AARCH64_HPP\n@@ -28,1 +29,1 @@\n-#include <sys\/types.h>\n+#include <stdint.h>\n@@ -54,1 +55,1 @@\n-#endif \/\/ _IMMEDIATE_H\n+#endif \/\/ CPU_AARCH64_IMMEDIATE_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -6643,8 +6643,4 @@\n-\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes char[] to byte[] in ISO-8859-1\n-\/\/\n-\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n-\/\/\n-\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes char[] to byte[] in ASCII\n+\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n+\/\/     return the number of characters copied.\n+\/\/ - java\/lang\/StringUTF16.compress\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2816,8 +2816,4 @@\n-\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes char[] to byte[] in ISO-8859-1\n-\/\/\n-\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n-\/\/\n-\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes char[] to byte[] in ASCII\n+\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n+\/\/     return the number of characters copied.\n+\/\/ - java\/lang\/StringUTF16.compress\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -170,5 +170,0 @@\n-  if (FLAG_IS_DEFAULT(AlignVector)) {\n-    FLAG_SET_DEFAULT(AlignVector,\n-      unaligned_vector.value() != MISALIGNED_VECTOR_FAST);\n-  }\n-\n@@ -245,0 +240,5 @@\n+  if (FLAG_IS_DEFAULT(AlignVector)) {\n+    FLAG_SET_DEFAULT(AlignVector,\n+      unaligned_vector.value() != MISALIGNED_VECTOR_FAST);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -6892,1 +6892,1 @@\n-          jccb(Assembler::less, L_check_fill_32_bytes);\n+          jcc(Assembler::less, L_check_fill_32_bytes);\n@@ -7057,40 +7057,26 @@\n-\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n-\/\/\n-\/\/ @IntrinsicCandidate\n-\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n-\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n-\/\/     int i = 0;\n-\/\/     for (; i < len; i++) {\n-\/\/         char c = sa[sp++];\n-\/\/         if (c > '\\u00FF')\n-\/\/             break;\n-\/\/         da[dp++] = (byte) c;\n-\/\/     }\n-\/\/     return i;\n-\/\/ }\n-\/\/\n-\/\/ @IntrinsicCandidate\n-\/\/ int java.lang.StringCoding.encodeISOArray0(\n-\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n-\/\/   int i = 0;\n-\/\/   for (; i < len; i++) {\n-\/\/     char c = StringUTF16.getChar(sa, sp++);\n-\/\/     if (c > '\\u00FF')\n-\/\/       break;\n-\/\/     da[dp++] = (byte) c;\n-\/\/   }\n-\/\/   return i;\n-\/\/ }\n-\/\/\n-\/\/ @IntrinsicCandidate\n-\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n-\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n-\/\/   int i = 0;\n-\/\/   for (; i < len; i++) {\n-\/\/     char c = sa[sp++];\n-\/\/     if (c >= '\\u0080')\n-\/\/       break;\n-\/\/     da[dp++] = (byte) c;\n-\/\/   }\n-\/\/   return i;\n-\/\/ }\n+\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n+   \/\/@IntrinsicCandidate\n+   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n+   \/\/byte[] da, int dp, int len) {\n+   \/\/  int i = 0;\n+   \/\/  for (; i < len; i++) {\n+   \/\/    char c = StringUTF16.getChar(sa, sp++);\n+   \/\/    if (c > '\\u00FF')\n+   \/\/      break;\n+   \/\/    da[dp++] = (byte)c;\n+   \/\/  }\n+   \/\/  return i;\n+   \/\/}\n+   \/\/\n+   \/\/@IntrinsicCandidate\n+   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n+   \/\/    byte[] da, int dp, int len) {\n+   \/\/  int i = 0;\n+   \/\/  for (; i < len; i++) {\n+   \/\/    char c = sa[sp++];\n+   \/\/    if (c >= '\\u0080')\n+   \/\/      break;\n+   \/\/    da[dp++] = (byte)c;\n+   \/\/  }\n+   \/\/  return i;\n+   \/\/}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":27,"deletions":41,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-#ifdef _LP64\n@@ -40,3 +39,0 @@\n-#else\n-    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n-#endif \/\/ _LP64\n@@ -57,1 +53,0 @@\n-#ifdef _LP64\n@@ -61,1 +56,0 @@\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-\/\/ The implementation of integer registers for the x86\/x64 architectures.\n+\/\/ The implementation of integer registers for the x64 architectures.\n@@ -47,5 +47,3 @@\n-  enum {\n-    number_of_registers      = LP64_ONLY( 32 ) NOT_LP64( 8 ),\n-    number_of_byte_registers = LP64_ONLY( 32 ) NOT_LP64( 4 ),\n-    max_slots_per_register   = LP64_ONLY(  2 ) NOT_LP64( 1 )\n-  };\n+  static const int number_of_registers      = 32;\n+  static const int number_of_byte_registers = 32;\n+  static const int max_slots_per_register   =  2;\n@@ -82,1 +80,0 @@\n-#ifdef _LP64\n@@ -86,1 +83,0 @@\n-#endif \/\/ _LP64\n@@ -119,3 +115,2 @@\n-#ifdef _LP64\n-constexpr Register r8  = as_Register( 8);\n-constexpr Register r9  = as_Register( 9);\n+constexpr Register r8  = as_Register(8);\n+constexpr Register r9  = as_Register(9);\n@@ -144,1 +139,0 @@\n-#endif \/\/ _LP64\n@@ -157,4 +151,2 @@\n-  enum {\n-    number_of_registers    = 8,\n-    max_slots_per_register = 2\n-  };\n+  static const int number_of_registers    = 8;\n+  static const int max_slots_per_register = 2;\n@@ -220,4 +212,2 @@\n-  enum {\n-    number_of_registers    = LP64_ONLY( 32 ) NOT_LP64(  8 ),\n-    max_slots_per_register = LP64_ONLY( 16 ) NOT_LP64( 16 )   \/\/ 512-bit\n-  };\n+  static const int number_of_registers    =  32;\n+  static const int max_slots_per_register =  16; \/\/ 512-bit\n@@ -253,1 +243,0 @@\n-#ifdef _LP64\n@@ -257,1 +246,0 @@\n-#endif \/\/ _LP64\n@@ -290,1 +278,0 @@\n-#ifdef _LP64\n@@ -315,1 +302,0 @@\n-#endif \/\/ _LP64\n@@ -397,5 +383,4 @@\n-  enum {\n-    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n-    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n-    max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register,\n-    max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register,\n+    static const int max_gpr = Register::number_of_registers * Register::max_slots_per_register;\n+    static const int max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register;\n+    static const int max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register;\n+    static const int max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register;\n@@ -407,9 +392,2 @@\n-\n-    \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n-    \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n-    \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n-    \/\/ added for 32 bit jvm.\n-    number_of_registers = max_kpr +       \/\/ gpr\/fpr\/xmm\/kpr\n-                          NOT_LP64( 8 + ) \/\/ FILL0-FILL7 in x86_32.ad\n-                          1               \/\/ eflags\n-  };\n+    static const int number_of_registers = max_kpr + \/\/ gpr\/fpr\/xmm\/kpr\n+                                           1;        \/\/ eflags\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":17,"deletions":39,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-#ifdef AMD64\n@@ -37,1 +36,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,4 +55,1 @@\n-\n-  assert( is_Register(), \"must be\");\n-  \/\/ Yuk\n-#ifdef AMD64\n+  assert(is_Register(), \"must be\");\n@@ -60,3 +57,0 @@\n-#else\n-  return ::as_Register(value());\n-#endif \/\/ AMD64\n@@ -85,3 +79,0 @@\n-#ifndef AMD64\n-  if (is_Register()) return true;\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-  return VMRegImpl::as_VMReg(encoding() LP64_ONLY( << 1 ));\n+  return VMRegImpl::as_VMReg(encoding() << 1);\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2647,2 +2647,2 @@\n-static bool is_ndd_demotable(const MachNode* mdef) {\n-  return ((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0);\n+static bool is_ndd_demotable_opr1(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_opr1) != 0);\n@@ -2651,2 +2651,2 @@\n-static bool is_ndd_demotable_commutative(const MachNode* mdef) {\n-  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n+static bool is_ndd_demotable_opr2(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_opr2) != 0);\n@@ -2655,2 +2655,3 @@\n-static bool is_demotion_candidate(const MachNode* mdef) {\n-  return (is_ndd_demotable(mdef) || is_ndd_demotable_commutative(mdef));\n+#ifdef ASSERT\n+static bool is_ndd_demotable(const MachNode* mdef) {\n+  return (is_ndd_demotable_opr1(mdef) || is_ndd_demotable_opr2(mdef));\n@@ -2658,0 +2659,1 @@\n+#endif\n@@ -2667,2 +2669,2 @@\n-    assert(oper_index != 1 || !is_demotion_candidate(mdef), \"%s\", mdef->Name());\n-    assert(oper_index != 2 || !is_ndd_demotable_commutative(mdef), \"%s\", mdef->Name());\n+    assert(oper_index != 1 || !is_ndd_demotable_opr1(mdef), \"%s\", mdef->Name());\n+    assert(oper_index != 2 || !is_ndd_demotable_opr2(mdef), \"%s\", mdef->Name());\n@@ -2676,1 +2678,0 @@\n-    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n@@ -2683,1 +2684,1 @@\n-    assert(!is_demotion_candidate(mdef), \"%s\", mdef->Name());\n+    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n@@ -2695,1 +2696,1 @@\n-    return is_demotion_candidate(mdef);\n+    return is_ndd_demotable_opr1(mdef);\n@@ -2700,1 +2701,1 @@\n-    return is_ndd_demotable_commutative(mdef);\n+    return is_ndd_demotable_opr2(mdef);\n@@ -2902,3 +2903,3 @@\n-    Flag_ndd_demotable        = Node::_last_flag << 12,\n-    Flag_ndd_demotable_commutative = Node::_last_flag << 13,\n-    _last_flag                = Flag_ndd_demotable_commutative\n+    Flag_ndd_demotable_opr1   = Node::_last_flag << 12,\n+    Flag_ndd_demotable_opr2   = Node::_last_flag << 13,\n+    _last_flag                = Flag_ndd_demotable_opr2\n@@ -9961,1 +9962,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -9989,1 +9990,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -10032,1 +10033,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -10089,1 +10090,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -10144,1 +10145,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -10251,1 +10252,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -10279,1 +10280,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -10322,1 +10323,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -10378,1 +10379,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -10433,1 +10434,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -11148,1 +11149,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11162,1 +11163,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11205,1 +11206,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11263,1 +11264,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11277,1 +11278,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11320,1 +11321,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11392,1 +11393,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr2);\n@@ -11420,1 +11421,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11461,1 +11462,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr2);\n@@ -11489,1 +11490,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11534,1 +11535,1 @@\n-  flag(PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11576,1 +11577,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11628,1 +11629,1 @@\n-  flag(PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11670,1 +11671,1 @@\n-  flag(PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11945,1 +11946,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -11974,1 +11975,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12081,1 +12082,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12188,1 +12189,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12296,1 +12297,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12325,1 +12326,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12432,1 +12433,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12539,1 +12540,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12711,1 +12712,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12776,1 +12777,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12843,1 +12844,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12908,1 +12909,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12986,1 +12987,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13079,1 +13080,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13123,1 +13124,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13323,1 +13324,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13352,1 +13353,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13366,1 +13367,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13410,1 +13411,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13486,1 +13487,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13512,1 +13513,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -13543,1 +13544,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13589,1 +13590,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13668,1 +13669,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13724,1 +13725,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13768,1 +13769,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13971,1 +13972,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -14026,1 +14027,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -14040,1 +14041,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -14085,1 +14086,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -14164,1 +14165,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -14190,1 +14191,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -14221,1 +14222,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -14267,1 +14268,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -16935,1 +16936,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -16987,1 +16988,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":77,"deletions":76,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -28,3 +29,0 @@\n-#include <stdlib.h>\n-#include <dlfcn.h>\n-#include <string.h>\n@@ -35,0 +33,2 @@\n+#include <dlfcn.h>\n+#include <string.h>\n","filename":"src\/hotspot\/os\/aix\/libodm_aix.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n+\n@@ -36,1 +38,0 @@\n-#include <stdlib.h>\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -49,1 +50,0 @@\n-#include <stdlib.h>\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -37,1 +38,0 @@\n-#include <stdlib.h>\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,3 +69,0 @@\n-#ifndef O_CLOEXEC\n-#define O_CLOEXEC                        02000000\n-#endif\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -99,1 +100,0 @@\n-# include <stdlib.h>\n@@ -4881,23 +4881,1 @@\n-  \/\/ might fork and exec without closing all appropriate file descriptors,\n-  \/\/ and this in turn might:\n-  \/\/\n-  \/\/ - cause end-of-file to fail to be detected on some file\n-  \/\/   descriptors, resulting in mysterious hangs, or\n-  \/\/\n-  \/\/ - might cause an fopen in the subprocess to fail on a system\n-  \/\/   suffering from bug 1085341.\n-  \/\/\n-  \/\/ (Yes, the default setting of the close-on-exec flag is a Unix\n-  \/\/ design flaw)\n-  \/\/\n-  \/\/ See:\n-  \/\/ 1085341: 32-bit stdio routines should support file descriptors >255\n-  \/\/ 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n-  \/\/ 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n-  \/\/\n-  \/\/ Modern Linux kernels (after 2.6.23 2007) support O_CLOEXEC with open().\n-  \/\/ O_CLOEXEC is preferable to using FD_CLOEXEC on an open file descriptor\n-  \/\/ because it saves a system call and removes a small window where the flag\n-  \/\/ is unset.  On ancient Linux kernels the O_CLOEXEC flag will be ignored\n-  \/\/ and we fall back to using FD_CLOEXEC (see below).\n-#ifdef O_CLOEXEC\n+  \/\/ might fork and exec without closing all appropriate file descriptors.\n@@ -4905,1 +4883,0 @@\n-#endif\n@@ -4928,15 +4905,0 @@\n-#ifdef FD_CLOEXEC\n-  \/\/ Validate that the use of the O_CLOEXEC flag on open above worked.\n-  \/\/ With recent kernels, we will perform this check exactly once.\n-  static sig_atomic_t O_CLOEXEC_is_known_to_work = 0;\n-  if (!O_CLOEXEC_is_known_to_work) {\n-    int flags = ::fcntl(fd, F_GETFD);\n-    if (flags != -1) {\n-      if ((flags & FD_CLOEXEC) != 0)\n-        O_CLOEXEC_is_known_to_work = 1;\n-      else\n-        ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n-    }\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -43,1 +44,0 @@\n-#include <stdlib.h>\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,3 @@\n+\/\/ POSIX puts _exit in <unistd.h>.\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void _exit(int), \/* not noexcept *\/, \"use os::exit\")\n+\n@@ -42,6 +45,0 @@\n-\/\/ These are unimplementable for Windows, and they aren't useful for a\n-\/\/ POSIX implementation of NMT either.\n-\/\/ https:\/\/stackoverflow.com\/questions\/62962839\/stdaligned-alloc-missing-from-visual-studio-2019\n-FORBID_C_FUNCTION(int posix_memalign(void**, size_t, size_t), noexcept, \"don't use\");\n-FORBID_C_FUNCTION(void* aligned_alloc(size_t, size_t), noexcept, \"don't use\");\n-\n","filename":"src\/hotspot\/os\/posix\/forbiddenFunctions_posix.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -460,6 +461,4 @@\n-  if (base != nullptr && addr != base) {\n-    if (!os::release_memory(addr, size)) {\n-      warning(\"Could not release memory on unsuccessful file mapping\");\n-    }\n-    return nullptr;\n-  }\n+\n+  \/\/ The requested address should be the same as the returned address when using MAP_FIXED\n+  \/\/ as per POSIX.\n+  assert(base == nullptr || addr == base, \"base should equal addr when using MAP_FIXED\");\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026 SAP SE. All rights reserved.\n@@ -949,1 +949,1 @@\n-        warning(\"Insufficient space for shared memory file:\\n   %s\\nTry using the -Djava.io.tmpdir= option to select an alternate temp location.\\n\", filename);\n+        warning(\"Insufficient space for shared memory file: %s\/%s\\n\", dirname, filename);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -31,0 +32,2 @@\n+#include <unistd.h>\n+\n@@ -37,0 +40,2 @@\n+[[noreturn]] inline void _exit(int status) { ::_exit(status); }\n+\n","filename":"src\/hotspot\/os\/posix\/permitForbiddenFunctions_posix.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -954,0 +954,26 @@\n+#if defined(LINUX)\n+\/\/ Additional kernel si_code definitions that are only exported by\n+\/\/ more recent glibc distributions, so we have to hard-code the values.\n+#ifndef BUS_MCEERR_AR \/\/ glibc 2.17\n+#define BUS_MCEERR_AR 4\n+#define BUS_MCEERR_AO 5\n+#endif\n+\n+#ifndef SEGV_PKUERR \/\/ glibc 2.27\n+#define SEGV_PKUERR 4\n+#endif\n+\n+#ifndef SYS_SECCOMP \/\/ glibc 2.28\n+#define SYS_SECCOMP 1\n+#endif\n+\n+#ifndef TRAP_BRANCH \/\/ glibc 2.30\n+#define TRAP_BRANCH 3\n+#endif\n+\n+#ifndef TRAP_HWBKPT \/\/ not glibc version specific - gdb related\n+#define TRAP_HWBKPT 4\n+#endif\n+\n+#endif \/\/ LINUX\n+\n@@ -979,0 +1005,1 @@\n+    { SIGSEGV, SEGV_PKUERR,  \"SEGV_PKUERR\",  \"Protection key checking failure.\" },\n@@ -987,0 +1014,6 @@\n+#if defined(LINUX)\n+    { SIGBUS,  BUS_MCEERR_AR,\"BUS_MCEERR_AR\",\"Hardware memory error consumed on a machine check: action required.\" },\n+    { SIGBUS,  BUS_MCEERR_AO,\"BUS_MCEERR_AO\",\"Hardware memory error detected in process but not consumed: action optional.\" },\n+\n+    { SIGSYS,  SYS_SECCOMP,  \"SYS_SECCOMP\",  \"Secure computing (seccomp) filter failure.\" },\n+#endif\n@@ -989,0 +1022,4 @@\n+#if defined(LINUX)\n+    { SIGTRAP, TRAP_BRANCH,  \"TRAP_BRANCH\",  \"Process taken branch trap.\" },\n+    { SIGTRAP, TRAP_HWBKPT,  \"TRAP_HWBKPT\",  \"Hardware breakpoint\/watchpoint.\" },\n+#endif\n@@ -996,0 +1033,1 @@\n+    { SIGPOLL, POLL_IN,      \"POLL_IN\",      \"Data input available.\" },\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -37,0 +38,2 @@\n+[[noreturn]] inline void _exit(int status) { ::_exit(status); }\n+\n","filename":"src\/hotspot\/os\/windows\/permitForbiddenFunctions_windows.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/prefetch_aix_ppc.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -66,1 +67,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/prefetch_bsd_aarch64.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -61,1 +62,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/prefetch_bsd_x86.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/prefetch.hpp\"\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/prefetch_bsd_zero.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -62,1 +63,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/prefetch_linux_aarch64.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -60,1 +61,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/prefetch.hpp\"\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/prefetch_linux_arm.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -65,1 +66,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/prefetch_linux_ppc.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -64,1 +65,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/prefetch.hpp\"\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/prefetch_linux_riscv.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -65,1 +66,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/prefetch.hpp\"\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/prefetch_linux_s390.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -62,1 +63,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/prefetch_linux_x86.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/prefetch.hpp\"\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/prefetch_linux_zero.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -57,1 +58,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * Copyright (c) 2020, 2026, Microsoft Corporation. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/prefetch_windows_aarch64.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/prefetch.hpp\"\n+\/\/ Included in runtime\/prefetch.inline.hpp\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/prefetch_windows_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,4 @@\n+    if (CDSConfig::is_dumping_dynamic_archive()) {\n+      \/\/ This is difficult to handle. See JDK-8374639\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-    *((narrowOop*)field_addr_in_buffer) = checked_cast<narrowOop>(addr);\n+    *((narrowOop*)field_addr_in_buffer) = CompressedOops::narrow_oop_cast(addr);\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2178,1 +2178,0 @@\n-    DynamicArchive::setup_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -574,1 +574,6 @@\n-        log_debug(cds, dynamic)(\"Skipping class (excluded): %s\", klass->external_name());\n+        aot_log_trace(aot)(\"pointer set to null: class (excluded): %s\", klass->external_name());\n+        return set_to_null;\n+      }\n+      if (klass->is_array_klass() && CDSConfig::is_dumping_dynamic_archive()) {\n+        ResourceMark rm;\n+        aot_log_trace(aot)(\"pointer set to null: array class not supported in dynamic region: %s\", klass->external_name());\n@@ -993,2 +998,0 @@\n-\n-  DynamicArchive::make_array_klasses_shareable();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+#include \"oops\/array.hpp\"\n@@ -98,1 +99,0 @@\n-  void gather_array_klasses();\n@@ -135,1 +135,0 @@\n-    gather_array_klasses();\n@@ -162,1 +161,0 @@\n-      DynamicArchive::dump_array_klasses();\n@@ -178,2 +176,0 @@\n-    DynamicArchive::post_dump();\n-\n@@ -188,24 +184,0 @@\n-    iterate_primitive_array_klasses(it);\n-  }\n-\n-  void iterate_primitive_array_klasses(MetaspaceClosure* it) {\n-    for (int i = T_BOOLEAN; i <= T_LONG; i++) {\n-      assert(is_java_primitive((BasicType)i), \"sanity\");\n-      Klass* k = Universe::typeArrayKlass((BasicType)i);  \/\/ this give you \"[I\", etc\n-      assert(AOTMetaspace::in_aot_cache_static_region((void*)k),\n-        \"one-dimensional primitive array should be in static archive\");\n-      ArrayKlass* ak = ArrayKlass::cast(k);\n-      while (ak != nullptr && ak->in_aot_cache()) {\n-        Klass* next_k = ak->array_klass_or_null();\n-        if (next_k != nullptr) {\n-          ak = ArrayKlass::cast(next_k);\n-        } else {\n-          ak = nullptr;\n-        }\n-      }\n-      if (ak != nullptr) {\n-        assert(ak->dimension() > 1, \"sanity\");\n-        \/\/ this is the lowest dimension that's not in the static archive\n-        it->push(&ak);\n-      }\n-    }\n@@ -370,23 +342,0 @@\n-void DynamicArchiveBuilder::gather_array_klasses() {\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    if (klasses()->at(i)->is_objArray_klass()) {\n-      ObjArrayKlass* oak = ObjArrayKlass::cast(klasses()->at(i));\n-      if (oak->is_refined_objArray_klass()) {\n-        oak = ObjArrayKlass::cast(oak->super());\n-      }\n-      Klass* elem = oak->element_klass();\n-      if (AOTMetaspace::in_aot_cache_static_region(elem)) {\n-        \/\/ Only capture the array klass whose element_klass is in the static archive.\n-        \/\/ During run time, setup (see DynamicArchive::setup_array_klasses()) is needed\n-        \/\/ so that the element_klass can find its array klasses from the dynamic archive.\n-        DynamicArchive::append_array_klass(oak);\n-      } else {\n-        \/\/ The element_klass and its array klasses are in the same archive.\n-        assert(!AOTMetaspace::in_aot_cache_static_region(oak),\n-          \"we should not gather klasses that are already in the static archive\");\n-      }\n-    }\n-  }\n-  log_debug(aot)(\"Total array klasses gathered for dynamic archive: %d\", DynamicArchive::num_array_klasses());\n-}\n-\n@@ -409,5 +358,0 @@\n-\/\/ _array_klasses and _dynamic_archive_array_klasses only hold the array klasses\n-\/\/ which have element klass in the static archive.\n-GrowableArray<ObjArrayKlass*>* DynamicArchive::_array_klasses = nullptr;\n-Array<ObjArrayKlass*>* DynamicArchive::_dynamic_archive_array_klasses = nullptr;\n-\n@@ -417,64 +361,0 @@\n-  soc->do_ptr(&_dynamic_archive_array_klasses);\n-}\n-\n-void DynamicArchive::append_array_klass(ObjArrayKlass* ak) {\n-  if (_array_klasses == nullptr) {\n-    _array_klasses = new (mtClassShared) GrowableArray<ObjArrayKlass*>(50, mtClassShared);\n-  }\n-  _array_klasses->append(ak);\n-}\n-\n-void DynamicArchive::dump_array_klasses() {\n-  assert(CDSConfig::is_dumping_dynamic_archive(), \"sanity\");\n-  if (_array_klasses != nullptr) {\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    int num_array_klasses = _array_klasses->length();\n-    _dynamic_archive_array_klasses =\n-        ArchiveBuilder::new_ro_array<ObjArrayKlass*>(num_array_klasses);\n-    for (int i = 0; i < num_array_klasses; i++) {\n-      builder->write_pointer_in_buffer(_dynamic_archive_array_klasses->adr_at(i), _array_klasses->at(i));\n-    }\n-  }\n-}\n-\n-void DynamicArchive::setup_array_klasses() {\n-  if (_dynamic_archive_array_klasses != nullptr) {\n-    for (int i = 0; i < _dynamic_archive_array_klasses->length(); i++) {\n-      ObjArrayKlass* oak = _dynamic_archive_array_klasses->at(i);\n-      Klass* elm = oak->element_klass();\n-      assert(AOTMetaspace::in_aot_cache_static_region((void*)elm), \"must be\");\n-      \/\/ Higher dimension may have been set when doing setup on ObjArrayKlass\n-      if (!oak->is_refined_objArray_klass()) {\n-        if (elm->is_instance_klass()) {\n-          assert(InstanceKlass::cast(elm)->array_klasses() == nullptr, \"must be\");\n-          InstanceKlass::cast(elm)->set_array_klasses(oak);\n-        } else {\n-          assert(elm->is_array_klass(), \"sanity\");\n-          assert(ArrayKlass::cast(elm)->higher_dimension() == nullptr, \"must be\");\n-          ArrayKlass::cast(elm)->set_higher_dimension(oak);\n-        }\n-      }\n-    }\n-    log_debug(aot)(\"Total array klasses read from dynamic archive: %d\", _dynamic_archive_array_klasses->length());\n-  }\n-}\n-\n-void DynamicArchive::make_array_klasses_shareable() {\n-  if (_array_klasses != nullptr) {\n-    int num_array_klasses = _array_klasses->length();\n-    for (int i = 0; i < num_array_klasses; i++) {\n-      ObjArrayKlass* k = ArchiveBuilder::current()->get_buffered_addr(_array_klasses->at(i));\n-      k->remove_unshareable_info();\n-    }\n-  }\n-}\n-\n-void DynamicArchive::post_dump() {\n-  if (_array_klasses != nullptr) {\n-    delete _array_klasses;\n-    _array_klasses = nullptr;\n-  }\n-}\n-\n-int DynamicArchive::num_array_klasses() {\n-  return _array_klasses != nullptr ? _array_klasses->length() : 0;\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":122,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"classfile\/compactHashtable.hpp\"\n@@ -31,3 +30,0 @@\n-#include \"memory\/memRegion.hpp\"\n-#include \"oops\/array.hpp\"\n-#include \"oops\/oop.hpp\"\n@@ -35,1 +31,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -62,3 +57,0 @@\n-private:\n-  static GrowableArray<ObjArrayKlass*>* _array_klasses;\n-  static Array<ObjArrayKlass*>* _dynamic_archive_array_klasses;\n@@ -71,3 +63,0 @@\n-  static void dump_array_klasses();\n-  static void setup_array_klasses();\n-  static void append_array_klass(ObjArrayKlass* oak);\n@@ -75,3 +64,0 @@\n-  static void make_array_klasses_shareable();\n-  static void post_dump();\n-  static int  num_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -84,1 +85,0 @@\n-#include <stdlib.h>\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -4344,4 +4344,0 @@\n-bool jdk_internal_foreign_abi_NativeEntryPoint::is_instance(oop obj) {\n-  return obj != nullptr && is_subclass(obj->klass());\n-}\n-\n@@ -4384,4 +4380,0 @@\n-bool jdk_internal_foreign_abi_ABIDescriptor::is_instance(oop obj) {\n-  return obj != nullptr && is_subclass(obj->klass());\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1188,7 +1188,0 @@\n-  \/\/ Testers\n-  static bool is_subclass(Klass* klass) {\n-    return vmClasses::NativeEntryPoint_klass() != nullptr &&\n-      klass->is_subclass_of(vmClasses::NativeEntryPoint_klass());\n-  }\n-  static bool is_instance(oop obj);\n-\n@@ -1225,7 +1218,0 @@\n-\n-  \/\/ Testers\n-  static bool is_subclass(Klass* klass) {\n-    return vmClasses::ABIDescriptor_klass() != nullptr &&\n-      klass->is_subclass_of(vmClasses::ABIDescriptor_klass());\n-  }\n-  static bool is_instance(oop obj);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n+   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n@@ -437,1 +437,1 @@\n-   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n+   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n@@ -443,1 +443,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n+   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1385,0 +1385,1 @@\n+  SET_ADDRESS(_extrs, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr());\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CPPSTDLIB_CSTDLIB_HPP\n+#define SHARE_CPPSTDLIB_CSTDLIB_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+\n+\/\/ HotSpot usage for <cstdlib>:\n+\/\/\n+\/\/ Some functions are explicitly forbidden below. That may not be a complete\n+\/\/ list of all the functions we should forbid.\n+\/\/\n+\/\/ We assume <cstdlib> provides definitions in the global namespace, in\n+\/\/ addition to providing them in the std namespace. We prefer to use the names\n+\/\/ in the global namespace.\n+\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+#include \"utilities\/vmassert_uninstall.hpp\"\n+\n+#include <cstdlib>\n+\n+#include \"utilities\/vmassert_reinstall.hpp\" \/\/ don't reorder\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+\/\/ AIX may define malloc and calloc as macros when certain other features are\n+\/\/ present, causing us all sorts of grief.\n+\/\/ https:\/\/www.ibm.com\/docs\/en\/openxl-c-and-cpp-aix\/17.1.4?topic=compilers-memory-allocation\n+\/\/ Replace the macro definitions with something we can work with.\n+\/\/ AIX 7.3 no longer uses macro renaming when building with clang, instead\n+\/\/ using the same asm replacement approach as used below.  This workaround can\n+\/\/ be removed once earlier versions are no longer supported as build platforms.\n+#if defined(AIX) && (defined(__VEC__) || defined(__AIXVEC))\n+#if defined(malloc) || defined(calloc)\n+#if !defined(malloc) || !defined(calloc)\n+#error \"Inconsistent alloc macro mappings, expected both to be mapped.\"\n+#endif\n+\/\/ Remove the macros.\n+#undef malloc\n+#undef calloc\n+\/\/ Implement the mapping using gcc\/clang asm name mapping.\n+extern \"C\" {\n+extern void* malloc(size_t) noexcept asm(\"vec_malloc\");\n+extern void* calloc(size_t, size_t) noexcept asm(\"vec_calloc\");\n+} \/\/ extern \"C\"\n+\/\/ Because the macros are in place when <cstdlib> brings names into the std\n+\/\/ namespace, macro replacement causes the expanded names to be added instead\n+\/\/ of the intended names. We can't remove std::vec_malloc and std::vec_calloc,\n+\/\/ but we do add the standard names in case someone uses them.\n+namespace std {\n+using ::malloc;\n+using ::calloc;\n+} \/\/ namespace std\n+#endif \/\/ Macro definition for malloc or calloc\n+#endif \/\/ AIX altivec allocator support\n+\n+\/\/ Prefer os:: variants of these.\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void exit(int), noexcept, \"use os::exit\")\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void _Exit(int), noexcept, \"use os::exit\")\n+\n+\/\/ Windows puts _exit in <stdlib.h>. POSIX puts it in <unistd.h>.\n+\/\/ We can't forbid it here when using clang if it's not in <stdlib.h> - see\n+\/\/ the clang definition for FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE.\n+#ifdef _WINDOWS\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void _exit(int), \/* not noexcept *\/, \"use os::exit\")\n+#endif \/\/ _WINDOWS\n+\n+\/\/ These functions return raw C-heap pointers or, in case of free(), take raw\n+\/\/ C-heap pointers.  We generally want allocation to be done through NMT, using\n+\/\/ os::malloc and friends.\n+FORBID_IMPORTED_C_FUNCTION(void* malloc(size_t), noexcept, \"use os::malloc\");\n+FORBID_IMPORTED_C_FUNCTION(void free(void*), noexcept, \"use os::free\");\n+FORBID_IMPORTED_C_FUNCTION(void* calloc(size_t, size_t), noexcept, \"use os::malloc and zero out manually\");\n+FORBID_IMPORTED_C_FUNCTION(void* realloc(void*, size_t), noexcept, \"use os::realloc\");\n+\n+\/\/ These are not provided (and are unimplementable?) by Windows.\n+\/\/ https:\/\/stackoverflow.com\/questions\/62962839\/stdaligned-alloc-missing-from-visual-studio-2019\n+\/\/ They also aren't useful for a POSIX implementation of NMT.\n+#ifndef _WINDOWS\n+FORBID_C_FUNCTION(void* aligned_alloc(size_t, size_t), noexcept, \"don't use\");\n+FORBID_C_FUNCTION(int posix_memalign(void**, size_t, size_t), noexcept, \"don't use\");\n+#endif \/\/ !_WINDOWS\n+\n+#endif \/\/ SHARE_CPPSTDLIB_CSTDLIB_HPP\n","filename":"src\/hotspot\/share\/cppstdlib\/cstdlib.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -65,2 +65,0 @@\n-  _last_counter_update = 0;\n-  _last_heap_print = 0;\n@@ -80,0 +78,1 @@\n+  _monitoring_support->mark_ready();\n@@ -104,1 +103,1 @@\n-HeapWord* EpsilonHeap::allocate_work(size_t size, bool verbose) {\n+HeapWord* EpsilonHeap::allocate_work(size_t size) {\n@@ -154,4 +153,8 @@\n-  \/\/ Allocation successful, update counters\n-  if (verbose) {\n-    size_t last = _last_counter_update;\n-    if ((used - last >= _step_counter_update) && AtomicAccess::cmpxchg(&_last_counter_update, last, used) == last) {\n+  \/\/ Allocation successful, update counters and print status.\n+  \/\/ At this point, some diagnostic subsystems might not yet be initialized.\n+  \/\/ We pretend the printout happened either way. This keeps allocation path\n+  \/\/ from obsessively checking the subsystems' status on every allocation.\n+  size_t last_counter = _last_counter_update.load_relaxed();\n+  if ((used - last_counter >= _step_counter_update) &&\n+      _last_counter_update.compare_set(last_counter, used)) {\n+    if (_monitoring_support->is_ready()) {\n@@ -162,5 +165,5 @@\n-  \/\/ ...and print the occupancy line, if needed\n-  if (verbose) {\n-    size_t last = _last_heap_print;\n-    if ((used - last >= _step_heap_print) && AtomicAccess::cmpxchg(&_last_heap_print, last, used) == last) {\n-      print_heap_info(used);\n+  size_t last_heap = _last_heap_print.load_relaxed();\n+  if ((used - last_heap >= _step_heap_print) &&\n+      _last_heap_print.compare_set(last_heap, used)) {\n+    print_heap_info(used);\n+    if (Metaspace::initialized()) {\n@@ -268,2 +271,1 @@\n-  \/\/ Cannot use verbose=true because Metaspace is not initialized\n-  return allocate_work(size, \/* verbose = *\/false);\n+  return allocate_work(size);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -48,2 +49,2 @@\n-  volatile size_t _last_counter_update;\n-  volatile size_t _last_heap_print;\n+  Atomic<size_t> _last_counter_update;\n+  Atomic<size_t> _last_heap_print;\n@@ -86,1 +87,1 @@\n-  HeapWord* allocate_work(size_t size, bool verbose = true);\n+  HeapWord* allocate_work(size_t size);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  assert(is_ready(), \"Must be ready\");\n@@ -113,0 +114,8 @@\n+\n+bool EpsilonMonitoringSupport::is_ready() {\n+  return _ready.load_acquire();\n+}\n+\n+void EpsilonMonitoringSupport::mark_ready() {\n+  _ready.release_store(true);\n+}\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonMonitoringSupport.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -38,0 +39,1 @@\n+  Atomic<bool> _ready;\n@@ -41,0 +43,2 @@\n+  bool is_ready();\n+  void mark_ready();\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonMonitoringSupport.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -193,1 +194,2 @@\n-    FLAG_SET_ERGO(G1ConcRefinementThreads, ParallelGCThreads);\n+    const JVMTypedFlagLimit<uint>* conc_refinement_threads_limits = JVMFlagLimit::get_range_at(FLAG_MEMBER_ENUM(G1ConcRefinementThreads))->cast<uint>();\n+    FLAG_SET_ERGO(G1ConcRefinementThreads, MIN2(ParallelGCThreads, conc_refinement_threads_limits->max()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -689,1 +689,2 @@\n-  if (policy()->need_to_start_conc_mark(\"concurrent humongous allocation\",\n+  \/\/ Only try that if we can actually perform a GC.\n+  if (is_init_completed() && policy()->need_to_start_conc_mark(\"concurrent humongous allocation\",\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-#include \"runtime\/prefetch.hpp\"\n+#include \"runtime\/prefetch.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/prefetch.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-#include \"runtime\/prefetch.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+#include \"runtime\/prefetch.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -199,2 +200,2 @@\n-      static volatile uint32_t counter=0;\n-      if (AtomicAccess::add(&counter, 1u) % 10 == 0) {\n+      static Atomic<uint32_t> counter{0};\n+      if (counter.add_then_fetch(1u) % 10 == 0) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -51,1 +51,1 @@\n-  AtomicAccess::release_store(&_has_terminated, true);\n+  _has_terminated.release_store(true);\n@@ -60,1 +60,1 @@\n-  AtomicAccess::release_store_fence(&_should_terminate, true);\n+  _should_terminate.release_store_fence(true);\n@@ -66,1 +66,1 @@\n-  while (!_has_terminated) {\n+  while (!_has_terminated.load_relaxed()) {\n@@ -72,1 +72,1 @@\n-  return AtomicAccess::load_acquire(&_should_terminate);\n+  return _should_terminate.load_acquire();\n@@ -76,1 +76,1 @@\n-  return AtomicAccess::load_acquire(&_has_terminated);\n+  return _has_terminated.load_acquire();\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -34,2 +35,2 @@\n-  volatile bool _should_terminate;\n-  volatile bool _has_terminated;\n+  Atomic<bool> _should_terminate;\n+  Atomic<bool> _has_terminated;\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -63,1 +63,1 @@\n-volatile bool GCLocker::_is_gc_request_pending;\n+Atomic<bool> GCLocker::_is_gc_request_pending{false};\n@@ -65,1 +65,1 @@\n-DEBUG_ONLY(uint64_t GCLocker::_verify_in_cr_count;)\n+DEBUG_ONLY(Atomic<uint64_t> GCLocker::_verify_in_cr_count{0};)\n@@ -70,3 +70,0 @@\n-  _is_gc_request_pending = false;\n-\n-  DEBUG_ONLY(_verify_in_cr_count = 0;)\n@@ -87,1 +84,1 @@\n-  assert(AtomicAccess::load(&_is_gc_request_pending) == false, \"precondition\");\n+  assert(_is_gc_request_pending.load_relaxed() == false, \"precondition\");\n@@ -91,1 +88,1 @@\n-  AtomicAccess::store(&_is_gc_request_pending, true);\n+  _is_gc_request_pending.store_relaxed(true);\n@@ -115,1 +112,1 @@\n-  assert(AtomicAccess::load(&_verify_in_cr_count) == 0, \"inv\");\n+  assert(_verify_in_cr_count.load_relaxed() == 0, \"inv\");\n@@ -120,1 +117,1 @@\n-  assert(AtomicAccess::load(&_is_gc_request_pending) == true, \"precondition\");\n+  assert(_is_gc_request_pending.load_relaxed() == true, \"precondition\");\n@@ -122,1 +119,1 @@\n-  AtomicAccess::store(&_is_gc_request_pending, false);\n+  _is_gc_request_pending.store_relaxed(false);\n@@ -142,1 +139,1 @@\n-    if (!AtomicAccess::load(&_is_gc_request_pending)) {\n+    if (!_is_gc_request_pending.load_relaxed()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -46,1 +47,1 @@\n-  static volatile bool _is_gc_request_pending;\n+  static Atomic<bool> _is_gc_request_pending;\n@@ -50,1 +51,1 @@\n-  static uint64_t _verify_in_cr_count;\n+  static Atomic<uint64_t> _verify_in_cr_count;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    if (AtomicAccess::load(&_is_gc_request_pending)) {\n+    if (_is_gc_request_pending.load_relaxed()) {\n@@ -47,1 +47,1 @@\n-    DEBUG_ONLY(AtomicAccess::add(&_verify_in_cr_count, (uint64_t)1);)\n+    DEBUG_ONLY(_verify_in_cr_count.add_then_fetch(1u);)\n@@ -58,1 +58,1 @@\n-    AtomicAccess::add(&_verify_in_cr_count, (uint64_t)-1);\n+    _verify_in_cr_count.sub_then_fetch(1u);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -703,1 +703,1 @@\n-    if (_deferred_updates_next.compare_exchange(nullptr, this) == nullptr) {\n+    if (_deferred_updates_next.compare_set(nullptr, this)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -55,1 +55,1 @@\n-    char* cur_start = AtomicAccess::load(&_cur_addr);\n+    char* cur_start = _cur_addr.load_relaxed();\n@@ -59,1 +59,1 @@\n-    } else if (cur_start == AtomicAccess::cmpxchg(&_cur_addr, cur_start, cur_end)) {\n+    } else if (_cur_addr.compare_set(cur_start, cur_end)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -31,1 +33,1 @@\n-  char* volatile _cur_addr;\n+  Atomic<char*> _cur_addr;\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-volatile bool SuspendibleThreadSet::_suspend_all       = false;\n+Atomic<bool>  SuspendibleThreadSet::_suspend_all{false};\n@@ -99,1 +99,1 @@\n-    AtomicAccess::store(&_suspend_all, true);\n+    _suspend_all.store_relaxed(true);\n@@ -130,1 +130,1 @@\n-  AtomicAccess::store(&_suspend_all, false);\n+  _suspend_all.store_relaxed(false);\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -46,1 +46,1 @@\n-  static volatile bool _suspend_all;\n+  static Atomic<bool>  _suspend_all;\n@@ -62,1 +62,1 @@\n-  static bool should_yield() { return AtomicAccess::load(&_suspend_all); }\n+  static bool should_yield() { return _suspend_all.load_relaxed(); }\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-  Age cmpxchg_age(Age old_age, Age new_age) {\n-    return _age.compare_exchange(old_age, new_age);\n+  bool par_set_age(Age old_age, Age new_age) {\n+    return _age.compare_set(old_age, new_age);\n@@ -348,1 +348,1 @@\n-  using TaskQueueSuper<N, MT>::cmpxchg_age;\n+  using TaskQueueSuper<N, MT>::par_set_age;\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -173,2 +173,1 @@\n-    Age tempAge = cmpxchg_age(oldAge, newAge);\n-    if (tempAge == oldAge) {\n+    if (par_set_age(oldAge, newAge)) {\n@@ -286,1 +285,1 @@\n-  Age resAge = cmpxchg_age(oldAge, newAge);\n+  bool result = par_set_age(oldAge, newAge);\n@@ -291,1 +290,1 @@\n-  return resAge == oldAge ? PopResult::Success : PopResult::Contended;\n+  return result ? PopResult::Success : PopResult::Contended;\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  _not_finished = num_workers;\n+  _not_finished.store_relaxed(num_workers);\n@@ -54,1 +54,4 @@\n-  assert(_not_finished == 0, \"%d not finished workers?\", _not_finished);\n+#ifdef ASSERT\n+  uint not_finished = _not_finished.load_relaxed();\n+  assert(not_finished == 0, \"%u not finished workers?\", not_finished);\n+#endif \/\/ ASSERT\n@@ -56,1 +59,1 @@\n-  _started = 0;\n+  _started.store_relaxed(0);\n@@ -64,1 +67,1 @@\n-  const uint worker_id = AtomicAccess::fetch_then_add(&_started, 1u);\n+  const uint worker_id = _started.fetch_then_add(1u);\n@@ -73,1 +76,1 @@\n-  const uint not_finished = AtomicAccess::sub(&_not_finished, 1u);\n+  const uint not_finished = _not_finished.sub_then_fetch(1u);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -61,2 +62,2 @@\n-  volatile uint _started;\n-  volatile uint _not_finished;\n+  Atomic<uint> _started;\n+  Atomic<uint> _not_finished;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-void ShenandoahAdaptiveHeuristics::record_success_degenerated() {\n-  ShenandoahHeuristics::record_success_degenerated();\n+void ShenandoahAdaptiveHeuristics::record_degenerated() {\n+  ShenandoahHeuristics::record_degenerated();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  virtual void record_success_degenerated() override;\n+  virtual void record_degenerated() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-void ShenandoahHeuristics::record_success_degenerated() {\n+void ShenandoahHeuristics::record_degenerated() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-  virtual void record_success_degenerated();\n+  virtual void record_degenerated();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -769,1 +769,1 @@\n-void ShenandoahOldHeuristics::record_success_degenerated() {\n+void ShenandoahOldHeuristics::record_degenerated() {\n@@ -772,1 +772,1 @@\n-  this->ShenandoahHeuristics::record_success_degenerated();\n+  this->ShenandoahHeuristics::record_degenerated();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  void record_success_degenerated() override;\n+  void record_degenerated() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+    _generation->heuristics()->record_degenerated();\n@@ -317,0 +318,1 @@\n+    \/\/ Upgrade to full GC, register full-GC impact on heuristics.\n@@ -318,0 +320,2 @@\n+  } else {\n+    _generation->heuristics()->record_degenerated();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-    _available[partition_id] = FreeSetUnderConstruction;\n+    _available[partition_id] = 0;\n@@ -2498,0 +2498,4 @@\n+  assert(rebuild_lock() != nullptr, \"sanity\");\n+  rebuild_lock()->lock(false);\n+  \/\/ This resets all state information, removing all regions from all sets.\n+  clear();\n@@ -2527,0 +2531,3 @@\n+\n+  \/\/ Release the rebuild lock now.  What remains in this function is read-only\n+  rebuild_lock()->unlock();\n@@ -3061,1 +3068,1 @@\n-      size_t free = capacity() - used();\n+      size_t free = capacity_holding_lock() - used_holding_lock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahLock.hpp\"\n@@ -34,0 +35,3 @@\n+typedef ShenandoahLock    ShenandoahRebuildLock;\n+typedef ShenandoahLocker  ShenandoahRebuildLocker;\n+\n@@ -142,2 +146,0 @@\n-  static const size_t FreeSetUnderConstruction = SIZE_MAX;\n-\n@@ -355,0 +357,10 @@\n+  \/\/ Return available_in assuming caller does not hold the heap lock but does hold the rebuild_lock.\n+  \/\/ The returned value may be \"slightly stale\" because we do not assure that every fetch of this value\n+  \/\/ sees the most recent update of this value.  Requiring the caller to hold the rebuild_lock assures\n+  \/\/ that we don't see \"bogus\" values that are \"worse than stale\".  During rebuild of the freeset, the\n+  \/\/ value of _available is not reliable.\n+  inline size_t available_in_locked_for_rebuild(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    return _available[int(which_partition)];\n+  }\n+\n@@ -362,17 +374,0 @@\n-  \/\/ Return available_in assuming caller does not hold the heap lock.  In production builds, available is\n-  \/\/ returned without acquiring the lock.  In debug builds, the global heap lock is acquired in order to\n-  \/\/ enforce a consistency assert.\n-  inline size_t available_in_not_locked(ShenandoahFreeSetPartitionId which_partition) const {\n-    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n-    shenandoah_assert_not_heaplocked();\n-#ifdef ASSERT\n-    ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n-    assert((_available[int(which_partition)] == FreeSetUnderConstruction) ||\n-           (_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)]),\n-           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n-           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n-           partition_membership_name(idx_t(which_partition)));\n-#endif\n-    return _available[int(which_partition)];\n-  }\n-\n@@ -443,0 +438,9 @@\n+  \/\/ This locks the rebuild process (in combination with the global heap lock).  Whenever we rebuild the free set,\n+  \/\/ we first acquire the global heap lock and then we acquire this _rebuild_lock in a nested context.  Threads that\n+  \/\/ need to check available, acquire only the _rebuild_lock to make sure that they are not obtaining the value of\n+  \/\/ available for a partially reconstructed free-set.\n+  \/\/\n+  \/\/ Note that there is rank ordering of nested locks to prevent deadlock.  All threads that need to acquire both\n+  \/\/ locks will acquire them in the same order: first the global heap lock and then the rebuild lock.\n+  ShenandoahRebuildLock _rebuild_lock;\n+\n@@ -638,2 +642,0 @@\n-  static const size_t FreeSetUnderConstruction = ShenandoahRegionPartitions::FreeSetUnderConstruction;\n-\n@@ -642,0 +644,4 @@\n+  ShenandoahRebuildLock* rebuild_lock() {\n+    return &_rebuild_lock;\n+  }\n+\n@@ -779,3 +785,23 @@\n-  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator);             }\n-  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);                 }\n-  inline size_t available() const { return _partitions.available_in_not_locked(ShenandoahFreeSetPartitionId::Mutator); }\n+  inline size_t capacity_holding_lock() const {\n+    shenandoah_assert_heaplocked();\n+    return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator);\n+  }\n+  inline size_t capacity_not_holding_lock() {\n+    shenandoah_assert_not_heaplocked();\n+    ShenandoahRebuildLocker locker(rebuild_lock());\n+    return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator);\n+  }\n+  inline size_t used_holding_lock() const {\n+    shenandoah_assert_heaplocked();\n+    return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);\n+  }\n+  inline size_t used_not_holding_lock() {\n+    shenandoah_assert_not_heaplocked();\n+    ShenandoahRebuildLocker locker(rebuild_lock());\n+    return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);\n+  }\n+  inline size_t available() {\n+    shenandoah_assert_not_heaplocked();\n+    ShenandoahRebuildLocker locker(rebuild_lock());\n+    return _partitions.available_in_locked_for_rebuild(ShenandoahFreeSetPartitionId::Mutator);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":50,"deletions":24,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1116,8 +1116,10 @@\n-    size_t young_cset_regions, old_cset_regions;\n-    size_t first_old, last_old, num_old;\n-    heap->free_set()->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n-\n-    \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n-    \/\/ no longer have objects separated by age into distinct regions.\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGenerationalFullGC::compute_balances();\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n+    ShenandoahFreeSet* free_set = heap->free_set();\n+    {\n+      free_set->prepare_to_rebuild(young_cset_regions, old_cset_regions, first_old, last_old, num_old);\n+      \/\/ We also do not expand old generation size following Full GC because we have scrambled age populations and\n+      \/\/ no longer have objects separated by age into distinct regions.\n+      if (heap->mode()->is_generational()) {\n+        ShenandoahGenerationalFullGC::compute_balances();\n+      }\n+      free_set->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n@@ -1125,3 +1127,0 @@\n-\n-    heap->free_set()->finish_rebuild(young_cset_regions, old_cset_regions, num_old);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -818,1 +818,0 @@\n-    size_t young_cset_regions, old_cset_regions;\n@@ -821,1 +820,1 @@\n-    size_t first_old, last_old, num_old;\n+    size_t young_cset_regions, old_cset_regions, first_old, last_old, num_old;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+  \/\/ This is the only instance of request. It is important that request.generation\n+  \/\/ does not change between a concurrent cycle failure and the start of a degenerated\n+  \/\/ cycle. We initialize it with the young generation to handle the pathological case\n+  \/\/ where the very first cycle is degenerated (some tests exercise this path).\n@@ -65,0 +69,1 @@\n+  request.generation = _heap->young_generation();\n@@ -80,6 +85,4 @@\n-    if (!_heap->cancelled_gc()) {\n-      MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n-      if (_requested_gc_cause == GCCause::_no_gc) {\n-        set_gc_mode(ml, none);\n-        ml.wait();\n-      }\n+    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+    if (_requested_gc_cause == GCCause::_no_gc) {\n+      set_gc_mode(ml, none);\n+      ml.wait();\n@@ -99,2 +102,1 @@\n-  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n-  notify_cancellation(ml, GCCause::_shenandoah_stop_vm);\n+  notify_control_thread(ml, GCCause::_shenandoah_stop_vm);\n@@ -108,7 +110,7 @@\n-  if (_heap->cancelled_gc()) {\n-    \/\/ The previous request was cancelled. Either it was cancelled for an allocation\n-    \/\/ failure (degenerated cycle), or old marking was cancelled to run a young collection.\n-    \/\/ In either case, the correct generation for the next cycle can be determined by\n-    \/\/ the cancellation cause.\n-    request.cause = _heap->clear_cancellation(GCCause::_shenandoah_concurrent_gc);\n-    if (request.cause == GCCause::_shenandoah_concurrent_gc) {\n+\n+  log_debug(gc, thread)(\"cancelled cause: %s, requested cause: %s\",\n+    GCCause::to_string(_heap->cancelled_cause()), GCCause::to_string(_requested_gc_cause));\n+\n+  request.cause = _requested_gc_cause;\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(request.cause)) {\n+    if (_degen_point == ShenandoahGC::_degenerated_unset) {\n@@ -116,0 +118,3 @@\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+    } else {\n+      assert(request.generation != nullptr, \"Must know which generation to use for degenerated cycle\");\n@@ -118,1 +123,6 @@\n-    request.cause = _requested_gc_cause;\n+    if (request.cause == GCCause::_shenandoah_concurrent_gc) {\n+      \/\/ This is a regulator request. It is also possible that the regulator \"canceled\" an old mark,\n+      \/\/ so we can clear that here. This clear operation will only clear the cancellation if it is\n+      \/\/ a regulator request.\n+      _heap->clear_cancellation(GCCause::_shenandoah_concurrent_gc);\n+    }\n@@ -120,5 +130,0 @@\n-\n-    \/\/ Only clear these if we made a request from them. In the case of a cancelled gc,\n-    \/\/ we do not want to inadvertently lose this pending request.\n-    _requested_gc_cause = GCCause::_no_gc;\n-    _requested_generation = nullptr;\n@@ -127,0 +132,6 @@\n+  log_debug(gc, thread)(\"request.cause: %s, request.generation: %s\",\n+    GCCause::to_string(request.cause), request.generation == nullptr ? \"None\" : request.generation->name());\n+\n+  _requested_gc_cause = GCCause::_no_gc;\n+  _requested_generation = nullptr;\n+\n@@ -131,0 +142,1 @@\n+  assert(request.generation != nullptr, \"request.generation cannot be null, cause is: %s\", GCCause::to_string(request.cause));\n@@ -143,5 +155,3 @@\n-\n-  if (_degen_point == ShenandoahGC::_degenerated_unset) {\n-    _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n-    request.generation = _heap->young_generation();\n-  } else if (request.generation->is_old()) {\n+  \/\/ Important: not all paths update the request.generation. This is intentional.\n+  \/\/ A degenerated cycle must use the same generation carried over from the previous request.\n+  if (request.generation->is_old()) {\n@@ -591,0 +601,2 @@\n+    MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+    _requested_gc_cause = _heap->cancelled_cause();\n@@ -636,3 +648,1 @@\n-    \/\/ GC should already be cancelled. Here we are just notifying the control thread to\n-    \/\/ wake up and handle the cancellation request, so we don't need to set _requested_gc_cause.\n-    notify_cancellation(cause);\n+    notify_control_thread(cause);\n@@ -656,1 +666,2 @@\n-      log_debug(gc, thread)(\"Cannot start young, old collection is not preemptible\");\n+      \/\/ Global should be able to cause old collection to be abandoned\n+      log_debug(gc, thread)(\"Cannot start %s, old collection is not preemptible\", generation->name());\n@@ -664,1 +675,1 @@\n-      notify_cancellation(ml, GCCause::_shenandoah_concurrent_gc);\n+      notify_control_thread(ml, GCCause::_shenandoah_concurrent_gc, generation);\n@@ -698,4 +709,10 @@\n-  log_debug(gc, thread)(\"Notify control (%s): %s, %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause), generation->name());\n-  _requested_gc_cause = cause;\n-  _requested_generation = generation;\n-  ml.notify();\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(_requested_gc_cause)) {\n+    \/\/ We have already observed a request to handle an allocation failure. We cannot allow\n+    \/\/ another request (System.gc or regulator) to subvert the degenerated cycle.\n+    log_debug(gc, thread)(\"Not overwriting gc cause %s with %s\", GCCause::to_string(_requested_gc_cause), GCCause::to_string(cause));\n+  } else {\n+    log_debug(gc, thread)(\"Notify control (%s): %s, %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause), generation->name());\n+    _requested_gc_cause = cause;\n+    _requested_generation = generation;\n+    ml.notify();\n+  }\n@@ -704,1 +721,1 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(GCCause::Cause cause) {\n+void ShenandoahGenerationalControlThread::notify_control_thread(GCCause::Cause cause) {\n@@ -706,1 +723,1 @@\n-  notify_cancellation(ml, cause);\n+  notify_control_thread(ml, cause);\n@@ -709,4 +726,11 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(MonitorLocker& ml, GCCause::Cause cause) {\n-  assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n-  log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n-  ml.notify();\n+void ShenandoahGenerationalControlThread::notify_control_thread(MonitorLocker& ml, GCCause::Cause cause) {\n+  assert(_control_lock.is_locked(), \"Request lock must be held here\");\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(_requested_gc_cause)) {\n+    \/\/ We have already observed a request to handle an allocation failure. We cannot allow\n+    \/\/ another request (System.gc or regulator) to subvert the degenerated cycle.\n+    log_debug(gc, thread)(\"Not overwriting gc cause %s with %s\", GCCause::to_string(_requested_gc_cause), GCCause::to_string(cause));\n+  } else {\n+    log_debug(gc, thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+    _requested_gc_cause = cause;\n+    ml.notify();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":65,"deletions":41,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -138,2 +138,4 @@\n-  \/\/ Takes the request lock and updates the requested cause and generation, then notifies the control thread.\n-  \/\/ The overloaded variant should be used when the _control_lock is already held.\n+  \/\/ These notify the control thread after updating _requested_gc_cause and (optionally) _requested_generation.\n+  \/\/ Updating the requested generation is not necessary for allocation failures nor when stopping the thread.\n+  void notify_control_thread(GCCause::Cause cause);\n+  void notify_control_thread(MonitorLocker& ml, GCCause::Cause cause);\n@@ -143,5 +145,0 @@\n-  \/\/ Notifies the control thread, but does not update the requested cause or generation.\n-  \/\/ The overloaded variant should be used when the _control_lock is already held.\n-  void notify_cancellation(GCCause::Cause cause);\n-  void notify_cancellation(MonitorLocker& ml, GCCause::Cause cause);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    assert(ShenandoahCardBarrier, \"Should have card barrier to use genenrational heap\");\n+    assert(ShenandoahCardBarrier, \"Should have card barrier to use generational heap\");\n@@ -53,1 +53,1 @@\n-    assert(ShenandoahCardBarrier, \"Should have card barrier to use genenrational heap\");\n+    assert(ShenandoahCardBarrier, \"Should have card barrier to use generational heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,2 +429,0 @@\n-\n-\n@@ -1661,1 +1659,1 @@\n-  return _free_set->capacity();\n+  return _free_set->capacity_not_holding_lock();\n@@ -2141,1 +2139,1 @@\n-  return _free_set->used();\n+  return _free_set->used_not_holding_lock();\n@@ -2531,2 +2529,1 @@\n-  size_t young_cset_regions, old_cset_regions;\n-  size_t first_old_region, last_old_region, old_region_count;\n+  size_t young_cset_regions, old_cset_regions, first_old_region, last_old_region, old_region_count;\n@@ -2551,1 +2548,2 @@\n-    size_t allocation_runway = gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    size_t allocation_runway =\n+      gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n@@ -2556,2 +2554,2 @@\n-    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.  Fragmentation\n-    \/\/ will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n+    \/\/ regions in place when many of these regular regions have an abundant amount of available memory within them.\n+    \/\/ Fragmentation will decrease as promote-by-copy consumes the available memory within these partially consumed regions.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  , _used_before(free_set->used())\n+  , _used_before(free_set->used_not_holding_lock())\n@@ -41,1 +41,0 @@\n-  assert(free_actual != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n@@ -55,1 +54,1 @@\n-  const size_t used_after = _free_set->used();\n+  const size_t used_after = _free_set->used_not_holding_lock();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -415,0 +415,1 @@\n+    ShenandoahFreeSet* free_set = heap->free_set();\n@@ -416,2 +417,4 @@\n-    size_t young_trash_regions, old_trash_regions;\n-    size_t first_old, last_old, num_old;\n+\n+    \/\/ This is completion of old-gen marking.  We rebuild in order to reclaim immediate garbage and to\n+    \/\/ prepare for subsequent mixed evacuations.\n+    size_t young_trash_regions, old_trash_regions, first_old, last_old, num_old;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,0 +152,7 @@\n+\n+  \/\/ This call may find the control thread waiting on workers which have suspended\n+  \/\/ to allow a safepoint to run. If this regulator thread does not yield, the safepoint\n+  \/\/ will not run. The worker threads won't progress, the control thread won't progress,\n+  \/\/ and the regulator thread may never yield. Therefore, we leave the suspendible\n+  \/\/ thread set before making this call.\n+  SuspendibleThreadSetLeaver leaver;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"jfr\/recorder\/service\/jfrRecorderService.hpp\"\n@@ -46,0 +47,1 @@\n+\n@@ -156,1 +158,1 @@\n-void Jfr::on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown, bool halt) {\n+void Jfr::on_vm_shutdown(bool exception_handler \/* false *\/, bool halt \/* false *\/, bool oom \/* false *\/) {\n@@ -158,1 +160,1 @@\n-    JfrEmergencyDump::on_vm_shutdown(emit_old_object_samples, emit_event_shutdown);\n+    JfrEmergencyDump::on_vm_shutdown(exception_handler, oom);\n@@ -176,0 +178,6 @@\n+void Jfr::on_report_java_out_of_memory() {\n+  if (CrashOnOutOfMemoryError && JfrRecorder::is_recording()) {\n+    JfrRecorderService::emit_leakprofiler_events_on_oom();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-  static void on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown, bool halt = false);\n+  static void on_vm_shutdown(bool exception_handler = false, bool halt = false, bool oom = false);\n@@ -82,0 +82,1 @@\n+  static void on_report_java_out_of_memory();\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,2 +367,1 @@\n-  JfrRecorderService service;\n-  service.emit_leakprofiler_events(cutoff_ticks, emit_all == JNI_TRUE, skip_bfs == JNI_TRUE);\n+  JfrRecorderService::emit_leakprofiler_events(cutoff_ticks, emit_all == JNI_TRUE, skip_bfs == JNI_TRUE);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -235,31 +235,40 @@\n-  ThreadsListHandle tlh;\n-  \/\/ Resolve a sample session relative start position index into the thread list array.\n-  \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n-  _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n-  JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n-\n-  while (num_samples < sample_limit) {\n-    current = next_thread(tlh.list(), start, current);\n-    if (current == nullptr) {\n-      break;\n-    }\n-    if (is_excluded(current)) {\n-      continue;\n-    }\n-    if (start == nullptr) {\n-      start = current; \/\/ remember the thread where we started to attempt sampling\n-    }\n-    bool success;\n-    if (JAVA_SAMPLE == type) {\n-      success = sample_java_thread(current);\n-    } else {\n-      assert(type == NATIVE_SAMPLE, \"invariant\");\n-      success = sample_native_thread(current);\n-    }\n-    if (success) {\n-      num_samples++;\n-    }\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      \/\/ For _thread_in_native, we cannot get the Threads_lock.\n-      \/\/ For _thread_in_Java, well, there are none.\n-      break;\n+  {\n+    \/*\n+     * Take the Threads_lock for three purposes:\n+     *\n+     * 1) Avoid sampling right through a safepoint,\n+     *    which could result in touching oops in case of virtual threads.\n+     * 2) Prevent JFR from issuing an epoch rotation while the sampler thread\n+     *    is actively processing a thread in state native, as both threads are outside the safepoint protocol.\n+     * 3) Some operating systems (BSD \/ Mac) require a process lock when sending a signal with pthread_kill.\n+     *    Holding the Threads_lock prevents a JavaThread from calling os::create_thread(), which also takes the process lock.\n+     *    In a sense, we provide a coarse signal mask, so we can always send the resume signal.\n+     *\/\n+    MutexLocker tlock(Threads_lock);\n+    ThreadsListHandle tlh;\n+    \/\/ Resolve a sample session relative start position index into the thread list array.\n+    \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n+    _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n+    JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n+\n+    while (num_samples < sample_limit) {\n+      current = next_thread(tlh.list(), start, current);\n+      if (current == nullptr) {\n+        break;\n+      }\n+      if (is_excluded(current)) {\n+        continue;\n+      }\n+      if (start == nullptr) {\n+        start = current; \/\/ remember the thread where we started to attempt sampling\n+      }\n+      bool success;\n+      if (JAVA_SAMPLE == type) {\n+        success = sample_java_thread(current);\n+      } else {\n+        assert(type == NATIVE_SAMPLE, \"invariant\");\n+        success = sample_native_thread(current);\n+      }\n+      if (success) {\n+        num_samples++;\n+      }\n@@ -267,1 +276,0 @@\n-  }\n@@ -269,1 +277,2 @@\n-  *last_thread = current; \/\/ remember the thread we last attempted to sample\n+    *last_thread = current; \/\/ remember the thread we last attempted to sample\n+  }\n@@ -300,0 +309,1 @@\n+  assert_lock_strong(Threads_lock);\n@@ -331,0 +341,1 @@\n+  assert_lock_strong(Threads_lock);\n@@ -346,14 +357,5 @@\n-  \/\/ Take the Threads_lock for two purposes:\n-  \/\/ 1) Avoid sampling through a safepoint which could result\n-  \/\/    in touching oops in case of virtual threads.\n-  \/\/ 2) Prevent JFR from issuing an epoch rotation while the sampler thread\n-  \/\/    is actively processing a thread in native, as both threads are now\n-  \/\/    outside the safepoint protocol.\n-\n-  \/\/ OrderAccess::fence() as part of acquiring the lock prevents loads from floating up.\n-  JfrMutexTryLock threads_lock(Threads_lock);\n-\n-  if (!threads_lock.acquired() || !jt->has_last_Java_frame()) {\n-    \/\/ Remove the native sample request and release the potentially waiting thread.\n-    JfrSampleMonitor jsm(tl);\n-    return false;\n+  \/\/ Separate the arming of the poll (above) from the reading of JavaThread state (below).\n+  if (UseSystemMemoryBarrier) {\n+    SystemMemoryBarrier::emit();\n+  } else {\n+    OrderAccess::fence();\n@@ -362,2 +364,1 @@\n-  if (jt->thread_state() != _thread_in_native) {\n-    assert_lock_strong(Threads_lock);\n+  if (jt->thread_state() != _thread_in_native || !jt->has_last_Java_frame()) {\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":51,"deletions":50,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -463,9 +465,0 @@\n-#ifdef ASSERT\n-  Mutex* owned_lock = thread->owned_locks();\n-  while (owned_lock != nullptr) {\n-    Mutex* next = owned_lock->next();\n-    owned_lock->unlock();\n-    owned_lock = next;\n-  }\n-#endif \/\/ ASSERT\n-\n@@ -553,5 +546,2 @@\n-static void post_events(bool emit_old_object_samples, bool emit_event_shutdown, Thread* thread) {\n-  if (emit_old_object_samples) {\n-    LeakProfiler::emit_events(max_jlong, false, false);\n-  }\n-  if (emit_event_shutdown) {\n+static void post_events(bool exception_handler, bool oom, Thread * thread) {\n+  if (exception_handler) {\n@@ -559,1 +549,1 @@\n-    e.set_reason(\"VM Error\");\n+    e.set_reason(oom ? \"CrashOnOutOfMemoryError\" : \"VM Error\");\n@@ -563,1 +553,1 @@\n-  event.set_reason(emit_old_object_samples ? \"Out of Memory\" : \"Crash\");\n+  event.set_reason(exception_handler && oom ? \"CrashOnOutOfMemoryError\" : exception_handler ? \"Crash\" : \"Out of Memory\");\n@@ -597,1 +587,1 @@\n-void JfrEmergencyDump::on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown) {\n+void JfrEmergencyDump::on_vm_shutdown(bool exception_handler, bool oom) {\n@@ -601,0 +591,1 @@\n+\n@@ -603,0 +594,5 @@\n+\n+  \/\/ Ensure a JavaThread is _thread_in_vm when we make this call\n+  JavaThreadInVMAndNative jtivm(thread);\n+  post_events(exception_handler, oom, thread);\n+\n@@ -604,1 +600,6 @@\n-    log_info(jfr, system)(\"The Watcher thread crashed so no jfr emergency dump will be generated.\");\n+    \/\/ We cannot attempt an emergency dump using the Watcher thread\n+    \/\/ because we rely on the WatcherThread task \"is_error_reported()\",\n+    \/\/ to exit the VM after a hardcoded timeout, should the relatively\n+    \/\/ risky operation of an emergency dump fail (deadlock, livelock).\n+    log_warning(jfr, system)\n+      (\"The Watcher thread crashed so no jfr emergency dump will be generated.\");\n@@ -607,2 +608,12 @@\n-  \/\/ Ensure a JavaThread is _thread_in_vm when we make this call\n-  JavaThreadInVMAndNative jtivm(thread);\n+\n+  if (thread->is_VM_thread()) {\n+    const VM_Operation* const operation = VMThread::vm_operation();\n+    if (operation != nullptr && operation->type() == VM_Operation::VMOp_JFROldObject) {\n+      \/\/ We will not be able to issue a rotation because the rotation lock\n+      \/\/ is held by the JFR Recorder Thread that issued the VM_Operation.\n+      log_warning(jfr, system)\n+        (\"The VM Thread crashed as part of emitting leak profiler events so no jfr emergency dump will be generated.\");\n+      return;\n+    }\n+  }\n+\n@@ -610,1 +621,0 @@\n-  post_events(emit_old_object_samples, emit_event_shutdown, thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  static void on_vm_shutdown(bool emit_old_object_samples, bool emit_event_shutdown);\n+  static void on_vm_shutdown(bool exception_handler, bool oom);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-                             (MSGBIT(MSG_FLUSHPOINT))        \\\n+                             (MSGBIT(MSG_FLUSHPOINT))      | \\\n+                             (MSGBIT(MSG_EMIT_LEAKP_REFCHAINS)) \\\n@@ -168,1 +169,1 @@\n-  JfrMsg_lock->notify();\n+  JfrMsg_lock->notify_all();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+  MSG_EMIT_LEAKP_REFCHAINS,\n@@ -54,6 +55,7 @@\n- *  MSG_CLONE_IN_MEMORY (0) ; MSGBIT(MSG_CLONE_IN_MEMORY) == (1 << 0) == 0x1\n- *  MSG_START(1)            ; MSGBIT(MSG_START) == (1 << 0x1) == 0x2\n- *  MSG_STOP (2)            ; MSGBIT(MSG_STOP) == (1 << 0x2) == 0x4\n- *  MSG_ROTATE (3)          ; MSGBIT(MSG_ROTATE) == (1 << 0x3) == 0x8\n- *  MSG_VM_ERROR (8)        ; MSGBIT(MSG_VM_ERROR) == (1 << 0x8) == 0x100\n- *  MSG_FLUSHPOINT (9)     ; MSGBIT(MSG_FLUSHPOINT) == (1 << 0x9) == 0x200\n+ *  MSG_CLONE_IN_MEMORY (0)      ; MSGBIT(MSG_CLONE_IN_MEMORY) == (1 << 0) == 0x1\n+ *  MSG_START(1)                 ; MSGBIT(MSG_START) == (1 << 0x1) == 0x2\n+ *  MSG_STOP (2)                 ; MSGBIT(MSG_STOP) == (1 << 0x2) == 0x4\n+ *  MSG_ROTATE (3)               ; MSGBIT(MSG_ROTATE) == (1 << 0x3) == 0x8\n+ *  MSG_VM_ERROR (8)             ; MSGBIT(MSG_VM_ERROR) == (1 << 0x8) == 0x100\n+ *  MSG_FLUSHPOINT (9)           ; MSGBIT(MSG_FLUSHPOINT) == (1 << 0x9) == 0x200\n+ *  MSG_EMIT_LEAKP_REFCHAINS (10); MSGBIT(MSG_EMIT_LEAKP_REFCHAINS) == (1 << 0xa) == 0x400\n@@ -63,4 +65,4 @@\n- *  MSG_FULLBUFFER (4)      ; MSGBIT(MSG_FULLBUFFER) == (1 << 0x4) == 0x10\n- *  MSG_CHECKPOINT (5)      ; MSGBIT(CHECKPOINT) == (1 << 0x5) == 0x20\n- *  MSG_WAKEUP (6)          ; MSGBIT(WAKEUP) == (1 << 0x6) == 0x40\n- *  MSG_SHUTDOWN (7)        ; MSGBIT(MSG_SHUTDOWN) == (1 << 0x7) == 0x80\n+ *  MSG_FULLBUFFER (4)           ; MSGBIT(MSG_FULLBUFFER) == (1 << 0x4) == 0x10\n+ *  MSG_CHECKPOINT (5)           ; MSGBIT(CHECKPOINT) == (1 << 0x5) == 0x20\n+ *  MSG_WAKEUP (6)               ; MSGBIT(WAKEUP) == (1 << 0x6) == 0x40\n+ *  MSG_SHUTDOWN (7)             ; MSGBIT(MSG_SHUTDOWN) == (1 << 0x7) == 0x80\n@@ -71,0 +73,1 @@\n+  friend class JfrRecorderService;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.hpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -394,0 +395,1 @@\n+  _post_box(JfrPostBox::instance()),\n@@ -673,5 +675,48 @@\n-void JfrRecorderService::emit_leakprofiler_events(int64_t cutoff_ticks, bool emit_all, bool skip_bfs) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(JavaThread::current()));\n-  \/\/ Take the rotation lock to exclude flush() during event emits. This is because event emit\n-  \/\/ also creates a number checkpoint events. Those checkpoint events require a future typeset checkpoint\n-  \/\/ event for completeness, i.e. to be generated before being flushed to a segment.\n+\/\/ LeakProfiler event serialization support.\n+\n+struct JfrLeakProfilerEmitRequest {\n+  int64_t cutoff_ticks;\n+  bool emit_all;\n+  bool skip_bfs;\n+  bool oom;\n+};\n+\n+typedef GrowableArrayCHeap<JfrLeakProfilerEmitRequest, mtTracing> JfrLeakProfilerEmitRequestQueue;\n+static JfrLeakProfilerEmitRequestQueue* _queue = nullptr;\n+constexpr const static int64_t _no_path_to_gc_roots = 0;\n+static bool _oom_emit_request_posted = false;\n+static bool _oom_emit_request_delivered = false;\n+\n+static inline bool exclude_paths_to_gc_roots(int64_t cutoff_ticks) {\n+  return cutoff_ticks <= _no_path_to_gc_roots;\n+}\n+\n+static void enqueue(const JfrLeakProfilerEmitRequest& request) {\n+  assert(JfrRotationLock::is_owner(), \"invariant\");\n+  if (_queue == nullptr) {\n+    _queue = new JfrLeakProfilerEmitRequestQueue(4);\n+  }\n+  assert(_queue != nullptr, \"invariant\");\n+  assert(!_oom_emit_request_posted, \"invariant\");\n+  if (request.oom) {\n+    _oom_emit_request_posted = true;\n+  }\n+  _queue->append(request);\n+}\n+\n+static JfrLeakProfilerEmitRequest dequeue() {\n+  assert(JfrRotationLock::is_owner(), \"invariant\");\n+  assert(_queue != nullptr, \"invariant\");\n+  assert(_queue->is_nonempty(), \"invariant\");\n+  const JfrLeakProfilerEmitRequest& request = _queue->first();\n+  _queue->remove_at(0);\n+  return request;\n+}\n+\n+\/\/ This version of emit excludes path-to-gc-roots, i.e. it skips reference chains.\n+static void emit_leakprofiler_events(bool emit_all, bool skip_bfs, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  \/\/ Take the rotation lock to exclude flush() during event emits. This is because the event emit operation\n+  \/\/ also creates a number of checkpoint events. Those checkpoint events require a future typeset checkpoint\n+  \/\/ event for completeness, i.e., to be generated before being flushed to a segment.\n@@ -679,1 +724,1 @@\n-  \/\/ and serializes all event emit checkpoint events to the same segment.\n+  \/\/ and serializes all checkpoint events to the same segment.\n@@ -681,0 +726,87 @@\n+  \/\/ Take the rotation lock before the thread transition, to avoid blocking safepoints.\n+  if (_oom_emit_request_posted) {\n+    \/\/ A request to emit leakprofiler events in response to CrashOnOutOfMemoryError\n+    \/\/ is pending or has already been completed. We are about to crash at any time now.\n+    assert(CrashOnOutOfMemoryError, \"invariant\");\n+    return;\n+  }\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n+  ThreadInVMfromNative transition(jt);\n+  \/\/ Since we are not requesting path-to-gc-roots, i.e., reference chains, we need not issue a VM_Operation.\n+  \/\/ Therefore, we can let the requesting thread process the request directly, since it already holds the requisite lock.\n+  LeakProfiler::emit_events(_no_path_to_gc_roots, emit_all, skip_bfs);\n+}\n+\n+void JfrRecorderService::transition_and_post_leakprofiler_emit_msg(JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt);)\n+  assert(!JfrRotationLock::is_owner(), \"invariant\");\n+  \/\/ Transition to _thread_in_VM and post a synchronous message to the JFR Recorder Thread\n+  \/\/ for it to process our enqueued request, which includes paths-to-gc-roots, i.e., reference chains.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n+  ThreadInVMfromNative transition(jt);\n+  _post_box.post(MSG_EMIT_LEAKP_REFCHAINS);\n+}\n+\n+\/\/ This version of emit includes path-to-gc-roots, i.e., it includes in the request traversing of reference chains.\n+\/\/ Traversing reference chains is performed as part of a VM_Operation, and we initiate it from the JFR Recorder Thread.\n+\/\/ Because multiple threads can concurrently report_on_java_out_of_memory(), having them all post a synchronous JFR msg,\n+\/\/ they rendezvous at a safepoint in a convenient state, ThreadBlockInVM. This mechanism prevents any thread from racing past\n+\/\/ this point and begin executing VMError::report_and_die(), until at least one oom request has been delivered.\n+void JfrRecorderService::emit_leakprofiler_events_paths_to_gc_roots(int64_t cutoff_ticks,\n+                                                                    bool emit_all,\n+                                                                    bool skip_bfs,\n+                                                                    bool oom,\n+                                                                    JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt);)\n+  assert(!exclude_paths_to_gc_roots(cutoff_ticks), \"invariant\");\n+\n+  {\n+    JfrRotationLock lock;\n+    \/\/ Take the rotation lock to read and post a request for the JFR Recorder Thread.\n+    if (_oom_emit_request_posted) {\n+      if (!oom) {\n+        \/\/ A request to emit leakprofiler events in response to CrashOnOutOfMemoryError\n+        \/\/ is pending or has already been completed. We are about to crash at any time now.\n+        assert(CrashOnOutOfMemoryError, \"invariant\");\n+        return;\n+      }\n+    } else {\n+      assert(!_oom_emit_request_posted, \"invariant\");\n+      JfrLeakProfilerEmitRequest request = { cutoff_ticks, emit_all, skip_bfs, oom };\n+      enqueue(request);\n+    }\n+  }\n+  JfrRecorderService service;\n+  service.transition_and_post_leakprofiler_emit_msg(jt);\n+}\n+\n+\/\/ Leakprofiler serialization request, the jdk.jfr.internal.JVM.emitOldObjectSamples() Java entry point.\n+void JfrRecorderService::emit_leakprofiler_events(int64_t cutoff_ticks,\n+                                                  bool emit_all,\n+                                                  bool skip_bfs) {\n+  JavaThread* const jt = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt);)\n+  if (exclude_paths_to_gc_roots(cutoff_ticks)) {\n+    ::emit_leakprofiler_events(emit_all, skip_bfs, jt);\n+    return;\n+  }\n+  emit_leakprofiler_events_paths_to_gc_roots(cutoff_ticks, emit_all, skip_bfs, \/* oom *\/ false, jt);\n+}\n+\n+\/\/ Leakprofiler serialization request, the report_on_java_out_of_memory VM entry point.\n+void JfrRecorderService::emit_leakprofiler_events_on_oom() {\n+  assert(CrashOnOutOfMemoryError, \"invariant\");\n+  if (EventOldObjectSample::is_enabled()) {\n+    JavaThread* const jt = JavaThread::current();\n+    DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt);)\n+    ThreadToNativeFromVM transition(jt);\n+    emit_leakprofiler_events_paths_to_gc_roots(max_jlong, false, false, \/* oom *\/ true, jt);\n+  }\n+}\n+\n+\/\/ The worker routine for the JFR Recorder Thread when processing MSG_EMIT_LEAKP_REFCHAINS messages.\n+void JfrRecorderService::emit_leakprofiler_events() {\n+  JavaThread* const jt = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n@@ -682,4 +814,30 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n-  ThreadInVMfromNative transition(current_thread);\n-  LeakProfiler::emit_events(cutoff_ticks, emit_all, skip_bfs);\n+  JfrRotationLock lock;\n+  if (_oom_emit_request_delivered) {\n+    \/\/ A request to emit leakprofiler events in response to CrashOnOutOfMemoryError\n+    \/\/ has already been completed. We are about to crash at any time now.\n+    assert(_oom_emit_request_posted, \"invariant\");\n+    assert(CrashOnOutOfMemoryError, \"invariant\");\n+    return;\n+  }\n+\n+  assert(_queue->is_nonempty(), \"invariant\");\n+\n+  {\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, jt));\n+    ThreadInVMfromNative transition(jt);\n+    while (_queue->is_nonempty()) {\n+      const JfrLeakProfilerEmitRequest& request = dequeue();\n+      LeakProfiler::emit_events(request.cutoff_ticks, request.emit_all, request.skip_bfs);\n+      if (_oom_emit_request_posted && request.oom) {\n+        assert(CrashOnOutOfMemoryError, \"invariant\");\n+        _oom_emit_request_delivered = true;\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/\/ If processing involved an out-of-memory request, issue an immediate flush operation.\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  if (_chunkwriter.is_valid() && _oom_emit_request_delivered) {\n+    invoke_flush();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":169,"deletions":11,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+class JavaThread;\n@@ -32,0 +33,1 @@\n+class JfrPostBox;\n@@ -38,0 +40,1 @@\n+  friend class Jfr;\n@@ -43,0 +46,1 @@\n+  JfrPostBox& _post_box;\n@@ -67,0 +71,8 @@\n+  void transition_and_post_leakprofiler_emit_msg(JavaThread* jt);\n+\n+  static void emit_leakprofiler_events_on_oom();\n+  static void emit_leakprofiler_events_paths_to_gc_roots(int64_t cutoff_ticks,\n+                                                         bool emit_all,\n+                                                         bool skip_bfs,\n+                                                         bool oom,\n+                                                         JavaThread* jt);\n@@ -75,1 +87,2 @@\n-  void emit_leakprofiler_events(int64_t cutoff_ticks, bool emit_all, bool skip_bfs);\n+  void emit_leakprofiler_events();\n+\n@@ -77,0 +90,3 @@\n+  static void emit_leakprofiler_events(int64_t cutoff_ticks,\n+                                       bool emit_all,\n+                                       bool skip_bfs);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  #define LEAKPROFILER_REFCHAINS (msgs & MSGBIT(MSG_EMIT_LEAKP_REFCHAINS))\n@@ -73,0 +74,3 @@\n+        if (LEAKPROFILER_REFCHAINS) {\n+          service.emit_leakprofiler_events();\n+        }\n@@ -101,1 +105,1 @@\n-  #undef SCAVENGE\n+  #undef LEAKPROFILER_REFCHAINS\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThreadLoop.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_METAPROGRAMMING_DEPENDENTALWAYSFALSE_HPP\n+#define SHARE_METAPROGRAMMING_DEPENDENTALWAYSFALSE_HPP\n+\n+\/\/ This provides a workaround for static_assert(false) in discarded or\n+\/\/ otherwise uninstantiated places.  Instead use\n+\/\/   static_assert(DependentAlwaysFalse<T>, \"...\")\n+\/\/ See http:\/\/wg21.link\/p2593r1. Some, but not all, compiler versions we're\n+\/\/ using have implemented that change as a DR:\n+\/\/ https:\/\/cplusplus.github.io\/CWG\/issues\/2518.html\n+template<typename T> inline constexpr bool DependentAlwaysFalse = false;\n+\n+#endif \/\/ SHARE_METAPROGRAMMING_DEPENDENTALWAYSFALSE_HPP\n","filename":"src\/hotspot\/share\/metaprogramming\/dependentAlwaysFalse.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1210,1 +1210,1 @@\n-Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n+Node* MinMaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1218,1 +1218,1 @@\n-Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n+Node* MinMaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n@@ -1226,1 +1226,1 @@\n-Node* MaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn) {\n+Node* MinMaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn) {\n@@ -1258,1 +1258,1 @@\n-Node* MaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn) {\n+Node* MinMaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn) {\n@@ -1305,1 +1305,1 @@\n-Node* MaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n+Node* MinMaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n@@ -1342,1 +1342,1 @@\n-Node* MaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n+Node* MinMaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n@@ -1416,1 +1416,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1449,1 +1449,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1579,1 +1579,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1611,1 +1611,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1625,1 +1625,1 @@\n-int MaxNode::opposite_opcode() const {\n+int MinMaxNode::opposite_opcode() const {\n@@ -1636,1 +1636,1 @@\n-Node* MaxNode::find_identity_operation(Node* operation, Node* operand) {\n+Node* MinMaxNode::find_identity_operation(Node* operation, Node* operand) {\n@@ -1660,1 +1660,1 @@\n-Node* MaxNode::Identity(PhaseGVN* phase) {\n+Node* MinMaxNode::Identity(PhaseGVN* phase) {\n@@ -1665,1 +1665,1 @@\n-  Node* identity_1 = MaxNode::find_identity_operation(in(2), in(1));\n+  Node* identity_1 = MinMaxNode::find_identity_operation(in(2), in(1));\n@@ -1670,1 +1670,1 @@\n-  Node* identity_2 = MaxNode::find_identity_operation(in(1), in(2));\n+  Node* identity_2 = MinMaxNode::find_identity_operation(in(1), in(2));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-class MaxNode : public AddNode {\n+class MinMaxNode : public AddNode {\n@@ -334,1 +334,3 @@\n-  MaxNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}\n+  MinMaxNode(Node* in1, Node* in2) : AddNode(in1, in2) {\n+    init_class_id(Class_MinMax);\n+  }\n@@ -376,1 +378,1 @@\n-class MaxINode : public MaxNode {\n+class MaxINode : public MinMaxNode {\n@@ -378,1 +380,1 @@\n-  MaxINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}\n+  MaxINode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -393,1 +395,1 @@\n-class MinINode : public MaxNode {\n+class MinINode : public MinMaxNode {\n@@ -395,1 +397,1 @@\n-  MinINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}\n+  MinINode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -409,1 +411,1 @@\n-class MaxLNode : public MaxNode {\n+class MaxLNode : public MinMaxNode {\n@@ -411,1 +413,1 @@\n-  MaxLNode(Compile* C, Node* in1, Node* in2) : MaxNode(in1, in2) {\n+  MaxLNode(Compile* C, Node* in1, Node* in2) : MinMaxNode(in1, in2) {\n@@ -428,1 +430,1 @@\n-class MinLNode : public MaxNode {\n+class MinLNode : public MinMaxNode {\n@@ -430,1 +432,1 @@\n-  MinLNode(Compile* C, Node* in1, Node* in2) : MaxNode(in1, in2) {\n+  MinLNode(Compile* C, Node* in1, Node* in2) : MinMaxNode(in1, in2) {\n@@ -447,1 +449,1 @@\n-class MaxFNode : public MaxNode {\n+class MaxFNode : public MinMaxNode {\n@@ -449,1 +451,1 @@\n-  MaxFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MaxFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -461,1 +463,1 @@\n-class MinFNode : public MaxNode {\n+class MinFNode : public MinMaxNode {\n@@ -463,1 +465,1 @@\n-  MinFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MinFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -475,1 +477,1 @@\n-class MaxHFNode : public MaxNode {\n+class MaxHFNode : public MinMaxNode {\n@@ -477,1 +479,1 @@\n-  MaxHFNode(Node* in1, Node* in2) : MaxNode(in1, in2) {}\n+  MaxHFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -489,1 +491,1 @@\n-class MinHFNode : public MaxNode {\n+class MinHFNode : public MinMaxNode {\n@@ -491,1 +493,1 @@\n-  MinHFNode(Node* in1, Node* in2) : MaxNode(in1, in2) {}\n+  MinHFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -503,1 +505,1 @@\n-class MaxDNode : public MaxNode {\n+class MaxDNode : public MinMaxNode {\n@@ -505,1 +507,1 @@\n-  MaxDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MaxDNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -517,1 +519,1 @@\n-class MinDNode : public MaxNode {\n+class MinDNode : public MinMaxNode {\n@@ -519,1 +521,1 @@\n-  MinDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MinDNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -678,3 +678,0 @@\n-  develop(bool, VerifyIntrinsicChecks, false,                               \\\n-          \"Verify in intrinsic that Java level checks work as expected\")    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,1 +450,2 @@\n-    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline || StressIncrementalInlining, \"we're doing late inlining\");\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || cg->is_virtual_late_inline() ||\n+           AlwaysIncrementalInline || StressIncrementalInlining, \"we're doing late inlining\");\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1070,0 +1070,9 @@\n+bool CallNode::is_call_to_multianewarray_stub() const {\n+  if (_name != nullptr &&\n+      strstr(_name, \"multianewarray\") != nullptr &&\n+      strstr(_name, \"C2 runtime\") != nullptr) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -780,0 +780,1 @@\n+  bool is_call_to_multianewarray_stub() const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1115,2 +1115,0 @@\n-  Node *hook = new Node(1);\n-\n@@ -1132,1 +1130,3 @@\n-      hook->init_req(0, x);       \/\/ Add a use to x to prevent him from dying\n+      \/\/ Add a use to x to prevent it from dying\n+      Node* hook = new Node(1);\n+      hook->init_req(0, x);\n@@ -1188,0 +1188,1 @@\n+  Node* hook = new Node(1);\n@@ -1410,2 +1411,0 @@\n-  Node *hook = new Node(1);\n-\n@@ -1429,1 +1428,3 @@\n-      hook->init_req(0, x);       \/\/ Add a use to x to prevent him from dying\n+      \/\/ Add a use to x to prevent it from dying\n+      Node* hook = new Node(1);\n+      hook->init_req(0, x);\n@@ -1435,1 +1436,1 @@\n-        hook->set_req(0, x);    \/\/ Add a use to x to prevent him from dying\n+        hook->set_req(0, x);    \/\/ Add a use to x to prevent it from dying\n@@ -1485,0 +1486,2 @@\n+  \/\/ Add a use to x to prevent him from dying\n+  Node* hook = new Node(1);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1081,0 +1081,33 @@\n+\n+      \/\/ If new_load is a Load but not from an AddP, it means that the load is folded into another\n+      \/\/ load. And since this load is not from a field, we cannot create a unique type for it.\n+      \/\/ For example:\n+      \/\/\n+      \/\/   if (b) {\n+      \/\/       Holder h1 = new Holder();\n+      \/\/       Object o = ...;\n+      \/\/       h.o = o.getClass();\n+      \/\/   } else {\n+      \/\/       Holder h2 = ...;\n+      \/\/   }\n+      \/\/   Holder h = Phi(h1, h2);\n+      \/\/   Object r = h.o;\n+      \/\/\n+      \/\/ Then, splitting r through the merge point results in:\n+      \/\/\n+      \/\/   if (b) {\n+      \/\/       Holder h1 = new Holder();\n+      \/\/       Object o = ...;\n+      \/\/       h.o = o.getClass();\n+      \/\/       Object o1 = h.o;\n+      \/\/   } else {\n+      \/\/       Holder h2 = ...;\n+      \/\/       Object o2 = h2.o;\n+      \/\/   }\n+      \/\/   Object r = Phi(o1, o2);\n+      \/\/\n+      \/\/ In this case, o1 is folded to o.getClass() which is a Load but not from an AddP, but from\n+      \/\/ an OopHandle that is loaded from the Klass of o.\n+      if (!new_addp->is_AddP()) {\n+        continue;\n+      }\n@@ -2156,2 +2189,2 @@\n-      assert(strncmp(name, \"C2 Runtime multianewarray\", 25) == 0 ||\n-             strncmp(name, \"C2 Runtime load_unknown_inline\", 30) == 0 ||\n+      assert(call->as_CallStaticJava()->is_call_to_multianewarray_stub() ||\n+             strncmp(name, \"load_unknown_inline\", 19) == 0 ||\n@@ -2882,2 +2915,2 @@\n-    assert(strncmp(name, \"C2 Runtime multianewarray\", 25) == 0 ||\n-           strncmp(name, \"C2 Runtime load_unknown_inline\", 30) == 0 ||\n+    assert(alloc->as_CallStaticJava()->is_call_to_multianewarray_stub() ||\n+           strncmp(name, \"load_unknown_inline\", 19) == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -971,5 +971,1 @@\n-void LibraryCallKit::generate_string_range_check(Node* array,\n-                                                 Node* offset,\n-                                                 Node* count,\n-                                                 bool char_count,\n-                                                 bool halt_on_oob) {\n+void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n@@ -993,11 +989,4 @@\n-    if (halt_on_oob) {\n-      bailout = _gvn.transform(bailout)->as_Region();\n-      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n-      Node* halt = _gvn.transform(new HaltNode(bailout, frame, \"unexpected guard failure in intrinsic\"));\n-      C->root()->add_req(halt);\n-    } else {\n-      PreserveJVMState pjvms(this);\n-      set_control(_gvn.transform(bailout));\n-      uncommon_trap(Deoptimization::Reason_intrinsic,\n-                    Deoptimization::Action_maybe_recompile);\n-    }\n+    PreserveJVMState pjvms(this);\n+    set_control(_gvn.transform(bailout));\n+    uncommon_trap(Deoptimization::Reason_intrinsic,\n+                  Deoptimization::Action_maybe_recompile);\n@@ -1161,1 +1150,0 @@\n-\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1173,7 +1161,1 @@\n-  if (VerifyIntrinsicChecks) {\n-    ba = must_be_not_null(ba, true);\n-    generate_string_range_check(ba, offset, len, false, true);\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n+  ba = must_be_not_null(ba, true);\n@@ -1181,0 +1163,5 @@\n+  \/\/ Range checks\n+  generate_string_range_check(ba, offset, len, false);\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -6954,3 +6941,0 @@\n-\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6967,8 +6951,2 @@\n-  \/\/ Cast source & target arrays to not-null\n-  if (VerifyIntrinsicChecks) {\n-    src = must_be_not_null(src, true);\n-    dst = must_be_not_null(dst, true);\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n+  src = must_be_not_null(src, true);\n+  dst = must_be_not_null(dst, true);\n@@ -6991,9 +6969,0 @@\n-  \/\/ Check source & target bounds\n-  if (VerifyIntrinsicChecks) {\n-    generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n-    generate_string_range_check(dst, dst_offset, length, false, true);\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":44,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -175,2 +175,1 @@\n-                                    Node* length, bool char_count,\n-                                    bool halt_on_oob = false);\n+                                    Node* length, bool char_count);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -982,1 +982,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeInteger::bottom(bt), _igvn);\n+    inner_iters_max = MinMaxNode::max_diff_with_zero(limit, outer_phi, TypeInteger::bottom(bt), _igvn);\n@@ -984,1 +984,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeInteger::bottom(bt), _igvn);\n+    inner_iters_max = MinMaxNode::max_diff_with_zero(outer_phi, limit, TypeInteger::bottom(bt), _igvn);\n@@ -992,1 +992,1 @@\n-  Node* inner_iters_actual = MaxNode::unsigned_min(inner_iters_max, inner_iters_limit, inner_iters_actual_range, _igvn);\n+  Node* inner_iters_actual = MinMaxNode::unsigned_min(inner_iters_max, inner_iters_limit, inner_iters_actual_range, _igvn);\n@@ -1621,1 +1621,1 @@\n-      R = MaxNode::unsigned_min(R, max_range, TypeLong::POS, _igvn);\n+      R = MinMaxNode::unsigned_min(R, max_range, TypeLong::POS, _igvn);\n@@ -1720,1 +1720,1 @@\n-  Node* min = MaxNode::signed_min(R, H, TypeLong::LONG, _igvn);\n+  Node* min = MinMaxNode::signed_min(R, H, TypeLong::LONG, _igvn);\n@@ -1722,1 +1722,1 @@\n-  Node* max = MaxNode::signed_max(L, min, TypeLong::LONG, _igvn);\n+  Node* max = MinMaxNode::signed_max(L, min, TypeLong::LONG, _igvn);\n@@ -3488,1 +3488,1 @@\n-      max = MaxNode::max_diff_with_zero(limit, iv_phi, TypeInt::INT, *igvn);\n+      max = MinMaxNode::max_diff_with_zero(limit, iv_phi, TypeInt::INT, *igvn);\n@@ -3490,1 +3490,1 @@\n-      max = MaxNode::max_diff_with_zero(iv_phi, limit, TypeInt::INT, *igvn);\n+      max = MinMaxNode::max_diff_with_zero(iv_phi, limit, TypeInt::INT, *igvn);\n@@ -3495,1 +3495,1 @@\n-    Node* min = MaxNode::unsigned_min(max, const_iters, TypeInt::make(0, scaled_iters, Type::WidenMin), *igvn);\n+    Node* min = MinMaxNode::unsigned_min(max, const_iters, TypeInt::make(0, scaled_iters, Type::WidenMin), *igvn);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3261,1 +3261,1 @@\n-        Node* repl = MaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        Node* repl = MinMaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n@@ -3265,1 +3265,1 @@\n-        Node* repl = MaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        Node* repl = MinMaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4190,1 +4190,0 @@\n-    _adr_type(at),\n@@ -4198,0 +4197,1 @@\n+  DEBUG_ONLY(_adr_type = at; adr_type();)\n@@ -4221,0 +4221,5 @@\n+const TypePtr* LoadStoreNode::adr_type() const {\n+  const TypePtr* cross_check = DEBUG_ONLY(_adr_type) NOT_DEBUG(nullptr);\n+  return MemNode::calculate_adr_type(in(MemNode::Address)->bottom_type(), cross_check);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -823,5 +823,0 @@\n-  virtual const TypePtr *adr_type() const {\n-    Node* ctrl = in(0);\n-    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n-    return ctrl->in(MemNode::Memory)->adr_type();\n-  }\n@@ -840,1 +835,0 @@\n-  const TypePtr* _adr_type;     \/\/ What kind of memory is being addressed?\n@@ -843,0 +837,3 @@\n+#ifdef ASSERT\n+  const TypePtr* _adr_type;     \/\/ What kind of memory is being addressed?\n+#endif \/\/ ASSERT\n@@ -850,1 +847,1 @@\n-  virtual const class TypePtr *adr_type() const { return _adr_type; }  \/\/ returns bottom_type of address\n+  virtual const TypePtr* adr_type() const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-    return MaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n+    return MinMaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n@@ -276,1 +276,1 @@\n-    return MaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n+    return MinMaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+class MinMaxNode;\n@@ -825,0 +826,1 @@\n+      DEFINE_CLASS_ID(MinMax,      Add, 0)\n@@ -1006,0 +1008,1 @@\n+  DEFINE_CLASS_QUERY(MinMax)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -765,16 +765,28 @@\n-void PhaseGVN::dead_loop_check( Node *n ) {\n-  \/\/ Phi may reference itself in a loop\n-  if (n != nullptr && !n->is_dead_loop_safe() && !n->is_CFG()) {\n-    \/\/ Do 2 levels check and only data inputs.\n-    bool no_dead_loop = true;\n-    uint cnt = n->req();\n-    for (uint i = 1; i < cnt && no_dead_loop; i++) {\n-      Node *in = n->in(i);\n-      if (in == n) {\n-        no_dead_loop = false;\n-      } else if (in != nullptr && !in->is_dead_loop_safe()) {\n-        uint icnt = in->req();\n-        for (uint j = 1; j < icnt && no_dead_loop; j++) {\n-          if (in->in(j) == n || in->in(j) == in)\n-            no_dead_loop = false;\n-        }\n+void PhaseGVN::dead_loop_check(Node* n) {\n+  \/\/ Phi may reference itself in a loop.\n+  if (n == nullptr || n->is_dead_loop_safe() || n->is_CFG()) {\n+    return;\n+  }\n+\n+  \/\/ Do 2 levels check and only data inputs.\n+  for (uint i = 1; i < n->req(); i++) {\n+    Node* in = n->in(i);\n+    if (in == n) {\n+      n->dump_bfs(100, nullptr, \"\");\n+      fatal(\"Dead loop detected, node references itself: %s (%d)\",\n+            n->Name(), n->_idx);\n+    }\n+\n+    if (in == nullptr || in->is_dead_loop_safe()) {\n+      continue;\n+    }\n+    for (uint j = 1; j < in->req(); j++) {\n+      if (in->in(j) == n) {\n+        n->dump_bfs(100, nullptr, \"\");\n+        fatal(\"Dead loop detected, node input references current node: %s (%d) -> %s (%d)\",\n+              in->Name(), in->_idx, n->Name(), n->_idx);\n+      }\n+      if (in->in(j) == in) {\n+        n->dump_bfs(100, nullptr, \"\");\n+        fatal(\"Dead loop detected, node input references itself: %s (%d)\",\n+              in->Name(), in->_idx);\n@@ -783,2 +795,0 @@\n-    if (!no_dead_loop) { n->dump_bfs(100, nullptr, \"\"); }\n-    assert(no_dead_loop, \"dead loop detected\");\n@@ -2658,0 +2668,9 @@\n+  \/\/ Check for Max\/Min(A, Max\/Min(B, C)) where A == B or A == C\n+  if (use->is_MinMax()) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == use->Opcode()) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":37,"deletions":18,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2485,0 +2485,5 @@\n+  \/\/ Since casts specifically change the type of a node, stay on the safe side and do not truncate them.\n+  if (in->is_ConstraintCast()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -190,1 +190,4 @@\n-  _memory_slices.find_memory_slices();\n+  VStatus slices_status = _memory_slices.find_memory_slices();\n+  if (!slices_status.is_success()) {\n+    return slices_status;\n+  }\n@@ -210,1 +213,3 @@\n-\/\/ - No memory phi: only loads. All have the same input memory state from before the loop.\n+\/\/ - No memory phi: only loads.\n+\/\/   - Usually, all loads have the same input memory state from before the loop.\n+\/\/   - Only rarely this is not the case, and we just bail out for now.\n@@ -212,1 +217,1 @@\n-void VLoopMemorySlices::find_memory_slices() {\n+VStatus VLoopMemorySlices::find_memory_slices() {\n@@ -231,2 +236,9 @@\n-        assert(_inputs.at(alias_idx) == nullptr || _inputs.at(alias_idx) == load->in(1),\n-               \"not yet touched or the same input\");\n+        \/\/ For now, we can only handle slices with a single memory input before the loop,\n+        \/\/ so if we find multiple, we bail out of auto vectorization. If this becomes\n+        \/\/ too restrictive in the fututure, we could consider tracking multiple inputs.\n+        \/\/ Different memory inputs can for example happen if one load has its memory state\n+        \/\/ optimized, and the other load fails to have it optimized, for example because\n+        \/\/ it does not end up on the IGVN worklist any more.\n+        if (_inputs.at(alias_idx) != nullptr && _inputs.at(alias_idx) != load->in(1)) {\n+          return VStatus::make_failure(FAILURE_DIFFERENT_MEMORY_INPUT);\n+        }\n@@ -246,0 +258,1 @@\n+  return VStatus::make_success();\n@@ -1112,1 +1125,1 @@\n-  Node* last_clamped = MaxNode::build_min_max_long(&igvn, initL, last, stride > 0);\n+  Node* last_clamped = MinMaxNode::build_min_max_long(&igvn, initL, last, stride > 0);\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,0 +507,2 @@\n+  static constexpr char const* FAILURE_DIFFERENT_MEMORY_INPUT = \"Load only slice has multiple memory inputs\";\n+\n@@ -524,1 +526,1 @@\n-  void find_memory_slices();\n+  VStatus find_memory_slices();\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,0 @@\n-#include \"utilities\/checkedCast.hpp\"\n@@ -1212,1 +1211,1 @@\n-  int  pos = 0;\n+  size_t pos = 0;\n@@ -1217,1 +1216,1 @@\n-  int  quote_c        = 0;\n+  char quote_c        = 0;\n@@ -1220,2 +1219,8 @@\n-  int c = getc(stream);\n-  while(c != EOF && pos < (int)(sizeof(token)-1)) {\n+  int c_or_eof = getc(stream);\n+  while (c_or_eof != EOF && pos < (sizeof(token) - 1)) {\n+    \/\/ We have checked the c_or_eof for EOF. getc should only ever return the\n+    \/\/ EOF or an unsigned char converted to an int. We cast down to a char to\n+    \/\/ avoid the char to int promotions we would otherwise do in the comparisons\n+    \/\/ below (which would be incorrect if we ever compared to a non-ascii char),\n+    \/\/ and the int to char conversions we would otherwise do in the assignments.\n+    const char c = static_cast<char>(c_or_eof);\n@@ -1229,1 +1234,1 @@\n-          token[pos++] = checked_cast<char>(c);\n+          token[pos++] = c;\n@@ -1249,1 +1254,1 @@\n-        token[pos++] = checked_cast<char>(c);\n+        token[pos++] = c;\n@@ -1252,1 +1257,1 @@\n-    c = getc(stream);\n+    c_or_eof = getc(stream);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"metaprogramming\/dependentAlwaysFalse.hpp\"\n@@ -77,0 +78,1 @@\n+\/\/     v.compare_set(x, y [, o]) -> bool\n@@ -269,0 +271,5 @@\n+  bool compare_set(T compare_value, T new_value,\n+                   atomic_memory_order order = memory_order_conservative) {\n+    return compare_exchange(compare_value, new_value, order) == compare_value;\n+  }\n+\n@@ -481,0 +488,7 @@\n+  bool compare_set(T compare_value, T new_value,\n+                   atomic_memory_order order = memory_order_conservative) {\n+    return _value.compare_set(decay(compare_value),\n+                              decay(new_value),\n+                              order);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -469,4 +469,1 @@\n-  \/\/ 2nd argument (emit_event_shutdown) should be set to false\n-  \/\/ because EventShutdown would be emitted at Threads::destroy_vm().\n-  \/\/ (one of the callers of before_exit())\n-  JFR_ONLY(Jfr::on_vm_shutdown(true, false, halt);)\n+  JFR_ONLY(Jfr::on_vm_shutdown(false, halt);)\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_PREFETCH_HPP\n-#define SHARE_RUNTIME_PREFETCH_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-\n-\/\/ If calls to prefetch methods are in a loop, the loop should be cloned\n-\/\/ such that if Prefetch{Scan,Copy}Interval and\/or PrefetchFieldInterval\n-\/\/ say not to do prefetching, these methods aren't called.  At the very\n-\/\/ least, they take up a memory issue slot.  They should be implemented\n-\/\/ as inline assembly code: doing an actual call isn't worth the cost.\n-\n-class Prefetch : AllStatic {\n- public:\n-  \/\/ Prefetch anticipating read; must not fault, semantically a no-op\n-  static void read(const void* loc, intx interval);\n-\n-  \/\/ Prefetch anticipating write; must not fault, semantically a no-op\n-  static void write(void* loc, intx interval);\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_PREFETCH_HPP\n","filename":"src\/hotspot\/share\/runtime\/prefetch.hpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"runtime\/prefetch.hpp\"\n-\n+#include \"memory\/allStatic.hpp\"\n@@ -31,0 +30,16 @@\n+\n+\/\/ If calls to prefetch methods are in a loop, the loop should be cloned\n+\/\/ such that if Prefetch{Scan,Copy}Interval and\/or PrefetchFieldInterval\n+\/\/ say not to do prefetching, these methods aren't called.  At the very\n+\/\/ least, they take up a memory issue slot.  They should be implemented\n+\/\/ as inline assembly code: doing an actual call isn't worth the cost.\n+\n+class Prefetch : AllStatic {\n+ public:\n+  \/\/ Prefetch anticipating read; must not fault, semantically a no-op\n+  static void read(const void* loc, intx interval);\n+\n+  \/\/ Prefetch anticipating write; must not fault, semantically a no-op\n+  static void write(void* loc, intx interval);\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/prefetch.inline.hpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -202,2 +202,1 @@\n-\/\/ C2 stubs are provided with names in the format \"C2 Runtime\n-\/\/ <stubname> _blob\".\n+\/\/ C2 stubs are provided with names in the format \"<stubname>_blob (C2 runtime)\".\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-                      \"Shared Runtime \" # name \"_blob\",                 \\\n+                      #name \"_blob (shared runtime)\",                   \\\n@@ -491,1 +491,1 @@\n-                  \"C1 Runtime \" # name \"_blob\",                   \\\n+                  #name \"_blob (C1 runtime)\",                     \\\n@@ -499,1 +499,1 @@\n-                  \"C2 Runtime \" # name \"_blob\",             \\\n+                  #name \"_blob (C2 runtime)\",               \\\n@@ -507,1 +507,1 @@\n-                  \"C2 Runtime \" # name \"_blob\",                   \\\n+                  #name \"_blob (C2 runtime)\",                     \\\n@@ -515,1 +515,1 @@\n-                       \"Stub Generator \" # blob \"_blob\",          \\\n+                       #blob \"_blob (stub gen)\",                  \\\n@@ -521,1 +521,1 @@\n-                       \"Stub Generator \" # stub \"_stub\",          \\\n+                       #stub \"_stub (stub gen)\",                  \\\n@@ -528,1 +528,1 @@\n-                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        #field_name \"_entry (stub gen)\",                \\\n@@ -538,1 +538,1 @@\n-                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        #field_name \"_entry (stub gen)\",                \\\n@@ -548,1 +548,1 @@\n-                        \"Stub Generator \" # field_name \"_entry\",        \\\n+                        #field_name \"_entry (stub gen)\",                \\\n@@ -570,1 +570,1 @@\n-                        \"Stub Generator \" # arch_name \"_\" # field_name \"_entry\", \\\n+                        #arch_name \"_\" # field_name \"_entry (stub gen)\",\\\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +145,1 @@\n-#include <cstdlib>\n+#include \"cppstdlib\/cstdlib.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/byteswap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  if (_first.compare_exchange(expect, node) == expect) {\n+  if (_first.compare_set(expect, node)) {\n@@ -175,1 +175,1 @@\n-  if (_first.compare_exchange(tmp, set_state(tmp, STATE_LOCK_BIT)) == tmp) {\n+  if (_first.compare_set(tmp, set_state(tmp, STATE_LOCK_BIT))) {\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -265,0 +268,2 @@\n+  JFR_ONLY(Jfr::on_report_java_out_of_memory();)\n+\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,6 +35,0 @@\n-\/\/ Workaround for noreturn functions: exit, _exit, _Exit - see the clang\n-\/\/ definition of FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE.\n-#ifdef __clang__\n-#include <stdlib.h>\n-#endif\n-\n@@ -52,6 +46,0 @@\n-FORBID_IMPORTED_NORETURN_C_FUNCTION(void exit(int), noexcept, \"use os::exit\")\n-FORBID_IMPORTED_NORETURN_C_FUNCTION(void _Exit(int), noexcept, \"use os::exit\")\n-\n-\/\/ Windows puts _exit in <stdlib.h>, POSIX in <unistd.h>.\n-FORBID_IMPORTED_NORETURN_C_FUNCTION(void _exit(int), \/* not noexcept *\/, \"use os::exit\")\n-\n@@ -73,7 +61,2 @@\n-\/\/ All of the following functions return raw C-heap pointers (sometimes as an\n-\/\/ option, e.g. realpath or getwd) or, in case of free(), take raw C-heap\n-\/\/ pointers.  We generally want allocation to be done through NMT.\n-FORBID_IMPORTED_C_FUNCTION(void* malloc(size_t size), noexcept, \"use os::malloc\");\n-FORBID_IMPORTED_C_FUNCTION(void free(void *ptr), noexcept, \"use os::free\");\n-FORBID_IMPORTED_C_FUNCTION(void* calloc(size_t nmemb, size_t size), noexcept, \"use os::malloc and zero out manually\");\n-FORBID_IMPORTED_C_FUNCTION(void* realloc(void *ptr, size_t size), noexcept, \"use os::realloc\");\n+\/\/ All of the following functions return raw C-heap pointers.  We generally\n+\/\/ want allocation to be done through NMT.\n","filename":"src\/hotspot\/share\/utilities\/forbiddenFunctions.hpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1391,8 +1391,0 @@\n-\/\/ This provides a workaround for static_assert(false) in discarded or\n-\/\/ otherwise uninstantiated places.  Instead use\n-\/\/   static_assert(DependentAlwaysFalse<T>, \"...\")\n-\/\/ See http:\/\/wg21.link\/p2593r1. Some, but not all, compiler versions we're\n-\/\/ using have implemented that change as a DR:\n-\/\/ https:\/\/cplusplus.github.io\/CWG\/issues\/2518.html\n-template<typename T> inline constexpr bool DependentAlwaysFalse = false;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n+\n@@ -47,9 +49,0 @@\n-#include <stdlib.h>\n-\/\/ In stdlib.h on AIX malloc is defined as a macro causing\n-\/\/ compiler errors when resolving them in different depths as it\n-\/\/ happens in the log tags. This avoids the macro.\n-#if (defined(__VEC__) || defined(__AIXVEC)) && defined(AIX) \\\n-    && defined(__open_xl_version__) && __open_xl_version__ >= 17\n-  #undef malloc\n-  extern void *malloc(size_t) asm(\"vec_malloc\");\n-#endif\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n+\n@@ -48,1 +50,0 @@\n-# include <stdlib.h>\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"metaprogramming\/dependentAlwaysFalse.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/lockFreeStack.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -36,1 +37,0 @@\n-#include <stdlib.h>\n","filename":"src\/hotspot\/share\/utilities\/parseInteger.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -37,0 +38,3 @@\n+#include <stdio.h>\n+#include <string.h>\n+\n@@ -56,1 +60,0 @@\n-[[noreturn]] inline void _exit(int status) { ::_exit(status); }\n","filename":"src\/hotspot\/share\/utilities\/permitForbiddenFunctions.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1901,1 +1901,1 @@\n-  JFR_ONLY(Jfr::on_vm_shutdown(static_cast<VMErrorType>(_id) == OOM_JAVA_HEAP_FATAL, true);)\n+  JFR_ONLY(Jfr::on_vm_shutdown(true, false, static_cast<VMErrorType>(_id) == OOM_JAVA_HEAP_FATAL);)\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-    if (_state.compare_exchange(state, new_state) == state) {\n+    if (_state.compare_set(state, new_state)) {\n@@ -221,1 +221,1 @@\n-    if (_state.compare_exchange(state, new_state) == state) {\n+    if (_state.compare_set(state, new_state)) {\n@@ -250,1 +250,1 @@\n-    if (_state.compare_exchange(state, new_state) == state) {\n+    if (_state.compare_set(state, new_state)) {\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1477,0 +1477,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n@@ -1495,0 +1496,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1440,0 +1440,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n@@ -1463,0 +1464,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2381,0 +2381,14 @@\n+        \/\/ Implementation note: this method is intentionally coded in\n+        \/\/ a straightforward manner relying on BigDecimal for the\n+        \/\/ heavy-lifting of the numerical computation. It would be\n+        \/\/ possible for the computation to be done solely using binary\n+        \/\/ floating-point and integer operations, at the cost of more\n+        \/\/ complicated logic. Since most processors have hardware\n+        \/\/ support for fma and this method is an intrinsic candidate,\n+        \/\/ the software implementation below would only be used on\n+        \/\/ processors without native fma support (and also possibly on\n+        \/\/ processors with native fma support while running in the\n+        \/\/ interpreter). Therefore, the direct performance of the code\n+        \/\/ is less of a concern than the code's simplicity,\n+        \/\/ maintainability, and testability.\n+\n@@ -2495,0 +2509,2 @@\n+        \/\/ See implementation note in fma(double, double, double).\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-            int ret = StringCoding.encodeISOArray(val, sp, dst, dp, len);\n+            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n@@ -2048,1 +2048,1 @@\n-    boolean bytesCompatible(Charset charset) {\n+    boolean bytesCompatible(Charset charset, int srcIndex, int numChars) {\n@@ -2053,1 +2053,1 @@\n-                return !StringCoding.hasNegatives(value, 0, value.length); \/\/ ok, if ASCII-compatible\n+                return !StringCoding.hasNegatives(value, srcIndex, numChars); \/\/ ok, if ASCII-compatible\n@@ -2059,2 +2059,9 @@\n-    void copyToSegmentRaw(MemorySegment segment, long offset) {\n-        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n+    void copyToSegmentRaw(MemorySegment segment, long offset, int srcIndex, int srcLength) {\n+        if (!isLatin1()) {\n+            \/\/ This method is intended to be used together with bytesCompatible, which currently only supports\n+            \/\/ latin1 strings. In the future, bytesCompatible could be updated to handle more cases, like\n+            \/\/ UTF-16 strings (when the platform and charset endianness match, and the String doesnt contain\n+            \/\/ unpaired surrogates). If that happens, copyToSegmentRaw should also be updated.\n+            throw new IllegalStateException(\"This string does not support copyToSegmentRaw\");\n+        }\n+        MemorySegment.copy(value, srcIndex, segment, ValueLayout.JAVA_BYTE, offset, srcLength);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import jdk.internal.util.Preconditions;\n@@ -32,2 +31,0 @@\n-import java.util.function.BiFunction;\n-\n@@ -44,1 +41,1 @@\n-    static int countNonZeroAscii(String s) {\n+    public static int countNonZeroAscii(String s) {\n@@ -56,1 +53,1 @@\n-    private static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n+    public static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n@@ -69,1 +66,1 @@\n-    private static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n+    public static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n@@ -80,1 +77,1 @@\n-    static boolean hasNegatives(byte[] ba, int off, int len) {\n+    public static boolean hasNegatives(byte[] ba, int off, int len) {\n@@ -91,7 +88,0 @@\n-     *\n-     * @param ba a byte array\n-     * @param off the index of the first byte to start reading from\n-     * @param len the total number of bytes to read\n-     * @throws NullPointerException if {@code ba} is null\n-     * @throws ArrayIndexOutOfBoundsException if the provided sub-range is\n-     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -99,8 +89,0 @@\n-    static int countPositives(byte[] ba, int off, int len) {\n-        Preconditions.checkFromIndexSize(\n-                off, len,\n-                ba.length,      \/\/ Implicit null check on `ba`\n-                Preconditions.AIOOBE_FORMATTER);\n-        return countPositives0(ba, off, len);\n-    }\n-\n@@ -108,1 +90,1 @@\n-    private static int countPositives0(byte[] ba, int off, int len) {\n+    public static int countPositives(byte[] ba, int off, int len) {\n@@ -118,28 +100,0 @@\n-    \/**\n-     * Encodes as many ISO-8859-1 codepoints as possible from the source byte\n-     * array containing characters encoded in UTF-16, into the destination byte\n-     * array, assuming that the encoding is ISO-8859-1 compatible.\n-     *\n-     * @param sa the source byte array containing characters encoded in UTF-16\n-     * @param sp the index of the <em>character (not byte!)<\/em> from the source array to start reading from\n-     * @param da the target byte array\n-     * @param dp the index of the target array to start writing to\n-     * @param len the maximum number of <em>characters (not bytes!)<\/em> to be encoded\n-     * @return the total number of <em>characters (not bytes!)<\/em> successfully encoded\n-     * @throws NullPointerException if any of the provided arrays is null\n-     *\/\n-    static int encodeISOArray(byte[] sa, int sp,\n-                              byte[] da, int dp, int len) {\n-        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n-        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n-        int sl;\n-        if ((sp | dp | len) < 0 ||\n-                \/\/ Halving the length of `sa` to obtain the number of characters:\n-                sp >= (sl = sa.length >>> 1) ||     \/\/ Implicit null check on `sa`\n-                dp >= da.length) {                  \/\/ Implicit null check on `da`\n-            return 0;\n-        }\n-        int minLen = Math.min(len, Math.min(sl - sp, da.length - dp));\n-        return encodeISOArray0(sa, sp, da, dp, minLen);\n-    }\n-\n@@ -147,2 +101,2 @@\n-    private static int encodeISOArray0(byte[] sa, int sp,\n-                                       byte[] da, int dp, int len) {\n+    public static int implEncodeISOArray(byte[] sa, int sp,\n+                                         byte[] da, int dp, int len) {\n@@ -159,26 +113,0 @@\n-    \/**\n-     * Encodes as many ASCII codepoints as possible from the source\n-     * character array into the destination byte array, assuming that\n-     * the encoding is ASCII compatible.\n-     *\n-     * @param sa the source character array\n-     * @param sp the index of the source array to start reading from\n-     * @param da the target byte array\n-     * @param dp the index of the target array to start writing to\n-     * @param len the maximum number of characters to be encoded\n-     * @return the total number of characters successfully encoded\n-     * @throws NullPointerException if any of the provided arrays is null\n-     *\/\n-    static int encodeAsciiArray(char[] sa, int sp,\n-                                byte[] da, int dp, int len) {\n-        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n-        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n-        if ((sp | dp | len) < 0 ||\n-                sp >= sa.length ||      \/\/ Implicit null check on `sa`\n-                dp >= da.length) {      \/\/ Implicit null check on `da`\n-            return 0;\n-        }\n-        int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n-        return encodeAsciiArray0(sa, sp, da, dp, minLen);\n-    }\n-\n@@ -186,2 +114,3 @@\n-    static int encodeAsciiArray0(char[] sa, int sp,\n-                                 byte[] da, int dp, int len) {\n+    public static int implEncodeAsciiArray(char[] sa, int sp,\n+                                           byte[] da, int dp, int len)\n+    {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":11,"deletions":82,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -2195,2 +2196,2 @@\n-            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n-                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n+            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n@@ -2353,2 +2354,2 @@\n-            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-                string.copyToSegmentRaw(segment, offset);\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength) {\n+                string.copyToSegmentRaw(segment, offset, srcIndex, srcLength);\n@@ -2358,2 +2359,2 @@\n-            public boolean bytesCompatible(String string, Charset charset) {\n-                return string.bytesCompatible(charset);\n+            public boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars) {\n+                return string.bytesCompatible(charset, srcIndex, numChars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-     *  PARKING -> PINNED          \/\/ cont.yield failed, parked indefinitely on carrier\n@@ -94,1 +93,0 @@\n-     *   PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n@@ -97,0 +95,4 @@\n+     *  PARKING -> RUNNING         \/\/ cont.yield failed, need to park on carrier\n+     *  RUNNING -> PINNED          \/\/ park on carrier\n+     *   PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n+     *\n@@ -99,1 +101,0 @@\n-     * TIMED_PARKING -> TIMED_PINNED    \/\/ cont.yield failed, timed-parked on carrier\n@@ -101,0 +102,3 @@\n+     *\n+     * TIMED_PARKING -> RUNNING         \/\/ cont.yield failed, need to park on carrier\n+     *       RUNNING -> TIMED_PINNED    \/\/ park on carrier\n@@ -111,1 +115,1 @@\n-     *      WAIT -> UNBLOCKED      \/\/ timed-out\/interrupted\n+     *      WAIT -> UNBLOCKED      \/\/ interrupted\n@@ -859,0 +863,1 @@\n+     * @param lazySubmit to use lazySubmit if possible\n@@ -861,2 +866,1 @@\n-    @Override\n-    void unpark() {\n+    private void unpark(boolean lazySubmit) {\n@@ -868,1 +872,5 @@\n-                submitRunContinuation();\n+                if (lazySubmit) {\n+                    lazySubmitRunContinuation();\n+                } else {\n+                    submitRunContinuation();\n+                }\n@@ -891,0 +899,5 @@\n+    @Override\n+    void unpark() {\n+        unpark(false);\n+    }\n+\n@@ -907,5 +920,1 @@\n-        if (!getAndSetParkPermit(true)\n-                && (state() == TIMED_PARKED)\n-                && compareAndSetState(TIMED_PARKED, UNPARKED)) {\n-            lazySubmitRunContinuation();\n-        }\n+        unpark(true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+import jdk.internal.classfile.impl.Util;\n@@ -85,1 +87,32 @@\n-        return new AbstractInstruction.UnboundIncrementInstruction(slot, constant);\n+        var opcode = BytecodeHelpers.validateAndIsWideIinc(slot, constant) ? Opcode.IINC_W: Opcode.IINC;\n+        return new AbstractInstruction.UnboundIncrementInstruction(opcode, slot, constant);\n+    }\n+\n+    \/**\n+     * {@return an increment instruction}\n+     * <p>\n+     * {@code slot} must be {@link java.lang.classfile##u1 u1} and\n+     * {@code constant} must be within {@code [-128, 127]} for\n+     * {@link Opcode#IINC iinc}, or {@code slot} must be\n+     * {@link java.lang.classfile##u2 u2} and {@code constant} must be\n+     * within {@code [-32768, 32767]} for {@link Opcode#IINC_W wide iinc}.\n+     *\n+     * @apiNote\n+     * The explicit {@code op} argument allows creating {@code wide} or\n+     * regular increment instructions when {@code slot} and\n+     * {@code constant} can be encoded with more optimized\n+     * increment instructions.\n+     *\n+     * @param op the opcode for the specific type of increment instruction,\n+     *           which must be of kind {@link Opcode.Kind#INCREMENT}\n+     * @param slot the local variable slot to increment\n+     * @param constant the increment constant\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#INCREMENT} or {@code slot} or\n+     *         {@code constant} is out of range\n+     * @since 27\n+     *\/\n+    static IncrementInstruction of(Opcode op, int slot, int constant) {\n+        Util.checkKind(op, Opcode.Kind.INCREMENT);\n+        BytecodeHelpers.validateIncrement(op, slot, constant);\n+        return new AbstractInstruction.UnboundIncrementInstruction(op, slot, constant);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1299,6 +1299,1 @@\n-     * known byte length can be done like so:\n-     * {@snippet lang=java :\n-     *     byte[] bytes = new byte[length];\n-     *     MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, length);\n-     *     return new String(bytes, charset);\n-     * }\n+     * known byte length can be done using {@link #getString(long, Charset, long)}.\n@@ -1331,0 +1326,35 @@\n+    \/**\n+     * Reads a string from this segment at the given offset, using the provided length\n+     * and charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string. The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the string contains any {@code '\\0'} characters, they will be read as well.\n+     * This differs from {@link #getString(long, Charset)}, which will only read up\n+     * to the first {@code '\\0'}, resulting in truncation for string data that contains\n+     * the {@code '\\0'} character.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this\n+     *                access operation will occur\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the\n+     *                string bytes\n+     * @param byteLength length, in bytes, of the region of memory to read and decode into\n+     *                a string\n+     * @return a Java string constructed from the bytes read from the given starting\n+     *         address up to the given length\n+     * @throws IllegalArgumentException  if the size of the string is greater than the\n+     *         largest string supported by the platform\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - byteLength}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code isAccessibleBy(T) == false}\n+     * @throws IllegalArgumentException if {@code byteLength < 0}\n+     * @since 27\n+     *\/\n+    String getString(long offset, Charset charset, long byteLength);\n+\n@@ -1369,1 +1399,2 @@\n-     * will appear truncated when read again.\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link #getString(long, Charset, long)}.\n@@ -2609,0 +2640,45 @@\n+    \/**\n+     * Copies the byte sequence of the given string encoded using the provided charset\n+     * to the destination segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string. The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link #getString(long, Charset, long)}.\n+     *\n+     * @param src      the Java string to be written into the destination segment\n+     * @param dstEncoding the charset used to {@linkplain Charset#newEncoder() encode}\n+     *                 the string bytes.\n+     * @param srcIndex the starting character index of the source string\n+     * @param dst      the destination segment\n+     * @param dstOffset the starting offset, in bytes, of the destination segment\n+     * @param numChars the number of characters to be copied\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code dst} is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code dst.isAccessibleBy(T) == false}\n+     * @throws IndexOutOfBoundsException if either {@code srcIndex}, {@code numChars}, or {@code dstOffset}\n+     *         are {@code < 0}\n+     * @throws IndexOutOfBoundsException if {@code srcIndex > src.length() - numChars}\n+     * @throws IllegalArgumentException if {@code dst} is {@linkplain #isReadOnly() read-only}\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - B} where {@code B} is the size,\n+     *         in bytes, of the substring of {@code src} encoded using the given charset\n+     * @return the number of copied bytes.\n+     * @since 27\n+     *\/\n+    @ForceInline\n+    static long copy(String src, Charset dstEncoding, int srcIndex, MemorySegment dst, long dstOffset, int numChars) {\n+        Objects.requireNonNull(src);\n+        Objects.requireNonNull(dstEncoding);\n+        Objects.requireNonNull(dst);\n+        Objects.checkFromIndexSize(srcIndex, numChars, src.length());\n+\n+        return AbstractMemorySegmentImpl.copy(src, dstEncoding, srcIndex, dst, dstOffset, numChars);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":83,"deletions":7,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-     * will appear truncated when read again.\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link MemorySegment#getString(long, Charset, long)}.\n@@ -140,1 +141,1 @@\n-        if (StringSupport.bytesCompatible(str, charset)) {\n+        if (StringSupport.bytesCompatible(str, charset, 0, str.length())) {\n@@ -143,1 +144,1 @@\n-            StringSupport.copyToSegmentRaw(str, segment, 0);\n+            StringSupport.copyToSegmentRaw(str, segment, 0, 0, str.length());\n@@ -156,0 +157,48 @@\n+    \/**\n+     * Encodes a Java string using the provided charset and stores the resulting\n+     * byte array into a memory segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array. The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link MemorySegment#getString(long, Charset, long)}.\n+     *\n+     * @param str      the Java string to be encoded\n+     * @param charset  the charset used to {@linkplain Charset#newEncoder() encode} the\n+     *                 string bytes\n+     * @param srcIndex the starting index of the source string\n+     * @param numChars the number of characters to be copied\n+     * @return a new native segment containing the encoded string\n+     * @throws IndexOutOfBoundsException if either {@code srcIndex} or {@code numChars} are {@code < 0}\n+     * @throws IndexOutOfBoundsException if {@code srcIndex > str.length() - numChars}\n+     *\n+     * @implSpec The default implementation for this method copies the contents of the\n+     *           provided Java string into a new memory segment obtained by calling\n+     *           {@code this.allocate(B)}, where {@code B} is the size, in bytes, of\n+     *           the string encoded using the provided charset\n+     *           (e.g. {@code str.getBytes(charset).length});\n+     * @since 27\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset, int srcIndex, int numChars) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        Objects.checkFromIndexSize(srcIndex, numChars, str.length());\n+        MemorySegment segment;\n+        if (StringSupport.bytesCompatible(str, charset, srcIndex, numChars)) {\n+            segment = allocateNoInit(numChars);\n+            StringSupport.copyToSegmentRaw(str, segment, 0, srcIndex, numChars);\n+        } else {\n+            byte[] bytes = str.substring(srcIndex, srcIndex + numChars).getBytes(charset);\n+            segment = allocateNoInit(bytes.length);\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        }\n+        return segment;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -115,1 +116,1 @@\n-        private static final Set<Path> activePaths = new HashSet<>();\n+        private static final List<Path> activePaths = new ArrayList<>();\n@@ -265,0 +266,17 @@\n+        private static void checkCyclicInclude(Path path) {\n+            for (Path activePath : activePaths) {\n+                try {\n+                    if (Files.isSameFile(path, activePath)) {\n+                        throw new InternalError(\n+                                \"Cyclic include of '\" + path + \"'\");\n+                    }\n+                } catch (IOException e) {\n+                    if (sdebug != null) {\n+                        sdebug.println(\"skipped exception when checking for \" +\n+                                \"cyclic inclusion of \" + path + \":\");\n+                        e.printStackTrace();\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -267,4 +285,1 @@\n-            boolean isRegularFile = Files.isRegularFile(path);\n-            if (isRegularFile) {\n-                path = path.toRealPath();\n-            } else if (Files.isDirectory(path)) {\n+            if (Files.isDirectory(path)) {\n@@ -272,5 +287,0 @@\n-            } else {\n-                path = path.toAbsolutePath();\n-            }\n-            if (activePaths.contains(path)) {\n-                throw new InternalError(\"Cyclic include of '\" + path + \"'\");\n@@ -279,0 +289,1 @@\n+                checkCyclicInclude(path);\n@@ -281,1 +292,1 @@\n-                currentPath = isRegularFile ? path : null;\n+                currentPath = Files.isRegularFile(path) ? path : null;\n@@ -288,1 +299,1 @@\n-                    activePaths.remove(path);\n+                    activePaths.removeLast();\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1084,4 +1084,3 @@\n-     * <p> This method may only be invoked by the scope owner. Once the result or\n-     * exception outcome is obtained, this method may not be invoked again. The only\n-     * case where the method may be called again is where {@code InterruptedException}\n-     * is thrown while waiting.\n+     * <p> This method may only be invoked by the scope owner. It may only be invoked once\n+     * to get the result, exception or timeout outcome, unless the previous invocation\n+     * resulted in an {@code InterruptedException} being thrown.\n@@ -1096,1 +1095,3 @@\n-     * @throws InterruptedException if interrupted while waiting\n+     * @throws InterruptedException if the current thread is interrupted before or\n+     * while waiting. The current thread's interrupted status is cleared when this\n+     * exception is thrown.\n@@ -1098,0 +1099,1 @@\n+     * @see Thread##thread-interruption Thread Interruption\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,5 @@\n-            readHeader(in);\n+            \/\/ we don't expect the stream to be at EOF\n+            \/\/ and if it is, then we want readHeader to\n+            \/\/ raise an exception, so we pass \"true\" for\n+            \/\/ the \"failOnEOF\" param.\n+            readHeader(in, true);\n@@ -193,0 +197,5 @@\n+     * If failOnEOF is false and if the given InputStream has already\n+     * reached EOF when this method was invoked, then this method returns\n+     * -1 (indicating that there's no GZIP member header).\n+     * In all other cases of malformed header or EOF being detected\n+     * when reading the header, this method will throw an IOException.\n@@ -194,1 +203,1 @@\n-    private int readHeader(InputStream this_in) throws IOException {\n+    private int readHeader(InputStream this_in, boolean failOnEOF) throws IOException {\n@@ -197,0 +206,23 @@\n+\n+        int magic;\n+        if (!failOnEOF) {\n+            \/\/ read an unsigned short value representing the GZIP magic header.\n+            \/\/ this is the same as calling readUShort(in), except that here,\n+            \/\/ when reading the first byte, we don't raise an EOFException\n+            \/\/ if the stream has already reached EOF.\n+\n+            \/\/ read unsigned byte\n+            int b = in.read();\n+            if (b == -1) { \/\/ EOF\n+                crc.reset();\n+                return -1; \/\/ represents no header bytes available\n+            }\n+            checkUnexpectedByte(b);\n+            \/\/ read the next unsigned byte to form the unsigned\n+            \/\/ short. we throw the usual EOFException\/ZipException\n+            \/\/ from this point on if there is no more data or\n+            \/\/ the data doesn't represent a header.\n+            magic = (readUByte(in) << 8) | b;\n+        } else {\n+            magic = readUShort(in);\n+        }\n@@ -198,1 +230,1 @@\n-        if (readUShort(in) != GZIP_MAGIC) {\n+        if (magic != GZIP_MAGIC) {\n@@ -264,1 +296,5 @@\n-            m += readHeader(in);    \/\/ next.header\n+            int numNextHeaderBytes = readHeader(in, false); \/\/ next.header (if available)\n+            if (numNextHeaderBytes == -1) {\n+                return true; \/\/ end of stream reached\n+            }\n+            m += numNextHeaderBytes;\n@@ -298,0 +334,5 @@\n+        checkUnexpectedByte(b);\n+        return b;\n+    }\n+\n+    private void checkUnexpectedByte(final int b) throws IOException {\n@@ -299,1 +340,1 @@\n-            \/\/ Report on this.in, not argument in; see read{Header, Trailer}.\n+            \/\/ report the InputStream type which returned this unexpected byte\n@@ -301,1 +342,1 @@\n-                + \".read() returned value out of range -1..255: \" + b);\n+                    + \".read() returned value out of range -1..255: \" + b);\n@@ -303,1 +344,0 @@\n-        return b;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -452,3 +452,5 @@\n-     * Encodes as many ASCII codepoints as possible from the source\n-     * character array into the destination byte array, assuming that\n-     * the encoding is ASCII compatible.\n+     * Encodes as many ASCII codepoints as possible from the source array into\n+     * the destination byte array, assuming that the encoding is ASCII\n+     * compatible.\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -456,7 +458,1 @@\n-     * @param sa the source character array\n-     * @param sp the index of the source array to start reading from\n-     * @param da the target byte array\n-     * @param dp the index of the target array to start writing to\n-     * @param len the total number of characters to be encoded\n-     * @return the total number of characters successfully encoded\n-     * @throws NullPointerException if any of the provided arrays is null\n+     * @return the number of bytes successfully encoded, or 0 if none\n@@ -464,1 +460,1 @@\n-    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n+    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n@@ -648,1 +644,1 @@\n-    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength);\n@@ -653,1 +649,1 @@\n-    boolean bytesCompatible(String string, Charset charset);\n+    boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -835,4 +835,2 @@\n-        public UnboundIncrementInstruction(int slot, int constant) {\n-            super(BytecodeHelpers.validateAndIsWideIinc(slot, constant)\n-                  ? Opcode.IINC_W\n-                  : Opcode.IINC);\n+        public UnboundIncrementInstruction(Opcode op, int slot, int constant) {\n+            super(op);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -453,0 +453,7 @@\n+    public static void validateIncrement(Opcode opcode, int slot, int constant) {\n+        if (validateAndIsWideIinc(slot, constant) && opcode != Opcode.IINC_W) {\n+            throw new IllegalArgumentException(\n+                    \"IINC: operands require wide encoding for %s\".formatted(opcode));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -554,0 +554,7 @@\n+    @Override\n+    public String getString(long offset, Charset charset, long byteLength) {\n+        Utils.checkNonNegativeArgument(byteLength, \"byteLength\");\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset, byteLength);\n+    }\n+\n@@ -705,0 +712,10 @@\n+    @ForceInline\n+    public static long copy(String src, Charset dstEncoding, int srcIndex, MemorySegment dst, long dstOffset, int numChars) {\n+        Objects.requireNonNull(src);\n+        Objects.requireNonNull(dstEncoding);\n+        Objects.requireNonNull(dst);\n+\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dst;\n+        return StringSupport.copyBytes(src, destImpl, dstEncoding, dstOffset, srcIndex, numChars);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -36,0 +37,1 @@\n+import java.lang.reflect.Array;\n@@ -38,0 +40,1 @@\n+import java.util.Objects;\n@@ -61,0 +64,21 @@\n+    @ForceInline\n+    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset, long length) {\n+        return readBytes(segment, offset, charset, length);\n+    }\n+\n+    @ForceInline\n+    public static String readBytes(AbstractMemorySegmentImpl segment, long offset, Charset charset, long length) {\n+        if (length > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Required length exceeds implementation limit\");\n+        }\n+        final int lengthBytes = (int) length;\n+        final byte[] bytes = new byte[lengthBytes];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, lengthBytes);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n+    }\n+\n@@ -73,8 +97,1 @@\n-        final byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-            \/\/ use replacement characters for malformed input\n-            return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -92,8 +109,1 @@\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-          \/\/ use replacement characters for malformed input\n-          return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -111,8 +121,1 @@\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-            \/\/ use replacement characters for malformed input\n-            return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -348,2 +351,2 @@\n-    public static boolean bytesCompatible(String string, Charset charset) {\n-        return JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n+    public static boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars) {\n+        return JAVA_LANG_ACCESS.bytesCompatible(string, charset, srcIndex, numChars);\n@@ -353,3 +356,7 @@\n-        if (bytesCompatible(string, charset)) {\n-            copyToSegmentRaw(string, segment, offset);\n-            return string.length();\n+        return copyBytes(string, segment, charset, offset, 0, string.length());\n+    }\n+\n+    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset, int srcIndex, int numChars) {\n+        if (bytesCompatible(string, charset, srcIndex, numChars)) {\n+            copyToSegmentRaw(string, segment, offset, srcIndex, numChars);\n+            return numChars;\n@@ -357,1 +364,1 @@\n-            byte[] bytes = string.getBytes(charset);\n+            byte[] bytes = string.substring(srcIndex, srcIndex + numChars).getBytes(charset);\n@@ -363,2 +370,2 @@\n-    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n+    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength) {\n+        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset, srcIndex, srcLength);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-     *                                   the range [0, array.length]\n+     *                                   the range [0, array.length - 1]\n@@ -331,1 +331,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 4]\n@@ -353,1 +353,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 4]\n@@ -371,1 +371,1 @@\n-     *                                   the range [0, array.length - 4]\n+     *                                   the range [0, array.length - 8]\n@@ -390,1 +390,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 8]\n@@ -412,1 +412,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 8]\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArray.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-     *                                   the range [0, array.length]\n+     *                                   the range [0, array.length - 1]\n@@ -331,1 +331,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 4]\n@@ -353,1 +353,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 4]\n@@ -371,1 +371,1 @@\n-     *                                   the range [0, array.length - 4]\n+     *                                   the range [0, array.length - 8]\n@@ -390,1 +390,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 8]\n@@ -412,1 +412,1 @@\n-     *                                   the range [0, array.length - 2]\n+     *                                   the range [0, array.length - 8]\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArrayLittleEndian.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -144,13 +145,1 @@\n-        \/**\n-         * Encodes as many ISO-8859-1 codepoints as possible from the source\n-         * character array into the destination byte array, assuming that\n-         * the encoding is ISO-8859-1 compatible.\n-         *\n-         * @param sa the source character array\n-         * @param sp the index of the source array to start reading from\n-         * @param da the target byte array\n-         * @param dp the index of the target array to start writing to\n-         * @param len the maximum number of characters to be encoded\n-         * @return the total number of characters successfully encoded\n-         * @throws NullPointerException if any of the provided arrays is null\n-         *\/\n+        \/\/ Method possible replaced with a compiler intrinsic.\n@@ -159,5 +148,1 @@\n-            \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n-            \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n-            if ((sp | dp | len) < 0 ||\n-                    sp >= sa.length ||      \/\/ Implicit null check on `sa`\n-                    dp >= da.length) {      \/\/ Implicit null check on `da`\n+            if (len <= 0) {\n@@ -166,2 +151,2 @@\n-            int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n-            return encodeISOArray0(sa, sp, da, dp, minLen);\n+            encodeISOArrayCheck(sa, sp, da, dp, len);\n+            return implEncodeISOArray(sa, sp, da, dp, len);\n@@ -171,1 +156,3 @@\n-        private static int encodeISOArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n+        private static int implEncodeISOArray(char[] sa, int sp,\n+                                              byte[] da, int dp, int len)\n+        {\n@@ -182,0 +169,11 @@\n+        private static void encodeISOArrayCheck(char[] sa, int sp,\n+                                                byte[] da, int dp, int len) {\n+            Objects.requireNonNull(sa);\n+            Objects.requireNonNull(da);\n+            Preconditions.checkIndex(sp, sa.length, Preconditions.AIOOBE_FORMATTER);\n+            Preconditions.checkIndex(dp, da.length, Preconditions.AIOOBE_FORMATTER);\n+\n+            Preconditions.checkIndex(sp + len - 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n+            Preconditions.checkIndex(dp + len - 1, da.length, Preconditions.AIOOBE_FORMATTER);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                int n = JLA.encodeASCII(sa, sp, da, dp, len);\n+                int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-        this.basePoint = toAffinePoint(basePoint, ecOps.getField());\n+        this.basePoint = AffinePoint.fromECPoint(basePoint, ecOps.getField());\n@@ -82,8 +82,0 @@\n-    public static AffinePoint toAffinePoint(ECPoint point,\n-        IntegerFieldModuloP field) {\n-\n-        ImmutableIntegerModuloP affineX = field.getElement(point.getAffineX());\n-        ImmutableIntegerModuloP affineY = field.getElement(point.getAffineY());\n-        return new AffinePoint(affineX, affineY);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECDSAOperations.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,16 @@\n+    },\n+\n+    \/**\n+     * Distrust TLS Server certificates anchored by the Chunghwa ePKI root CA\n+     * and issued after March 17, 2026. If enabled, this policy is currently\n+     * enforced by the PKIX and SunX509 TrustManager implementations\n+     * of the SunJSSE provider implementation.\n+     *\/\n+    CHUNGHWA_TLS {\n+        void checkDistrust(String variant, X509Certificate[] chain)\n+                           throws ValidatorException {\n+            if (!variant.equals(Validator.VAR_TLS_SERVER)) {\n+                return;\n+            }\n+            ChunghwaTLSPolicy.checkDistrust(chain);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/CADistrustPolicy.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.validator;\n+\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import sun.security.util.Debug;\n+import sun.security.x509.X509CertImpl;\n+\n+\/**\n+ * This class checks if Chunghwa issued TLS Server certificates should be\n+ * restricted.\n+ *\/\n+final class ChunghwaTLSPolicy {\n+\n+    private static final Debug debug = Debug.getInstance(\"certpath\");\n+\n+    \/\/ SHA-256 certificate fingerprint of distrusted root for TLS\n+    \/\/ cacerts alias: chunghwaepkirootca\n+    \/\/ DN: OU=ePKI Root Certification Authority,\n+    \/\/     O=\"Chunghwa Telecom Co., Ltd.\", C=TW\n+    private static final String FINGERPRINT =\n+            \"C0A6F4DC63A24BFDCF54EF2A6A082A0A72DE35803E2FF5FF527AE5D87206DFD5\";\n+\n+    \/\/ Any TLS Server certificate that is anchored by the Chunghwa\n+    \/\/ root above and is issued after this date will be distrusted.\n+    private static final LocalDate MARCH_17_2026 =\n+        LocalDate.of(2026, Month.MARCH, 17);\n+\n+    \/**\n+     * This method assumes the eeCert is a TLS Server Cert and chains back to\n+     * the anchor.\n+     *\n+     * @param chain the end-entity's certificate chain. The end entity cert\n+     *              is at index 0, the trust anchor at index n-1.\n+     * @throws ValidatorException if the certificate is distrusted\n+     *\/\n+    static void checkDistrust(X509Certificate[] chain)\n+                              throws ValidatorException {\n+        X509Certificate anchor = chain[chain.length-1];\n+        String fp = fingerprint(anchor);\n+        if (fp == null) {\n+            throw new ValidatorException(\"Cannot generate fingerprint for \"\n+                + \"trust anchor of TLS server certificate\");\n+        }\n+        if (FINGERPRINT.equalsIgnoreCase(fp)) {\n+            Date notBefore = chain[0].getNotBefore();\n+            LocalDate ldNotBefore = LocalDate.ofInstant(notBefore.toInstant(),\n+                                                        ZoneOffset.UTC);\n+            \/\/ reject if certificate is issued after March 17, 2026\n+            checkNotBefore(ldNotBefore, MARCH_17_2026, anchor);\n+        }\n+    }\n+\n+    private static String fingerprint(X509Certificate cert) {\n+        return X509CertImpl.getFingerprint(\"SHA-256\", cert, debug);\n+    }\n+\n+    \/\/ Check whether the certificate's notBeforeDate is after the\n+    \/\/ distrust date for the anchor (root CA). Throw ValidatorException\n+    \/\/ if it is after the distrust date.\n+    private static void checkNotBefore(LocalDate notBeforeDate,\n+            LocalDate distrustDate, X509Certificate anchor)\n+            throws ValidatorException {\n+        if (notBeforeDate.isAfter(distrustDate)) {\n+            throw new ValidatorException\n+                (\"TLS Server certificate issued after \" + distrustDate +\n+                 \" and anchored by a distrusted legacy Chunghwa root CA: \"\n+                 + anchor.getSubjectX500Principal(),\n+                 ValidatorException.T_UNTRUSTED_CERT, anchor);\n+        }\n+    }\n+\n+    private ChunghwaTLSPolicy() {}\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/ChunghwaTLSPolicy.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -1440,0 +1440,3 @@\n+#   CHUNGHWA_TLS : Distrust TLS Server certificates anchored by\n+#   a Chunghwa root CA and issued after March 17, 2026.\n+#\n@@ -1451,1 +1454,2 @@\n-jdk.security.caDistrustPolicies=SYMANTEC_TLS,ENTRUST_TLS,CAMERFIRMA_TLS\n+jdk.security.caDistrustPolicies=SYMANTEC_TLS,ENTRUST_TLS,CAMERFIRMA_TLS,\\\n+    CHUNGHWA_TLS\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-`-jar` *jarfile*\n+[`-jar`]{#-jar} *jarfile*\n@@ -73,1 +73,1 @@\n-`-m` or `--module` *module*\\[`\/`*mainclass*\\]\n+[`-m`]{#-m} or `--module` *module*\\[`\/`*mainclass*\\]\n@@ -373,1 +373,1 @@\n-`-agentlib:`*libname*\\[`=`*options*\\]\n+[`-agentlib:`]{#-agentlib}*libname*\\[`=`*options*\\]\n@@ -396,1 +396,1 @@\n-`-agentpath:`*pathname*\\[`=`*options*\\]\n+[`-agentpath:`]{#-agentpath}*pathname*\\[`=`*options*\\]\n@@ -401,1 +401,1 @@\n-`--class-path` *classpath*, `-classpath` *classpath*, or `-cp` *classpath*\n+[`--class-path`]{#--class-path} *classpath*, `-classpath` *classpath*, or `-cp` *classpath*\n@@ -427,1 +427,1 @@\n-`--disable-@files`\n+[`--disable-@files`]{#--disable-@files}\n@@ -432,1 +432,1 @@\n-`--enable-preview`\n+[`--enable-preview`]{#--enable-preview}\n@@ -435,1 +435,1 @@\n-`--enable-native-access` *module*\\[`,`*module*...\\]\n+[`--enable-native-access`]{#--enable-native-access} *module*\\[`,`*module*...\\]\n@@ -468,1 +468,1 @@\n-`--enable-final-field-mutation` *module*\\[,*module*...\\]\n+[`--enable-final-field-mutation`]{#--enable-final-field-mutation} *module*\\[,*module*...\\]\n@@ -501,1 +501,1 @@\n-`--finalization=`*value*\n+[`--finalization=`]{#--finalization}*value*\n@@ -507,1 +507,1 @@\n-`--module-path` *modulepath*... or `-p` *modulepath*\n+[`--module-path`]{#--module-path} *modulepath*... or `-p` *modulepath*\n@@ -516,1 +516,1 @@\n-`--upgrade-module-path` *modulepath*...\n+[`--upgrade-module-path`]{#--upgrade-module-path} *modulepath*...\n@@ -526,1 +526,1 @@\n-`--add-modules` *module*\\[`,`*module*...\\]\n+[`--add-modules`]{#--add-modules} *module*\\[`,`*module*...\\]\n@@ -530,1 +530,1 @@\n-`--list-modules`\n+[`--list-modules`]{#--list-modules}\n@@ -533,1 +533,1 @@\n-`-d` *module\\_name* or `--describe-module` *module\\_name*\n+[`-d`]{#-d} *module\\_name* or `--describe-module` *module\\_name*\n@@ -536,1 +536,1 @@\n-`--dry-run`\n+[`--dry-run`]{#--dry-run}\n@@ -541,1 +541,1 @@\n-`--validate-modules`\n+[`--validate-modules`]{#--validate-modules}\n@@ -545,1 +545,1 @@\n-`-D`*property*`=`*value*\n+[`-D`]{#-D}*property*`=`*value*\n@@ -552,1 +552,1 @@\n-`-disableassertions`\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\] or `-da`\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\]\n+[`-disableassertions`]{#-disableassertions}\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\] or `-da`\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\]\n@@ -577,1 +577,1 @@\n-`-disablesystemassertions` or `-dsa`\n+[`-disablesystemassertions`]{#-disablesystemassertions} or `-dsa`\n@@ -580,1 +580,1 @@\n-`-enableassertions`\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\] or `-ea`\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\]\n+[`-enableassertions`]{#-enableassertions}\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\] or `-ea`\\[`:`\\[*packagename*\\]...\\|`:`*classname*\\]\n@@ -607,1 +607,1 @@\n-`-enablesystemassertions` or `-esa`\n+[`-enablesystemassertions`]{#-enablesystemassertions} or `-esa`\n@@ -610,1 +610,1 @@\n-`-help`, `-h`, or `-?`\n+[`-help`]{#-help}, `-h`, or `-?`\n@@ -613,1 +613,1 @@\n-`--help`\n+[`--help`]{#--help}\n@@ -616,1 +616,1 @@\n-`-javaagent:`*jarpath*\\[`=`*options*\\]\n+[`-javaagent:`]{#-javaagent_}*jarpath*\\[`=`*options*\\]\n@@ -619,1 +619,1 @@\n-`--show-version`\n+[`--show-version`]{#--show-version}\n@@ -622,1 +622,1 @@\n-`-showversion`\n+[`-showversion`]{#-showversion}\n@@ -625,1 +625,1 @@\n-`--show-module-resolution`\n+[`--show-module-resolution`]{#--show-module-resolution}\n@@ -628,1 +628,1 @@\n-`-splash:`*imagepath*\n+[`-splash:`]{#-splash_}*imagepath*\n@@ -642,1 +642,1 @@\n-`-verbose:class`\n+[`-verbose:class`]{#-verbose_class}\n@@ -645,1 +645,1 @@\n-`-verbose:gc`\n+[`-verbose:gc`]{#-verbose_gc}\n@@ -648,1 +648,1 @@\n-`-verbose:jni`\n+[`-verbose:jni`]{#-verbose_jni}\n@@ -652,1 +652,1 @@\n-`-verbose:module`\n+[`-verbose:module`]{#-verbose_module}\n@@ -655,1 +655,1 @@\n-`--version`\n+[`--version`]{#--version}\n@@ -658,1 +658,1 @@\n-`-version`\n+[`-version`]{#-version}\n@@ -661,1 +661,1 @@\n-`-X`\n+[`-X`]{#-X}\n@@ -664,1 +664,1 @@\n-`--help-extra`\n+[`--help-extra`]{#--help-extra}\n@@ -691,1 +691,1 @@\n-`-Xbatch`\n+[`-Xbatch`]{#-Xbatch}\n@@ -699,1 +699,1 @@\n-`-Xbootclasspath\/a:`*directories*\\|*zip*\\|*JAR-files*\n+[`-Xbootclasspath\/a:`]{#-Xbootclasspath}*directories*\\|*zip*\\|*JAR-files*\n@@ -706,1 +706,1 @@\n-`-Xcheck:jni`\n+[`-Xcheck:jni`]{#-Xcheck_jni}\n@@ -742,1 +742,1 @@\n-`-Xcomp`\n+[`-Xcomp`]{#-Xcomp}\n@@ -745,1 +745,1 @@\n-`-Xdebug`\n+[`-Xdebug`]{#-Xdebug}\n@@ -748,1 +748,1 @@\n-`-Xdiag`\n+[`-Xdiag`]{#-Xdiag}\n@@ -751,1 +751,1 @@\n-`-Xint`\n+[`-Xint`]{#-Xint}\n@@ -757,1 +757,1 @@\n-`-Xinternalversion`\n+[`-Xinternalversion`]{#-Xinternalversion}\n@@ -766,1 +766,1 @@\n-`-Xmixed`\n+[`-Xmixed`]{#-Xmixed}\n@@ -770,1 +770,1 @@\n-`-Xmn` *size*\n+[`-Xmn`]{#-Xmn} *size*\n@@ -796,1 +796,1 @@\n-`-Xms` *size*\n+[`-Xms`]{#-Xms} *size*\n@@ -818,1 +818,1 @@\n-`-Xmx` *size*\n+[`-Xmx`]{#-Xmx} *size*\n@@ -835,1 +835,1 @@\n-`-Xnoclassgc`\n+[`-Xnoclassgc`]{#-Xnoclassgc}\n@@ -843,1 +843,1 @@\n-`-Xrs`\n+[`-Xrs`]{#-Xrs}\n@@ -893,1 +893,1 @@\n-`-Xshare:`*mode*\n+[`-Xshare:`]{#-Xshare_}*mode*\n@@ -913,1 +913,1 @@\n-`-XshowSettings`\n+[`-XshowSettings`]{#-XshowSettings}\n@@ -916,1 +916,1 @@\n-`-XshowSettings:`*category*\n+[`-XshowSettings:`]{#-XshowSettings_}*category*\n@@ -945,1 +945,1 @@\n-`-Xss` *size*\n+[`-Xss`]{#-Xss} *size*\n@@ -973,1 +973,1 @@\n-`--add-reads` *module*`=`*target-module*(`,`*target-module*)\\*\n+[`--add-reads`]{#--add-reads} *module*`=`*target-module*(`,`*target-module*)\\*\n@@ -978,1 +978,1 @@\n-`--add-exports` *module*`\/`*package*`=`*target-module*(`,`*target-module*)\\*\n+[`--add-exports`]{#--add-exports} *module*`\/`*package*`=`*target-module*(`,`*target-module*)\\*\n@@ -983,1 +983,1 @@\n-`--add-opens` *module*`\/`*package*`=`*target-module*(`,`*target-module*)\\*\n+[`--add-opens`]{#--add-opens} *module*`\/`*package*`=`*target-module*(`,`*target-module*)\\*\n@@ -987,1 +987,1 @@\n-`--limit-modules` *module*\\[`,`*module*...\\]\n+[`--limit-modules`]{#--limit-modules} *module*\\[`,`*module*...\\]\n@@ -990,1 +990,1 @@\n-`--patch-module` *module*`=`*file*(`;`*file*)\\*\n+[`--patch-module`]{#--patch-module} *module*`=`*file*(`;`*file*)\\*\n@@ -994,1 +994,1 @@\n-`--source` *version*\n+[`--source`]{#--source} *version*\n@@ -998,1 +998,1 @@\n-`--sun-misc-unsafe-memory-access=` *value*\n+[`--sun-misc-unsafe-memory-access=`]{#--sun-misc-unsafe-memory-access} *value*\n@@ -1024,1 +1024,1 @@\n-`-XstartOnFirstThread`\n+[`-XstartOnFirstThread`]{#-XstartOnFirstThread}\n@@ -1027,1 +1027,1 @@\n-`-Xdock:name=`*application\\_name*\n+[`-Xdock:name=`]{#-Xdock_name}*application\\_name*\n@@ -1030,1 +1030,1 @@\n-`-Xdock:icon=`*path\\_to\\_icon\\_file*\n+[`-Xdock:icon=`]{#-Xdock_icon}*path\\_to\\_icon\\_file*\n@@ -1037,1 +1037,1 @@\n-`-XX:+UnlockDiagnosticVMOptions`\n+[`-XX:+UnlockDiagnosticVMOptions`]{#-XX__UnlockDiagnosticVMOptions}\n@@ -1049,1 +1049,1 @@\n-`-XX:+UnlockExperimentalVMOptions`\n+[`-XX:+UnlockExperimentalVMOptions`]{#-XX__UnlockExperimentalVMOptions}\n@@ -1057,1 +1057,1 @@\n-`-XX:ActiveProcessorCount=`*x*\n+[`-XX:ActiveProcessorCount=`]{#-XX_ActiveProcessorCount}*x*\n@@ -1069,1 +1069,1 @@\n-`-XX:AllocateHeapAt=`*path*\n+[`-XX:AllocateHeapAt=`]{#-XX_AllocateHeapAt}*path*\n@@ -1087,1 +1087,1 @@\n-`-XX:-CompactStrings`\n+[`-XX:-CompactStrings`]{#-XX__CompactStrings}\n@@ -1110,1 +1110,1 @@\n-`-XX:ErrorFile=`*filename*\n+[`-XX:ErrorFile=`]{#-XX_ErrorFile}*filename*\n@@ -1142,1 +1142,1 @@\n-`-XX:+ExtensiveErrorReports`\n+[`-XX:+ExtensiveErrorReports`]{#-XX__ExtensiveErrorReports}\n@@ -1150,1 +1150,1 @@\n-`-XX:FlightRecorderOptions=`*parameter*`=`*value* (or) `-XX:FlightRecorderOptions:`*parameter*`=`*value*\n+[`-XX:FlightRecorderOptions=`]{#-XX_FlightRecorderOptions}*parameter*`=`*value* (or) `-XX:FlightRecorderOptions:`*parameter*`=`*value*\n@@ -1210,1 +1210,1 @@\n-`-XX:LargePageSizeInBytes=`*size*\n+[`-XX:LargePageSizeInBytes=`]{#-XX_LargePageSizeInBytes}*size*\n@@ -1224,1 +1224,1 @@\n-`-XX:MaxDirectMemorySize=`*size*\n+[`-XX:MaxDirectMemorySize=`]{#-XX_MaxDirectMemorySize}*size*\n@@ -1240,1 +1240,1 @@\n-`-XX:-MaxFDLimit`\n+[`-XX:-MaxFDLimit`]{#-XX__MaxFDLimit}\n@@ -1247,1 +1247,1 @@\n-`-XX:NativeMemoryTracking=`*mode*\n+[`-XX:NativeMemoryTracking=`]{#-XX_NativeMemoryTracking}*mode*\n@@ -1264,1 +1264,1 @@\n-`-XX:TrimNativeHeapInterval=`*millis*\n+[`-XX:TrimNativeHeapInterval=`]{#-XX_TrimNativeHeapInterval}*millis*\n@@ -1272,1 +1272,1 @@\n-`-XX:ObjectAlignmentInBytes=`*alignment*\n+[`-XX:ObjectAlignmentInBytes=`]{#-XX_ObjectAlignmentInBytes}*alignment*\n@@ -1286,1 +1286,1 @@\n-`-XX:OnError=`*string*\n+[`-XX:OnError=`]{#-XX_OnError}*string*\n@@ -1307,1 +1307,1 @@\n-`-XX:OnOutOfMemoryError=`*string*\n+[`-XX:OnOutOfMemoryError=`]{#-XX_OnOutOfMemoryError}*string*\n@@ -1319,1 +1319,1 @@\n-`-XX:+PrintCommandLineFlags`\n+[`-XX:+PrintCommandLineFlags`]{#-XX__PrintCommandLineFlags}\n@@ -1325,1 +1325,1 @@\n-`-XX:+PreserveFramePointer`\n+[`-XX:+PreserveFramePointer`]{#-XX__PreserveFramePointer}\n@@ -1332,1 +1332,1 @@\n-`-XX:+PrintNMTStatistics`\n+[`-XX:+PrintNMTStatistics`]{#-XX__PrintNMTStatistics}\n@@ -1338,1 +1338,1 @@\n-`-XX:SharedArchiveFile=`*path*\n+[`-XX:SharedArchiveFile=`]{#-XX_SharedArchiveFile}*path*\n@@ -1343,1 +1343,1 @@\n-`-XX:+VerifySharedSpaces`\n+[`-XX:+VerifySharedSpaces`]{#-XX__VerifySharedSpaces}\n@@ -1351,1 +1351,1 @@\n-`-XX:SharedArchiveConfigFile=`*shared\\_config\\_file*\n+[`-XX:SharedArchiveConfigFile=`]{#-XX_SharedArchiveConfigFile}*shared\\_config\\_file*\n@@ -1354,1 +1354,1 @@\n-`-XX:SharedClassListFile=`*file\\_name*\n+[`-XX:SharedClassListFile=`]{#-XX_SharedClassListFile}*file\\_name*\n@@ -1372,1 +1372,1 @@\n-`-XX:+ShowCodeDetailsInExceptionMessages`\n+[`-XX:+ShowCodeDetailsInExceptionMessages`]{#-XX__ShowCodeDetailsInExceptionMessages}\n@@ -1381,1 +1381,1 @@\n-`-XX:+ShowMessageBoxOnError`\n+[`-XX:+ShowMessageBoxOnError`]{#-XX__ShowMessageBoxOnError}\n@@ -1387,1 +1387,1 @@\n-`-XX:StartFlightRecording:`*parameter*`=`*value*\n+[`-XX:StartFlightRecording:`]{#-XX_StartFlightRecording_}*parameter*`=`*value*\n@@ -1506,1 +1506,1 @@\n-`-XX:ThreadStackSize=`*size*\n+[`-XX:ThreadStackSize=`]{#-XX_ThreadStackSize}*size*\n@@ -1532,1 +1532,1 @@\n-`-XX:+UseCompactObjectHeaders`\n+[`-XX:+UseCompactObjectHeaders`]{#-XX__UseCompactObjectHeaders}\n@@ -1541,1 +1541,1 @@\n-`-XX:-UseCompressedOops`\n+[`-XX:-UseCompressedOops`]{#-XX__UseCompressedOops}\n@@ -1556,1 +1556,1 @@\n-`-XX:-UseContainerSupport`\n+[`-XX:-UseContainerSupport`]{#-XX__UseContainerSupport}\n@@ -1571,1 +1571,1 @@\n-`-XX:+UseLargePages`\n+[`-XX:+UseLargePages`]{#-XX__UseLargePages}\n@@ -1577,1 +1577,1 @@\n-`-XX:+UseTransparentHugePages`\n+[`-XX:+UseTransparentHugePages`]{#-XX__UseTransparentHugePages}\n@@ -1583,1 +1583,1 @@\n-`-XX:+AllowUserSignalHandlers`\n+[`-XX:+AllowUserSignalHandlers`]{#-XX__AllowUserSignalHandlers}\n@@ -1588,1 +1588,1 @@\n-`-XX:VMOptionsFile=`*filename*\n+[`-XX:VMOptionsFile=`]{#-XX_VMOptionsFile}*filename*\n@@ -1592,1 +1592,1 @@\n-`-XX:UseBranchProtection=`*mode*\n+[`-XX:UseBranchProtection=`]{#-XX_UseBranchProtection}*mode*\n@@ -1616,1 +1616,1 @@\n-`-XX:AllocateInstancePrefetchLines=`*lines*\n+[`-XX:AllocateInstancePrefetchLines=`]{#-XX_AllocateInstancePrefetchLines}*lines*\n@@ -1623,1 +1623,1 @@\n-`-XX:AllocatePrefetchDistance=`*size*\n+[`-XX:AllocatePrefetchDistance=`]{#-XX_AllocatePrefetchDistance}*size*\n@@ -1639,1 +1639,1 @@\n-`-XX:AllocatePrefetchInstr=`*instruction*\n+[`-XX:AllocatePrefetchInstr=`]{#-XX_AllocatePrefetchInstr}*instruction*\n@@ -1647,1 +1647,1 @@\n-`-XX:AllocatePrefetchLines=`*lines*\n+[`-XX:AllocatePrefetchLines=`]{#-XX_AllocatePrefetchLines}*lines*\n@@ -1659,1 +1659,1 @@\n-`-XX:AllocatePrefetchStepSize=`*size*\n+[`-XX:AllocatePrefetchStepSize=`]{#-XX_AllocatePrefetchStepSize}*size*\n@@ -1668,1 +1668,1 @@\n-`-XX:AllocatePrefetchStyle=`*style*\n+[`-XX:AllocatePrefetchStyle=`]{#-XX_AllocatePrefetchStyle}*style*\n@@ -1687,1 +1687,1 @@\n-`-XX:+BackgroundCompilation`\n+[`-XX:+BackgroundCompilation`]{#-XX__BackgroundCompilation}\n@@ -1692,1 +1692,1 @@\n-`-XX:CICompilerCount=`*threads*\n+[`-XX:CICompilerCount=`]{#-XX_CICompilerCount}*threads*\n@@ -1700,1 +1700,1 @@\n-`-XX:+UseDynamicNumberOfCompilerThreads`\n+[`-XX:+UseDynamicNumberOfCompilerThreads`]{#-XX__UseDynamicNumberOfCompilerThreads}\n@@ -1704,1 +1704,1 @@\n-`-XX:CompileCommand=`*command*`,`*method*\\[`,`*option*\\]\n+[`-XX:CompileCommand=`]{#-XX_CompileCommand}*command*`,`*method*\\[`,`*option*\\]\n@@ -1803,1 +1803,1 @@\n-`-XX:CompileCommandFile=`*filename*\n+[`-XX:CompileCommandFile=`]{#-XX_CompileCommandFile}*filename*\n@@ -1817,1 +1817,1 @@\n-`-XX:CompilerDirectivesFile=`*file*\n+[`-XX:CompilerDirectivesFile=`]{#-XX_CompilerDirectivesFile}*file*\n@@ -1825,1 +1825,1 @@\n-`-XX:+CompilerDirectivesPrint`\n+[`-XX:+CompilerDirectivesPrint`]{#-XX__CompilerDirectivesPrint}\n@@ -1832,1 +1832,1 @@\n-`-XX:CompileOnly=`*methods*\n+[`-XX:CompileOnly=`]{#-XX_CompileOnly}*methods*\n@@ -1844,1 +1844,1 @@\n-`-XX:CompileThresholdScaling=`*scale*\n+[`-XX:CompileThresholdScaling=`]{#-XX_CompileThresholdScaling}*scale*\n@@ -1854,1 +1854,1 @@\n-`-XX:+DoEscapeAnalysis`\n+[`-XX:+DoEscapeAnalysis`]{#-XX__DoEscapeAnalysis}\n@@ -1858,1 +1858,1 @@\n-`-XX:InitialCodeCacheSize=`*size*\n+[`-XX:InitialCodeCacheSize=`]{#-XX_InitialCodeCacheSize}*size*\n@@ -1868,1 +1868,1 @@\n-`-XX:+Inline`\n+[`-XX:+Inline`]{#-XX__Inline}\n@@ -1872,1 +1872,1 @@\n-`-XX:InlineSmallCode=`*size*\n+[`-XX:InlineSmallCode=`]{#-XX_InlineSmallCode}*size*\n@@ -1882,1 +1882,1 @@\n-`-XX:+LogCompilation`\n+[`-XX:+LogCompilation`]{#-XX__LogCompilation}\n@@ -1896,1 +1896,1 @@\n-`-XX:FreqInlineSize=`*size*\n+[`-XX:FreqInlineSize=`]{#-XX_FreqInlineSize}*size*\n@@ -1906,1 +1906,1 @@\n-`-XX:MaxInlineSize=`*size*\n+[`-XX:MaxInlineSize=`]{#-XX_MaxInlineSize}*size*\n@@ -1915,1 +1915,1 @@\n-`-XX:C1MaxInlineSize=`*size*\n+[`-XX:C1MaxInlineSize=`]{#-XX_C1MaxInlineSize}*size*\n@@ -1924,1 +1924,1 @@\n-`-XX:MaxTrivialSize=`*size*\n+[`-XX:MaxTrivialSize=`]{#-XX_MaxTrivialSize}*size*\n@@ -1933,1 +1933,1 @@\n-`-XX:C1MaxTrivialSize=`*size*\n+[`-XX:C1MaxTrivialSize=`]{#-XX_C1MaxTrivialSize}*size*\n@@ -1942,1 +1942,1 @@\n-`-XX:MaxNodeLimit=`*nodes*\n+[`-XX:MaxNodeLimit=`]{#-XX_MaxNodeLimit}*nodes*\n@@ -1949,1 +1949,1 @@\n-`-XX:NonNMethodCodeHeapSize=`*size*\n+[`-XX:NonNMethodCodeHeapSize=`]{#-XX_NonNMethodCodeHeapSize}*size*\n@@ -1957,1 +1957,1 @@\n-`-XX:NonProfiledCodeHeapSize=`*size*\n+[`-XX:NonProfiledCodeHeapSize=`]{#-XX_NonProfiledCodeHeapSize}*size*\n@@ -1961,1 +1961,1 @@\n-`-XX:+OptimizeStringConcat`\n+[`-XX:+OptimizeStringConcat`]{#-XX__OptimizeStringConcat}\n@@ -1966,1 +1966,1 @@\n-`-XX:+PrintAssembly`\n+[`-XX:+PrintAssembly`]{#-XX__PrintAssembly}\n@@ -1976,1 +1976,1 @@\n-`-XX:ProfiledCodeHeapSize=`*size*\n+[`-XX:ProfiledCodeHeapSize=`]{#-XX_ProfiledCodeHeapSize}*size*\n@@ -1980,1 +1980,1 @@\n-`-XX:+PrintCompilation`\n+[`-XX:+PrintCompilation`]{#-XX__PrintCompilation}\n@@ -1989,1 +1989,1 @@\n-`-XX:+PrintInlining`\n+[`-XX:+PrintInlining`]{#-XX__PrintInlining}\n@@ -1998,1 +1998,1 @@\n-`-XX:ReservedCodeCacheSize=`*size*\n+[`-XX:ReservedCodeCacheSize=`]{#-XX_ReservedCodeCacheSize}*size*\n@@ -2008,1 +2008,1 @@\n-`-XX:+SegmentedCodeCache`\n+[`-XX:+SegmentedCodeCache`]{#-XX__SegmentedCodeCache}\n@@ -2021,1 +2021,1 @@\n-`-XX:StartAggressiveSweepingAt=`*percent*\n+[`-XX:StartAggressiveSweepingAt=`]{#-XX_StartAggressiveSweepingAt}*percent*\n@@ -2026,1 +2026,1 @@\n-`-XX:-TieredCompilation`\n+[`-XX:-TieredCompilation`]{#-XX__TieredCompilation}\n@@ -2029,1 +2029,1 @@\n-`-XX:UseSSE=`*version*\n+[`-XX:UseSSE=`]{#-XX_UseSSE}*version*\n@@ -2033,1 +2033,1 @@\n-`-XX:UseAVX=`*version*\n+[`-XX:UseAVX=`]{#-XX_UseAVX}*version*\n@@ -2037,1 +2037,1 @@\n-`-XX:+UseAES`\n+[`-XX:+UseAES`]{#-XX__UseAES}\n@@ -2043,1 +2043,1 @@\n-`-XX:+UseAESIntrinsics`\n+[`-XX:+UseAESIntrinsics`]{#-XX__UseAESIntrinsics}\n@@ -2054,1 +2054,1 @@\n-`-XX:+UseAESCTRIntrinsics`\n+[`-XX:+UseAESCTRIntrinsics`]{#-XX__UseAESCTRIntrinsics}\n@@ -2057,1 +2057,1 @@\n-`-XX:+UseGHASHIntrinsics`\n+[`-XX:+UseGHASHIntrinsics`]{#-XX__UseGHASHIntrinsics}\n@@ -2062,1 +2062,1 @@\n-`-XX:+UseChaCha20Intrinsics`\n+[`-XX:+UseChaCha20Intrinsics`]{#-XX__UseChaCha20Intrinsics}\n@@ -2068,1 +2068,1 @@\n-`-XX:+UsePoly1305Intrinsics`\n+[`-XX:+UsePoly1305Intrinsics`]{#-XX__UsePoly1305Intrinsics}\n@@ -2074,1 +2074,1 @@\n-`-XX:+UseBASE64Intrinsics`\n+[`-XX:+UseBASE64Intrinsics`]{#-XX__UseBASE64Intrinsics}\n@@ -2079,1 +2079,1 @@\n-`-XX:+UseAdler32Intrinsics`\n+[`-XX:+UseAdler32Intrinsics`]{#-XX__UseAdler32Intrinsics}\n@@ -2084,1 +2084,1 @@\n-`-XX:+UseCRC32Intrinsics`\n+[`-XX:+UseCRC32Intrinsics`]{#-XX__UseCRC32Intrinsics}\n@@ -2089,1 +2089,1 @@\n-`-XX:+UseCRC32CIntrinsics`\n+[`-XX:+UseCRC32CIntrinsics`]{#-XX__UseCRC32CIntrinsics}\n@@ -2094,1 +2094,1 @@\n-`-XX:+UseSHA`\n+[`-XX:+UseSHA`]{#-XX__UseSHA}\n@@ -2111,1 +2111,1 @@\n-`-XX:+UseSHA1Intrinsics`\n+[`-XX:+UseSHA1Intrinsics`]{#-XX__UseSHA1Intrinsics}\n@@ -2115,1 +2115,1 @@\n-`-XX:+UseSHA256Intrinsics`\n+[`-XX:+UseSHA256Intrinsics`]{#-XX__UseSHA256Intrinsics}\n@@ -2120,1 +2120,1 @@\n-`-XX:+UseSHA512Intrinsics`\n+[`-XX:+UseSHA512Intrinsics`]{#-XX__UseSHA512Intrinsics}\n@@ -2125,1 +2125,1 @@\n-`-XX:+UseMathExactIntrinsics`\n+[`-XX:+UseMathExactIntrinsics`]{#-XX__UseMathExactIntrinsics}\n@@ -2130,1 +2130,1 @@\n-`-XX:+UseMultiplyToLenIntrinsic`\n+[`-XX:+UseMultiplyToLenIntrinsic`]{#-XX__UseMultiplyToLenIntrinsic}\n@@ -2155,1 +2155,1 @@\n-`-XX:+UseCMoveUnconditionally`\n+[`-XX:+UseCMoveUnconditionally`]{#-XX__UseCMoveUnconditionally}\n@@ -2159,1 +2159,1 @@\n-`-XX:+UseCodeCacheFlushing`\n+[`-XX:+UseCodeCacheFlushing`]{#-XX__UseCodeCacheFlushing}\n@@ -2164,1 +2164,1 @@\n-`-XX:+UseCondCardMark`\n+[`-XX:+UseCondCardMark`]{#-XX__UseCondCardMark}\n@@ -2170,1 +2170,1 @@\n-`-XX:+UseCountedLoopSafepoints`\n+[`-XX:+UseCountedLoopSafepoints`]{#-XX__UseCountedLoopSafepoints}\n@@ -2174,1 +2174,1 @@\n-`-XX:LoopStripMiningIter=`*number_of_iterations*\n+[`-XX:LoopStripMiningIter=`]{#-XX_LoopStripMiningIter}*number_of_iterations*\n@@ -2181,1 +2181,1 @@\n-`-XX:LoopStripMiningIterShortLoop=`*number_of_iterations*\n+[`-XX:LoopStripMiningIterShortLoop=`]{#-XX_LoopStripMiningIterShortLoop}*number_of_iterations*\n@@ -2186,1 +2186,1 @@\n-`-XX:+UseFMA`\n+[`-XX:+UseFMA`]{#-XX__UseFMA}\n@@ -2192,1 +2192,1 @@\n-`-XX:+UseSuperWord`\n+[`-XX:+UseSuperWord`]{#-XX__UseSuperWord}\n@@ -2203,1 +2203,1 @@\n-`-XX:+DisableAttachMechanism`\n+[`-XX:+DisableAttachMechanism`]{#-XX__DisableAttachMechanism}\n@@ -2214,1 +2214,1 @@\n-`-XX:+DTraceAllocProbes`\n+[`-XX:+DTraceAllocProbes`]{#-XX__DTraceAllocProbes}\n@@ -2217,1 +2217,1 @@\n-`-XX:+DTraceMethodProbes`\n+[`-XX:+DTraceMethodProbes`]{#-XX__DTraceMethodProbes}\n@@ -2221,1 +2221,1 @@\n-`-XX:+DTraceMonitorProbes`\n+[`-XX:+DTraceMonitorProbes`]{#-XX__DTraceMonitorProbes}\n@@ -2224,1 +2224,1 @@\n-`-XX:+HeapDumpOnOutOfMemoryError`\n+[`-XX:+HeapDumpOnOutOfMemoryError`]{#-XX__HeapDumpOnOutOfMemoryError}\n@@ -2236,1 +2236,1 @@\n-`-XX:HeapDumpPath=`*path*\n+[`-XX:HeapDumpPath=`]{#-XX_HeapDumpPath}*path*\n@@ -2256,1 +2256,1 @@\n-`-XX:LogFile=`*path*\n+[`-XX:LogFile=`]{#-XX_LogFile}*path*\n@@ -2271,1 +2271,1 @@\n-`-XX:+PrintClassHistogram`\n+[`-XX:+PrintClassHistogram`]{#-XX__PrintClassHistogram}\n@@ -2285,1 +2285,1 @@\n-`-XX:+PrintConcurrentLocks`\n+[`-XX:+PrintConcurrentLocks`]{#-XX__PrintConcurrentLocks}\n@@ -2299,1 +2299,1 @@\n-`-XX:+PrintFlagsRanges`\n+[`-XX:+PrintFlagsRanges`]{#-XX__PrintFlagsRanges}\n@@ -2304,1 +2304,1 @@\n-`-XX:+PerfDataSaveToFile`\n+[`-XX:+PerfDataSaveToFile`]{#-XX__PerfDataSaveToFile}\n@@ -2315,1 +2315,1 @@\n-`-XX:+UsePerfData`\n+[`-XX:+UsePerfData`]{#-XX__UsePerfData}\n@@ -2326,1 +2326,1 @@\n-`-XX:+AlwaysPreTouch`\n+[`-XX:+AlwaysPreTouch`]{#-XX__AlwaysPreTouch}\n@@ -2332,1 +2332,1 @@\n-`-XX:ConcGCThreads=`*threads*\n+[`-XX:ConcGCThreads=`]{#-XX_ConcGCThreads}*threads*\n@@ -2342,1 +2342,1 @@\n-`-XX:+DisableExplicitGC`\n+[`-XX:+DisableExplicitGC`]{#-XX__DisableExplicitGC}\n@@ -2348,1 +2348,1 @@\n-`-XX:+ExplicitGCInvokesConcurrent`\n+[`-XX:+ExplicitGCInvokesConcurrent`]{#-XX__ExplicitGCInvokesConcurrent}\n@@ -2352,1 +2352,1 @@\n-`-XX:G1AdaptiveIHOPNumInitialSamples=`*number*\n+[`-XX:G1AdaptiveIHOPNumInitialSamples=`]{#-XX_G1AdaptiveIHOPNumInitialSamples}*number*\n@@ -2359,1 +2359,1 @@\n-`-XX:G1HeapRegionSize=`*size*\n+[`-XX:G1HeapRegionSize=`]{#-XX_G1HeapRegionSize}*size*\n@@ -2370,1 +2370,1 @@\n-`-XX:G1HeapWastePercent=`*percent*\n+[`-XX:G1HeapWastePercent=`]{#-XX_G1HeapWastePercent}*percent*\n@@ -2376,1 +2376,1 @@\n-`-XX:G1MaxNewSizePercent=`*percent*\n+[`-XX:G1MaxNewSizePercent=`]{#-XX_G1MaxNewSizePercent}*percent*\n@@ -2383,1 +2383,1 @@\n-`-XX:G1MixedGCCountTarget=`*number*\n+[`-XX:G1MixedGCCountTarget=`]{#-XX_G1MixedGCCountTarget}*number*\n@@ -2389,1 +2389,1 @@\n-`-XX:G1MixedGCLiveThresholdPercent=`*percent*\n+[`-XX:G1MixedGCLiveThresholdPercent=`]{#-XX_G1MixedGCLiveThresholdPercent}*percent*\n@@ -2396,1 +2396,1 @@\n-`-XX:G1NewSizePercent=`*percent*\n+[`-XX:G1NewSizePercent=`]{#-XX_G1NewSizePercent}*percent*\n@@ -2403,1 +2403,1 @@\n-`-XX:G1OldCSetRegionThresholdPercent=`*percent*\n+[`-XX:G1OldCSetRegionThresholdPercent=`]{#-XX_G1OldCSetRegionThresholdPercent}*percent*\n@@ -2407,1 +2407,1 @@\n-`-XX:G1ReservePercent=`*percent*\n+[`-XX:G1ReservePercent=`]{#-XX_G1ReservePercent}*percent*\n@@ -2418,1 +2418,1 @@\n-`-XX:+G1UseAdaptiveIHOP`\n+[`-XX:+G1UseAdaptiveIHOP`]{#-XX__G1UseAdaptiveIHOP}\n@@ -2431,1 +2431,1 @@\n-`-XX:InitialHeapSize=`*size*\n+[`-XX:InitialHeapSize=`]{#-XX_InitialHeapSize}*size*\n@@ -2455,1 +2455,1 @@\n-`-XX:InitialRAMPercentage=`*percent*\n+[`-XX:InitialRAMPercentage=`]{#-XX_InitialRAMPercentage}*percent*\n@@ -2465,1 +2465,1 @@\n-`-XX:InitialSurvivorRatio=`*ratio*\n+[`-XX:InitialSurvivorRatio=`]{#-XX_InitialSurvivorRatio}*ratio*\n@@ -2494,1 +2494,1 @@\n-`-XX:InitiatingHeapOccupancyPercent=`*percent*\n+[`-XX:InitiatingHeapOccupancyPercent=`]{#-XX_InitiatingHeapOccupancyPercent}*percent*\n@@ -2509,1 +2509,1 @@\n-`-XX:MaxGCPauseMillis=`*time*\n+[`-XX:MaxGCPauseMillis=`]{#-XX_MaxGCPauseMillis}*time*\n@@ -2520,1 +2520,1 @@\n-`-XX:MaxHeapSize=`*size*\n+[`-XX:MaxHeapSize=`]{#-XX_MaxHeapSize}*size*\n@@ -2540,1 +2540,1 @@\n-`-XX:MaxHeapFreeRatio=`*percent*\n+[`-XX:MaxHeapFreeRatio=`]{#-XX_MaxHeapFreeRatio}*percent*\n@@ -2561,1 +2561,1 @@\n-`-XX:MaxMetaspaceSize=`*size*\n+[`-XX:MaxMetaspaceSize=`]{#-XX_MaxMetaspaceSize}*size*\n@@ -2572,1 +2572,1 @@\n-`-XX:MaxNewSize=`*size*\n+[`-XX:MaxNewSize=`]{#-XX_MaxNewSize}*size*\n@@ -2576,1 +2576,1 @@\n-`-XX:MaxRAMPercentage=`*percent*\n+[`-XX:MaxRAMPercentage=`]{#-XX_MaxRAMPercentage}*percent*\n@@ -2592,1 +2592,1 @@\n-`-XX:MinRAMPercentage=`*percent*\n+[`-XX:MinRAMPercentage=`]{#-XX_MinRAMPercentage}*percent*\n@@ -2603,1 +2603,1 @@\n-`-XX:MaxTenuringThreshold=`*threshold*\n+[`-XX:MaxTenuringThreshold=`]{#-XX_MaxTenuringThreshold}*threshold*\n@@ -2613,1 +2613,1 @@\n-`-XX:MetaspaceSize=`*size*\n+[`-XX:MetaspaceSize=`]{#-XX_MetaspaceSize}*size*\n@@ -2619,1 +2619,1 @@\n-`-XX:MinHeapFreeRatio=`*percent*\n+[`-XX:MinHeapFreeRatio=`]{#-XX_MinHeapFreeRatio}*percent*\n@@ -2640,1 +2640,1 @@\n-`-XX:MinHeapSize=`*size*\n+[`-XX:MinHeapSize=`]{#-XX_MinHeapSize}*size*\n@@ -2659,1 +2659,1 @@\n-`-XX:NewRatio=`*ratio*\n+[`-XX:NewRatio=`]{#-XX_NewRatio}*ratio*\n@@ -2666,1 +2666,1 @@\n-`-XX:NewSize=`*size*\n+[`-XX:NewSize=`]{#-XX_NewSize}*size*\n@@ -2690,1 +2690,1 @@\n-`-XX:ParallelGCThreads=`*threads*\n+[`-XX:ParallelGCThreads=`]{#-XX_ParallelGCThreads}*threads*\n@@ -2700,1 +2700,1 @@\n-`-XX:+PrintAdaptiveSizePolicy`\n+[`-XX:+PrintAdaptiveSizePolicy`]{#-XX__PrintAdaptiveSizePolicy}\n@@ -2704,1 +2704,1 @@\n-`-XX:SoftRefLRUPolicyMSPerMB=`*time*\n+[`-XX:SoftRefLRUPolicyMSPerMB=`]{#-XX_SoftRefLRUPolicyMSPerMB}*time*\n@@ -2721,1 +2721,1 @@\n-`-XX:-ShrinkHeapInSteps`\n+[`-XX:-ShrinkHeapInSteps`]{#-XX__ShrinkHeapInSteps}\n@@ -2733,1 +2733,1 @@\n-`-XX:StringDeduplicationAgeThreshold=`*threshold*\n+[`-XX:StringDeduplicationAgeThreshold=`]{#-XX_StringDeduplicationAgeThreshold}*threshold*\n@@ -2744,1 +2744,1 @@\n-`-XX:SurvivorRatio=`*ratio*\n+[`-XX:SurvivorRatio=`]{#-XX_SurvivorRatio}*ratio*\n@@ -2751,1 +2751,1 @@\n-`-XX:TargetSurvivorRatio=`*percent*\n+[`-XX:TargetSurvivorRatio=`]{#-XX_TargetSurvivorRatio}*percent*\n@@ -2760,1 +2760,1 @@\n-`-XX:TLABSize=`*size*\n+[`-XX:TLABSize=`]{#-XX_TLABSize}*size*\n@@ -2770,1 +2770,1 @@\n-`-XX:+UseAdaptiveSizePolicy`\n+[`-XX:+UseAdaptiveSizePolicy`]{#-XX__UseAdaptiveSizePolicy}\n@@ -2776,1 +2776,1 @@\n-`-XX:+UseG1GC`\n+[`-XX:+UseG1GC`]{#-XX__UseG1GC}\n@@ -2786,1 +2786,1 @@\n-`-XX:+UseGCOverheadLimit`\n+[`-XX:+UseGCOverheadLimit`]{#-XX__UseGCOverheadLimit}\n@@ -2796,1 +2796,1 @@\n-`-XX:+UseNUMA`\n+[`-XX:+UseNUMA`]{#-XX__UseNUMA}\n@@ -2802,1 +2802,1 @@\n-`-XX:+UseParallelGC`\n+[`-XX:+UseParallelGC`]{#-XX__UseParallelGC}\n@@ -2809,1 +2809,1 @@\n-`-XX:+UseSerialGC`\n+[`-XX:+UseSerialGC`]{#-XX__UseSerialGC}\n@@ -2815,1 +2815,1 @@\n-`-XX:+UseStringDeduplication`\n+[`-XX:+UseStringDeduplication`]{#-XX__UseStringDeduplication}\n@@ -2825,1 +2825,1 @@\n-`-XX:+UseTLAB`\n+[`-XX:+UseTLAB`]{#-XX__UseTLAB}\n@@ -2830,1 +2830,1 @@\n-`-XX:+UseZGC`\n+[`-XX:+UseZGC`]{#-XX__UseZGC}\n@@ -2836,1 +2836,1 @@\n-`-XX:ZAllocationSpikeTolerance=`*factor*\n+[`-XX:ZAllocationSpikeTolerance=`]{#-XX_ZAllocationSpikeTolerance}*factor*\n@@ -2842,1 +2842,1 @@\n-`-XX:ZCollectionInterval=`*seconds*\n+[`-XX:ZCollectionInterval=`]{#-XX_ZCollectionInterval}*seconds*\n@@ -2846,1 +2846,1 @@\n-`-XX:ZFragmentationLimit=`*percent*\n+[`-XX:ZFragmentationLimit=`]{#-XX_ZFragmentationLimit}*percent*\n@@ -2852,1 +2852,1 @@\n-`-XX:+ZProactive`\n+[`-XX:+ZProactive`]{#-XX__ZProactive}\n@@ -2860,1 +2860,1 @@\n-`-XX:+ZUncommit`\n+[`-XX:+ZUncommit`]{#-XX__ZUncommit}\n@@ -2866,1 +2866,1 @@\n-`-XX:ZUncommitDelay=`*seconds*\n+[`-XX:ZUncommitDelay=`]{#-XX_ZUncommitDelay}*seconds*\n@@ -2873,1 +2873,1 @@\n-`-XX:+UseShenandoahGC`\n+[`-XX:+UseShenandoahGC`]{#-XX__UseShenandoahGC}\n@@ -2880,1 +2880,1 @@\n-`-XX:ShenandoahGCMode=`*mode*\n+[`-XX:ShenandoahGCMode=`]{#-XX_ShenandoahGCMode}*mode*\n@@ -2894,1 +2894,1 @@\n-`-XX:ShenandoahGCHeuristics=`*heuristics*\n+[`-XX:ShenandoahGCHeuristics=`]{#-XX_ShenandoahGCHeuristics}*heuristics*\n@@ -2919,1 +2919,1 @@\n-`-Xloggc:`*filename*\n+[`-Xloggc:`]{#-Xloggc_}*filename*\n@@ -2930,1 +2930,1 @@\n-`-XX:+FlightRecorder`\n+[`-XX:+FlightRecorder`]{#-XX__FlightRecorder}\n@@ -2934,1 +2934,1 @@\n-`-XX:+ParallelRefProcEnabled`\n+[`-XX:+ParallelRefProcEnabled`]{#-XX__ParallelRefProcEnabled}\n@@ -2942,1 +2942,1 @@\n-`-XX:MaxRAM=`*size*\n+[`-XX:MaxRAM=`]{#-XX_MaxRAM}*size*\n@@ -2961,1 +2961,1 @@\n-`-XX:+AggressiveHeap`\n+[`-XX:+AggressiveHeap`]{#-XX__AggressiveHeap}\n@@ -2967,1 +2967,1 @@\n-`-XX:+NeverActAsServerClassMachine`\n+[`-XX:+NeverActAsServerClassMachine`]{#-XX__NeverActAsServerClassMachine}\n@@ -2992,1 +2992,1 @@\n-`--illegal-access=`*parameter*\n+[`--illegal-access=`]{#--illegal-access}*parameter*\n@@ -3286,1 +3286,1 @@\n-`-Xlog`\n+[`-Xlog`]{#-Xlog}\n@@ -3573,1 +3573,1 @@\n-`-Xlog`\n+[`-Xlog`]{#-Xlog}\n@@ -4078,1 +4078,1 @@\n-`-XX:AOTCache=`*cachefile*\n+[`-XX:AOTCache=`]{#-XX_AOTCache}*cachefile*\n@@ -4087,1 +4087,1 @@\n-`-XX:AOTCacheOutput=`*cachefile*\n+[`-XX:AOTCacheOutput=`]{#-XX_AOTCacheOutput}*cachefile*\n@@ -4093,1 +4093,1 @@\n-`-XX:AOTConfiguration=`*configfile*\n+[`-XX:AOTConfiguration=`]{#-XX_AOTConfiguration}*configfile*\n@@ -4101,1 +4101,1 @@\n-`-XX:AOTMode=`*mode*\n+[`-XX:AOTMode=`]{#-XX_AOTMode}*mode*\n@@ -4173,1 +4173,1 @@\n-`-XX:+AOTClassLinking`\n+[`-XX:+AOTClassLinking`]{#-XX__AOTClassLinking}\n","filename":"src\/java.base\/share\/man\/java.md","additions":247,"deletions":247,"binary":false,"changes":494,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include <fcntl.h>\n@@ -78,11 +79,13 @@\n-    if (fd != -1) {\n-        struct stat buf;\n-        int result;\n-        RESTARTABLE(fstat(fd, &buf), result);\n-        if (result != -1) {\n-            if (S_ISDIR(buf.st_mode)) {\n-                close(fd);\n-                errno = EISDIR;\n-                fd = -1;\n-            }\n-        } else {\n+    \/\/ No further checking is needed if the file is not a\n+    \/\/ directory or open returned an error\n+    if (fd == -1 || ((oflag & O_ACCMODE) != O_RDONLY) != 0) {\n+        return fd;\n+    }\n+\n+    \/\/ FileInputStream is specified to throw if the\n+    \/\/ file is a directory\n+    struct stat buf;\n+    int result;\n+    RESTARTABLE(fstat(fd, &buf), result);\n+    if (result != -1) {\n+        if (S_ISDIR(buf.st_mode)) {\n@@ -90,0 +93,1 @@\n+            errno = EISDIR;\n@@ -92,0 +96,3 @@\n+    } else {\n+        close(fd);\n+        fd = -1;\n","filename":"src\/java.base\/unix\/native\/libjava\/io_util_md.c","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+ * @jls 9.6 Annotation Interfaces\n+ * @jls 9.7 Annotations\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/AnnotationMirror.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,6 +30,8 @@\n- * A value is of one of the following types:\n- * <ul><li> a wrapper class (such as {@link Integer}) for a primitive type\n- *     <li> {@code String}\n- *     <li> {@code TypeMirror}\n- *     <li> {@code VariableElement} (representing an enum constant)\n- *     <li> {@code AnnotationMirror}\n+ * A value is of one of the following types (JLS {@jls 9.6.1}):\n+ * <ul><li> a {@linkplain java.lang##wrapperClass wrapper class} to hold a\n+ *          primitive type, such as an {@code Integer} object to hold an\n+ *          {@code int}\n+ *     <li> {@code String} representing a {@code String}\n+ *     <li> {@link javax.lang.model.type.TypeMirror TypeMirror} representing a {@code Class} literal\n+ *     <li> {@link VariableElement} representing an enum constant\n+ *     <li> {@link AnnotationMirror} representing an annotation\n@@ -37,1 +39,1 @@\n- *              (representing the elements, in declared order, if the value is an array)\n+ *              representing the elements, in declared order, if the value is an array\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/AnnotationValue.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,7 @@\n+ * @jls 8.4 Method Declarations\n+ * @jls 8.6 Instance Initializers\n+ * @jls 8.7 Static Initializers\n+ * @jls 8.8 Constructor Declarations\n+ * @jls 9.4 Method Declarations\n+ * @jls 9.6.1 Annotation Interface Elements\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,2 @@\n+ * @jls 7.4 Package Declarations\n+ *\n@@ -90,0 +92,1 @@\n+     * @jls 7.4.1 Named Packages\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/PackageElement.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+ * @jls 4.5 Parameterized Types\n+ * @jls 8.4.4 Generic Methods\n+ * @jls 8.8.4 Generic Constructors\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Parameterizable.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+ * @jls 6.5.3.2 Qualified Package Names\n+ * @jls 6.5.5.2 Qualified Type Names\n+ * @jls 6.7 Fully Qualified Names and Canonical Names\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/QualifiedNameable.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,1 @@\n+ *\n@@ -84,0 +85,8 @@\n+ * @jls 8.1 Class Declarations\n+ * @jls 8.5 Member Class and Interface Declarations\n+ * @jls 8.9 Enum Classes\n+ * @jls 8.10 Record Classes\n+ * @jls 9.1 Interface Declarations\n+ * @jls 9.5 Member Class and Interface Declarations\n+ * @jls 9.6 Annotation Interfaces\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,5 @@\n+ * @jls 8.1.2 Generic Classes and Type Parameters\n+ * @jls 8.4.4 Generic Methods\n+ * @jls 8.8.4 Generic Constructors\n+ * @jls 9.1.2 Generic Interfaces and Type Parameters\n+ *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeParameterElement.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,8 @@\n+ * @jls 8.3 Field Declaration\n+ * @jls 8.9.1 Enum Constants\n+ * @jls 8.4.1 Formal Parameters\n+ * @jls 8.8.1 Formal Parameters\n+ * @jls 14.4 Local Variable Declarations\n+ * @jls 14.20 The {@code try} statement\n+ * @jls 14.20.3 {@code try}-with-resources\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,9 @@\n+     * @apiNote The identity of a {@code TypeMirror} involves implicit\n+     * state not directly accessible from its methods, including state\n+     * about the presence of unrelated types. {@code TypeMirror}\n+     * objects created by different implementations of these\n+     * interfaces should <i>not<\/i> be expected to compare as equal\n+     * even if &quot;the same&quot; type is being modeled; this is\n+     * analogous to the inequality of {@code Class} objects for the\n+     * same class file loaded through different class loaders.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeMirror.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,0 +109,9 @@\n+     * @apiNote The identity of a {@code TypeMirror} involves implicit\n+     * state not directly accessible from its methods, including state\n+     * about the presence of unrelated types. {@code TypeMirror}\n+     * objects created by different implementations of these\n+     * interfaces should <i>not<\/i> be expected to compare as equal\n+     * even if &quot;the same&quot; type is being modeled; this is\n+     * analogous to the inequality of {@code Class} objects for the\n+     * same class file loaded through different class loaders.\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import sun.awt.AppContext;\n-\n@@ -153,0 +151,13 @@\n+    abstract static class LazySingleton<T> {\n+        T instance;\n+\n+         final T get() {\n+            if (instance == null) {\n+                instance = getInstance();\n+            }\n+            return instance;\n+         }\n+\n+        abstract T getInstance();\n+    }\n+\n@@ -154,3 +165,0 @@\n-        final T get() {\n-            return AppContext.getSoftReferenceValue(this, () -> getInstance());\n-        }\n@@ -158,2 +166,13 @@\n-        void reset() {\n-            AppContext.getAppContext().remove(this);\n+        SoftReference<T> ref;\n+\n+        final T get() {\n+            T instance;\n+            if (ref != null) {\n+                instance = ref.get();\n+                if (instance != null) {\n+                    return instance;\n+                }\n+            }\n+            instance = getInstance();\n+            ref = new SoftReference<>(instance);\n+            return instance;\n@@ -200,1 +219,1 @@\n-    private static final RecyclableSingleton<Boolean> enableAnimations = new RecyclableSingleton<Boolean>() {\n+    private static final LazySingleton<Boolean> enableAnimations = new LazySingleton<Boolean>() {\n@@ -203,2 +222,2 @@\n-            final String sizeProperty = System.getProperty(ANIMATIONS_PROPERTY);\n-            return !\"false\".equals(sizeProperty); \/\/ should be true by default\n+            final String animationsProperty = System.getProperty(ANIMATIONS_PROPERTY);\n+            return !\"false\".equals(animationsProperty); \/\/ should be true by default\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaUtils.java","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,2 +165,1 @@\n-                bits == 8 ? FALSE           \/\/ little-endian for 8bit\n-                    : UTIL_IsBigEndianPlatform());\n+                FALSE);                     \/\/ all supported macOS versions run on LE\n@@ -178,1 +177,1 @@\n-            UTIL_IsBigEndianPlatform());    \/\/ native endianness\n+            FALSE);                         \/\/ native endianness; all supported macOS versions run on LE\n","filename":"src\/java.desktop\/macosx\/native\/libjsound\/PLATFORM_API_MacOSX_PCM.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+        @Override\n@@ -80,0 +81,1 @@\n+        @Override\n@@ -102,0 +104,1 @@\n+        @Override\n@@ -112,0 +115,1 @@\n+        @Override\n@@ -133,0 +137,1 @@\n+        @Override\n@@ -190,0 +195,1 @@\n+        @Override\n@@ -205,0 +211,1 @@\n+        @Override\n@@ -226,0 +233,1 @@\n+        @Override\n@@ -239,0 +247,1 @@\n+        @Override\n@@ -252,0 +261,1 @@\n+        @Override\n@@ -300,0 +310,1 @@\n+        @Override\n@@ -427,0 +438,1 @@\n+        @Override\n@@ -490,0 +502,1 @@\n+        @Override\n@@ -509,0 +522,1 @@\n+        @Override\n@@ -528,0 +542,1 @@\n+        @Override\n@@ -548,0 +563,1 @@\n+        @Override\n@@ -570,0 +586,1 @@\n+        @Override\n@@ -670,0 +687,1 @@\n+        @Override\n@@ -716,0 +734,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifBorders.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifButtonListener.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+    @Override\n@@ -84,0 +85,1 @@\n+    @Override\n@@ -93,0 +95,1 @@\n+    @Override\n@@ -109,0 +112,1 @@\n+    @Override\n@@ -115,0 +119,1 @@\n+    @Override\n@@ -130,0 +135,1 @@\n+    @Override\n@@ -134,0 +140,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifButtonUI.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+    @Override\n@@ -59,0 +60,1 @@\n+    @Override\n@@ -69,0 +71,1 @@\n+        @Override\n@@ -75,0 +78,1 @@\n+    @Override\n@@ -81,0 +85,1 @@\n+        @Override\n@@ -82,0 +87,1 @@\n+        @Override\n@@ -86,0 +92,1 @@\n+        @Override\n@@ -102,0 +109,1 @@\n+        @Override\n@@ -103,0 +111,1 @@\n+        @Override\n@@ -104,0 +113,1 @@\n+        @Override\n@@ -107,0 +117,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifCheckBoxMenuItemUI.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+    @Override\n@@ -70,0 +71,1 @@\n+    @Override\n@@ -78,0 +80,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifCheckBoxUI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    @Override\n@@ -75,0 +76,1 @@\n+    @Override\n@@ -92,0 +94,1 @@\n+    @Override\n@@ -109,0 +112,1 @@\n+        @Override\n@@ -113,0 +117,1 @@\n+        @Override\n@@ -124,0 +129,1 @@\n+    @Override\n@@ -132,0 +138,1 @@\n+    @Override\n@@ -137,0 +144,1 @@\n+    @Override\n@@ -183,0 +191,1 @@\n+    @Override\n@@ -229,0 +238,1 @@\n+    @Override\n@@ -254,0 +264,1 @@\n+    @Override\n@@ -259,0 +270,1 @@\n+    @Override\n@@ -276,0 +288,1 @@\n+        @Override\n@@ -301,0 +314,1 @@\n+        @Override\n@@ -325,0 +339,1 @@\n+        @Override\n@@ -329,0 +344,1 @@\n+        @Override\n@@ -339,0 +355,1 @@\n+    @Override\n@@ -348,0 +365,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifComboBoxUI.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+    @Override\n@@ -97,0 +98,1 @@\n+    @Override\n@@ -100,0 +102,1 @@\n+    @Override\n@@ -103,0 +106,1 @@\n+    @Override\n@@ -152,0 +156,1 @@\n+    @Override\n@@ -159,0 +164,1 @@\n+    @Override\n@@ -166,0 +172,1 @@\n+    @Override\n@@ -183,0 +190,1 @@\n+    @Override\n@@ -187,0 +195,1 @@\n+    @Override\n@@ -216,0 +225,1 @@\n+                @Override\n@@ -219,0 +229,1 @@\n+                @Override\n@@ -224,0 +235,1 @@\n+                @Override\n@@ -227,0 +239,1 @@\n+                @Override\n@@ -230,0 +243,1 @@\n+                @Override\n@@ -233,0 +247,1 @@\n+                @Override\n@@ -236,0 +251,1 @@\n+                @Override\n@@ -254,0 +270,1 @@\n+        @Override\n@@ -259,0 +276,1 @@\n+        @Override\n@@ -264,0 +282,1 @@\n+        @Override\n@@ -274,0 +293,1 @@\n+        @Override\n@@ -311,0 +331,1 @@\n+                @Override\n@@ -314,0 +335,1 @@\n+                @Override\n@@ -319,0 +341,1 @@\n+                @Override\n@@ -322,0 +345,1 @@\n+                @Override\n@@ -325,0 +349,1 @@\n+                @Override\n@@ -330,0 +355,1 @@\n+                @Override\n@@ -333,0 +359,1 @@\n+                @Override\n@@ -350,0 +377,1 @@\n+        @Override\n@@ -358,0 +386,1 @@\n+        @Override\n@@ -365,0 +394,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifDesktopIconUI.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+    @Override\n@@ -78,0 +79,1 @@\n+        @Override\n@@ -95,0 +97,1 @@\n+    @Override\n@@ -115,0 +118,1 @@\n+    @Override\n@@ -128,0 +132,1 @@\n+    @Override\n@@ -132,0 +137,1 @@\n+    @Override\n@@ -146,0 +152,1 @@\n+    @Override\n@@ -160,0 +167,1 @@\n+    @Override\n@@ -165,0 +173,1 @@\n+    @Override\n@@ -175,0 +184,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifDesktopPaneUI.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifEditorPaneUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,1 @@\n+    @Override\n@@ -152,0 +153,1 @@\n+    @Override\n@@ -158,0 +160,1 @@\n+    @Override\n@@ -162,0 +165,1 @@\n+    @Override\n@@ -166,0 +170,1 @@\n+    @Override\n@@ -170,0 +175,1 @@\n+    @Override\n@@ -174,0 +180,1 @@\n+    @Override\n@@ -176,0 +183,1 @@\n+            @Override\n@@ -269,0 +277,1 @@\n+    @Override\n@@ -273,0 +282,1 @@\n+    @Override\n@@ -280,0 +290,1 @@\n+    @Override\n@@ -285,0 +296,1 @@\n+            @Override\n@@ -308,0 +320,1 @@\n+            @Override\n@@ -343,0 +356,1 @@\n+            @Override\n@@ -420,0 +434,1 @@\n+            @Override\n@@ -444,0 +459,1 @@\n+            @Override\n@@ -459,0 +475,1 @@\n+            @Override\n@@ -473,0 +490,1 @@\n+            @Override\n@@ -487,0 +505,1 @@\n+            @Override\n@@ -523,0 +542,1 @@\n+    @Override\n@@ -531,0 +551,1 @@\n+    @Override\n@@ -558,0 +579,1 @@\n+    @Override\n@@ -563,0 +585,1 @@\n+    @Override\n@@ -583,0 +606,1 @@\n+            @Override\n@@ -653,0 +677,1 @@\n+        @Override\n@@ -668,0 +693,1 @@\n+        @Override\n@@ -687,0 +713,1 @@\n+        @Override\n@@ -691,0 +718,1 @@\n+        @Override\n@@ -695,0 +723,1 @@\n+        @Override\n@@ -699,0 +728,1 @@\n+        @Override\n@@ -712,0 +742,1 @@\n+        @Override\n@@ -724,0 +755,1 @@\n+        @Override\n@@ -736,0 +768,1 @@\n+        @Override\n@@ -740,0 +773,1 @@\n+        @Override\n@@ -744,0 +778,1 @@\n+        @Override\n@@ -756,0 +791,1 @@\n+        @Override\n@@ -782,0 +818,1 @@\n+        @Override\n@@ -808,0 +845,1 @@\n+        @Override\n@@ -818,0 +856,1 @@\n+        @Override\n@@ -825,0 +864,1 @@\n+        @Override\n@@ -846,0 +886,1 @@\n+        @Override\n@@ -854,0 +895,1 @@\n+        @Override\n@@ -867,0 +909,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifFileChooserUI.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,1 @@\n+        @Override\n@@ -161,0 +162,1 @@\n+        @Override\n@@ -165,0 +167,1 @@\n+        @Override\n@@ -261,0 +264,1 @@\n+        @Override\n@@ -306,0 +310,1 @@\n+        @Override\n@@ -310,0 +315,1 @@\n+        @Override\n@@ -318,0 +324,1 @@\n+        @Override\n@@ -321,0 +328,1 @@\n+        @Override\n@@ -322,0 +330,1 @@\n+        @Override\n@@ -329,0 +338,1 @@\n+        @Override\n@@ -332,0 +342,1 @@\n+        @Override\n@@ -333,0 +344,1 @@\n+        @Override\n@@ -343,0 +355,1 @@\n+        @Override\n@@ -417,0 +430,1 @@\n+        @Override\n@@ -418,0 +432,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifIconFactory.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+    @Override\n@@ -74,0 +75,1 @@\n+    @Override\n@@ -79,0 +81,1 @@\n+    @Override\n@@ -83,0 +86,1 @@\n+    @Override\n@@ -91,0 +95,1 @@\n+    @Override\n@@ -109,0 +114,1 @@\n+            @Override\n@@ -115,0 +121,1 @@\n+            @Override\n@@ -140,0 +147,1 @@\n+    @Override\n@@ -149,0 +157,1 @@\n+    @Override\n@@ -159,0 +168,1 @@\n+    @Override\n@@ -168,0 +178,1 @@\n+    @Override\n@@ -171,0 +182,1 @@\n+    @Override\n@@ -197,0 +209,1 @@\n+    @Override\n@@ -198,0 +211,1 @@\n+    @Override\n@@ -199,0 +213,1 @@\n+    @Override\n@@ -203,0 +218,1 @@\n+    @Override\n@@ -207,0 +223,1 @@\n+    @Override\n@@ -229,0 +246,1 @@\n+    @Override\n@@ -248,0 +266,1 @@\n+        @Override\n@@ -253,0 +272,1 @@\n+        @Override\n@@ -257,0 +277,1 @@\n+        @Override\n@@ -261,0 +282,1 @@\n+        @Override\n@@ -265,0 +287,1 @@\n+        @Override\n@@ -287,0 +310,1 @@\n+        @Override\n@@ -300,0 +324,1 @@\n+        @Override\n@@ -315,0 +340,1 @@\n+        @Override\n@@ -316,0 +342,1 @@\n+        @Override\n@@ -318,0 +345,1 @@\n+        @Override\n@@ -342,0 +370,1 @@\n+                @Override\n@@ -345,0 +374,1 @@\n+                @Override\n@@ -350,0 +380,1 @@\n+                @Override\n@@ -353,0 +384,1 @@\n+                @Override\n@@ -356,0 +388,1 @@\n+                @Override\n@@ -359,0 +392,1 @@\n+                @Override\n@@ -362,0 +396,1 @@\n+                @Override\n@@ -380,0 +415,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifInternalFrameTitlePane.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+    @Override\n@@ -89,0 +90,1 @@\n+    @Override\n@@ -98,0 +100,1 @@\n+    @Override\n@@ -106,0 +109,1 @@\n+    @Override\n@@ -116,0 +120,1 @@\n+    @Override\n@@ -121,0 +126,1 @@\n+    @Override\n@@ -125,0 +131,1 @@\n+    @Override\n@@ -135,0 +142,1 @@\n+    @Override\n@@ -144,0 +152,1 @@\n+                @Override\n@@ -147,0 +156,1 @@\n+                @Override\n@@ -154,0 +164,1 @@\n+    @Override\n@@ -158,0 +169,1 @@\n+                @Override\n@@ -161,0 +173,1 @@\n+                @Override\n@@ -187,0 +200,1 @@\n+                @Override\n@@ -194,0 +208,1 @@\n+                @Override\n@@ -204,0 +219,1 @@\n+    @Override\n@@ -210,0 +226,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifInternalFrameUI.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+    @Override\n@@ -63,0 +64,1 @@\n+    @Override\n@@ -67,0 +69,1 @@\n+    @Override\n@@ -72,0 +75,1 @@\n+    @Override\n@@ -77,0 +81,1 @@\n+    @Override\n@@ -90,0 +95,1 @@\n+    @Override\n@@ -126,0 +132,1 @@\n+    @Override\n@@ -181,0 +188,1 @@\n+    @Override\n@@ -258,0 +266,1 @@\n+            @Override\n@@ -264,0 +273,1 @@\n+            @Override\n@@ -270,0 +280,1 @@\n+            @Override\n@@ -276,0 +287,1 @@\n+            @Override\n@@ -282,0 +294,1 @@\n+            @Override\n@@ -288,0 +301,1 @@\n+            @Override\n@@ -297,0 +311,1 @@\n+            @Override\n@@ -306,0 +321,1 @@\n+            @Override\n@@ -316,0 +332,1 @@\n+            @Override\n@@ -465,0 +482,1 @@\n+            @Override\n@@ -471,0 +489,1 @@\n+            @Override\n@@ -477,0 +496,1 @@\n+            @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifLookAndFeel.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+    @Override\n@@ -59,0 +60,1 @@\n+    @Override\n@@ -68,0 +70,1 @@\n+    @Override\n@@ -74,0 +77,1 @@\n+        @Override\n@@ -82,0 +86,1 @@\n+        @Override\n@@ -83,0 +88,1 @@\n+        @Override\n@@ -87,0 +93,1 @@\n+        @Override\n@@ -100,0 +107,1 @@\n+        @Override\n@@ -101,0 +109,1 @@\n+        @Override\n@@ -102,0 +111,1 @@\n+        @Override\n@@ -105,0 +115,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifMenuItemUI.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+    @Override\n@@ -39,0 +40,1 @@\n+    @Override\n@@ -42,0 +44,1 @@\n+    @Override\n@@ -45,0 +48,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifMenuMouseListener.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+    @Override\n@@ -40,0 +41,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifMenuMouseMotionListener.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    @Override\n@@ -79,0 +80,1 @@\n+    @Override\n@@ -89,0 +91,1 @@\n+        @Override\n@@ -103,0 +106,1 @@\n+        @Override\n@@ -104,0 +108,1 @@\n+        @Override\n@@ -132,0 +137,1 @@\n+        @Override\n@@ -142,0 +148,1 @@\n+        @Override\n@@ -143,0 +150,1 @@\n+        @Override\n@@ -144,0 +152,1 @@\n+        @Override\n@@ -147,0 +156,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifMenuUI.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+    @Override\n@@ -72,0 +73,1 @@\n+    @Override\n@@ -76,0 +78,1 @@\n+    @Override\n@@ -79,0 +82,1 @@\n+            @Override\n@@ -83,0 +87,1 @@\n+            @Override\n@@ -98,0 +103,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifOptionPaneUI.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifPasswordFieldUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+    @Override\n@@ -61,0 +62,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifPopupMenuSeparatorUI.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    @Override\n@@ -97,0 +98,1 @@\n+            @Override\n@@ -101,0 +103,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifPopupMenuUI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    @Override\n@@ -64,0 +65,1 @@\n+    @Override\n@@ -75,0 +77,1 @@\n+        @Override\n@@ -81,0 +84,1 @@\n+    @Override\n@@ -87,0 +91,1 @@\n+        @Override\n@@ -88,0 +93,1 @@\n+        @Override\n@@ -92,0 +98,1 @@\n+        @Override\n@@ -108,0 +115,1 @@\n+        @Override\n@@ -109,0 +117,1 @@\n+        @Override\n@@ -110,0 +119,1 @@\n+        @Override\n@@ -113,0 +123,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifRadioButtonMenuItemUI.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,1 @@\n+    @Override\n@@ -79,0 +80,1 @@\n+    @Override\n@@ -95,0 +97,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifRadioButtonUI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+    @Override\n@@ -79,0 +80,1 @@\n+    @Override\n@@ -83,0 +85,1 @@\n+    @Override\n@@ -87,0 +90,1 @@\n+    @Override\n@@ -91,0 +95,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifScrollBarButton.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+    @Override\n@@ -64,0 +65,1 @@\n+    @Override\n@@ -68,0 +70,1 @@\n+    @Override\n@@ -72,0 +75,1 @@\n+    @Override\n@@ -77,0 +81,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifScrollBarUI.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+    @Override\n@@ -71,0 +72,1 @@\n+    @Override\n@@ -75,0 +77,1 @@\n+    @Override\n@@ -79,0 +82,1 @@\n+    @Override\n@@ -83,0 +87,1 @@\n+    @Override\n@@ -92,0 +97,1 @@\n+    @Override\n@@ -95,0 +101,1 @@\n+    @Override\n@@ -98,0 +105,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifSliderUI.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,1 @@\n+    @Override\n@@ -112,0 +113,1 @@\n+    @Override\n@@ -182,0 +184,1 @@\n+    @Override\n@@ -190,0 +193,1 @@\n+    @Override\n@@ -271,0 +275,1 @@\n+        @Override\n@@ -280,0 +285,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifSplitPaneDivider.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifSplitPaneUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    @Override\n@@ -73,0 +74,1 @@\n+    @Override\n@@ -84,0 +86,1 @@\n+   @Override\n@@ -107,0 +110,1 @@\n+    @Override\n@@ -129,0 +133,1 @@\n+    @Override\n@@ -151,0 +156,1 @@\n+    @Override\n@@ -177,0 +183,1 @@\n+    @Override\n@@ -228,0 +235,1 @@\n+    @Override\n@@ -266,0 +274,1 @@\n+    @Override\n@@ -270,0 +279,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifTabbedPaneUI.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifTextAreaUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifTextFieldUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifTextPaneUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+        @Override\n@@ -91,0 +92,1 @@\n+        @Override\n@@ -104,0 +106,1 @@\n+        @Override\n@@ -124,0 +127,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifTextUI.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+    @Override\n@@ -83,0 +84,1 @@\n+    @Override\n@@ -99,0 +101,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifToggleButtonUI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+        @Override\n@@ -93,0 +94,1 @@\n+        @Override\n@@ -97,0 +99,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifTreeCellRenderer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    @Override\n@@ -63,0 +64,1 @@\n+    @Override\n@@ -72,0 +74,1 @@\n+    @Override\n@@ -99,0 +102,1 @@\n+        @Override\n@@ -116,0 +120,1 @@\n+        @Override\n@@ -117,0 +122,1 @@\n+        @Override\n@@ -129,0 +135,1 @@\n+        @Override\n@@ -144,0 +151,1 @@\n+    @Override\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifTreeUI.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.nio.ByteOrder;\n@@ -43,6 +44,0 @@\n-    \/\/ SYSTEM CHARACTERISTICS\n-    \/\/ vary according to hardware architecture\n-\n-    \/\/ intel is little-endian.  sparc is big-endian.\n-    private static boolean bigEndian;\n-\n@@ -69,1 +64,1 @@\n-        return bigEndian;\n+        return ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);\n@@ -85,3 +80,0 @@\n-        if (isNativeLibLoaded) {\n-            bigEndian = nIsBigEndian();\n-        }\n@@ -101,3 +93,0 @@\n-\n-    \/\/ the following native method is implemented in Platform.c\n-    private static native boolean nIsBigEndian();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/Platform.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1408,1 +1408,1 @@\n-            if (containerSize.height <= 0 || containerSize.width <= 0 ) {\n+            if (containerSize.height <= 0 && containerSize.width <= 0 ) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import java.util.function.Supplier;\n@@ -738,18 +737,0 @@\n-\n-    public static <T> T getSoftReferenceValue(Object key,\n-            Supplier<T> supplier) {\n-\n-        final AppContext appContext = AppContext.getAppContext();\n-        @SuppressWarnings(\"unchecked\")\n-        SoftReference<T> ref = (SoftReference<T>) appContext.get(key);\n-        if (ref != null) {\n-            final T object = ref.get();\n-            if (object != null) {\n-                return object;\n-            }\n-        }\n-        final T object = supplier.get();\n-        ref = new SoftReference<>(object);\n-        appContext.put(key, ref);\n-        return object;\n-    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AppContext.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import sun.awt.AppContext;\n@@ -40,2 +39,0 @@\n- * The ImageCache must be used from the thread with an AppContext only.\n- *\n@@ -59,0 +56,2 @@\n+    private static final ImageCache instance = new ImageCache();\n+\n@@ -60,2 +59,1 @@\n-        return AppContext.getSoftReferenceValue(ImageCache.class,\n-                () -> new ImageCache());\n+        return instance;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ImageCache.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,2 +305,10 @@\n-            if(interlaceMethod==0) { pass = -1; passLimit = 0; }\n-            else { pass = 0; passLimit = 7; }\n+            boolean isDirectByteCopy;\n+            if(interlaceMethod==0) {\n+                pass = -1;\n+                passLimit = 0;\n+                isDirectByteCopy = bPixels != null && bitDepth == 8;\n+            } else {\n+                pass = 0;\n+                passLimit = 7;\n+                isDirectByteCopy = false;\n+            }\n@@ -337,1 +345,5 @@\n-                        if(wPixels !=null) {\n+                        if (isDirectByteCopy) {\n+                            System.arraycopy(rowByteBuffer, spos, bPixels, col + rowOffset, width);\n+                            spos += width;\n+                            break;\n+                        } else if(wPixels !=null) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/PNGImageDecoder.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,2 +95,2 @@\n-        String matchRegex = \"(0[xX])?[0-9a-fA-F]+[\\\\s+]?[,|};]\";\n-        String replaceRegex = \"(0[xX])|,|[\\\\s+]|[};]\";\n+        String matchRegex = \"\\\\s*(0[xX])?((?:(?!,|\\\\};).)+)(,|\\\\};)\";\n+        String replaceRegex = \"0[xX]|,|\\\\s+|\\\\};\";\n@@ -114,2 +114,6 @@\n-                            W = Integer.parseInt(token[2]);\n-                            state = 1; \/\/ after width is set\n+                            if (token[1].endsWith(\"th\")) {\n+                                W = Integer.parseInt(token[2]);\n+                            } else if (token[1].endsWith(\"t\")) {\n+                                H = Integer.parseInt(token[2]);\n+                            }\n+                            state = 1; \/\/ after first dimension is set\n@@ -117,2 +121,6 @@\n-                            H = Integer.parseInt(token[2]);\n-                            state = 2; \/\/ after height is set\n+                            if (token[1].endsWith(\"th\")) {\n+                                W = Integer.parseInt(token[2]);\n+                            } else if (token[1].endsWith(\"t\")) {\n+                                H = Integer.parseInt(token[2]);\n+                            }\n+                            state = 2; \/\/ after second dimension is set\n@@ -150,0 +158,3 @@\n+            boolean contFlag = false;\n+            StringBuilder sb = new StringBuilder();\n+\n@@ -154,7 +165,7 @@\n-                if (line.contains(\"[]\")) {\n-                    Matcher matcher = Pattern.compile(matchRegex).matcher(line);\n-                    while (matcher.find()) {\n-                        if (y >= H) {\n-                            error(\"Scan size of XBM file exceeds\"\n-                                    + \" the defined width x height\");\n-                        }\n+                if (!contFlag) {\n+                    if (line.contains(\"[]\")) {\n+                        contFlag = true;\n+                    } else {\n+                        continue;\n+                    }\n+                }\n@@ -162,3 +173,8 @@\n-                        int startIndex = matcher.start();\n-                        int endIndex = matcher.end();\n-                        String hexByte = line.substring(startIndex, endIndex);\n+                int end = line.indexOf(';');\n+                if (end >= 0) {\n+                    sb.append(line, 0, end + 1);\n+                    break;\n+                } else {\n+                    sb.append(line).append(System.lineSeparator());\n+                }\n+            }\n@@ -166,10 +182,3 @@\n-                        if (!(hexByte.startsWith(\"0x\")\n-                                || hexByte.startsWith(\"0X\"))) {\n-                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n-                                    + \" Col#:\" + (startIndex + 1));\n-                        }\n-                        hexByte = hexByte.replaceAll(replaceRegex, \"\");\n-                        if (hexByte.length() != 2) {\n-                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n-                                    + \" Col#:\" + (startIndex + 1));\n-                        }\n+            String resultLine = sb.toString();\n+            int cutOffIndex = resultLine.indexOf('{');\n+            resultLine = resultLine.substring(cutOffIndex + 1);\n@@ -177,15 +186,6 @@\n-                        try {\n-                            n = Integer.parseInt(hexByte, 16);\n-                        } catch (NumberFormatException nfe) {\n-                            error(\"Error parsing hexadecimal at Ln#:\" + lineNum\n-                                    + \" Col#:\" + (startIndex + 1));\n-                        }\n-                        for (int mask = 1; mask <= 0x80; mask <<= 1) {\n-                            if (x < W) {\n-                                if ((n & mask) != 0)\n-                                    raster[x] = 1;\n-                                else\n-                                    raster[x] = 0;\n-                            }\n-                            x++;\n-                        }\n+            Matcher matcher = Pattern.compile(matchRegex).matcher(resultLine);\n+            while (matcher.find()) {\n+                if (y >= H) {\n+                    error(\"Scan size of XBM file exceeds\"\n+                            + \" the defined width x height\");\n+                }\n@@ -193,8 +193,36 @@\n-                        if (x >= W) {\n-                            int result = setPixels(0, y, W, 1, model, raster, 0, W);\n-                            if (result <= 0) {\n-                                error(\"Unexpected error occurred during setPixel()\");\n-                            }\n-                            x = 0;\n-                            y++;\n-                        }\n+                int startIndex = matcher.start();\n+                int endIndex = matcher.end();\n+                String hexByte = resultLine.substring(startIndex, endIndex);\n+                hexByte = hexByte.replaceAll(\"^\\\\s+\", \"\");\n+\n+                if (!(hexByte.startsWith(\"0x\")\n+                        || hexByte.startsWith(\"0X\"))) {\n+                    error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                            + \" Col#:\" + (startIndex + 1));\n+                }\n+                hexByte = hexByte.replaceAll(replaceRegex, \"\");\n+                if (hexByte.length() != 2) {\n+                    error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                            + \" Col#:\" + (startIndex + 1));\n+                }\n+\n+                try {\n+                    n = Integer.parseInt(hexByte, 16);\n+                } catch (NumberFormatException nfe) {\n+                    error(\"Error parsing hexadecimal at Ln#:\" + lineNum\n+                            + \" Col#:\" + (startIndex + 1));\n+                }\n+                for (int mask = 1; mask <= 0x80; mask <<= 1) {\n+                    if (x < W) {\n+                        if ((n & mask) != 0)\n+                            raster[x] = 1;\n+                        else\n+                            raster[x] = 0;\n+                    }\n+                    x++;\n+                }\n+\n+                if (x >= W) {\n+                    int result = setPixels(0, y, W, 1, model, raster, 0, W);\n+                    if (result <= 0) {\n+                        error(\"Unexpected error occurred during setPixel()\");\n@@ -202,0 +230,2 @@\n+                    x = 0;\n+                    y++;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/XbmImageDecoder.java","additions":80,"deletions":50,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-#include \"Utilities.h\"\n-\/\/ Platform.java includes\n-#include \"com_sun_media_sound_Platform.h\"\n-\n-\/*\n- * Declare library specific JNI_Onload entry if static build\n- *\/\n-DEF_STATIC_JNI_OnLoad\n-\n-\/*\n- * Class:     com_sun_media_sound_Platform\n- * Method:    nIsBigEndian\n- * Signature: ()Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_com_sun_media_sound_Platform_nIsBigEndian(JNIEnv *env, jclass clss) {\n-    return UTIL_IsBigEndianPlatform();\n-}\n","filename":"src\/java.desktop\/share\/native\/libjsound\/Platform.c","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,9 +29,0 @@\n-\n-int UTIL_IsBigEndianPlatform() {\n-#ifdef _LITTLE_ENDIAN\n-    return 0;\n-#else\n-    return 1;\n-#endif\n-}\n-\n","filename":"src\/java.desktop\/share\/native\/libjsound\/Utilities.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,0 @@\n-\/\/ return 1 if this platform is big endian, or 0 for little endian\n-int UTIL_IsBigEndianPlatform();\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libjsound\/Utilities.h","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.util.Assert;\n@@ -43,2 +41,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -181,0 +177,8 @@\n+     * Each lint category has a logical name (a string), which is the string used e.g. in a {@code SuppressWarning} annotation.\n+     * To ensure automation, the enum field name for a lint category string {@code C} should be obtained by:\n+     * <ol>\n+     *    <li>capitalize all the letters in {@code C}, and<\/li>\n+     *    <li>replacing any occurrence of {@code -} with {@code _}<\/li>\n+     * <\/ol>\n+     * For instance, the lint category string {@code dangling-doc-comments} corresponds to the enum field\n+     * {@code DANGLING_DOC_COMMENTS}.\n@@ -334,1 +338,1 @@\n-        RAW(\"rawtypes\"),\n+        RAWTYPES(\"rawtypes\"),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1406,0 +1406,1 @@\n+            scan(tree.dims);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1128,0 +1128,1 @@\n+            scan(tree.dims);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2876,1 +2876,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (byte) VectorMath.minUnsigned(a, b)));\n+                    toBits(v.rOp(UMAX_VALUE, m, (i, a, b) -> (byte) VectorMath.minUnsigned(a, b)));\n@@ -2878,1 +2878,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (byte) VectorMath.maxUnsigned(a, b)));\n+                    toBits(v.rOp(UMIN_VALUE, m, (i, a, b) -> (byte) VectorMath.maxUnsigned(a, b)));\n@@ -2893,0 +2893,2 @@\n+    private static final byte UMIN_VALUE = (byte)0;   \/\/ Minimum unsigned value\n+    private static final byte UMAX_VALUE = (byte)-1;  \/\/ Maximum unsigned value\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2861,1 +2861,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (int) VectorMath.minUnsigned(a, b)));\n+                    toBits(v.rOp(UMAX_VALUE, m, (i, a, b) -> (int) VectorMath.minUnsigned(a, b)));\n@@ -2863,1 +2863,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (int) VectorMath.maxUnsigned(a, b)));\n+                    toBits(v.rOp(UMIN_VALUE, m, (i, a, b) -> (int) VectorMath.maxUnsigned(a, b)));\n@@ -2878,0 +2878,2 @@\n+    private static final int UMIN_VALUE = (int)0;   \/\/ Minimum unsigned value\n+    private static final int UMAX_VALUE = (int)-1;  \/\/ Maximum unsigned value\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2727,1 +2727,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (long) VectorMath.minUnsigned(a, b)));\n+                    toBits(v.rOp(UMAX_VALUE, m, (i, a, b) -> (long) VectorMath.minUnsigned(a, b)));\n@@ -2729,1 +2729,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (long) VectorMath.maxUnsigned(a, b)));\n+                    toBits(v.rOp(UMIN_VALUE, m, (i, a, b) -> (long) VectorMath.maxUnsigned(a, b)));\n@@ -2744,0 +2744,2 @@\n+    private static final long UMIN_VALUE = (long)0;   \/\/ Minimum unsigned value\n+    private static final long UMAX_VALUE = (long)-1;  \/\/ Maximum unsigned value\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2877,1 +2877,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> (short) VectorMath.minUnsigned(a, b)));\n+                    toBits(v.rOp(UMAX_VALUE, m, (i, a, b) -> (short) VectorMath.minUnsigned(a, b)));\n@@ -2879,1 +2879,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> (short) VectorMath.maxUnsigned(a, b)));\n+                    toBits(v.rOp(UMIN_VALUE, m, (i, a, b) -> (short) VectorMath.maxUnsigned(a, b)));\n@@ -2894,0 +2894,2 @@\n+    private static final short UMIN_VALUE = (short)0;   \/\/ Minimum unsigned value\n+    private static final short UMAX_VALUE = (short)-1;  \/\/ Maximum unsigned value\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -3451,1 +3451,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) VectorMath.minUnsigned(a, b)));\n+                    toBits(v.rOp(UMAX_VALUE, m, (i, a, b) -> ($type$) VectorMath.minUnsigned(a, b)));\n@@ -3453,1 +3453,1 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) VectorMath.maxUnsigned(a, b)));\n+                    toBits(v.rOp(UMIN_VALUE, m, (i, a, b) -> ($type$) VectorMath.maxUnsigned(a, b)));\n@@ -3475,0 +3475,2 @@\n+    private static final $type$ UMIN_VALUE = ($type$)0;   \/\/ Minimum unsigned value\n+    private static final $type$ UMAX_VALUE = ($type$)-1;  \/\/ Maximum unsigned value\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,7 @@\n-        modificationMap.put(name + signature, new Method(methodId, Modification.valueOf(modification), className + \"::\" + name));\n+        Method method = new Method(\n+            methodId,\n+            Modification.valueOf(modification),\n+            name.equals(\"<init>\"),\n+            className + \"::\" + name\n+        );\n+        modificationMap.put(name + signature, method);\n@@ -74,1 +80,1 @@\n-                if (modifyClassElement(classBuilder, ce)) {\n+                if (modifyClassElement(classModel, classBuilder, ce)) {\n@@ -96,1 +102,1 @@\n-    private boolean modifyClassElement(ClassBuilder classBuilder, ClassElement ce) {\n+    private boolean modifyClassElement(ClassModel classModel, ClassBuilder classBuilder, ClassElement ce) {\n@@ -105,1 +111,1 @@\n-                    return modifyMethod(classBuilder, mm, tm);\n+                    return modifyMethod(classModel, classBuilder, mm, tm);\n@@ -112,2 +118,2 @@\n-    private boolean modifyMethod(ClassBuilder classBuilder, MethodModel m, Method method) {\n-        var code = m.code();\n+    private boolean modifyMethod(ClassModel classModel, ClassBuilder classBuilder, MethodModel methodModel, Method method) {\n+        var code = methodModel.code();\n@@ -121,1 +127,1 @@\n-                () -> MethodTransform.transformingCode(new Transform(method))\n+                () -> MethodTransform.transformingCode(new Transform(classModel, code.get(), method))\n@@ -123,1 +129,1 @@\n-            classBuilder.transformMethod(m, s);\n+            classBuilder.transformMethod(methodModel, s);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Instrumentation.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-record Method(long methodId, Modification modification, String name) {\n+record Method(long methodId, Modification modification, boolean constructor, String name) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Method.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.CodeModel;\n@@ -30,0 +32,1 @@\n+import java.lang.classfile.Label;\n@@ -31,0 +34,1 @@\n+import java.lang.classfile.instruction.InvokeInstruction;\n@@ -34,0 +38,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -46,0 +52,4 @@\n+    private static class TryBlock {\n+        Label start;\n+        Label end;\n+    }\n@@ -52,0 +62,3 @@\n+    private final List<TryBlock> tryBlocks = new ArrayList<>();\n+    private final boolean simplifiedInstrumentation;\n+    private final ClassModel classModel;\n@@ -55,1 +68,1 @@\n-    Transform(Method method) {\n+    Transform(ClassModel classModel, CodeModel model, Method method) {\n@@ -57,0 +70,60 @@\n+        this.classModel = classModel;\n+        \/\/ The JVMS (not the JLS) allows multiple mutually exclusive super\/this.<init>\n+        \/\/ invocations in a constructor body as long as only one lies on any given\n+        \/\/ execution path. For example, this is valid bytecode:\n+        \/\/\n+        \/\/ Foo(boolean value) {\n+        \/\/   if (value) {\n+        \/\/     staticMethodThatMayThrow();\n+        \/\/     super();\n+        \/\/   } else {\n+        \/\/     try {\n+        \/\/       if (value == 0) {\n+        \/\/         throw new Exception(\"\");\n+        \/\/       }\n+        \/\/     } catch (Throwable t) {\n+        \/\/       throw t;\n+        \/\/     }\n+        \/\/     super();\n+        \/\/   }\n+        \/\/ }\n+        \/\/\n+        \/\/ If such a method is found, instrumentation falls back to instrumenting only\n+        \/\/ RET and ATHROW. This can cause exceptions to be missed or counted twice.\n+        \/\/\n+        \/\/ An effect of this heuristic is that constructors like the one below\n+        \/\/ will also trigger simplified instrumentation.\n+        \/\/\n+        \/\/ class Bar {\n+        \/\/ }\n+        \/\/\n+        \/\/ class Foo extends Bar {\n+        \/\/   Foo() {\n+        \/\/     new Bar();\n+        \/\/   }\n+        \/\/ }\n+        \/\/\n+        \/\/ java.lang.Object::<init> with zero constructor invocations should use simplified instrumentation\n+        this.simplifiedInstrumentation = method.constructor() && constructorInvocations(model.elementList()) != 1;\n+    }\n+\n+    private int constructorInvocations(List<CodeElement> elementList) {\n+        int count = 0;\n+        for (CodeElement e : elementList) {\n+            if (isConstructorInvocation(e)) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private boolean isConstructorInvocation(CodeElement element) {\n+        if (element instanceof InvokeInstruction inv && inv.name().equalsString(\"<init>\")) {\n+            if (classModel.thisClass().equals(inv.owner())) {\n+                return true;\n+            }\n+            if (classModel.superclass().isPresent()) {\n+                return classModel.superclass().get().equals(inv.owner());\n+            }\n+        }\n+        return false;\n@@ -60,1 +133,57 @@\n-    public final void accept(CodeBuilder builder, CodeElement element) {\n+    public void accept(CodeBuilder builder, CodeElement element) {\n+        if (simplifiedInstrumentation) {\n+            acceptSimplifiedInstrumentation(builder, element);\n+            return;\n+        }\n+        if (method.constructor()) {\n+            acceptConstructor(builder, element, isConstructorInvocation(element));\n+        } else {\n+            acceptMethod(builder, element);\n+        }\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder builder) {\n+        endTryBlock(builder);\n+        for (TryBlock block : tryBlocks) {\n+            addCatchHandler(block, builder);\n+        }\n+    }\n+\n+    private void acceptConstructor(CodeBuilder builder, CodeElement element, boolean isConstructorInvocation) {\n+        if (timestampSlot == -1) {\n+            timestampSlot = invokeTimestamp(builder);\n+            builder.lstore(timestampSlot);\n+            if (!isConstructorInvocation) {\n+                beginTryBlock(builder);\n+            }\n+        }\n+        if (isConstructorInvocation) {\n+            endTryBlock(builder);\n+            builder.with(element);\n+            beginTryBlock(builder);\n+            return;\n+        }\n+        if (element instanceof ReturnInstruction) {\n+            addTracing(builder);\n+        }\n+        builder.with(element);\n+    }\n+\n+    private void endTryBlock(CodeBuilder builder) {\n+        if (tryBlocks.isEmpty()) {\n+            return;\n+        }\n+        TryBlock last = tryBlocks.getLast();\n+        if (last.end == null) {\n+            last.end = builder.newBoundLabel();\n+        }\n+    }\n+\n+    private void beginTryBlock(CodeBuilder builder) {\n+        TryBlock block = new TryBlock();\n+        block.start = builder.newBoundLabel();\n+        tryBlocks.add(block);\n+    }\n+\n+    private void acceptSimplifiedInstrumentation(CodeBuilder builder, CodeElement element) {\n@@ -66,11 +195,36 @@\n-            builder.lload(timestampSlot);\n-            builder.ldc(method.methodId());\n-            Modification modification = method.modification();\n-            boolean objectInit = method.name().equals(\"java.lang.Object::<init>\");\n-            String suffix = objectInit ? \"ObjectInit\" : \"\";\n-            if (modification.timing()) {\n-                if (modification.tracing()) {\n-                    invokeTraceTiming(builder, suffix);\n-                } else {\n-                    invokeTiming(builder, suffix);\n-                }\n+            addTracing(builder);\n+        }\n+        builder.with(element);\n+    }\n+\n+    private void acceptMethod(CodeBuilder builder, CodeElement element) {\n+        if (timestampSlot == -1) {\n+            timestampSlot = invokeTimestamp(builder);\n+            builder.lstore(timestampSlot);\n+            beginTryBlock(builder);\n+        }\n+        if (element instanceof ReturnInstruction) {\n+            addTracing(builder);\n+        }\n+        builder.with(element);\n+    }\n+\n+    private void addCatchHandler(TryBlock block, CodeBuilder builder) {\n+        Label catchHandler = builder.newBoundLabel();\n+        int exceptionSlot = builder.allocateLocal(TypeKind.REFERENCE);\n+        builder.astore(exceptionSlot);\n+        addTracing(builder);\n+        builder.aload(exceptionSlot);\n+        builder.athrow();\n+        builder.exceptionCatchAll(block.start, block.end, catchHandler);\n+    }\n+\n+    private void addTracing(CodeBuilder builder) {\n+        builder.lload(timestampSlot);\n+        builder.ldc(method.methodId());\n+        Modification modification = method.modification();\n+        boolean objectInit = method.name().equals(\"java.lang.Object::<init>\");\n+        String suffix = objectInit ? \"ObjectInit\" : \"\";\n+        if (modification.timing()) {\n+            if (modification.tracing()) {\n+                invokeTraceTiming(builder, suffix);\n@@ -78,3 +232,5 @@\n-                if (modification.tracing()) {\n-                    invokeTrace(builder, suffix);\n-                }\n+                invokeTiming(builder, suffix);\n+            }\n+        } else {\n+            if (modification.tracing()) {\n+                invokeTrace(builder, suffix);\n@@ -83,1 +239,0 @@\n-        builder.with(element);\n@@ -86,1 +241,1 @@\n-    public static void invokeTiming(CodeBuilder builder, String suffix) {\n+    private static void invokeTiming(CodeBuilder builder, String suffix) {\n@@ -90,1 +245,1 @@\n-    public static void invokeTrace(CodeBuilder builder, String suffix) {\n+    private static void invokeTrace(CodeBuilder builder, String suffix) {\n@@ -94,1 +249,1 @@\n-    public static void invokeTraceTiming(CodeBuilder builder, String suffix) {\n+    private static void invokeTraceTiming(CodeBuilder builder, String suffix) {\n@@ -98,1 +253,1 @@\n-    public static int invokeTimestamp(CodeBuilder builder) {\n+    private static int invokeTimestamp(CodeBuilder builder) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Transform.java","additions":176,"deletions":21,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+\n@@ -185,0 +186,1 @@\n+\n","filename":"src\/jdk.jlink\/share\/man\/jlink.md","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+import jdk.jpackage.internal.util.Enquoter;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -32,1 +31,0 @@\n-import java.util.Objects;\n@@ -34,2 +32,0 @@\n-import java.util.Set;\n-import java.util.ArrayList;\n@@ -37,0 +33,3 @@\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n@@ -51,3 +50,0 @@\n-    public LibProvidersLookup() {\n-    }\n-\n@@ -90,10 +86,1 @@\n-        List<Path> result = new ArrayList<>();\n-        int ret = Executor.of(TOOL_LDD, path.toString()).setOutputConsumer(lines -> {\n-            lines.map(line -> {\n-                Matcher matcher = LIB_IN_LDD_OUTPUT_REGEX.matcher(line);\n-                if (matcher.find()) {\n-                    return matcher.group(1);\n-                }\n-                return null;\n-            }).filter(Objects::nonNull).map(Path::of).forEach(result::add);\n-        }).execute();\n+        final var result = Executor.of(TOOL_LDD, path.toString()).saveOutput().execute();\n@@ -101,1 +88,1 @@\n-        if (ret != 0) {\n+        if (result.getExitCode() != 0) {\n@@ -106,1 +93,7 @@\n-        return result;\n+        return result.stdout().stream().map(line -> {\n+            Matcher matcher = LIB_IN_LDD_OUTPUT_REGEX.matcher(line);\n+            if (matcher.find()) {\n+                return matcher.group(1);\n+            }\n+            return null;\n+        }).filter(Objects::nonNull).map(Path::of).toList();\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LibProvidersLookup.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.function.Supplier;\n@@ -47,7 +48,22 @@\n-        super(build()\n-                .defaultOperation(() -> {\n-                    return LazyLoad.SYS_ENV.value().map(LinuxSystemEnvironment::nativePackageType).map(DESCRIPTORS::get);\n-                })\n-                .bundler(CREATE_LINUX_APP_IMAGE, LinuxBundlingEnvironment::createAppImage)\n-                .bundler(CREATE_LINUX_DEB, LazyLoad::debSysEnv, LinuxBundlingEnvironment::createDebPackage)\n-                .bundler(CREATE_LINUX_RPM, LazyLoad::rpmSysEnv, LinuxBundlingEnvironment::createRpmPackage));\n+        super(build().mutate(builder -> {\n+\n+            \/\/ Wrap the generic Linux system environment supplier in the run-once wrapper\n+            \/\/ as this supplier is called from both RPM and DEB Linux system environment suppliers.\n+            var sysEnv = runOnce(() -> {\n+                return LinuxSystemEnvironment.create();\n+            });\n+\n+            Supplier<Result<LinuxDebSystemEnvironment>> debSysEnv = () -> {\n+                return LinuxDebSystemEnvironment.create(sysEnv.get());\n+            };\n+\n+            Supplier<Result<LinuxRpmSystemEnvironment>> rpmSysEnv = () -> {\n+                return LinuxRpmSystemEnvironment.create(sysEnv.get());\n+            };\n+\n+            builder.defaultOperation(() -> {\n+                return sysEnv.get().value().map(LinuxSystemEnvironment::nativePackageType).map(DESCRIPTORS::get);\n+            })\n+            .bundler(CREATE_LINUX_DEB, debSysEnv, LinuxBundlingEnvironment::createDebPackage)\n+            .bundler(CREATE_LINUX_RPM, rpmSysEnv, LinuxBundlingEnvironment::createRpmPackage);\n+        }).bundler(CREATE_LINUX_APP_IMAGE, LinuxBundlingEnvironment::createAppImage));\n@@ -59,1 +75,1 @@\n-                LinuxFromOptions.createLinuxDebPackage(options),\n+                LinuxFromOptions.createLinuxDebPackage(options, sysEnv),\n@@ -70,1 +86,1 @@\n-                LinuxFromOptions.createLinuxRpmPackage(options),\n+                LinuxFromOptions.createLinuxRpmPackage(options, sysEnv),\n@@ -93,17 +109,0 @@\n-    private static final class LazyLoad {\n-\n-        static Result<LinuxDebSystemEnvironment> debSysEnv() {\n-            return DEB_SYS_ENV;\n-        }\n-\n-        static Result<LinuxRpmSystemEnvironment> rpmSysEnv() {\n-            return RPM_SYS_ENV;\n-        }\n-\n-        private static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n-\n-        private static final Result<LinuxDebSystemEnvironment> DEB_SYS_ENV = LinuxDebSystemEnvironment.create(SYS_ENV);\n-\n-        private static final Result<LinuxRpmSystemEnvironment> RPM_SYS_ENV = LinuxRpmSystemEnvironment.create(SYS_ENV);\n-    }\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxBundlingEnvironment.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n@@ -79,1 +78,1 @@\n-                return findProvidingPackages(realPath, sysEnv.dpkg());\n+                return findProvidingPackages(realPath, sysEnv);\n@@ -83,1 +82,1 @@\n-                    return findProvidingPackages(file, sysEnv.dpkg());\n+                    return findProvidingPackages(file, sysEnv);\n@@ -110,1 +109,1 @@\n-        Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n+        Map<String, String> actualValues = Executor.of(cmdline)\n@@ -151,2 +150,0 @@\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", debFile.toAbsolutePath()));\n-\n@@ -161,5 +158,2 @@\n-        RetryExecutor.retryOnKnownErrorMessage(\n-                \"semop(1): encountered an error: Invalid argument\").execute(\n-                        cmdline.toArray(String[]::new));\n-\n-        Log.verbose(I18N.format(\"message.output-to-location\", debFile.toAbsolutePath()));\n+        Executor.of(cmdline).retryOnKnownErrorMessage(\n+                \"semop(1): encountered an error: Invalid argument\").execute();\n@@ -236,1 +230,1 @@\n-    private static Stream<String> findProvidingPackages(Path file, Path dpkg) throws IOException {\n+    private static Stream<String> findProvidingPackages(Path file, LinuxDebSystemEnvironment sysEnv) throws IOException {\n@@ -282,1 +276,1 @@\n-        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n+        var debArch = sysEnv.packageArch().value();\n@@ -284,1 +278,1 @@\n-        Executor.of(dpkg.toString(), \"-S\", file.toString())\n+        Executor.of(sysEnv.dpkg().toString(), \"-S\", file.toString())\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebPackager.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public interface LinuxDebSystemEnvironment extends LinuxSystemEnvironment, LinuxDebSystemEnvironmentMixin {\n+interface LinuxDebSystemEnvironment extends LinuxSystemEnvironment, LinuxDebSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-public interface LinuxDebSystemEnvironmentMixin {\n+interface LinuxDebSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironmentMixin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    static LinuxRpmPackage createLinuxRpmPackage(Options options) {\n+    static LinuxRpmPackage createLinuxRpmPackage(Options options, LinuxRpmSystemEnvironment sysEnv) {\n@@ -75,1 +75,1 @@\n-        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_RPM);\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, sysEnv, LINUX_RPM);\n@@ -84,1 +84,1 @@\n-    static LinuxDebPackage createLinuxDebPackage(Options options) {\n+    static LinuxDebPackage createLinuxDebPackage(Options options, LinuxDebSystemEnvironment sysEnv) {\n@@ -86,1 +86,1 @@\n-        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_DEB);\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, sysEnv, LINUX_DEB);\n@@ -102,1 +102,1 @@\n-    private static LinuxPackageBuilder createLinuxPackageBuilder(Options options, StandardPackageType type) {\n+    private static LinuxPackageBuilder createLinuxPackageBuilder(Options options, LinuxSystemEnvironment sysEnv, StandardPackageType type) {\n@@ -110,0 +110,2 @@\n+        pkgBuilder.arch(sysEnv.packageArch());\n+\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromOptions.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.jpackage.internal.util.Enquoter;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxLaunchersAsServices.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import java.util.ArrayList;\n@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+import jdk.jpackage.internal.util.Result;\n@@ -31,1 +33,1 @@\n-final class LinuxPackageArch {\n+record LinuxPackageArch(String value) {\n@@ -33,1 +35,1 @@\n-    static String getValue(StandardPackageType pkgType) {\n+    static Result<LinuxPackageArch> create(StandardPackageType pkgType) {\n@@ -36,1 +38,1 @@\n-                return RpmPackageArch.VALUE;\n+                return rpm().map(LinuxPackageArch::new);\n@@ -39,1 +41,1 @@\n-                return DebPackageArch.VALUE;\n+                return deb().map(LinuxPackageArch::new);\n@@ -47,8 +49,4 @@\n-    private static class DebPackageArch {\n-\n-        static final String VALUE = toSupplier(DebPackageArch::getValue).get();\n-\n-        private static String getValue() throws IOException {\n-            return Executor.of(\"dpkg\", \"--print-architecture\").saveOutput(true)\n-                    .executeExpectSuccess().getOutput().get(0);\n-        }\n+    private static Result<String> deb() {\n+        var exec = Executor.of(\"dpkg\", \"--print-architecture\").saveOutput(true);\n+        return Result.of(exec::executeExpectSuccess, IOException.class)\n+                .flatMap(LinuxPackageArch::getStdoutFirstLine);\n@@ -57,1 +55,10 @@\n-    private static class RpmPackageArch {\n+    private static Result<String> rpm() {\n+        var errors = new ArrayList<Exception>();\n+        for (var tool : RpmArchReader.values()) {\n+            var result = tool.getRpmArch();\n+            if (result.hasValue()) {\n+                return result;\n+            } else {\n+                errors.addAll(result.errors());\n+            }\n+        }\n@@ -59,8 +66,2 @@\n-        \/*\n-         * Various ways to get rpm arch. Needed to address JDK-8233143. rpmbuild is mandatory for\n-         * rpm packaging, try it first. rpm is optional and may not be available, use as the last\n-         * resort.\n-         *\/\n-        private static enum RpmArchReader {\n-            Rpmbuild(\"rpmbuild\", \"--eval=%{_target_cpu}\"),\n-            Rpm(\"rpm\", \"--eval=%{_target_cpu}\");\n+        return Result.ofErrors(errors);\n+    }\n@@ -68,3 +69,8 @@\n-            RpmArchReader(String... cmdline) {\n-                this.cmdline = cmdline;\n-            }\n+    \/*\n+     * Various ways to get rpm arch. Needed to address JDK-8233143. rpmbuild is mandatory for\n+     * rpm packaging, try it first. rpm is optional and may not be available, use as the last\n+     * resort.\n+     *\/\n+    private enum RpmArchReader {\n+        RPMBUILD(\"rpmbuild\", \"--eval=%{_target_cpu}\"),\n+        RPM(\"rpm\", \"--eval=%{_target_cpu}\");\n@@ -72,17 +78,3 @@\n-            String getRpmArch() throws IOException {\n-                Executor exec = Executor.of(cmdline).saveOutput(true);\n-                switch (this) {\n-                    case Rpm -> {\n-                        exec.executeExpectSuccess();\n-                    }\n-                    case Rpmbuild -> {\n-                        if (exec.execute() != 0) {\n-                            return null;\n-                        }\n-                    }\n-                    default -> {\n-                        throw new UnsupportedOperationException();\n-                    }\n-                }\n-                return exec.getOutput().get(0);\n-            }\n+        RpmArchReader(String... cmdline) {\n+            this.cmdline = cmdline;\n+        }\n@@ -90,1 +82,4 @@\n-            private final String[] cmdline;\n+        Result<String> getRpmArch() {\n+            var exec = Executor.of(cmdline).saveOutput(true);\n+            return Result.of(exec::executeExpectSuccess, IOException.class)\n+                    .flatMap(LinuxPackageArch::getStdoutFirstLine);\n@@ -93,1 +88,2 @@\n-        static final String VALUE = toSupplier(RpmPackageArch::getValue).get();\n+        private final String[] cmdline;\n+    }\n@@ -95,9 +91,4 @@\n-        private static String getValue() throws IOException {\n-            for (var rpmArchReader : RpmArchReader.values()) {\n-                var rpmArchStr = rpmArchReader.getRpmArch();\n-                if (rpmArchStr != null) {\n-                    return rpmArchStr;\n-                }\n-            }\n-            throw new RuntimeException(\"error.rpm-arch-not-detected\");\n-        }\n+    private static Result<String> getStdoutFirstLine(CommandOutputControl.Result result) {\n+        return Result.of(() -> {\n+            return result.stdout().stream().findFirst().orElseThrow(result::unexpected);\n+        }, IOException.class);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageArch.java","additions":45,"deletions":54,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-                pkg.asStandardPackageType().map(LinuxPackageArch::getValue).orElseThrow()));\n+                arch.value()));\n@@ -122,0 +122,5 @@\n+    LinuxPackageBuilder arch(LinuxPackageArch v) {\n+        arch = v;\n+        return this;\n+    }\n+\n@@ -187,0 +192,1 @@\n+    private LinuxPackageArch arch;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,0 @@\n-        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n-\n@@ -150,2 +148,0 @@\n-\n-        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmPackager.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-public interface LinuxRpmSystemEnvironment extends LinuxSystemEnvironment, LinuxRpmSystemEnvironmentMixin {\n+interface LinuxRpmSystemEnvironment extends LinuxSystemEnvironment, LinuxRpmSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-public interface LinuxRpmSystemEnvironmentMixin {\n+interface LinuxRpmSystemEnvironmentMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironmentMixin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Objects;\n@@ -38,1 +37,1 @@\n-public interface LinuxSystemEnvironment extends SystemEnvironment {\n+interface LinuxSystemEnvironment extends SystemEnvironment {\n@@ -41,0 +40,1 @@\n+    LinuxPackageArch packageArch();\n@@ -48,1 +48,1 @@\n-    static Optional<PackageType> detectNativePackageType() {\n+    static Optional<StandardPackageType> detectNativePackageType() {\n@@ -58,3 +58,4 @@\n-    static Result<LinuxSystemEnvironment> create(PackageType nativePackageType) {\n-        return Result.ofValue(new Stub(LibProvidersLookup.supported(),\n-                Objects.requireNonNull(nativePackageType)));\n+    static Result<LinuxSystemEnvironment> create(StandardPackageType nativePackageType) {\n+        return LinuxPackageArch.create(nativePackageType).map(arch -> {\n+            return new Stub(LibProvidersLookup.supported(), nativePackageType, arch);\n+        });\n@@ -64,1 +65,1 @@\n-        return CompositeProxy.create(type, base, mixin);\n+        return CompositeProxy.build().invokeTunnel(CompositeProxyTunnel.INSTANCE).create(type, base, mixin);\n@@ -82,1 +83,1 @@\n-    record Stub(boolean soLookupAvailable, PackageType nativePackageType) implements LinuxSystemEnvironment {\n+    record Stub(boolean soLookupAvailable, PackageType nativePackageType, LinuxPackageArch packageArch) implements LinuxSystemEnvironment {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxSystemEnvironment.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,0 @@\n-message.outputting-to-location=Generating DEB for installer to: {0}.\n-message.output-to-location=Package (.deb) saved to: {0}.\n@@ -55,2 +53,0 @@\n-message.outputting-bundle-location=Generating RPM for installer to: {0}.\n-message.output-bundle-location=Package (.rpm) saved to: {0}.\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/LinuxResources.properties","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import static jdk.jpackage.internal.util.XmlUtils.initDocumentBuilder;\n-\n@@ -53,1 +51,1 @@\n-        final var plistReader = new PListReader(initDocumentBuilder().parse(Files.newInputStream(infoPListFile)));\n+        final var plistReader = new PListReader(Files.readAllBytes(infoPListFile));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageInfoPListFile.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -51,0 +52,1 @@\n+import jdk.jpackage.internal.util.Result;\n@@ -191,5 +193,3 @@\n-        try {\n-            return Executor.of(\"\/usr\/bin\/xcrun\", \"--help\").setQuiet(true).execute() == 0;\n-        } catch (IOException ex) {\n-            return false;\n-        }\n+        return Result.of(\n+                Executor.of(\"\/usr\/bin\/xcrun\", \"--help\").setQuiet(true)::executeExpectSuccess,\n+                IOException.class).hasValue();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -97,4 +96,1 @@\n-        var exec = Executor.of(Stream.concat(\n-                cmdline.stream(),\n-                Stream.of(path.toString())).toArray(String[]::new)\n-        ).saveOutput(true);\n+        var exec = Executor.of(cmdline).args(path.toString()).saveOutput(true);\n@@ -103,2 +99,3 @@\n-        if (exec.execute() != 0) {\n-            throw new CodesignException(exec.getOutput().toArray(String[]::new));\n+        var result = exec.execute();\n+        if (result.getExitCode() != 0) {\n+            throw new CodesignException(result.getOutput().toArray(String[]::new));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/Codesign.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-\n-\/**\n- * An abstraction of macOS Application bundle.\n- *\n- * @see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles\">https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles<\/a>\n- *\/\n-record MacBundle(Path root) {\n-\n-    MacBundle {\n-        Objects.requireNonNull(root);\n-    }\n-\n-    boolean isValid() {\n-        return Files.isDirectory(contentsDir()) && Files.isDirectory(macOsDir()) && Files.isRegularFile(infoPlistFile());\n-    }\n-\n-    boolean isSigned() {\n-        return Files.isDirectory(contentsDir().resolve(\"_CodeSignature\"));\n-    }\n-\n-    Path contentsDir() {\n-        return root.resolve(\"Contents\");\n-    }\n-\n-    Path homeDir() {\n-        return contentsDir().resolve(\"Home\");\n-    }\n-\n-    Path macOsDir() {\n-        return contentsDir().resolve(\"MacOS\");\n-    }\n-\n-    Path resourcesDir() {\n-        return contentsDir().resolve(\"Resources\");\n-    }\n-\n-    Path infoPlistFile() {\n-        return contentsDir().resolve(\"Info.plist\");\n-    }\n-\n-    static Optional<MacBundle> fromPath(Path path) {\n-        var bundle = new MacBundle(path);\n-        if (bundle.isValid()) {\n-            return Optional.of(bundle);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    static Optional<MacBundle> fromAppImageLayout(AppImageLayout layout) {\n-        final var root = layout.rootDirectory();\n-        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n-        final var contentsDirname = Path.of(\"Contents\");\n-        var bundleRoot = root;\n-        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n-            var nameComponent = bundleSubdir.getName(i);\n-            if (contentsDirname.equals(nameComponent)) {\n-                return Optional.of(new MacBundle(bundleRoot));\n-            } else {\n-                bundleRoot = bundleRoot.resolve(nameComponent);\n-            }\n-        }\n-        return Optional.empty();\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundle.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.jpackage.internal.util.Result;\n@@ -48,1 +47,1 @@\n-                .bundler(CREATE_MAC_DMG, LazyLoad::dmgSysEnv, MacBundlingEnvironment::createDmdPackage)\n+                .bundler(CREATE_MAC_DMG, MacDmgSystemEnvironment::create, MacBundlingEnvironment::createDmdPackage)\n@@ -58,1 +57,0 @@\n-                    Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n@@ -68,4 +66,1 @@\n-                (env, pkg, outputDir) -> {\n-                    Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n-                    return new MacPkgPackager(env, pkg, outputDir);\n-                });\n+                MacPkgPackager::new);\n@@ -101,9 +96,0 @@\n-\n-    private static final class LazyLoad {\n-\n-        static Result<MacDmgSystemEnvironment> dmgSysEnv() {\n-            return DMG_SYS_ENV;\n-        }\n-\n-        private static final Result<MacDmgSystemEnvironment> DMG_SYS_ENV = MacDmgSystemEnvironment.create();\n-    }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundlingEnvironment.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-            final var output = Executor.of(args.toArray(String[]::new))\n+            final var output = Executor.of(args)\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacCertificateUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+\n+final class MacDmgLicense {\n+\n+    public static void prepareLicensePListFile(Path licenseFile, Path licensePListFile)\n+            throws IOException {\n+        byte[] licenseContentOriginal =\n+                Files.readAllBytes(licenseFile);\n+        String licenseInBase64 =\n+                Base64.getEncoder().encodeToString(licenseContentOriginal);\n+\n+        Map<String, String> data = new HashMap<>();\n+        data.put(\"APPLICATION_LICENSE_TEXT\", licenseInBase64);\n+        data.put(\"STR_DATA_ENGLISH\",\n+                getSTRData(\"English\", Locale.ENGLISH, \"MacRoman\"));\n+        data.put(\"STR_DATA_GERMAN\",\n+                getSTRData(\"German\", Locale.GERMAN, \"MacRoman\"));\n+        data.put(\"STR_DATA_JAPANESE\",\n+                getSTRData(\"Japanese\", Locale.JAPANESE, \"Shift_JIS\"));\n+        data.put(\"STR_DATA_SIMPLIFIED_CHINESE\",\n+                getSTRData(\"Simplified Chinese\", Locale.SIMPLIFIED_CHINESE, \"GB2312\"));\n+\n+        new OverridableResource(DEFAULT_LICENSE_PLIST, ResourceLocator.class)\n+                .setCategory(I18N.getString(\"resource.license-setup\"))\n+                .setSubstitutionData(data)\n+                .saveToFile(licensePListFile);\n+    }\n+\n+    private static void writeSTRDataString(ByteArrayOutputStream bos,\n+                String str, String charset) {\n+        byte [] bytes = str.getBytes(Charset.forName(charset));\n+        byte [] bytesLength = {(byte)bytes.length};\n+        bos.writeBytes(bytesLength);\n+        bos.writeBytes(bytes);\n+    }\n+\n+    \/\/ Returns base64 decoded STR section data.\n+    \/\/ Strings should be in following order:\n+    \/\/ Language, message.dmg.license.button.agree,\n+    \/\/ message.dmg.license.button.disagree, message.dmg.license.button.print\n+    \/\/ message.dmg.license.button.save, message.dmg.license.message\n+    \/\/ STR section data encoded:\n+    \/\/ Number of strings in the list (unsigned 16-bit integer, big endian): 6\n+    \/\/ A sequence of strings prefixed with string length (unsigned 8-bit integer)\n+    \/\/ Note: Language should not be translated.\n+    private static String getSTRData(String language, Locale locale, String charset) {\n+        ResourceBundle bundle = ResourceBundle.getBundle(\n+                \"jdk.jpackage.internal.resources.MacResources\", locale);\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+\n+        byte [] numberOfStrings = {0x00, 0x06}; \/\/ Always 6\n+        bos.writeBytes(numberOfStrings);\n+\n+        writeSTRDataString(bos, language, charset);\n+        writeSTRDataString(bos, bundle.getString(\"message.dmg.license.button.agree\"), charset);\n+        writeSTRDataString(bos, bundle.getString(\"message.dmg.license.button.disagree\"), charset);\n+        writeSTRDataString(bos, bundle.getString(\"message.dmg.license.button.print\"), charset);\n+        writeSTRDataString(bos, bundle.getString(\"message.dmg.license.button.save\"), charset);\n+        writeSTRDataString(bos, bundle.getString(\"message.dmg.license.message\"), charset);\n+\n+        return Base64.getEncoder().encodeToString(bos.toByteArray());\n+    }\n+\n+    private static final String DEFAULT_LICENSE_PLIST = \"lic_template.plist\";\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgLicense.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-import java.util.Base64;\n+import java.util.ArrayList;\n@@ -38,0 +38,1 @@\n+import java.util.List;\n@@ -40,0 +41,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -41,0 +43,1 @@\n+import java.util.function.Function;\n@@ -104,1 +107,1 @@\n-    Path licenseFile() {\n+    Path licensePListFile() {\n@@ -108,0 +111,4 @@\n+    private Path finalDmg() {\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n@@ -131,0 +138,4 @@\n+    private Executor hdiutil(String... args) {\n+        return Executor.of(sysEnv.hdiutil().toString()).args(args).storeOutputInFiles();\n+    }\n+\n@@ -166,20 +177,0 @@\n-    private void prepareLicense() throws IOException {\n-        final var licFile = pkg.licenseFile();\n-        if (licFile.isEmpty()) {\n-            return;\n-        }\n-\n-        byte[] licenseContentOriginal =\n-                Files.readAllBytes(licFile.orElseThrow());\n-        String licenseInBase64 =\n-                Base64.getEncoder().encodeToString(licenseContentOriginal);\n-\n-        Map<String, String> data = new HashMap<>();\n-        data.put(\"APPLICATION_LICENSE_TEXT\", licenseInBase64);\n-\n-        env.createResource(DEFAULT_LICENSE_PLIST)\n-                .setCategory(I18N.getString(\"resource.license-setup\"))\n-                .setSubstitutionData(data)\n-                .saveToFile(licenseFile());\n-    }\n-\n@@ -197,1 +188,3 @@\n-        prepareLicense();\n+        if (pkg.licenseFile().isPresent()) {\n+            MacDmgLicense.prepareLicensePListFile(pkg.licenseFile().get(), licensePListFile());\n+        }\n@@ -214,0 +207,4 @@\n+    private String hdiUtilVerbosityFlag() {\n+        return env.verbose() ? \"-verbose\" : \"-quiet\";\n+    }\n+\n@@ -217,4 +214,2 @@\n-        Path protoDMG = protoDmg();\n-        Path finalDMG = outputDir.resolve(pkg.packageFileNameWithSuffix());\n-\n-        Path srcFolder = env.appImageDir();\n+        final Path protoDMG = protoDmg();\n+        final Path finalDMG = finalDmg();\n@@ -222,10 +217,1 @@\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.creating-dmg-file\"), finalDMG.toAbsolutePath()));\n-\n-        try {\n-            Files.deleteIfExists(finalDMG);\n-        } catch (IOException ex) {\n-            throw new IOException(MessageFormat.format(I18N.getString(\n-                    \"message.dmg-cannot-be-overwritten\"),\n-                    finalDMG.toAbsolutePath()));\n-        }\n+        final Path srcFolder = env.appImageDir();\n@@ -236,2 +222,1 @@\n-        String hdiUtilVerbosityFlag = env.verbose() ?\n-                \"-verbose\" : \"-quiet\";\n+        final String hdiUtilVerbosityFlag = hdiUtilVerbosityFlag();\n@@ -240,9 +225,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"create\",\n-                hdiUtilVerbosityFlag,\n-                \"-srcfolder\", normalizedAbsolutePathString(srcFolder),\n-                \"-volname\", volumeName(),\n-                \"-ov\", normalizedAbsolutePathString(protoDMG),\n-                \"-fs\", \"HFS+\",\n-                \"-format\", \"UDRW\");\n@@ -250,1 +226,7 @@\n-            IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+            hdiutil(\"create\",\n+                    hdiUtilVerbosityFlag,\n+                    \"-srcfolder\", normalizedAbsolutePathString(srcFolder),\n+                    \"-volname\", volumeName(),\n+                    \"-ov\", normalizedAbsolutePathString(protoDMG),\n+                    \"-fs\", \"HFS+\",\n+                    \"-format\", \"UDRW\").executeExpectSuccess();\n@@ -263,13 +245,11 @@\n-            pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"create\",\n-                hdiUtilVerbosityFlag,\n-                \"-size\", String.valueOf(size),\n-                \"-volname\", volumeName(),\n-                \"-ov\", normalizedAbsolutePathString(protoDMG),\n-                \"-fs\", \"HFS+\");\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .setWriteOutputToFile(true)\n-                .execute(pb);\n+            hdiutil(\n+                    \"create\",\n+                    hdiUtilVerbosityFlag,\n+                    \"-size\", String.valueOf(size),\n+                    \"-volname\", volumeName(),\n+                    \"-ov\", normalizedAbsolutePathString(protoDMG),\n+                    \"-fs\", \"HFS+\"\n+            ).retry()\n+                    .setMaxAttemptsCount(10)\n+                    .setAttemptTimeout(3, TimeUnit.SECONDS)\n+                    .execute();\n@@ -278,0 +258,2 @@\n+        final Path mountedVolume = volumePath();\n+\n@@ -279,3 +261,1 @@\n-        pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"attach\",\n+        hdiutil(\"attach\",\n@@ -284,4 +264,1 @@\n-                \"-mountroot\", protoDMG.getParent().toString());\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-\n-        final Path mountedVolume = volumePath();\n+                \"-mountroot\", mountedVolume.getParent().toString()).executeExpectSuccess();\n@@ -305,3 +282,7 @@\n-                pb = new ProcessBuilder(sysEnv.osascript().toString(),\n-                        normalizedAbsolutePathString(volumeScript()));\n-                IOUtils.exec(pb, 180); \/\/ Wait 3 minutes. See JDK-8248248.\n+                Executor.of(\n+                        sysEnv.osascript().toString(),\n+                        normalizedAbsolutePathString(volumeScript())\n+                )\n+                \/\/ Wait 3 minutes. See JDK-8248248.\n+                .timeout(3, TimeUnit.MINUTES)\n+                .executeExpectSuccess();\n@@ -328,1 +309,1 @@\n-                    pb = new ProcessBuilder(\n+                    Executor.of(\n@@ -331,2 +312,2 @@\n-                            normalizedAbsolutePathString(volumeIconFile));\n-                    IOUtils.exec(pb);\n+                            normalizedAbsolutePathString(volumeIconFile)\n+                    ).executeExpectSuccess();\n@@ -335,1 +316,1 @@\n-                    pb = new ProcessBuilder(\n+                    Executor.of(\n@@ -338,2 +319,2 @@\n-                            normalizedAbsolutePathString(mountedVolume));\n-                    IOUtils.exec(pb);\n+                            normalizedAbsolutePathString(mountedVolume)\n+                    ).executeExpectSuccess();\n@@ -350,33 +331,1 @@\n-            pb = new ProcessBuilder(\n-                    sysEnv.hdiutil().toString(),\n-                    \"detach\",\n-                    hdiUtilVerbosityFlag,\n-                    normalizedAbsolutePathString(mountedVolume));\n-            \/\/ \"hdiutil detach\" might not work right away due to resource busy error, so\n-            \/\/ repeat detach several times.\n-            RetryExecutor retryExecutor = new RetryExecutor();\n-            \/\/ Image can get detach even if we got resource busy error, so stop\n-            \/\/ trying to detach it if it is no longer attached.\n-            retryExecutor.setExecutorInitializer(exec -> {\n-                if (!Files.exists(mountedVolume)) {\n-                    retryExecutor.abort();\n-                }\n-            });\n-            try {\n-                \/\/ 10 times with 6 second delays.\n-                retryExecutor.setMaxAttemptsCount(10).setAttemptTimeoutMillis(6000)\n-                        .execute(pb);\n-            } catch (IOException ex) {\n-                if (!retryExecutor.isAborted()) {\n-                    \/\/ Now force to detach if it still attached\n-                    if (Files.exists(mountedVolume)) {\n-                        pb = new ProcessBuilder(\n-                                sysEnv.hdiutil().toString(),\n-                                \"detach\",\n-                                \"-force\",\n-                                hdiUtilVerbosityFlag,\n-                                normalizedAbsolutePathString(mountedVolume));\n-                        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-                    }\n-                }\n-            }\n+            detachVolume();\n@@ -386,29 +335,1 @@\n-        pb = new ProcessBuilder(\n-                sysEnv.hdiutil().toString(),\n-                \"convert\",\n-                normalizedAbsolutePathString(protoDMG),\n-                hdiUtilVerbosityFlag,\n-                \"-format\", \"UDZO\",\n-                \"-o\", normalizedAbsolutePathString(finalDMG));\n-        try {\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .execute(pb);\n-        } catch (Exception ex) {\n-            \/\/ Convert might failed if something holds file. Try to convert copy.\n-            Path protoCopyDMG = protoCopyDmg();\n-            Files.copy(protoDMG, protoCopyDMG);\n-            try {\n-                pb = new ProcessBuilder(\n-                        sysEnv.hdiutil().toString(),\n-                        \"convert\",\n-                        normalizedAbsolutePathString(protoCopyDMG),\n-                        hdiUtilVerbosityFlag,\n-                        \"-format\", \"UDZO\",\n-                        \"-o\", normalizedAbsolutePathString(finalDMG));\n-                IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-            } finally {\n-                Files.deleteIfExists(protoCopyDMG);\n-            }\n-        }\n+        convertProtoDmg();\n@@ -418,2 +339,1 @@\n-            pb = new ProcessBuilder(\n-                    sysEnv.hdiutil().toString(),\n+            hdiutil(\n@@ -423,6 +343,5 @@\n-                    normalizedAbsolutePathString(licenseFile())\n-            );\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .execute(pb);\n+                    normalizedAbsolutePathString(licensePListFile())\n+            ).retry()\n+                    .setMaxAttemptsCount(10)\n+                    .setAttemptTimeout(3, TimeUnit.SECONDS)\n+                    .execute();\n@@ -437,0 +356,1 @@\n+    }\n@@ -438,3 +358,14 @@\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.output-to-location\"),\n-                pkg.app().name(), normalizedAbsolutePathString(finalDMG)));\n+    private void detachVolume() throws IOException {\n+        var mountedVolume = volumePath();\n+\n+        \/\/ \"hdiutil detach\" might not work right away due to resource busy error, so\n+        \/\/ repeat detach several times.\n+        Globals.instance().objectFactory().<Void, IOException>retryExecutor(IOException.class).setExecutable(context -> {\n+\n+            List<String> cmdline = new ArrayList<>();\n+            cmdline.add(\"detach\");\n+\n+            if (context.isLastAttempt()) {\n+                \/\/ The last attempt, force detach.\n+                cmdline.add(\"-force\");\n+            }\n@@ -442,0 +373,46 @@\n+            cmdline.addAll(List.of(\n+                    hdiUtilVerbosityFlag(),\n+                    normalizedAbsolutePathString(mountedVolume)\n+            ));\n+\n+            \/\/ The image can get detached even if we get a resource busy error,\n+            \/\/ so execute the detach command without checking the exit code.\n+            var result = hdiutil(cmdline.toArray(String[]::new)).execute();\n+\n+            if (result.getExitCode() == 0 || !Files.exists(mountedVolume)) {\n+                \/\/ Detached successfully!\n+                return null;\n+            } else {\n+                throw result.unexpected();\n+            }\n+        }).setMaxAttemptsCount(10).setAttemptTimeout(6, TimeUnit.SECONDS).execute();\n+    }\n+\n+    private void convertProtoDmg() throws IOException {\n+\n+        Function<Path, Executor> convert = srcDmg -> {\n+            return hdiutil(\n+                    \"convert\",\n+                    normalizedAbsolutePathString(srcDmg),\n+                    hdiUtilVerbosityFlag(),\n+                    \"-format\", \"UDZO\",\n+                    \"-o\", normalizedAbsolutePathString(finalDmg()));\n+        };\n+\n+        \/\/ Convert it to a new image.\n+        try {\n+            convert.apply(protoDmg()).retry()\n+                .setMaxAttemptsCount(10)\n+                .setAttemptTimeout(3, TimeUnit.SECONDS)\n+                .execute();\n+        } catch (IOException ex) {\n+            Log.verbose(ex);\n+            \/\/ Something holds the file, try to convert a copy.\n+            Path copyDmg = protoCopyDmg();\n+            Files.copy(protoDmg(), copyDmg);\n+            try {\n+                convert.apply(copyDmg).executeExpectSuccess();\n+            } finally {\n+                Files.deleteIfExists(copyDmg);\n+            }\n+        }\n@@ -448,2 +425,0 @@\n-\n-    private static final String DEFAULT_LICENSE_PLIST=\"lic_template.plist\";\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackager.java","additions":129,"deletions":154,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.file.Files;\n@@ -30,0 +29,1 @@\n+import java.util.List;\n@@ -32,0 +32,1 @@\n+import java.util.stream.Collectors;\n@@ -57,3 +58,9 @@\n-    private static Optional<Path> findSetFileUtility() {\n-        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n-                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n+    static Optional<Path> findSetFileUtility() {\n+        return SETFILE_KNOWN_PATHS.stream().filter(setFilePath -> {\n+            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error code\n+            return Result.of(\n+                    Executor.of(setFilePath.toString(), \"-h\").setQuiet(true)::executeExpectSuccess,\n+                    IOException.class).hasValue();\n+        }).findFirst().or(() -> {\n+            \/\/ generic find attempt\n+            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\").setQuiet(true).saveFirstLineOfOutput();\n@@ -61,29 +68,8 @@\n-        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n-        if (setFilePath.isPresent()) {\n-            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n-            \/\/ code\n-            try {\n-                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n-                    return setFilePath;\n-                }\n-            } catch (Exception ignored) {\n-                \/\/ No need for generic find attempt. We found it, but it does not work.\n-                \/\/ Probably due to missing xcode.\n-                return Optional.empty();\n-            }\n-        }\n-\n-        \/\/ generic find attempt\n-        try {\n-            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n-            final var code = executor.setQuiet(true).saveOutput(true).execute();\n-            if (code == 0 && !executor.getOutput().isEmpty()) {\n-                final var firstLine = executor.getOutput().getFirst();\n-                Path f = Path.of(firstLine);\n-                if (new ToolValidator(f).checkExistsOnly().validate() == null) {\n-                    return Optional.of(f.toAbsolutePath());\n-                }\n-            }\n-        } catch (IOException ignored) {}\n-\n-        return Optional.empty();\n+            return Result.of(executor::executeExpectSuccess, IOException.class).flatMap(execResult -> {\n+                return Result.of(() -> {\n+                    return execResult.stdout().stream().findFirst().map(Path::of).orElseThrow(execResult::unexpected);\n+                }, Exception.class);\n+            }).value().filter(v -> {\n+                return new ToolValidator(v).checkExistsOnly().validate() == null;\n+            }).map(Path::toAbsolutePath);\n+        });\n@@ -92,0 +78,5 @@\n+    static final List<Path> SETFILE_KNOWN_PATHS = Stream.of(\n+            \"\/Developer\/Tools\/SetFile\",\n+            \"\/usr\/bin\/SetFile\",\n+            \"\/Developer\/usr\/bin\/SetFile\").map(Path::of).collect(Collectors.toUnmodifiableList());\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgSystemEnvironment.java","additions":25,"deletions":34,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import static jdk.jpackage.internal.cli.StandardOption.ICON;\n@@ -35,0 +34,1 @@\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n@@ -55,0 +55,1 @@\n+import java.util.List;\n@@ -60,0 +61,1 @@\n+import jdk.jpackage.internal.cli.OptionValue;\n@@ -74,0 +76,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -279,10 +282,6 @@\n-        app.externalApp()\n-                .map(ExternalApplication::extra)\n-                .flatMap(MAC_SIGN::findIn)\n-                .ifPresent(builder::predefinedAppImageSigned);\n-\n-        PREDEFINED_RUNTIME_IMAGE.findIn(options)\n-                .map(MacBundle::new)\n-                .filter(MacBundle::isValid)\n-                .map(MacBundle::isSigned)\n-                .ifPresent(builder::predefinedAppImageSigned);\n+        for (OptionValue<Path> ov : List.of(PREDEFINED_APP_IMAGE, PREDEFINED_RUNTIME_IMAGE)) {\n+            ov.findIn(options)\n+                    .flatMap(MacBundle::fromPath)\n+                    .map(MacPackagingPipeline::isSigned)\n+                    .ifPresent(builder::predefinedAppImageSigned);\n+        }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromOptions.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,2 @@\n+import jdk.jpackage.internal.util.MacBundle;\n+import jdk.jpackage.internal.util.PListReader;\n@@ -181,3 +183,0 @@\n-                final var predefinedRuntimeBundle = Optional.of(\n-                        new MacBundle(p.predefinedAppImage().orElseThrow())).filter(MacBundle::isValid);\n-\n@@ -187,1 +186,1 @@\n-                if (predefinedRuntimeBundle.isPresent()) {\n+                if (MacBundle.fromPath(p.predefinedAppImage().orElseThrow()).isPresent()) {\n@@ -198,1 +197,1 @@\n-                if (predefinedRuntimeBundle.map(MacBundle::isSigned).orElse(false) && !((MacPackage)p).app().sign()) {\n+                if (((MacPackage)p).predefinedAppImageSigned().orElse(false) && !((MacPackage)p).app().sign()) {\n@@ -221,0 +220,5 @@\n+\n+        @Override\n+        public String label() {\n+            throw new UnsupportedOperationException();\n+        }\n@@ -282,0 +286,24 @@\n+    static boolean isSigned(MacBundle bundle) {\n+\n+        var result = toSupplier(Executor.of(\n+                \"\/usr\/sbin\/spctl\",\n+                \"-vv\",\n+                \"--raw\",\n+                \"--assess\",\n+                \"--type\", \"exec\",\n+                bundle.root().toString()).setQuiet(true).saveOutput(true).binaryOutput()::execute).get();\n+\n+        switch (result.getExitCode()) {\n+            case 0, 3 -> {\n+                \/\/ These exit codes are accompanied with valid plist xml.\n+                return toSupplier(() -> {\n+                    return new PListReader(result.byteStdout()).findValue(\"assessment:originator\").isPresent();\n+                }).get();\n+            }\n+            default -> {\n+                \/\/ Likely to be an \"a sealed resource is missing or invalid\" error.\n+                return false;\n+            }\n+        }\n+    }\n+\n@@ -289,1 +317,1 @@\n-            srcMacBundle = MacBundle.fromAppImageLayout(srcAppImage);\n+            srcMacBundle = macBundleFromAppImageLayout(srcAppImage);\n@@ -300,1 +328,1 @@\n-                        MacBundle.fromAppImageLayout(dstAppImage).orElseThrow().root(),\n+                        macBundleFromAppImageLayout(dstAppImage).orElseThrow().root(),\n@@ -418,1 +446,1 @@\n-        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n+        final var infoPlistFile = macBundleFromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n@@ -471,1 +499,1 @@\n-            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow());\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(macBundleFromAppImageLayout(env.resolvedLayout()).orElseThrow());\n@@ -553,1 +581,1 @@\n-            return MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow();\n+            return macBundleFromAppImageLayout(env.resolvedLayout()).orElseThrow();\n@@ -598,0 +626,16 @@\n+    private static Optional<MacBundle> macBundleFromAppImageLayout(AppImageLayout layout) {\n+        final var root = layout.rootDirectory();\n+        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n+        final var contentsDirname = Path.of(\"Contents\");\n+        var bundleRoot = root;\n+        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n+            var nameComponent = bundleSubdir.getName(i);\n+            if (contentsDirname.equals(nameComponent)) {\n+                return Optional.of(new MacBundle(bundleRoot));\n+            } else {\n+                bundleRoot = bundleRoot.resolve(nameComponent);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":55,"deletions":11,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.nio.file.DirectoryStream;\n@@ -60,0 +59,1 @@\n+import jdk.jpackage.internal.util.Enquoter;\n@@ -111,1 +111,1 @@\n-                IOUtils.exec(new ProcessBuilder(cmdline), false, null, true, Executor.INFINITE_TIMEOUT);\n+                Executor.of(cmdline).executeExpectSuccess();\n@@ -490,1 +490,1 @@\n-        final var pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n+        Executor.of(\"\/usr\/bin\/pkgbuild\",\n@@ -496,3 +496,1 @@\n-                normalizedAbsolutePathString(cpl));\n-\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+                normalizedAbsolutePathString(cpl)).executeExpectSuccess();\n@@ -547,2 +545,1 @@\n-        final var pb = new ProcessBuilder(commandLine);\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+        Executor.of(commandLine).executeExpectSuccess();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackager.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -33,0 +34,1 @@\n+import java.util.function.Consumer;\n@@ -34,1 +36,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n@@ -38,1 +39,2 @@\n-    static void withKeychains(ThrowingConsumer<List<Keychain>, ? extends Exception> keychainConsumer, List<Keychain> keychains) throws Exception {\n+    static void withKeychains(Consumer<List<Keychain>> keychainConsumer, List<Keychain> keychains) {\n+\n@@ -46,0 +48,2 @@\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n@@ -50,1 +54,2 @@\n-    static void withKeychain(ThrowingConsumer<Keychain, ? extends Exception> keychainConsumer, Keychain keychain) throws Exception {\n+    static void withKeychain(Consumer<Keychain> keychainConsumer, Keychain keychain) {\n+\n@@ -81,1 +86,1 @@\n-            Executor.of(args.toArray(String[]::new)).executeExpectSuccess();\n+            Executor.of(args).executeExpectSuccess();\n@@ -92,1 +97,1 @@\n-            Executor.of(restoreKeychainsCmd.toArray(String[]::new)).executeExpectSuccess();\n+            Executor.of(restoreKeychainsCmd).executeExpectSuccess();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/TempKeychain.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n@@ -99,3 +98,0 @@\n-        SIGNED(MAC_SIGNED, app -> {\n-            return Optional.of(Boolean.toString(app.sign()));\n-        }),\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacApplication.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-message.building-dmg=Building DMG package for {0}.\n@@ -62,4 +61,0 @@\n-message.creating-dmg-file=Creating DMG file: {0}.\n-message.dmg-cannot-be-overwritten=Dmg file exists [{0}] and can not be removed.\n-message.output-to-location=Result DMG installer for {0}: {1}.\n-message.building-pkg=Building PKG package for {0}.\n@@ -72,0 +67,5 @@\n+message.dmg.license.button.agree=Agree\n+message.dmg.license.button.disagree=Disagree\n+message.dmg.license.button.print=Print\n+message.dmg.license.button.save=Save...\n+message.dmg.license.message=If you agree with the terms of this license, press \"Agree\" to install the software. If you do not agree, press \"Disagree\".\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,5 @@\n+message.dmg.license.button.agree=Akzeptieren\n+message.dmg.license.button.disagree=Ablehnen\n+message.dmg.license.button.print=Drucken\n+message.dmg.license.button.save=Sichern...\n+message.dmg.license.message=Klicken Sie in Akzeptieren, wenn Sie mit den Bestimmungen des Software-Lizenzvertrags einverstanden sind. Falls nicht, bitte Ablehnen anklicken. Sie knnen die Software nur installieren, wenn Sie Akzeptieren angeklickt haben.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_de.properties","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,5 @@\n+message.dmg.license.button.agree=\n+message.dmg.license.button.disagree=\n+message.dmg.license.button.print=\n+message.dmg.license.button.save=...\n+message.dmg.license.message=\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_ja.properties","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,5 @@\n+message.dmg.license.button.agree=\n+message.dmg.license.button.disagree=\n+message.dmg.license.button.print=\n+message.dmg.license.button.save=...\n+message.dmg.license.message=\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_zh_CN.properties","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -11,1 +11,3 @@\n-\t\t\t<data>AAAAAgAAAAAAAAAAAAQAAA==<\/data>\n+\t\t\t<data>\n+\t\t\tAAAABAAAAAAAAAADAAEAAAAOAAIAAQA0AAMAAQ==\n+\t\t\t<\/data>\n@@ -24,1 +26,3 @@\n-\t\t\t<data>AAYPRW5nbGlzaCBkZWZhdWx0BUFncmVlCERpc2FncmVlBVByaW50B1NhdmUuLi56SWYgeW91IGFncmVlIHdpdGggdGhlIHRlcm1zIG9mIHRoaXMgbGljZW5zZSwgY2xpY2sgIkFncmVlIiB0byBhY2Nlc3MgdGhlIHNvZnR3YXJlLiAgSWYgeW91IGRvIG5vdCBhZ3JlZSwgcHJlc3MgIkRpc2FncmVlLiI=<\/data>\n+\t\t\t<data>\n+\t\t\tSTR_DATA_ENGLISH\n+\t\t\t<\/data>\n@@ -27,0 +31,1 @@\n+\t\t\t<!-- Note: Values if \"Name\" keys should not be localized for all languages. It is internal use only. -->\n@@ -28,1 +33,1 @@\n-\t\t\t<string>English buttons<\/string>\n+\t\t\t<string>English (United States)<\/string>\n@@ -34,1 +39,3 @@\n-\t\t\t<data>AAYHRGV1dHNjaAtBa3plcHRpZXJlbghBYmxlaG5lbgdEcnVja2VuClNpY2hlcm4uLi7nS2xpY2tlbiBTaWUgaW4g0kFremVwdGllcmVu0ywgd2VubiBTaWUgbWl0IGRlbiBCZXN0aW1tdW5nZW4gZGVzIFNvZnR3YXJlLUxpemVuenZlcnRyYWdzIGVpbnZlcnN0YW5kZW4gc2luZC4gRmFsbHMgbmljaHQsIGJpdHRlINJBYmxlaG5lbtMgYW5rbGlja2VuLiBTaWUga5pubmVuIGRpZSBTb2Z0d2FyZSBudXIgaW5zdGFsbGllcmVuLCB3ZW5uIFNpZSDSQWt6ZXB0aWVyZW7TIGFuZ2VrbGlja3QgaGFiZW4u<\/data>\n+\t\t\t<data>\n+\t\t\tSTR_DATA_GERMAN\n+\t\t\t<\/data>\n@@ -44,1 +51,3 @@\n-\t\t\t<data>AAYHRW5nbGlzaAVBZ3JlZQhEaXNhZ3JlZQVQcmludAdTYXZlLi4ue0lmIHlvdSBhZ3JlZSB3aXRoIHRoZSB0ZXJtcyBvZiB0aGlzIGxpY2Vuc2UsIHByZXNzICJBZ3JlZSIgdG8gaW5zdGFsbCB0aGUgc29mdHdhcmUuICBJZiB5b3UgZG8gbm90IGFncmVlLCBwcmVzcyAiRGlzYWdyZWUiLg==<\/data>\n+\t\t\t<data>\n+\t\t\tSTR_DATA_JAPANESE\n+\t\t\t<\/data>\n@@ -48,40 +57,0 @@\n-\t\t\t<string>English<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYHRXNwYZZvbAdBY2VwdGFyCk5vIGFjZXB0YXIISW1wcmltaXIKR3VhcmRhci4uLsBTaSBlc3SHIGRlIGFjdWVyZG8gY29uIGxvcyB0jnJtaW5vcyBkZSBlc3RhIGxpY2VuY2lhLCBwdWxzZSAiQWNlcHRhciIgcGFyYSBpbnN0YWxhciBlbCBzb2Z0d2FyZS4gRW4gZWwgc3VwdWVzdG8gZGUgcXVlIG5vIGVzdI4gZGUgYWN1ZXJkbyBjb24gbG9zIHSOcm1pbm9zIGRlIGVzdGEgbGljZW5jaWEsIHB1bHNlICJObyBhY2VwdGFyLiI=<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5003<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Spanish<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYIRnJhbo1haXMIQWNjZXB0ZXIHUmVmdXNlcghJbXByaW1lcg5FbnJlZ2lzdHJlci4uLrpTaSB2b3VzIGFjY2VwdGV6IGxlcyB0ZXJtZXMgZGUgbGEgcHKOc2VudGUgbGljZW5jZSwgY2xpcXVleiBzdXIgIkFjY2VwdGVyIiBhZmluIGQnaW5zdGFsbGVyIGxlIGxvZ2ljaWVsLiBTaSB2b3VzIG4nkHRlcyBwYXMgZCdhY2NvcmQgYXZlYyBsZXMgdGVybWVzIGRlIGxhIGxpY2VuY2UsIGNsaXF1ZXogc3VyICJSZWZ1c2VyIi4=<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5004<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>French<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYISXRhbGlhbm8HQWNjZXR0bwdSaWZpdXRvBlN0YW1wYQtSZWdpc3RyYS4uLn9TZSBhY2NldHRpIGxlIGNvbmRpemlvbmkgZGkgcXVlc3RhIGxpY2VuemEsIGZhaSBjbGljIHN1ICJBY2NldHRvIiBwZXIgaW5zdGFsbGFyZSBpbCBzb2Z0d2FyZS4gQWx0cmltZW50aSBmYWkgY2xpYyBzdSAiUmlmaXV0byIu<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5005<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Italian<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYISmFwYW5lc2UKk6+I04K1gtyCtwyTr4jTgrWC3IK5gvEIiPON\/IK3gukHlduRti4uLrSWe4Ncg3SDZ4NFg0eDQY5nl3CLlpH4jF+W8YLMj\/CMj4LJk6+I04KzguqC6Y\/qjYeCyYLNgUGDXIN0g2eDRYNHg0GC8INDg5ODWINngVuDi4K3gumCvYLfgsmBdZOviNOCtYLcgreBdoLwiZ+CtYLEgq2CvoKzgqKBQoFAk6+I04KzguqCyIKij+qNh4LJgs2BQYF1k6+I04K1gtyCuYLxgXaC8ImfgrWCxIKtgr6Cs4KigUI=<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5006<\/string>\n-\t\t\t<key>Name<\/key>\n@@ -94,51 +63,3 @@\n-\t\t\t<data>AAYKTmVkZXJsYW5kcwJKYQNOZWUFUHJpbnQJQmV3YWFyLi4upEluZGllbiB1IGFra29vcmQgZ2FhdCBtZXQgZGUgdm9vcndhYXJkZW4gdmFuIGRlemUgbGljZW50aWUsIGt1bnQgdSBvcCAnSmEnIGtsaWtrZW4gb20gZGUgcHJvZ3JhbW1hdHV1ciB0ZSBpbnN0YWxsZXJlbi4gSW5kaWVuIHUgbmlldCBha2tvb3JkIGdhYXQsIGtsaWt0IHUgb3AgJ05lZScu<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5007<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Dutch<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYGU3ZlbnNrCEdvZGuKbm5zBkF2YppqcwhTa3JpdiB1dAhTcGFyYS4uLpNPbSBEdSBnb2Rrim5uZXIgbGljZW5zdmlsbGtvcmVuIGtsaWNrYSBwjCAiR29ka4pubnMiIGaaciBhdHQgaW5zdGFsbGVyYSBwcm9ncmFtcHJvZHVrdGVuLiBPbSBEdSBpbnRlIGdvZGuKbm5lciBsaWNlbnN2aWxsa29yZW4sIGtsaWNrYSBwjCAiQXZimmpzIi4=<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5008<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Swedish<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYRUG9ydHVndZBzLCBCcmFzaWwJQ29uY29yZGFyCURpc2NvcmRhcghJbXByaW1pcglTYWx2YXIuLi6MU2UgZXN0hyBkZSBhY29yZG8gY29tIG9zIHRlcm1vcyBkZXN0YSBsaWNlbo1hLCBwcmVzc2lvbmUgIkNvbmNvcmRhciIgcGFyYSBpbnN0YWxhciBvIHNvZnR3YXJlLiBTZSBui28gZXN0hyBkZSBhY29yZG8sIHByZXNzaW9uZSAiRGlzY29yZGFyIi4=<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5009<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Brazilian Portuguese<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYSU2ltcGxpZmllZCBDaGluZXNlBM2s0uIGsrvNrNLiBLTy06EGtOa0oqGtVMjnufvE+s2s0uKxvtDtv8nQrdLptcTM9b\/uo6zH67C0obDNrNLiobHAtLCy17C0y8jtvP6ho8jnufvE+rK7zazS4qOsx+uwtKGwsrvNrNLiobGhow==<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5010<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Simplified Chinese<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYTVHJhZGl0aW9uYWwgQ2hpbmVzZQSmULdOBqSjplC3TgSmQ6ZMBsB4pnOhS1CmcKpHsXqmULdOpbuzXKVpw9K4zKq6sfi02qFBvdCr9qGnplC3TqGopUimd7jLs27F6aFDpnCqR6SjplC3TqFBvdCr9qGnpKOmULdOoaihQw==<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5011<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Traditional Chinese<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYFRGFuc2sERW5pZwVVZW5pZwdVZHNrcml2CkFya2l2ZXIuLi6YSHZpcyBkdSBhY2NlcHRlcmVyIGJldGluZ2Vsc2VybmUgaSBsaWNlbnNhZnRhbGVuLCBza2FsIGR1IGtsaWtrZSBwjCDSRW5pZ9MgZm9yIGF0IGluc3RhbGxlcmUgc29mdHdhcmVuLiBLbGlrIHCMINJVZW5pZ9MgZm9yIGF0IGFubnVsbGVyZSBpbnN0YWxsZXJpbmdlbi4=<\/data>\n+\t\t\t<data>\n+\t\t\tSTR_DATA_SIMPLIFIED_CHINESE\n+\t\t\t<\/data>\n@@ -146,41 +67,1 @@\n-\t\t\t<string>5012<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Danish<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYFU3VvbWkISHl2imtzeW4KRW4gaHl2imtzeQdUdWxvc3RhCVRhbGxlbm5hyW9IeXaKa3N5IGxpc2Vuc3Npc29waW11a3NlbiBlaGRvdCBvc29pdHRhbWFsbGEg1Uh5doprc3nVLiBKb3MgZXQgaHl2imtzeSBzb3BpbXVrc2VuIGVodG9qYSwgb3NvaXRhINVFbiBoeXaKa3N51S4=<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5013<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Finnish<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYRRnJhbo1haXMgY2FuYWRpZW4IQWNjZXB0ZXIHUmVmdXNlcghJbXByaW1lcg5FbnJlZ2lzdHJlci4uLrpTaSB2b3VzIGFjY2VwdGV6IGxlcyB0ZXJtZXMgZGUgbGEgcHKOc2VudGUgbGljZW5jZSwgY2xpcXVleiBzdXIgIkFjY2VwdGVyIiBhZmluIGQnaW5zdGFsbGVyIGxlIGxvZ2ljaWVsLiBTaSB2b3VzIG4nkHRlcyBwYXMgZCdhY2NvcmQgYXZlYyBsZXMgdGVybWVzIGRlIGxhIGxpY2VuY2UsIGNsaXF1ZXogc3VyICJSZWZ1c2VyIi4=<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5014<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>French Canadian<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYGS29yZWFuBLW\/wMcJtb\/AxyC+yMfUBsfBuLDGrgfA+sDlLi4ufrvnv+sgsOi+4LytwMcgs7u\/67+hILW\/wMfHz7jpLCAitb\/AxyIgtNzD37imILStt68gvNLHwcauv\/6+7rimILyzxKHHz73KvcO\/wC4gtb\/Ax8fPwfYgvsq0wrTZuOksICK1v8DHIL7Ix9QiILTcw9+4piC0qbijvcq9w7\/ALg==<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5015<\/string>\n-\t\t\t<key>Name<\/key>\n-\t\t\t<string>Korean<\/string>\n-\t\t<\/dict>\n-\t\t<dict>\n-\t\t\t<key>Attributes<\/key>\n-\t\t\t<string>0x0000<\/string>\n-\t\t\t<key>Data<\/key>\n-\t\t\t<data>AAYFTm9yc2sERW5pZwlJa2tlIGVuaWcIU2tyaXYgdXQKQXJraXZlci4uLqNIdmlzIERlIGVyIGVuaWcgaSBiZXN0ZW1tZWxzZW5lIGkgZGVubmUgbGlzZW5zYXZ0YWxlbiwga2xpa2tlciBEZSBwjCAiRW5pZyIta25hcHBlbiBmb3IgjCBpbnN0YWxsZXJlIHByb2dyYW12YXJlbi4gSHZpcyBEZSBpa2tlIGVyIGVuaWcsIGtsaWtrZXIgRGUgcIwgIklra2UgZW5pZyIu<\/data>\n-\t\t\t<key>ID<\/key>\n-\t\t\t<string>5016<\/string>\n+\t\t\t<string>5003<\/string>\n@@ -188,1 +69,1 @@\n-\t\t\t<string>Norwegian<\/string>\n+\t\t\t<string>Chinese (Simplified)<\/string>\n@@ -197,1 +78,3 @@\n-\t\t\t<data>APPLICATION_LICENSE_TEXT<\/data>\n+\t\t\t<data>\n+\t\t\tAPPLICATION_LICENSE_TEXT\n+\t\t\t<\/data>\n@@ -201,1 +84,1 @@\n-\t\t\t<string>English SLA<\/string>\n+\t\t\t<string>English (United States) SLA<\/string>\n@@ -203,4 +86,1 @@\n-\t<\/array>\n-\t<key>TMPL<\/key>\n-\t<array>\n-\t\t<dict>\n+\t\t\t\t<dict>\n@@ -210,1 +90,3 @@\n-\t\t\t<data>E0RlZmF1bHQgTGFuZ3VhZ2UgSUREV1JEBUNvdW50T0NOVAQqKioqTFNUQwtzeXMgbGFuZyBJRERXUkQebG9jYWwgcmVzIElEIChvZmZzZXQgZnJvbSA1MDAwRFdSRBAyLWJ5dGUgbGFuZ3VhZ2U\/RFdSRAQqKioqTFNURQ==<\/data>\n+\t\t\t<data>\n+\t\t\tAPPLICATION_LICENSE_TEXT\n+\t\t\t<\/data>\n@@ -212,1 +94,1 @@\n-\t\t\t<string>128<\/string>\n+\t\t\t<string>5001<\/string>\n@@ -214,1 +96,1 @@\n-\t\t\t<string>LPic<\/string>\n+\t\t\t<string>German SLA<\/string>\n@@ -216,3 +98,0 @@\n-\t<\/array>\n-\t<key>plst<\/key>\n-\t<array>\n@@ -221,1 +100,1 @@\n-\t\t\t<string>0x0050<\/string>\n+\t\t\t<string>0x0000<\/string>\n@@ -223,1 +102,3 @@\n-\t\t\t<data>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<\/data>\n+\t\t\t<data>\n+\t\t\tAPPLICATION_LICENSE_TEXT\n+\t\t\t<\/data>\n@@ -225,1 +106,1 @@\n-\t\t\t<string>0<\/string>\n+\t\t\t<string>5002<\/string>\n@@ -227,1 +108,1 @@\n-\t\t\t<string><\/string>\n+\t\t\t<string>Japanese SLA<\/string>\n@@ -229,3 +110,0 @@\n-\t<\/array>\n-\t<key>styl<\/key>\n-\t<array>\n@@ -236,1 +114,3 @@\n-\t\t\t<data>AAMAAAAAAAwACQAUAAAAAAAAAAAAAAAAACcADAAJABQBAAAAAAAAAAAAAAAAKgAMAAkAFAAAAAAAAAAAAAA=<\/data>\n+\t\t\t<data>\n+\t\t\tAPPLICATION_LICENSE_TEXT\n+\t\t\t<\/data>\n@@ -238,1 +118,1 @@\n-\t\t\t<string>5000<\/string>\n+\t\t\t<string>5003<\/string>\n@@ -240,1 +120,1 @@\n-\t\t\t<string>English SLA<\/string>\n+\t\t\t<string>Chinese (Simplified) SLA<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/lic_template.plist","additions":40,"deletions":160,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_AS_SERVICE;\n@@ -33,0 +32,1 @@\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_AS_SERVICE;\n@@ -36,0 +36,1 @@\n+import java.io.ByteArrayInputStream;\n@@ -165,1 +166,17 @@\n-            final Document doc = XmlUtils.initDocumentBuilder().parse(Files.newInputStream(appImageFilePath));\n+            \/\/\n+            \/\/ Use javax.xml.parsers.DocumentBuilder#parse(java.io.InputStream).\n+            \/\/ Don't use javax.xml.parsers.DocumentBuilder#parse(java.io.File) as this will introduce\n+            \/\/ dependency on how the XML parser reports filesystem I\/O errors.\n+            \/\/ E.g.: the default JDK XML parser throws java.io.FileNotFoundException if the supplied\n+            \/\/ directory is not found and throws org.xml.sax.SAXParseException if the supplied file is a directory.\n+            \/\/ Another DOM XML parser (a different version of Xerces?) may behave differently.\n+            \/\/\n+            \/\/ The use of javax.xml.parsers.DocumentBuilder#parse(java.io.InputStream) eliminates\n+            \/\/ differences in how XML parsers handle file system I\/O errors.\n+            \/\/ Filesystem I\/O is delegated to java.nio.file.Files#readAllBytes(java.nio.file.Path),\n+            \/\/ XML parser deals with the byte stream in memory and the error handling code\n+            \/\/ doesn't depend on how XML parser reports filesystem I\/O errors because\n+            \/\/ it reads data from memory, not from the filesystem.\n+            \/\/\n+            final Document doc = XmlUtils.initDocumentBuilder().parse(\n+                    new ByteArrayInputStream(Files.readAllBytes(appImageFilePath)));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n@@ -49,1 +49,0 @@\n-import jdk.jpackage.internal.model.AppImagePackageType;\n@@ -54,2 +53,1 @@\n-import jdk.jpackage.internal.model.PackageType;\n-import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.PathUtils;\n@@ -68,1 +66,1 @@\n-            return new CachingSupplier<>(e.getValue());\n+            return runOnce(e.getValue());\n@@ -71,1 +69,1 @@\n-        this.defaultOperationSupplier = Objects.requireNonNull(defaultOperationSupplier).map(CachingSupplier::new);\n+        this.defaultOperationSupplier = Objects.requireNonNull(defaultOperationSupplier).map(DefaultBundlingEnvironment::runOnce);\n@@ -101,0 +99,5 @@\n+        Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n@@ -110,0 +113,4 @@\n+    static <T> Supplier<T> runOnce(Supplier<T> supplier) {\n+        return new CachingSupplier<>(supplier);\n+    }\n+\n@@ -128,1 +135,3 @@\n-        final var outputDir = OptionUtils.outputDir(options).resolve(app.appImageDirName());\n+        final var outputDir = PathUtils.normalizedAbsolutePath(OptionUtils.outputDir(options).resolve(app.appImageDirName()));\n+\n+        Log.verbose(I18N.getString(\"message.create-app-image\"));\n@@ -136,2 +145,0 @@\n-        Log.verbose(I18N.format(\"message.creating-app-bundle\", outputDir.getFileName(), outputDir.toAbsolutePath().getParent()));\n-\n@@ -139,1 +146,1 @@\n-            throw new JPackageException(I18N.format(\"error.root-exists\", outputDir.toAbsolutePath()));\n+            throw new JPackageException(I18N.format(\"error.root-exists\", outputDir));\n@@ -144,0 +151,2 @@\n+\n+        Log.verbose(I18N.getString(\"message.app-image-created\"));\n@@ -168,0 +177,9 @@\n+        var pipelineBuilder = Objects.requireNonNull(createPipelineBuilder.apply(pkg));\n+\n+        \/\/ Delete an old output package file (if any) before creating a new one.\n+        pipelineBuilder.task(PackageTaskID.DELETE_OLD_PACKAGE_FILE)\n+                .addDependencies(pipelineBuilder.taskGraphSnapshot().getTailsOf(PackageTaskID.CREATE_PACKAGE_FILE))\n+                .addDependent(PackageTaskID.CREATE_PACKAGE_FILE)\n+                .packageAction(PackagingPipeline::deleteOutputBundle)\n+                .add();\n+\n@@ -169,4 +187,4 @@\n-            .outputDir(OptionUtils.outputDir(options))\n-            .env(Objects.requireNonNull(createBuildEnv.apply(options, pkg)))\n-            .pipelineBuilderMutatorFactory(pipelineBuilderMutatorFactory)\n-            .execute(Objects.requireNonNull(createPipelineBuilder.apply(pkg)));\n+                .outputDir(OptionUtils.outputDir(options))\n+                .env(Objects.requireNonNull(createBuildEnv.apply(options, pkg)))\n+                .pipelineBuilderMutatorFactory(pipelineBuilderMutatorFactory)\n+                .execute(pipelineBuilder);\n@@ -189,4 +207,0 @@\n-\n-            var packageType = OptionUtils.bundlingOperation(cmdline).packageType();\n-\n-            Log.verbose(I18N.format(\"message.bundle-created\", I18N.getString(bundleTypeDescription(packageType, op.os()))));\n@@ -213,49 +227,0 @@\n-    private String bundleTypeDescription(PackageType type, OperatingSystem os) {\n-        switch (type) {\n-            case StandardPackageType stdType -> {\n-                switch (stdType) {\n-                    case WIN_MSI -> {\n-                        return \"bundle-type.win-msi\";\n-                    }\n-                    case WIN_EXE -> {\n-                        return \"bundle-type.win-exe\";\n-                    }\n-                    case LINUX_DEB -> {\n-                        return \"bundle-type.linux-deb\";\n-                    }\n-                    case LINUX_RPM -> {\n-                        return \"bundle-type.linux-rpm\";\n-                    }\n-                    case MAC_DMG -> {\n-                        return \"bundle-type.mac-dmg\";\n-                    }\n-                    case MAC_PKG -> {\n-                        return \"bundle-type.mac-pkg\";\n-                    }\n-                    default -> {\n-                        throw new AssertionError();\n-                    }\n-                }\n-            }\n-            case AppImagePackageType appImageType -> {\n-                switch (os) {\n-                    case WINDOWS -> {\n-                        return \"bundle-type.win-app\";\n-                    }\n-                    case LINUX -> {\n-                        return \"bundle-type.linux-app\";\n-                    }\n-                    case MACOS -> {\n-                        return \"bundle-type.mac-app\";\n-                    }\n-                    default -> {\n-                        throw new AssertionError();\n-                    }\n-                }\n-            }\n-            default -> {\n-                throw new AssertionError();\n-            }\n-        }\n-    }\n-\n@@ -282,1 +247,1 @@\n-    private final Optional<CachingSupplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier;\n+    private final Optional<Supplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DefaultBundlingEnvironment.java","additions":34,"deletions":69,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.util.Optional;\n-import java.util.function.BiConsumer;\n-import java.util.function.Predicate;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Add quotes to the given string in a configurable way.\n- *\/\n-final class Enquoter {\n-\n-    private Enquoter() {\n-        setQuoteChar('\"');\n-    }\n-\n-    static Enquoter forPropertyValues() {\n-        return new Enquoter()\n-                .setEnquotePredicate(QUOTE_IF_WHITESPACES)\n-                .setEscaper(PREPEND_BACKSLASH);\n-    }\n-\n-    static Enquoter forShellLiterals() {\n-        return forShellLiterals('\\'');\n-    }\n-\n-    static Enquoter forShellLiterals(char quoteChar) {\n-        return new Enquoter()\n-                .setQuoteChar(quoteChar)\n-                .setEnquotePredicate(x -> true)\n-                .setEscaper(PREPEND_BACKSLASH);\n-    }\n-\n-    String applyTo(String v) {\n-        if (!needQuotes.test(v)) {\n-            return v;\n-        } else {\n-            var buf = new StringBuilder();\n-            buf.appendCodePoint(beginQuoteChr);\n-            Optional.of(escaper).ifPresentOrElse(op -> {\n-                v.codePoints().forEachOrdered(chr -> {\n-                    if (chr == beginQuoteChr || chr == endQuoteChr) {\n-                        escaper.accept(chr, buf);\n-                    } else {\n-                        buf.appendCodePoint(chr);\n-                    }\n-                });\n-            }, () -> {\n-                buf.append(v);\n-            });\n-            buf.appendCodePoint(endQuoteChr);\n-            return buf.toString();\n-        }\n-    }\n-\n-    Enquoter setQuoteChar(char chr) {\n-        beginQuoteChr = chr;\n-        endQuoteChr = chr;\n-        return this;\n-    }\n-\n-    Enquoter setEscaper(BiConsumer<Integer, StringBuilder> v) {\n-        escaper = v;\n-        return this;\n-    }\n-\n-    Enquoter setEnquotePredicate(Predicate<String> v) {\n-        needQuotes = v;\n-        return this;\n-    }\n-\n-    private int beginQuoteChr;\n-    private int endQuoteChr;\n-    private BiConsumer<Integer, StringBuilder> escaper;\n-    private Predicate<String> needQuotes = str -> false;\n-\n-    private static final Predicate<String> QUOTE_IF_WHITESPACES = new Predicate<String>() {\n-        @Override\n-        public boolean test(String t) {\n-            return pattern.matcher(t).find();\n-        }\n-        private final Pattern pattern = Pattern.compile(\"\\\\s\");\n-    };\n-\n-    private static final BiConsumer<Integer, StringBuilder> PREPEND_BACKSLASH = (chr, buf) -> {\n-        buf.append('\\\\');\n-        buf.appendCodePoint(chr);\n-    };\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Enquoter.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -29,3 +30,7 @@\n-import java.io.InputStreamReader;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n+import java.io.PrintStream;\n+import java.io.StringReader;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n@@ -33,0 +38,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -34,2 +41,2 @@\n-import java.util.function.Consumer;\n-import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+import java.util.spi.ToolProvider;\n@@ -37,0 +44,7 @@\n+import jdk.jpackage.internal.model.ExecutableAttributesWithCapturedOutput;\n+import jdk.jpackage.internal.util.CommandLineFormat;\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+import jdk.jpackage.internal.util.CommandOutputControl.ProcessAttributes;\n+import jdk.jpackage.internal.util.CommandOutputControl.Result;\n+import jdk.jpackage.internal.util.RetryExecutor;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -38,1 +52,1 @@\n-public final class Executor {\n+final class Executor {\n@@ -40,1 +54,2 @@\n-    Executor() {\n+    static Executor of(String... cmdline) {\n+        return of(List.of(cmdline));\n@@ -43,3 +58,21 @@\n-    Executor setOutputConsumer(Consumer<Stream<String>> v) {\n-        outputConsumer = v;\n-        return this;\n+    static Executor of(List<String> cmdline) {\n+        return of(new ProcessBuilder(cmdline));\n+    }\n+\n+    static Executor of(ProcessBuilder pb) {\n+        return Globals.instance().objectFactory().executor().processBuilder(pb);\n+    }\n+\n+    public Executor() {\n+        commandOutputControl = new CommandOutputControl();\n+        args = new ArrayList<>();\n+    }\n+\n+    private Executor(Executor other) {\n+        commandOutputControl = other.commandOutputControl.copy();\n+        quietCommand = other.quietCommand;\n+        args = new ArrayList<>(other.args);\n+        processBuilder = other.processBuilder;\n+        toolProvider = other.toolProvider;\n+        timeout = other.timeout;\n+        mapper = other.mapper;\n@@ -49,1 +82,29 @@\n-        saveOutput = v;\n+        commandOutputControl.saveOutput(v);\n+        return this;\n+    }\n+\n+    Executor saveOutput() {\n+        return saveOutput(true);\n+    }\n+\n+    Executor saveFirstLineOfOutput() {\n+        commandOutputControl.saveFirstLineOfOutput();\n+        return this;\n+    }\n+\n+    Executor charset(Charset v) {\n+        commandOutputControl.charset(v);\n+        return this;\n+    }\n+\n+    Executor storeOutputInFiles(boolean v) {\n+        commandOutputControl.storeOutputInFiles(v);\n+        return this;\n+    }\n+\n+    Executor storeOutputInFiles() {\n+        return storeOutputInFiles(true);\n+    }\n+\n+    Executor binaryOutput(boolean v) {\n+        commandOutputControl.binaryOutput(v);\n@@ -53,2 +114,15 @@\n-    Executor setWriteOutputToFile(boolean v) {\n-        writeOutputToFile = v;\n+    Executor binaryOutput() {\n+        return binaryOutput(true);\n+    }\n+\n+    Executor discardStdout(boolean v) {\n+        commandOutputControl.discardStdout(v);\n+        return this;\n+    }\n+\n+    Executor discardStdout() {\n+        return discardStdout(true);\n+    }\n+\n+    Executor discardStderr(boolean v) {\n+        commandOutputControl.discardStderr(v);\n@@ -58,1 +132,9 @@\n-    Executor setTimeout(long v) {\n+    Executor discardStderr() {\n+        return discardStderr(true);\n+    }\n+\n+    Executor timeout(long v, TimeUnit unit) {\n+        return timeout(Duration.of(v, unit.toChronoUnit()));\n+    }\n+\n+    Executor timeout(Duration v) {\n@@ -60,5 +142,0 @@\n-        if (timeout != INFINITE_TIMEOUT) {\n-            \/\/ Redirect output to file if timeout is requested, otherwise we will\n-            \/\/ reading until process ends and timeout will never be reached.\n-            setWriteOutputToFile(true);\n-        }\n@@ -68,2 +145,3 @@\n-    Executor setProcessBuilder(ProcessBuilder v) {\n-        pb = v;\n+    Executor toolProvider(ToolProvider v) {\n+        toolProvider = Objects.requireNonNull(v);\n+        processBuilder = null;\n@@ -73,2 +151,25 @@\n-    Executor setCommandLine(String... cmdline) {\n-        return setProcessBuilder(new ProcessBuilder(cmdline));\n+    Optional<ToolProvider> toolProvider() {\n+        return Optional.ofNullable(toolProvider);\n+    }\n+\n+    Executor processBuilder(ProcessBuilder v) {\n+        processBuilder = Objects.requireNonNull(v);\n+        toolProvider = null;\n+        return this;\n+    }\n+\n+    Optional<ProcessBuilder> processBuilder() {\n+        return Optional.ofNullable(processBuilder);\n+    }\n+\n+    Executor args(List<String> v) {\n+        args.addAll(v);\n+        return this;\n+    }\n+\n+    Executor args(String... args) {\n+        return args(List.of(args));\n+    }\n+\n+    List<String> args() {\n+        return args;\n@@ -82,2 +183,3 @@\n-    List<String> getOutput() {\n-        return output;\n+    Executor mapper(UnaryOperator<Executor> v) {\n+        mapper = v;\n+        return this;\n@@ -86,8 +188,2 @@\n-    Executor executeExpectSuccess() throws IOException {\n-        int ret = execute();\n-        if (0 != ret) {\n-            throw new IOException(\n-                    String.format(\"Command %s exited with %d code\",\n-                            createLogMessage(pb, false), ret));\n-        }\n-        return this;\n+    Optional<UnaryOperator<Executor>> mapper() {\n+        return Optional.ofNullable(mapper);\n@@ -96,2 +192,3 @@\n-    int execute() throws IOException {\n-        output = null;\n+    Executor copy() {\n+        return new Executor(this);\n+    }\n@@ -99,7 +196,5 @@\n-        boolean needProcessOutput = outputConsumer != null || Log.isVerbose() || saveOutput;\n-        Path outputFile = null;\n-        if (needProcessOutput) {\n-            pb.redirectErrorStream(true);\n-            if (writeOutputToFile) {\n-                outputFile = Files.createTempFile(\"jpackageOutputTempFile\", \".tmp\");\n-                pb.redirectOutput(outputFile.toFile());\n+    Result execute() throws IOException {\n+        if (mapper != null) {\n+            var mappedExecutor = Objects.requireNonNull(mapper.apply(this));\n+            if (mappedExecutor != this) {\n+                return mappedExecutor.execute();\n@@ -107,6 +202,0 @@\n-        } else {\n-            \/\/ We are not going to read process output, so need to notify\n-            \/\/ ProcessBuilder about this. Otherwise some processes might just\n-            \/\/ hang up (`ldconfig -p`).\n-            pb.redirectError(ProcessBuilder.Redirect.DISCARD);\n-            pb.redirectOutput(ProcessBuilder.Redirect.DISCARD);\n@@ -115,5 +204,1 @@\n-        if (!quietCommand) {\n-            Log.verbose(String.format(\"Running %s\", createLogMessage(pb, true)));\n-        }\n-\n-        Process p = pb.start();\n+        var coc = commandOutputControl.copy();\n@@ -121,8 +206,7 @@\n-        int code = 0;\n-        if (writeOutputToFile) {\n-            try {\n-                code = waitForProcess(p);\n-            } catch (InterruptedException ex) {\n-                Log.verbose(ex);\n-                throw new RuntimeException(ex);\n-            }\n+        final CommandOutputControl.Executable exec;\n+        if (processBuilder != null) {\n+            exec = coc.createExecutable(copyProcessBuilder());\n+        } else if (toolProvider != null) {\n+            exec = coc.createExecutable(toolProvider, args.toArray(String[]::new));\n+        } else {\n+            throw new IllegalStateException(\"No target to execute\");\n@@ -131,49 +215,2 @@\n-        if (needProcessOutput) {\n-            final List<String> savedOutput;\n-            Supplier<Stream<String>> outputStream;\n-\n-            if (writeOutputToFile) {\n-                output = savedOutput = Files.readAllLines(outputFile);\n-                Files.delete(outputFile);\n-                outputStream = () -> {\n-                    if (savedOutput != null) {\n-                        return savedOutput.stream();\n-                    }\n-                    return null;\n-                };\n-                if (outputConsumer != null) {\n-                    outputConsumer.accept(outputStream.get());\n-                }\n-            } else {\n-                try (var br = new BufferedReader(new InputStreamReader(\n-                        p.getInputStream()))) {\n-\n-                    if ((outputConsumer != null || Log.isVerbose())\n-                            || saveOutput) {\n-                        savedOutput = br.lines().toList();\n-                    } else {\n-                        savedOutput = null;\n-                    }\n-                    output = savedOutput;\n-\n-                    outputStream = () -> {\n-                        if (savedOutput != null) {\n-                            return savedOutput.stream();\n-                        }\n-                        return br.lines();\n-                    };\n-                    if (outputConsumer != null) {\n-                        outputConsumer.accept(outputStream.get());\n-                    }\n-\n-                    if (savedOutput == null) {\n-                        \/\/ For some processes on Linux if the output stream\n-                        \/\/ of the process is opened but not consumed, the process\n-                        \/\/ would exit with code 141.\n-                        \/\/ It turned out that reading just a single line of process\n-                        \/\/ output fixes the problem, but let's process\n-                        \/\/ all of the output, just in case.\n-                        br.lines().forEach(x -> {});\n-                    }\n-                }\n-            }\n+        if (dumpOutput()) {\n+            Log.verbose(String.format(\"Running %s\", CommandLineFormat.DEFAULT.apply(List.of(commandLine().getFirst()))));\n@@ -182,0 +219,2 @@\n+        var printableOutputBuilder = new PrintableOutputBuilder(coc);\n+        Result result;\n@@ -183,5 +222,4 @@\n-            if (!writeOutputToFile) {\n-                code = p.waitFor();\n-            }\n-            if (!quietCommand) {\n-                Log.verbose(pb.command(), getOutput(), code, IOUtils.getPID(p));\n+            if (timeout == null) {\n+                result = exec.execute();\n+            } else {\n+                result = exec.execute(timeout.toMillis(), TimeUnit.MILLISECONDS);\n@@ -189,1 +227,0 @@\n-            return code;\n@@ -191,2 +228,1 @@\n-            Log.verbose(ex);\n-            throw new RuntimeException(ex);\n+            throw ExceptionBox.toUnchecked(ex);\n@@ -194,0 +230,7 @@\n+\n+        var printableOutput = printableOutputBuilder.create();\n+        if (dumpOutput()) {\n+            log(result, printableOutput);\n+        }\n+\n+        return ExecutableAttributesWithCapturedOutput.augmentResultWithOutput(result, printableOutput);\n@@ -196,11 +239,20 @@\n-    private int waitForProcess(Process p) throws InterruptedException {\n-        if (timeout == INFINITE_TIMEOUT) {\n-            return p.waitFor();\n-        } else {\n-            if (p.waitFor(timeout, TimeUnit.SECONDS)) {\n-                return p.exitValue();\n-            } else {\n-                Log.verbose(String.format(\"Command %s timeout after %d seconds\",\n-                            createLogMessage(pb, false), timeout));\n-                p.destroy();\n-                return -1;\n+    Result executeExpectSuccess() throws IOException {\n+        return execute().expectExitCode(0);\n+    }\n+\n+    Result executeExpect(int mainExitCode, int... otherExitCodes) throws IOException {\n+        return execute().expectExitCode(mainExitCode, otherExitCodes);\n+    }\n+\n+    RetryExecutor<Result, IOException> retry() {\n+        return Globals.instance().objectFactory().<Result, IOException>retryExecutor(IOException.class)\n+                .setExecutable(this::executeExpectSuccess);\n+    }\n+\n+    RetryExecutor<Result, IOException> retryOnKnownErrorMessage(String msg) {\n+        Objects.requireNonNull(msg);\n+        return saveOutput().retry().setExecutable(() -> {\n+            \/\/ Execute it without exit code check.\n+            var result = execute();\n+            if (result.stderr().stream().anyMatch(msg::equals)) {\n+                throw result.unexpected();\n@@ -208,0 +260,11 @@\n+            return result;\n+        });\n+    }\n+\n+    List<String> commandLine() {\n+        if (processBuilder != null) {\n+            return Stream.of(processBuilder.command(), args).flatMap(Collection::stream).toList();\n+        } else if (toolProvider != null) {\n+            return Stream.concat(Stream.of(toolProvider.name()), args.stream()).toList();\n+        } else {\n+            throw new IllegalStateException(\"No target to execute\");\n@@ -211,2 +274,12 @@\n-    static Executor of(String... cmdline) {\n-        return new Executor().setCommandLine(cmdline);\n+    private ProcessBuilder copyProcessBuilder() {\n+        if (processBuilder == null) {\n+            throw new IllegalStateException();\n+        }\n+\n+        var copy = new ProcessBuilder(commandLine());\n+        copy.directory(processBuilder.directory());\n+        var env = copy.environment();\n+        env.clear();\n+        env.putAll(processBuilder.environment());\n+\n+        return copy;\n@@ -215,2 +288,2 @@\n-    static Executor of(ProcessBuilder pb) {\n-        return new Executor().setProcessBuilder(pb);\n+    private boolean dumpOutput() {\n+        return Log.isVerbose() && !quietCommand;\n@@ -219,5 +292,28 @@\n-    private static String createLogMessage(ProcessBuilder pb, boolean quiet) {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append((quiet) ? pb.command().get(0) : pb.command());\n-        if (pb.directory() != null) {\n-            sb.append(String.format(\" in %s\", pb.directory().getAbsolutePath()));\n+    private static void log(Result result, String printableOutput) throws IOException {\n+        Objects.requireNonNull(result);\n+        Objects.requireNonNull(printableOutput);\n+\n+        Optional<Long> pid;\n+        if (result.execAttrs() instanceof ProcessAttributes attrs) {\n+            pid = attrs.pid();\n+        } else {\n+            pid = Optional.empty();\n+        }\n+\n+        var sb = new StringBuilder();\n+        sb.append(\"Command\");\n+        pid.ifPresent(p -> {\n+            sb.append(\" [PID: \").append(p).append(\"]\");\n+        });\n+        sb.append(\":\\n    \").append(result.execAttrs().printableCommandLine());\n+        Log.verbose(sb.toString());\n+\n+        if (!printableOutput.isEmpty()) {\n+            sb.delete(0, sb.length());\n+            sb.append(\"Output:\");\n+            try (var lines = new BufferedReader(new StringReader(printableOutput)).lines()) {\n+                lines.forEach(line -> {\n+                    sb.append(\"\\n    \").append(line);\n+                });\n+            }\n+            Log.verbose(sb.toString());\n@@ -225,1 +321,6 @@\n-        return sb.toString();\n+\n+        result.exitCode().ifPresentOrElse(exitCode -> {\n+            Log.verbose(\"Returned: \" + exitCode + \"\\n\");\n+        }, () -> {\n+            Log.verbose(\"Aborted: timed-out\" + \"\\n\");\n+        });\n@@ -228,1 +329,44 @@\n-    public static final int INFINITE_TIMEOUT = -1;\n+    private static final class PrintableOutputBuilder {\n+\n+        PrintableOutputBuilder(CommandOutputControl coc) {\n+            coc.dumpOutput(true);\n+            charset = coc.charset();\n+            if (coc.isBinaryOutput()) {\n+                \/\/ Assume binary output goes into stdout and text error messages go into stderr, so keep them separated.\n+                sinks = new ByteArrayOutputStream[2];\n+                sinks[0] = new ByteArrayOutputStream();\n+                sinks[1] = new ByteArrayOutputStream();\n+                coc.dumpStdout(new PrintStream(sinks[0], false, charset))\n+                    .dumpStderr(new PrintStream(sinks[1], false, charset));\n+            } else {\n+                sinks = new ByteArrayOutputStream[1];\n+                sinks[0] = new ByteArrayOutputStream();\n+                var ps = new PrintStream(sinks[0], false, charset);\n+                \/\/ Redirect stderr in stdout.\n+                coc.dumpStdout(ps).dumpStderr(ps);\n+            }\n+        }\n+\n+        String create() {\n+            if (isBinaryOutput()) {\n+                \/\/ In case of binary output:\n+                \/\/  - Convert binary stdout to text using ISO-8859-1 encoding and\n+                \/\/    replace non-printable characters with the question mark symbol (?).\n+                \/\/  - Convert binary stderr to text using designated encoding (assume stderr is always a character stream).\n+                \/\/  - Merge text stdout and stderr into a single string;\n+                \/\/    stderr first, stdout follows, with the aim to present user error messages first.\n+                var sb = new StringBuilder();\n+                var stdout = sinks[0].toString(StandardCharsets.ISO_8859_1).replaceAll(\"[^\\\\p{Print}\\\\p{Space}]\", \"?\");\n+                return sb.append(sinks[1].toString(charset)).append(stdout).toString();\n+            } else {\n+                return sinks[0].toString(charset);\n+            }\n+        }\n+\n+        private boolean isBinaryOutput() {\n+            return sinks.length == 2;\n+        }\n+\n+        private final ByteArrayOutputStream sinks[];\n+        private final Charset charset;\n+    }\n@@ -230,3 +374,1 @@\n-    private ProcessBuilder pb;\n-    private boolean saveOutput;\n-    private boolean writeOutputToFile;\n+    private final CommandOutputControl commandOutputControl;\n@@ -234,3 +376,5 @@\n-    private long timeout = INFINITE_TIMEOUT;\n-    private List<String> output;\n-    private Consumer<Stream<String>> outputConsumer;\n+    private final List<String> args;\n+    private ProcessBuilder processBuilder;\n+    private ToolProvider toolProvider;\n+    private Duration timeout;\n+    private UnaryOperator<Executor> mapper;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Executor.java","additions":291,"deletions":147,"binary":false,"changes":438,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+@FunctionalInterface\n+interface ExecutorFactory {\n+\n+    Executor executor();\n+\n+    static final ExecutorFactory DEFAULT = Executor::new;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ExecutorFactory.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.PrintWriter;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+public final class Globals {\n+\n+    private Globals() {\n+    }\n+\n+    Globals objectFactory(ObjectFactory v) {\n+        checkMutable();\n+        objectFactory = Optional.ofNullable(v).orElse(ObjectFactory.DEFAULT);\n+        return this;\n+    }\n+\n+    ObjectFactory objectFactory() {\n+        return objectFactory;\n+    }\n+\n+    Globals executorFactory(ExecutorFactory v) {\n+        return objectFactory(ObjectFactory.build(objectFactory).executorFactory(v).create());\n+    }\n+\n+    Log.Logger logger() {\n+        return logger;\n+    }\n+\n+    public void loggerOutputStreams(PrintWriter out, PrintWriter err) {\n+        logger.setPrintWriter(out, err);\n+    }\n+\n+    public void loggerVerbose() {\n+        logger.setVerbose();\n+    }\n+\n+    public static int main(Supplier<Integer> mainBody) {\n+        if (INSTANCE.isBound()) {\n+            return mainBody.get();\n+        } else {\n+            return ScopedValue.where(INSTANCE, new Globals()).call(mainBody::get);\n+        }\n+    }\n+\n+    public static Globals instance() {\n+        return INSTANCE.orElse(DEFAULT);\n+    }\n+\n+    private void checkMutable() {\n+        if (this == DEFAULT) {\n+            throw new UnsupportedOperationException(\"Can't modify immutable instance\");\n+        }\n+    }\n+\n+    private ObjectFactory objectFactory = ObjectFactory.DEFAULT;\n+    private final Log.Logger logger = new Log.Logger();\n+\n+    private static final ScopedValue<Globals> INSTANCE = ScopedValue.newInstance();\n+    private static final Globals DEFAULT = new Globals();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Globals.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.io.PrintStream;\n@@ -33,2 +32,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -53,40 +50,0 @@\n-    public static void exec(ProcessBuilder pb)\n-            throws IOException {\n-        exec(pb, false, null, false, Executor.INFINITE_TIMEOUT);\n-    }\n-\n-    \/\/ timeout in seconds. -1 will be return if process timeouts.\n-    public static void exec(ProcessBuilder pb, long timeout)\n-            throws IOException {\n-        exec(pb, false, null, false, timeout);\n-    }\n-\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n-            PrintStream consumer, boolean writeOutputToFile, long timeout)\n-            throws IOException {\n-        exec(pb, testForPresenceOnly, consumer, writeOutputToFile,\n-                timeout, false);\n-    }\n-\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n-            PrintStream consumer, boolean writeOutputToFile,\n-            long timeout, boolean quiet) throws IOException {\n-        List<String> output = new ArrayList<>();\n-        Executor exec = Executor.of(pb)\n-                .setWriteOutputToFile(writeOutputToFile)\n-                .setTimeout(timeout)\n-                .setQuiet(quiet)\n-                .setOutputConsumer(lines -> {\n-                    lines.forEach(output::add);\n-                    if (consumer != null) {\n-                        output.forEach(consumer::println);\n-                    }\n-                });\n-\n-        if (testForPresenceOnly) {\n-            exec.execute();\n-        } else {\n-            exec.executeExpectSuccess();\n-        }\n-    }\n-\n@@ -106,11 +63,0 @@\n-\n-    public static long getPID(Process p) {\n-        try {\n-            return p.pid();\n-        } catch (UnsupportedOperationException ex) {\n-            Log.verbose(ex); \/\/ Just log exception and ignore it. This method\n-                             \/\/ is used for verbose output, so not a problem\n-                             \/\/ if unsupported.\n-            return -1;\n-        }\n-    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":1,"deletions":55,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -26,0 +27,1 @@\n+\n@@ -27,0 +29,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n@@ -30,2 +33,0 @@\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n@@ -53,1 +54,0 @@\n-import jdk.jpackage.internal.model.JPackageException;\n@@ -61,1 +61,1 @@\n-        this.jlinkCmdLine = jlinkCmdLine;\n+        this.jlinkCmdLine = Objects.requireNonNull(jlinkCmdLine);\n@@ -66,16 +66,4 @@\n-        var args = new ArrayList<String>();\n-        args.add(\"--output\");\n-        args.add(appImageLayout.runtimeDirectory().toString());\n-        args.addAll(jlinkCmdLine);\n-\n-        StringWriter writer = new StringWriter();\n-        PrintWriter pw = new PrintWriter(writer);\n-\n-        int retVal = LazyLoad.JLINK_TOOL.run(pw, pw, args.toArray(String[]::new));\n-        String jlinkOut = writer.toString();\n-\n-        args.add(0, \"jlink\");\n-        Log.verbose(args, List.of(jlinkOut), retVal, -1);\n-        if (retVal != 0) {\n-            throw new JPackageException(I18N.format(\"error.jlink.failed\", jlinkOut));\n-        }\n+        toRunnable(Executor.of()\n+                .toolProvider(LazyLoad.JLINK_TOOL)\n+                .args(\"--output\", appImageLayout.runtimeDirectory().toString())\n+                .args(jlinkCmdLine)::executeExpectSuccess).run();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -133,2 +134,1 @@\n-                \/\/ TODO: Must do something about this condition!\n-                throw new AssertionError();\n+                throw new JPackageException(I18N.format(\"error.no-extensions-for-file-association\", faID));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherFromOptions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -65,10 +64,0 @@\n-        public void flush() {\n-            if (out != null) {\n-                out.flush();\n-            }\n-\n-            if (err != null) {\n-                err.flush();\n-            }\n-        }\n-\n@@ -108,23 +97,0 @@\n-        public void verbose(List<String> strings,\n-                List<String> output, int returnCode, long pid) {\n-            if (verbose) {\n-                StringBuilder sb = new StringBuilder();\n-                sb.append(\"Command [PID: \");\n-                sb.append(pid);\n-                sb.append(\"]:\\n   \");\n-\n-                for (String s : strings) {\n-                    sb.append(\" \" + s);\n-                }\n-                verbose(sb.toString());\n-                if (output != null && !output.isEmpty()) {\n-                    sb = new StringBuilder(\"Output:\");\n-                    for (String s : output) {\n-                        sb.append(\"\\n    \" + s);\n-                    }\n-                    verbose(sb.toString());\n-                }\n-                verbose(\"Returned: \" + returnCode + \"\\n\");\n-            }\n-        }\n-\n@@ -138,15 +104,0 @@\n-    private static final InheritableThreadLocal<Logger> instance =\n-            new InheritableThreadLocal<Logger>() {\n-                @Override protected Logger initialValue() {\n-                    return new Logger();\n-                }\n-            };\n-\n-    public static void setPrintWriter (PrintWriter out, PrintWriter err) {\n-        instance.get().setPrintWriter(out, err);\n-    }\n-\n-    public static void flush() {\n-        instance.get().flush();\n-    }\n-\n@@ -154,1 +105,1 @@\n-        instance.get().info(msg);\n+        Globals.instance().logger().info(msg);\n@@ -158,1 +109,1 @@\n-        instance.get().fatalError(msg);\n+        Globals.instance().logger().fatalError(msg);\n@@ -162,5 +113,1 @@\n-        instance.get().error(msg);\n-    }\n-\n-    public static void setVerbose() {\n-        instance.get().setVerbose();\n+        Globals.instance().logger().error(msg);\n@@ -170,1 +117,1 @@\n-        return instance.get().isVerbose();\n+        return Globals.instance().logger().isVerbose();\n@@ -174,1 +121,1 @@\n-       instance.get().verbose(msg);\n+        Globals.instance().logger().verbose(msg);\n@@ -178,6 +125,1 @@\n-       instance.get().verbose(t);\n-    }\n-\n-    public static void verbose(List<String> strings, List<String> out,\n-            int ret, long pid) {\n-       instance.get().verbose(strings, out, ret, pid);\n+        Globals.instance().logger().verbose(t);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Log.java","additions":7,"deletions":65,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+interface ObjectFactory extends ExecutorFactory, RetryExecutorFactory {\n+\n+    static ObjectFactory.Builder build() {\n+        return new Builder();\n+    }\n+\n+    static ObjectFactory.Builder build(ObjectFactory from) {\n+        return build().initFrom(from);\n+    }\n+\n+    static final class Builder {\n+        private Builder() {\n+        }\n+\n+        ObjectFactory create() {\n+            return CompositeProxy.build().invokeTunnel(CompositeProxyTunnel.INSTANCE).create(\n+                    ObjectFactory.class,\n+                    Optional.ofNullable(executorFactory).orElse(ExecutorFactory.DEFAULT),\n+                    Optional.ofNullable(retryExecutorFactory).orElse(RetryExecutorFactory.DEFAULT));\n+        }\n+\n+        Builder initFrom(ObjectFactory of) {\n+            Objects.requireNonNull(of);\n+            return executorFactory(of).retryExecutorFactory(of);\n+        }\n+\n+        Builder executorFactory(ExecutorFactory v) {\n+            executorFactory = v;\n+            return this;\n+        }\n+\n+        Builder retryExecutorFactory(RetryExecutorFactory v) {\n+            retryExecutorFactory = v;\n+            return this;\n+        }\n+\n+        private ExecutorFactory executorFactory;\n+        private RetryExecutorFactory retryExecutorFactory;\n+    }\n+\n+    static final ObjectFactory DEFAULT = build().create();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ObjectFactory.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.nio.file.Files;\n@@ -42,0 +43,2 @@\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n@@ -43,0 +46,1 @@\n+import java.util.function.Supplier;\n@@ -48,0 +52,1 @@\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -100,1 +105,1 @@\n-    interface StartupParameters {\n+    sealed interface StartupParameters {\n@@ -130,0 +135,1 @@\n+        DELETE_OLD_PACKAGE_FILE,\n@@ -186,1 +192,1 @@\n-    record TaskConfig(Optional<TaskAction> action) {\n+    record TaskConfig(Optional<TaskAction> action, Optional<TaskAction> beforeAction, Optional<TaskAction> afterAction) {\n@@ -189,0 +195,2 @@\n+            Objects.requireNonNull(beforeAction);\n+            Objects.requireNonNull(afterAction);\n@@ -199,14 +207,0 @@\n-            private TaskBuilder(TaskID id) {\n-                super(id);\n-            }\n-\n-            private TaskBuilder(TaskID id, TaskConfig config) {\n-                this(id);\n-                config.action().ifPresent(this::setAction);\n-            }\n-\n-            private TaskBuilder setAction(TaskAction v) {\n-                action = v;\n-                return this;\n-            }\n-\n@@ -214,2 +208,1 @@\n-                action = null;\n-                return this;\n+                return setAction(ActionRole.WORKLOAD, null);\n@@ -219,1 +212,1 @@\n-                return setAction(action);\n+                return applicationAction(ActionRole.WORKLOAD, action);\n@@ -223,1 +216,1 @@\n-                return setAction(action);\n+                return appImageAction(ActionRole.WORKLOAD, action);\n@@ -227,1 +220,1 @@\n-                return setAction(action);\n+                return copyAction(ActionRole.WORKLOAD, action);\n@@ -231,1 +224,1 @@\n-                return setAction(action);\n+                return packageAction(ActionRole.WORKLOAD, action);\n@@ -235,1 +228,33 @@\n-                return setAction(action);\n+                return action(ActionRole.WORKLOAD, action);\n+            }\n+\n+            <T extends Application, U extends AppImageLayout> TaskBuilder logAppImageActionBegin(String keyId, Function<AppImageBuildEnv<T, U>, Object[]> formatArgsSupplier) {\n+                return logAppImageAction(ActionRole.BEFORE, keyId, formatArgsSupplier);\n+            }\n+\n+            <T extends Application, U extends AppImageLayout> TaskBuilder logAppImageActionEnd(String keyId, Function<AppImageBuildEnv<T, U>, Object[]> formatArgsSupplier) {\n+                return logAppImageAction(ActionRole.AFTER, keyId, formatArgsSupplier);\n+            }\n+\n+            <T extends Package, U extends AppImageLayout> TaskBuilder logPackageActionBegin(String keyId, Function<PackageBuildEnv<T, U>, Object[]> argsSupplier) {\n+                return logPackageAction(ActionRole.BEFORE, keyId, argsSupplier);\n+            }\n+\n+            <T extends Package, U extends AppImageLayout> TaskBuilder logPackageActionEnd(String keyId, Function<PackageBuildEnv<T, U>, Object[]> argsSupplier) {\n+                return logPackageAction(ActionRole.AFTER, keyId, argsSupplier);\n+            }\n+\n+            TaskBuilder logActionBegin(String keyId, Supplier<Object[]> formatArgsSupplier) {\n+                return logAction(ActionRole.BEFORE, keyId, formatArgsSupplier);\n+            }\n+\n+            TaskBuilder logActionBegin(String keyId, Object... formatArgsSupplier) {\n+                return logAction(ActionRole.BEFORE, keyId, () -> formatArgsSupplier);\n+            }\n+\n+            TaskBuilder logActionEnd(String keyId, Supplier<Object[]> formatArgsSupplier) {\n+                return logAction(ActionRole.AFTER, keyId, formatArgsSupplier);\n+            }\n+\n+            TaskBuilder logActionEnd(String keyId, Object... formatArgsSupplier) {\n+                return logAction(ActionRole.AFTER, keyId, () -> formatArgsSupplier);\n@@ -239,1 +264,1 @@\n-                return action != null;\n+                return workloadAction != null;\n@@ -275,1 +300,4 @@\n-                final var config = new TaskConfig(Optional.ofNullable(action));\n+                final var config = new TaskConfig(\n+                        Optional.ofNullable(workloadAction),\n+                        Optional.ofNullable(beforeAction),\n+                        Optional.ofNullable(afterAction));\n@@ -281,1 +309,94 @@\n-            private TaskAction action;\n+\n+            private enum ActionRole {\n+                WORKLOAD(TaskBuilder::setWorkloadAction),\n+                BEFORE(TaskBuilder::setBeforeAction),\n+                AFTER(TaskBuilder::setAfterAction),\n+                ;\n+\n+                ActionRole(BiConsumer<TaskBuilder, TaskAction> actionSetter) {\n+                    this.actionSetter = Objects.requireNonNull(actionSetter);\n+                }\n+\n+                TaskBuilder setAction(TaskBuilder taskBuilder, TaskAction action) {\n+                    actionSetter.accept(taskBuilder, action);\n+                    return taskBuilder;\n+                }\n+\n+                private final BiConsumer<TaskBuilder, TaskAction> actionSetter;\n+            }\n+\n+\n+            private TaskBuilder(TaskID id) {\n+                super(id);\n+            }\n+\n+            private TaskBuilder(TaskID id, TaskConfig config) {\n+                this(id);\n+                config.action().ifPresent(this::setWorkloadAction);\n+                config.beforeAction().ifPresent(this::setBeforeAction);\n+                config.afterAction().ifPresent(this::setAfterAction);\n+            }\n+\n+            private TaskBuilder setAction(ActionRole role, TaskAction v) {\n+                return role.setAction(this, v);\n+            }\n+\n+            private TaskBuilder setWorkloadAction(TaskAction v) {\n+                workloadAction = v;\n+                return this;\n+            }\n+\n+            private TaskBuilder setBeforeAction(TaskAction v) {\n+                beforeAction = v;\n+                return this;\n+            }\n+\n+            private TaskBuilder setAfterAction(TaskAction v) {\n+                afterAction = v;\n+                return this;\n+            }\n+\n+            private <T extends Application, U extends ApplicationLayout> TaskBuilder applicationAction(ActionRole role, ApplicationImageTaskAction<T, U> action) {\n+                return setAction(role, action);\n+            }\n+\n+            private <T extends Application, U extends AppImageLayout> TaskBuilder appImageAction(ActionRole role, AppImageTaskAction<T, U> action) {\n+                return setAction(role, action);\n+            }\n+\n+            private <T extends Package> TaskBuilder copyAction(ActionRole role, CopyAppImageTaskAction<T> action) {\n+                return setAction(role, action);\n+            }\n+\n+            private <T extends Package, U extends AppImageLayout> TaskBuilder packageAction(ActionRole role, PackageTaskAction<T, U> action) {\n+                return setAction(role, action);\n+            }\n+\n+            private TaskBuilder action(ActionRole role, NoArgTaskAction action) {\n+                return setAction(role, action);\n+            }\n+\n+            private <T extends Application, U extends AppImageLayout> TaskBuilder logAppImageAction(ActionRole role, String keyId, Function<AppImageBuildEnv<T, U>, Object[]> formatArgsSupplier) {\n+                Objects.requireNonNull(keyId);\n+                return appImageAction(role, (AppImageBuildEnv<T, U> env) -> {\n+                    Log.verbose(I18N.format(keyId, formatArgsSupplier.apply(env)));\n+                });\n+            }\n+\n+            private <T extends Package, U extends AppImageLayout> TaskBuilder logPackageAction(ActionRole role, String keyId, Function<PackageBuildEnv<T, U>, Object[]> formatArgsSupplier) {\n+                Objects.requireNonNull(keyId);\n+                return packageAction(role, (PackageBuildEnv<T, U> env) -> {\n+                    Log.verbose(I18N.format(keyId, formatArgsSupplier.apply(env)));\n+                });\n+            }\n+\n+            private TaskBuilder logAction(ActionRole role, String keyId, Supplier<Object[]> formatArgsSupplier) {\n+                Objects.requireNonNull(keyId);\n+                return action(role, () -> {\n+                    Log.verbose(I18N.format(keyId, formatArgsSupplier.get()));\n+                });\n+            }\n+\n+            private TaskAction workloadAction;\n+            private TaskAction beforeAction;\n+            private TaskAction afterAction;\n@@ -297,1 +418,5 @@\n-            return new TaskBuilder(id);\n+            return Optional.ofNullable(taskConfig.get(id)).map(taskConfig -> {\n+                return new TaskBuilder(id, taskConfig);\n+            }).orElseGet(() -> {\n+                return new TaskBuilder(id);\n+            });\n@@ -395,0 +520,2 @@\n+                .logActionBegin(\"message.create-package\")\n+                .logActionEnd(\"message.package-created\")\n@@ -428,0 +555,11 @@\n+    static void deleteOutputBundle(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n+\n+        var outputBundle = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n+\n+        try {\n+            Files.deleteIfExists(outputBundle);\n+        } catch (IOException ex) {\n+            throw new JPackageException(I18N.format(\"error.output-bundle-cannot-be-overwritten\", outputBundle.toAbsolutePath()), ex);\n+        }\n+    }\n+\n@@ -648,0 +786,3 @@\n+                if (config.beforeAction.isPresent()) {\n+                    context.execute(config.beforeAction.orElseThrow());\n+                }\n@@ -649,0 +790,3 @@\n+                if (config.afterAction.isPresent()) {\n+                    context.execute(config.afterAction.orElseThrow());\n+                }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":172,"deletions":28,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.function.Consumer;\n-import java.util.function.Supplier;\n-\n-public final class RetryExecutor {\n-    public RetryExecutor() {\n-        setMaxAttemptsCount(5);\n-        setAttemptTimeoutMillis(2 * 1000);\n-        setWriteOutputToFile(false);\n-    }\n-\n-    public RetryExecutor setMaxAttemptsCount(int v) {\n-        attempts = v;\n-        return this;\n-    }\n-\n-    public RetryExecutor setAttemptTimeoutMillis(int v) {\n-        timeoutMillis = v;\n-        return this;\n-    }\n-\n-    public RetryExecutor saveOutput(boolean v) {\n-        saveOutput = v;\n-        return this;\n-    }\n-\n-    public List<String> getOutput() {\n-        return output;\n-    }\n-\n-    public RetryExecutor setWriteOutputToFile(boolean v) {\n-        writeOutputToFile = v;\n-        return this;\n-    }\n-\n-    public RetryExecutor setExecutorInitializer(Consumer<Executor> v) {\n-        executorInitializer = v;\n-        return this;\n-    }\n-\n-    public void abort() {\n-        aborted = true;\n-    }\n-\n-    public boolean isAborted() {\n-        return aborted;\n-    }\n-\n-    static RetryExecutor retryOnKnownErrorMessage(String v) {\n-        RetryExecutor result = new RetryExecutor();\n-        return result.setExecutorInitializer(exec -> {\n-            exec.setOutputConsumer(output -> {\n-                if (!output.anyMatch(v::equals)) {\n-                    result.abort();\n-                }\n-            });\n-        });\n-    }\n-\n-    public void execute(String cmdline[]) throws IOException {\n-        executeLoop(() ->\n-                Executor.of(cmdline).setWriteOutputToFile(writeOutputToFile));\n-    }\n-\n-    public void execute(ProcessBuilder pb) throws IOException {\n-        executeLoop(() ->\n-                Executor.of(pb).setWriteOutputToFile(writeOutputToFile));\n-    }\n-\n-    private void executeLoop(Supplier<Executor> execSupplier) throws IOException {\n-        aborted = false;\n-        for (;;) {\n-            if (aborted) {\n-                break;\n-            }\n-\n-            try {\n-                Executor exec = execSupplier.get().saveOutput(saveOutput);\n-                if (executorInitializer != null) {\n-                    executorInitializer.accept(exec);\n-                }\n-                exec.executeExpectSuccess();\n-                if (saveOutput) {\n-                    output = exec.getOutput();\n-                }\n-                break;\n-            } catch (IOException ex) {\n-                if (aborted || (--attempts) <= 0) {\n-                    throw ex;\n-                }\n-            }\n-\n-            try {\n-                Thread.sleep(timeoutMillis);\n-            } catch (InterruptedException ex) {\n-                Log.verbose(ex);\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-    }\n-\n-    private Consumer<Executor> executorInitializer;\n-    private boolean aborted;\n-    private int attempts;\n-    private int timeoutMillis;\n-    private boolean saveOutput;\n-    private List<String> output;\n-    private boolean writeOutputToFile;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/RetryExecutor.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import jdk.jpackage.internal.util.RetryExecutor;\n+\n+@FunctionalInterface\n+interface RetryExecutorFactory {\n+\n+    <T, E extends Exception> RetryExecutor<T, E> retryExecutor(Class<? extends E> exceptionType);\n+\n+    static final RetryExecutorFactory DEFAULT = RetryExecutor::new;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/RetryExecutorFactory.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-public interface SystemEnvironment {\n+interface SystemEnvironment {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/SystemEnvironment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-        boolean canUseTool[] = new boolean[1];\n+        boolean canUseTool = false;\n@@ -127,1 +127,1 @@\n-            canUseTool[0] = true;\n+            canUseTool = true;\n@@ -130,1 +130,1 @@\n-        String[] version = new String[1];\n+        String version = null;\n@@ -133,6 +133,6 @@\n-            Executor.of(cmdline.toArray(String[]::new)).setQuiet(true).setOutputConsumer(lines -> {\n-                if (versionParser != null && minimalVersion != null) {\n-                    version[0] = versionParser.apply(lines);\n-                    if (version[0] != null && minimalVersion.compareTo(version[0]) <= 0) {\n-                        canUseTool[0] = true;\n-                    }\n+            var result = Executor.of(cmdline).setQuiet(true).saveOutput().execute();\n+            var lines = result.content();\n+            if (versionParser != null && minimalVersion != null) {\n+                version = versionParser.apply(lines.stream());\n+                if (version != null && minimalVersion.compareTo(version) <= 0) {\n+                    canUseTool = true;\n@@ -140,1 +140,1 @@\n-            }).execute();\n+            }\n@@ -145,1 +145,1 @@\n-        if (canUseTool[0]) {\n+        if (canUseTool) {\n@@ -149,1 +149,1 @@\n-            return toolOldVersionErrorHandler.apply(toolPath, version[0]);\n+            return toolOldVersionErrorHandler.apply(toolPath, version);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ToolValidator.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.io.BufferedReader;\n@@ -36,0 +37,1 @@\n+import java.io.StringReader;\n@@ -48,0 +50,1 @@\n+import jdk.jpackage.internal.Globals;\n@@ -50,0 +53,1 @@\n+import jdk.jpackage.internal.model.ExecutableAttributesWithCapturedOutput;\n@@ -51,0 +55,3 @@\n+import jdk.jpackage.internal.model.SelfContainedException;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedExitCodeException;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedResultException;\n@@ -59,1 +66,9 @@\n-    public static final class Provider implements ToolProvider {\n+    public record Provider(Supplier<CliBundlingEnvironment> bundlingEnvSupplier) implements ToolProvider {\n+\n+        public Provider {\n+            Objects.requireNonNull(bundlingEnvSupplier);\n+        }\n+\n+        public Provider() {\n+            this(DefaultBundlingEnvironmentLoader.INSTANCE);\n+        }\n@@ -68,1 +83,1 @@\n-            return Main.run(out, err, args);\n+            return Main.run(bundlingEnvSupplier, out, err, args);\n@@ -73,2 +88,2 @@\n-            PrintWriter outWriter = new PrintWriter(out, true);\n-            PrintWriter errWriter = new PrintWriter(err, true);\n+            PrintWriter outWriter = toPrintWriter(out);\n+            PrintWriter errWriter = toPrintWriter(err);\n@@ -92,2 +107,2 @@\n-        var out = new PrintWriter(System.out, true);\n-        var err = new PrintWriter(System.err, true);\n+        var out = toPrintWriter(System.out);\n+        var err = toPrintWriter(System.err);\n@@ -97,1 +112,17 @@\n-    public static int run(PrintWriter out, PrintWriter err, String... args) {\n+    static int run(PrintWriter out, PrintWriter err, String... args) {\n+        return run(DefaultBundlingEnvironmentLoader.INSTANCE, out, err, args);\n+    }\n+\n+    static int run(Supplier<CliBundlingEnvironment> bundlingEnvSupplier, PrintWriter out, PrintWriter err, String... args) {\n+        return Globals.main(() -> {\n+            return runWithGlobals(bundlingEnvSupplier, out, err, args);\n+        });\n+    }\n+\n+    private static int runWithGlobals(\n+            Supplier<CliBundlingEnvironment> bundlingEnvSupplier,\n+            PrintWriter out,\n+            PrintWriter err,\n+            String... args) {\n+\n+        Objects.requireNonNull(bundlingEnvSupplier);\n@@ -105,1 +136,1 @@\n-        Log.setPrintWriter(out, err);\n+        Globals.instance().loggerOutputStreams(out, err);\n@@ -131,2 +162,1 @@\n-            final var bundlingEnv = ServiceLoader.load(CliBundlingEnvironment.class,\n-                    CliBundlingEnvironment.class.getClassLoader()).findFirst().orElseThrow();\n+            final var bundlingEnv = bundlingEnvSupplier.get();\n@@ -158,1 +188,1 @@\n-                    Log.setVerbose();\n+                    Globals.instance().loggerVerbose();\n@@ -218,0 +248,2 @@\n+            } else if (t instanceof UnexpectedResultException ex) {\n+                printExternalCommandError(ex);\n@@ -223,0 +255,27 @@\n+        private void printExternalCommandError(UnexpectedResultException ex) {\n+            var result = ex.getResult();\n+            var commandOutput = ((ExecutableAttributesWithCapturedOutput)result.execAttrs()).printableOutput();\n+            var printableCommandLine = result.execAttrs().printableCommandLine();\n+\n+            if (verbose) {\n+                stackTracePrinter.accept(ex);\n+            }\n+\n+            String msg;\n+            if (ex instanceof UnexpectedExitCodeException) {\n+                msg = I18N.format(\"error.command-failed-unexpected-exit-code\", result.getExitCode(), printableCommandLine);\n+            } else if (result.exitCode().isPresent()) {\n+                msg = I18N.format(\"error.command-failed-unexpected-output\", printableCommandLine);\n+            } else {\n+                msg = I18N.format(\"error.command-failed-timed-out\", printableCommandLine);\n+            }\n+\n+            messagePrinter.accept(I18N.format(\"message.error-header\", msg));\n+            if (!verbose) {\n+                messagePrinter.accept(I18N.format(\"message.failed-command-output-header\"));\n+                try (var lines = new BufferedReader(new StringReader(commandOutput)).lines()) {\n+                    lines.forEach(messagePrinter);\n+                }\n+            }\n+        }\n+\n@@ -224,1 +283,1 @@\n-            var isAlienException = isAlienExceptionType(t);\n+            var isSelfContained = isSelfContained(t);\n@@ -226,1 +285,1 @@\n-            if (isAlienException || verbose) {\n+            if (!isSelfContained || verbose) {\n@@ -231,3 +290,1 @@\n-            if (isAlienException) {\n-                msg = t.toString();\n-            } else {\n+            if (isSelfContained) {\n@@ -235,0 +292,2 @@\n+            } else {\n+                msg = t.toString();\n@@ -241,15 +300,2 @@\n-        private static boolean isAlienExceptionType(Throwable t) {\n-            switch (t) {\n-                case JPackageException _ -> {\n-                    return false;\n-                }\n-                case Utils.ParseException _ -> {\n-                    return false;\n-                }\n-                case StandardOption.AddLauncherIllegalArgumentException _ -> {\n-                    return false;\n-                }\n-                default -> {\n-                    return true;\n-                }\n-            }\n+        private static boolean isSelfContained(Throwable t) {\n+            return t.getClass().getAnnotation(SelfContainedException.class) != null;\n@@ -288,0 +334,15 @@\n+\n+    private static PrintWriter toPrintWriter(PrintStream ps) {\n+        return new PrintWriter(ps, true, ps.charset());\n+    }\n+\n+    private enum DefaultBundlingEnvironmentLoader implements Supplier<CliBundlingEnvironment> {\n+        INSTANCE;\n+\n+        @Override\n+        public CliBundlingEnvironment get() {\n+            return ServiceLoader.load(\n+                    CliBundlingEnvironment.class,\n+                    CliBundlingEnvironment.class.getClassLoader()).findFirst().orElseThrow();\n+        }\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Main.java","additions":93,"deletions":32,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+        validator = other.validator;\n@@ -138,1 +139,1 @@\n-                Optional.of(arryValuePattern()),\n+                Optional.of(arrayValuePattern()),\n@@ -142,0 +143,10 @@\n+    Optional<? extends Validator<T, RuntimeException>> createValidator() {\n+        return Optional.ofNullable(validator).or(() -> {\n+            if (validatorBuilder.hasValidatingMethod()) {\n+                return Optional.of(validatorBuilder.create());\n+            } else {\n+                return Optional.empty();\n+            }\n+        });\n+    }\n+\n@@ -165,0 +176,1 @@\n+        validator = null;\n@@ -170,0 +182,1 @@\n+        validator = null;\n@@ -185,0 +198,1 @@\n+        validator = null;\n@@ -228,0 +242,1 @@\n+        validator = null;\n@@ -234,0 +249,1 @@\n+        validator = null;\n@@ -240,0 +256,7 @@\n+        validator = null;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validator(Validator<T, RuntimeException> v) {\n+        validatorBuilder.predicate(null).consumer(null);\n+        validator = Objects.requireNonNull(v);\n@@ -250,0 +273,1 @@\n+        validator = null;\n@@ -426,8 +450,0 @@\n-    private Optional<Validator<T, ? extends RuntimeException>> createValidator() {\n-        if (validatorBuilder.hasValidatingMethod()) {\n-            return Optional.of(validatorBuilder.create());\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -443,1 +459,1 @@\n-    private String arryValuePattern() {\n+    private String arrayValuePattern() {\n@@ -471,0 +487,1 @@\n+    private Validator<T, RuntimeException> validator;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecBuilder.java","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.BundleType;\n@@ -253,1 +253,1 @@\n-                    optionSpec, bundlingOperation.packageTypeValue()));\n+                    optionSpec, bundlingOperation.bundleTypeValue()));\n@@ -270,2 +270,2 @@\n-            if (obj instanceof PackageType packageType) {\n-                return packageType;\n+            if (obj instanceof BundleType bundleType) {\n+                return bundleType;\n@@ -273,1 +273,2 @@\n-                return typeOption.spec()\n+                var spec = new StandardOptionContext(os).mapOptionSpec(typeOption.spec());\n+                return spec\n@@ -275,1 +276,1 @@\n-                        .convert(typeOption.spec().name(), StringToken.of(((String[])obj)[0]))\n+                        .convert(spec.name(), StringToken.of(((String[])obj)[0]))\n@@ -278,2 +279,2 @@\n-        }).map(packageType -> {\n-            \/\/ Find standard bundling operations producing the given package type.\n+        }).map(bundleType -> {\n+            \/\/ Find standard bundling operations producing the given bundle type.\n@@ -281,1 +282,1 @@\n-                return op.packageType().equals(packageType);\n+                return op.bundleType().equals(bundleType);\n@@ -286,1 +287,1 @@\n-                \/\/ bundles of the `packageType`.\n+                \/\/ bundles of the `bundleType`.\n@@ -289,1 +290,1 @@\n-                        packageType));\n+                        bundleType));\n@@ -293,1 +294,1 @@\n-                \/\/ Multiple standard bundling operations produce the `packageType` package type.\n+                \/\/ Multiple standard bundling operations produce the `bundleType` bundle type.\n@@ -301,1 +302,1 @@\n-                    \/\/ bundles of the `packageType` on the current OS.\n+                    \/\/ bundles of the `bundleType` on the current OS.\n@@ -304,1 +305,1 @@\n-                            packageType, OperatingSystem.current()));\n+                            bundleType, OperatingSystem.current()));\n@@ -319,1 +320,1 @@\n-            \/\/ No package type specified, use the default bundling operation in the given environment.\n+            \/\/ No bundle type specified, use the default bundling operation in the given environment.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsAnalyzer.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,9 +172,0 @@\n-    \/**\n-     * Is an application image is signed. macOS-only.\n-     *\/\n-    public static final OptionValue<Boolean> MAC_SIGNED = booleanOption(\"signed\")\n-            .inScope(AppImageFileOptionScope.APP)\n-            .mutate(setPlatformScope(OperatingSystem.MACOS))\n-            .toOptionValueBuilder().id(StandardOption.MAC_SIGN.id()).create();\n-\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardAppImageFileOption.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import static jdk.jpackage.internal.model.AppImagePackageType.APP_IMAGE;\n-\n@@ -37,0 +35,2 @@\n+import jdk.jpackage.internal.model.AppImageBundleType;\n+import jdk.jpackage.internal.model.BundleType;\n@@ -47,3 +47,3 @@\n-    CREATE_WIN_APP_IMAGE(APP_IMAGE, \"^(?!(linux-|mac-|win-exe-|win-msi-))\", OperatingSystem.WINDOWS),\n-    CREATE_LINUX_APP_IMAGE(APP_IMAGE, \"^(?!(win-|mac-|linux-rpm-|linux-deb-))\", OperatingSystem.LINUX),\n-    CREATE_MAC_APP_IMAGE(APP_IMAGE, \"^(?!(linux-|win-|mac-dmg-|mac-pkg-))\", OperatingSystem.MACOS),\n+    CREATE_WIN_APP_IMAGE(AppImageBundleType.WIN_APP_IMAGE, \"^(?!(linux-|mac-|win-exe-|win-msi-))\", OperatingSystem.WINDOWS),\n+    CREATE_LINUX_APP_IMAGE(AppImageBundleType.LINUX_APP_IMAGE, \"^(?!(win-|mac-|linux-rpm-|linux-deb-))\", OperatingSystem.LINUX),\n+    CREATE_MAC_APP_IMAGE(AppImageBundleType.MAC_APP_IMAGE, \"^(?!(linux-|win-|mac-dmg-|mac-pkg-))\", OperatingSystem.MACOS),\n@@ -56,1 +56,1 @@\n-    SIGN_MAC_APP_IMAGE(APP_IMAGE, OperatingSystem.MACOS, Verb.SIGN);\n+    SIGN_MAC_APP_IMAGE(AppImageBundleType.MAC_APP_IMAGE, OperatingSystem.MACOS, Verb.SIGN);\n@@ -81,2 +81,2 @@\n-    StandardBundlingOperation(PackageType packageType, String optionNameRegexp, OperatingSystem os, Verb descriptorVerb) {\n-        this.packageType = Objects.requireNonNull(packageType);\n+    StandardBundlingOperation(BundleType bundleType, String optionNameRegexp, OperatingSystem os, Verb descriptorVerb) {\n+        this.bundleType = Objects.requireNonNull(bundleType);\n@@ -88,2 +88,2 @@\n-    StandardBundlingOperation(PackageType packageType, String optionNameRegexp, OperatingSystem os) {\n-        this(packageType, optionNameRegexp, os, Verb.CREATE);\n+    StandardBundlingOperation(BundleType bundleType, String optionNameRegexp, OperatingSystem os) {\n+        this(bundleType, optionNameRegexp, os, Verb.CREATE);\n@@ -92,2 +92,2 @@\n-    StandardBundlingOperation(PackageType packageType, OperatingSystem os, Verb descriptorVerb) {\n-        this.packageType = Objects.requireNonNull(packageType);\n+    StandardBundlingOperation(BundleType bundleType, OperatingSystem os, Verb descriptorVerb) {\n+        this.bundleType = Objects.requireNonNull(bundleType);\n@@ -103,2 +103,2 @@\n-    public String packageTypeValue() {\n-        if (packageType.equals(APP_IMAGE)) {\n+    public String bundleTypeValue() {\n+        if (bundleType instanceof AppImageBundleType) {\n@@ -107,1 +107,1 @@\n-            return ((StandardPackageType)packageType).suffix().substring(1);\n+            return ((StandardPackageType)bundleType).suffix().substring(1);\n@@ -111,0 +111,4 @@\n+    public BundleType bundleType() {\n+        return bundleType;\n+    }\n+\n@@ -112,1 +116,1 @@\n-        return packageType;\n+        return (PackageType)bundleType();\n@@ -125,1 +129,1 @@\n-        return new BundlingOperationDescriptor(os(), packageTypeValue(), descriptorVerb.value());\n+        return new BundlingOperationDescriptor(os(), bundleTypeValue(), descriptorVerb.value());\n@@ -202,1 +206,1 @@\n-    private final PackageType packageType;\n+    private final BundleType bundleType;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardBundlingOperation.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+import jdk.jpackage.internal.model.AppImageBundleType;\n+import jdk.jpackage.internal.model.BundleType;\n@@ -63,0 +65,1 @@\n+import jdk.jpackage.internal.model.SelfContainedException;\n@@ -106,1 +109,1 @@\n-    public static final OptionValue<PackageType> TYPE = option(\"type\", PackageType.class).addAliases(\"t\")\n+    public static final OptionValue<BundleType> TYPE = option(\"type\", BundleType.class).addAliases(\"t\")\n@@ -110,4 +113,1 @@\n-                Objects.requireNonNull(str);\n-                return Stream.of(StandardBundlingOperation.values()).filter(bundlingOperation -> {\n-                    return bundlingOperation.packageTypeValue().equals(str);\n-                }).map(StandardBundlingOperation::packageType).findFirst().orElseThrow(IllegalArgumentException::new);\n+                return parseBundleType(str, OperatingSystem.current());\n@@ -118,0 +118,3 @@\n+                b.converter(str -> {\n+                    return parseBundleType(str, context.os());\n+                });\n@@ -236,0 +239,6 @@\n+                    var directoryValidator = b.createValidator().orElseThrow();\n+                    var macBundleValidator = b\n+                            .validatorExceptionFormatString(\"error.parameter-not-mac-bundle\")\n+                            .validator(StandardValidator.IS_VALID_MAC_BUNDLE)\n+                            .createValidator().orElseThrow();\n+                    b.validator(Validator.and(directoryValidator, macBundleValidator));\n@@ -662,0 +671,17 @@\n+    private static BundleType parseBundleType(String str, OperatingSystem appImageOS) {\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(appImageOS);\n+\n+        return Stream.of(StandardBundlingOperation.values()).filter(bundlingOperation -> {\n+            return bundlingOperation.bundleTypeValue().equals(str);\n+        })\n+        .filter(bundlingOperation -> {\n+            \/\/ Skip app image bundle type if it is from another platform.\n+            return !(bundlingOperation.bundleType() instanceof AppImageBundleType)\n+                    || (bundlingOperation.os() == appImageOS);\n+        })\n+        .map(StandardBundlingOperation::bundleType)\n+        .findFirst()\n+        .orElseThrow(IllegalArgumentException::new);\n+    }\n+\n@@ -680,0 +706,1 @@\n+    @SelfContainedException\n@@ -730,2 +757,9 @@\n-        private static Pattern pattern = Pattern.compile(\n-              \"(?:(?:([\\\"'])(?:\\\\\\\\\\\\1|.)*?(?:\\\\1|$))|(?:\\\\\\\\[\\\"'\\\\s]|[^\\\\s]))++\");\n+        private static Pattern PATTERN = Pattern.compile(String.format(\n+                \"(?:(?:%s|%s)|(?:\\\\\\\\[\\\"'\\\\s]|\\\\S))++\",\n+                createPatternComponent('\\''),\n+                createPatternComponent('\\\"')));\n+\n+        private static String createPatternComponent(char quoteChar) {\n+            var str = Character.toString(quoteChar);\n+            return String.format(\"(?:%s(?:\\\\\\\\%s|[^%s])*+(?:%s|$))\", str, str, str, str);\n+        }\n@@ -744,1 +778,1 @@\n-            Matcher m = pattern.matcher(inputString);\n+            Matcher m = PATTERN.matcher(inputString);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOption.java","additions":43,"deletions":9,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -141,0 +142,4 @@\n+    public static Predicate<Path> IS_VALID_MAC_BUNDLE = path -> {\n+        return MacBundle.fromPath(path).isPresent();\n+    };\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardValidator.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.jpackage.internal.model.SelfContainedException;\n@@ -101,0 +102,1 @@\n+    @SelfContainedException\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Utils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.Collection;\n@@ -33,0 +32,1 @@\n+import java.util.stream.Stream;\n@@ -39,2 +39,37 @@\n-    default Validator<T, ? extends Exception> andThen(Validator<T, ? extends Exception> after) {\n-        return reduce(this, after);\n+    default Validator<T, ? extends Exception> and(Validator<T, ? extends Exception> after) {\n+        Objects.requireNonNull(after);\n+        var before = this;\n+        return (optionName, optionValue) -> {\n+            return Stream.concat(\n+                    before.validate(optionName, optionValue).stream(),\n+                    after.validate(optionName, optionValue).stream()\n+            ).toList();\n+        };\n+    }\n+\n+    default Validator<T, ? extends Exception> or(Validator<T, ? extends Exception> after) {\n+        Objects.requireNonNull(after);\n+        var before = this;\n+        return (optionName, optionValue) -> {\n+            var bErrors = before.validate(optionName, optionValue);\n+            if (bErrors.isEmpty()) {\n+                return List.of();\n+            }\n+\n+            var aErrors = after.validate(optionName, optionValue);\n+            if (aErrors.isEmpty()) {\n+                return List.of();\n+            }\n+\n+            return Stream.concat(bErrors.stream(), aErrors.stream()).toList();\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U extends Exception> Validator<T, U> and(Validator<T, U> first, Validator<T, U> second) {\n+        return (Validator<T, U>)first.and(second);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U extends Exception> Validator<T, U> or(Validator<T, U> first, Validator<T, U> second) {\n+        return (Validator<T, U>)first.or(second);\n@@ -254,11 +289,0 @@\n-\n-    @SafeVarargs\n-    private static <T> Validator<T, ? extends Exception> reduce(Validator<T, ? extends Exception>... validators) {\n-        @SuppressWarnings(\"varargs\")\n-        var theValidators = List.of(validators);\n-        return (optionName, optionValue) -> {\n-            return theValidators.stream().map(validator -> {\n-                return validator.validate(optionName, optionValue);\n-            }).flatMap(Collection::stream).map(Exception.class::cast).toList();\n-        };\n-    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Validator.java","additions":39,"deletions":15,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * App image bundle type.\n+ *\n+ * @see StandardPackageType\n+ *\/\n+public enum AppImageBundleType implements BundleType {\n+\n+    WIN_APP_IMAGE(\"bundle-type.win-app\"),\n+    LINUX_APP_IMAGE(\"bundle-type.linux-app\"),\n+    MAC_APP_IMAGE(\"bundle-type.mac-app\"),\n+    ;\n+\n+    private AppImageBundleType(String key) {\n+        this.key = Objects.requireNonNull(key);\n+    }\n+\n+    @Override\n+    public String label() {\n+        return I18N.getString(key);\n+    }\n+\n+    private final String key;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImageBundleType.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal.model;\n-\n-\/**\n- * App image packaging type.\n- *\n- * @see StandardPackageType\n- *\/\n-public final class AppImagePackageType implements PackageType {\n-\n-    private AppImagePackageType() {\n-    }\n-\n-    \/**\n-     * Singleton\n-     *\/\n-    public static final AppImagePackageType APP_IMAGE = new AppImagePackageType();\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImagePackageType.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+\n+\/**\n+ * Generic bundle type. E.g.: application image, rpm, msi are all bundle types.\n+ *\/\n+public sealed interface BundleType permits PackageType, AppImageBundleType {\n+\n+    \/**\n+     * Returns a user-facing label of this bundle type.\n+     * @return a user-facing label of this bundle type.\n+     *\/\n+    String label();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundleType.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.CommandOutputControl.ExecutableAttributes;\n+import jdk.jpackage.internal.util.CommandOutputControl.Result;\n+\n+\/**\n+ * {@link ExecutableAttributes} augmented with printable command output.\n+ *\/\n+public record ExecutableAttributesWithCapturedOutput(ExecutableAttributes execAttrs, String printableOutput)\n+        implements ExecutableAttributes {\n+\n+    public ExecutableAttributesWithCapturedOutput {\n+        Objects.requireNonNull(execAttrs);\n+        Objects.requireNonNull(printableOutput);\n+    }\n+\n+    @Override\n+    public List<String> commandLine() {\n+        return execAttrs.commandLine();\n+    }\n+\n+    public static Result augmentResultWithOutput(Result result, String output) {\n+        var execAttrs = new ExecutableAttributesWithCapturedOutput(result.execAttrs(), output);\n+        return result.copyWithExecutableAttributes(execAttrs);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ExecutableAttributesWithCapturedOutput.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+@SelfContainedException\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/JPackageException.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * Generic package type. E.g.: application image, rpm, msi are all package types.\n+ * Native package type. E.g.: dmg, rpm, msi are all package types.\n@@ -34,1 +34,1 @@\n-public interface PackageType {}\n+public non-sealed interface PackageType extends BundleType {}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/PackageType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Annotation for exceptions with self-contained error messages that don't\n+ * require an additional context, like exception class name or a stack trace.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+@Inherited\n+public @interface SelfContainedException {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/SelfContainedException.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.util.Objects;\n+\n@@ -31,6 +33,6 @@\n-    WIN_MSI(\".msi\"),\n-    WIN_EXE(\".exe\"),\n-    LINUX_DEB(\".deb\"),\n-    LINUX_RPM(\".rpm\"),\n-    MAC_PKG(\".pkg\"),\n-    MAC_DMG(\".dmg\");\n+    WIN_MSI(\"bundle-type.win-msi\", \".msi\"),\n+    WIN_EXE(\"bundle-type.win-exe\", \".exe\"),\n+    LINUX_DEB(\"bundle-type.linux-deb\", \".deb\"),\n+    LINUX_RPM(\"bundle-type.linux-rpm\", \".rpm\"),\n+    MAC_PKG(\"bundle-type.mac-pkg\", \".pkg\"),\n+    MAC_DMG(\"bundle-type.mac-dmg\", \".dmg\");\n@@ -38,2 +40,3 @@\n-    StandardPackageType(String suffix) {\n-        this.suffix = suffix;\n+    StandardPackageType(String key, String suffix) {\n+        this.key = Objects.requireNonNull(key);\n+        this.suffix = Objects.requireNonNull(suffix);\n@@ -51,0 +54,6 @@\n+    @Override\n+    public String label() {\n+        return I18N.getString(key);\n+    }\n+\n+    private final String key;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/StandardPackageType.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-bundle-type.win-exe=EXE Installer Package\n-bundle-type.win-msi=MSI Installer Package\n+bundle-type.win-exe=Windows EXE Installer\n+bundle-type.win-msi=Windows MSI Installer\n@@ -37,2 +37,2 @@\n-bundle-type.linux-deb=DEB Bundle\n-bundle-type.linux-rpm=RPM Bundle\n+bundle-type.linux-deb=Linux DEB Package\n+bundle-type.linux-rpm=Linux RPM Package\n@@ -46,1 +46,6 @@\n-message.creating-app-bundle=Creating app package: {0} in {1}\n+\n+message.create-package=Building output package file...\n+message.create-app-image=Building output application image directory...\n+message.package-created=Succeeded in building output package file\n+message.app-image-created=Succeeded in building output application image directory\n+\n@@ -48,1 +53,1 @@\n-message.bundle-created=Succeeded in building {0} package\n+\n@@ -53,0 +58,5 @@\n+message.failed-command-output-header=Command output:\n+\n+error.command-failed-unexpected-output=Unexpected output from executing the command {0}\n+error.command-failed-unexpected-exit-code=Unexpected exit code {0} from executing the command {1}\n+error.command-failed-timed-out=Timed-out command {0}\n@@ -78,0 +88,1 @@\n+error.parameter-not-mac-bundle=The value \"{0}\" provided for parameter {1} is not a valid macOS bundle\n@@ -85,0 +96,1 @@\n+error.no-extensions-for-file-association=No extensions were specified for File Association number {0}\n@@ -99,1 +111,2 @@\n-error.jlink.failed=jlink failed with: {0}\n+error.output-bundle-cannot-be-overwritten=Output package file \"{0}\" exists and can not be removed.\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Formats command line arguments.\n+ *\/\n+public final class CommandLineFormat {\n+\n+    public String format(List<String> cmdline) {\n+        return cmdline.stream().map(enquoter::applyTo).collect(Collectors.joining(\" \"));\n+    }\n+\n+    public static CommandLineFormat platform() {\n+        var format = new CommandLineFormat();\n+        format.enquoter = Enquoter.identity().setEnquotePredicate(Enquoter.QUOTE_IF_WHITESPACES).setQuoteChar('\\'');\n+        return format;\n+    }\n+\n+    private CommandLineFormat() {\n+    }\n+\n+    private Enquoter enquoter;\n+\n+    public static final Function<List<String>, String> DEFAULT = platform()::format;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CommandLineFormat.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,1949 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.StringReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n+\n+\/**\n+ * Runs commands and processes their stdout and stderr streams.\n+ * <p>\n+ * A command is either a subprocess represented by {@link ProcessBuilder} or a\n+ * tool provided by {@link ToolProvider}.\n+ * <p>\n+ * A command is executed synchronously, and the result of its execution is\n+ * stored in a {@link Result} instance which captures the exit code and any\n+ * saved output streams.\n+ * <p>\n+ * Depending on the configuration, it can save the entire output stream, only\n+ * the first line, or not save the output at all. Stdout and stderr streams can\n+ * be configured independently.\n+ * <p>\n+ * Output streams can be treated as either byte streams or character streams.\n+ *\n+ * <p>\n+ * The table below shows how different parameter combinations affect the content\n+ * written to streams returned by {@link #dumpStdout()} and\n+ * {@link #dumpStderr()} for subsequently executed tools, regardless of whether\n+ * their output streams are saved, or for subprocesses when the output streams\n+ * are saved:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>discardStdout(false) and discardStderr(false)<\/th>\n+ * <th>discardStdout(false) and discardStderr(true)<\/th>\n+ * <th>discardStdout(true) and discardStderr(false)<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT and STDERR interleaved\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDERR;\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT\n+ * <p>\n+ * dumpStderr(): STDERR<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): STDOUT\n+ * <p>\n+ * dumpStderr(): unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * dumpStdout(): unchanged\n+ * <p>\n+ * dumpStderr(): STDERR<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\n+ * <p>\n+ * The table below shows how different parameter combinations affect the content\n+ * written to the native file descriptors associated with {@link System#out} and\n+ * {@link System#err} for subsequently executed subprocesses when the output\n+ * streams are not saved:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>discardStdout(false) and discardStderr(false)<\/th>\n+ * <th>discardStdout(false) and discardStderr(true)<\/th>\n+ * <th>discardStdout(true) and discardStderr(false)<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT and STDERR interleaved\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: STDERR;\n+ * <p>\n+ * The command's STDERR will be written to the stream referenced by\n+ * {@link #dumpStdout()} rather than to the underlying file descriptor\n+ * associated with the Java process's STDOUT\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and dumpOutput(true)<\/th>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT\n+ * <p>\n+ * System.err: STDERR<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: STDOUT\n+ * <p>\n+ * System.err: unchanged<\/td>\n+ * <td>\n+ * <p>\n+ * System.out: unchanged\n+ * <p>\n+ * System.err: STDERR<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\n+ * <p>\n+ * The table below shows how different parameter combinations affect the\n+ * properties of {@link Result} objects returned by\n+ * {@link #execute(ProcessBuilder, long)} or\n+ * {@link #execute(ToolProvider, long, String...)} when processing character\n+ * streams:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>saveOutput(true)<\/th>\n+ * <th>saveFirstLineOfOutput()<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT and STDERR interleaved\n+ * <p>\n+ * findStdout(): {@code Optional.empty()}\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <td>\n+ * <p>\n+ * content(): a single-item list containing the first line of interleaved STDOUT\n+ * and STDERR if the command produced any output; otherwise, an empty list\n+ * <p>\n+ * findStdout(): {@code Optional.empty()}\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT followed by STDERR\n+ * <p>\n+ * stdout(): STDOUT\n+ * <p>\n+ * stderr(): STDERR<\/td>\n+ * <td>\n+ * <p>\n+ * content(): a list containing at most two items: the first line of STDOUT (if\n+ * the command produced any), followed by the first line of STDERR (if the\n+ * command produced any)\n+ * <p>\n+ * stdout(): The first line of STDOUT (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * findStderr(): The first line of STDERR (if the command produced any);\n+ * otherwise an empty list\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDOUT (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDOUT\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * stderr(): an empty list<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDOUT (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * stderr(): an empty list<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDERR\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDERR (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * stdout(): The same as content()\n+ * <p>\n+ * findStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * content(): STDERR\n+ * <p>\n+ * findStdout(): an empty list\n+ * <p>\n+ * stderr(): The same as content()<\/td>\n+ * <td>\n+ * <p>\n+ * content(): The first line of STDERR (if the command produced any); otherwise\n+ * an empty list\n+ * <p>\n+ * findStdout(): an empty list\n+ * <p>\n+ * stderr(): The same as content()<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ * <p>\n+ * The table below shows how different parameter combinations affect the\n+ * properties of {@link Result} objects returned by\n+ * {@link #execute(ProcessBuilder, long)} or\n+ * {@link #execute(ToolProvider, long, String...)} when processing byte streams:\n+ * <table border=\"1\">\n+ * <thead>\n+ * <tr>\n+ * <th><\/th>\n+ * <th>saveOutput(true) or saveFirstLineOfOutput()<\/th>\n+ * <\/tr>\n+ * <\/thead> <tbody>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT and STDERR interleaved\n+ * <p>\n+ * findByteStdout(): {@code Optional.empty()}\n+ * <p>\n+ * findByteStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT followed by STDERR\n+ * <p>\n+ * byteStdout(): STDOUT\n+ * <p>\n+ * byteStderr(): STDERR<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT\n+ * <p>\n+ * byteStdout(): The same as byteContent()\n+ * <p>\n+ * findByteStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(false) and\n+ * discardStderr(true)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDOUT\n+ * <p>\n+ * byteStdout(): The same as byteContent()\n+ * <p>\n+ * byteStderr(): an empty array<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(true) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDERR\n+ * <p>\n+ * byteStdout(): The same as byteContent()\n+ * <p>\n+ * findByteStderr(): {@code Optional.empty()}<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th scope=\"row\">redirectStderr(false) and discardStdout(true) and\n+ * discardStderr(false)<\/th>\n+ * <td>\n+ * <p>\n+ * byteContent(): STDERR\n+ * <p>\n+ * findByteStdout(): an empty array\n+ * <p>\n+ * byteStderr(): The same as byteContent()<\/td>\n+ * <\/tr>\n+ * <\/tbody>\n+ * <\/table>\n+ *\/\n+public final class CommandOutputControl {\n+\n+    public CommandOutputControl() {\n+        outputStreamsControl = new OutputStreamsControl();\n+    }\n+\n+    private CommandOutputControl(CommandOutputControl other) {\n+        flags = other.flags;\n+        outputStreamsControl = other.outputStreamsControl.copy();\n+        dumpStdout = other.dumpStdout;\n+        dumpStderr = other.dumpStderr;\n+        charset = other.charset;\n+        processListener = other.processListener;\n+    }\n+\n+    \/**\n+     * Specifies whether the full output produced by commands subsequently executed\n+     * by this object will be saved.\n+     * <p>\n+     * If {@code v} is {@code true}, both stdout and stderr streams will be saved;\n+     * otherwise, they will not be saved.\n+     * <p>\n+     * This setting is mutually exclusive with {@link #saveFirstLineOfOutput()}.\n+     *\n+     * @param v {@code true} to save the full stdout and stderr streams;\n+     *          {@code false} otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl saveOutput(boolean v) {\n+        return setOutputControl(v, OutputControlOption.SAVE_ALL);\n+    }\n+\n+    \/**\n+     * Returns whether this object will save the complete output of commands\n+     * subsequently executed.\n+     *\n+     * @return {@code true} if this object will save the full output of commands it\n+     *         executes subsequently; {@code false} otherwise\n+     *\/\n+    public boolean isSaveOutput() {\n+        return outputStreamsControl.stdout().saveAll();\n+    }\n+\n+    \/**\n+     * Specifies whether the first line of the output, combined from the stdout and\n+     * stderr streams of commands subsequently executed by this object, will be\n+     * saved.\n+     * <p>\n+     * This setting is mutually exclusive with {@link #saveOutput(boolean)}.\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl saveFirstLineOfOutput() {\n+        return setOutputControl(true, OutputControlOption.SAVE_FIRST_LINE);\n+    }\n+\n+    \/**\n+     * Returns whether this object will save the first line of the output of\n+     * commands subsequently executed.\n+     *\n+     * @return {@code true} if this object will save the first line of the output of\n+     *         commands it executes subsequently; {@code false} otherwise\n+     *\/\n+    public boolean isSaveFirstLineOfOutput() {\n+        return outputStreamsControl.stdout().saveFirstLine();\n+    }\n+\n+    \/**\n+     * Specifies whether this object will dump the output streams from\n+     * subsequently executed commands into the streams returned by\n+     * {@link #dumpStdout()} and {@link #dumpStdout()} methods respectively.\n+     * <p>\n+     * If this object is configured to redirect stderr of subsequently executed\n+     * commands into their stdout ({@code redirectStderr(true)}), their output\n+     * streams will be dumped into the stream returned by {@code dumpStdout()}\n+     * method. Otherwise, their stdout and stderr streams will be dumped into the\n+     * stream returned by {@code dumpStdout()} and {@code dumpStderr()} methods\n+     * respectively.\n+     *\n+     * @param v if output streams from subsequently executed commands will be\n+     *          dumped into streams returned by {@code dumpStdout()} and\n+     *          {@code dumpStderr()} methods respectively\n+     *\n+     * @return this\n+     *\n+     * @see #redirectStderr(boolean)\n+     * @see #dumpStdout()\n+     * @see #dumpStderr()\n+     *\/\n+    public CommandOutputControl dumpOutput(boolean v) {\n+        setFlag(Flag.DUMP, v);\n+        return setOutputControl(v, OutputControlOption.DUMP);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #dumpOutput(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #dumpOutput(boolean)}\n+     *\/\n+    public boolean isDumpOutput() {\n+        return Flag.DUMP.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether this object will treat output streams of subsequently\n+     * executed commands as byte streams rather than character streams.\n+     *\n+     * @param v {@code true} if this object will treat the output streams of\n+     *          subsequently executed commands as byte streams, and {@code false}\n+     *          otherwise\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl binaryOutput(boolean v) {\n+        return setFlag(Flag.BINARY_OUTPUT, v);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #binaryOutput(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #binaryOutput(boolean)}\n+     *\/\n+    public boolean isBinaryOutput() {\n+        return Flag.BINARY_OUTPUT.isSet(flags);\n+    }\n+\n+    \/**\n+     * Sets character encoding that will be applied to the stdout and the stderr\n+     * streams of commands (subprocesses and {@code ToolProvider}-s) subsequently\n+     * executed by this object. The default encoding is {@code UTF-8}.\n+     * <p>\n+     * The value will be ignored if this object is configured for byte output\n+     * streams.\n+     *\n+     * @param v character encoding for output streams of subsequently executed\n+     *          commands\n+     *\n+     * @see #binaryOutput(boolean)\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl charset(Charset v) {\n+        charset = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of\n+     * {@link #charset(Charset)} method on this object, or\n+     * {@link StandardCharsets#UTF_8} if the method has not been called.\n+     *\n+     * @return the character encoding that will be applied to the stdout and stderr\n+     *         streams of commands subsequently executed by this object\n+     *\/\n+    public Charset charset() {\n+        return Optional.ofNullable(charset).orElse(StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Specifies whether the stderr stream will be redirected into the stdout stream\n+     * for commands subsequently executed by this object.\n+     *\n+     * @see ProcessBuilder#redirectErrorStream(boolean)\n+     *\n+     * @param v {@code true} if the stderr stream of commands subsequently executed\n+     *          by this object will be redirected into the stdout stream;\n+     *          {@code false} otherwise\n+     *\n+     * @return this\n+     *\/\n+    public CommandOutputControl redirectStderr(boolean v) {\n+        return setFlag(Flag.REDIRECT_STDERR, v);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #redirectStderr(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #redirectStderr(boolean)}\n+     *\/\n+    public boolean isRedirectStderr() {\n+        return Flag.REDIRECT_STDERR.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether stderr and stdout streams for subprocesses subsequently\n+     * executed by this object will be stored in files.\n+     * <p>\n+     * By default, if an output stream of a subprocess is configured for saving,\n+     * this object will retrieve the content using {@link Process#getInputStream()}\n+     * function for stdout and {@link Process#getErrorStream()} function for stderr.\n+     * However, these functions don't always work correctly due to a\n+     * <a href=\"https:\/\/bugs.openjdk.org\/browse\/JDK-8236825\">JDK-8236825<\/a> bug\n+     * still reproducible on macOS JDK26. The alternative way to get the content of\n+     * output streams of a subprocess is to redirect them into files and read these\n+     * files when the subprocess terminates.\n+     * <p>\n+     * It will use {@code Files.createTempFile(\"jpackageOutputTempFile\", \".tmp\")} to\n+     * create a file for each subprocess's output stream configured for saving. All\n+     * created files will be automatically deleted at the exit of\n+     * {@link #execute(ProcessBuilder, long)} method.\n+     * <p>\n+     * Doesn't apply to executing {@code ToolProvider}-s.\n+     * <p>\n+     * Storing output streams in files takes longer than managing them in memory and\n+     * should be avoided if possible.\n+     *\n+     * @param v {@code true} if this object will use files to store saved output\n+     *          streams of subsequently executed subprocesses; {@code false}\n+     *          otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl storeOutputInFiles(boolean v) {\n+        return setFlag(Flag.STORE_OUTPUT_IN_FILES, v);\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #storeOutputInFiles(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #storeOutputInFiles(boolean)}\n+     *\/\n+    public boolean isStoreOutputInFiles() {\n+        return Flag.STORE_OUTPUT_IN_FILES.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether stdout streams from commands subsequently executed by this\n+     * object will be discarded.\n+     *\n+     * @param v {@code true} if this object will discard stdout streams from\n+     *          commands subsequently executed by this object; {@code false}\n+     *          otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl discardStdout(boolean v) {\n+        setFlag(Flag.DISCARD_STDOUT, v);\n+        outputStreamsControl.stdout().discard(v);\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #discardStdout(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #discardStdout(boolean)}\n+     *\/\n+    public boolean isDiscardStdout() {\n+        return Flag.DISCARD_STDOUT.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies whether stderr streams from commands subsequently executed by this\n+     * object will be discarded.\n+     *\n+     * @param v {@code true} if this object will discard stderr streams from\n+     *          commands subsequently executed by this object; {@code false}\n+     *          otherwise\n+     * @return this\n+     *\/\n+    public CommandOutputControl discardStderr(boolean v) {\n+        setFlag(Flag.DISCARD_STDERR, v);\n+        outputStreamsControl.stderr().discard(v);\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #discardStderr(boolean)}\n+     * method on this object, or {@code false} if the method has not been called.\n+     *\n+     * @return the value passed in the last call of {@link #discardStderr(boolean)}\n+     *\/\n+    public boolean isDiscardStderr() {\n+        return Flag.DISCARD_STDERR.isSet(flags);\n+    }\n+\n+    \/**\n+     * Specifies the stream where stdout streams from commands subsequently executed\n+     * by this object will be dumped.\n+     * <p>\n+     * If the {@code null} is specified and this object configuration is equivalent\n+     * to {@code dumpOutput(true).saveOutput(false).discardStdout(false)} the stdout\n+     * streams from commands subsequently executed by this object will be written\n+     * into the file descriptor associated with the {@code Systsem.out} stream. If\n+     * you want them to be written into the {@code Systsem.out} object, pass the\n+     * {@code Systsem.out} reference into this function.\n+     *\n+     * @param v the stream where stdout streams from commands subsequently executed\n+     *          by this object will be dumped; {@code null} permitted\n+     * @return this\n+     *\/\n+    public CommandOutputControl dumpStdout(PrintStream v) {\n+        dumpStdout = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #dumpStdout(PrintStream)}\n+     * method on this object, or {@link System#out} if the method has not been\n+     * called.\n+     *\n+     * @return the stream where stdout streams from commands subsequently executed\n+     *         by this object will be dumped\n+     *\/\n+    public PrintStream dumpStdout() {\n+        return Optional.ofNullable(dumpStdout).orElse(System.out);\n+    }\n+\n+    \/**\n+     * Specifies the stream where stderr streams from commands subsequently executed\n+     * by this object will be dumped.\n+     * <p>\n+     * If the {@code null} is specified and this object configuration is equivalent\n+     * to\n+     * {@code dumpOutput(true).saveOutput(false).redirectStderr(false).discardStderr(false)}\n+     * the stderr streams from commands subsequently executed by this object will be\n+     * written into the file descriptor associated with the {@code Systsem.err}\n+     * stream. If you want them to be written into the {@code Systsem.err} object,\n+     * pass the {@code Systsem.err} reference into this function.\n+     *\n+     * @param v the stream where stderr streams from commands subsequently executed\n+     *          by this object will be dumped; {@code null} permitted\n+     * @return this\n+     *\/\n+    public CommandOutputControl dumpStderr(PrintStream v) {\n+        dumpStderr = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the value passed in the last call of {@link #dumpStderr(PrintStream)}\n+     * method on this object, or {@link System#err} if the method has not been\n+     * called.\n+     *\n+     * @return the stream where stderr streams from commands subsequently executed\n+     *         by this object will be dumped\n+     *\/\n+    public PrintStream dumpStderr() {\n+        return Optional.ofNullable(dumpStderr).orElse(System.err);\n+    }\n+\n+    \/**\n+     * Sets the callback to be invoked when this object starts a subprocess from\n+     * subsequent {@link #execute(ProcessBuilder, long)} calls.\n+     *\n+     * <p>\n+     * This object maintains a single callback. Calling this method replaces any\n+     * previously set callback.\n+     *\n+     * <p>\n+     * The callback is invoked on the thread that calls\n+     * {@link #execute(ProcessBuilder, long)} after the subprocess's output streams\n+     * begin being pumped.\n+     *\n+     * @param v the callback for notifying a subprocess being started or\n+     *          {@code null}\n+     * @return this\n+     *\/\n+    public CommandOutputControl processListener(Consumer<Process> v) {\n+        processListener = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns an {@code Optional} wrapping the value passed in the last call of\n+     * {@link #processListener(Consumer)} method on this object, or an empty\n+     * {@code Optional} if the method has not been called or {@code null} was passed in the last call.\n+     *\n+     * @return an {@code Optional} wrapping the value passed in the last call of\n+     *         {@link #processListener(Consumer)}\n+     *\/\n+    public Optional<Consumer<Process>> processListener() {\n+        return Optional.ofNullable(processListener);\n+    }\n+\n+    \/**\n+     * Returns a deep copy of this object. Changes to the copy will not affect the\n+     * original.\n+     *\n+     * @return a deep copy of this object\n+     *\/\n+    public CommandOutputControl copy() {\n+        return new CommandOutputControl(this);\n+    }\n+\n+    public interface ExecutableAttributes {\n+        List<String> commandLine();\n+\n+        default String printableCommandLine() {\n+            return CommandLineFormat.DEFAULT.apply(commandLine());\n+        }\n+    }\n+\n+    public sealed interface Executable {\n+\n+        ExecutableAttributes attributes();\n+\n+        Result execute() throws IOException, InterruptedException;\n+\n+        Result execute(long timeout, TimeUnit unit) throws IOException, InterruptedException;\n+    }\n+\n+    public record ProcessAttributes(Optional<Long> pid, List<String> commandLine) implements ExecutableAttributes {\n+        public ProcessAttributes {\n+            Objects.requireNonNull(pid);\n+            commandLine.forEach(Objects::requireNonNull);\n+        }\n+    }\n+\n+    public record ToolProviderAttributes(String name, List<String> args) implements ExecutableAttributes {\n+        public ToolProviderAttributes {\n+            Objects.requireNonNull(name);\n+            args.forEach(Objects::requireNonNull);\n+        }\n+\n+        @Override\n+        public List<String> commandLine() {\n+            return Stream.concat(Stream.of(name), args.stream()).toList();\n+        }\n+    }\n+\n+    public static ExecutableAttributes EMPTY_EXECUTABLE_ATTRIBUTES = new ExecutableAttributes() {\n+        @Override\n+        public List<String> commandLine() {\n+            return List.of(\"<unknown>\");\n+        }\n+    };\n+\n+    public Executable createExecutable(ToolProvider tp, String... args) {\n+        return new ToolProviderExecutable(tp, List.of(args), this);\n+    }\n+\n+    public Executable createExecutable(ProcessBuilder pb) {\n+        return new ProcessExecutable(pb, this);\n+    }\n+\n+    public record Result(\n+            Optional<Integer> exitCode,\n+            Optional<CommandOutput<List<String>>> output,\n+            Optional<CommandOutput<byte[]>> byteOutput,\n+            ExecutableAttributes execAttrs) {\n+\n+        public Result {\n+            Objects.requireNonNull(exitCode);\n+            Objects.requireNonNull(output);\n+            Objects.requireNonNull(byteOutput);\n+            Objects.requireNonNull(execAttrs);\n+        }\n+\n+        public static Builder build() {\n+            return new Builder();\n+        }\n+\n+        public static final class Builder {\n+\n+            public Result create() {\n+                return new Result(\n+                        exitCode,\n+                        Optional.ofNullable(content).map(List::copyOf).map(StringListContent::new).map(c -> {\n+                            return new CommandOutput<List<String>>(Optional.of(c), c.size(), true);\n+                        }),\n+                        Optional.empty(),\n+                        Optional.ofNullable(execAttrs).orElse(EMPTY_EXECUTABLE_ATTRIBUTES));\n+            }\n+\n+            public Builder exitCode(int v) {\n+                exitCode = Optional.of(v);\n+                return this;\n+            }\n+\n+            public Builder noExitCode() {\n+                exitCode = Optional.empty();\n+                return this;\n+            }\n+\n+            public Builder execAttrs(ExecutableAttributes v) {\n+                execAttrs = v;\n+                return this;\n+            }\n+\n+            public Builder content(List<String> v) {\n+                content = v;\n+                return this;\n+            }\n+\n+            public Builder content(String... v) {\n+                return content(List.of(v));\n+            }\n+\n+            private ExecutableAttributes execAttrs;\n+            private List<String> content;\n+            private Optional<Integer> exitCode = Optional.empty();\n+        }\n+\n+        public Result(int exitCode) {\n+            this(Optional.of(exitCode), Optional.empty(), Optional.empty(), EMPTY_EXECUTABLE_ATTRIBUTES);\n+        }\n+\n+        public int getExitCode() {\n+            return exitCode.orElseThrow(() -> {\n+                return new IllegalStateException(\"Exit code is unavailable for timed-out command\");\n+            });\n+        }\n+\n+        public Result expectExitCode(int main, int... other) throws UnexpectedExitCodeException {\n+            return expectExitCode(v -> {\n+                return IntStream.concat(IntStream.of(main), IntStream.of(other)).boxed().anyMatch(Predicate.isEqual(v));\n+            });\n+        }\n+\n+        public Result expectExitCode(Collection<Integer> expected) throws UnexpectedExitCodeException {\n+            return expectExitCode(expected::contains);\n+        }\n+\n+        public Result expectExitCode(IntPredicate expected) throws UnexpectedExitCodeException {\n+            if (!expected.test(getExitCode())) {\n+                throw new UnexpectedExitCodeException(this);\n+            }\n+            return this;\n+        }\n+\n+        public UnexpectedResultException unexpected() {\n+            return new UnexpectedResultException(this);\n+        }\n+\n+        public UnexpectedResultException unexpected(String message) {\n+            return new UnexpectedResultException(this, message);\n+        }\n+\n+        public Optional<List<String>> findContent() {\n+            return output.flatMap(CommandOutput::combined);\n+        }\n+\n+        public Optional<List<String>> findStdout() {\n+            return output.flatMap(CommandOutput::stdout);\n+        }\n+\n+        public Optional<List<String>> findStderr() {\n+            return output.flatMap(CommandOutput::stderr);\n+        }\n+\n+        \/\/ For backward compatibility\n+        public List<String> getOutput() {\n+            return content();\n+        }\n+\n+        public List<String> content() {\n+            return findContent().orElseThrow();\n+        }\n+\n+        public List<String> stdout() {\n+            return findStdout().orElseThrow();\n+        }\n+\n+        public List<String> stderr() {\n+            return findStderr().orElseThrow();\n+        }\n+\n+        public Optional<byte[]> findByteContent() {\n+            return byteOutput.flatMap(CommandOutput::combined);\n+        }\n+\n+        public Optional<byte[]> findByteStdout() {\n+            return byteOutput.flatMap(CommandOutput::stdout);\n+        }\n+\n+        public Optional<byte[]> findByteStderr() {\n+            return byteOutput.flatMap(CommandOutput::stderr);\n+        }\n+\n+        public byte[] byteContent() {\n+            return findByteContent().orElseThrow();\n+        }\n+\n+        public byte[] byteStdout() {\n+            return findByteStdout().orElseThrow();\n+        }\n+\n+        public byte[] byteStderr() {\n+            return findByteStderr().orElseThrow();\n+        }\n+\n+        public Result toCharacterResult(Charset charset, boolean keepByteContent) throws IOException {\n+            Objects.requireNonNull(charset);\n+\n+            if (byteOutput.isEmpty()) {\n+                return this;\n+            }\n+\n+            var theByteOutput = byteOutput.get();\n+\n+            try {\n+                Optional<? extends Content<List<String>>> out;\n+                if (theByteOutput.content().isEmpty()) {\n+                    \/\/ The content is unavailable.\n+                    out = Optional.empty();\n+                } else if (theByteOutput.stdoutContentSize() == 0) {\n+                    \/\/ The content is available, but empty.\n+                    out = Optional.of(new StringListContent(List.of()));\n+                } else if (theByteOutput.interleaved()) {\n+                    \/\/ STDOUT and STDERR streams are interleaved.\n+                    out = theByteOutput.combined().map(data -> {\n+                        return toStringList(data, charset);\n+                    });\n+                } else {\n+                    \/\/ Non-empty STDOUT not interleaved with STDERR.\n+                    out = findByteStdout().map(data -> {\n+                        return toStringList(data, charset);\n+                    });\n+                }\n+\n+                var err = findByteStderr().map(data -> {\n+                    return toStringList(data, charset);\n+                });\n+\n+                var newOutput = combine(out, err, theByteOutput.interleaved);\n+\n+                return new Result(exitCode, Optional.of(newOutput), byteOutput.filter(_ -> keepByteContent), execAttrs);\n+            } catch (UncheckedIOException ex) {\n+                throw ex.getCause();\n+            }\n+        }\n+\n+        public Result copyWithExecutableAttributes(ExecutableAttributes execAttrs) {\n+            return new Result(exitCode, output, byteOutput, Objects.requireNonNull(execAttrs));\n+        }\n+\n+        private static StringListContent toStringList(byte[] data, Charset charset) {\n+            try (var bufReader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(data), charset))) {\n+                return new StringListContent(bufReader.lines().toList());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+    public static sealed class UnexpectedResultException extends IOException {\n+\n+        private UnexpectedResultException(Result value, String message) {\n+            super(Objects.requireNonNull(message));\n+            this.value = Objects.requireNonNull(value);\n+        }\n+\n+        private UnexpectedResultException(Result value) {\n+            this(value, String.format(\"Unexpected result from executing the command %s\",\n+                    value.execAttrs().printableCommandLine()));\n+        }\n+\n+        public Result getResult() {\n+            return value;\n+        }\n+\n+        private final transient Result value;\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    public static final class UnexpectedExitCodeException extends UnexpectedResultException {\n+\n+        public UnexpectedExitCodeException(Result value, String message) {\n+            super(requireExitCode(value), message);\n+        }\n+\n+        public UnexpectedExitCodeException(Result value) {\n+            this(value, String.format(\"Unexpected exit code %d from executing the command %s\",\n+                    requireExitCode(value).getExitCode(), value.execAttrs().printableCommandLine()));\n+        }\n+\n+        private static Result requireExitCode(Result v) {\n+            Objects.requireNonNull(v);\n+            if (v.exitCode().isPresent()) {\n+                return v;\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    public String description() {\n+        var tokens = outputStreamsControl.descriptionTokens();\n+        if (isBinaryOutput()) {\n+            tokens.add(\"byte\");\n+        }\n+        if (redirectRetainedStderr()) {\n+            tokens.add(\"interleave\");\n+        }\n+        return String.join(\"; \", tokens);\n+    }\n+\n+    private Result execute(ProcessBuilder pb, long timeoutMillis)\n+            throws IOException, InterruptedException {\n+\n+        Objects.requireNonNull(pb);\n+\n+        var theCharset = charset();\n+\n+        configureProcessBuilder(pb);\n+\n+        var csc = new CachingStreamsConfig();\n+\n+        var process = pb.start();\n+\n+        BiConsumer<InputStream, PrintStream> gobbler = (in, ps) -> {\n+            try {\n+                if (isBinaryOutput()) {\n+                    try (in) {\n+                        in.transferTo(ps);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                } else {\n+                    try (var bufReader = new BufferedReader(new InputStreamReader(in, theCharset))) {\n+                        bufReader.lines().forEach(ps::println);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                }\n+            } finally {\n+                suppressIOException(ps::flush);\n+            }\n+        };\n+\n+        \/\/ Start fetching process output streams.\n+        \/\/ Do it before waiting for the process termination to avoid deadlocks.\n+\n+        final Optional<CompletableFuture<Void>> stdoutGobbler;\n+        if (mustReadOutputStream(pb.redirectOutput())) {\n+            stdoutGobbler = Optional.of(CompletableFuture.runAsync(() -> {\n+                gobbler.accept(process.getInputStream(), csc.out());\n+            }, gobblerExecutor));\n+        } else {\n+            stdoutGobbler = Optional.empty();\n+        }\n+\n+        final Optional<CompletableFuture<Void>> stderrGobbler;\n+        if (!pb.redirectErrorStream() && mustReadOutputStream(pb.redirectError())) {\n+            stderrGobbler = Optional.of(CompletableFuture.runAsync(() -> {\n+                gobbler.accept(process.getErrorStream(), csc.err());\n+            }, gobblerExecutor));\n+        } else {\n+            stderrGobbler = Optional.empty();\n+        }\n+\n+        processListener().ifPresent(c -> {\n+            c.accept(process);\n+        });\n+\n+        final Optional<Integer> exitCode;\n+        if (timeoutMillis < 0) {\n+            exitCode = Optional.of(process.waitFor());\n+        } else if (!process.waitFor(timeoutMillis, TimeUnit.MILLISECONDS)) {\n+            \/\/ Destroy the process and cancel the process output stream gobblers.\n+            process.destroy();\n+            for (var g : List.of(stdoutGobbler, stderrGobbler)) {\n+                g.ifPresent(future -> {\n+                    future.cancel(true);\n+                });\n+            }\n+            exitCode = Optional.empty();\n+        } else {\n+            exitCode = Optional.of(process.exitValue());\n+        }\n+\n+        try {\n+            if (isStoreOutputInFiles()) {\n+                var stdoutStorage = streamFileSink(pb.redirectOutput());\n+                var stderrStorage = streamFileSink(pb.redirectError());\n+\n+                Function<Path, InputStream> toInputStream = path -> {\n+                    try {\n+                        return Files.newInputStream(path);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                };\n+\n+                try {\n+                    stdoutStorage.map(toInputStream).ifPresent(in -> {\n+                        gobbler.accept(in, csc.out());\n+                    });\n+\n+                    stderrStorage.map(toInputStream).ifPresent(in -> {\n+                        gobbler.accept(in, csc.err());\n+                    });\n+                } finally {\n+                    Consumer<Path> silentDeleter = path -> {\n+                        suppressIOException(Files::delete, path);\n+                    };\n+\n+                    stdoutStorage.ifPresent(silentDeleter);\n+                    stderrStorage.ifPresent(silentDeleter);\n+                }\n+            } else {\n+                stdoutGobbler.ifPresent(CommandOutputControl::join);\n+                stderrGobbler.ifPresent(CommandOutputControl::join);\n+            }\n+        } catch (UncheckedIOException ex) {\n+            throw ex.getCause();\n+        }\n+\n+        return csc.createResult(exitCode, new ProcessAttributes(getPID(process), pb.command()));\n+    }\n+\n+    private Result execute(ToolProvider tp, long timeoutMillis, String... args)\n+            throws IOException, InterruptedException {\n+\n+        var csc = new CachingStreamsConfig();\n+\n+        Optional<Integer> exitCode;\n+        var out = csc.out();\n+        var err = csc.err();\n+        try {\n+            if (timeoutMillis < 0) {\n+                exitCode = Optional.of(tp.run(out, err, args));\n+            } else {\n+                var future = new CompletableFuture<Optional<Integer>>();\n+\n+                var workerThread = Thread.ofVirtual().start(() -> {\n+                    Optional<Integer> result = Optional.empty();\n+                    try {\n+                        result = Optional.of(tp.run(out, err, args));\n+                    } catch (Exception ex) {\n+                        future.completeExceptionally(ex);\n+                        return;\n+                    }\n+                    future.complete(result);\n+                });\n+\n+                try {\n+                    exitCode = future.get(timeoutMillis, TimeUnit.MILLISECONDS);\n+                } catch (ExecutionException ex) {\n+                    \/\/ Rethrow the cause (ex.getCause()) as a RuntimeException.\n+                    \/\/ If `ex.getCause()` returns an Error, ExceptionBox.unbox() will throw it.\n+                    throw ExceptionBox.toUnchecked(ExceptionBox.unbox(ex.getCause()));\n+                } catch (TimeoutException ex) {\n+                    workerThread.interrupt();\n+                    exitCode = Optional.empty();\n+                }\n+            }\n+        } finally {\n+            suppressIOException(out::flush);\n+            suppressIOException(err::flush);\n+        }\n+\n+        return csc.createResult(exitCode, new ToolProviderAttributes(tp.name(), List.of(args)));\n+    }\n+\n+    private CommandOutputControl setOutputControl(boolean set, OutputControlOption v) {\n+        outputStreamsControl.stdout().set(set, v);\n+        outputStreamsControl.stderr().set(set, v);\n+        return this;\n+    }\n+\n+    private CommandOutputControl setFlag(Flag flag, boolean v) {\n+        flags = flag.set(flags, v);\n+        return this;\n+    }\n+\n+    private Optional<Path> streamFileSink(ProcessBuilder.Redirect redirect) {\n+        return Optional.of(redirect)\n+                .filter(Predicate.isEqual(ProcessBuilder.Redirect.DISCARD).negate())\n+                .map(ProcessBuilder.Redirect::file)\n+                .map(File::toPath);\n+    }\n+\n+    private void configureProcessBuilder(ProcessBuilder pb) throws IOException {\n+\n+        var stdoutRedirect = outputStreamsControl.stdout().asProcessBuilderRedirect();\n+        var stderrRedirect = outputStreamsControl.stderr().asProcessBuilderRedirect();\n+\n+        if (!stdoutRedirect.equals(stderrRedirect) && Stream.of(\n+                stdoutRedirect,\n+                stderrRedirect\n+        ).noneMatch(Predicate.isEqual(ProcessBuilder.Redirect.DISCARD)) && redirectRetainedStderr()) {\n+            throw new IllegalStateException(String.format(\n+                    \"Can't redirect stderr into stdout because they have different redirects: stdout=%s; stderr=%s\",\n+                    stdoutRedirect, stderrRedirect));\n+        }\n+\n+        pb.redirectErrorStream(redirectRetainedStderr());\n+        if (replaceStdoutWithStderr()) {\n+            if (stderrRedirect.equals(ProcessBuilder.Redirect.INHERIT)) {\n+                stderrRedirect = ProcessBuilder.Redirect.PIPE;\n+            }\n+            pb.redirectErrorStream(false);\n+        }\n+\n+        stdoutRedirect = mapRedirect(stdoutRedirect);\n+        stderrRedirect = mapRedirect(stderrRedirect);\n+\n+        if (dumpStdout != null && stdoutRedirect.equals(ProcessBuilder.Redirect.INHERIT)) {\n+            stdoutRedirect = ProcessBuilder.Redirect.PIPE;\n+        }\n+\n+        if (dumpStderr != null && stderrRedirect.equals(ProcessBuilder.Redirect.INHERIT)) {\n+            stderrRedirect = ProcessBuilder.Redirect.PIPE;\n+        }\n+\n+        pb.redirectOutput(stdoutRedirect);\n+        pb.redirectError(stderrRedirect);\n+    }\n+\n+    private ProcessBuilder.Redirect mapRedirect(ProcessBuilder.Redirect redirect) throws IOException {\n+        if (isStoreOutputInFiles() && redirect.equals(ProcessBuilder.Redirect.PIPE)) {\n+            var sink = Files.createTempFile(\"jpackageOutputTempFile\", \".tmp\");\n+            return ProcessBuilder.Redirect.to(sink.toFile());\n+        } else {\n+            return redirect;\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if STDERR is not discarded and will be redirected to STDOUT, and {@code false} otherwise.\n+     *\/\n+    private boolean redirectRetainedStderr() {\n+        return isRedirectStderr() && !outputStreamsControl.stderr().discard();\n+    }\n+\n+    \/**\n+     * Returns {@code true} if STDERR will replace STDOUT, and {@code false} otherwise.\n+     * <p>\n+     * STDERR will replace STDOUT if it is redirected and not discarded, and if STDOUT is discarded.\n+     *\/\n+    private boolean replaceStdoutWithStderr() {\n+        return redirectRetainedStderr() && outputStreamsControl.stdout().discard();\n+    }\n+\n+    private static <T> T join(CompletableFuture<T> future, T cancelledValue) {\n+        Objects.requireNonNull(future);\n+        try {\n+            return future.join();\n+        } catch (CancellationException ex) {\n+            return cancelledValue;\n+        } catch (CompletionException ex) {\n+            switch (ExceptionBox.unbox(ex.getCause())) {\n+                case IOException cause -> {\n+                    throw new UncheckedIOException(cause);\n+                }\n+                case UncheckedIOException cause -> {\n+                    throw cause;\n+                }\n+                case Exception cause -> {\n+                    throw ExceptionBox.toUnchecked(cause);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void join(CompletableFuture<Void> future) {\n+        join(future, null);\n+    }\n+\n+    private static boolean mustReadOutputStream(ProcessBuilder.Redirect redirect) {\n+        return redirect.equals(ProcessBuilder.Redirect.PIPE);\n+    }\n+\n+    private static Optional<List<String>> read(OutputControl outputControl, CachingPrintStream cps) throws IOException {\n+        final var bufferAsString = cps.bufferContents();\n+        try (final var bufReader = new BufferedReader(new StringReader(bufferAsString.orElse(\"\")))) {\n+            if (outputControl.saveFirstLine()) {\n+                return Optional.of(bufReader.lines().findFirst().map(List::of).orElseGet(List::of));\n+            } else if (outputControl.saveAll()) {\n+                return Optional.of(bufReader.lines().toList());\n+            } else {\n+                return Optional.empty();\n+            }\n+        } catch (UncheckedIOException ex) {\n+            throw ex.getCause();\n+        }\n+    }\n+\n+    private static Optional<byte[]> readBinary(OutputControl outputControl, CachingPrintStream cps) {\n+        if (outputControl.save()) {\n+            return cps.buf().map(ByteArrayOutputStream::toByteArray).or(() -> {\n+                return Optional.of(new byte[0]);\n+            });\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static <T> CommandOutput<T> combine(\n+            Optional<? extends Content<T>> out,\n+            Optional<? extends Content<T>> err,\n+            boolean interleaved) {\n+\n+        if (out.isEmpty() && err.isEmpty()) {\n+            return CommandOutput.empty();\n+        } else if (out.isEmpty()) {\n+            \/\/ This branch is unreachable because it is impossible to make it save stderr without saving stdout.\n+            \/\/ If streams are configured for saving and stdout is discarded,\n+            \/\/ its saved contents will be an Optional instance wrapping an empty content, not an empty Optional.\n+            throw ExceptionBox.reachedUnreachable();\n+        } else if (err.isEmpty()) {\n+            return new CommandOutput<>(out, Integer.MAX_VALUE, interleaved);\n+        } else {\n+            final var combined = out.get().append(err.get());\n+            return new CommandOutput<>(Optional.of(combined), out.orElseThrow().size(), interleaved);\n+        }\n+    }\n+\n+    private static PrintStream nullPrintStream() {\n+        return new PrintStream(OutputStream.nullOutputStream());\n+    }\n+\n+    private sealed interface Content<T> {\n+        T data();\n+        int size();\n+        Content<T> slice(int from, int to);\n+        Content<T> append(Content<T> other);\n+    }\n+\n+    private record StringListContent(List<String> data) implements Content<List<String>> {\n+        StringListContent {\n+            Objects.requireNonNull(data);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return data.size();\n+        }\n+\n+        @Override\n+        public StringListContent slice(int from, int to) {\n+            return new StringListContent(data.subList(from, to));\n+        }\n+\n+        @Override\n+        public StringListContent append(Content<List<String>> other) {\n+            return new StringListContent(Stream.of(data, other.data()).flatMap(List::stream).toList());\n+        }\n+    }\n+\n+    private record ByteContent(byte[] data) implements Content<byte[]> {\n+        ByteContent {\n+            Objects.requireNonNull(data);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return data.length;\n+        }\n+\n+        @Override\n+        public ByteContent slice(int from, int to) {\n+            return new ByteContent(Arrays.copyOfRange(data, from, to));\n+        }\n+\n+        @Override\n+        public ByteContent append(Content<byte[]> other) {\n+            byte[] combined = new byte[size() + other.size()];\n+            System.arraycopy(data, 0, combined, 0, data.length);\n+            System.arraycopy(other.data(), 0, combined, data.length, other.size());\n+            return new ByteContent(combined);\n+        }\n+    }\n+\n+    private record OutputStreamsControl(OutputControl stdout, OutputControl stderr) {\n+        OutputStreamsControl {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        OutputStreamsControl() {\n+            this(new OutputControl(), new OutputControl());\n+        }\n+\n+        OutputStreamsControl copy() {\n+            return new OutputStreamsControl(stdout.copy(), stderr.copy());\n+        }\n+\n+        List<String> descriptionTokens() {\n+            final List<String> tokens = new ArrayList<>();\n+            if (stdout.save()) { \/\/ Save flags are the same for stdout and stderr, checking stdout is sufficient.\n+                streamsLabel(\"save \", true).ifPresent(tokens::add);\n+            }\n+            if (stdout.dump() || stderr.dump()) {\n+                streamsLabel(\"echo \", true).ifPresent(tokens::add);\n+            }\n+            streamsLabel(\"discard \", false).ifPresent(tokens::add);\n+            if (tokens.isEmpty()) {\n+                \/\/ Unreachable because there is always at least one token in the description.\n+                throw ExceptionBox.reachedUnreachable();\n+            } else {\n+                return tokens;\n+            }\n+        }\n+\n+        private Optional<String> streamsLabel(String prefix, boolean negate) {\n+            Objects.requireNonNull(prefix);\n+            final var str = Stream.of(stdoutLabel(negate), stderrLabel(negate))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::orElseThrow)\n+                    .collect(joining(\"+\"));\n+            if (str.isEmpty()) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(prefix + str);\n+            }\n+        }\n+\n+        private Optional<String> stdoutLabel(boolean negate) {\n+            if ((stdout.discard() && !negate) || (!stdout.discard() && negate)) {\n+                return Optional.of(\"out\");\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        private Optional<String> stderrLabel(boolean negate) {\n+            if ((stderr.discard() && !negate) || (!stderr.discard() && negate)) {\n+                return Optional.of(\"err\");\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+    }\n+\n+    private record CachingPrintStream(PrintStream ps, Optional<ByteArrayOutputStream> buf) {\n+        CachingPrintStream {\n+            Objects.requireNonNull(ps);\n+            Objects.requireNonNull(buf);\n+        }\n+\n+        Optional<String> bufferContents() {\n+            return buf.map(ByteArrayOutputStream::toString);\n+        }\n+\n+        static Builder build(Charset charset) {\n+            return new Builder(charset);\n+        }\n+\n+        static final class Builder {\n+\n+            private Builder(Charset charset) {\n+                this.charset = Objects.requireNonNull(charset);\n+            }\n+\n+            Builder save(boolean v) {\n+                save = v;\n+                return this;\n+            }\n+\n+            Builder discard(boolean v) {\n+                discard = v;\n+                return this;\n+            }\n+\n+            Builder dumpStream(PrintStream v) {\n+                dumpStream = v;\n+                return this;\n+            }\n+\n+            Builder buffer(ByteArrayOutputStream v) {\n+                externalBuffer = v;\n+                return this;\n+            }\n+\n+            CachingPrintStream create() {\n+                final Optional<ByteArrayOutputStream> buf;\n+                if (save && !discard) {\n+                    buf = Optional.ofNullable(externalBuffer).or(() -> {\n+                        return Optional.of(new ByteArrayOutputStream());\n+                    });\n+                } else {\n+                    buf = Optional.empty();\n+                }\n+\n+                final PrintStream ps;\n+                if (buf.isPresent() && dumpStream != null) {\n+                    ps = new PrintStream(new TeeOutputStream(List.of(buf.get(), dumpStream)), true, dumpStream.charset());\n+                } else if (!discard) {\n+                    ps = buf.map(in -> {\n+                        return new PrintStream(in, false, charset);\n+                    }).or(() -> {\n+                        return Optional.ofNullable(dumpStream);\n+                    }).orElseGet(CommandOutputControl::nullPrintStream);\n+                } else {\n+                    ps = nullPrintStream();\n+                }\n+\n+                return new CachingPrintStream(ps, buf);\n+            }\n+\n+            private boolean save;\n+            private boolean discard;\n+            private PrintStream dumpStream;\n+            private ByteArrayOutputStream externalBuffer;\n+            private final Charset charset;\n+        }\n+    }\n+\n+    private final class CachingStreamsConfig {\n+\n+        CachingStreamsConfig() {\n+            out = outputStreamsControl.stdout().buildCachingPrintStream(dumpStdout(), charset()).create();\n+            if (isRedirectStderr()) {\n+                var builder = outputStreamsControl.stderr().buildCachingPrintStream(dumpStdout(), charset());\n+                out.buf().ifPresent(builder::buffer);\n+                err = builder.create();\n+            } else {\n+                err = outputStreamsControl.stderr().buildCachingPrintStream(dumpStderr(), charset()).create();\n+            }\n+        }\n+\n+        Result createResult(Optional<Integer> exitCode, ExecutableAttributes execAttrs) throws IOException {\n+\n+            CommandOutput<List<String>> output;\n+            CommandOutput<byte[]> byteOutput;\n+\n+            CachingPrintStream effectiveOut;\n+            if (out.buf().isEmpty() && isRedirectStderr()) {\n+                effectiveOut = new CachingPrintStream(nullPrintStream(), err.buf());\n+            } else {\n+                effectiveOut = out;\n+            }\n+\n+            if (isBinaryOutput()) {\n+                Optional<ByteContent> outContent, errContent;\n+                if (isRedirectStderr()) {\n+                    outContent = readBinary(outputStreamsControl.stdout(), effectiveOut).map(ByteContent::new);\n+                    errContent = Optional.empty();\n+                } else {\n+                    outContent = readBinary(outputStreamsControl.stdout(), out).map(ByteContent::new);\n+                    errContent = readBinary(outputStreamsControl.stderr(), err).map(ByteContent::new);\n+                }\n+\n+                byteOutput = combine(outContent, errContent, redirectRetainedStderr());\n+                output = null;\n+            } else {\n+                Optional<StringListContent> outContent, errContent;\n+                if (isRedirectStderr()) {\n+                    outContent = read(outputStreamsControl.stdout(), effectiveOut).map(StringListContent::new);\n+                    errContent = Optional.empty();\n+                } else {\n+                    outContent = read(outputStreamsControl.stdout(), out).map(StringListContent::new);\n+                    errContent = read(outputStreamsControl.stderr(), err).map(StringListContent::new);\n+                }\n+\n+                output = combine(outContent, errContent, redirectRetainedStderr());\n+                byteOutput = null;\n+            }\n+\n+            return new Result(exitCode, Optional.ofNullable(output), Optional.ofNullable(byteOutput), execAttrs);\n+        }\n+\n+        PrintStream out() {\n+            return out.ps();\n+        }\n+\n+        PrintStream err() {\n+            return err.ps();\n+        }\n+\n+        private final CachingPrintStream out;\n+        private final CachingPrintStream err;\n+    }\n+\n+    private static final class OutputControl {\n+\n+        OutputControl() {\n+        }\n+\n+        private OutputControl(OutputControl other) {\n+            dump = other.dump;\n+            discard = other.discard;\n+            save = other.save;\n+        }\n+\n+        boolean save() {\n+            return save.isPresent();\n+        }\n+\n+        boolean saveAll() {\n+            return save.orElse(null) == OutputControlOption.SAVE_ALL;\n+        }\n+\n+        boolean saveFirstLine() {\n+            return save.orElse(null) == OutputControlOption.SAVE_FIRST_LINE;\n+        }\n+\n+        boolean discard() {\n+            return discard || (!dump && save.isEmpty());\n+        }\n+\n+        boolean dump() {\n+            return !discard && dump;\n+        }\n+\n+        OutputControl dump(boolean v) {\n+            this.dump = v;\n+            return this;\n+        }\n+\n+        OutputControl discard(boolean v) {\n+            this.discard = v;\n+            return this;\n+        }\n+\n+        OutputControl saveAll(boolean v) {\n+            if (v) {\n+                save = Optional.of(OutputControlOption.SAVE_ALL);\n+            } else {\n+                save = Optional.empty();\n+            }\n+            return this;\n+        }\n+\n+        OutputControl saveFirstLine(boolean v) {\n+            if (v) {\n+                save = Optional.of(OutputControlOption.SAVE_FIRST_LINE);\n+            } else {\n+                save = Optional.empty();\n+            }\n+            return this;\n+        }\n+\n+        OutputControl set(boolean set, OutputControlOption v) {\n+            switch (v) {\n+            case DUMP -> dump(set);\n+            case SAVE_ALL -> saveAll(set);\n+            case SAVE_FIRST_LINE -> saveFirstLine(set);\n+            }\n+            return this;\n+        }\n+\n+        OutputControl copy() {\n+            return new OutputControl(this);\n+        }\n+\n+        ProcessBuilder.Redirect asProcessBuilderRedirect() {\n+            if (discard()) {\n+                return ProcessBuilder.Redirect.DISCARD;\n+            } else if (dump && !save()) {\n+                return ProcessBuilder.Redirect.INHERIT;\n+            } else {\n+                return ProcessBuilder.Redirect.PIPE;\n+            }\n+        }\n+\n+        CachingPrintStream.Builder buildCachingPrintStream(PrintStream dumpStream, Charset charset) {\n+            Objects.requireNonNull(dumpStream);\n+            final var builder = CachingPrintStream.build(charset).save(save()).discard(discard());\n+            if (dump()) {\n+                builder.dumpStream(dumpStream);\n+            }\n+            return builder;\n+        }\n+\n+        private boolean dump;\n+        private boolean discard;\n+        private Optional<OutputControlOption> save = Optional.empty();\n+    }\n+\n+    private record CommandOutput<T>(Optional<? extends Content<T>> content, int stdoutContentSize, boolean interleaved) {\n+\n+        CommandOutput {\n+            Objects.requireNonNull(content);\n+            if (interleaved) {\n+                stdoutContentSize = content.map(Content::size).orElse(-1);\n+            }\n+        }\n+\n+        CommandOutput() {\n+            this(Optional.empty(), 0, false);\n+        }\n+\n+        Optional<T> combined() {\n+            return content.map(Content::data);\n+        }\n+\n+        \/**\n+         * Returns non-empty {@code Optional} if stdout is available and stdout and stderr are not interleaved.\n+         * @return stdout if it can be extracted from the combined output\n+         *\/\n+        Optional<T> stdout() {\n+            if (withoutExtractableStdout()) {\n+                return Optional.empty();\n+            }\n+\n+            final var theContent = content.orElseThrow();\n+            if (stdoutContentSize == theContent.size()) {\n+                return combined();\n+            } else {\n+                return Optional.of(theContent.slice(0, Integer.min(stdoutContentSize, theContent.size())).data());\n+            }\n+        }\n+\n+        \/**\n+         * Returns non-empty {@code Optional} if stderr is available and stdout and stderr are not interleaved.\n+         * @return stderr if it can be extracted from the combined output\n+         *\/\n+        Optional<T> stderr() {\n+            if (withoutExtractableStderr()) {\n+                return Optional.empty();\n+            } else if (stdoutContentSize <= 0) {\n+                return combined();\n+            } else {\n+                final var theContent = content.orElseThrow();\n+                return Optional.of(theContent.slice(stdoutContentSize, theContent.size()).data());\n+            }\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        static <T> CommandOutput<T> empty() {\n+            return (CommandOutput<T>)EMPTY;\n+        }\n+\n+        private boolean withoutExtractableStdout() {\n+            return interleaved || content.isEmpty() || stdoutContentSize < 0;\n+        }\n+\n+        private boolean withoutExtractableStderr() {\n+            return interleaved || content.isEmpty() || stdoutContentSize > content.get().size();\n+        }\n+\n+        private static final CommandOutput<?> EMPTY = new CommandOutput<>();\n+    }\n+\n+    private record ToolProviderExecutable(ToolProvider tp, List<String> args, CommandOutputControl coc) implements Executable {\n+\n+        ToolProviderExecutable {\n+            Objects.requireNonNull(tp);\n+            Objects.requireNonNull(args);\n+            Objects.requireNonNull(coc);\n+        }\n+\n+        @Override\n+        public Result execute() throws IOException, InterruptedException {\n+            return coc.execute(tp, -1, args.toArray(String[]::new));\n+        }\n+\n+        @Override\n+        public Result execute(long timeout, TimeUnit unit) throws IOException, InterruptedException {\n+            return coc.execute(tp, unit.toMillis(timeout), args.toArray(String[]::new));\n+        }\n+\n+        @Override\n+        public ExecutableAttributes attributes() {\n+            return new ToolProviderAttributes(tp.name(), args);\n+        }\n+    }\n+\n+    private record ProcessExecutable(ProcessBuilder pb, CommandOutputControl coc) implements Executable {\n+\n+        ProcessExecutable {\n+            Objects.requireNonNull(pb);\n+            Objects.requireNonNull(coc);\n+        }\n+\n+        @Override\n+        public Result execute() throws IOException, InterruptedException {\n+            return coc.execute(pb, -1L);\n+        }\n+\n+        @Override\n+        public Result execute(long timeout, TimeUnit unit) throws IOException, InterruptedException {\n+            return coc.execute(pb, unit.toMillis(timeout));\n+        }\n+\n+        @Override\n+        public ExecutableAttributes attributes() {\n+            return new ProcessAttributes(Optional.empty(), pb.command());\n+        }\n+    }\n+\n+    private static Optional<Long> getPID(Process p) {\n+        try {\n+            return Optional.of(p.pid());\n+        } catch (UnsupportedOperationException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static void suppressIOException(ThrowingRunnable<IOException> r) {\n+        try {\n+            r.run();\n+        } catch (IOException ex) {}\n+    }\n+\n+    private static <T> void suppressIOException(ThrowingConsumer<T, IOException> c, T value) {\n+        suppressIOException(() -> {\n+            c.accept(value);\n+        });\n+    }\n+\n+    private int flags;\n+    private final OutputStreamsControl outputStreamsControl;\n+    private PrintStream dumpStdout;\n+    private PrintStream dumpStderr;\n+    private Charset charset;\n+    private Consumer<Process> processListener;\n+\n+    \/\/ Executor to run subprocess output stream gobblers.\n+    \/\/ Output stream gobblers should start fetching output streams ASAP after the process starts.\n+    \/\/ No pooling, no waiting.\n+    \/\/ CompletableFuture#runAsync() method starts an output stream gobbler.\n+    \/\/ If used with the default executor, it is known to make WiX3 light.exe create\n+    \/\/ a locked msi file when multiple jpackage tool providers are executed asynchronously.\n+    \/\/ The AsyncTest fails with cryptic java.nio.file.FileSystemException error:\n+    \/\/ jtreg_open_test_jdk_tools_jpackage_share_AsyncTest_java\\\\tmp\\\\jdk.jpackage8108811639097525318\\\\msi\\\\Foo-1.0.msi: The process cannot access the file because it is being used by another process.\n+    \/\/ The remedy for the problem is to use non-pooling executor to run subprocess output stream gobblers.\n+    private final java.util.concurrent.Executor gobblerExecutor = Executors.newVirtualThreadPerTaskExecutor();\n+\n+    private enum OutputControlOption {\n+        SAVE_ALL, SAVE_FIRST_LINE, DUMP\n+    }\n+\n+    private enum Flag {\n+        DUMP                    (0x01),\n+        REDIRECT_STDERR         (0x02),\n+        BINARY_OUTPUT           (0x04),\n+        STORE_OUTPUT_IN_FILES   (0x08),\n+        DISCARD_STDOUT          (0x10),\n+        DISCARD_STDERR          (0x20),\n+        ;\n+\n+        Flag(int value) {\n+            this.value = value;\n+        }\n+\n+        int set(int flags, boolean set) {\n+            if (set) {\n+                return flags | value;\n+            } else {\n+                return flags & ~value;\n+            }\n+        }\n+\n+        boolean isSet(int flags) {\n+            return (flags & value) != 0;\n+        }\n+\n+        private final int value;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CommandOutputControl.java","additions":1949,"deletions":0,"binary":false,"changes":1949,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Add quotes to the given string in a configurable way.\n+ *\/\n+public final class Enquoter {\n+\n+    private Enquoter() {\n+        setQuoteChar('\"');\n+    }\n+\n+    public static Enquoter identity() {\n+        return new Enquoter();\n+    }\n+\n+    public static Enquoter forPropertyValues() {\n+        return new Enquoter()\n+                .setEnquotePredicate(QUOTE_IF_WHITESPACES)\n+                .setEscaper(PREPEND_BACKSLASH);\n+    }\n+\n+    public static Enquoter forShellLiterals() {\n+        return forShellLiterals('\\'');\n+    }\n+\n+    public static Enquoter forShellLiterals(char quoteChar) {\n+        return new Enquoter()\n+                .setQuoteChar(quoteChar)\n+                .setEnquotePredicate(x -> true)\n+                .setEscaper(PREPEND_BACKSLASH);\n+    }\n+\n+    public String applyTo(String v) {\n+        if (!needQuotes.test(v)) {\n+            return v;\n+        } else {\n+            var buf = new StringBuilder();\n+            buf.appendCodePoint(beginQuoteChr);\n+            Optional.ofNullable(escaper).ifPresentOrElse(op -> {\n+                v.codePoints().forEachOrdered(chr -> {\n+                    if (chr == beginQuoteChr || chr == endQuoteChr) {\n+                        op.accept(chr, buf);\n+                    } else {\n+                        buf.appendCodePoint(chr);\n+                    }\n+                });\n+            }, () -> {\n+                buf.append(v);\n+            });\n+            buf.appendCodePoint(endQuoteChr);\n+            return buf.toString();\n+        }\n+    }\n+\n+    public Enquoter setQuoteChar(char chr) {\n+        beginQuoteChr = chr;\n+        endQuoteChr = chr;\n+        return this;\n+    }\n+\n+    public Enquoter setEscaper(BiConsumer<Integer, StringBuilder> v) {\n+        escaper = v;\n+        return this;\n+    }\n+\n+    public Enquoter setEnquotePredicate(Predicate<String> v) {\n+        needQuotes = v;\n+        return this;\n+    }\n+\n+    public static final Predicate<String> QUOTE_IF_WHITESPACES = new Predicate<String>() {\n+        @Override\n+        public boolean test(String t) {\n+            return pattern.matcher(t).find();\n+        }\n+        private final Pattern pattern = Pattern.compile(\"\\\\s\");\n+    };\n+\n+    public static final BiConsumer<Integer, StringBuilder> PREPEND_BACKSLASH = (chr, buf) -> {\n+        buf.append('\\\\');\n+        buf.appendCodePoint(chr);\n+    };\n+\n+    private int beginQuoteChr;\n+    private int endQuoteChr;\n+    private BiConsumer<Integer, StringBuilder> escaper;\n+    private Predicate<String> needQuotes = str -> false;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Enquoter.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * An abstraction of macOS Application bundle.\n+ *\n+ * @see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles\">https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles<\/a>\n+ *\/\n+public record MacBundle(Path root) {\n+\n+    public MacBundle {\n+        Objects.requireNonNull(root);\n+    }\n+\n+    public boolean isValid() {\n+        return Files.isDirectory(contentsDir()) && Files.isDirectory(macOsDir()) && Files.isRegularFile(infoPlistFile());\n+    }\n+\n+    public Path contentsDir() {\n+        return root.resolve(\"Contents\");\n+    }\n+\n+    public Path homeDir() {\n+        return contentsDir().resolve(\"Home\");\n+    }\n+\n+    public Path macOsDir() {\n+        return contentsDir().resolve(\"MacOS\");\n+    }\n+\n+    public Path resourcesDir() {\n+        return contentsDir().resolve(\"Resources\");\n+    }\n+\n+    public Path infoPlistFile() {\n+        return contentsDir().resolve(\"Info.plist\");\n+    }\n+\n+    public static Optional<MacBundle> fromPath(Path path) {\n+        var bundle = new MacBundle(path);\n+        if (bundle.isValid()) {\n+            return Optional.of(bundle);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/MacBundle.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n@@ -314,1 +313,1 @@\n-    public PListReader(byte[] xmlData) throws ParserConfigurationException, SAXException, IOException {\n+    public PListReader(byte[] xmlData) throws SAXException, IOException {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PListReader.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.time.Duration;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+\n+public class RetryExecutor<T, E extends Exception> {\n+\n+    public RetryExecutor(Class<? extends E> exceptionType) {\n+        this.exceptionType = Objects.requireNonNull(exceptionType);\n+        setMaxAttemptsCount(5);\n+        setAttemptTimeout(2, TimeUnit.SECONDS);\n+    }\n+\n+    final public Class<? extends E> exceptionType() {\n+        return exceptionType;\n+    }\n+\n+    public RetryExecutor<T, E> setExecutable(ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> v) {\n+        executable = v;\n+        return this;\n+    }\n+\n+    final public RetryExecutor<T, E> setExecutable(ThrowingSupplier<T, E> v) {\n+        if (v != null) {\n+            setExecutable(_ -> {\n+                return v.get();\n+            });\n+        } else {\n+            executable = null;\n+        }\n+        return this;\n+    }\n+\n+    public RetryExecutor<T, E> setMaxAttemptsCount(int v) {\n+        attempts = v;\n+        return this;\n+    }\n+\n+    final public RetryExecutor<T, E> setAttemptTimeout(long v, TimeUnit unit) {\n+        return setAttemptTimeout(Duration.of(v, unit.toChronoUnit()));\n+    }\n+\n+    public RetryExecutor<T, E> setAttemptTimeout(Duration v) {\n+        timeout = v;\n+        return this;\n+    }\n+\n+    public RetryExecutor<T, E> setExceptionMapper(Function<E, RuntimeException> v) {\n+        toUnchecked = v;\n+        return this;\n+    }\n+\n+    public RetryExecutor<T, E> setSleepFunction(Consumer<Duration> v) {\n+        sleepFunction = v;\n+        return this;\n+    }\n+\n+    final public RetryExecutor<T, E> mutate(Consumer<RetryExecutor<T, E>> mutator) {\n+        mutator.accept(this);\n+        return this;\n+    }\n+\n+    public T execute() throws E {\n+        var curExecutable = executable();\n+        T result = null;\n+        var attemptIter = new DefaultContext();\n+        while (attemptIter.hasNext()) {\n+            attemptIter.next();\n+            try {\n+                result = curExecutable.apply(attemptIter);\n+                break;\n+            } catch (Exception ex) {\n+                if (!exceptionType.isInstance(ex)) {\n+                    throw ExceptionBox.toUnchecked(ex);\n+                } else if (attemptIter.isLastAttempt()) {\n+                    \/\/ No more attempts left. This is fatal.\n+                    throw exceptionType.cast(ex);\n+                } else {\n+                    curExecutable = executable();\n+                }\n+            }\n+\n+            sleep();\n+        }\n+\n+        return result;\n+    }\n+\n+    final public T executeUnchecked() {\n+        try {\n+            return execute();\n+        } catch (Error | RuntimeException t) {\n+            throw t;\n+        } catch (Exception ex) {\n+            if (exceptionType.isInstance(ex)) {\n+                throw Optional.ofNullable(toUnchecked).orElse(ExceptionBox::toUnchecked).apply(exceptionType.cast(ex));\n+            } else {\n+                \/\/ Unreachable unless it is a direct subclass of Throwable,\n+                \/\/ which is not Error or Exception which should not happen.\n+                throw ExceptionBox.reachedUnreachable();\n+            }\n+        }\n+    }\n+\n+    public interface Context<T> {\n+        boolean isLastAttempt();\n+        int attempt();\n+        T executor();\n+    }\n+\n+    private final class DefaultContext implements Context<RetryExecutor<T, E>>, Iterator<Void> {\n+\n+        @Override\n+        public boolean isLastAttempt() {\n+            return !hasNext();\n+        }\n+\n+        @Override\n+        public int attempt() {\n+            return attempt;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return (attempts - attempt) > 1;\n+        }\n+\n+        @Override\n+        public Void next() {\n+            attempt++;\n+            return null;\n+        }\n+\n+        @Override\n+        public RetryExecutor<T, E> executor() {\n+            return RetryExecutor.this;\n+        }\n+\n+        private int attempt = -1;\n+    }\n+\n+    private ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> executable() {\n+        return Optional.ofNullable(executable).orElseThrow(() -> {\n+            return new IllegalStateException(\"No executable\");\n+        });\n+    }\n+\n+    private void sleep() {\n+        Optional.ofNullable(timeout).ifPresent(Optional.ofNullable(sleepFunction).orElseGet(() -> {\n+            return toConsumer(Thread::sleep);\n+        }));\n+    }\n+\n+    private final Class<? extends E> exceptionType;\n+    private ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> executable;\n+    private int attempts;\n+    private Duration timeout;\n+    private Function<E, RuntimeException> toUnchecked;\n+    private Consumer<Duration> sleepFunction;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/RetryExecutor.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.io.Closeable;\n+import java.io.Flushable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+\n+public final class TeeOutputStream extends OutputStream {\n+\n+    public TeeOutputStream(Iterable<OutputStream> items) {\n+        items.forEach(Objects::requireNonNull);\n+        this.items = items;\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        for (final var item : items) {\n+            item.write(b);\n+        }\n+    }\n+\n+    @Override\n+    public void write(byte[] b) throws IOException {\n+        for (final var item : items) {\n+            item.write(b);\n+        }\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        for (final var item : items) {\n+            item.write(b, off, len);\n+        }\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        forEach(Flushable::flush);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        forEach(Closeable::close);\n+    }\n+\n+    private void forEach(ThrowingConsumer<OutputStream, IOException> c) throws IOException {\n+        IOException firstEx = null;\n+        for (final var item : items) {\n+            try {\n+                c.accept(item);\n+            } catch (IOException e) {\n+                if (firstEx == null) {\n+                    firstEx = e;\n+                }\n+            }\n+        }\n+        if (firstEx != null) {\n+            throw firstEx;\n+        }\n+    }\n+\n+    private final Iterable<OutputStream> items;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/TeeOutputStream.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.Application;\n@@ -39,0 +37,3 @@\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.util.Enquoter;\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/UnixLaunchersAsServices.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.jpackage.internal.util.Result;\n@@ -39,5 +38,7 @@\n-        super(build()\n-                .defaultOperation(CREATE_WIN_EXE)\n-                .bundler(CREATE_WIN_APP_IMAGE, WinBundlingEnvironment::createAppImage)\n-                .bundler(CREATE_WIN_EXE, LazyLoad::sysEnv, WinBundlingEnvironment::createExePackage)\n-                .bundler(CREATE_WIN_MSI, LazyLoad::sysEnv, WinBundlingEnvironment::createMsiPackage));\n+        super(build().mutate(builder -> {\n+            var sysEnv = runOnce(WinSystemEnvironment::create);\n+\n+            builder\n+            .bundler(CREATE_WIN_EXE, sysEnv, WinBundlingEnvironment::createExePackage)\n+            .bundler(CREATE_WIN_MSI, sysEnv, WinBundlingEnvironment::createMsiPackage);\n+        }).defaultOperation(CREATE_WIN_EXE).bundler(CREATE_WIN_APP_IMAGE, WinBundlingEnvironment::createAppImage));\n@@ -101,8 +102,0 @@\n-    private static final class LazyLoad {\n-\n-        static Result<WinSystemEnvironment> sysEnv() {\n-            return SYS_ENV;\n-        }\n-\n-        private static final Result<WinSystemEnvironment> SYS_ENV = WinSystemEnvironment.create();\n-    }\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinBundlingEnvironment.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,2 +82,0 @@\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", outputDir.toAbsolutePath()));\n-\n@@ -105,2 +103,0 @@\n-\n-        Log.verbose(I18N.format(\"message.output-location\", outputDir.toAbsolutePath()));\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExePackager.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,0 @@\n-        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackager.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,2 +236,2 @@\n-                        final var exec = Executor.of(toolPath.toString(), \"-?\").setQuiet(true).saveOutput(true);\n-                        final var exitCode = exec.execute();\n+                        final var result = Executor.of(toolPath.toString(), \"-?\").setQuiet(true).saveOutput(true).execute();\n+                        final var exitCode = result.getExitCode();\n@@ -239,1 +239,1 @@\n-                            final var output = exec.getOutput();\n+                            final var output = result.getOutput();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,0 @@\n-message.outputting-to-location=Generating EXE for installer to: {0}.\n-message.output-location=Installer (.exe) saved to: {0}\n@@ -67,2 +65,0 @@\n-message.generating-msi=Generating MSI: {0}.\n-\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.io.FileWriter;\n+import java.io.IOException;\n@@ -27,0 +29,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -30,0 +34,3 @@\n+    static final String STYLE_SHEET_FILENAME = \"failure-handler-style.css\";\n+    static final String SCRIPT_FILENAME = \"failure-handler-script.js\";\n+\n@@ -33,3 +40,26 @@\n-    public HtmlPage(PrintWriter writer) {\n-        Objects.requireNonNull(writer, \"writer cannot be null\");\n-        this.writer = writer;\n+    \/**\n+     * Constructs a {@code HtmlPage}\n+     *\n+     * @param dir          The directory into which the HTML file and related resources will be created\n+     * @param htmlFileName The HTML file name\n+     * @param append       if {@code true} then the content will be appended to the file represented\n+     *                     by the {@code htmlFileName}, else the {@code htmlFileName} will be overwritten\n+     *                     with the new content\n+     * @throws IllegalArgumentException if {@code dir} is not a directory or if the\n+     *                                  {@code htmlFileName} is {@linkplain String#isBlank() blank}\n+     * @throws IOException if there is an error constructing file resource(s) for this HTML page\n+     *\/\n+    public HtmlPage(final Path dir, final String htmlFileName, final boolean append)\n+            throws IOException {\n+        Objects.requireNonNull(dir, \"directory cannot be null\");\n+        Objects.requireNonNull(htmlFileName, \"HTML file name cannot be null\");\n+        if (!Files.isDirectory(dir)) {\n+            throw new IllegalArgumentException(dir + \" is not a directory\");\n+        }\n+        if (htmlFileName.isBlank()) {\n+            throw new IllegalArgumentException(\"HTML file name cannot be blank\");\n+        }\n+        final FileWriter fileWriter = new FileWriter(dir.resolve(htmlFileName).toFile(), append);\n+        this.writer = new PrintWriter(fileWriter, true);\n+        createScriptFile(dir);\n+        createStyleSheetFile(dir);\n@@ -39,0 +69,1 @@\n+\n@@ -47,0 +78,67 @@\n+\n+    private static void createStyleSheetFile(final Path destDir) throws IOException {\n+        final Path styleSheet = destDir.resolve(STYLE_SHEET_FILENAME);\n+        if (Files.exists(styleSheet)) {\n+            return;\n+        }\n+        final String content = \"\"\"\n+                div { display:none;}\n+                \"\"\";\n+        Files.writeString(styleSheet, content);\n+    }\n+\n+    private static void createScriptFile(final Path destDir) throws IOException {\n+        final Path script = destDir.resolve(SCRIPT_FILENAME);\n+        if (Files.exists(script)) {\n+            return;\n+        }\n+        final String content = \"\"\"\n+                function doShow(e) {\n+                  while (e != null) {\n+                    if (e.tagName == 'DIV') {\n+                      e.style.display = 'block';\n+                    }\n+                    e = e.parentNode;\n+                  }\n+                }\n+\n+                function showHandler(event) {\n+                  elementId = this.dataset.show;\n+                  elementToShow = document.getElementById(elementId);\n+                  doShow(elementToShow);\n+                }\n+\n+                function toggleHandler(event) {\n+                  toggleElementId = this.dataset.toggle;\n+                  elementToToggle = document.getElementById(toggleElementId);\n+                  d = elementToToggle.style.display;\n+                  if (d == 'block') {\n+                    elementToToggle.style.display = 'none';\n+                  } else {\n+                    doShow(elementToToggle);\n+                  }\n+                }\n+\n+                function bodyLoadHandler() {\n+                  const index = location.href.indexOf(\"#\");\n+                  if (index != -1) {\n+                    doShow(document.getElementById(location.href.substring(index + 1)));\n+                  }\n+                  \/\/ elements that require the \"toggleHandler\" function to be registered\n+                  \/\/ as an event handler for the onclick event\n+                  const requiringToggleHandler = document.querySelectorAll(\"[data-toggle]\");\n+                  for (const e of requiringToggleHandler) {\n+                    e.addEventListener(\"click\", toggleHandler);\n+                  }\n+                  \/\/ elements that require the \"showHandler\" function to be registered\n+                  \/\/ as an event handler for the onclick event\n+                  const requiringShowHandler = document.querySelectorAll(\"[data-show]\");\n+                  for (const e of requiringShowHandler) {\n+                    e.addEventListener(\"click\", showHandler);\n+                  }\n+                }\n+                \/\/ register a onload event handler\n+                window.addEventListener(\"DOMContentLoaded\", bodyLoadHandler);\n+                \"\"\";\n+        Files.writeString(script, content);\n+    }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/HtmlPage.java","additions":102,"deletions":4,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,35 +60,9 @@\n-            this.pw.println(\"<style>\\n\"\n-                    + \"div { display:none;}\\n\"\n-                    + \"<\/style>\\n\"\n-                    + \"\\n\"\n-                    + \"<script>\\n\"\n-                    + \"function show(e) {\\n\"\n-                    + \"  while (e != null) {\\n\"\n-                    + \"    if (e.tagName == 'DIV') {\\n\"\n-                    + \"      e.style.display = 'block';\\n\"\n-                    + \"    }\\n\"\n-                    + \"    e = e.parentNode;\\n\"\n-                    + \"  }\\n\"\n-                    + \"}\\n\"\n-                    + \"\\n\"\n-                    + \"function toggle(id) {\\n\"\n-                    + \"  e = document.getElementById(id);\\n\"\n-                    + \"  d = e.style.display;\\n\"\n-                    + \"  if (d == 'block') {\\n\"\n-                    + \"    e.style.display = 'none';\\n\"\n-                    + \"  } else {\\n\"\n-                    + \"    show(e);\\n\"\n-                    + \"  }\\n\"\n-                    + \"}\\n\"\n-                    + \"\\n\"\n-                    + \"function main() {\\n\"\n-                    + \"  index = location.href.indexOf(\\\"#\\\");\"\n-                    + \"  if (index != -1) {\\n\"\n-                    + \"    show(document.getElementById(location.href.substring(index + 1)));\\n\"\n-                    + \"  }\\n\"\n-                    + \"}\\n\"\n-                    + \"\\n\"\n-                    + \"<\/script>\\n\"\n-                    + \"<\/head>\");\n-\n-            this.pw.println(\"<body onload='main()'>\");\n+\n+            this.pw.println(\"<head>\");\n+            this.pw.println(\n+                    \"<link href=\\\"\" + HtmlPage.STYLE_SHEET_FILENAME + \"\\\" rel=\\\"stylesheet\\\" type=\\\"text\/css\\\" \/>\");\n+            this.pw.println(\n+                    \"<script src=\\\"\" + HtmlPage.SCRIPT_FILENAME + \"\\\" type=\\\"text\/javascript\\\" ><\/script>\");\n+            this.pw.println(\"<\/head>\");\n+\n+            this.pw.println(\"<body>\");\n@@ -149,1 +123,1 @@\n-        pw.printf(\"<a href=\\\"#%1$s\\\" onclick=\\\"show(document.getElementById('%1$s')); return true;\\\">%2$s<\/a>%n\",\n+        pw.printf(\"<a href=\\\"#%1$s\\\" data-show=\\\"%1$s\\\" >%2$s<\/a>%n\",\n@@ -191,1 +165,1 @@\n-            pw.printf(\"<li><a name='%1$s'\/><a href='#%1$s' onclick=\\\"toggle('%1$s'); return false;\\\">%2$s<\/a><div id='%1$s'><code><pre>\",\n+            pw.printf(\"<li><a name='%1$s'\/><a href='#%1$s' data-toggle=\\\"%1$s\\\" >%2$s<\/a><div id='%1$s'><code><pre>\",\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/HtmlSection.java","additions":12,"deletions":38,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.io.File;\n@@ -39,0 +38,2 @@\n+import java.util.List;\n+import java.util.stream.Stream;\n@@ -88,5 +89,9 @@\n-            Files.walk(workDir)\n-                    .filter(Files::isRegularFile)\n-                    .filter(f -> (f.getFileName().toString().contains(\"core\") || f.getFileName().toString().contains(\"mdmp\")))\n-                    .forEach(core -> gatherCoreInfo(workDir, name,\n-                            core, log, gathererFactory.getCoreInfoGatherer()));\n+            \/\/ generate a cores.html file after parsing the core dump files (if any)\n+            List<Path> coreFiles;\n+            try (Stream<Path> paths = Files.walk(workDir)) {\n+                coreFiles = paths.filter(Files::isRegularFile)\n+                        .filter(f -> (f.getFileName().toString().contains(\"core\")\n+                                || f.getFileName().toString().contains(\"mdmp\")))\n+                        .toList();\n+            }\n+            gatherCoreInfo(workDir, name, coreFiles, log, gathererFactory.getCoreInfoGatherer());\n@@ -106,5 +111,6 @@\n-    private void gatherCoreInfo(Path workDir, String name, Path core, PrintWriter log,\n-                               CoreInfoGatherer gatherer) {\n-        File output = workDir.resolve(CORES_OUTPUT).toFile();\n-        try (HtmlPage html = new HtmlPage(new PrintWriter(\n-                new FileWriter(output, true), true))) {\n+    private void gatherCoreInfo(Path workDir, String name, List<Path> coreFiles,\n+                                PrintWriter log, CoreInfoGatherer gatherer) {\n+        if (coreFiles.isEmpty()) {\n+            return;\n+        }\n+        try (HtmlPage html = new HtmlPage(workDir, CORES_OUTPUT, true)) {\n@@ -113,1 +119,4 @@\n-                gatherer.gatherCoreInfo(html.getRootSection(), core);\n+                \/\/ gather information from the contents of each core file\n+                for (Path coreFile : coreFiles) {\n+                    gatherer.gatherCoreInfo(html.getRootSection(), coreFile);\n+                }\n@@ -116,2 +125,2 @@\n-            log.printf(\"ERROR: exception in observer on getting environment \"\n-                    + \"information %s:\", name);\n+            log.printf(\"ERROR: exception in %s observer while gathering information from\"\n+                    + \" core dump file\", name);\n@@ -124,3 +133,1 @@\n-        File output = workDir.resolve(ENVIRONMENT_OUTPUT).toFile();\n-        try (HtmlPage html = new HtmlPage(new PrintWriter(\n-                new FileWriter(output, true), true))) {\n+        try (HtmlPage html = new HtmlPage(workDir, ENVIRONMENT_OUTPUT, true)) {\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherDiagnosticInfoObserver.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,10 +72,1 @@\n-\n-            File output = workDir.resolve(OUTPUT_FILENAME).toFile();\n-            try {\n-                PrintWriter pw = new PrintWriter(new FileWriter(output, true), true);\n-                runGatherer(name, workDir, actionsLog, pw, pid);\n-            } catch (IOException e) {\n-                actionsLog.printf(\"IOException: cannot open output file[%s] : %s\",\n-                        output, e.getMessage());\n-                e.printStackTrace(actionsLog);\n-            }\n+            runGatherer(name, actionsLog, pid);\n@@ -93,3 +84,3 @@\n-    private void runGatherer(String name, Path workDir, PrintWriter log,\n-                             PrintWriter out, long pid) {\n-        try (HtmlPage html = new HtmlPage(out)) {\n+    private void runGatherer(String name, PrintWriter log, long pid) {\n+        Path workDir = outputDir.toPath();\n+        try (HtmlPage html = new HtmlPage(workDir, OUTPUT_FILENAME, true)) {\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherProcessInfoTimeoutHandler.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -34,1 +35,0 @@\n-#include <stdlib.h>\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,1 +205,1 @@\n-TEST(opto, canonicalize_constraints) {\n+TEST_VM(opto, canonicalize_constraints) {\n","filename":"test\/hotspot\/gtest\/opto\/test_rangeinference.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,0 +165,29 @@\n+template<typename T>\n+struct AtomicIntegerCmpsetTestSupport {\n+  Atomic<T> _test_value;\n+\n+  AtomicIntegerCmpsetTestSupport() : _test_value{} {}\n+\n+  void test() {\n+    T zero = 0;\n+    T five = 5;\n+    T ten = 10;\n+    _test_value.store_relaxed(zero);\n+    EXPECT_FALSE(_test_value.compare_set(five, ten));\n+    EXPECT_EQ(zero, _test_value.load_relaxed());\n+    EXPECT_TRUE(_test_value.compare_set(zero, ten));\n+    EXPECT_EQ(ten, _test_value.load_relaxed());\n+  }\n+};\n+\n+TEST_VM(AtomicIntegerTest, cmpset_int32) {\n+  using Support = AtomicIntegerCmpsetTestSupport<int32_t>;\n+  Support().test();\n+}\n+\n+TEST_VM(AtomicIntegerTest, cmpset_int64) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  using Support = AtomicIntegerCmpsetTestSupport<int64_t>;\n+  Support().test();\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -29,1 +30,0 @@\n-#include <stdlib.h>\n","filename":"test\/hotspot\/gtest\/unittest.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -32,2 +33,0 @@\n-#include <stdlib.h>\n-\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_setops.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8284883\n+ * @bug 8284883 8374570\n@@ -36,0 +36,2 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation -Xbatch\n+ *   -XX:+EnableX86ECoreOpts -XX:MaxVectorSize=8 -XX:UseAVX=3 compiler.c2.ClearArray\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/ClearArray.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.igvn;\n+\n+\/*\n+ * @test\n+ * @bug 8372302\n+ * @summary ModINode::Ideal and ModLNode::Ideal use an intermediate \"hook\" node\n+ *          to keep stuff alive between phase->transform(...) calls. In some cases,\n+ *          this node is not properly deleted before returning, causing failure\n+ *          in the verification because the node count has changed. This test\n+ *          ensures that the intermediate node gets destroyed before returning.\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,${test.main.class}::test*\n+ *      -XX:VerifyIterativeGVN=1110\n+ *      ${test.main.class}\n+ * @run main ${test.main.class}\n+ *\n+ *\/\n+\n+public class TestModIdealCreatesUselessNode {\n+    static int test0(int x) {\n+        return x % Integer.MIN_VALUE;\n+    }\n+\n+    static long test1(long x) {\n+        return x % Long.MIN_VALUE;\n+    }\n+\n+    public static void main(String[] args) {\n+        test0(0);\n+        test1(0L);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/igvn\/TestModIdealCreatesUselessNode.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.escapeAnalysis;\n+\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 8374435\n+ * @summary assert during escape analysis when splitting a Load through a Phi because the input of\n+ *          the result Phi is a Load not from an AddP\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-UseCompressedOops ${test.main.class}\n+ *\/\n+public class TestSplitLoadThroughPhiDuringEA {\n+    static class Holder {\n+        Object o;\n+    }\n+\n+    public static void main(String[] args) {\n+        Object o = new Object();\n+        Holder h = new Holder();\n+        for (int i = 0; i < 20000; i++) {\n+            test(true, h, o);\n+            test(false, h, o);\n+        }\n+    }\n+\n+    private static Object test(boolean b, Holder h, Object o) {\n+        h = Objects.requireNonNull(h);\n+        if (b) {\n+            h = new Holder();\n+            \/\/ This access has the pattern LoadP -> LoadP, which upsets the compiler because the\n+            \/\/ pointer input of a LoadP is not an AddP\n+            h.o = o.getClass();\n+        }\n+        return h.o;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestSplitLoadThroughPhiDuringEA.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -207,1 +207,5 @@\n-        Asserts.assertEquals(INT_CONST_1 \/ INT_CONST_2, testIntConstantFolding());\n+        if (INT_CONST_2 == 0) {\n+            Asserts.assertThrows(ArithmeticException.class, () -> testIntConstantFolding());\n+        } else {\n+            Asserts.assertEquals(INT_CONST_1 \/ INT_CONST_2, testIntConstantFolding());\n+        }\n@@ -444,1 +448,5 @@\n-        Asserts.assertEquals(LONG_CONST_1 \/ LONG_CONST_2, testLongConstantFolding());\n+        if (LONG_CONST_2 == 0L) {\n+            Asserts.assertThrows(ArithmeticException.class, () -> testLongConstantFolding());\n+        } else {\n+            Asserts.assertEquals(LONG_CONST_1 \/ LONG_CONST_2, testLongConstantFolding());\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/IntegerDivValueTests.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373134\n+ * @summary Verify that min\/max add identity optimizations get applied correctly\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package compiler.igvn;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.scope;\n+\n+public class TestMinMaxIdentity {\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"compiler.igvn.templated.MinMaxIdentity\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile(\"--add-modules=jdk.incubator.vector\");\n+\n+        comp.invoke(\"compiler.igvn.templated.MinMaxIdentity\", \"main\", new Object[] {new String[] {\n+            \"--add-modules=jdk.incubator.vector\",\n+            \"--add-opens\", \"jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\"\n+        }});\n+    }\n+\n+    private static String generate(CompileFramework comp) {\n+        \/\/ Create a list to collect all tests.\n+        List<TemplateToken> testTemplateTokens = new ArrayList<>();\n+\n+        Stream.of(MinMaxOp.values())\n+            .flatMap(MinMaxOp::generate)\n+            .forEach(testTemplateTokens::add);\n+\n+        Stream.of(Fp16MinMaxOp.values())\n+            .flatMap(Fp16MinMaxOp::generate)\n+            .forEach(testTemplateTokens::add);\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"compiler.igvn.templated\", \"MinMaxIdentity\",\n+            \/\/ List of imports.\n+            Set.of(\"jdk.incubator.vector.Float16\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+\n+    enum MinMaxOp {\n+        MIN_D(\"min\", CodeGenerationDataNameType.doubles()),\n+        MAX_D(\"max\", CodeGenerationDataNameType.doubles()),\n+        MIN_F(\"min\", CodeGenerationDataNameType.floats()),\n+        MAX_F(\"max\", CodeGenerationDataNameType.floats()),\n+        MIN_I(\"min\", CodeGenerationDataNameType.ints()),\n+        MAX_I(\"max\", CodeGenerationDataNameType.ints()),\n+        MIN_L(\"min\", CodeGenerationDataNameType.longs()),\n+        MAX_L(\"max\", CodeGenerationDataNameType.longs());\n+\n+        final String functionName;\n+        final PrimitiveType type;\n+\n+        MinMaxOp(String functionName, PrimitiveType type) {\n+            this.functionName = functionName;\n+            this.type = type;\n+        }\n+\n+        Stream<TemplateToken> generate() {\n+            return Stream.of(template(\"a\", \"b\"), template(\"b\", \"a\")).\n+                map(Template.ZeroArgs::asToken);\n+        }\n+\n+        private Template.ZeroArgs template(String arg1, String arg2) {\n+            return Template.make(() -> scope(\n+                let(\"boxedTypeName\", type.boxedTypeName()),\n+                let(\"op\", name()),\n+                let(\"type\", type.name()),\n+                let(\"functionName\", functionName),\n+                let(\"arg1\", arg1),\n+                let(\"arg2\", arg2),\n+                \"\"\"\n+                @Test\n+                @IR(counts = {IRNode.#op, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type $test(#type #arg1, #type #arg2) {\n+                    int i;\n+                    for (i = -10; i < 1; i++) {\n+                    }\n+                    #type c = a * i;\n+                    return #boxedTypeName.#functionName(a, #boxedTypeName.#functionName(b, c));\n+                }\n+                \"\"\"\n+            ));\n+        }\n+    }\n+\n+    enum Fp16MinMaxOp {\n+        MAX_HF(\"max\"),\n+        MIN_HF(\"min\");\n+\n+        final String functionName;\n+\n+        Fp16MinMaxOp(String functionName) {\n+            this.functionName = functionName;\n+        }\n+\n+        Stream<TemplateToken> generate() {\n+            return Stream.of(template(\"a\", \"b\"), template(\"b\", \"a\")).\n+                map(Template.ZeroArgs::asToken);\n+        }\n+\n+        private Template.ZeroArgs template(String arg1, String arg2) {\n+            return Template.make(() -> scope(\n+                let(\"op\", name()),\n+                let(\"functionName\", functionName),\n+                let(\"arg1\", arg1),\n+                let(\"arg2\", arg2),\n+                \"\"\"\n+                @Setup\n+                private static Object[] $setup() {\n+                    return new Object[] {Float16.valueOf(42), Float16.valueOf(42)};\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#op, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION,\n+                    applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+                @IR(counts = {IRNode.#op, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION,\n+                    applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+                @Arguments(setup = \"$setup\")\n+                public Float16 $test(Float16 #arg1, Float16 #arg2) {\n+                    int i;\n+                    for (i = -10; i < 1; i++) {\n+                    }\n+                    Float16 c = Float16.multiply(a, Float16.valueOf(i));\n+                    return Float16.#functionName(a, Float16.#functionName(b, c));\n+                }\n+                \"\"\"\n+            ));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/TestMinMaxIdentity.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8361842\n- * @summary Verify the effectiveness of the `VerifyIntrinsicChecks` VM flag\n- *          through (bypassing `StringCoding::encodeAsciiArray`, and) feeding\n- *          invalid input to an intrinsified `StringCoding::encodeAsciiArray0`\n- *          (note the `0` suffix!).\n- * @library \/compiler\/patches\n- * @library \/test\/lib\n- * @build java.base\/java.lang.Helper\n- * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n- *          development flag\n- * @requires vm.debug == true & vm.flavor == \"server\" & !vm.graal.enabled\n- * @requires (os.arch != \"riscv64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"))\n- * @run main\/othervm compiler.intrinsics.TestVerifyIntrinsicChecks verify\n- *\/\n-\n-package compiler.intrinsics;\n-\n-import java.lang.Helper;\n-import java.time.Instant;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public final class TestVerifyIntrinsicChecks {\n-\n-    public static void main(String[] args) throws Exception {\n-        switch (args[0]) {\n-            case \"verify\" -> {\n-                log(\"Starting JVM in a separate process to verify the crash\");\n-                OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n-                        \"-Xcomp\",\n-                        \"-XX:-TieredCompilation\",\n-                        \"-XX:CompileCommand=inline,java.lang.StringCoding::encodeAsciiArray0\",\n-                        \"-XX:+VerifyIntrinsicChecks\",\n-                        \"--patch-module\", \"java.base=%s\/java.base\".formatted(System.getProperty(\"test.patch.path\")),\n-                        \"compiler.intrinsics.TestVerifyIntrinsicChecks\",\n-                        \"crash\");\n-                outputAnalyzer.shouldContain(\"unexpected null in intrinsic\");\n-                outputAnalyzer.shouldNotHaveExitValue(0);\n-            }\n-            case \"crash\" -> {\n-                log(\"Triggering the crash\");\n-                warmUpIntrinsicMethod();\n-                violateIntrinsicMethodContract();\n-            }\n-            default -> throw new IllegalArgumentException();\n-        }\n-    }\n-\n-    private static void warmUpIntrinsicMethod() {\n-        log(\"Warming up the intrinsic method\");\n-        char[] sa = createAsciiChars(8192);\n-        byte[] sp = new byte[4096];\n-        for (int i = 0; i < 1_000; i++) {\n-            Helper.StringCodingEncodeAsciiArray0(sa, i, sp, 0, sp.length - i);\n-        }\n-    }\n-\n-    private static char[] createAsciiChars(int length) {\n-        char[] buffer = new char[length];\n-        for (int i = 0; i < length; i++) {\n-            buffer[i] = (char) (i % '\\u0080');\n-        }\n-        return buffer;\n-    }\n-\n-    private static void violateIntrinsicMethodContract() {\n-        log(\"Violating the intrinsic method contract (sa=null)\");\n-        Helper.StringCodingEncodeAsciiArray0(null, 1, null, 1, 1);\n-    }\n-\n-    private synchronized static void log(String format, Object... args) {\n-        Object[] extendedArgs = new Object[2 + args.length];\n-        extendedArgs[0] = Instant.now();\n-        extendedArgs[1] = Thread.currentThread().getName();\n-        System.arraycopy(args, 0, extendedArgs, extendedArgs.length - args.length, args.length);\n-        String extendedFormat = \"%%s [%%s] %s%%n\".formatted(format);\n-        System.out.printf(extendedFormat, extendedArgs);\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestVerifyIntrinsicChecks.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-\n@@ -50,20 +49,2 @@\n-\n-\/*\n- * @test\n- * @bug 8281146\n- * @summary Verify `StringCoding::countPositives` intrinsic Java wrapper checks\n- *          by enabling the ones in the VM intrinsic using\n- *          `-XX:+VerifyIntrinsicChecks`\n- * @comment This does not check out-of-range conditions. The\n- *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n- *          that the VM intrinsic will produce no spurious errors.\n- * @key randomness\n- * @library \/compiler\/patches\n- * @library \/test\/lib\n- * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n- *          development flag\n- * @requires vm.debug == true\n- * @build java.base\/java.lang.Helper\n- * @run main\/othervm\n- *      -XX:+VerifyIntrinsicChecks\n- *      compiler.intrinsics.string.TestCountPositives\n+\/**\n+ * This test was derived from compiler.intrinsics.string.TestHasNegatives\n@@ -71,1 +52,0 @@\n-\n@@ -76,0 +56,1 @@\n+import java.util.stream.IntStream;\n@@ -79,3 +60,0 @@\n-\/**\n- * This test was derived from {@link TestHasNegatives}.\n- *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,20 +34,0 @@\n-\/*\n- * @test\n- * @bug 6896617 8274242\n- * @summary Verify `sun.nio.cs.ISO_8859_1.Encoder::encodeISOArray` intrinsic\n- *          Java wrapper checks by enabling the ones in the VM intrinsic using\n- *          `-XX:+VerifyIntrinsicChecks`\n- * @comment This does not check out-of-range conditions. The\n- *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n- *          that the VM intrinsic will produce no spurious errors.\n- * @key randomness\n- * @library \/test\/lib\n- * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n- *          development flag\n- * @requires vm.debug == true\n- * @run main\/othervm\/timeout=1200\n- *      -XX:+VerifyIntrinsicChecks\n- *      --add-opens=java.base\/sun.nio.cs=ALL-UNNAMED -Xbatch -Xmx256m\n- *      compiler.intrinsics.string.TestEncodeIntrinsics\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestEncodeIntrinsics.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-\n@@ -50,21 +49,0 @@\n-\/*\n- * @test\n- * @bug 8054307\n- * @summary Verify `StringCoding::hasNegatives` intrinsic Java wrapper checks\n- *          by enabling the ones in the VM intrinsic using\n- *          `-XX:+VerifyIntrinsicChecks`\n- * @comment This does not check out-of-range conditions. The\n- *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n- *          that the VM intrinsic will produce no spurious errors.\n- * @key randomness\n- * @library \/compiler\/patches\n- * @library \/test\/lib\n- * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n- *          development flag\n- * @requires vm.debug == true\n- * @build java.base\/java.lang.Helper\n- * @run main\/othervm\n- *      -XX:+VerifyIntrinsicChecks\n- *      compiler.intrinsics.string.TestHasNegatives\n- *\/\n-\n@@ -75,0 +53,1 @@\n+import java.util.stream.IntStream;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestHasNegatives.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+        \/\/ Note: Math.copySign is non-deterministic because of NaN having encoding with sign bit set and unset.\n@@ -297,1 +298,2 @@\n-        ops.add(Expression.make(FLOAT16, \"Float16.copySign(\", FLOAT16, \",\", FLOAT16, \")\"));\n+        \/\/ Note: There are NaN encodings with bit set or unset.\n+        ops.add(Expression.make(FLOAT16, \"Float16.copySign(\", FLOAT16, \",\", FLOAT16, \")\", WITH_NONDETERMINISTIC_RESULT));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Operations.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1055,29 +1055,14 @@\n-                        \/\/ We would have liked to check that there is no multiversioning.\n-                        \/\/\n-                        \/\/ But sadly there are some cases that have issues with RCE and\/or\n-                        \/\/ predicates, and so we end up using multiversioning anyway. We\n-                        \/\/ should fix those cases eventually, to strengthen the checks here.\n-                        \/\/\n-                        \/\/ The array cases are a little more tame, and do not have the same\n-                        \/\/ issues as the MemorySegment cases.\n-                        (containerKind == ContainerKind.ARRAY)\n-                        ? \"\"\"\n-                          \/\/ Aliasing check should never fail at runtime, so the predicate\n-                          \/\/ should never fail, and we do not have to use multiversioning.\n-                          \/\/ Failure could have a few causes:\n-                          \/\/ - issues with doing RCE \/ missing predicates\n-                          \/\/   -> other loop-opts need to be fixed\n-                          \/\/ - predicate fails: recompile with multiversioning\n-                          \/\/   -> logic in runtime check may be wrong\n-                          @IR(counts = {\".*multiversion.*\", \"= 0\"},\n-                              phase = CompilePhase.PRINT_IDEAL,\n-                              applyIf = {\"UseAutoVectorizationPredicate\", \"true\"},\n-                              applyIfPlatform = {\"64-bit\", \"true\"},\n-                              applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n-                          \"\"\"\n-                        : \"\"\"\n-                          \/\/ Due to cases like JDK-8360204 and JDK-8365982, there can be issues\n-                          \/\/ with RCE leading cases where we remove predicates and then unroll again\n-                          \/\/ and then end up multiversioning. These cases seem relatively rare but\n-                          \/\/ prevent us from asserting that there is never multiversioning in these cases.\n-                          \"\"\";\n+                            \"\"\"\n+                            \/\/ Aliasing check should never fail at runtime, so the predicate\n+                            \/\/ should never fail, and we do not have to use multiversioning.\n+                            \/\/ Failure could have a few causes:\n+                            \/\/ - issues with doing RCE \/ missing predicates\n+                            \/\/   -> other loop-opts need to be fixed\n+                            \/\/ - predicate fails: recompile with multiversioning\n+                            \/\/   -> logic in runtime check may be wrong\n+                            @IR(counts = {\".*multiversion.*\", \"= 0\"},\n+                                phase = CompilePhase.PRINT_IDEAL,\n+                                applyIf = {\"UseAutoVectorizationPredicate\", \"true\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\";\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":15,"deletions":30,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=all-flags\n+ * @summary Test a case where we can have one memory slice that has only loads,\n+ *          but the loads from the slice do not have all the same input memory\n+ *          state from before the loop. This is rather rare but it can happen.\n+ * @bug 8373453\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,${test.main.class}::test\n+ *      -Xbatch -XX:-TieredCompilation\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=fewer-flags\n+ * @bug 8373453\n+ * @run main\/othervm\n+ *      -XX:CompileCommand=compileonly,${test.main.class}::test\n+ *      ${test.main.class}\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8373453\n+ * @run main ${test.main.class}\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestLoadSliceWithMultipleMemoryInputStates {\n+    static void test() {\n+        \/\/ The relevant slice is the value field of the Byte Objects.\n+        Byte x = 1;\n+\n+        for (int i = 0; i < 2; i++) {\n+            if ((i & 1) == 0) {\n+                \/\/ Not sure what this loop is needed for, but it is very sensitive,\n+                \/\/ I cannot even replace N with 32.\n+                int N = 32;\n+                for (int j = 0; j < N; j++) {\n+                    if (j == 1) {\n+                        x = (byte) x;\n+                    }\n+                }\n+\n+                for (int j = 0; j < 32; j++) {\n+                    \/\/ The call below has an effect on the memory state\n+                    \/\/ If we optimize the Load for Byte::value, we can bypass\n+                    \/\/ this call, since we know that Byte::value cannot be\n+                    \/\/ modified during the call.\n+                    Object o = 1;\n+                    o.toString();\n+\n+                    for (int k = 0; k < 32; k++) { \/\/ OSR around here\n+                        \/\/ Loads of x byte field have different memory input states\n+                        \/\/ This is because some loads can split their memory state\n+                        \/\/ through a phi further up, and others are not put back on\n+                        \/\/ the IGVN worklist and are thus not optimized and keep\n+                        \/\/ the old memory state. Both are correct though.\n+                        x = (byte) (x + 1);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLoadSliceWithMultipleMemoryInputStates.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -42,5 +42,0 @@\n-    @jdk.internal.vm.annotation.ForceInline\n-    public static int StringCodingEncodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n-        return StringCoding.encodeAsciiArray0(sa, sp, da, dp, len);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-    public static final String LOAD_UNKNOWN_INLINE = \"C2 Runtime load_unknown_inline\";\n-    public static final String STORE_UNKNOWN_INLINE = \"C2 Runtime store_unknown_inline\";\n+    public static final String LOAD_UNKNOWN_INLINE = \"load_unknown_inline_blob \\\\(C2 runtime\\\\)\";\n+    public static final String STORE_UNKNOWN_INLINE = \"store_unknown_inline_blob \\\\(C2 runtime\\\\)\";\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -482,0 +482,26 @@\n+    @Test\n+    @IR(counts = { IRNode.CAST_II, \">0\" })\n+    @Warmup(0)\n+    public Object[] testCastII() {\n+        byte[] bytes = new byte[400];\n+        intField = 6;\n+        int i = 0;\n+        int j = 1;\n+\n+        do {\n+            bytes[j] = (byte) i;\n+            int k = 1;\n+\n+            do {\n+                i <<= intField;\n+                i += (k ^ i);\n+                i -= j;\n+\n+                for (int u = 1; 1 > u; u++) {\n+                }\n+            } while (++k < 8);\n+        } while (++j < 191);\n+\n+        return new Object[] { bytes };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,2 @@\n-        File started = new File(sharedtmpdir, \"started\");\n+        File started1 = new File(sharedtmpdir, \"started-1\");\n+        File started2 = new File(sharedtmpdir, \"started-2\");\n@@ -72,1 +73,2 @@\n-        started.delete();\n+        started1.delete();\n+        started2.delete();\n@@ -74,0 +76,1 @@\n+        Object lock = new Object();\n@@ -80,0 +83,3 @@\n+                    synchronized(lock) {\n+                        opts.addClassOptions(\"1\");\n+                    }\n@@ -85,0 +91,5 @@\n+        while (!started1.exists()) {\n+            System.out.println(\"Waiting for first JVM to start\");\n+            Thread.sleep(1000);\n+        }\n+\n@@ -87,0 +98,3 @@\n+                    synchronized(lock) {\n+                        opts.addClassOptions(\"2\");\n+                    }\n@@ -92,2 +106,2 @@\n-        while (!started.exists()) {\n-            System.out.println(\"Wait for at least one JVM to start\");\n+        while (!started2.exists()) {\n+            System.out.println(\"Waiting for second JVM to start\");\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/ShareTmpDir.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-        File started = new File(\"\/tmp\/started\");\n+        File started = new File(\"\/tmp\/started-\" + args.length);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/WaitForFlagFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.epsilon;\n+\n+\/**\n+ * @test TestInitAllocs\n+ * @requires vm.gc.Epsilon\n+ * @summary Test that allocation path taken in early JVM phases works\n+ *\n+ * @run main\/othervm -Xmx256m\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC\n+ *                   gc.epsilon.TestInitAllocs\n+ *\n+ * @run main\/othervm -Xmx256m\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC\n+ *                   -XX:+UseTLAB\n+ *                   -XX:+UseCompressedOops\n+ *                   -XX:EpsilonMinHeapExpand=1024\n+ *                   -XX:EpsilonUpdateCountersStep=1\n+ *                   -XX:EpsilonPrintHeapSteps=1000000\n+ *                   gc.epsilon.TestInitAllocs\n+ *\n+ * @run main\/othervm -Xmx256m\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC\n+ *                   -XX:+UseTLAB\n+ *                   -XX:-UseCompressedOops\n+ *                   -XX:EpsilonMinHeapExpand=1024\n+ *                   -XX:EpsilonUpdateCountersStep=1\n+ *                   -XX:EpsilonPrintHeapSteps=1000000\n+ *                   gc.epsilon.TestInitAllocs\n+ *\n+ * @run main\/othervm -Xmx256m\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC\n+ *                   -XX:-UseTLAB\n+ *                   -XX:+UseCompressedOops\n+ *                   -XX:EpsilonMinHeapExpand=1024\n+ *                   -XX:EpsilonUpdateCountersStep=1\n+ *                   -XX:EpsilonPrintHeapSteps=1000000\n+ *                   gc.epsilon.TestInitAllocs\n+ *\n+ * @run main\/othervm -Xmx256m\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC\n+ *                   -XX:-UseTLAB\n+ *                   -XX:-UseCompressedOops\n+ *                   -XX:EpsilonMinHeapExpand=1024\n+ *                   -XX:EpsilonUpdateCountersStep=1\n+ *                   -XX:EpsilonPrintHeapSteps=1000000\n+ *                   gc.epsilon.TestInitAllocs\n+ *\/\n+\n+public class TestInitAllocs {\n+  public static void main(String[] args) throws Exception {\n+    System.out.println(\"Hello World\");\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/epsilon\/TestInitAllocs.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -56,0 +56,1 @@\n+import jdk.test.lib.Platform;\n@@ -58,1 +59,0 @@\n-import static jdk.test.lib.Asserts.*;\n@@ -73,1 +73,1 @@\n-                                                                    \"-XX:ReservedCodeCacheSize=8M\",\n+                                                                    \"-XX:ReservedCodeCacheSize=\" + (Platform.is32bit() ? \"4M\" : \"8M\"),\n@@ -76,0 +76,1 @@\n+                                                                    \"-XX:CompileCommand=compileonly,gc.g1.Foo*::*\",\n@@ -143,1 +144,1 @@\n-            } while (i < 1000);\n+            } while (i < 200);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestCodeCacheUnloadDuringConcCycle.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                        + \"option types! Got \" + type + \" type!\");\n+                        + \"option types! Got \" + type + \" type for option \" + name + \"!\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/common\/optionsvalidation\/JVMOption.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8374639\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib\n+ * @build DynamicDumpWithAOTLinkedStaticArchive jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar TestApp\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. DynamicDumpWithAOTLinkedStaticArchive\n+ *\/\n+\n+import jdk.test.lib.cds.SimpleCDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class DynamicDumpWithAOTLinkedStaticArchive {\n+    public static void main(String... args) throws Exception {\n+        SimpleCDSAppTester.of(\"DynamicDumpWithAOTLinkedStaticArchive\")\n+            .classpath(\"app.jar\")\n+            .appCommandLine(\"TestApp\")\n+            .setGenerateBaseArchive(true)\n+            .setBaseArchiveOptions(\"-XX:+AOTClassLinking\")\n+            .setProductionChecker((OutputAnalyzer out) -> {\n+                    out.shouldContain(\"HelloWorld\");\n+                })\n+            .runDynamicWorkflow();\n+    }\n+}\n+\n+class TestApp {\n+    public static void main(String[] args) {\n+        System.out.println(\"HelloWorld\");\n+        System[][][] x = new System[0][0][0];\n+        System.out.println(x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/DynamicDumpWithAOTLinkedStaticArchive.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary handling of the existence of InstanceKlass::array_klasses()\n- * @requires vm.cds\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n- * @build ArrayKlassesApp\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar ArrayKlasses.jar ArrayKlassesApp\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. ArrayKlasses\n- *\/\n-\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-\n-public class ArrayKlasses extends DynamicArchiveTestBase {\n-    public static void main(String[] args) throws Exception {\n-        runTest(ArrayKlasses::test);\n-    }\n-\n-    static void test() throws Exception {\n-        String topArchiveName = getNewArchiveName();\n-        final String appJar = ClassFileInstaller.getJarPath(\"ArrayKlasses.jar\");\n-        final String mainClass = \"ArrayKlassesApp\";\n-        final String runtimeLogOptions =\n-            \"-Xlog:class+load,class+load+array=debug,cds+dynamic=debug,cds=debug,aot+unshareable=trace\";\n-\n-        \/\/ Case 1\n-        \/\/ Create a dynamic archive with the ArrayKlassesApp app class and its\n-        \/\/ array classes.\n-        dump2(null, topArchiveName,\n-              \"-Xlog:cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass)\n-              .assertNormalExit(output -> {\n-                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[LArrayKlassesApp;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[LArrayKlassesApp;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[LArrayKlassesApp;\");\n-                 });\n-\n-        \/\/ Case 1\n-        \/\/ At runtime , the ArrayKlasesApp and its array class should be loaded\n-        \/\/ from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass)\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"ArrayKlassesApp source: shared objects file (top)\")\n-                           .shouldContain(\"restore: ArrayKlassesApp with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldContain(\"[LArrayKlassesApp; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [LArrayKlassesApp; with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldContain(\"[[LArrayKlassesApp; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[LArrayKlassesApp; with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldContain(\"[[[LArrayKlassesApp; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[LArrayKlassesApp; with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-\n-        \/\/ Case 2\n-        \/\/ Create a dynamic archive with the array classes of java\/util\/Date which\n-        \/\/ is in the default CDS archive.\n-        topArchiveName = getNewArchiveName();\n-        dump2(null, topArchiveName,\n-              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass, \"system\")\n-              .assertNormalExit(output -> {\n-                     output.shouldContain(\"java.util.Date source: shared objects file\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[Ljava.util.Date;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.util.Date;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.util.Date;\");\n-                 });\n-\n-        \/\/ Case 2\n-        \/\/ At runtime, the java\/util\/Date class should be loaded from the default\n-        \/\/ CDS archive; its array class should be loaded from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass, \"system\")\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"java.util.Date source: shared objects file\")\n-                           .shouldContain(\"restore: java.util.Date with class loader: boot\")\n-                           .shouldContain(\"[Ljava.util.Date; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [Ljava.util.Date; with class loader: boot\")\n-                           .shouldContain(\"[[Ljava.util.Date; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[Ljava.util.Date; with class loader: boot\")\n-                           .shouldContain(\"[[[Ljava.util.Date; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[Ljava.util.Date; with class loader: boot\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-\n-        \/\/ Case 3\n-        \/\/ Create a dynamic archive with primitive arrays [[J and [[[J with [J\n-        \/\/ already in the default CDS archive\n-        topArchiveName = getNewArchiveName();\n-        dump2(null, topArchiveName,\n-              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass, \"primitive\")\n-              .assertNormalExit(output -> {\n-                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[J\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[J\");\n-                 });\n-\n-        \/\/ Case 3\n-        \/\/ At runtime, the [J should be loaded from the default CDS archive;\n-        \/\/ the higher-dimension array should be loaded from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass, \"primitive\")\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"[J source: shared objects file\")\n-                           .shouldContain(\"restore: [J with class loader: boot\")\n-                           .shouldContain(\"[[J source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[J with class loader: boot\")\n-                           .shouldContain(\"[[[J source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[J with class loader: boot\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-\n-        \/\/ Case 4\n-        \/\/ Create a dynamic archive with 2-, 3- and 4-dimension arrays of java\/lang\/Integer.\n-        \/\/ The java\/lang\/Integer class and the 1-dimension array is in the default archive.\n-        topArchiveName = getNewArchiveName();\n-        dump2(null, topArchiveName,\n-              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass, \"integer-array\")\n-              .assertNormalExit(output -> {\n-                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.lang.Integer;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.lang.Integer;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[\\\\[Ljava.lang.Integer;\");\n-                 });\n-\n-        \/\/ Case 4\n-        \/\/ At runtime, the 4-dimension array of java\/lang\/Integer should be\n-        \/\/ loaded from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass, \"integer-array\")\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"java.lang.Integer source: shared objects file\")\n-                           .shouldContain(\"restore: java.lang.Integer with class loader: boot\")\n-                           .shouldContain(\"restore: [Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldContain(\"[[Ljava.lang.Integer; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldContain(\"[[[Ljava.lang.Integer; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldContain(\"[[[[Ljava.lang.Integer; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[[Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArrayKlasses.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.lang.reflect.Array;\n-import java.util.Date;\n-\n-public class ArrayKlassesApp {\n-    public static void main(String args[]) {\n-        if (args.length == 1) {\n-            if (args[0].equals(\"system\")) {\n-                Date[][][] array = new Date[1][2][2];\n-                int count = 0;\n-                for (int i=0; i<1; i++) {\n-                    for (int j=0; j<2; j++) {\n-                        for (int k=0; k<2; k++) {\n-                            array[i][j][k] = new Date();\n-                            count++;\n-                            array[i][j][k].setTime(20000 * count);\n-                        }\n-                    }\n-                }\n-            } else if (args[0].equals(\"primitive\")) {\n-                long[][][] larray = new long[1][2][2];\n-                long lcount = 0;\n-                for (int i=0; i<1; i++) {\n-                    for (int j=0; j<2; j++) {\n-                        for (int k=0; k<2; k++) {\n-                            lcount++;\n-                            larray[i][j][k] = lcount;\n-                        }\n-                    }\n-                }\n-            } else if (args[0].equals(\"integer-array\")) {\n-                Integer[][][][] iarray = new Integer[4][4][4][4];\n-                int count = 0;\n-                for (int i = 0; i < 4; i++) {\n-                    for (int j = 0; j < 4; j++) {\n-                        for (int k = 0; k < 4; k++) {\n-                            for (int l = 0; l < 4; l++) {\n-                                count++;\n-                                iarray[i][j][k][l] = new Integer(count);\n-                            }\n-                        }\n-                    }\n-                }\n-                System.out.println(iarray);\n-                System.out.println(iarray.getClass());\n-            }\n-        } else {\n-            Object x = Array.newInstance(ArrayKlassesApp.class, 3,3,3);\n-            System.out.println(x);\n-            System.out.println(x.getClass());\n-            System.out.println(Array.getLength(x));\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/ArrayKlassesApp.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018 by SAP AG, Walldorf, Germany.\n+ * Copyright (c) 2018, 2026 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/IllegalAccessError\/IAE78_A.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018 by SAP AG, Walldorf, Germany.\n+ * Copyright (c) 2018, 2026 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/IllegalAccessError\/IAE_Loader2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2011 SAP AG.  All Rights Reserved.\n+ * Copyright (c) 2011, 2026 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/execstack\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2011 SAP AG.  All Rights Reserved.\n+ * Copyright (c) 2011, 2026 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/execstack\/TestMT.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2011 SAP AG.  All Rights Reserved.\n+ * Copyright (c) 2011, 2026 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/execstack\/libtest-rw.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2011 SAP AG.  All Rights Reserved.\n+ * Copyright (c) 2011, 2026 SAP SE. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/execstack\/libtest-rwx.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -29,2 +28,6 @@\n- * @requires vm.jvmti\n- * @requires vm.gc == \"null\" | vm.gc == \"Serial\"\n+ * @requires vm.jvmti &\n+ *           vm.gc != \"Epsilon\" &\n+ *           vm.flavor == \"server\" &\n+ *           !vm.emulatedClient &\n+ *           (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4) &\n+ *           vm.compMode == \"Xmixed\"\n@@ -34,1 +37,11 @@\n- * @run main\/othervm\/native NMethodRelocationTest\n+ * @run main\/othervm\/native -agentlib:NMethodRelocationTest\n+ *                          --enable-native-access=ALL-UNNAMED\n+ *                          -Xbootclasspath\/a:.\n+ *                          -Xbatch\n+ *                          -XX:+UnlockDiagnosticVMOptions\n+ *                          -XX:+WhiteBoxAPI\n+ *                          -XX:+SegmentedCodeCache\n+ *                          -XX:-TieredCompilation\n+ *                          -XX:+UnlockExperimentalVMOptions\n+ *                          -XX:+NMethodRelocation\n+ *                          NMethodRelocationTest\n@@ -37,2 +50,0 @@\n-import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n-\n@@ -40,3 +51,0 @@\n-import java.util.Objects;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -51,0 +59,1 @@\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n@@ -53,44 +62,0 @@\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                \"-agentlib:NMethodRelocationTest\",\n-                \"--enable-native-access=ALL-UNNAMED\",\n-                \"-Xbootclasspath\/a:.\",\n-                \"-XX:+UseSerialGC\",\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:+WhiteBoxAPI\",\n-                \"-XX:+SegmentedCodeCache\",\n-                \"-XX:-TieredCompilation\",\n-                \"-XX:+UnlockExperimentalVMOptions\",\n-                \"-XX:+NMethodRelocation\",\n-                \"DoWork\");\n-\n-        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n-        String output = oa.getOutput();\n-        if (oa.getExitValue() != 0) {\n-            System.err.println(oa.getOutput());\n-            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n-        }\n-        Asserts.assertTrue(oa.getExitValue() == 0);\n-\n-        Pattern pattern = Pattern.compile(\"(?m)^Relocated nmethod from (0x[0-9a-f]{16}) to (0x[0-9a-f]{16})$\");\n-        Matcher matcher = pattern.matcher(output);\n-\n-        if (matcher.find()) {\n-            String fromAddr = matcher.group(1);\n-            String toAddr = matcher.group(2);\n-\n-            \/\/ Confirm events sent for both original and relocated nmethod\n-            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + fromAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + toAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + fromAddr);\n-            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + toAddr);\n-        } else {\n-            System.err.println(oa.getOutput());\n-            throw new RuntimeException(\"Unable to find relocation information\");\n-        }\n-    }\n-}\n-\n-class DoWork {\n-\n-    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n@@ -110,25 +75,1 @@\n-    \/**\n-     * Returns value of VM option.\n-     *\n-     * @param name option's name\n-     * @return value of option or {@code null}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     *\/\n-    protected static String getVMOption(String name) {\n-        Objects.requireNonNull(name);\n-        return Objects.toString(WHITE_BOX.getVMFlag(name), null);\n-    }\n-\n-    \/**\n-     * Returns value of VM option or default value.\n-     *\n-     * @param name         option's name\n-     * @param defaultValue default value\n-     * @return value of option or {@code defaultValue}, if option doesn't exist\n-     * @throws NullPointerException if name is null\n-     * @see #getVMOption(String)\n-     *\/\n-    protected static String getVMOption(String name, String defaultValue) {\n-        String result = getVMOption(name);\n-        return result == null ? defaultValue : result;\n-    }\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n@@ -136,3 +77,1 @@\n-    public static void main(String argv[]) throws Exception {\n-        run();\n-    }\n+    native static boolean shouldExit();\n@@ -140,2 +79,2 @@\n-    public static void run() throws Exception {\n-        Executable method = DoWork.class.getDeclaredMethod(\"compiledMethod\");\n+    public static void main(String[] argv) throws Exception {\n+        Executable method = NMethodRelocationTest.class.getDeclaredMethod(\"compiledMethod\");\n@@ -145,2 +84,3 @@\n-        while (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n-            Thread.onSpinWait();\n+\n+        if (!WHITE_BOX.isMethodCompiled(method)) {\n+            throw new AssertionError(\"Method not compiled\");\n@@ -167,7 +107,3 @@\n-        WHITE_BOX.fullGC();\n-        WHITE_BOX.fullGC();\n-\n-        WHITE_BOX.lockCompilation();\n-\n-        System.out.printf(\"Relocated nmethod from 0x%016x to 0x%016x%n\", originalNMethod.code_begin, relocatedNMethod.code_begin);\n-        System.out.flush();\n+        while (!shouldExit()) {\n+            WHITE_BOX.fullGC();\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java","additions":28,"deletions":92,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <atomic>\n@@ -25,3 +26,12 @@\n-#include <jvmti.h>\n-#include <stdio.h>\n-#include <string.h>\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+\/\/ Track nmethod addresses for LOAD and UNLOAD events\n+static const void* first_load_addr      = nullptr;\n+static const void* second_load_addr     = nullptr;\n+static const void* first_unload_addr    = nullptr;\n+static const void* second_unload_addr   = nullptr;\n+\n+\/\/ Keep track of test completion\n+static std::atomic<bool> should_exit{false};\n@@ -37,2 +47,0 @@\n-    char* name = nullptr;\n-    char* sig = nullptr;\n@@ -40,3 +48,3 @@\n-    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n-        printf(\"    [Could not retrieve method name]\\n\");\n-        fflush(stdout);\n+    \/\/ Only track events for \"compiledMethod\"\n+    char* name = get_method_name(jvmti, method);\n+    if (strcmp(name, \"compiledMethod\") != 0) {\n@@ -46,3 +54,14 @@\n-    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n-        name, (uintptr_t)code_addr);\n-    fflush(stdout);\n+    LOG(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+\n+    if (first_load_addr == nullptr) {\n+        first_load_addr = code_addr;\n+    } else if (second_load_addr == nullptr) {\n+        second_load_addr = code_addr;\n+\n+        \/\/ Verify that the addresses are different\n+        if (first_load_addr == second_load_addr) {\n+            fatal(\"Load events for 'compiledMethod' are expected to use different addresses\");\n+        }\n+    } else {\n+        fatal(\"Received too many load events for 'compiledMethod'\");\n+    }\n@@ -57,2 +76,0 @@\n-    char* name = nullptr;\n-    char* sig = nullptr;\n@@ -60,3 +77,3 @@\n-    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n-        printf(\"    [Could not retrieve method name]\\n\");\n-        fflush(stdout);\n+    \/\/ Only track events for \"compiledMethod\"\n+    char* name = get_method_name(jvmti, method);\n+    if (strcmp(name, \"compiledMethod\") != 0) {\n@@ -65,3 +82,31 @@\n-    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n-        name, (uintptr_t)code_addr);\n-    fflush(stdout);\n+\n+    LOG(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\", name, (uintptr_t)code_addr);\n+\n+    \/\/ Validate both loads have occurred\n+    if (first_load_addr == nullptr || second_load_addr == nullptr) {\n+        fatal(\"UNLOAD event for 'compiledMethod' occurred before both LOAD events\");\n+    }\n+\n+    if (first_unload_addr == nullptr) {\n+        first_unload_addr = code_addr;\n+    } else if (second_unload_addr == nullptr) {\n+        second_unload_addr = code_addr;\n+\n+        \/\/ Verify that the addresses are different\n+        if (first_unload_addr == second_unload_addr) {\n+            fatal(\"Unload events for 'compiledMethod' are expected to use different addresses\");\n+        }\n+\n+        \/\/ LOAD and UNLOAD events should report the same two addresses, but the order of\n+        \/\/ the UNLOADs is not guaranteed, since the GC may unload either nmethod first.\n+        if ((first_load_addr == first_unload_addr  && second_load_addr == second_unload_addr) ||\n+            (first_load_addr == second_unload_addr && second_load_addr == first_unload_addr)) {\n+\n+            \/\/ Update should_exit to signal test completion\n+            should_exit.store(true);\n+        } else {\n+            fatal(\"Address mismatch for 'compiledMethod' events\");\n+        }\n+    } else {\n+        fatal(\"Received too many unload events for 'compiledMethod'\");\n+    }\n@@ -72,1 +117,0 @@\n-    jvmtiError error;\n@@ -75,1 +119,1 @@\n-        printf(\"Unable to access JVMTI!\\n\");\n+        LOG(\"Unable to access JVMTI!\\n\");\n@@ -83,5 +127,2 @@\n-    error = jvmti->AddCapabilities(&caps);\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to add capabilities, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    jvmtiError error = jvmti->AddCapabilities(&caps);\n+    check_jvmti_error(error, \"Unable to add capabilities\");\n@@ -95,4 +136,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to set event callbacks, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to set event callbacks\");\n@@ -102,4 +140,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to enable COMPILED_METHOD_LOAD event, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to enable COMPILED_METHOD_LOAD event\");\n@@ -108,4 +143,1 @@\n-    if (error != JVMTI_ERROR_NONE) {\n-        printf(\"ERROR: Unable to enable COMPILED_METHOD_UNLOAD event, error=%d\\n\", error);\n-        return JNI_ERR;\n-    }\n+    check_jvmti_error(error, \"Unable to enable COMPILED_METHOD_UNLOAD event\");\n@@ -115,0 +147,7 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NMethodRelocationTest_shouldExit(JNIEnv *env, jclass cls) {\n+  return should_exit.load();\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/NMethodRelocation\/libNMethodRelocationTest.cpp","additions":77,"deletions":38,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+        sleep(50); \/\/ reliability: wait for a potential class loading to complete\n@@ -49,1 +50,1 @@\n-        while (!threadReady || (vt.getState() != expState) || !rlock.hasQueuedThreads()) {\n+        while (!threadReady || (vt.getState() != expState) || !rlock.hasQueuedThread(vt)) {\n@@ -128,0 +129,1 @@\n+        Thread.State state = vt.getState();\n@@ -129,2 +131,2 @@\n-        System.out.printf(\"State: expected: %s single: %x multi: %x\\n\",\n-                          vt.getState(), singleState, multiState);\n+        System.out.printf(\"State: expected: %s, vt.getState(): %s, jvmtiExpState: %x single: %x multi: %x\\n\",\n+                          expState, state, jvmtiExpState, singleState, multiState);\n@@ -132,1 +134,1 @@\n-        if (vt.getState() != expState) {\n+        if (state != expState) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadListStackTracesTest\/ThreadListStackTracesTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,2 @@\n- *     The test loads the classes with nsk.share.gc.GCClassUnloader class that\n- *     extends nsk.share.ClassUnloader and has a bit different algorith of eating\n- *     heap. As soon as a class is loaded, the test creates an instance of\n+ *     The test loads the classes with nsk.share.gc.GCClassUnloader class.\n+ *     As soon as a class is loaded, the test creates an instance of\n@@ -60,0 +59,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -64,0 +65,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -82,0 +84,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -149,2 +152,2 @@\n-                    \/\/ Drop all references to the class and try to unload it\n-                    Algorithms.eatMemory(getExecutionController());\n+                    \/\/ Keep all references to the class and try to unload it\n+                    WhiteBox.getWhiteBox().fullGC();\n@@ -161,0 +164,1 @@\n+                    \/\/ Drop all references to the class and try to unload it\n@@ -167,9 +171,1 @@\n-                    boolean result = unloader.unloadClass(getExecutionController());\n-                    log.debug(id + \": Result of uloading \"\n-                            + \"class \" + name + \": \" + result);\n-                }\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ just skip if we eat memory in several threads...\n-                \/\/ rethrow in the case of one thread\n-                if (runParams.getNumberOfThreads() == 1) {\n-                    throw oome;\n+                    WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large001\/large001.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,2 @@\n- *     The test loads the classes with nsk.share.gc.GCClassUnloader class that\n- *     extends nsk.share.ClassUnloader and has a bit different algorith of eating\n- *     heap. As soon as a class is loaded, the test creates an instance of\n+ *     The test loads the classes with nsk.share.gc.GCClassUnloader class.\n+ *     As soon as a class is loaded, the test creates an instance of\n@@ -61,0 +60,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -65,0 +66,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large002\/TestDescription.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,2 @@\n- *     The test loads the classes with nsk.share.gc.GCClassUnloader class that\n- *     extends nsk.share.ClassUnloader and has a bit different algorith of eating\n- *     heap. As soon as a class is loaded, the test creates an instance of\n+ *     The test loads the classes with nsk.share.gc.GCClassUnloader class.\n+ *     As soon as a class is loaded, the test creates an instance of\n@@ -65,0 +64,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -69,0 +70,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large003\/TestDescription.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,2 @@\n- *     The test loads the classes with nsk.share.gc.GCClassUnloader class that\n- *     extends nsk.share.ClassUnloader and has a bit different algorith of eating\n- *     heap. As soon as a class is loaded, the test creates an instance of\n+ *     The test loads the classes with nsk.share.gc.GCClassUnloader class.\n+ *     As soon as a class is loaded, the test creates an instance of\n@@ -65,0 +64,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -69,0 +70,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large004\/TestDescription.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,2 @@\n- *     The test loads the classes with nsk.share.gc.GCClassUnloader class that\n- *     extends nsk.share.ClassUnloader and has a bit different algorith of eating\n- *     heap. As soon as a class is loaded, the test creates an instance of\n+ *     The test loads the classes with nsk.share.gc.GCClassUnloader class.\n+ *     As soon as a class is loaded, the test creates an instance of\n@@ -65,0 +64,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -69,0 +70,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large005\/TestDescription.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires test.thread.factory != \"Virtual\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/MemoryEaterMT\/MemoryEaterMT.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassObjectReference\/reflectedType\/reflectype002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- *    unload class, using memory stressing techique, and waits for\n+ *    unload class, using whitebox full GC techique, and waits for\n@@ -84,0 +84,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -95,1 +97,2 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n@@ -97,1 +100,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassUnloadEvent\/className\/classname001\/TestDescription.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- *    unload classes, using memory stressing techique, and waits for\n+ *    unload classes, using whitebox full GC techique, and waits for\n@@ -90,0 +90,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -101,1 +103,2 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n@@ -103,1 +106,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassUnloadEvent\/classSignature\/signature001\/TestDescription.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -80,1 +82,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -82,1 +86,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassUnloadRequest\/addClassExclusionFilter\/exclfilter001\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -78,1 +80,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -80,1 +84,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassUnloadRequest\/addClassFilter\/filter001\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/allFields\/allfields003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/allMethods\/allmethods003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/classObject\/classobj002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/equals\/equals002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/failedToInitialize\/failedtoinit002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/fieldByName\/fieldbyname003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/fields\/fields003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/hashCode\/hashcode002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/isAbstract\/isabstract002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/isInitialized\/isinit002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/isPrepared\/isprepared002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -70,1 +72,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -72,1 +76,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/isVerified\/isverified002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,2 @@\n- *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +69,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +73,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/methods\/methods003\/TestDescription.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/methodsByName_s\/methbyname_s003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/methodsByName_ss\/methbyname_ss003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/name\/name002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/sourceName\/sourcename002\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/visibleFields\/visibfield003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -68,1 +70,3 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\" .\/bin\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Xbootclasspath\/a:.\n+ *                      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\"\n+ *      .\/bin\n@@ -70,1 +74,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ReferenceType\/visibleMethods\/visibmethod003\/TestDescription.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -58,1 +60,3 @@\n- *      -debugee.vmkeys=\"-Xmx256M ${test.vm.opts} ${test.java.opts}\"\n+ *      -debugee.vmkeys=\"-Xmx256M ${test.vm.opts} ${test.java.opts}\n+ *                      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                      -XX:+WhiteBoxAPI\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/instanceCounts\/instancecounts003\/instancecounts003.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    private final static int MAX_ITERATIONS = 5;\n+    private final static int MAX_ITERATIONS = 10;\n@@ -98,1 +98,0 @@\n-        System.gc();\n@@ -113,6 +112,7 @@\n-           System.gc();\n-           num = unloaded();\n-           iter++;\n-           if (iter > MAX_ITERATIONS) {\n-               throw new Failure(\"PRODUCT BUG: class was not unloaded in \" + MAX_ITERATIONS);\n-           }\n+            \/\/ The unload is delayed because it happens async\n+            Thread.sleep(1000);\n+            num = unloaded();\n+            iter++;\n+            if (iter > MAX_ITERATIONS) {\n+                throw new Failure(\"PRODUCT BUG: class was not unloaded in \" + MAX_ITERATIONS);\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodUnload\/compmethunload001.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -54,0 +56,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -57,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodUnload\/compmethunload001\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -60,0 +62,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ObjectFree\/objfree001\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -80,0 +82,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -83,1 +86,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t003\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -73,0 +75,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -76,1 +79,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t005\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -66,0 +68,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -69,1 +72,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM07\/em07t002\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -64,0 +66,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -67,1 +70,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/extension\/EX03\/ex03t001\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @key randomness\n@@ -32,1 +31,0 @@\n- * @requires vm.opt.DisableExplicitGC != \"true\"\n@@ -35,1 +33,7 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.opt.DisableExplicitGC != \"true\"\n+ * @requires vm.compMode != \"Xcomp\"\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseGCOverheadLimit\n@@ -45,0 +49,3 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n@@ -48,1 +55,0 @@\n-import nsk.share.gc.Algorithms;\n@@ -83,1 +89,2 @@\n-                Algorithms.eatMemory(stresser);\n+\n+                WhiteBox.getWhiteBox().fullGC();\n@@ -86,0 +93,1 @@\n+\n@@ -89,0 +97,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/GarbageCollectorMXBean\/CollectionCounters\/CollectionCounters001\/CollectionCounters001.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @key randomness\n@@ -32,1 +31,0 @@\n- * @requires vm.opt.DisableExplicitGC != \"true\"\n@@ -35,1 +33,7 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.opt.DisableExplicitGC != \"true\"\n+ * @requires vm.compMode != \"Xcomp\"\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/GarbageCollectorMXBean\/CollectionCounters\/CollectionCounters002\/TestDescription.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @key randomness\n@@ -32,1 +31,0 @@\n- * @requires vm.opt.DisableExplicitGC != \"true\"\n@@ -35,1 +33,7 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.opt.DisableExplicitGC != \"true\"\n+ * @requires vm.compMode != \"Xcomp\"\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/GarbageCollectorMXBean\/CollectionCounters\/CollectionCounters003\/TestDescription.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @key randomness\n@@ -32,1 +31,0 @@\n- * @requires vm.opt.DisableExplicitGC != \"true\"\n@@ -35,1 +33,7 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.opt.DisableExplicitGC != \"true\"\n+ * @requires vm.compMode != \"Xcomp\"\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/GarbageCollectorMXBean\/CollectionCounters\/CollectionCounters004\/TestDescription.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @key randomness\n@@ -32,1 +31,0 @@\n- * @requires vm.opt.DisableExplicitGC != \"true\"\n@@ -35,1 +33,7 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.opt.DisableExplicitGC != \"true\"\n+ * @requires vm.compMode != \"Xcomp\"\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/GarbageCollectorMXBean\/CollectionCounters\/CollectionCounters005\/TestDescription.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -49,0 +51,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -54,1 +57,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load001\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load002\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load003\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -53,0 +55,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load004\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -57,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load005\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load006\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -57,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load007\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -56,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load008\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -57,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load009\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load010\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -57,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load011\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/load012\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -51,0 +53,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -56,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload001\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload002\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload003\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -53,0 +55,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload004\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -57,1 +60,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload005\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -50,0 +52,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload006\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -54,0 +56,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload007\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +61,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload008\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload009\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -54,0 +56,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -60,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload010\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload011\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -52,0 +54,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -60,1 +63,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/classload\/unload012\/TestDescription.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -39,1 +40,1 @@\n- * using memory stressing technique.\n+ * using WhiteBox.fullGC technique.\n@@ -41,2 +42,2 @@\n- * <p>The method <code>unloadClass()<\/code> is provided which eats memory\n- * to enforce GC to cleanup the heap. So, if all references to a class\n+ * <p>The method <code>unloadClass()<\/code> is provided which calls\n+ * WhiteBox.fullGC to cleanup the heap. So, if all references to a class\n@@ -231,1 +232,1 @@\n-     * to class loader with its loaded classes and eating memory.\n+     * to class loader with its loaded classes.\n@@ -237,1 +238,1 @@\n-     *           is thrown while eating memory\n+     *           is thrown while triggering full GC\n@@ -239,1 +240,1 @@\n-     * @see #eatMemory()\n+     * @see WhiteBox.getWhiteBox().fullGC()\n@@ -241,1 +242,1 @@\n-    public boolean unloadClass(ExecutionController stresser) {\n+    public boolean unloadClass() {\n@@ -247,2 +248,2 @@\n-        \/\/ force class unloading by eating memory pool\n-        eatMemory(stresser);\n+        \/\/ force class unloading by triggering full GC\n+        WhiteBox.getWhiteBox().fullGC();\n@@ -259,30 +260,0 @@\n-\n-    public boolean unloadClass() {\n-        Stresser stresser = new Stresser() {\n-\n-            @Override\n-            public boolean continueExecution() {\n-                return true;\n-            }\n-\n-        };\n-        return unloadClass(stresser);\n-    }\n-\n-     \/\/ Stresses memory by allocating arrays of bytes.\n-   public static void eatMemory(ExecutionController stresser) {\n-       GarbageUtils.eatMemory(stresser, 50, 1024, 2);\n-    }\n-\n-     \/\/ Stresses memory by allocating arrays of bytes.\n-    public static void eatMemory() {\n-        Stresser stresser = new Stresser() {\n-\n-            @Override\n-            public boolean continueExecution() {\n-                return true;\n-            }\n-\n-        };\n-        eatMemory(stresser);\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/ClassUnloader.java","additions":11,"deletions":40,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,4 +76,1 @@\n-         * is thrown while eating memory. To avoid OOM while allocating\n-         * exception we preallocate it before the lunch starts. It means\n-         * that exception stack trace does not correspond to the place\n-         * where exception is thrown, but points at start of the method.\n+         * is thrown while eating memory.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/Algorithms.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,4 +184,1 @@\n-         * is thrown while eating memory. To avoid OOM while allocating\n-         * exception we preallocate it before the lunch starts. It means\n-         * that exception stack trace does not correspond to the place\n-         * where exception is thrown, but points at start of the method.\n+         * is thrown while eating memory.\n@@ -203,4 +200,1 @@\n-         * is thrown while eating memory. To avoid OOM while allocating\n-         * exception we preallocate it before the lunch starts. It means\n-         * that exception stack trace does not correspond to the place\n-         * where exception is thrown, but points at start of the method.\n+         * is thrown while eating memory.\n@@ -273,4 +267,1 @@\n-         * is thrown while eating memory. To avoid OOM while allocating\n-         * exception we preallocate it before the lunch starts. It means\n-         * that exception stack trace does not correspond to the place\n-         * where exception is thrown, but points at start of the method.\n+         * is thrown while eating memory.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/gp\/GarbageUtils.java","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -572,2 +572,0 @@\n-java\/nio\/channels\/AsyncCloseAndInterrupt.java                   8368290 macosx-26.0.1\n-\n@@ -728,1 +726,0 @@\n-jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java             8371014 aix-ppc64,linux-ppc64le\n@@ -801,0 +798,1 @@\n+build\/CheckFiles.java 8376088  generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2026 SAP SE. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * @summary Check for unwanted file (types\/extensions) in the jdk image\n+ * @library \/test\/lib\n+ * @requires !vm.debug\n+ * @run main CheckFiles\n+ *\/\n+public class CheckFiles {\n+\n+    \/\/ Set this property on command line to scan an alternate dir or file:\n+    \/\/ JTREG=JAVA_OPTIONS=-Djdk.test.build.CheckFiles.dir=\/path\/to\/dir\n+    public static final String DIR_PROPERTY = \"jdk.test.build.CheckFiles.dir\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String jdkPathString = System.getProperty(\"test.jdk\");\n+        Path jdkHome = Paths.get(jdkPathString);\n+\n+        Path mainDirToScan = jdkHome;\n+        String overrideDir = System.getProperty(DIR_PROPERTY);\n+        if (overrideDir != null) {\n+            mainDirToScan = Paths.get(overrideDir);\n+        }\n+\n+        System.out.println(\"Main directory to scan:\" + mainDirToScan);\n+        Path binDir = mainDirToScan.resolve(\"bin\");\n+        Path libDir = mainDirToScan.resolve(\"lib\");\n+        Path includeDir = mainDirToScan.resolve(\"include\");\n+        Path jmodsDir = mainDirToScan.resolve(\"jmods\");\n+\n+        System.out.println(\"Bin directory to scan:\" + binDir);\n+        ArrayList<String> allowedEndingsBinDir = new ArrayList<>();\n+        \/\/ UNIX - no extensions are allowed; Windows : .dll, .exe, .pdb, .jsa\n+        if (Platform.isWindows()) {\n+            allowedEndingsBinDir.add(\".dll\");\n+            allowedEndingsBinDir.add(\".exe\");\n+            allowedEndingsBinDir.add(\".pdb\");\n+            allowedEndingsBinDir.add(\".jsa\");\n+        }\n+        boolean binDirRes = scanFiles(binDir, allowedEndingsBinDir);\n+\n+        System.out.println(\"Lib directory to scan:\" + libDir);\n+        ArrayList<String> allowedEndingsLibDir = new ArrayList<>();\n+        allowedEndingsLibDir.add(\".jfc\");  \/\/ jfr config files\n+        allowedEndingsLibDir.add(\"cacerts\");\n+        allowedEndingsLibDir.add(\"blocked.certs\");\n+        allowedEndingsLibDir.add(\"public_suffix_list.dat\");\n+        allowedEndingsLibDir.add(\"classlist\");\n+        allowedEndingsLibDir.add(\"fontconfig.bfc\");\n+        allowedEndingsLibDir.add(\"fontconfig.properties.src\");\n+        allowedEndingsLibDir.add(\"ct.sym\");\n+        allowedEndingsLibDir.add(\"jrt-fs.jar\");\n+        allowedEndingsLibDir.add(\"jvm.cfg\");\n+        allowedEndingsLibDir.add(\"modules\");\n+        allowedEndingsLibDir.add(\"psfontj2d.properties\");\n+        allowedEndingsLibDir.add(\"psfont.properties.ja\");\n+        allowedEndingsLibDir.add(\"src.zip\");\n+        allowedEndingsLibDir.add(\"tzdb.dat\");\n+        if (Platform.isWindows()) {\n+            allowedEndingsLibDir.add(\".lib\");\n+            allowedEndingsLibDir.add(\"tzmappings\");\n+        } else {\n+            allowedEndingsLibDir.add(\"jexec\");\n+            allowedEndingsLibDir.add(\"jspawnhelper\");\n+            allowedEndingsLibDir.add(\".jsa\");\n+            if (Platform.isOSX()) {\n+                allowedEndingsLibDir.add(\"shaders.metallib\");\n+                allowedEndingsLibDir.add(\".dylib\");\n+            } else {\n+                allowedEndingsLibDir.add(\".so\");\n+            }\n+            if (Platform.isAix()) {\n+                allowedEndingsLibDir.add(\"tzmappings\");\n+            }\n+        }\n+        boolean libDirRes = scanFiles(libDir, allowedEndingsLibDir);\n+\n+        if (binDirRes) {\n+            System.out.println(\"Bin directory scan successful.\");\n+        } else {\n+            throw new Error(\"bin dir scan failed\");\n+        }\n+\n+        if (libDirRes) {\n+            System.out.println(\"Lib directory scan successful.\");\n+        } else {\n+            throw new Error(\"lib dir scan failed\");\n+        }\n+\n+        if (Files.isDirectory(includeDir)) {\n+            System.out.println(\"Include directory to scan:\" + includeDir);\n+            ArrayList<String> allowedEndingsIncludeDir = new ArrayList<>();\n+            allowedEndingsIncludeDir.add(\".h\");\n+            allowedEndingsIncludeDir.add(\".hpp\");\n+            boolean includeDirRes = scanFiles(includeDir, allowedEndingsIncludeDir);\n+            if (includeDirRes) {\n+                System.out.println(\"Include directory scan successful.\");\n+            } else {\n+                throw new Error(\"include dir scan failed\");\n+            }\n+        }\n+\n+        \/\/ when enabling \"JEP 493: Linking Run-Time Images without JMODs\" we do not\n+        \/\/ have the jmods folder at all, so first test the presence of the folder\n+        if (Files.isDirectory(jmodsDir)) {\n+            System.out.println(\"Jmods directory to scan:\" + jmodsDir);\n+            ArrayList<String> allowedEndingsJmodsDir = new ArrayList<>();\n+            allowedEndingsJmodsDir.add(\".jmod\");\n+            boolean jmodsDirRes = scanFiles(jmodsDir, allowedEndingsJmodsDir);\n+            if (jmodsDirRes) {\n+                System.out.println(\"Jmods directory scan successful.\");\n+            } else {\n+                throw new Error(\"jmods dir scan failed\");\n+            }\n+        }\n+    }\n+\n+    private static boolean scanFiles(Path root, ArrayList<String> allowedEndings) throws IOException {\n+        AtomicBoolean badFileFound = new AtomicBoolean(false);\n+\n+        Files.walkFileTree(root, new SimpleFileVisitor<>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                String fullFileName = file.toString();\n+                String fileName = file.getFileName().toString();\n+                System.out.println(\"  visiting file:\" + fullFileName);\n+                checkFile(fileName, allowedEndings);\n+                return super.visitFile(file, attrs);\n+            }\n+\n+            private void checkFile(String name, ArrayList<String> allowedEndings) {\n+                if (allowedEndings.isEmpty()) {  \/\/ no file extensions allowed\n+                    int lastDot = name.lastIndexOf('.');\n+                    if (lastDot > 0) {\n+                        System.out.println(\"  --> ERROR this file is not allowed:\" + name);\n+                        badFileFound.set(true);\n+                    }\n+                } else {\n+                    boolean allowed = allowedEndings.stream().anyMatch(name::endsWith);\n+                    if (! allowed) {\n+                        System.out.println(\"  --> ERROR this file is not allowed:\" + name);\n+                        badFileFound.set(true);\n+                    }\n+                }\n+            }\n+        });\n+\n+        return !badFileFound.get();\n+    }\n+}\n","filename":"test\/jdk\/build\/CheckFiles.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-        var sslContext = new SimpleSSLContext().get();\n+        var sslContext = SimpleSSLContext.findSSLContext();\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ClearTextServerSSL.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n@@ -36,0 +39,1 @@\n+import java.util.Arrays;\n@@ -60,0 +64,1 @@\n+\n@@ -64,1 +69,0 @@\n-\n@@ -67,1 +71,1 @@\n-                } else if (!validCase && isErrEmpty) {\n+                } else if (!validCase && isErrEmpty && hasPixelData(icon.getImage())) {\n@@ -71,0 +75,4 @@\n+                if (validCase && !hasPixelData(icon.getImage())) {\n+                    throw new RuntimeException(\"Test failed: the parsed image \" +\n+                            \"does not contain any pixel data\");\n+                }\n@@ -77,0 +85,14 @@\n+\n+    private static boolean hasPixelData(Image img) {\n+        int w = img.getWidth(null);\n+        int h = img.getHeight(null);\n+        BufferedImage bi = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D g = bi.createGraphics();\n+        g.drawImage(img, 0, 0, null);\n+        g.dispose();\n+        int[] pixels = bi.getRGB(0, 0, w, h, null, 0, w);\n+        if (Arrays.stream(pixels).allMatch(i -> i == 0)) {\n+            return false;\n+        }\n+        return true;\n+    }\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/XBMDecoderTest.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+#define test_width 16\n+#define test_height 3\n+#define ht_x 1\n+#define ht_y 2\n+static unsigned char test_bits[] = {\n+};\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_empty.xbm","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -1,2 +1,2 @@\n-#define k_wt 16\n-#define k_ht  1\n+#define k_width 16\n+#define k_height  1\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_hex.xbm","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+#define test_width 16\n+#define test_height 2\n+static unsigned char test_bits[] = { 0x13, 0x11, 0xAB+, 0xff };\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_plus.xbm","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+#define test_width 16\n+#define test_height 3\n+#define ht_x 1\n+#define ht_y 2\n+static unsigned char test_bits[] = {\n+0x20, 0x10, \n+0x25, 0x01, \n+0xAC, 0xab };\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/valid_multiline.xbm","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Set;\n@@ -105,0 +106,134 @@\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsLength(String testString) {\n+        if (!testString.isEmpty()) {\n+            for (Charset charset : Charset.availableCharsets().values()) {\n+                if (charset.canEncode()) {\n+                    for (Arena arena : arenas()) {\n+                        try (arena) {\n+                            MemorySegment text = arena.allocateFrom(testString, charset, 0, testString.length());\n+                            long length = text.byteSize();\n+                            assertEquals(length, testString.getBytes(charset).length);\n+                            String roundTrip = text.getString(0, charset, length);\n+                            if (charset.newEncoder().canEncode(testString)) {\n+                                assertEquals(roundTrip, testString);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsCopy(String testString) {\n+        if (!testString.isEmpty()) {\n+            for (Charset charset : Charset.availableCharsets().values()) {\n+                if (charset.canEncode()) {\n+                    for (Arena arena : arenas()) {\n+                        try (arena) {\n+                            byte[] bytes = testString.getBytes(charset);\n+                            MemorySegment text = arena.allocate(JAVA_BYTE, bytes.length);\n+                            MemorySegment.copy(testString, charset, 0, text, 0, testString.length());\n+                            String roundTrip = text.getString(0, charset, bytes.length);\n+                            if (charset.newEncoder().canEncode(testString)) {\n+                                assertEquals(roundTrip, testString);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testStringsLengthNegative() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocateFrom(\"abc\");\n+            assertThrows(IllegalArgumentException.class, () -> segment.getString(1, StandardCharsets.UTF_8, -1));\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            String testString_notBytesCompatible = \"snowman \\u26C4\";\n+            MemorySegment text = arena.allocate(JAVA_BYTE, 3);\n+            MemorySegment text_notBytesCompatible = arena.allocate(JAVA_BYTE,\n+                    testString_notBytesCompatible.getBytes(StandardCharsets.UTF_8).length);\n+            MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, testString.length());\n+            MemorySegment.copy(testString_notBytesCompatible, StandardCharsets.UTF_8, 0,\n+                    text_notBytesCompatible, 0,\n+                    testString_notBytesCompatible.length());\n+            \/\/ srcIndex < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, -1, text, 0, testString.length()));\n+            \/\/ dstOffset < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, -1, testString.length()));\n+            \/\/ numChars < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, -1));\n+            \/\/ srcIndex + numChars > length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 1, text, 0, testString.length()));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, testString.length() + 1));\n+            \/\/ dstOffset > byteSize() - B\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 1, testString.length()));\n+            \/\/ srcIndex + numChars overflows\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, Integer.MAX_VALUE, text, 0, Integer.MAX_VALUE + 3));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString_notBytesCompatible, StandardCharsets.UTF_8, Integer.MAX_VALUE, text, 0, Integer.MAX_VALUE + 3));\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocateFromThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            String testString_notBytesCompatible = \"snowman \\u26C4\";\n+            arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length());\n+            arena.allocateFrom(testString, StandardCharsets.UTF_8, 2, 1);\n+            \/\/ srcIndex < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, -1, testString.length()));\n+            \/\/ numChars < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, -1));\n+            \/\/ srcIndex + numChars > length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length() + 1));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 1, testString.length()));\n+            \/\/ srcIndex + numChars overflows\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 3, Integer.MAX_VALUE));\n+            assertThrows(IndexOutOfBoundsException.class, () -> arena.allocateFrom(\n+                    testString_notBytesCompatible, StandardCharsets.UTF_8, 3, Integer.MAX_VALUE));\n+        }\n+    }\n+\n+    @Test\n+    public void testGetStringThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            MemorySegment text = arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length());\n+            text.getString(0, StandardCharsets.UTF_8, 3);\n+            \/\/ unsupported string size\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    text.getString(0, StandardCharsets.UTF_8, Integer.MAX_VALUE + 1L));\n+            \/\/ offset < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    text.getString(-1, StandardCharsets.UTF_8, 3));\n+            \/\/ offset > byteSize() - length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    text.getString(1, StandardCharsets.UTF_8, 3));\n+            \/\/ length < 0\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    text.getString(0, StandardCharsets.UTF_8, -1));\n+        }\n+    }\n+\n@@ -224,0 +359,68 @@\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringGetString(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset, 0, testString.length());\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            \/\/ this test assumes single-byte charsets\n+                            String roundTrip = text.getString(srcIndex, charset, numChars);\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            assertEquals(roundTrip, substring);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringAllocate(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            MemorySegment text = arena.allocateFrom(testString, charset, srcIndex, numChars);\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            assertEquals(text.byteSize(), substring.getBytes(charset).length);\n+                            String roundTrip = text.getString(0, charset, text.byteSize());\n+                            assertEquals(roundTrip, substring);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringCopy(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            long length = substring.getBytes(charset).length;\n+                            MemorySegment text = arena.allocate(JAVA_BYTE, length);\n+                            long copied = MemorySegment.copy(testString, charset, srcIndex, text, 0, numChars);\n+                            String roundTrip = text.getString(0, charset, length);\n+                            assertEquals(roundTrip, substring);\n+                            assertEquals(copied, length);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -405,1 +608,1 @@\n-                {\"yen \\u00A5\"},\n+                {\"section \\u00A7\"},\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":204,"deletions":1,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import jdk.test.lib.Platform;\n@@ -106,1 +105,1 @@\n-        Space(String name) {\n+        Space(String name) throws IOException {\n@@ -110,6 +109,1 @@\n-                try {\n-                    getCDDriveSpace(name, sizes);\n-                } catch (IOException e) {\n-                    e.printStackTrace();\n-                    throw new RuntimeException(\"can't get CDDrive sizes\");\n-                }\n+                getCDDriveSpace(name, sizes);\n@@ -173,1 +167,1 @@\n-    private static void compare(Space s) {\n+    private static void compare(Space s) throws IOException {\n@@ -321,1 +315,1 @@\n-    private static int testFile(Path dir) {\n+    private static int testFile(Path dir) throws IOException {\n@@ -336,1 +330,1 @@\n-    private static int testVolumes() {\n+    private static int testVolumes() throws IOException {\n@@ -339,1 +333,2 @@\n-        \/\/ returned by File::getXSpace are equivalent to those from getSpace or getCDDriveSpace\n+        \/\/ returned by File::getXSpace are equivalent to those from getSpace\n+        \/\/ or getCDDriveSpace\n@@ -353,1 +348,12 @@\n-            Space s = new Space(p);\n+            Space s;\n+            try {\n+                s = new Space(p);\n+            } catch (IOException x) {\n+                \/\/ Avoid failing for transient file systems on Windows\n+                if (Platform.isWindows()) {\n+                    File f = new File(p);\n+                    if (!f.exists())\n+                        continue;\n+                }\n+                throw new IOException(\"Failure for volume \" + p, x);\n+            }\n@@ -411,1 +417,2 @@\n-    private static native boolean getSpace0(String root, long[] space);\n+    private static native boolean getSpace0(String root, long[] space)\n+        throws IOException;\n@@ -415,1 +422,2 @@\n-    private static boolean getSpace(String root, long[] space) {\n+    private static boolean getSpace(String root, long[] space)\n+        throws IOException {\n@@ -418,1 +426,1 @@\n-        } catch (RuntimeException e) {\n+        } catch (IOException e) {\n@@ -420,2 +428,0 @@\n-            boolean exists = f.exists();\n-            boolean readable = f.canRead();\n@@ -423,1 +429,1 @@\n-                              root, exists, readable);\n+                              root, f.exists(), f.canRead());\n","filename":"test\/jdk\/java\/io\/File\/GetXSpace.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-            JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+            JNU_ThrowByNameWithLastError(env, \"java\/io\/IOException\",\n@@ -116,1 +116,1 @@\n-            JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+            JNU_ThrowByNameWithLastError(env, \"java\/io\/IOException\",\n@@ -134,2 +134,1 @@\n-        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n-                                     \"malloc\");\n+        JNU_ThrowOutOfMemoryError(env, \"malloc\");\n@@ -149,1 +148,1 @@\n-        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+        JNU_ThrowByNameWithLastError(env, \"java\/io\/IOException\",\n","filename":"test\/jdk\/java\/io\/File\/libGetXSpace.c","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run testng ReadFieldsCNF\n- * @run testng\/othervm -Djdk.serialGetFieldCnfeReturnsNull=true ReadFieldsCNF\n+ * @run junit ReadFieldsCNF\n+ * @run junit\/othervm -Djdk.serialGetFieldCnfeReturnsNull=true ReadFieldsCNF\n@@ -44,3 +44,0 @@\n-import org.testng.annotations.Test;\n-import org.testng.Assert;\n-\n@@ -50,0 +47,3 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n@@ -61,1 +61,1 @@\n-    private static void testVectorWithRole() throws IOException {\n+    void testVectorWithRole() throws IOException {\n@@ -78,1 +78,1 @@\n-            Assert.fail(\"classname not found\");\n+            Assertions.fail(\"classname not found\");\n@@ -88,1 +88,1 @@\n-            Assert.fail(\"Should not reach here, an exception should always occur\");\n+            Assertions.fail(\"Should not reach here, an exception should always occur\");\n@@ -92,1 +92,1 @@\n-            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            Assertions.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n@@ -94,1 +94,1 @@\n-                Assert.fail(\"Expected IOException got ClassNotFoundException\", cnfe);\n+                Assertions.fail(\"Expected IOException got ClassNotFoundException\", cnfe);\n@@ -99,1 +99,1 @@\n-                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+                Assertions.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n@@ -111,1 +111,1 @@\n-    private static void testHolderWithRole() throws IOException {\n+    void testHolderWithRole() throws IOException {\n@@ -126,1 +126,1 @@\n-            Assert.fail(\"classname found at index: \" + off + \" (0x\" + Integer.toHexString(off) + \")\");\n+            Assertions.fail(\"classname found at index: \" + off + \" (0x\" + Integer.toHexString(off) + \")\");\n@@ -136,1 +136,1 @@\n-            Assert.fail(\"Should not reach here, an exception should always occur\");\n+            Assertions.fail(\"Should not reach here, an exception should always occur\");\n@@ -140,1 +140,1 @@\n-            Assert.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n+            Assertions.assertEquals(expected, cnfe.getMessage(), \"Wrong classname\");\n@@ -144,1 +144,1 @@\n-                Assert.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n+                Assertions.fail(\"Expected ClassNotFoundException got StreamCorruptedException \", ioe);\n","filename":"test\/jdk\/java\/io\/Serializable\/GetField\/ReadFieldsCNF.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run testng\/timeout=300 NonSerializableTest\n+ * @run junit\/timeout=300 NonSerializableTest\n@@ -41,0 +41,2 @@\n+import java.util.List;\n+import java.util.stream.Stream;\n@@ -42,5 +44,2 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -51,0 +50,4 @@\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -54,2 +57,2 @@\n-    @BeforeClass\n-    public void setup() throws Exception {\n+    @BeforeAll\n+    public static void setup() throws Exception {\n@@ -62,3 +65,3 @@\n-    @DataProvider\n-    public Object[][] provider() {\n-        return new String[][][] {\n+    \/\/ Test cases to compile and run\n+    public static Stream<List<String>> provider() {\n+        return Stream.of(\n@@ -66,2 +69,2 @@\n-            {{\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-d\"}},\n+            List.of(\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-d\"),\n@@ -70,2 +73,2 @@\n-            {{\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"NonSerialA_2\", \"-cp\", \".\", \"TestEntry\", \"-d\"}},\n+            List.of(\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"NonSerialA_2\", \"-cp\", \".\", \"TestEntry\", \"-d\"),\n@@ -74,2 +77,2 @@\n-            {{\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-d\"}},\n+            List.of(\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-d\"),\n@@ -78,2 +81,2 @@\n-            {{\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-doe\"}},\n+            List.of(\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"NonSerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-doe\"),\n@@ -82,2 +85,2 @@\n-            {{\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"SerialA_2\", \"-cp\", \".\", \"TestEntry\", \"-d\"}},\n+            List.of(\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"SerialA_2\", \"-cp\", \".\", \"TestEntry\", \"-d\"),\n@@ -86,2 +89,2 @@\n-            {{\"SerialA_2\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-d\"}},\n+            List.of(\"SerialA_2\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-d\"),\n@@ -90,2 +93,2 @@\n-            {{\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"SerialA_3\", \"-cp\", \".\", \"TestEntry\", \"-de\"}},\n+            List.of(\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"SerialA_3\", \"-cp\", \".\", \"TestEntry\", \"-de\"),\n@@ -94,3 +97,2 @@\n-            {{\"SerialA_3\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"}},\n-            {{\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-de\"}},\n-        };\n+            List.of(\"SerialA_3\", \"-cp\", \".\", \"TestEntry\", \"-s\", \"A\"),\n+            List.of(\"SerialA_1\", \"-cp\", \".\", \"TestEntry\", \"-de\"));\n@@ -99,2 +101,4 @@\n-    @Test(dataProvider=\"provider\")\n-    public void test(String[] args) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"provider\")\n+    public void test(List<String> argList) throws Exception {\n+        String[] args = argList.toArray(new String[0]);\n@@ -104,1 +108,1 @@\n-        String params[] = Arrays.copyOfRange(args, 1, args.length);\n+        String[] params = Arrays.copyOfRange(args, 1, args.length);\n@@ -106,3 +110,4 @@\n-        Process p = ProcessTools.startProcess(\"Serializable Test\", pb);\n-        int exitValue = p.waitFor();\n-        assertEquals(exitValue, 0, \"Test failed\");\n+        try (Process p = ProcessTools.startProcess(\"Serializable Test\", pb)) {\n+            int exitValue = p.waitFor();\n+            assertEquals(0, exitValue, \"Test failed\");\n+        }\n","filename":"test\/jdk\/java\/io\/Serializable\/class\/NonSerializableTest.java","additions":40,"deletions":35,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.io.Serial;\n@@ -53,1 +54,0 @@\n-@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -59,0 +59,1 @@\n+        @Serial\n@@ -74,0 +75,1 @@\n+        @Serial\n@@ -81,1 +83,1 @@\n-    public Object[][] recordClasses() {\n+    public static Object[][] recordClasses() {\n@@ -128,1 +130,1 @@\n-    public Object[][] notSerRecordClasses() {\n+    public static Object[][] notSerRecordClasses() {\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/RecordClassTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.io.Serial;\n@@ -47,1 +48,0 @@\n-import org.junit.jupiter.api.TestInstance;\n@@ -51,1 +51,0 @@\n-@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -55,0 +54,1 @@\n+        @Serial\n@@ -59,0 +59,1 @@\n+        @Serial\n@@ -67,0 +68,1 @@\n+        @Serial\n@@ -70,1 +72,1 @@\n-    public Object[][] recordObjects() {\n+    public static Object[][] recordObjects() {\n@@ -106,1 +108,1 @@\n-    public Object[][] recordClasses() {\n+    public static Object[][] recordClasses() {\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialVersionUIDTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,3 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.Assert;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -41,1 +41,1 @@\n- * @run testng CheckArrayTest\n+ * @run junit CheckArrayTest\n@@ -56,2 +56,2 @@\n-    @DataProvider(name = \"Patterns\")\n-    Object[][] patterns() {\n+    \/\/ Test patterns for arrays\n+    private static Object[][] patterns() {\n@@ -67,1 +67,2 @@\n-    @Test(dataProvider = \"Patterns\")\n+    @ParameterizedTest\n+    @MethodSource(\"patterns\")\n@@ -78,1 +79,1 @@\n-                Assert.assertTrue(array.length >= arraySize,\n+                Assertions.assertTrue(array.length >= arraySize,\n@@ -81,1 +82,1 @@\n-                Assert.assertFalse(array.length > arraySize,\n+                Assertions.assertFalse(array.length > arraySize,\n@@ -91,1 +92,2 @@\n-    @Test(dataProvider = \"Patterns\")\n+    @ParameterizedTest\n+    @MethodSource(\"patterns\")\n@@ -101,1 +103,1 @@\n-            Assert.assertTrue(array.length >= arraySize,\n+            Assertions.assertTrue(array.length >= arraySize,\n@@ -104,1 +106,1 @@\n-            Assert.assertFalse(array.length > arraySize,\n+            Assertions.assertFalse(array.length > arraySize,\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/CheckArrayTest.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.Serial;\n@@ -30,6 +31,4 @@\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,1 +38,1 @@\n- * @run testng\/othervm CheckInputOrderTest\n+ * @run junit\/othervm CheckInputOrderTest\n@@ -46,0 +45,1 @@\n+    @Serial\n@@ -48,2 +48,2 @@\n-    @DataProvider(name=\"Patterns\")\n-    Object[][] patterns() {\n+    \/\/ Test cases for serial filter strings\n+    static Object[][] patterns() {\n@@ -78,1 +78,2 @@\n-    @Test(dataProvider=\"Patterns\")\n+    @ParameterizedTest\n+    @MethodSource(\"patterns\")\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/CheckInputOrderTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,2 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertSame;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -38,3 +37,5 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-import org.testng.annotations.DataProvider;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -45,2 +46,2 @@\n- * @run testng\/othervm GlobalFilterTest\n- * @run testng\/othervm -Djdk.serialFilter=java.**\n+ * @run junit\/othervm GlobalFilterTest\n+ * @run junit\/othervm -Djdk.serialFilter=java.**\n@@ -50,1 +51,0 @@\n-@Test\n@@ -57,0 +57,7 @@\n+    private static final String EXPECTED_GLOBAL_FILTER = System.getProperty(\"expected-\" + serialPropName,\n+            Security.getProperty(serialPropName));\n+\n+    static boolean hasGlobalFilter() {\n+        return EXPECTED_GLOBAL_FILTER != null && !EXPECTED_GLOBAL_FILTER.isEmpty();\n+    }\n+\n@@ -61,8 +68,1 @@\n-    @DataProvider(name=\"globalPatternElements\")\n-    Object[][] globalPatternElements() {\n-        String globalFilter =\n-                System.getProperty(\"expected-\" + serialPropName,\n-                        Security.getProperty(serialPropName));\n-        if (globalFilter == null) {\n-            return new Object[0][];\n-        }\n+    static Object[][] globalPatternElements() {\n@@ -70,1 +70,1 @@\n-        String[] patterns = globalFilter.split(\";\");\n+        String[] patterns = EXPECTED_GLOBAL_FILTER.split(\";\");\n@@ -86,1 +86,1 @@\n-                Assert.assertNotNull(o, \"fail generation failed\");\n+                Assertions.assertNotNull(o, \"fail generation failed\");\n@@ -101,1 +101,1 @@\n-    static void globalFilter() {\n+    void globalFilter() {\n@@ -107,1 +107,1 @@\n-        Assert.assertNotEquals(Objects.toString(filter, null), asSetSystemProp,\n+        Assertions.assertNotEquals(asSetSystemProp, Objects.toString(filter, null),\n@@ -115,1 +115,1 @@\n-        Assert.assertEquals(Objects.toString(filter, null), pattern,\n+        assertEquals(pattern, Objects.toString(filter, null),\n@@ -123,3 +123,2 @@\n-    @Test()\n-    @SuppressWarnings(\"removal\")\n-    static void setGlobalFilter() {\n+    @Test\n+    void setGlobalFilter() {\n@@ -132,1 +131,1 @@\n-                Assert.fail(\"set only once process-wide filter\");\n+                Assertions.fail(\"set only once process-wide filter\");\n@@ -144,1 +143,1 @@\n-                Assert.fail(\"set only once process-wide filter\");\n+                Assertions.fail(\"set only once process-wide filter\");\n@@ -157,2 +156,4 @@\n-    @Test(dataProvider = \"globalPatternElements\")\n-    static void globalFilterElements(String pattern, boolean allowed,Object obj) {\n+    @ParameterizedTest\n+    @EnabledIf(\"hasGlobalFilter\")\n+    @MethodSource(\"globalPatternElements\")\n+    void globalFilterElements(String pattern, boolean allowed,Object obj) {\n@@ -180,1 +181,1 @@\n-                Assert.fail(\"Deserializing\", cnf);\n+                Assertions.fail(\"Deserializing\", cnf);\n@@ -182,1 +183,1 @@\n-            Assert.assertTrue(allowed, \"filter should have thrown an exception\");\n+            assertTrue(allowed, \"filter should have thrown an exception\");\n@@ -184,1 +185,1 @@\n-            Assert.fail(\"bad format pattern\", iae);\n+            Assertions.fail(\"bad format pattern\", iae);\n@@ -186,1 +187,1 @@\n-            Assert.assertFalse(allowed, \"filter should not have thrown an exception: \" + ice);\n+            Assertions.assertFalse(allowed, \"filter should not have thrown an exception: \" + ice);\n@@ -188,1 +189,1 @@\n-            Assert.fail(\"Unexpected IOException\", ioe);\n+            Assertions.fail(\"Unexpected IOException\", ioe);\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/GlobalFilterTest.java","additions":36,"deletions":35,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -34,0 +31,5 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -40,3 +42,3 @@\n- * @run testng\/othervm -Djdk.serialFilter=.* InvalidGlobalFilterTest\n- * @run testng\/othervm -Djdk.serialFilter=! InvalidGlobalFilterTest\n- * @run testng\/othervm -Djdk.serialFilter=\/ InvalidGlobalFilterTest\n+ * @run junit\/othervm -Djdk.serialFilter=.* InvalidGlobalFilterTest\n+ * @run junit\/othervm -Djdk.serialFilter=! InvalidGlobalFilterTest\n+ * @run junit\/othervm -Djdk.serialFilter=\/ InvalidGlobalFilterTest\n@@ -45,1 +47,0 @@\n-@Test\n@@ -67,2 +68,2 @@\n-    @DataProvider(name = \"MethodsToCall\")\n-    private Object[][] cases() {\n+    \/\/ Test cases for exceptions\n+    private static Object[][] cases() {\n@@ -70,4 +71,4 @@\n-                {serialFilter, \"getSerialFilter\", (Assert.ThrowingRunnable) () -> ObjectInputFilter.Config.getSerialFilter()},\n-                {serialFilter, \"setSerialFilter\", (Assert.ThrowingRunnable) () -> ObjectInputFilter.Config.setSerialFilter(new NoopFilter())},\n-                {serialFilter, \"new ObjectInputStream(is)\", (Assert.ThrowingRunnable) () -> new ObjectInputStream(new ByteArrayInputStream(new byte[0]))},\n-                {serialFilter, \"new OISSubclass()\", (Assert.ThrowingRunnable) () -> new OISSubclass()},\n+                {serialFilter, \"getSerialFilter\", (Executable) () -> ObjectInputFilter.Config.getSerialFilter()},\n+                {serialFilter, \"setSerialFilter\", (Executable) () -> ObjectInputFilter.Config.setSerialFilter(new NoopFilter())},\n+                {serialFilter, \"new ObjectInputStream(is)\", (Executable) () -> new ObjectInputStream(new ByteArrayInputStream(new byte[0]))},\n+                {serialFilter, \"new OISSubclass()\", (Executable) () -> new OISSubclass()},\n@@ -81,2 +82,3 @@\n-    @Test(dataProvider = \"MethodsToCall\")\n-    public void initFaultTest(String pattern, String method, Assert.ThrowingRunnable runnable) {\n+    @ParameterizedTest\n+    @MethodSource(\"cases\")\n+    public void initFaultTest(String pattern, String method, Executable runnable) {\n@@ -84,1 +86,1 @@\n-        IllegalStateException ex = Assert.expectThrows(IllegalStateException.class,\n+        IllegalStateException ex = Assertions.assertThrows(IllegalStateException.class,\n@@ -89,1 +91,1 @@\n-            Assert.fail(\"No expected message for filter: \" + serialFilter);\n+            Assertions.fail(\"No expected message for filter: \" + serialFilter);\n@@ -92,1 +94,1 @@\n-        Assert.assertEquals(ex.getMessage(), expected, \"wrong message\");\n+        Assertions.assertEquals(expected, ex.getMessage(), \"wrong message\");\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/InvalidGlobalFilterTest.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.Serial;\n@@ -31,6 +32,6 @@\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.condition.DisabledIf;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -40,2 +41,2 @@\n- * @run testng\/othervm -Djdk.serialFilter=!java.**;!java.lang.Long;maxdepth=5;maxarray=5;maxbytes=90;maxrefs=5          MixedFiltersTest\n- * @run testng\/othervm -Djdk.serialFilter=java.**;java.lang.Long;maxdepth=1000;maxarray=1000;maxbytes=1000;maxrefs=1000 MixedFiltersTest\n+ * @run junit\/othervm -Djdk.serialFilter=!java.**;!java.lang.Long;maxdepth=5;maxarray=5;maxbytes=90;maxrefs=5          MixedFiltersTest\n+ * @run junit\/othervm -Djdk.serialFilter=java.**;java.lang.Long;maxdepth=1000;maxarray=1000;maxbytes=1000;maxrefs=1000 MixedFiltersTest\n@@ -49,0 +50,1 @@\n+    @Serial\n@@ -51,0 +53,2 @@\n+    private static final String JDK_SERIAL_FILTER = System.getProperty(\"jdk.serialFilter\",\n+            Security.getProperty(\"jdk.serialFilter\"));\n@@ -52,7 +56,2 @@\n-    boolean globalRejected;\n-\n-    @BeforeClass\n-    public void setup() {\n-        String pattern = System.getProperty(\"jdk.serialFilter\",\n-                Security.getProperty(\"jdk.serialFilter\"));\n-        globalRejected = pattern.startsWith(\"!\");\n+    private static boolean globalRejected() {\n+        return JDK_SERIAL_FILTER.startsWith(\"!\");\n@@ -61,5 +60,1 @@\n-    @DataProvider(name=\"RejectedInGlobal\")\n-    Object[][] rejectedInGlobal() {\n-        if (!globalRejected) {\n-            return new Object[0][];\n-        }\n+    static Object[][] rejectedInGlobal() {\n@@ -82,1 +77,3 @@\n-    @Test(dataProvider=\"RejectedInGlobal\")\n+    @ParameterizedTest\n+    @EnabledIf(\"globalRejected\")\n+    @MethodSource(\"rejectedInGlobal\")\n@@ -99,6 +96,1 @@\n-    @DataProvider(name=\"AllowedInGlobal\")\n-    Object[][] allowedInGlobal() {\n-        if (globalRejected) {\n-            return new Object[0][];\n-        }\n-\n+    static Object[][] allowedInGlobal() {\n@@ -121,1 +113,3 @@\n-    @Test(dataProvider=\"AllowedInGlobal\")\n+    @ParameterizedTest\n+    @DisabledIf(\"globalRejected\")\n+    @MethodSource(\"allowedInGlobal\")\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/MixedFiltersTest.java","additions":23,"deletions":29,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n@@ -49,0 +45,4 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -50,2 +50,2 @@\n- * @run testng\/othervm SerialFactoryExample\n- * @run testng\/othervm -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread SerialFactoryExample\n+ * @run junit\/othervm SerialFactoryExample\n+ * @run junit\/othervm -Djdk.serialFilterFactory=SerialFactoryExample$FilterInThread SerialFactoryExample\n@@ -79,1 +79,0 @@\n-@Test\n@@ -82,1 +81,1 @@\n-    @DataProvider(name = \"Examples\")\n+    \/\/ Test cases for filters\n@@ -111,1 +110,2 @@\n-    @Test(dataProvider = \"Examples\")\n+    @ParameterizedTest\n+    @MethodSource(\"examples\")\n@@ -131,1 +131,1 @@\n-                Assert.fail(\"IllegalClassException should have occurred\");\n+                Assertions.fail(\"IllegalClassException should have occurred\");\n@@ -134,2 +134,2 @@\n-            Assert.assertEquals(ioe.getClass(), InvalidClassException.class, \"Wrong exception\");\n-            Assert.assertEquals(REJECTED, expected, \"Exception should not have occurred\");\n+            Assertions.assertEquals(InvalidClassException.class, ioe.getClass(), \"Wrong exception\");\n+            Assertions.assertEquals(expected, REJECTED, \"Exception should not have occurred\");\n@@ -145,1 +145,2 @@\n-    @Test(dataProvider = \"Examples\")\n+    @ParameterizedTest\n+    @MethodSource(\"examples\")\n@@ -169,1 +170,1 @@\n-                    Assert.assertEquals(actualStatus, expected, \"Wrong Status\");\n+                    Assertions.assertEquals(expected, actualStatus, \"Wrong Status\");\n@@ -174,1 +175,1 @@\n-            Assert.fail(\"unexpected exception\", ex);\n+            Assertions.fail(\"unexpected exception\", ex);\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryExample.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -35,0 +32,5 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -36,4 +38,4 @@\n- * @run testng\/othervm  -Djdk.serialFilterFactory=ForcedError_NoSuchClass SerialFactoryFaults\n- * @run testng\/othervm  -Djdk.serialFilterFactory=SerialFactoryFaults$NoPublicConstructor SerialFactoryFaults\n- * @run testng\/othervm  -Djdk.serialFilterFactory=SerialFactoryFaults$ConstructorThrows SerialFactoryFaults\n- * @run testng\/othervm  -Djdk.serialFilterFactory=SerialFactoryFaults$FactorySetsFactory SerialFactoryFaults\n+ * @run junit\/othervm  -Djdk.serialFilterFactory=ForcedError_NoSuchClass SerialFactoryFaults\n+ * @run junit\/othervm  -Djdk.serialFilterFactory=SerialFactoryFaults$NoPublicConstructor SerialFactoryFaults\n+ * @run junit\/othervm  -Djdk.serialFilterFactory=SerialFactoryFaults$ConstructorThrows SerialFactoryFaults\n+ * @run junit\/othervm  -Djdk.serialFilterFactory=SerialFactoryFaults$FactorySetsFactory SerialFactoryFaults\n@@ -43,1 +45,0 @@\n-@Test\n@@ -55,2 +56,2 @@\n-    @DataProvider(name = \"MethodsToCall\")\n-    private Object[][] cases() {\n+    \/\/ Test cases of faults\n+    private static Object[][] cases() {\n@@ -58,4 +59,4 @@\n-                {\"getSerialFilterFactory\", (Assert.ThrowingRunnable) () -> Config.getSerialFilterFactory()},\n-                {\"setSerialFilterFactory\", (Assert.ThrowingRunnable) () -> Config.setSerialFilterFactory(new NoopFactory())},\n-                {\"new ObjectInputStream(is)\", (Assert.ThrowingRunnable) () -> new ObjectInputStream(new ByteArrayInputStream(new byte[0]))},\n-                {\"new OISSubclass()\", (Assert.ThrowingRunnable) () -> new OISSubclass()},\n+                {\"getSerialFilterFactory\", (Executable) () -> Config.getSerialFilterFactory()},\n+                {\"setSerialFilterFactory\", (Executable) () -> Config.setSerialFilterFactory(new NoopFactory())},\n+                {\"new ObjectInputStream(is)\", (Executable) () -> new ObjectInputStream(new ByteArrayInputStream(new byte[0]))},\n+                {\"new OISSubclass()\", (Executable) () -> new OISSubclass()},\n@@ -69,3 +70,4 @@\n-    @Test(dataProvider = \"MethodsToCall\")\n-    public void initFaultTest(String name, Assert.ThrowingRunnable runnable) {\n-        IllegalStateException ex = Assert.expectThrows(IllegalStateException.class,\n+    @ParameterizedTest\n+    @MethodSource(\"cases\")\n+    public void initFaultTest(String name, Executable runnable) {\n+        IllegalStateException ex = Assertions.assertThrows(IllegalStateException.class,\n@@ -76,2 +78,1 @@\n-            Assert.assertEquals(msg,\n-                    \"invalid jdk.serialFilterFactory: ForcedError_NoSuchClass: java.lang.ClassNotFoundException: ForcedError_NoSuchClass\", \"wrong exception\");\n+            Assertions.assertEquals(\"invalid jdk.serialFilterFactory: ForcedError_NoSuchClass: java.lang.ClassNotFoundException: ForcedError_NoSuchClass\", msg, \"wrong exception\");\n@@ -79,2 +80,1 @@\n-            Assert.assertEquals(msg,\n-                    \"invalid jdk.serialFilterFactory: SerialFactoryFaults$NoPublicConstructor: java.lang.NoSuchMethodException: SerialFactoryFaults$NoPublicConstructor.<init>()\", \"wrong exception\");\n+            Assertions.assertEquals(\"invalid jdk.serialFilterFactory: SerialFactoryFaults$NoPublicConstructor: java.lang.NoSuchMethodException: SerialFactoryFaults$NoPublicConstructor.<init>()\", msg, \"wrong exception\");\n@@ -82,2 +82,1 @@\n-            Assert.assertEquals(msg,\n-                    \"invalid jdk.serialFilterFactory: SerialFactoryFaults$ConstructorThrows: java.lang.RuntimeException: constructor throwing a runtime exception\", \"wrong exception\");\n+            Assertions.assertEquals(\"invalid jdk.serialFilterFactory: SerialFactoryFaults$ConstructorThrows: java.lang.RuntimeException: constructor throwing a runtime exception\", msg, \"wrong exception\");\n@@ -85,2 +84,1 @@\n-            Assert.assertEquals(msg,\n-                    \"invalid jdk.serialFilterFactory: SerialFactoryFaults$FactorySetsFactory: java.lang.IllegalStateException: Serial filter factory initialization incomplete\", \"wrong exception\");\n+            Assertions.assertEquals(\"invalid jdk.serialFilterFactory: SerialFactoryFaults$FactorySetsFactory: java.lang.IllegalStateException: Serial filter factory initialization incomplete\", msg, \"wrong exception\");\n@@ -88,1 +86,1 @@\n-            Assert.fail(\"No test for filter factory: \" + factoryName);\n+            Assertions.fail(\"No test for filter factory: \" + factoryName);\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFactoryFaults.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -41,0 +38,9 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.MethodOrderer;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -43,2 +49,2 @@\n- * @run testng\/othervm SerialFilterFactoryTest\n- * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$PropertyFilterFactory\n+ * @run junit\/othervm SerialFilterFactoryTest\n+ * @run junit\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$PropertyFilterFactory\n@@ -46,1 +52,1 @@\n- * @run testng\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$NotMyFilterFactory\n+ * @run junit\/othervm -Djdk.serialFilterFactory=SerialFilterFactoryTest$NotMyFilterFactory\n@@ -51,1 +57,1 @@\n-@Test\n+@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\n@@ -73,1 +79,1 @@\n-            Assert.fail(\"unexpected IOE\", ioe);\n+            Assertions.fail(\"unexpected IOE\", ioe);\n@@ -112,1 +118,1 @@\n-    @DataProvider(name=\"FilterCases\")\n+    \/\/ Test cases for filter factory\n@@ -127,1 +133,1 @@\n-    @Test(expectedExceptions=NullPointerException.class)\n+    @Test\n@@ -129,1 +135,3 @@\n-        Config.setSerialFilterFactory(null);\n+        Assertions.assertThrows(NullPointerException.class, () -> {\n+            Config.setSerialFilterFactory(null);\n+        });\n@@ -139,1 +147,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -148,1 +155,1 @@\n-                Assert.fail(\"First setSerialFilterFactory should not throw\");\n+                Assertions.fail(\"First setSerialFilterFactory should not throw\");\n@@ -152,1 +159,1 @@\n-        Assert.expectThrows(IllegalStateException.class,\n+        Assertions.assertThrows(IllegalStateException.class,\n@@ -155,1 +162,1 @@\n-        Assert.assertEquals(resetFF, currFF, \"Setting again should not change filter factory\");\n+        Assertions.assertEquals(currFF, resetFF, \"Setting again should not change filter factory\");\n@@ -170,2 +177,4 @@\n-    @Test(dataProvider=\"FilterCases\")\n-    @SuppressWarnings(\"removal\")\n+    @ParameterizedTest\n+    @EnabledIf(\"isValidFilterFactory\")\n+    @MethodSource(\"filterCases\")\n+    @Order(1)\n@@ -185,2 +194,2 @@\n-        Assert.assertNull(factory.current(), \"initially current should be null\");\n-        Assert.assertEquals(factory.next(), configFilter, \"initially next should be the configured filter\");\n+        Assertions.assertNull(factory.current(), \"initially current should be null\");\n+        Assertions.assertEquals(configFilter, factory.next(), \"initially next should be the configured filter\");\n@@ -190,1 +199,1 @@\n-            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be configured filter\");\n+            Assertions.assertEquals(configFilter, currFilter, \"getObjectInputFilter should be configured filter\");\n@@ -192,1 +201,1 @@\n-            Assert.assertEquals(currFilter, configFilter, \"getObjectInputFilter should be null\");\n+            Assertions.assertEquals(configFilter, currFilter, \"getObjectInputFilter should be null\");\n@@ -197,2 +206,2 @@\n-            Assert.assertEquals(factory.current(), currFilter, \"when setObjectInputFilter, current should be current filter\");\n-            Assert.assertEquals(factory.next(), streamFilter, \"next should be stream specific filter\");\n+            Assertions.assertEquals(currFilter, factory.current(), \"when setObjectInputFilter, current should be current filter\");\n+            Assertions.assertEquals(streamFilter, factory.next(), \"next should be stream specific filter\");\n@@ -202,1 +211,1 @@\n-            Assert.assertEquals(currFilter, streamFilter, \"getObjectInputFilter should be set\");\n+            Assertions.assertEquals(streamFilter, currFilter, \"getObjectInputFilter should be set\");\n@@ -205,1 +214,1 @@\n-            Assert.assertThrows(IllegalStateException.class, () -> ois.setObjectInputFilter(streamFilter));\n+            Assertions.assertThrows(IllegalStateException.class, () -> ois.setObjectInputFilter(streamFilter));\n@@ -210,1 +219,1 @@\n-            Assert.assertEquals(validator.count, 1, \"Wrong number of calls to the stream filter\");\n+            Assertions.assertEquals(1, validator.count, \"Wrong number of calls to the stream filter\");\n@@ -220,1 +229,1 @@\n-            Assert.assertEquals(jdkSerialFilterFactory.getClass().getName(), jdkSerialFilterFactoryProp,\n+            Assertions.assertEquals(jdkSerialFilterFactoryProp, jdkSerialFilterFactory.getClass().getName(),\n@@ -227,1 +236,2 @@\n-    @Test(dependsOnMethods=\"testCase\")\n+    @Test\n+    @Order(99)\n@@ -230,2 +240,2 @@\n-        IllegalStateException ise = Assert.expectThrows(IllegalStateException.class, () -> Config.setSerialFilterFactory(factory));\n-        Assert.assertTrue(ise.getMessage().startsWith(\"Cannot replace filter factory: \"));\n+        IllegalStateException ise = Assertions.assertThrows(IllegalStateException.class, () -> Config.setSerialFilterFactory(factory));\n+        Assertions.assertTrue(ise.getMessage().startsWith(\"Cannot replace filter factory: \"));\n@@ -246,1 +256,1 @@\n-                Assert.fail(\"setting filter to null after a non-null filter should throw\");\n+                Assertions.fail(\"setting filter to null after a non-null filter should throw\");\n@@ -250,1 +260,1 @@\n-                Assert.fail(\"setting filter to null after a null filter should not throw\");\n+                Assertions.fail(\"setting filter to null after a null filter should not throw\");\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFactoryTest.java","additions":43,"deletions":33,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,0 @@\n-\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n@@ -38,0 +33,5 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm -Djava.util.logging.config.file=${test.src}\/logging.properties\n+ * @run junit\/othervm -Djava.util.logging.config.file=${test.src}\/logging.properties\n@@ -43,1 +43,0 @@\n-@Test\n@@ -56,1 +55,1 @@\n-                Assert.assertEquals(merge(st1, st2), r, \"merge\");\n+                Assertions.assertEquals(r, merge(st1, st2), \"merge\");\n@@ -58,2 +57,2 @@\n-            Assert.assertSame(ObjectInputFilter.merge(filter1, null), filter1, \"merge with null fail\");\n-            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.merge(null, filter1));\n+            Assertions.assertSame(ObjectInputFilter.merge(filter1, null), filter1, \"merge with null fail\");\n+            Assertions.assertThrows(NullPointerException.class, () -> ObjectInputFilter.merge(null, filter1));\n@@ -87,1 +86,1 @@\n-    @DataProvider(name = \"AllowPredicateCases\")\n+    \/\/ Test cases of filter strings\n@@ -98,1 +97,2 @@\n-    @Test(dataProvider = \"AllowPredicateCases\")\n+    @ParameterizedTest\n+    @MethodSource(\"allowPredicateCases\")\n@@ -102,1 +102,1 @@\n-            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+            Assertions.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n@@ -104,2 +104,1 @@\n-            Assert.assertEquals(ObjectInputFilter.allowFilter(predicate, otherStatus).checkInput(info),\n-                    expected, \"Predicate result\");\n+            Assertions.assertEquals(                    expected, ObjectInputFilter.allowFilter(predicate, otherStatus).checkInput(info), \"Predicate result\");\n@@ -109,1 +108,0 @@\n-    @DataProvider(name = \"RejectPredicateCases\")\n@@ -120,1 +118,2 @@\n-    @Test(dataProvider = \"RejectPredicateCases\")\n+    @ParameterizedTest\n+    @MethodSource(\"rejectPredicateCases\")\n@@ -124,1 +123,1 @@\n-            Assert.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n+            Assertions.assertThrows(NullPointerException.class, () -> ObjectInputFilter.allowFilter(predicate, expected));\n@@ -126,2 +125,2 @@\n-            Assert.assertEquals(ObjectInputFilter.rejectFilter(predicate, otherStatus)\n-                    .checkInput(info), expected, \"Predicate result\");\n+            Assertions.assertEquals(expected, ObjectInputFilter.rejectFilter(predicate, otherStatus)\n+                    .checkInput(info), \"Predicate result\");\n@@ -136,1 +135,1 @@\n-        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(undecided).checkInput(info), REJECTED, \"undecided -> rejected\");\n+        Assertions.assertEquals(REJECTED, ObjectInputFilter.rejectUndecidedClass(undecided).checkInput(info), \"undecided -> rejected\");\n@@ -138,1 +137,1 @@\n-        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(allowed).checkInput(info), ALLOWED, \"allowed -> rejected\");\n+        Assertions.assertEquals(ALLOWED, ObjectInputFilter.rejectUndecidedClass(allowed).checkInput(info), \"allowed -> rejected\");\n@@ -140,1 +139,1 @@\n-        Assert.assertEquals(ObjectInputFilter.rejectUndecidedClass(rejected).checkInput(info), REJECTED, \"rejected -> rejected\");\n+        Assertions.assertEquals(REJECTED, ObjectInputFilter.rejectUndecidedClass(rejected).checkInput(info), \"rejected -> rejected\");\n@@ -167,1 +166,1 @@\n-                Assert.assertEquals(st, expected, \"Wrong status for class: \" + obj.getClass());\n+                Assertions.assertEquals(expected, st, \"Wrong status for class: \" + obj.getClass());\n@@ -169,1 +168,1 @@\n-                Assert.assertEquals(rawSt, st, \"raw filter and rejectUndecided filter disagree\");\n+                Assertions.assertEquals(st, rawSt, \"raw filter and rejectUndecided filter disagree\");\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterFunctionTest.java","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,4 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-import org.testng.annotations.DataProvider;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -56,1 +57,1 @@\n- * @run testng\/othervm -Djava.util.logging.config.file=${test.src}\/logging.properties\n+ * @run junit\/othervm -Djava.util.logging.config.file=${test.src}\/logging.properties\n@@ -58,1 +59,1 @@\n- * @run testng\/othervm -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n+ * @run junit\/othervm -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n@@ -62,1 +63,0 @@\n-@Test\n@@ -92,1 +92,0 @@\n-    @DataProvider(name=\"Patterns\")\n@@ -94,1 +93,1 @@\n-        Object[][] patterns = new Object[][]{\n+        return new Object[][]{\n@@ -108,1 +107,0 @@\n-        return patterns;\n@@ -111,1 +109,0 @@\n-    @DataProvider(name=\"InvalidPatterns\")\n@@ -123,1 +120,0 @@\n-    @DataProvider(name=\"Limits\")\n@@ -136,1 +132,0 @@\n-    @DataProvider(name=\"InvalidLimits\")\n@@ -160,1 +155,0 @@\n-    @DataProvider(name=\"Objects\")\n@@ -171,1 +165,1 @@\n-            Assert.fail(\"missing class: \" + className, e);\n+            Assertions.fail(\"missing class: \" + className, e);\n@@ -216,1 +210,0 @@\n-    @DataProvider(name=\"Arrays\")\n@@ -247,1 +240,2 @@\n-    @Test(dataProvider=\"Objects\")\n+    @ParameterizedTest\n+    @MethodSource(\"objects\")\n@@ -254,8 +248,8 @@\n-        System.out.printf(\"v: %s%n\", validator);\n-\n-        Assert.assertEquals(validator.count, count, \"callback count wrong\");\n-        Assert.assertEquals(validator.classes, classes, \"classes mismatch\");\n-        Assert.assertEquals(validator.maxArray, maxArray, \"maxArray mismatch\");\n-        Assert.assertEquals(validator.maxRefs, maxRefs, \"maxRefs wrong\");\n-        Assert.assertEquals(validator.maxDepth, maxDepth, \"depth wrong\");\n-        Assert.assertEquals(validator.maxBytes, maxBytes, \"maxBytes wrong\");\n+        System.err.printf(\"v: %s%n\", validator);\n+\n+        Assertions.assertEquals(count, validator.count, \"callback count wrong\");\n+        Assertions.assertEquals(classes, validator.classes, \"classes mismatch\");\n+        Assertions.assertEquals(maxArray, validator.maxArray, \"maxArray mismatch\");\n+        Assertions.assertEquals(maxRefs, validator.maxRefs, \"maxRefs wrong\");\n+        Assertions.assertEquals(maxDepth, validator.maxDepth, \"depth wrong\");\n+        Assertions.assertEquals(maxBytes, validator.maxBytes, \"maxBytes wrong\");\n@@ -272,1 +266,2 @@\n-    @Test(dataProvider=\"Patterns\")\n+    @ParameterizedTest\n+    @MethodSource(\"patterns\")\n@@ -300,1 +295,1 @@\n-                    Assert.assertEquals(global, initial, \"initial filter should be the global filter\");\n+                    Assertions.assertEquals(initial, global, \"initial filter should be the global filter\");\n@@ -306,1 +301,1 @@\n-                        Assert.fail(\"Should not be able to set filter twice\");\n+                        Assertions.fail(\"Should not be able to set filter twice\");\n@@ -311,1 +306,1 @@\n-                    Assert.fail(\"Should not reach end-of-file\", eof);\n+                    Assertions.fail(\"Should not reach end-of-file\", eof);\n@@ -313,1 +308,1 @@\n-                    Assert.fail(\"Deserializing\", cnf);\n+                    Assertions.fail(\"Deserializing\", cnf);\n@@ -316,1 +311,1 @@\n-                Assert.fail(\"Unexpected IOException\", ex);\n+                Assertions.fail(\"Unexpected IOException\", ex);\n@@ -339,1 +334,1 @@\n-                Assert.assertEquals(actual1, expected1, \"unexpected string\");\n+                Assertions.assertEquals(expected1, actual1, \"unexpected string\");\n@@ -348,1 +343,1 @@\n-                    Assert.fail(\"Should not be able to set filter after readObject has been called\");\n+                    Assertions.fail(\"Should not be able to set filter after readObject has been called\");\n@@ -352,1 +347,1 @@\n-                    Assert.fail(\"With jdk.serialSetFilterAfterRead property set = true; \" +\n+                    Assertions.fail(\"With jdk.serialSetFilterAfterRead property set = true; \" +\n@@ -355,1 +350,1 @@\n-                Assert.fail(\"Should not reach end-of-file\", eof);\n+                Assertions.fail(\"Should not reach end-of-file\", eof);\n@@ -365,1 +360,2 @@\n-    @Test(dataProvider=\"Arrays\")\n+    @ParameterizedTest\n+    @MethodSource(\"arrays\")\n@@ -370,1 +366,1 @@\n-        Assert.assertEquals(o.getClass(), array.getClass(), \"Filter not called with the array\");\n+        Assertions.assertEquals(array.getClass(), o.getClass(), \"Filter not called with the array\");\n@@ -382,1 +378,2 @@\n-    @Test(dataProvider=\"Limits\")\n+    @ParameterizedTest\n+    @MethodSource(\"limits\")\n@@ -387,1 +384,1 @@\n-        Assert.assertEquals(\n+        Assertions.assertEquals(ObjectInputFilter.Status.REJECTED,\n@@ -389,1 +386,0 @@\n-                ObjectInputFilter.Status.REJECTED,\n@@ -391,1 +387,1 @@\n-        Assert.assertEquals(\n+        Assertions.assertEquals(ObjectInputFilter.Status.UNDECIDED,\n@@ -393,1 +389,0 @@\n-                ObjectInputFilter.Status.UNDECIDED,\n@@ -402,1 +397,2 @@\n-    @Test(dataProvider=\"InvalidLimits\", expectedExceptions=java.lang.IllegalArgumentException.class)\n+    @ParameterizedTest\n+    @MethodSource(\"invalidLimits\")\n@@ -404,6 +400,3 @@\n-        try {\n-            ObjectInputFilter filter = ObjectInputFilter.Config.createFilter(pattern);\n-        } catch (IllegalArgumentException iae) {\n-            System.out.printf(\"    success exception: %s%n\", iae);\n-            throw iae;\n-        }\n+        var iae = Assertions.assertThrows(IllegalArgumentException.class,\n+                () -> ObjectInputFilter.Config.createFilter(pattern));\n+        System.err.printf(\"    success exception: %s%n\", iae);\n@@ -415,1 +408,1 @@\n-    @Test(expectedExceptions=InvalidClassException.class)\n+    @Test\n@@ -417,11 +410,5 @@\n-        byte[] bytes = writeObjects(0); \/\/ an Integer\n-        try {\n-            Object o = validate(bytes, new ObjectInputFilter() {\n-                public ObjectInputFilter.Status checkInput(ObjectInputFilter.FilterInfo f) {\n-                    return null;\n-                }\n-            });\n-        } catch (InvalidClassException ice) {\n-            System.out.printf(\"    success exception: %s%n\", ice);\n-            throw ice;\n-        }\n+        var ice = Assertions.assertThrows(InvalidClassException.class, () -> {\n+            byte[] bytes = writeObjects(0); \/\/ an Integer\n+            validate(bytes, f -> null);\n+        });\n+        System.err.printf(\"    success exception: %s%n\", ice);\n@@ -434,1 +421,2 @@\n-    @Test(dataProvider=\"InvalidPatterns\", expectedExceptions=IllegalArgumentException.class)\n+    @ParameterizedTest\n+    @MethodSource(\"invalidPatterns\")\n@@ -436,6 +424,3 @@\n-        try {\n-            ObjectInputFilter.Config.createFilter(pattern);\n-        } catch (IllegalArgumentException iae) {\n-            System.out.printf(\"    success exception: %s%n\", iae);\n-            throw iae;\n-        }\n+        var iae = Assertions.assertThrows(IllegalArgumentException.class,\n+                () -> ObjectInputFilter.Config.createFilter(pattern));\n+        System.err.printf(\"    success exception: %s%n\", iae);\n@@ -450,1 +435,1 @@\n-        Assert.assertNull(filter, \"empty pattern did not return null\");\n+        Assertions.assertNull(filter, \"empty pattern did not return null\");\n@@ -453,1 +438,1 @@\n-        Assert.assertNull(filter, \"pattern with only delimiters did not return null\");\n+        Assertions.assertNull(filter, \"pattern with only delimiters did not return null\");\n@@ -475,1 +460,1 @@\n-            Assert.fail(\"Deserializing\", cnf);\n+            Assertions.fail(\"Deserializing\", cnf);\n@@ -517,1 +502,1 @@\n-            System.out.printf(\"     checkInput: class: %s, arrayLen: %d, refs: %d, depth: %d, bytes; %d%n\",\n+            System.err.printf(\"     checkInput: class: %s, arrayLen: %d, refs: %d, depth: %d, bytes; %d%n\",\n@@ -564,1 +549,1 @@\n-            Assert.assertTrue(allowed, \"filter should have thrown an exception\");\n+            Assertions.assertTrue(allowed, \"filter should have thrown an exception\");\n@@ -566,1 +551,1 @@\n-            Assert.fail(\"bad format pattern\", iae);\n+            Assertions.fail(\"bad format pattern\", iae);\n@@ -568,1 +553,1 @@\n-            Assert.assertFalse(allowed, \"filter should not have thrown an exception: \" + ice);\n+            Assertions.assertFalse(allowed, \"filter should not have thrown an exception: \" + ice);\n@@ -570,1 +555,1 @@\n-            Assert.fail(\"Unexpected IOException\", ioe);\n+            Assertions.fail(\"Unexpected IOException\", ioe);\n@@ -581,1 +566,1 @@\n-        Assert.assertNotNull(o, \"success generation failed\");\n+        Assertions.assertNotNull(o, \"success generation failed\");\n@@ -586,1 +571,1 @@\n-        Assert.assertNotNull(o, \"fail generation failed\");\n+        Assertions.assertNotNull(o, \"fail generation failed\");\n@@ -619,1 +604,1 @@\n-                Assert.fail(\"no such class available: \" + pattern);\n+                Assertions.fail(\"no such class available: \" + pattern);\n@@ -624,1 +609,1 @@\n-                Assert.fail(\"newInstance: \" + ex1);\n+                Assertions.fail(\"newInstance: \" + ex1);\n@@ -664,1 +649,1 @@\n-        Assert.fail(\"Object could not be generated for pattern: \"\n+        Assertions.fail(\"Object could not be generated for pattern: \"\n@@ -680,1 +665,1 @@\n-        Assert.assertNotEquals(ndx, -1, \"missing value in limit\");\n+        Assertions.assertNotEquals(-1, ndx, \"missing value in limit\");\n@@ -706,1 +691,1 @@\n-        Assert.fail(\"Object could not be generated for pattern: \"\n+        Assertions.fail(\"Object could not be generated for pattern: \"\n@@ -739,1 +724,1 @@\n-                Assert.fail(\"exception generating stream\", ie);\n+                Assertions.fail(\"exception generating stream\", ie);\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":69,"deletions":84,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=parked\n+ * @bug 8369227\n+ * @summary Stress test untimed park after a timed park when a thread is unparked around the\n+ *     same time that the timeout expires.\n+ * @library \/test\/lib\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED ParkAfterTimedPark 200 false\n+ *\/\n+\n+\/*\n+ * @test id=pinned\n+ * @summary Stress test untimed park, while pinned, and after a timed park when a thread is\n+ *     unparked around the same time that the timeout expires.\n+ * @library \/test\/lib\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED ParkAfterTimedPark 200 true\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import jdk.test.lib.thread.VThreadPinner;\n+\n+public class ParkAfterTimedPark {\n+    public static void main(String[] args) throws Exception {\n+        int iterations = (args.length > 0) ? Integer.parseInt(args[0]) : 100;\n+        boolean pinned = (args.length > 1) ? Boolean.parseBoolean(args[1]) : false;\n+\n+        for (int i = 1; i <= iterations; i++) {\n+            System.out.println(Instant.now() + \" => \" + i + \" of \" + iterations);\n+            for (int timeout = 1; timeout <= 10; timeout++) {\n+                test(timeout, true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates two virtual threads. The first does a timed-park for the given time,\n+     * then parks in CountDownLatch.await. A second virtual thread unparks the first\n+     * around the same time that the timeout for the first expires.\n+     *\/\n+    private static void test(int millis, boolean pinned) throws Exception {\n+        long nanos = TimeUnit.MILLISECONDS.toNanos(millis);\n+\n+        var finish = new CountDownLatch(1);\n+\n+        Thread thread1 = Thread.startVirtualThread(() -> {\n+            LockSupport.parkNanos(nanos);\n+            boolean done = false;\n+            while (!done) {\n+                try {\n+                    if (pinned) {\n+                        VThreadPinner.runPinned(() -> {\n+                            finish.await();\n+                        });\n+                    } else {\n+                        finish.await();\n+                    }\n+                    done = true;\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+\n+        Thread thread2 = Thread.startVirtualThread(() -> {\n+            int delta = ThreadLocalRandom.current().nextInt(millis);\n+            boolean done = false;\n+            while (!done) {\n+                try {\n+                    Thread.sleep(millis - delta);\n+                    done = true;\n+                } catch (InterruptedException e) { }\n+            }\n+            LockSupport.unpark(thread1);\n+        });\n+\n+        \/\/ wait for first thread to park before count down\n+        await(thread1, Thread.State.WAITING);\n+        finish.countDown();\n+\n+        thread1.join();\n+        thread2.join();\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private static void await(Thread thread, Thread.State expectedState) throws Exception {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+             if (state == Thread.State.TERMINATED)\n+                 throw new RuntimeException(\"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/ParkAfterTimedPark.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -97,2 +97,7 @@\n-                    if (ThreadLocalRandom.current().nextBoolean()) {\n-                        synchronized (lock) {\n+                    executor.submit(() -> {\n+                        if (ThreadLocalRandom.current().nextBoolean()) {\n+                            synchronized (lock) {\n+                                sleepLessThan(timeout);\n+                                lock.notifyAll();\n+                            }\n+                        } else {\n@@ -100,6 +105,3 @@\n-                            lock.notifyAll();\n-                        }\n-                    } else {\n-                        sleepLessThan(timeout);\n-                        synchronized (lock) {\n-                            lock.notifyAll();\n+                            synchronized (lock) {\n+                                lock.notifyAll();\n+                            }\n@@ -107,1 +109,2 @@\n-                    }\n+                        return null;\n+                    });\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/TimedWaitALot.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,10 +145,6 @@\n-        try {\n-            HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n-                public boolean verify(String hostname, SSLSession session) {\n-                    return true;\n-                }\n-            });\n-            SSLContext.setDefault(new SimpleSSLContext().get());\n-        } catch (IOException ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n+        HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n+            public boolean verify(String hostname, SSLSession session) {\n+                return true;\n+            }\n+        });\n+        SSLContext.setDefault(SimpleSSLContext.findSSLContext());\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/SetAuthenticator\/HTTPTest.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-            \/\/               new SimpleSSLContext().get().getSocketFactory());\n+            \/\/               SimpleSSLContext.findSSLContext().getSocketFactory());\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/SetAuthenticator\/HTTPTestClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,1 +226,1 @@\n-    static SSLContext ctx;\n+    private static final SSLContext ctx = SimpleSSLContext.findSSLContext();\n@@ -246,2 +246,0 @@\n-\n-        ctx = new SimpleSSLContext().get();\n","filename":"test\/jdk\/java\/net\/URLPermission\/URLTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,2 @@\n-            Duration.ofMillis(Long.parseLong(System.getProperty(\"test.requestTimeoutMillis\")));\n+            Duration.ofMillis(jdk.test.lib.Utils.adjustTimeout(\n+                Long.parseLong(System.getProperty(\"test.requestTimeoutMillis\"))));\n@@ -90,1 +91,2 @@\n-            Long.parseLong(System.getProperty(\"test.responseFailureWaitDurationMillis\", \"0\"));\n+            jdk.test.lib.Utils.adjustTimeout(\n+                Long.parseLong(System.getProperty(\"test.responseFailureWaitDurationMillis\", \"0\")));\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseTestSupport.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,927 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpServer;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.util.FileUtils;\n-import sun.net.www.ParseUtil;\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.io.UncheckedIOException;\n-import java.lang.reflect.Method;\n-import java.net.HttpURLConnection;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.URI;\n-import java.nio.CharBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n-import java.security.Security;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @summary Tests security properties passed through java.security,\n- *   java.security.properties or included from other properties files.\n- * @bug 8155246 8292297 8292177 8281658 8319332\n- * @modules java.base\/sun.net.www\n- * @library \/test\/lib\n- * @run main ConfigFileTest\n- *\/\n-\n-public class ConfigFileTest {\n-    static final String SEPARATOR_THIN = \"----------------------------\";\n-\n-    private static void printTestHeader(String testName) {\n-        System.out.println();\n-        System.out.println(SEPARATOR_THIN);\n-        System.out.println(testName);\n-        System.out.println(SEPARATOR_THIN);\n-        System.out.println();\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1 && Executor.RUNNER_ARG.equals(args[0])) {\n-            \/\/ Executed by a test-launched JVM.\n-            \/\/ Force the initialization of java.security.Security.\n-            Security.getProviders();\n-            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n-            System.out.println(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n-                    Security.getProperty(FilesManager.LAST_FILE_PROP_NAME));\n-            assertTestSecuritySetPropertyShouldNotInclude();\n-        } else {\n-            \/\/ Executed by the test JVM.\n-            try (FilesManager filesMgr = new FilesManager()) {\n-                for (Method m : ConfigFileTest.class.getDeclaredMethods()) {\n-                    if (m.getName().startsWith(\"test\")) {\n-                        printTestHeader(m.getName());\n-                        Executor.run(m, filesMgr);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Success cases\n-     *\/\n-\n-    static void testShowSettings(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Sanity test passing the -XshowSettings:security option.\n-        ex.addJvmArg(\"-XshowSettings:security\");\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.assertSuccess();\n-        ex.getOutputAnalyzer()\n-                .shouldContain(\"Security properties:\")\n-                .shouldContain(\"Security provider static configuration:\")\n-                .shouldContain(\"Security TLS configuration\");\n-    }\n-\n-    static void testIncludeBasic(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-        PropsFile file2 = filesMgr.newFile(\"dir1\/dir2\/file2.properties\");\n-\n-        masterFile.addAbsoluteInclude(file0);\n-        extraFile.addRelativeInclude(file2);\n-        file2.addAbsoluteInclude(file1);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.setExtraFile(extraFile, Executor.ExtraMode.FILE_URI, false);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testRepeatedInclude(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-\n-        masterFile.addAbsoluteInclude(file0);\n-        masterFile.addAbsoluteInclude(file1);\n-        masterFile.addAbsoluteInclude(file0);\n-        file1.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testIncludeWithOverrideAll(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-\n-        masterFile.addRelativeInclude(file0);\n-        extraFile.addAbsoluteInclude(file1);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n-        ex.assertSuccess();\n-    }\n-\n-    static void extraPropertiesByHelper(Executor ex, FilesManager filesMgr,\n-            Executor.ExtraMode mode) throws Exception {\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        extraFile.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.setExtraFile(extraFile, mode, true);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testExtraPropertiesByPathAbsolute(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_ABS);\n-    }\n-\n-    static void testExtraPropertiesByPathRelative(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        extraPropertiesByHelper(ex, filesMgr, Executor.ExtraMode.PATH_REL);\n-    }\n-\n-    static void specialCharsIncludes(Executor ex, FilesManager filesMgr,\n-            char specialChar, Executor.ExtraMode extraMode,\n-            boolean useRelativeIncludes) throws Exception {\n-        String suffix = specialChar + \".properties\";\n-        ExtraPropsFile extraFile;\n-        PropsFile file0, file1;\n-        try {\n-            extraFile = filesMgr.newExtraFile(\"extra\" + suffix);\n-            file0 = filesMgr.newFile(\"file0\" + suffix);\n-            file1 = filesMgr.newFile(\"file1\" + suffix);\n-        } catch (InvalidPathException ipe) {\n-            \/\/ The platform encoding may not allow to create files with some\n-            \/\/ special characters. Skip the test in these cases.\n-            return;\n-        }\n-\n-        if (useRelativeIncludes) {\n-            extraFile.addRelativeInclude(file0);\n-        } else {\n-            extraFile.addAbsoluteInclude(file0);\n-        }\n-        extraFile.addAbsoluteInclude(file1);\n-\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.setExtraFile(extraFile, extraMode, false);\n-        ex.assertSuccess();\n-    }\n-\n-    static void testUnicodeIncludes1(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.PATH_ABS, true);\n-    }\n-\n-    static void testUnicodeIncludes2(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.FILE_URI, true);\n-    }\n-\n-    static void testUnicodeIncludes3(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/tmp\/extra.properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.RAW_FILE_URI1, false);\n-    }\n-\n-    static void testUnicodeIncludes4(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/\/\/tmp\/extra.properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, '\\u2022',\n-                Executor.ExtraMode.RAW_FILE_URI2, false);\n-    }\n-\n-    static void testSpaceIncludes1(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.PATH_ABS, true);\n-    }\n-\n-    static void testSpaceIncludes2(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.FILE_URI, true);\n-    }\n-\n-    static void testSpaceIncludes3(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/tmp\/extra .properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.RAW_FILE_URI1, false);\n-    }\n-\n-    static void testSpaceIncludes4(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Backward compatibility check. Malformed URLs such as\n-        \/\/ file:\/\/\/tmp\/extra .properties are supported for the extra file.\n-        \/\/ However, relative includes are not allowed in these cases.\n-        specialCharsIncludes(ex, filesMgr, ' ',\n-                Executor.ExtraMode.RAW_FILE_URI2, false);\n-    }\n-\n-    static void notOverrideOnFailureHelper(Executor ex, FilesManager filesMgr,\n-            String nonExistentExtraFile) throws Exception {\n-        \/\/ An overriding extra properties file that does not exist\n-        \/\/ should not erase properties from the master file.\n-        ex.setIgnoredExtraFile(nonExistentExtraFile, true);\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.assertSuccess();\n-        ex.getOutputAnalyzer().shouldContain(\"unable to load security \" +\n-                \"properties from \" + nonExistentExtraFile);\n-    }\n-\n-    static void testNotOverrideOnEmptyFailure(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"\");\n-        ex.getOutputAnalyzer()\n-                .shouldContain(\"Empty extra properties file path\");\n-    }\n-\n-    static void testNotOverrideOnURLFailure(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr,\n-                \"file:\/\/\/nonExistentFile.properties\");\n-    }\n-\n-    static void testNotOverrideOnPathFailure(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"nonExistentFile.properties\");\n-    }\n-\n-    static void testNotOverrideOnDirFailure(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/\");\n-        ex.getOutputAnalyzer().shouldContain(\"Is a directory\");\n-    }\n-\n-    static void testNotOverrideOnBadFileURLFailure(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/%00\");\n-    }\n-\n-    static void testDisabledExtraPropertiesFile(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        masterFile.addRawProperty(\"security.overridePropertiesFile\", \"false\");\n-\n-        ex.setMasterFile(masterFile);\n-        ex.setIgnoredExtraFile(file0.path.toString(), true);\n-        ex.assertSuccess();\n-    }\n-\n-    static final String SECURITY_SET_PROP_FILE_PATH =\n-            \"testSecuritySetPropertyShouldNotInclude.propsFilePath\";\n-\n-    static void testSecuritySetPropertyShouldNotInclude(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        ex.addSystemProp(SECURITY_SET_PROP_FILE_PATH, file0.path.toString());\n-        ex.setMasterFile(masterFile);\n-        ex.assertSuccess();\n-    }\n-\n-    static void assertTestSecuritySetPropertyShouldNotInclude() {\n-        \/\/ This check is executed by the launched JVM.\n-        String propsFilePath = System.getProperty(SECURITY_SET_PROP_FILE_PATH);\n-        if (propsFilePath != null) {\n-            String name = Path.of(propsFilePath).getFileName().toString();\n-            String setPropInvokeRepr = \"Security.setProperty(\\\"include\\\", \" +\n-                    \"\\\"\" + propsFilePath + \"\\\")\";\n-            try {\n-                Security.setProperty(\"include\", propsFilePath);\n-                throw new RuntimeException(setPropInvokeRepr + \" was \" +\n-                        \"expected to throw IllegalArgumentException.\");\n-            } catch (IllegalArgumentException expected) {}\n-            if (FilesManager.APPLIED_PROP_VALUE.equals(\n-                    Security.getProperty(name))) {\n-                throw new RuntimeException(setPropInvokeRepr + \" caused \" +\n-                        \"a file inclusion.\");\n-            }\n-            try {\n-                Security.getProperty(\"include\");\n-                throw new RuntimeException(\"Security.getProperty(\\\"include\\\")\" +\n-                        \" was expected to throw IllegalArgumentException.\");\n-            } catch (IllegalArgumentException expected) {}\n-        }\n-    }\n-\n-    \/*\n-     * Error cases\n-     *\/\n-\n-    static void testCannotResolveRelativeFromHTTPServed(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-\n-        extraFile.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(filesMgr.newMasterFile());\n-        ex.setExtraFile(extraFile, Executor.ExtraMode.HTTP_SERVED, true);\n-        ex.assertError(\"InternalError: Cannot resolve '\" + file0.fileName +\n-                \"' relative path when included from a non-regular \" +\n-                \"properties file (e.g. HTTP served file)\");\n-    }\n-\n-    static void testCannotIncludeCycles(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n-        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n-\n-        \/\/ Includes chain: master -> file0 -> file1 -> master.\n-        file1.addRelativeInclude(masterFile);\n-        file0.addRelativeInclude(file1);\n-        masterFile.addRelativeInclude(file0);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertError(\n-                \"InternalError: Cyclic include of '\" + masterFile.path + \"'\");\n-    }\n-\n-    static void testCannotIncludeURL(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-        ExtraPropsFile extraFile = filesMgr.newExtraFile();\n-\n-        masterFile.addRawProperty(\"include\", extraFile.url.toString());\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertError(\"InternalError: Unable to include 'http:\/\/127.0.0.1:\");\n-    }\n-\n-    static void testCannotIncludeNonexistentFile(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        PropsFile masterFile = filesMgr.newMasterFile();\n-\n-        String nonexistentPath = \"\/nonExistentFile.properties\";\n-        masterFile.addRawProperty(\"include\", nonexistentPath);\n-\n-        ex.setMasterFile(masterFile);\n-        ex.assertError(\n-                \"InternalError: Unable to include '\" + nonexistentPath + \"'\");\n-    }\n-\n-    static void testMustHaveMasterFile(Executor ex, FilesManager filesMgr)\n-            throws Exception {\n-        \/\/ Launch a JDK without a master java.security file present.\n-        ex.assertError(\"InternalError: Error loading java.security file\");\n-    }\n-\n-    static void testMustHaveMasterFileEvenWithExtraFile(Executor ex,\n-            FilesManager filesMgr) throws Exception {\n-        \/\/ Launch a JDK without a master java.security file present, but with an\n-        \/\/ extra file passed. Since the \"security.overridePropertiesFile=true\"\n-        \/\/ security property is missing, it should fail anyway.\n-        ex.setExtraFile(\n-                filesMgr.newExtraFile(), Executor.ExtraMode.FILE_URI, true);\n-        ex.assertError(\"InternalError: Error loading java.security file\");\n-    }\n-}\n-\n-sealed class PropsFile permits ExtraPropsFile {\n-    protected static final class Include {\n-        final PropsFile propsFile;\n-        final String value;\n-\n-        private Include(PropsFile propsFile, String value) {\n-            this.propsFile = propsFile;\n-            this.value = value;\n-        }\n-\n-        static Include of(PropsFile propsFile) {\n-            return new Include(propsFile, propsFile.path.toString());\n-        }\n-\n-        static Include of(PropsFile propsFile, String value) {\n-            return new Include(propsFile, value);\n-        }\n-    }\n-\n-    protected final List<Include> includes = new ArrayList<>();\n-    protected final PrintWriter writer;\n-    protected boolean includedFromExtra = false;\n-    final String fileName;\n-    final Path path;\n-\n-    PropsFile(String fileName, Path path) throws IOException {\n-        this.fileName = fileName;\n-        this.path = path;\n-        this.writer = new PrintWriter(Files.newOutputStream(path,\n-                StandardOpenOption.CREATE, StandardOpenOption.APPEND), true);\n-    }\n-\n-    private static String escape(String text, boolean escapeSpace) {\n-        StringBuilder sb = new StringBuilder(text.length());\n-        CharBuffer cb = CharBuffer.wrap(text);\n-        while (cb.hasRemaining()) {\n-            char c = cb.get();\n-            if (c == '\\\\' || escapeSpace && c == ' ') {\n-                sb.append('\\\\');\n-            }\n-            if (Character.UnicodeBlock.of(c) ==\n-                    Character.UnicodeBlock.BASIC_LATIN) {\n-                sb.append(c);\n-            } else {\n-                sb.append(\"\\\\u%04x\".formatted((int) c));\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    private void addRawProperty(String key, String value, String sep) {\n-        writer.println(escape(key, true) + sep + escape(value, false));\n-    }\n-\n-    protected void addIncludeDefinition(Include include) {\n-        if (include.propsFile instanceof ExtraPropsFile) {\n-            throw new RuntimeException(\"ExtraPropsFile should not be included\");\n-        }\n-        includes.add(include);\n-        addRawProperty(\"include\", include.value, \" \");\n-    }\n-\n-    void addComment(String comment) {\n-        writer.println(\"# \" + comment);\n-    }\n-\n-    void addRawProperty(String key, String value) {\n-        addRawProperty(key, value, \"=\");\n-    }\n-\n-    void addAbsoluteInclude(PropsFile propsFile) {\n-        addIncludeDefinition(Include.of(propsFile));\n-    }\n-\n-    void addRelativeInclude(PropsFile propsFile) {\n-        addIncludeDefinition(Include.of(propsFile,\n-                path.getParent().relativize(propsFile.path).toString()));\n-    }\n-\n-    void assertApplied(OutputAnalyzer oa) {\n-        oa.shouldContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n-                FilesManager.APPLIED_PROP_VALUE);\n-        for (Include include : includes) {\n-            include.propsFile.assertApplied(oa);\n-            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n-            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n-        }\n-    }\n-\n-    void assertWasOverwritten(OutputAnalyzer oa) {\n-        oa.shouldNotContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n-                FilesManager.APPLIED_PROP_VALUE);\n-        for (Include include : includes) {\n-            if (!include.propsFile.includedFromExtra) {\n-                include.propsFile.assertWasOverwritten(oa);\n-            }\n-            oa.shouldContain(\"processing include: '\" + include.value + \"'\");\n-            oa.shouldContain(\"finished processing \" + include.propsFile.path);\n-        }\n-    }\n-\n-    void markAsIncludedFromExtra() {\n-        includedFromExtra = true;\n-        for (Include include : includes) {\n-            include.propsFile.markAsIncludedFromExtra();\n-        }\n-    }\n-\n-    PropsFile getLastFile() {\n-        return includes.isEmpty() ?\n-                this : includes.getLast().propsFile.getLastFile();\n-    }\n-\n-    void close() {\n-        writer.close();\n-    }\n-}\n-\n-final class ExtraPropsFile extends PropsFile {\n-    private final Map<String, String> systemProps = new LinkedHashMap<>();\n-    final URI url;\n-\n-    ExtraPropsFile(String fileName, URI url, Path path) throws IOException {\n-        super(fileName, path);\n-        this.url = url;\n-    }\n-\n-    @Override\n-    protected void addIncludeDefinition(Include include) {\n-        if (includes.isEmpty()) {\n-            String propName = \"props.fileName\";\n-            systemProps.put(propName, include.propsFile.fileName);\n-            include = Include.of(include.propsFile,\n-                    include.value.replace(include.propsFile.fileName,\n-                            \"${props.none}${\" + propName + \"}\"));\n-        }\n-        include.propsFile.markAsIncludedFromExtra();\n-        super.addIncludeDefinition(include);\n-    }\n-\n-    Map<String, String> getSystemProperties() {\n-        return Collections.unmodifiableMap(systemProps);\n-    }\n-}\n-\n-final class FilesManager implements Closeable {\n-    private static final Path ROOT_DIR =\n-            Path.of(ConfigFileTest.class.getSimpleName()).toAbsolutePath();\n-    private static final Path PROPS_DIR = ROOT_DIR.resolve(\"properties\");\n-    private static final Path JDK_DIR = ROOT_DIR.resolve(\"jdk\");\n-    private static final Path MASTER_FILE =\n-            JDK_DIR.resolve(\"conf\/security\/java.security\");\n-    private static final Path MASTER_FILE_TEMPLATE =\n-            MASTER_FILE.resolveSibling(\"java.security.template\");\n-    static final String JAVA_EXECUTABLE =\n-            JDK_DIR.resolve(\"bin\/java\").toString();\n-    static final String LAST_FILE_PROP_NAME = \"last-file\";\n-    static final String APPLIED_PROP_VALUE = \"applied\";\n-\n-    private final List<PropsFile> createdFiles;\n-    private final Set<String> fileNamesInUse;\n-    private final HttpServer httpServer;\n-    private final URI serverUri;\n-    private final long masterFileLines;\n-\n-    FilesManager() throws Exception {\n-        createdFiles = new ArrayList<>();\n-        fileNamesInUse = new HashSet<>();\n-        httpServer = HttpServer.create(\n-                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n-        httpServer.createContext(\"\/\", this::handleRequest);\n-        InetSocketAddress address = httpServer.getAddress();\n-        httpServer.start();\n-        serverUri = new URI(\"http\", null, address.getHostString(),\n-                address.getPort(), null, null, null);\n-        copyJDK();\n-        try (Stream<String> s = Files.lines(MASTER_FILE_TEMPLATE)) {\n-            masterFileLines = s.count();\n-        }\n-    }\n-\n-    private static void copyJDK() throws Exception {\n-        Path testJDK = Path.of(Objects.requireNonNull(\n-                System.getProperty(\"test.jdk\"), \"unspecified test.jdk\"));\n-        if (!Files.exists(testJDK)) {\n-            throw new RuntimeException(\"test.jdk -> nonexistent JDK\");\n-        }\n-        Files.createDirectories(JDK_DIR);\n-        try (Stream<Path> pathStream = Files.walk(testJDK)) {\n-            pathStream.skip(1).forEach((Path file) -> {\n-                try {\n-                    Files.copy(file, JDK_DIR.resolve(testJDK.relativize(file)),\n-                            StandardCopyOption.COPY_ATTRIBUTES);\n-                } catch (IOException ioe) {\n-                    throw new UncheckedIOException(ioe);\n-                }\n-            });\n-        }\n-        Files.move(MASTER_FILE, MASTER_FILE_TEMPLATE);\n-    }\n-\n-    private void handleRequest(HttpExchange x) throws IOException {\n-        String rawPath = x.getRequestURI().getRawPath();\n-        Path f = ROOT_DIR.resolve(x.getRequestURI().getPath().substring(1));\n-        int statusCode;\n-        byte[] responseBody;\n-        \/\/ Check for unescaped space, unresolved parent or backward slash.\n-        if (rawPath.matches(\"^.*( |(\\\\.|%2[Ee]){2}|\\\\\\\\|%5[Cc]).*$\")) {\n-            statusCode = HttpURLConnection.HTTP_BAD_REQUEST;\n-            responseBody = new byte[0];\n-        } else if (Files.isRegularFile(f)) {\n-            x.getResponseHeaders().add(\"Content-type\", \"text\/plain\");\n-            statusCode = HttpURLConnection.HTTP_OK;\n-            responseBody = Files.readAllBytes(f);\n-        } else {\n-            statusCode = HttpURLConnection.HTTP_NOT_FOUND;\n-            responseBody = new byte[0];\n-        }\n-        System.out.println(\"[\" + Instant.now() + \"] \" +\n-                getClass().getSimpleName() + \": \" +\n-                x.getRequestMethod() + \" \" + rawPath + \" -> \" +\n-                statusCode + \" (\" + responseBody.length + \" bytes)\");\n-        try (OutputStream responseStream = x.getResponseBody()) {\n-            x.sendResponseHeaders(statusCode, responseBody.length);\n-            responseStream.write(responseBody);\n-        }\n-    }\n-\n-    @FunctionalInterface\n-    private interface PropsFileBuilder {\n-        PropsFile build(String fileName, Path path) throws IOException;\n-    }\n-\n-    private PropsFile newFile(Path path, PropsFileBuilder builder)\n-            throws IOException {\n-        String fileName = path.getFileName().toString();\n-        if (!fileNamesInUse.add(fileName)) {\n-            \/\/ Names must be unique in order for the special\n-            \/\/ property <fileName>=<APPLIED_PROP_VALUE> to work.\n-            throw new RuntimeException(fileName + \" is repeated\");\n-        }\n-        Files.createDirectories(path.getParent());\n-        PropsFile propsFile = builder.build(fileName, path);\n-        propsFile.addComment(\"Property to determine if this properties file \" +\n-                \"was parsed and not overwritten:\");\n-        propsFile.addRawProperty(fileName, APPLIED_PROP_VALUE);\n-        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n-        propsFile.addComment(\"Property to be overwritten by every properties \" +\n-                \"file (master, extra or included):\");\n-        propsFile.addRawProperty(LAST_FILE_PROP_NAME, fileName);\n-        propsFile.addComment(ConfigFileTest.SEPARATOR_THIN);\n-        createdFiles.add(propsFile);\n-        return propsFile;\n-    }\n-\n-    PropsFile newFile(String relPathStr) throws IOException {\n-        return newFile(PROPS_DIR.resolve(relPathStr), PropsFile::new);\n-    }\n-\n-    PropsFile newMasterFile() throws IOException {\n-        Files.copy(MASTER_FILE_TEMPLATE, MASTER_FILE);\n-        return newFile(MASTER_FILE, PropsFile::new);\n-    }\n-\n-    ExtraPropsFile newExtraFile() throws IOException {\n-        return newExtraFile(\"extra.properties\");\n-    }\n-\n-    ExtraPropsFile newExtraFile(String extraFileName) throws IOException {\n-        return (ExtraPropsFile) newFile(PROPS_DIR.resolve(extraFileName),\n-                (fileName, path) -> {\n-                    URI uri = serverUri.resolve(ParseUtil.encodePath(\n-                            ROOT_DIR.relativize(path).toString()));\n-                    return new ExtraPropsFile(fileName, uri, path);\n-                });\n-    }\n-\n-    void reportCreatedFiles() throws IOException {\n-        for (PropsFile propsFile : createdFiles) {\n-            System.err.println();\n-            System.err.println(propsFile.path.toString());\n-            System.err.println(ConfigFileTest.SEPARATOR_THIN.repeat(3));\n-            try (Stream<String> lines = Files.lines(propsFile.path)) {\n-                long lineNumber = 1L;\n-                Iterator<String> it = lines.iterator();\n-                while (it.hasNext()) {\n-                    String line = it.next();\n-                    if (!propsFile.path.equals(MASTER_FILE) ||\n-                            lineNumber > masterFileLines) {\n-                        System.err.println(line);\n-                    }\n-                    lineNumber++;\n-                }\n-            }\n-            System.err.println();\n-        }\n-    }\n-\n-    void clear() throws IOException {\n-        if (!createdFiles.isEmpty()) {\n-            for (PropsFile propsFile : createdFiles) {\n-                propsFile.close();\n-                Files.delete(propsFile.path);\n-            }\n-            FileUtils.deleteFileTreeUnchecked(PROPS_DIR);\n-            createdFiles.clear();\n-            fileNamesInUse.clear();\n-        }\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-        clear();\n-        httpServer.stop(0);\n-        FileUtils.deleteFileTreeUnchecked(ROOT_DIR);\n-    }\n-}\n-\n-final class Executor {\n-    enum ExtraMode {\n-        HTTP_SERVED, FILE_URI, RAW_FILE_URI1, RAW_FILE_URI2, PATH_ABS, PATH_REL\n-    }\n-    static final String RUNNER_ARG = \"runner\";\n-    static final String INITIAL_PROP_LOG_MSG = \"Initial security property: \";\n-    private static final String OVERRIDING_LOG_MSG =\n-            \"overriding other security properties files!\";\n-    private static final String[] ALWAYS_UNEXPECTED_LOG_MSGS = {\n-            \"java.lang.AssertionError\",\n-            INITIAL_PROP_LOG_MSG + \"postInitTest=shouldNotRecord\",\n-            INITIAL_PROP_LOG_MSG + \"include=\",\n-    };\n-    private static final Path CWD = Path.of(\".\").toAbsolutePath();\n-    private static final String JAVA_SEC_PROPS = \"java.security.properties\";\n-    private static final String CLASS_PATH = Objects.requireNonNull(\n-            System.getProperty(\"test.classes\"), \"unspecified test.classes\");\n-    private static final String DEBUG_ARG =\n-            \"-Xrunjdwp:transport=dt_socket,address=localhost:8000,suspend=y\";\n-    private final Map<String, String> systemProps = new LinkedHashMap<>(\n-            Map.of(\"java.security.debug\", \"all\", \"javax.net.debug\", \"all\",\n-                    \/\/ Ensure we get UTF-8 debug outputs in Windows:\n-                    \"stderr.encoding\", \"UTF-8\", \"stdout.encoding\", \"UTF-8\"));\n-    private final List<String> jvmArgs = new ArrayList<>(\n-            List.of(FilesManager.JAVA_EXECUTABLE, \"-enablesystemassertions\",\n-                    \/\/ Uncomment DEBUG_ARG to debug test-launched JVMs:\n-                    \"-classpath\", CLASS_PATH\/\/, DEBUG_ARG\n-            ));\n-    private PropsFile masterPropsFile;\n-    private ExtraPropsFile extraPropsFile;\n-    private boolean expectedOverrideAll = false;\n-    private OutputAnalyzer oa;\n-\n-    static void run(Method m, FilesManager filesMgr) throws Exception {\n-        try {\n-            m.invoke(null, new Executor(), filesMgr);\n-        } catch (Throwable e) {\n-            filesMgr.reportCreatedFiles();\n-            throw e;\n-        } finally {\n-            filesMgr.clear();\n-        }\n-    }\n-\n-    void addSystemProp(String key, String value) {\n-        systemProps.put(key, value);\n-    }\n-\n-    private void setRawExtraFile(String extraFile, boolean overrideAll) {\n-        addSystemProp(JAVA_SEC_PROPS, (overrideAll ? \"=\" : \"\") + extraFile);\n-    }\n-\n-    void setMasterFile(PropsFile masterPropsFile) {\n-        this.masterPropsFile = masterPropsFile;\n-    }\n-\n-    void setExtraFile(ExtraPropsFile extraPropsFile, ExtraMode mode,\n-            boolean overrideAll) {\n-        this.extraPropsFile = extraPropsFile;\n-        expectedOverrideAll = overrideAll;\n-        setRawExtraFile(switch (mode) {\n-            case HTTP_SERVED -> extraPropsFile.url.toString();\n-            case FILE_URI -> extraPropsFile.path.toUri().toString();\n-            case RAW_FILE_URI1 -> \"file:\" + extraPropsFile.path;\n-            case RAW_FILE_URI2 -> \"file:\/\/\" +\n-                    (extraPropsFile.path.startsWith(\"\/\") ? \"\" : \"\/\") +\n-                    extraPropsFile.path;\n-            case PATH_ABS -> extraPropsFile.path.toString();\n-            case PATH_REL -> CWD.relativize(extraPropsFile.path).toString();\n-        }, overrideAll);\n-    }\n-\n-    void setIgnoredExtraFile(String extraPropsFile, boolean overrideAll) {\n-        setRawExtraFile(extraPropsFile, overrideAll);\n-        expectedOverrideAll = false;\n-    }\n-\n-    void addJvmArg(String arg) {\n-        jvmArgs.add(arg);\n-    }\n-\n-    private void execute(boolean successExpected) throws Exception {\n-        List<String> command = new ArrayList<>(jvmArgs);\n-        Collections.addAll(command, Utils.getTestJavaOpts());\n-        addSystemPropertiesAsJvmArgs(command);\n-        command.add(ConfigFileTest.class.getSimpleName());\n-        command.add(RUNNER_ARG);\n-        oa = ProcessTools.executeProcess(new ProcessBuilder(command));\n-        oa.shouldHaveExitValue(successExpected ? 0 : 1);\n-        for (String output : ALWAYS_UNEXPECTED_LOG_MSGS) {\n-            oa.shouldNotContain(output);\n-        }\n-    }\n-\n-    private void addSystemPropertiesAsJvmArgs(List<String> command) {\n-        Map<String, String> allSystemProps = new LinkedHashMap<>(systemProps);\n-        if (extraPropsFile != null) {\n-            allSystemProps.putAll(extraPropsFile.getSystemProperties());\n-        }\n-        for (Map.Entry<String, String> e : allSystemProps.entrySet()) {\n-            command.add(\"-D\" + e.getKey() + \"=\" + e.getValue());\n-        }\n-    }\n-\n-    void assertSuccess() throws Exception {\n-        execute(true);\n-\n-        \/\/ Ensure every file was processed by checking a unique property used as\n-        \/\/ a flag. Each file defines <fileName>=applied.\n-        \/\/\n-        \/\/ For example:\n-        \/\/\n-        \/\/   file0\n-        \/\/   ---------------\n-        \/\/   file0=applied\n-        \/\/   include file1\n-        \/\/\n-        \/\/   file1\n-        \/\/   ---------------\n-        \/\/   file1=applied\n-        \/\/\n-        \/\/ The assertion would be file0 == applied AND file1 == applied.\n-        \/\/\n-        if (extraPropsFile != null) {\n-            extraPropsFile.assertApplied(oa);\n-        }\n-        if (expectedOverrideAll) {\n-            \/\/ When overriding with an extra file, check that neither\n-            \/\/ the master file nor its includes are visible.\n-            oa.shouldContain(OVERRIDING_LOG_MSG);\n-            masterPropsFile.assertWasOverwritten(oa);\n-        } else {\n-            oa.shouldNotContain(OVERRIDING_LOG_MSG);\n-            masterPropsFile.assertApplied(oa);\n-        }\n-\n-        \/\/ Ensure the last included file overwrote a fixed property. Each file\n-        \/\/ defines last-file=<fileName>.\n-        \/\/\n-        \/\/ For example:\n-        \/\/\n-        \/\/   file0\n-        \/\/   ---------------\n-        \/\/   last-file=file0\n-        \/\/   include file1\n-        \/\/\n-        \/\/   file1\n-        \/\/   ---------------\n-        \/\/   last-file=file1\n-        \/\/\n-        \/\/ The assertion would be last-file == file1.\n-        \/\/\n-        PropsFile lastFile = (extraPropsFile == null ?\n-                masterPropsFile : extraPropsFile).getLastFile();\n-        oa.shouldContain(FilesManager.LAST_FILE_PROP_NAME + \"=\" +\n-                lastFile.fileName);\n-        oa.stdoutShouldContain(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n-                lastFile.fileName);\n-    }\n-\n-    void assertError(String message) throws Exception {\n-        execute(false);\n-        oa.shouldContain(message);\n-    }\n-\n-    OutputAnalyzer getOutputAnalyzer() {\n-        return oa;\n-    }\n-}\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":0,"deletions":927,"binary":false,"changes":927,"status":"deleted"},{"patch":"@@ -0,0 +1,937 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import sun.net.www.ParseUtil;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.Method;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.nio.CharBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.security.Security;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @summary Tests security properties passed through java.security,\n+ *   java.security.properties or included from other properties files.\n+ * @bug 4303068 8155246 8292297 8292177 8281658 8319332\n+ * @modules java.base\/sun.net.www\n+ * @library \/test\/lib\n+ * @run main ExtraFileAndIncludes\n+ *\/\n+\n+public class ExtraFileAndIncludes {\n+    static final String SEPARATOR_THIN = \"----------------------------\";\n+\n+    private static void printTestHeader(String testName) {\n+        System.out.println();\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println(testName);\n+        System.out.println(SEPARATOR_THIN);\n+        System.out.println();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 1 && Executor.RUNNER_ARG.equals(args[0])) {\n+            \/\/ Executed by a test-launched JVM.\n+            \/\/ Force the initialization of java.security.Security.\n+            Security.getProviders();\n+            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n+            System.out.println(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                    Security.getProperty(FilesManager.LAST_FILE_PROP_NAME));\n+            assertTestSecuritySetPropertyShouldNotInclude();\n+        } else {\n+            \/\/ Executed by the test JVM.\n+            try (FilesManager filesMgr = new FilesManager()) {\n+                for (Method m :\n+                        ExtraFileAndIncludes.class.getDeclaredMethods()) {\n+                    if (m.getName().startsWith(\"test\")) {\n+                        printTestHeader(m.getName());\n+                        Executor.run(m, filesMgr);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Success cases\n+     *\/\n+\n+    static void testShowSettings(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Sanity test passing the -XshowSettings:security option.\n+        ex.addJvmArg(\"-XshowSettings:security\");\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Security properties:\")\n+                .shouldContain(\"Security provider static configuration:\")\n+                .shouldContain(\"Security TLS configuration\");\n+    }\n+\n+    static void testIncludeBasic(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.FILE_URI);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+        PropsFile file2 = filesMgr.newFile(\"dir1\/dir2\/file2.properties\");\n+\n+        masterFile.addAbsoluteInclude(file0);\n+        extraFile.addRelativeInclude(file2);\n+        file2.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, false);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testRepeatedInclude(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        masterFile.addAbsoluteInclude(file0);\n+        masterFile.addAbsoluteInclude(file1);\n+        masterFile.addAbsoluteInclude(file0);\n+        file1.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testIncludeWithOverrideAll(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.HTTP_SERVED);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        masterFile.addRelativeInclude(file0);\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setExtraFile(extraFile, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void extraPropertiesByHelper(Executor ex, FilesManager filesMgr,\n+            ExtraMode mode) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(mode);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, true);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testExtraPropertiesByPathAbsolute(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, ExtraMode.PATH_ABS);\n+    }\n+\n+    static void testExtraPropertiesByPathRelative(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        extraPropertiesByHelper(ex, filesMgr, ExtraMode.PATH_REL);\n+    }\n+\n+    static void specialCharsIncludes(Executor ex, FilesManager filesMgr,\n+            char specialChar, ExtraMode extraMode, boolean useRelativeIncludes)\n+            throws Exception {\n+        String suffix = specialChar + \".properties\";\n+        ExtraPropsFile extraFile;\n+        PropsFile file0, file1;\n+        try {\n+            extraFile = filesMgr.newExtraFile(\"extra\" + suffix, extraMode);\n+            file0 = filesMgr.newFile(\"file0\" + suffix);\n+            file1 = filesMgr.newFile(\"file1\" + suffix);\n+        } catch (InvalidPathException ipe) {\n+            \/\/ The platform encoding may not allow to create files with some\n+            \/\/ special characters. Skip the test in these cases.\n+            return;\n+        }\n+\n+        if (useRelativeIncludes) {\n+            extraFile.addRelativeInclude(file0);\n+        } else {\n+            extraFile.addAbsoluteInclude(file0);\n+        }\n+        extraFile.addAbsoluteInclude(file1);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, false);\n+        ex.assertSuccess();\n+    }\n+\n+    static void testUnicodeIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022', ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testUnicodeIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, '\\u2022', ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testUnicodeIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testUnicodeIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra.properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, '\\u2022',\n+                ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void testSpaceIncludes1(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.PATH_ABS, true);\n+    }\n+\n+    static void testSpaceIncludes2(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.FILE_URI, true);\n+    }\n+\n+    static void testSpaceIncludes3(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.RAW_FILE_URI1, false);\n+    }\n+\n+    static void testSpaceIncludes4(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Backward compatibility check. Malformed URLs such as\n+        \/\/ file:\/\/\/tmp\/extra .properties are supported for the extra file.\n+        \/\/ However, relative includes are not allowed in these cases.\n+        specialCharsIncludes(ex, filesMgr, ' ', ExtraMode.RAW_FILE_URI2, false);\n+    }\n+\n+    static void notOverrideOnFailureHelper(Executor ex, FilesManager filesMgr,\n+            String nonExistentExtraFile) throws Exception {\n+        \/\/ An overriding extra properties file that does not exist\n+        \/\/ should not erase properties from the master file.\n+        ex.setIgnoredExtraFile(nonExistentExtraFile, true);\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.assertSuccess();\n+        ex.getOutputAnalyzer().shouldContain(\"unable to load security \" +\n+                \"properties from \" + nonExistentExtraFile);\n+    }\n+\n+    static void testNotOverrideOnEmptyFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"\");\n+        ex.getOutputAnalyzer()\n+                .shouldContain(\"Empty extra properties file path\");\n+    }\n+\n+    static void testNotOverrideOnURLFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr,\n+                \"file:\/\/\/nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnPathFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"nonExistentFile.properties\");\n+    }\n+\n+    static void testNotOverrideOnDirFailure(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/\");\n+        ex.getOutputAnalyzer().shouldContain(\"Is a directory\");\n+    }\n+\n+    static void testNotOverrideOnBadFileURLFailure(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        notOverrideOnFailureHelper(ex, filesMgr, \"file:\/\/\/%00\");\n+    }\n+\n+    static void testDisabledExtraPropertiesFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        masterFile.addRawProperty(\"security.overridePropertiesFile\", \"false\");\n+\n+        ex.setMasterFile(masterFile);\n+        ex.setIgnoredExtraFile(file0.path.toString(), true);\n+        ex.assertSuccess();\n+    }\n+\n+    static final String SECURITY_SET_PROP_FILE_PATH =\n+            \"testSecuritySetPropertyShouldNotInclude.propsFilePath\";\n+\n+    static void testSecuritySetPropertyShouldNotInclude(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        ex.addSystemProp(SECURITY_SET_PROP_FILE_PATH, file0.path.toString());\n+        ex.setMasterFile(masterFile);\n+        ex.assertSuccess();\n+    }\n+\n+    static void assertTestSecuritySetPropertyShouldNotInclude() {\n+        \/\/ This check is executed by the launched JVM.\n+        String propsFilePath = System.getProperty(SECURITY_SET_PROP_FILE_PATH);\n+        if (propsFilePath != null) {\n+            String name = Path.of(propsFilePath).getFileName().toString();\n+            String setPropInvokeRepr = \"Security.setProperty(\\\"include\\\", \" +\n+                    \"\\\"\" + propsFilePath + \"\\\")\";\n+            try {\n+                Security.setProperty(\"include\", propsFilePath);\n+                throw new RuntimeException(setPropInvokeRepr + \" was \" +\n+                        \"expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n+            if (FilesManager.APPLIED_PROP_VALUE.equals(\n+                    Security.getProperty(name))) {\n+                throw new RuntimeException(setPropInvokeRepr + \" caused \" +\n+                        \"a file inclusion.\");\n+            }\n+            try {\n+                Security.getProperty(\"include\");\n+                throw new RuntimeException(\"Security.getProperty(\\\"include\\\")\" +\n+                        \" was expected to throw IllegalArgumentException.\");\n+            } catch (IllegalArgumentException expected) {}\n+        }\n+    }\n+\n+    \/*\n+     * Error cases\n+     *\/\n+\n+    static void testCannotResolveRelativeFromHTTPServed(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.HTTP_SERVED);\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+\n+        extraFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(filesMgr.newMasterFile());\n+        ex.setExtraFile(extraFile, true);\n+        ex.assertError(\"InternalError: Cannot resolve '\" + file0.fileName +\n+                \"' relative path when included from a non-regular \" +\n+                \"properties file (e.g. HTTP served file)\");\n+    }\n+\n+    static void testCannotIncludeCycles(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        PropsFile file0 = filesMgr.newFile(\"file0.properties\");\n+        PropsFile file1 = filesMgr.newFile(\"dir1\/file1.properties\");\n+\n+        \/\/ Includes chain: master -> file0 -> file1 -> master.\n+        file1.addRelativeInclude(masterFile);\n+        file0.addRelativeInclude(file1);\n+        masterFile.addRelativeInclude(file0);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\"Cyclic include\");\n+        ex.getOutputAnalyzer().stderrShouldMatch(\"\\\\QInternalError: Cyclic \" +\n+                \"include of '\\\\E[^']+\\\\Q\" + masterFile.fileName + \"'\\\\E\");\n+    }\n+\n+    static void testCannotIncludeURL(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+        ExtraPropsFile extraFile = filesMgr.newExtraFile(ExtraMode.HTTP_SERVED);\n+\n+        masterFile.addRawProperty(\"include\", extraFile.url.toString());\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\"InternalError: Unable to include 'http:\/\/127.0.0.1:\");\n+    }\n+\n+    static void testCannotIncludeNonexistentFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        PropsFile masterFile = filesMgr.newMasterFile();\n+\n+        String nonexistentPath = \"\/nonExistentFile.properties\";\n+        masterFile.addRawProperty(\"include\", nonexistentPath);\n+\n+        ex.setMasterFile(masterFile);\n+        ex.assertError(\n+                \"InternalError: Unable to include '\" + nonexistentPath + \"'\");\n+    }\n+\n+    static void testMustHaveMasterFile(Executor ex, FilesManager filesMgr)\n+            throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present.\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+\n+    static void testMustHaveMasterFileEvenWithExtraFile(Executor ex,\n+            FilesManager filesMgr) throws Exception {\n+        \/\/ Launch a JDK without a master java.security file present, but with an\n+        \/\/ extra file passed. Since the \"security.overridePropertiesFile=true\"\n+        \/\/ security property is missing, it should fail anyway.\n+        ex.setExtraFile(filesMgr.newExtraFile(ExtraMode.FILE_URI), true);\n+        ex.assertError(\"InternalError: Error loading java.security file\");\n+    }\n+}\n+\n+sealed class PropsFile permits ExtraPropsFile {\n+    protected static final class Include {\n+        final PropsFile propsFile;\n+        final String value;\n+\n+        private Include(PropsFile propsFile, String value) {\n+            this.propsFile = propsFile;\n+            this.value = value;\n+        }\n+\n+        static Include of(PropsFile propsFile) {\n+            return new Include(propsFile, propsFile.path.toString());\n+        }\n+\n+        static Include of(PropsFile propsFile, String value) {\n+            return new Include(propsFile, value);\n+        }\n+\n+        void assertProcessed(OutputAnalyzer oa) {\n+            oa.shouldContain(\"processing include: '\" + value + \"'\");\n+            oa.shouldContain(\"finished processing \" + propsFile.displayPath);\n+        }\n+    }\n+\n+    protected final List<Include> includes = new ArrayList<>();\n+    protected final PrintWriter writer;\n+    protected boolean includedFromExtra = false;\n+    protected Path displayPath;\n+    final String fileName;\n+    final Path path;\n+\n+    PropsFile(String fileName, Path path) throws IOException {\n+        this.fileName = fileName;\n+        this.path = path;\n+        this.displayPath = path;\n+        this.writer = new PrintWriter(Files.newOutputStream(path,\n+                StandardOpenOption.CREATE, StandardOpenOption.APPEND), true);\n+    }\n+\n+    private static String escape(String text, boolean escapeSpace) {\n+        StringBuilder sb = new StringBuilder(text.length());\n+        CharBuffer cb = CharBuffer.wrap(text);\n+        while (cb.hasRemaining()) {\n+            char c = cb.get();\n+            if (c == '\\\\' || escapeSpace && c == ' ') {\n+                sb.append('\\\\');\n+            }\n+            if (Character.UnicodeBlock.of(c) ==\n+                    Character.UnicodeBlock.BASIC_LATIN) {\n+                sb.append(c);\n+            } else {\n+                sb.append(\"\\\\u%04x\".formatted((int) c));\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private void addRawProperty(String key, String value, String sep) {\n+        writer.println(escape(key, true) + sep + escape(value, false));\n+    }\n+\n+    protected void addIncludeDefinition(Include include) {\n+        if (include.propsFile instanceof ExtraPropsFile) {\n+            throw new RuntimeException(\"ExtraPropsFile should not be included\");\n+        }\n+        includes.add(include);\n+        addRawProperty(\"include\", include.value, \" \");\n+    }\n+\n+    void addComment(String comment) {\n+        writer.println(\"# \" + comment);\n+    }\n+\n+    void addRawProperty(String key, String value) {\n+        addRawProperty(key, value, \"=\");\n+    }\n+\n+    void addAbsoluteInclude(PropsFile propsFile) {\n+        addIncludeDefinition(Include.of(propsFile));\n+    }\n+\n+    void addRelativeInclude(PropsFile propsFile) {\n+        Path rel = path.getParent().relativize(propsFile.path);\n+        addIncludeDefinition(Include.of(propsFile, rel.toString()));\n+        propsFile.displayPath = displayPath.getParent().resolve(rel);\n+    }\n+\n+    void assertApplied(OutputAnalyzer oa) {\n+        oa.shouldContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            include.propsFile.assertApplied(oa);\n+            include.assertProcessed(oa);\n+        }\n+    }\n+\n+    void assertWasOverwritten(OutputAnalyzer oa) {\n+        oa.shouldNotContain(Executor.INITIAL_PROP_LOG_MSG + fileName + \"=\" +\n+                FilesManager.APPLIED_PROP_VALUE);\n+        for (Include include : includes) {\n+            if (!include.propsFile.includedFromExtra) {\n+                include.propsFile.assertWasOverwritten(oa);\n+            }\n+            include.assertProcessed(oa);\n+        }\n+    }\n+\n+    void markAsIncludedFromExtra() {\n+        includedFromExtra = true;\n+        for (Include include : includes) {\n+            include.propsFile.markAsIncludedFromExtra();\n+        }\n+    }\n+\n+    PropsFile getLastFile() {\n+        return includes.isEmpty() ?\n+                this : includes.getLast().propsFile.getLastFile();\n+    }\n+\n+    void close() {\n+        writer.close();\n+    }\n+}\n+\n+enum ExtraMode {\n+    HTTP_SERVED, FILE_URI, RAW_FILE_URI1, RAW_FILE_URI2, PATH_ABS, PATH_REL\n+}\n+\n+final class ExtraPropsFile extends PropsFile {\n+    private static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    private final Map<String, String> systemProps = new LinkedHashMap<>();\n+    private final ExtraMode mode;\n+    final URI url;\n+\n+    ExtraPropsFile(String fileName, URI url, Path path, ExtraMode mode)\n+            throws IOException {\n+        super(fileName, path);\n+        this.url = url;\n+        this.mode = mode;\n+        if (mode == ExtraMode.PATH_REL) {\n+            this.displayPath = CWD.relativize(path);\n+        }\n+    }\n+\n+    @Override\n+    protected void addIncludeDefinition(Include include) {\n+        if (includes.isEmpty()) {\n+            String propName = \"props.fileName\";\n+            systemProps.put(propName, include.propsFile.fileName);\n+            include = Include.of(include.propsFile,\n+                    include.value.replace(include.propsFile.fileName,\n+                            \"${props.none}${\" + propName + \"}\"));\n+        }\n+        include.propsFile.markAsIncludedFromExtra();\n+        super.addIncludeDefinition(include);\n+    }\n+\n+    String getSysPropValue() {\n+        return switch (mode) {\n+            case HTTP_SERVED -> url.toString();\n+            case FILE_URI -> path.toUri().toString();\n+            case RAW_FILE_URI1 -> \"file:\" + path;\n+            case RAW_FILE_URI2 ->\n+                    \"file:\/\/\" + (path.startsWith(\"\/\") ? \"\" : \"\/\") + path;\n+            case PATH_ABS, PATH_REL -> displayPath.toString();\n+        };\n+    }\n+\n+    Map<String, String> getSystemProperties() {\n+        return Collections.unmodifiableMap(systemProps);\n+    }\n+}\n+\n+final class FilesManager implements Closeable {\n+    private static final Path ROOT_DIR = Path.of(\n+            ExtraFileAndIncludes.class.getSimpleName()).toAbsolutePath();\n+    private static final Path PROPS_DIR = ROOT_DIR.resolve(\"properties\");\n+    private static final Path JDK_DIR = ROOT_DIR.resolve(\"jdk\");\n+    private static final Path MASTER_FILE =\n+            JDK_DIR.resolve(\"conf\/security\/java.security\");\n+    private static final Path MASTER_FILE_TEMPLATE =\n+            MASTER_FILE.resolveSibling(\"java.security.template\");\n+    static final String JAVA_EXECUTABLE =\n+            JDK_DIR.resolve(\"bin\/java\").toString();\n+    static final String LAST_FILE_PROP_NAME = \"last-file\";\n+    static final String APPLIED_PROP_VALUE = \"applied\";\n+\n+    private final List<PropsFile> createdFiles;\n+    private final Set<String> fileNamesInUse;\n+    private final HttpServer httpServer;\n+    private final URI serverUri;\n+    private final long masterFileLines;\n+\n+    FilesManager() throws Exception {\n+        createdFiles = new ArrayList<>();\n+        fileNamesInUse = new HashSet<>();\n+        httpServer = HttpServer.create(\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        httpServer.createContext(\"\/\", this::handleRequest);\n+        InetSocketAddress address = httpServer.getAddress();\n+        httpServer.start();\n+        serverUri = new URI(\"http\", null, address.getHostString(),\n+                address.getPort(), null, null, null);\n+        copyJDK();\n+        try (Stream<String> s = Files.lines(MASTER_FILE_TEMPLATE)) {\n+            masterFileLines = s.count();\n+        }\n+    }\n+\n+    private static void copyJDK() throws Exception {\n+        Path testJDK = Path.of(Objects.requireNonNull(\n+                System.getProperty(\"test.jdk\"), \"unspecified test.jdk\"));\n+        if (!Files.exists(testJDK)) {\n+            throw new RuntimeException(\"test.jdk -> nonexistent JDK\");\n+        }\n+        Files.createDirectories(JDK_DIR);\n+        try (Stream<Path> pathStream = Files.walk(testJDK)) {\n+            pathStream.skip(1).forEach((Path file) -> {\n+                try {\n+                    Files.copy(file, JDK_DIR.resolve(testJDK.relativize(file)),\n+                            StandardCopyOption.COPY_ATTRIBUTES);\n+                } catch (IOException ioe) {\n+                    throw new UncheckedIOException(ioe);\n+                }\n+            });\n+        }\n+        Files.move(MASTER_FILE, MASTER_FILE_TEMPLATE);\n+    }\n+\n+    private void handleRequest(HttpExchange x) throws IOException {\n+        String rawPath = x.getRequestURI().getRawPath();\n+        Path f = ROOT_DIR.resolve(x.getRequestURI().getPath().substring(1));\n+        int statusCode;\n+        byte[] responseBody;\n+        \/\/ Check for unescaped space, unresolved parent or backward slash.\n+        if (rawPath.matches(\"^.*( |(\\\\.|%2[Ee]){2}|\\\\\\\\|%5[Cc]).*$\")) {\n+            statusCode = HttpURLConnection.HTTP_BAD_REQUEST;\n+            responseBody = new byte[0];\n+        } else if (Files.isRegularFile(f)) {\n+            x.getResponseHeaders().add(\"Content-type\", \"text\/plain\");\n+            statusCode = HttpURLConnection.HTTP_OK;\n+            responseBody = Files.readAllBytes(f);\n+        } else {\n+            statusCode = HttpURLConnection.HTTP_NOT_FOUND;\n+            responseBody = new byte[0];\n+        }\n+        System.out.println(\"[\" + Instant.now() + \"] \" +\n+                getClass().getSimpleName() + \": \" +\n+                x.getRequestMethod() + \" \" + rawPath + \" -> \" +\n+                statusCode + \" (\" + responseBody.length + \" bytes)\");\n+        try (OutputStream responseStream = x.getResponseBody()) {\n+            x.sendResponseHeaders(statusCode, responseBody.length);\n+            responseStream.write(responseBody);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface PropsFileBuilder {\n+        PropsFile build(String fileName, Path path) throws IOException;\n+    }\n+\n+    private PropsFile newFile(Path path, PropsFileBuilder builder)\n+            throws IOException {\n+        String fileName = path.getFileName().toString();\n+        if (!fileNamesInUse.add(fileName)) {\n+            \/\/ Names must be unique in order for the special\n+            \/\/ property <fileName>=<APPLIED_PROP_VALUE> to work.\n+            throw new RuntimeException(fileName + \" is repeated\");\n+        }\n+        Files.createDirectories(path.getParent());\n+        PropsFile propsFile = builder.build(fileName, path);\n+        propsFile.addComment(\"Property to determine if this properties file \" +\n+                \"was parsed and not overwritten:\");\n+        propsFile.addRawProperty(fileName, APPLIED_PROP_VALUE);\n+        propsFile.addComment(ExtraFileAndIncludes.SEPARATOR_THIN);\n+        propsFile.addComment(\"Property to be overwritten by every properties \" +\n+                \"file (master, extra or included):\");\n+        propsFile.addRawProperty(LAST_FILE_PROP_NAME, fileName);\n+        propsFile.addComment(ExtraFileAndIncludes.SEPARATOR_THIN);\n+        createdFiles.add(propsFile);\n+        return propsFile;\n+    }\n+\n+    PropsFile newFile(String relPathStr) throws IOException {\n+        return newFile(PROPS_DIR.resolve(relPathStr), PropsFile::new);\n+    }\n+\n+    PropsFile newMasterFile() throws IOException {\n+        Files.copy(MASTER_FILE_TEMPLATE, MASTER_FILE);\n+        return newFile(MASTER_FILE, PropsFile::new);\n+    }\n+\n+    ExtraPropsFile newExtraFile(ExtraMode mode) throws IOException {\n+        return newExtraFile(\"extra.properties\", mode);\n+    }\n+\n+    ExtraPropsFile newExtraFile(String extraFileName, ExtraMode mode)\n+            throws IOException {\n+        return (ExtraPropsFile) newFile(PROPS_DIR.resolve(extraFileName),\n+                (fileName, path) -> {\n+                    URI uri = serverUri.resolve(ParseUtil.encodePath(\n+                            ROOT_DIR.relativize(path).toString()));\n+                    return new ExtraPropsFile(fileName, uri, path, mode);\n+                });\n+    }\n+\n+    void reportCreatedFiles() throws IOException {\n+        for (PropsFile propsFile : createdFiles) {\n+            System.err.println();\n+            System.err.println(propsFile.path.toString());\n+            System.err.println(ExtraFileAndIncludes.SEPARATOR_THIN.repeat(3));\n+            try (Stream<String> lines = Files.lines(propsFile.path)) {\n+                long lineNumber = 1L;\n+                Iterator<String> it = lines.iterator();\n+                while (it.hasNext()) {\n+                    String line = it.next();\n+                    if (!propsFile.path.equals(MASTER_FILE) ||\n+                            lineNumber > masterFileLines) {\n+                        System.err.println(line);\n+                    }\n+                    lineNumber++;\n+                }\n+            }\n+            System.err.println();\n+        }\n+    }\n+\n+    void clear() throws IOException {\n+        if (!createdFiles.isEmpty()) {\n+            for (PropsFile propsFile : createdFiles) {\n+                propsFile.close();\n+                Files.delete(propsFile.path);\n+            }\n+            FileUtils.deleteFileTreeUnchecked(PROPS_DIR);\n+            createdFiles.clear();\n+            fileNamesInUse.clear();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        clear();\n+        httpServer.stop(0);\n+        FileUtils.deleteFileTreeUnchecked(ROOT_DIR);\n+    }\n+}\n+\n+final class Executor {\n+    static final String RUNNER_ARG = \"runner\";\n+    static final String INITIAL_PROP_LOG_MSG = \"Initial security property: \";\n+    private static final String OVERRIDING_LOG_MSG =\n+            \"overriding other security properties files!\";\n+    private static final String[] ALWAYS_UNEXPECTED_LOG_MSGS = {\n+            \"java.lang.AssertionError\",\n+            INITIAL_PROP_LOG_MSG + \"postInitTest=shouldNotRecord\",\n+            INITIAL_PROP_LOG_MSG + \"include=\",\n+    };\n+    private static final String JAVA_SEC_PROPS = \"java.security.properties\";\n+    private static final String CLASS_PATH = Objects.requireNonNull(\n+            System.getProperty(\"test.classes\"), \"unspecified test.classes\");\n+    private static final String DEBUG_ARG =\n+            \"-Xrunjdwp:transport=dt_socket,address=localhost:8000,suspend=y\";\n+    private final Map<String, String> systemProps = new LinkedHashMap<>(\n+            Map.of(\"java.security.debug\", \"all\", \"javax.net.debug\", \"all\",\n+                    \/\/ Ensure we get UTF-8 debug outputs in Windows:\n+                    \"stderr.encoding\", \"UTF-8\", \"stdout.encoding\", \"UTF-8\"));\n+    private final List<String> jvmArgs = new ArrayList<>(\n+            List.of(FilesManager.JAVA_EXECUTABLE, \"-enablesystemassertions\",\n+                    \/\/ Uncomment DEBUG_ARG to debug test-launched JVMs:\n+                    \"-classpath\", CLASS_PATH\/\/, DEBUG_ARG\n+            ));\n+    private PropsFile masterPropsFile;\n+    private ExtraPropsFile extraPropsFile;\n+    private boolean expectedOverrideAll = false;\n+    private OutputAnalyzer oa;\n+\n+    static void run(Method m, FilesManager filesMgr) throws Exception {\n+        try {\n+            m.invoke(null, new Executor(), filesMgr);\n+        } catch (Throwable e) {\n+            filesMgr.reportCreatedFiles();\n+            throw e;\n+        } finally {\n+            filesMgr.clear();\n+        }\n+    }\n+\n+    void addSystemProp(String key, String value) {\n+        systemProps.put(key, value);\n+    }\n+\n+    private void setRawExtraFile(String extraFile, boolean overrideAll) {\n+        addSystemProp(JAVA_SEC_PROPS, (overrideAll ? \"=\" : \"\") + extraFile);\n+    }\n+\n+    void setMasterFile(PropsFile masterPropsFile) {\n+        this.masterPropsFile = masterPropsFile;\n+    }\n+\n+    void setExtraFile(ExtraPropsFile extraPropsFile, boolean overrideAll) {\n+        this.extraPropsFile = extraPropsFile;\n+        expectedOverrideAll = overrideAll;\n+        setRawExtraFile(extraPropsFile.getSysPropValue(), overrideAll);\n+    }\n+\n+    void setIgnoredExtraFile(String extraPropsFile, boolean overrideAll) {\n+        setRawExtraFile(extraPropsFile, overrideAll);\n+        expectedOverrideAll = false;\n+    }\n+\n+    void addJvmArg(String arg) {\n+        jvmArgs.add(arg);\n+    }\n+\n+    private void execute(boolean successExpected) throws Exception {\n+        List<String> command = new ArrayList<>(jvmArgs);\n+        Collections.addAll(command, Utils.getTestJavaOpts());\n+        addSystemPropertiesAsJvmArgs(command);\n+        command.add(ExtraFileAndIncludes.class.getSimpleName());\n+        command.add(RUNNER_ARG);\n+        oa = ProcessTools.executeProcess(new ProcessBuilder(command));\n+        oa.shouldHaveExitValue(successExpected ? 0 : 1);\n+        for (String output : ALWAYS_UNEXPECTED_LOG_MSGS) {\n+            oa.shouldNotContain(output);\n+        }\n+    }\n+\n+    private void addSystemPropertiesAsJvmArgs(List<String> command) {\n+        Map<String, String> allSystemProps = new LinkedHashMap<>(systemProps);\n+        if (extraPropsFile != null) {\n+            allSystemProps.putAll(extraPropsFile.getSystemProperties());\n+        }\n+        for (Map.Entry<String, String> e : allSystemProps.entrySet()) {\n+            command.add(\"-D\" + e.getKey() + \"=\" + e.getValue());\n+        }\n+    }\n+\n+    void assertSuccess() throws Exception {\n+        execute(true);\n+\n+        \/\/ Ensure every file was processed by checking a unique property used as\n+        \/\/ a flag. Each file defines <fileName>=applied.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   file0=applied\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   file1=applied\n+        \/\/\n+        \/\/ The assertion would be file0 == applied AND file1 == applied.\n+        \/\/\n+        if (extraPropsFile != null) {\n+            extraPropsFile.assertApplied(oa);\n+        }\n+        if (expectedOverrideAll) {\n+            \/\/ When overriding with an extra file, check that neither\n+            \/\/ the master file nor its includes are visible.\n+            oa.shouldContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertWasOverwritten(oa);\n+        } else {\n+            oa.shouldNotContain(OVERRIDING_LOG_MSG);\n+            masterPropsFile.assertApplied(oa);\n+        }\n+\n+        \/\/ Ensure the last included file overwrote a fixed property. Each file\n+        \/\/ defines last-file=<fileName>.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/   file0\n+        \/\/   ---------------\n+        \/\/   last-file=file0\n+        \/\/   include file1\n+        \/\/\n+        \/\/   file1\n+        \/\/   ---------------\n+        \/\/   last-file=file1\n+        \/\/\n+        \/\/ The assertion would be last-file == file1.\n+        \/\/\n+        PropsFile lastFile = (extraPropsFile == null ?\n+                masterPropsFile : extraPropsFile).getLastFile();\n+        oa.shouldContain(FilesManager.LAST_FILE_PROP_NAME + \"=\" +\n+                lastFile.fileName);\n+        oa.stdoutShouldContain(FilesManager.LAST_FILE_PROP_NAME + \": \" +\n+                lastFile.fileName);\n+    }\n+\n+    void assertError(String message) throws Exception {\n+        execute(false);\n+        oa.shouldContain(message);\n+    }\n+\n+    OutputAnalyzer getOutputAnalyzer() {\n+        return oa;\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/ExtraFileAndIncludes.java","additions":937,"deletions":0,"binary":false,"changes":937,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2026, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/*\n+ * @test\n+ * @summary Ensures the java executable is able to load extra security\n+ * properties files from anonymous files and pipes.\n+ * @bug 8352728\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/java.io:+open\n+ * @library \/test\/lib\n+ * @run main LinuxAnonymousFiles\n+ *\/\n+\n+public class LinuxAnonymousFiles {\n+    private static final String TEST_PROP = \"property.name=PROPERTY_VALUE\";\n+\n+    private static final class AnonymousFile implements AutoCloseable {\n+        public final Path fdPath;\n+        private final FileInputStream fis;\n+\n+        private AnonymousFile(CharSequence content) throws Exception {\n+            Path tmp = Files.createTempFile(\"anonymous-file-\", \"\");\n+            Files.writeString(tmp, content + System.lineSeparator());\n+            fis = new FileInputStream(tmp.toFile());\n+            Files.delete(tmp);\n+            \/\/ Now the file is regular but anonymous, and will be unlinked\n+            \/\/ when we close the last file descriptor referring to it. The\n+            \/\/ fis instance ensures we keep it alive until close() is invoked.\n+            Field field = FileDescriptor.class.getDeclaredField(\"fd\");\n+            field.setAccessible(true);\n+            int fd = field.getInt(fis.getFD());\n+            fdPath = Path.of(\"\/proc\/self\").toRealPath().resolve(\"fd\/\" + fd);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            fis.close();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path java = Path.of(System.getProperty(\"test.jdk\"), \"bin\", \"java\");\n+        try (AnonymousFile af = new AnonymousFile(\"include \/dev\/stdin\")) {\n+            ProcessTools.executeProcess(new ProcessBuilder(java.toString(),\n+                            \"-Djava.security.debug=properties\",\n+                            \"-Djava.security.properties=\" + af.fdPath,\n+                            \"-XshowSettings:security:properties\", \"-version\"),\n+                    TEST_PROP).shouldHaveExitValue(0).shouldContain(TEST_PROP);\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/LinuxAnonymousFiles.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -1,1 +0,0 @@\n-policy.url.2=file:${test.src}\/SecurityPropFile.policy\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/SecurityPropFile.file","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4303068\n- * @summary be allowed to specify the security properties file\n- *      as a -D system property\n- *\n- * @run main\/othervm -Djava.security.properties=${test.src}\/SecurityPropFile.file -Djava.security.debug=properties SecurityPropFile\n- *\/\n-\n-public class SecurityPropFile {\n-    public static void main(String[] args) {\n-        System.out.println(java.security.Security.getProperty\n-                                (\"policy.provider\"));\n-        System.out.println(java.security.Security.getProperty\n-                                (\"policy.url.1\"));\n-        System.out.println(java.security.Security.getProperty\n-                                (\"policy.url.2\"));\n-    }\n-}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/SecurityPropFile.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2026, Red Hat, Inc.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.AclEntry;\n+import java.nio.file.attribute.AclEntryType;\n+import java.nio.file.attribute.AclFileAttributeView;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Ensures java.security is loadable in Windows, even when the user\n+ * does not have permissions on one of the parent directories.\n+ * @bug 8352728\n+ * @requires os.family == \"windows\"\n+ * @library \/test\/lib\n+ * @run main WindowsParentDirPermissions\n+ *\/\n+\n+public class WindowsParentDirPermissions {\n+    private static AutoCloseable restrictedAcl(Path path) throws IOException {\n+        AclFileAttributeView view =\n+                Files.getFileAttributeView(path, AclFileAttributeView.class);\n+        List<AclEntry> originalAcl = List.copyOf(view.getAcl());\n+        view.setAcl(List.of(AclEntry.newBuilder().setType(AclEntryType.DENY)\n+                .setPrincipal(Files.getOwner(path)).build()));\n+        return () -> view.setAcl(originalAcl);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Path temp = Files.createTempDirectory(\"JDK-8352728-tmp-\");\n+        try (AutoCloseable a1 = () -> FileUtils.deleteFileTreeUnchecked(temp)) {\n+            \/\/ Copy the jdk to a different directory\n+            Path originalJdk = Path.of(System.getProperty(\"test.jdk\"));\n+            Path jdk = temp.resolve(\"jdk-parent-dir\", \"jdk\");\n+            Files.createDirectories(jdk);\n+            FileUtils.copyDirectory(originalJdk, jdk);\n+\n+            \/\/ Remove current user permissions from jdk-parent-dir\n+            try (AutoCloseable a2 = restrictedAcl(jdk.getParent())) {\n+                \/\/ Make sure the permissions are affecting the current user\n+                try {\n+                    jdk.toRealPath();\n+                    throw new jtreg.SkippedException(\"Must run non-elevated!\");\n+                } catch (IOException expected) { }\n+\n+                \/\/ Execute the copied jdk, ensuring java.security.Security is\n+                \/\/ loaded (i.e. use -XshowSettings:security:properties)\n+                ProcessTools.executeProcess(new ProcessBuilder(\n+                        List.of(jdk.resolve(\"bin\", \"java.exe\").toString(),\n+                                \"-Djava.security.debug=properties\",\n+                                \"-XshowSettings:security:properties\",\n+                                \"-version\"))).shouldHaveExitValue(0);\n+            }\n+        }\n+        System.out.println(\"TEST PASS - OK\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/WindowsParentDirPermissions.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -63,1 +64,3 @@\n-import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -71,2 +74,2 @@\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -102,6 +105,5 @@\n-    @Test()\n-    public void basicTest_isSupported_TemporalField_supported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : validFields()) {\n-                assertEquals(true, sample.isSupported(field), \"Failed on \" + sample + \" \" + field);\n-            }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_isSupported_TemporalField_supported(TemporalAccessor sample) {\n+        for (TemporalField field : validFields()) {\n+            assertTrue(sample.isSupported(field), \"Failed on \" + sample + \" \" + field);\n@@ -111,6 +113,5 @@\n-    @Test()\n-    public void basicTest_isSupported_TemporalField_unsupported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : invalidFields()) {\n-                assertEquals(false, sample.isSupported(field), \"Failed on \" + sample + \" \" + field);\n-            }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_isSupported_TemporalField_unsupported(TemporalAccessor sample) {\n+        for (TemporalField field : invalidFields()) {\n+            assertFalse(sample.isSupported(field), \"Failed on \" + sample + \" \" + field);\n@@ -120,5 +121,4 @@\n-    @Test()\n-    public void basicTest_isSupported_TemporalField_null() {\n-        for (TemporalAccessor sample : samples()) {\n-            assertEquals(false, sample.isSupported(null), \"Failed on \" + sample);\n-        }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_isSupported_TemporalField_null(TemporalAccessor sample) {\n+        assertFalse(sample.isSupported(null), \"Failed on \" + sample);\n@@ -130,6 +130,5 @@\n-    @Test()\n-    public void basicTest_range_TemporalField_supported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : validFields()) {\n-                sample.range(field);  \/\/ no exception\n-            }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_range_TemporalField_supported(TemporalAccessor sample) {\n+        for (TemporalField field : validFields()) {\n+            assertDoesNotThrow(() -> sample.range(field));\n@@ -139,11 +138,6 @@\n-    @Test()\n-    public void basicTest_range_TemporalField_unsupported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : invalidFields()) {\n-                try {\n-                    sample.range(field);\n-                    fail(\"Failed on \" + sample + \" \" + field);\n-                } catch (DateTimeException ex) {\n-                    \/\/ expected\n-                }\n-            }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_range_TemporalField_unsupported(TemporalAccessor sample) {\n+        for (TemporalField field : invalidFields()) {\n+            assertThrows(DateTimeException.class,\n+                    () -> sample.range(field), \"Failed on \" + sample + \" \" + field);\n@@ -153,10 +147,5 @@\n-    @Test()\n-    public void basicTest_range_TemporalField_null() {\n-        for (TemporalAccessor sample : samples()) {\n-            try {\n-                sample.range(null);\n-                fail(\"Failed on \" + sample);\n-            } catch (NullPointerException ex) {\n-                \/\/ expected\n-            }\n-        }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_range_TemporalField_null(TemporalAccessor sample) {\n+        assertThrows(NullPointerException.class,\n+                () -> sample.range(null), \"Failed on \" + sample);\n@@ -168,14 +157,9 @@\n-    @Test()\n-    public void basicTest_get_TemporalField_supported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : validFields()) {\n-                if (sample.range(field).isIntValue()) {\n-                    sample.get(field);  \/\/ no exception\n-                } else {\n-                    try {\n-                        sample.get(field);\n-                        fail(\"Failed on \" + sample + \" \" + field);\n-                    } catch (DateTimeException ex) {\n-                        \/\/ expected\n-                    }\n-                }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_get_TemporalField_supported(TemporalAccessor sample) {\n+        for (TemporalField field : validFields()) {\n+            if (sample.range(field).isIntValue()) {\n+                assertDoesNotThrow(() -> sample.get(field));\n+            } else {\n+                assertThrows(DateTimeException.class,\n+                        () -> sample.get(field), \"Failed on \" + sample + \" \" + field);\n@@ -186,11 +170,6 @@\n-    @Test()\n-    public void basicTest_get_TemporalField_unsupported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : invalidFields()) {\n-                try {\n-                    sample.get(field);\n-                    fail(\"Failed on \" + sample + \" \" + field);\n-                } catch (DateTimeException ex) {\n-                    \/\/ expected\n-                }\n-            }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_get_TemporalField_unsupported(TemporalAccessor sample) {\n+        for (TemporalField field : invalidFields()) {\n+            assertThrows(DateTimeException.class,\n+                    () -> sample.get(field), \"Failed on \" + sample + \" \" + field);\n@@ -200,7 +179,5 @@\n-    @Test\n-    public void test_get_TemporalField_invalidField() {\n-        Assertions.assertThrows(DateTimeException.class, () -> {\n-            for (TemporalAccessor sample : samples()) {\n-                sample.get(MockFieldNoValue.INSTANCE);\n-            }\n-        });\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void test_get_TemporalField_invalidField(TemporalAccessor sample) {\n+        assertThrows(DateTimeException.class,\n+                () -> sample.get(MockFieldNoValue.INSTANCE));\n@@ -209,10 +186,5 @@\n-    @Test()\n-    public void basicTest_get_TemporalField_null() {\n-        for (TemporalAccessor sample : samples()) {\n-            try {\n-                sample.get(null);\n-                fail(\"Failed on \" + sample);\n-            } catch (NullPointerException ex) {\n-                \/\/ expected\n-            }\n-        }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_get_TemporalField_null(TemporalAccessor sample) {\n+        assertThrows(NullPointerException.class,\n+                () -> sample.get(null), \"Failed on \" + sample);\n@@ -224,6 +196,5 @@\n-    @Test()\n-    public void basicTest_getLong_TemporalField_supported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : validFields()) {\n-                sample.getLong(field);  \/\/ no exception\n-            }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_getLong_TemporalField_supported(TemporalAccessor sample) {\n+        for (TemporalField field : validFields()) {\n+            sample.getLong(field);\n@@ -233,11 +204,6 @@\n-    @Test()\n-    public void basicTest_getLong_TemporalField_unsupported() {\n-        for (TemporalAccessor sample : samples()) {\n-            for (TemporalField field : invalidFields()) {\n-                try {\n-                    sample.getLong(field);\n-                    fail(\"Failed on \" + sample + \" \" + field);\n-                } catch (DateTimeException ex) {\n-                    \/\/ expected\n-                }\n-            }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_getLong_TemporalField_unsupported(TemporalAccessor sample) {\n+        for (TemporalField field : invalidFields()) {\n+            assertThrows(DateTimeException.class,\n+                    () -> sample.getLong(field), \"Failed on \" + sample + \" \" + field);\n@@ -247,7 +213,5 @@\n-    @Test\n-    public void test_getLong_TemporalField_invalidField() {\n-        Assertions.assertThrows(DateTimeException.class, () -> {\n-            for (TemporalAccessor sample : samples()) {\n-                sample.getLong(MockFieldNoValue.INSTANCE);\n-            }\n-        });\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void test_getLong_TemporalField_invalidField(TemporalAccessor sample) {\n+        assertThrows(DateTimeException.class,\n+                () -> sample.getLong(MockFieldNoValue.INSTANCE));\n@@ -256,10 +220,5 @@\n-    @Test()\n-    public void basicTest_getLong_TemporalField_null() {\n-        for (TemporalAccessor sample : samples()) {\n-            try {\n-                sample.getLong(null);\n-                fail(\"Failed on \" + sample);\n-            } catch (NullPointerException ex) {\n-                \/\/ expected\n-            }\n-        }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_getLong_TemporalField_null(TemporalAccessor sample) {\n+        assertThrows(NullPointerException.class,\n+                () -> sample.getLong(null), \"Failed on \" + sample);\n@@ -269,10 +228,9 @@\n-    @Test\n-    public void basicTest_query() {\n-        for (TemporalAccessor sample : samples()) {\n-            assertEquals(\"foo\", sample.query(new TemporalQuery<String>() {\n-                @Override\n-                public String queryFrom(TemporalAccessor temporal) {\n-                    return \"foo\";\n-                }\n-            }));\n-        }\n+    @ParameterizedTest\n+    @MethodSource(\"samples\")\n+    public void basicTest_query(TemporalAccessor sample) {\n+        assertEquals(\"foo\", sample.query(new TemporalQuery<String>() {\n+            @Override\n+            public String queryFrom(TemporalAccessor temporal) {\n+                return \"foo\";\n+            }\n+        }));\n@@ -280,1 +238,0 @@\n-\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/AbstractDateTimeTest.java","additions":92,"deletions":135,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,2 @@\n-        TemporalAccessor[] array = {TEST_12345_123456789, Instant.MIN, Instant.MAX, Instant.EPOCH};\n+        TemporalAccessor[] array = {Instant.ofEpochSecond(12345, 123456789),\n+                Instant.MIN, Instant.MAX, Instant.EPOCH};\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKInstant.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,1 @@\n-        TemporalAccessor[] array = {TEST_2007_07_15, LocalDate.MAX, LocalDate.MIN, };\n+        TemporalAccessor[] array = {LocalDate.of(2007, 7, 15), LocalDate.MAX, LocalDate.MIN, };\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKLocalDate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,2 @@\n-        TemporalAccessor[] array = {TEST_12_30_40_987654321, LocalTime.MIN, LocalTime.MAX, LocalTime.MIDNIGHT, LocalTime.NOON};\n+        TemporalAccessor[] array = {LocalTime.of(12, 30, 40, 987654321),\n+                LocalTime.MIN, LocalTime.MAX, LocalTime.MIDNIGHT, LocalTime.NOON};\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKLocalTime.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-        TemporalAccessor[] array = {TEST_07_15, };\n+        TemporalAccessor[] array = {MonthDay.of(7, 15), };\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKMonthDay.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,2 @@\n-        TemporalAccessor[] array = {TEST_2008_6_30_11_30_59_000000500, OffsetDateTime.MIN, OffsetDateTime.MAX};\n+        TemporalAccessor[] array = {OffsetDateTime.of(2008, 6, 30, 11, 30, 59, 500, OFFSET_PONE),\n+                OffsetDateTime.MIN, OffsetDateTime.MAX};\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKOffsetDateTime.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,2 @@\n-        TemporalAccessor[] array = {TEST_11_30_59_500_PONE, OffsetTime.MIN, OffsetTime.MAX};\n+        TemporalAccessor[] array = {OffsetTime.of(11, 30, 59, 500, OFFSET_PONE),\n+                OffsetTime.MIN, OffsetTime.MAX};\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKOffsetTime.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-        TemporalAccessor[] array = {TEST_2008_06, };\n+        TemporalAccessor[] array = {YearMonth.of(2008, 6), };\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKYearMonth.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,1 @@\n-        TemporalAccessor[] array = {TEST_DATE_TIME, };\n+        TemporalAccessor[] array = {ZonedDateTime.of(LocalDateTime.of(2008, 6, 30, 11, 30, 59, 500), ZONE_0100), };\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKZonedDateTime.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    static SSLContext sslContext;\n+    private static final SSLContext sslContext = SimpleSSLContext.findSSLContext();\n@@ -64,1 +64,0 @@\n-            sslContext = new SimpleSSLContext().get();\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/DummyCacheResponse.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    static SSLContext ctx;\n+    private static final SSLContext ctx = SimpleSSLContext.findSSLContext();\n@@ -68,1 +68,0 @@\n-            ctx = new SimpleSSLContext().get();\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/Equals.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    static SSLContext sslContext;\n+    private static final SSLContext sslContext = SimpleSSLContext.findSSLContext();\n@@ -56,2 +56,0 @@\n-\n-            sslContext = new SimpleSSLContext().get();\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/HttpsSession.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-            new SimpleSSLContext().get().getServerSocketFactory();\n+            SimpleSSLContext.findSSLContext().getServerSocketFactory();\n@@ -142,1 +142,1 @@\n-        SSLSocketFactory sf = new SimpleSSLContext().get().getSocketFactory();\n+        SSLSocketFactory sf = SimpleSSLContext.findSSLContext().getSocketFactory();\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/SubjectAltNameIP.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4765299\n+ * @key headful\n+ * @summary Verifies componentResized() is called with nested JSplitPanes\n+ * @run main TestSplitPaneCompResize\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.InputEvent;\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JList;\n+import javax.swing.JScrollPane;\n+import javax.swing.JSplitPane;\n+import javax.swing.JPanel;\n+import javax.swing.ListSelectionModel;\n+import javax.swing.plaf.basic.BasicSplitPaneDivider;\n+import javax.swing.plaf.basic.BasicSplitPaneUI;\n+import javax.swing.SwingUtilities;\n+\n+public class TestSplitPaneCompResize {\n+\n+    private static JFrame frame;\n+    private JSplitPane outer;\n+    private static JButton leftOneTouchButton;\n+    private static volatile Point leftBtnPos;\n+    private static volatile boolean resized;\n+\n+    public TestSplitPaneCompResize() {\n+\n+        \/\/ set up a simple list embedded inside a scroll pane\n+        String[] listItems = {\"Item1\", \"Item2\"};\n+        JList list = new JList<>(listItems);\n+        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n+        list.setSelectedIndex(0);\n+\n+        JScrollPane comp = new JScrollPane(list);\n+        JSplitPane inner = new JSplitPane(JSplitPane.VERTICAL_SPLIT,\n+                                          comp, new JPanel());\n+        JPanel rightPanel = new JPanel();\n+\n+        outer = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n+                               inner, rightPanel);\n+        outer.setDividerLocation(150);\n+\n+        \/\/Provide minimum sizes for the two components in the split pane\n+        Dimension minimumSize = new Dimension(100, 50);\n+        comp.setMinimumSize(minimumSize);\n+        inner.setMinimumSize(minimumSize);\n+        rightPanel.setMinimumSize(minimumSize);\n+\n+        \/\/Provide a preferred size for the split pane\n+        outer.setPreferredSize(new Dimension(400, 200));\n+        inner.addComponentListener(new ComponentAdapter() {\n+            public void componentResized(ComponentEvent e) {\n+                System.out.println(\"inner resized\");\n+            }\n+        });\n+        comp.addComponentListener(new ComponentAdapter() {\n+            public void componentResized(ComponentEvent e) {\n+                resized = true;\n+                System.out.println(\"comp resized\");\n+            }\n+        });\n+    }\n+\n+    public JSplitPane getSplitPane() {\n+        return outer;\n+    }\n+\n+\n+    public static void main(String[] s) throws Exception {\n+        Robot robot = new Robot();\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame(\"SplitPaneDemo\");\n+\n+                TestSplitPaneCompResize sp = new TestSplitPaneCompResize();\n+                JSplitPane jsp = sp.getSplitPane();\n+                frame.getContentPane().add(jsp);\n+                jsp.setUI(new MySplitPaneUI());\n+                jsp.setOneTouchExpandable(true);\n+                frame.pack();\n+                frame.setLocationRelativeTo(null);\n+                frame.setVisible(true);\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                leftBtnPos = leftOneTouchButton.getLocationOnScreen();\n+                leftBtnPos.x += leftOneTouchButton.getWidth() \/ 2;\n+                leftBtnPos.y += leftOneTouchButton.getHeight() \/ 2;\n+            });\n+\n+            resized = false;\n+            robot.mouseMove(leftBtnPos.x, leftBtnPos.y);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            if (!resized) {\n+                throw new RuntimeException(\"ComponentResized not called\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+\n+    static class MySplitPaneUI extends BasicSplitPaneUI {\n+\n+        public MySplitPaneUI() {\n+            super();\n+        }\n+\n+        public BasicSplitPaneDivider createDefaultDivider() {\n+            return new MySplitPaneDivider(this);\n+        }\n+    }\n+\n+    static class MySplitPaneDivider extends BasicSplitPaneDivider {\n+\n+        public MySplitPaneDivider(BasicSplitPaneUI ui) {\n+            super(ui);\n+        }\n+\n+        protected JButton createLeftOneTouchButton() {\n+            leftOneTouchButton = super.createLeftOneTouchButton();\n+            return leftOneTouchButton;\n+        }\n+\n+        protected JButton createRightOneTouchButton() {\n+            JButton rightOneTouchButton = super.createRightOneTouchButton();\n+            return rightOneTouchButton;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSplitPane\/TestSplitPaneCompResize.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6657138\n- * @summary Verifies that buttons and labels don't share their ui's across appContexts\n- * @author Alexander Potochkin\n- * @modules java.desktop\/sun.awt\n- *\/\n-\n-import sun.awt.SunToolkit;\n-\n-import javax.swing.*;\n-import javax.swing.plaf.ButtonUI;\n-import javax.swing.plaf.ComponentUI;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-public class bug6657138 implements Runnable {\n-\n-    private static Map<JComponent, Map<String, ComponentUI>> componentMap =\n-            Collections.synchronizedMap(\n-            new HashMap<JComponent, Map<String, ComponentUI>>());\n-\n-    public void run() {\n-        SunToolkit.createNewAppContext();\n-        try {\n-            testUIMap();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private static void testUIMap() throws Exception {\n-        UIManager.LookAndFeelInfo[] lafs = UIManager.getInstalledLookAndFeels();\n-        Set<JComponent> components = componentMap.keySet();\n-        for (JComponent c : components) {\n-            Map<String, ComponentUI> uiMap = componentMap.get(c);\n-\n-            for (UIManager.LookAndFeelInfo laf : lafs) {\n-                if (\"Nimbus\".equals(laf.getName())) {\n-                    \/\/ for some unclear reasons\n-                    \/\/ Nimbus ui delegate for a button is null\n-                    \/\/ when this method is called from the new AppContext\n-                    continue;\n-                }\n-                String className = laf.getClassName();\n-                try {\n-                    UIManager.setLookAndFeel(className);\n-                } catch (final UnsupportedLookAndFeelException ignored) {\n-                    continue;\n-                }\n-                ComponentUI ui = UIManager.getUI(c);\n-                if (ui == null) {\n-                    throw new RuntimeException(\"UI is null for \" + c);\n-                }\n-                if (ui == uiMap.get(laf.getName())) {\n-                    throw new RuntimeException(\n-                            \"Two AppContexts share the same UI delegate! \\n\" +\n-                                    c + \"\\n\" + ui);\n-                }\n-                uiMap.put(laf.getName(), ui);\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        componentMap.put(new JButton(\"JButton\"),\n-                new HashMap<String, ComponentUI>());\n-        componentMap.put(new JToggleButton(\"JToggleButton\"),\n-                new HashMap<String, ComponentUI>());\n-        componentMap.put(new JRadioButton(\"JRadioButton\"),\n-                new HashMap<String, ComponentUI>());\n-        componentMap.put(new JCheckBox(\"JCheckBox\"),\n-                new HashMap<String, ComponentUI>());\n-        componentMap.put(new JCheckBox(\"JLabel\"),\n-                new HashMap<String, ComponentUI>());\n-        testUIMap();\n-        ThreadGroup group = new ThreadGroup(\"6657138\");\n-        Thread thread = new Thread(group, new bug6657138());\n-        thread.start();\n-        thread.join();\n-    }\n-}\n-\n","filename":"test\/jdk\/javax\/swing\/Security\/6657138\/bug6657138.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -198,0 +198,1 @@\n+            check(fails, () -> IncrementInstruction.of(IINC_W, i, 1));\n@@ -211,0 +212,1 @@\n+            check(fails, () -> IncrementInstruction.of(IINC, i, 1));\n@@ -253,0 +255,7 @@\n+        IncrementInstruction.of(IINC, 0, 2);\n+        IncrementInstruction.of(IINC, 0, Byte.MIN_VALUE);\n+        IncrementInstruction.of(IINC, 0, Byte.MAX_VALUE);\n+        IncrementInstruction.of(IINC_W, 0, 2);\n+        IncrementInstruction.of(IINC_W, 0, Short.MIN_VALUE);\n+        IncrementInstruction.of(IINC_W, 0, Short.MAX_VALUE);\n+\n@@ -260,0 +269,6 @@\n+        for (int i : new int[] {Byte.MIN_VALUE - 1, Byte.MAX_VALUE + 1}) {\n+            assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(IINC, 0, i));\n+        }\n+        for (int i : new int[] {Short.MIN_VALUE - 1, Short.MAX_VALUE + 1}) {\n+            assertThrows(IllegalArgumentException.class, () -> IncrementInstruction.of(IINC_W, 0, i));\n+        }\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final byte ADD_IDENTITY = (byte)0;\n+    private static final byte AND_IDENTITY = (byte)-1;\n+    private static final byte FIRST_NONZERO_IDENTITY = (byte)0;\n+    private static final byte MAX_IDENTITY = Byte.MIN_VALUE;\n+    private static final byte MIN_IDENTITY = Byte.MAX_VALUE;\n+    private static final byte MUL_IDENTITY = (byte)1;\n+    private static final byte OR_IDENTITY = (byte)0;\n+    private static final byte SUADD_IDENTITY = (byte)0;\n+    private static final byte UMAX_IDENTITY = (byte)0;   \/\/ Minimum unsigned value\n+    private static final byte UMIN_IDENTITY = (byte)-1;  \/\/ Maximum unsigned value\n+    private static final byte XOR_IDENTITY = (byte)0;\n+\n@@ -3614,1 +3626,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3623,1 +3635,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3635,8 +3647,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3645,1 +3650,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3648,1 +3653,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3656,0 +3663,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id & x), x);\n+                Assert.assertEquals((byte) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3657,1 +3687,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3667,1 +3697,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3681,8 +3711,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3691,1 +3714,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3694,1 +3717,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3703,1 +3728,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3712,1 +3737,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3727,0 +3752,1 @@\n+            ra = OR_IDENTITY;\n@@ -3729,9 +3755,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3745,0 +3765,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id | x), x);\n+                Assert.assertEquals((byte) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3746,1 +3789,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3756,1 +3799,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3773,0 +3816,1 @@\n+            ra = OR_IDENTITY;\n@@ -3775,9 +3819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3792,1 +3830,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3801,1 +3839,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3816,0 +3854,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3818,9 +3857,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3834,0 +3867,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id ^ x), x);\n+                Assert.assertEquals((byte) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3835,1 +3891,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3845,1 +3901,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3862,0 +3918,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3864,9 +3921,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3881,1 +3932,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3890,1 +3941,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3905,0 +3956,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3907,9 +3959,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3923,0 +3969,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id + x), x);\n+                Assert.assertEquals((byte) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3924,1 +3993,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3934,1 +4003,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3951,0 +4020,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3953,9 +4023,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3970,1 +4034,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3979,1 +4043,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3991,8 +4055,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4001,1 +4058,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4004,1 +4061,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4012,0 +4071,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id * x), x);\n+                Assert.assertEquals((byte) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4013,1 +4095,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4023,1 +4105,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4037,8 +4119,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4047,1 +4122,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4050,1 +4125,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4059,1 +4136,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4068,1 +4145,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4080,8 +4157,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4090,1 +4160,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4093,1 +4163,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4101,0 +4173,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.min(id, x), x);\n+                Assert.assertEquals((byte) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4102,1 +4197,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4112,1 +4207,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4126,8 +4221,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4136,1 +4224,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4139,1 +4227,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4148,1 +4238,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4157,1 +4247,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4169,8 +4259,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4179,1 +4262,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4182,1 +4265,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4190,0 +4275,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.max(id, x), x);\n+                Assert.assertEquals((byte) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4191,1 +4299,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4201,1 +4309,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4215,8 +4323,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4225,1 +4326,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4228,1 +4329,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4237,1 +4340,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4246,1 +4349,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4258,8 +4361,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4268,1 +4364,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4271,1 +4367,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4279,0 +4377,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4280,1 +4401,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4290,1 +4411,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4304,8 +4425,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4314,1 +4428,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4317,1 +4431,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4326,1 +4442,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4335,1 +4451,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4347,8 +4463,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4357,1 +4466,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4360,1 +4469,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4368,0 +4479,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4369,1 +4503,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4379,1 +4513,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4393,8 +4527,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4403,1 +4530,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4406,1 +4533,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4415,1 +4544,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4424,1 +4553,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4436,8 +4565,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4446,1 +4568,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4449,1 +4571,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4457,0 +4581,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4458,1 +4605,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4615,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4482,8 +4629,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4492,1 +4632,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4495,1 +4635,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4552,1 +4694,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4561,1 +4703,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4576,0 +4718,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4578,9 +4721,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4594,0 +4731,23 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4595,1 +4755,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4605,1 +4765,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4621,0 +4781,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4623,9 +4784,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final byte ADD_IDENTITY = (byte)0;\n+    private static final byte AND_IDENTITY = (byte)-1;\n+    private static final byte FIRST_NONZERO_IDENTITY = (byte)0;\n+    private static final byte MAX_IDENTITY = Byte.MIN_VALUE;\n+    private static final byte MIN_IDENTITY = Byte.MAX_VALUE;\n+    private static final byte MUL_IDENTITY = (byte)1;\n+    private static final byte OR_IDENTITY = (byte)0;\n+    private static final byte SUADD_IDENTITY = (byte)0;\n+    private static final byte UMAX_IDENTITY = (byte)0;   \/\/ Minimum unsigned value\n+    private static final byte UMIN_IDENTITY = (byte)-1;  \/\/ Maximum unsigned value\n+    private static final byte XOR_IDENTITY = (byte)0;\n+\n@@ -3614,1 +3626,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3623,1 +3635,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3635,8 +3647,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3645,1 +3650,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3648,1 +3653,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3656,0 +3663,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id & x), x);\n+                Assert.assertEquals((byte) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3657,1 +3687,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3667,1 +3697,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3681,8 +3711,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3691,1 +3714,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3694,1 +3717,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3703,1 +3728,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3712,1 +3737,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3727,0 +3752,1 @@\n+            ra = OR_IDENTITY;\n@@ -3729,9 +3755,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3745,0 +3765,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id | x), x);\n+                Assert.assertEquals((byte) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3746,1 +3789,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3756,1 +3799,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3773,0 +3816,1 @@\n+            ra = OR_IDENTITY;\n@@ -3775,9 +3819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3792,1 +3830,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3801,1 +3839,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3816,0 +3854,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3818,9 +3857,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3834,0 +3867,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id ^ x), x);\n+                Assert.assertEquals((byte) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3835,1 +3891,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3845,1 +3901,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3862,0 +3918,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3864,9 +3921,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3881,1 +3932,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3890,1 +3941,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3905,0 +3956,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3907,9 +3959,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3923,0 +3969,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id + x), x);\n+                Assert.assertEquals((byte) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3924,1 +3993,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3934,1 +4003,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3951,0 +4020,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3953,9 +4023,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3970,1 +4034,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3979,1 +4043,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3991,8 +4055,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4001,1 +4058,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4004,1 +4061,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4012,0 +4071,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id * x), x);\n+                Assert.assertEquals((byte) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4013,1 +4095,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4023,1 +4105,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4037,8 +4119,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4047,1 +4122,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4050,1 +4125,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4059,1 +4136,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4068,1 +4145,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4080,8 +4157,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4090,1 +4160,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4093,1 +4163,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4101,0 +4173,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.min(id, x), x);\n+                Assert.assertEquals((byte) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4102,1 +4197,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4112,1 +4207,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4126,8 +4221,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4136,1 +4224,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4139,1 +4227,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4148,1 +4238,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4157,1 +4247,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4169,8 +4259,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4179,1 +4262,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4182,1 +4265,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4190,0 +4275,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.max(id, x), x);\n+                Assert.assertEquals((byte) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4191,1 +4299,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4201,1 +4309,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4215,8 +4323,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4225,1 +4326,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4228,1 +4329,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4237,1 +4340,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4246,1 +4349,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4258,8 +4361,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4268,1 +4364,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4271,1 +4367,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4279,0 +4377,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4280,1 +4401,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4290,1 +4411,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4304,8 +4425,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4314,1 +4428,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4317,1 +4431,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4326,1 +4442,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4335,1 +4451,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4347,8 +4463,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4357,1 +4466,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4360,1 +4469,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4368,0 +4479,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4369,1 +4503,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4379,1 +4513,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4393,8 +4527,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4403,1 +4530,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4406,1 +4533,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4415,1 +4544,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4424,1 +4553,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4436,8 +4565,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4446,1 +4568,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4449,1 +4571,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4457,0 +4581,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4458,1 +4605,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4615,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4482,8 +4629,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4492,1 +4632,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4495,1 +4635,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4552,1 +4694,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4561,1 +4703,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4576,0 +4718,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4578,9 +4721,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4594,0 +4731,23 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4595,1 +4755,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4605,1 +4765,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4621,0 +4781,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4623,9 +4784,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final byte ADD_IDENTITY = (byte)0;\n+    private static final byte AND_IDENTITY = (byte)-1;\n+    private static final byte FIRST_NONZERO_IDENTITY = (byte)0;\n+    private static final byte MAX_IDENTITY = Byte.MIN_VALUE;\n+    private static final byte MIN_IDENTITY = Byte.MAX_VALUE;\n+    private static final byte MUL_IDENTITY = (byte)1;\n+    private static final byte OR_IDENTITY = (byte)0;\n+    private static final byte SUADD_IDENTITY = (byte)0;\n+    private static final byte UMAX_IDENTITY = (byte)0;   \/\/ Minimum unsigned value\n+    private static final byte UMIN_IDENTITY = (byte)-1;  \/\/ Maximum unsigned value\n+    private static final byte XOR_IDENTITY = (byte)0;\n+\n@@ -3614,1 +3626,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3623,1 +3635,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3635,8 +3647,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3645,1 +3650,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3648,1 +3653,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3656,0 +3663,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id & x), x);\n+                Assert.assertEquals((byte) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3657,1 +3687,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3667,1 +3697,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3681,8 +3711,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3691,1 +3714,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3694,1 +3717,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3703,1 +3728,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3712,1 +3737,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3727,0 +3752,1 @@\n+            ra = OR_IDENTITY;\n@@ -3729,9 +3755,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3745,0 +3765,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id | x), x);\n+                Assert.assertEquals((byte) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3746,1 +3789,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3756,1 +3799,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3773,0 +3816,1 @@\n+            ra = OR_IDENTITY;\n@@ -3775,9 +3819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3792,1 +3830,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3801,1 +3839,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3816,0 +3854,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3818,9 +3857,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3834,0 +3867,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id ^ x), x);\n+                Assert.assertEquals((byte) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3835,1 +3891,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3845,1 +3901,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3862,0 +3918,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3864,9 +3921,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3881,1 +3932,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3890,1 +3941,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3905,0 +3956,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3907,9 +3959,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3923,0 +3969,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id + x), x);\n+                Assert.assertEquals((byte) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3924,1 +3993,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3934,1 +4003,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3951,0 +4020,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3953,9 +4023,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3970,1 +4034,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3979,1 +4043,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3991,8 +4055,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4001,1 +4058,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4004,1 +4061,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4012,0 +4071,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id * x), x);\n+                Assert.assertEquals((byte) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4013,1 +4095,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4023,1 +4105,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4037,8 +4119,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4047,1 +4122,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4050,1 +4125,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4059,1 +4136,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4068,1 +4145,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4080,8 +4157,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4090,1 +4160,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4093,1 +4163,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4101,0 +4173,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.min(id, x), x);\n+                Assert.assertEquals((byte) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4102,1 +4197,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4112,1 +4207,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4126,8 +4221,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4136,1 +4224,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4139,1 +4227,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4148,1 +4238,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4157,1 +4247,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4169,8 +4259,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4179,1 +4262,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4182,1 +4265,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4190,0 +4275,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.max(id, x), x);\n+                Assert.assertEquals((byte) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4191,1 +4299,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4201,1 +4309,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4215,8 +4323,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4225,1 +4326,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4228,1 +4329,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4237,1 +4340,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4246,1 +4349,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4258,8 +4361,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4268,1 +4364,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4271,1 +4367,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4279,0 +4377,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4280,1 +4401,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4290,1 +4411,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4304,8 +4425,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4314,1 +4428,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4317,1 +4431,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4326,1 +4442,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4335,1 +4451,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4347,8 +4463,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4357,1 +4466,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4360,1 +4469,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4368,0 +4479,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4369,1 +4503,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4379,1 +4513,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4393,8 +4527,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4403,1 +4530,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4406,1 +4533,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4415,1 +4544,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4424,1 +4553,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4436,8 +4565,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4446,1 +4568,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4449,1 +4571,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4457,0 +4581,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4458,1 +4605,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4615,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4482,8 +4629,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4492,1 +4632,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4495,1 +4635,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4552,1 +4694,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4561,1 +4703,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4576,0 +4718,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4578,9 +4721,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4594,0 +4731,23 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4595,1 +4755,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4605,1 +4765,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4621,0 +4781,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4623,9 +4784,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final byte ADD_IDENTITY = (byte)0;\n+    private static final byte AND_IDENTITY = (byte)-1;\n+    private static final byte FIRST_NONZERO_IDENTITY = (byte)0;\n+    private static final byte MAX_IDENTITY = Byte.MIN_VALUE;\n+    private static final byte MIN_IDENTITY = Byte.MAX_VALUE;\n+    private static final byte MUL_IDENTITY = (byte)1;\n+    private static final byte OR_IDENTITY = (byte)0;\n+    private static final byte SUADD_IDENTITY = (byte)0;\n+    private static final byte UMAX_IDENTITY = (byte)0;   \/\/ Minimum unsigned value\n+    private static final byte UMIN_IDENTITY = (byte)-1;  \/\/ Maximum unsigned value\n+    private static final byte XOR_IDENTITY = (byte)0;\n+\n@@ -3614,1 +3626,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3623,1 +3635,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3635,8 +3647,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3645,1 +3650,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3648,1 +3653,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3656,0 +3663,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id & x), x);\n+                Assert.assertEquals((byte) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3657,1 +3687,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3667,1 +3697,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3681,8 +3711,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3691,1 +3714,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3694,1 +3717,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3703,1 +3728,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3712,1 +3737,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3727,0 +3752,1 @@\n+            ra = OR_IDENTITY;\n@@ -3729,9 +3755,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3745,0 +3765,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id | x), x);\n+                Assert.assertEquals((byte) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3746,1 +3789,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3756,1 +3799,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3773,0 +3816,1 @@\n+            ra = OR_IDENTITY;\n@@ -3775,9 +3819,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3792,1 +3830,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3801,1 +3839,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3816,0 +3854,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3818,9 +3857,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3834,0 +3867,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id ^ x), x);\n+                Assert.assertEquals((byte) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3835,1 +3891,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3845,1 +3901,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3862,0 +3918,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3864,9 +3921,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3881,1 +3932,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3890,1 +3941,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3905,0 +3956,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3907,9 +3959,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3923,0 +3969,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id + x), x);\n+                Assert.assertEquals((byte) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3924,1 +3993,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3934,1 +4003,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3951,0 +4020,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3953,9 +4023,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3970,1 +4034,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3979,1 +4043,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3991,8 +4055,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4001,1 +4058,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4004,1 +4061,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4012,0 +4071,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id * x), x);\n+                Assert.assertEquals((byte) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4013,1 +4095,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4023,1 +4105,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4037,8 +4119,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4047,1 +4122,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4050,1 +4125,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4059,1 +4136,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4068,1 +4145,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4080,8 +4157,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4090,1 +4160,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4093,1 +4163,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4101,0 +4173,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.min(id, x), x);\n+                Assert.assertEquals((byte) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4102,1 +4197,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4112,1 +4207,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4126,8 +4221,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4136,1 +4224,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4139,1 +4227,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4148,1 +4238,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4157,1 +4247,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4169,8 +4259,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4179,1 +4262,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4182,1 +4265,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4190,0 +4275,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.max(id, x), x);\n+                Assert.assertEquals((byte) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4191,1 +4299,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4201,1 +4309,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4215,8 +4323,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4225,1 +4326,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4228,1 +4329,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4237,1 +4340,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4246,1 +4349,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4258,8 +4361,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4268,1 +4364,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4271,1 +4367,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4279,0 +4377,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4280,1 +4401,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4290,1 +4411,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4304,8 +4425,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4314,1 +4428,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4317,1 +4431,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4326,1 +4442,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4335,1 +4451,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4347,8 +4463,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4357,1 +4466,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4360,1 +4469,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4368,0 +4479,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4369,1 +4503,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4379,1 +4513,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4393,8 +4527,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4403,1 +4530,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4406,1 +4533,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4415,1 +4544,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4424,1 +4553,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4436,8 +4565,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4446,1 +4568,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4449,1 +4571,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4457,0 +4581,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4458,1 +4605,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4615,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4482,8 +4629,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4492,1 +4632,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4495,1 +4635,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4552,1 +4694,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4561,1 +4703,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4576,0 +4718,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4578,9 +4721,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4594,0 +4731,23 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4595,1 +4755,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4605,1 +4765,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4621,0 +4781,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4623,9 +4784,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final byte ADD_IDENTITY = (byte)0;\n+    private static final byte AND_IDENTITY = (byte)-1;\n+    private static final byte FIRST_NONZERO_IDENTITY = (byte)0;\n+    private static final byte MAX_IDENTITY = Byte.MIN_VALUE;\n+    private static final byte MIN_IDENTITY = Byte.MAX_VALUE;\n+    private static final byte MUL_IDENTITY = (byte)1;\n+    private static final byte OR_IDENTITY = (byte)0;\n+    private static final byte SUADD_IDENTITY = (byte)0;\n+    private static final byte UMAX_IDENTITY = (byte)0;   \/\/ Minimum unsigned value\n+    private static final byte UMIN_IDENTITY = (byte)-1;  \/\/ Maximum unsigned value\n+    private static final byte XOR_IDENTITY = (byte)0;\n+\n@@ -3619,1 +3632,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3628,1 +3641,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3640,8 +3653,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3650,1 +3656,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3653,1 +3659,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                byte v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3661,0 +3669,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = AND_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id & x), x);\n+                Assert.assertEquals((byte) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3662,1 +3693,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3672,1 +3703,1 @@\n-        byte res = -1;\n+        byte res = AND_IDENTITY;\n@@ -3686,8 +3717,1 @@\n-        byte ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -3696,1 +3720,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3699,1 +3723,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                byte v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3708,1 +3734,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3717,1 +3743,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3732,0 +3758,1 @@\n+            ra = OR_IDENTITY;\n@@ -3734,9 +3761,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                byte v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3750,0 +3771,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = OR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id | x), x);\n+                Assert.assertEquals((byte) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3751,1 +3795,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3761,1 +3805,1 @@\n-        byte res = 0;\n+        byte res = OR_IDENTITY;\n@@ -3778,0 +3822,1 @@\n+            ra = OR_IDENTITY;\n@@ -3780,9 +3825,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3797,1 +3836,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3806,1 +3845,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3821,0 +3860,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3823,9 +3863,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                byte v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3839,0 +3873,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id ^ x), x);\n+                Assert.assertEquals((byte) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3840,1 +3897,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3850,1 +3907,1 @@\n-        byte res = 0;\n+        byte res = XOR_IDENTITY;\n@@ -3867,0 +3924,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3869,9 +3927,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                byte v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3886,1 +3938,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3895,1 +3947,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3910,0 +3962,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3912,9 +3965,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                byte v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3928,0 +3975,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id + x), x);\n+                Assert.assertEquals((byte) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3929,1 +3999,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3939,1 +4009,1 @@\n-        byte res = 0;\n+        byte res = ADD_IDENTITY;\n@@ -3956,0 +4026,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3958,9 +4029,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                byte v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3975,1 +4040,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3984,1 +4049,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -3996,8 +4061,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4006,1 +4064,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4009,1 +4067,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                byte v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4017,0 +4077,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((byte) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) (id * x), x);\n+                Assert.assertEquals((byte) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4018,1 +4101,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4028,1 +4111,1 @@\n-        byte res = 1;\n+        byte res = MUL_IDENTITY;\n@@ -4042,8 +4125,1 @@\n-        byte ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4052,1 +4128,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4055,1 +4131,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                byte v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4064,1 +4142,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4073,1 +4151,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4085,8 +4163,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4095,1 +4166,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4098,1 +4169,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                byte v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4106,0 +4179,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.min(id, x), x);\n+                Assert.assertEquals((byte) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4107,1 +4203,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4117,1 +4213,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = MIN_IDENTITY;\n@@ -4131,8 +4227,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4141,1 +4230,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4144,1 +4233,3 @@\n-                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.min(ra, v);\n@@ -4153,1 +4244,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4162,1 +4253,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4174,8 +4265,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4184,1 +4268,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4187,1 +4271,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                byte v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4195,0 +4281,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) Math.max(id, x), x);\n+                Assert.assertEquals((byte) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4196,1 +4305,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4206,1 +4315,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = MAX_IDENTITY;\n@@ -4220,8 +4329,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4230,1 +4332,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4233,1 +4335,3 @@\n-                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (byte) Math.max(ra, v);\n@@ -4242,1 +4346,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4251,1 +4355,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4263,8 +4367,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4273,1 +4370,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4276,1 +4373,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                byte v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4284,0 +4383,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4285,1 +4407,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4295,1 +4417,1 @@\n-        byte res = Byte.MAX_VALUE;\n+        byte res = UMIN_IDENTITY;\n@@ -4309,8 +4431,1 @@\n-        byte ra = Byte.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4319,1 +4434,1 @@\n-            ra = Byte.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4322,1 +4437,3 @@\n-                ra = (byte) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.minUnsigned(ra, v);\n@@ -4331,1 +4448,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4340,1 +4457,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4352,8 +4469,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4362,1 +4472,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4365,1 +4475,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                byte v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4373,0 +4485,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4374,1 +4509,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4384,1 +4519,1 @@\n-        byte res = Byte.MIN_VALUE;\n+        byte res = UMAX_IDENTITY;\n@@ -4398,8 +4533,1 @@\n-        byte ra = Byte.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4408,1 +4536,1 @@\n-            ra = Byte.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4411,1 +4539,3 @@\n-                ra = (byte) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                byte v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.maxUnsigned(ra, v);\n@@ -4420,1 +4550,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4429,1 +4559,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4441,8 +4571,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4451,1 +4574,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4454,1 +4577,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4462,0 +4587,23 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4463,1 +4611,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4473,1 +4621,1 @@\n-        byte res = (byte) 0;\n+        byte res = FIRST_NONZERO_IDENTITY;\n@@ -4487,8 +4635,1 @@\n-        byte ra = (byte) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        byte ra = 0;\n@@ -4497,1 +4638,1 @@\n-            ra = (byte) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4500,1 +4641,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                byte v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4557,1 +4700,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4566,1 +4709,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4581,0 +4724,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4583,9 +4727,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                byte v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4599,0 +4737,23 @@\n+    @Test(dataProvider = \"byteSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        byte x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((byte) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4600,1 +4761,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4610,1 +4771,1 @@\n-        byte res = 0;\n+        byte res = SUADD_IDENTITY;\n@@ -4626,0 +4787,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4628,9 +4790,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                ra = (byte) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                byte v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (byte) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":413,"deletions":257,"binary":false,"changes":670,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final double ADD_IDENTITY = (double)0;\n+    private static final double FIRST_NONZERO_IDENTITY = (double)0;\n+    private static final double MAX_IDENTITY = Double.NEGATIVE_INFINITY;\n+    private static final double MIN_IDENTITY = Double.POSITIVE_INFINITY;\n+    private static final double MUL_IDENTITY = (double)1;\n@@ -2387,1 +2393,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2396,1 +2402,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2411,0 +2417,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2413,9 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2429,0 +2430,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id + x), x);\n+                Assert.assertEquals((double) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2430,1 +2454,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2440,1 +2464,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2457,0 +2481,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2459,9 +2484,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2476,1 +2495,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2485,1 +2504,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2497,8 +2516,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        double ra = 0;\n@@ -2507,1 +2519,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2510,1 +2522,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2532,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id * x), x);\n+                Assert.assertEquals((double) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2519,1 +2556,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2529,1 +2566,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2543,8 +2580,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2553,1 +2583,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2556,1 +2586,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2565,1 +2597,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2574,1 +2606,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2586,8 +2618,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        double ra = 0;\n@@ -2596,1 +2621,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2599,1 +2624,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2607,0 +2634,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.min(id, x), x);\n+                Assert.assertEquals((double) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2608,1 +2658,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2618,1 +2668,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2632,8 +2682,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2642,1 +2685,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2645,1 +2688,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2654,1 +2699,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2663,1 +2708,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2675,8 +2720,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        double ra = 0;\n@@ -2685,1 +2723,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2688,1 +2726,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2696,0 +2736,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.max(id, x), x);\n+                Assert.assertEquals((double) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2697,1 +2760,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2707,1 +2770,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2721,8 +2784,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2731,1 +2787,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2734,1 +2790,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2743,1 +2801,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2752,1 +2810,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2764,8 +2822,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        double ra = 0;\n@@ -2774,1 +2825,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2777,1 +2828,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2785,0 +2838,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2786,1 +2862,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2796,1 +2872,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2810,8 +2886,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2820,1 +2889,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2823,1 +2892,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final double ADD_IDENTITY = (double)0;\n+    private static final double FIRST_NONZERO_IDENTITY = (double)0;\n+    private static final double MAX_IDENTITY = Double.NEGATIVE_INFINITY;\n+    private static final double MIN_IDENTITY = Double.POSITIVE_INFINITY;\n+    private static final double MUL_IDENTITY = (double)1;\n@@ -2387,1 +2393,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2396,1 +2402,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2411,0 +2417,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2413,9 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2429,0 +2430,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id + x), x);\n+                Assert.assertEquals((double) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2430,1 +2454,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2440,1 +2464,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2457,0 +2481,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2459,9 +2484,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2476,1 +2495,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2485,1 +2504,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2497,8 +2516,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        double ra = 0;\n@@ -2507,1 +2519,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2510,1 +2522,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2532,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id * x), x);\n+                Assert.assertEquals((double) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2519,1 +2556,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2529,1 +2566,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2543,8 +2580,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2553,1 +2583,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2556,1 +2586,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2565,1 +2597,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2574,1 +2606,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2586,8 +2618,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        double ra = 0;\n@@ -2596,1 +2621,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2599,1 +2624,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2607,0 +2634,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.min(id, x), x);\n+                Assert.assertEquals((double) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2608,1 +2658,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2618,1 +2668,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2632,8 +2682,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2642,1 +2685,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2645,1 +2688,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2654,1 +2699,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2663,1 +2708,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2675,8 +2720,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        double ra = 0;\n@@ -2685,1 +2723,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2688,1 +2726,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2696,0 +2736,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.max(id, x), x);\n+                Assert.assertEquals((double) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2697,1 +2760,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2707,1 +2770,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2721,8 +2784,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2731,1 +2787,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2734,1 +2790,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2743,1 +2801,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2752,1 +2810,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2764,8 +2822,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        double ra = 0;\n@@ -2774,1 +2825,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2777,1 +2828,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2785,0 +2838,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2786,1 +2862,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2796,1 +2872,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2810,8 +2886,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2820,1 +2889,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2823,1 +2892,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final double ADD_IDENTITY = (double)0;\n+    private static final double FIRST_NONZERO_IDENTITY = (double)0;\n+    private static final double MAX_IDENTITY = Double.NEGATIVE_INFINITY;\n+    private static final double MIN_IDENTITY = Double.POSITIVE_INFINITY;\n+    private static final double MUL_IDENTITY = (double)1;\n@@ -2387,1 +2393,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2396,1 +2402,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2411,0 +2417,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2413,9 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2429,0 +2430,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id + x), x);\n+                Assert.assertEquals((double) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2430,1 +2454,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2440,1 +2464,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2457,0 +2481,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2459,9 +2484,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2476,1 +2495,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2485,1 +2504,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2497,8 +2516,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        double ra = 0;\n@@ -2507,1 +2519,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2510,1 +2522,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2532,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id * x), x);\n+                Assert.assertEquals((double) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2519,1 +2556,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2529,1 +2566,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2543,8 +2580,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2553,1 +2583,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2556,1 +2586,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2565,1 +2597,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2574,1 +2606,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2586,8 +2618,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        double ra = 0;\n@@ -2596,1 +2621,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2599,1 +2624,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2607,0 +2634,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.min(id, x), x);\n+                Assert.assertEquals((double) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2608,1 +2658,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2618,1 +2668,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2632,8 +2682,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2642,1 +2685,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2645,1 +2688,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2654,1 +2699,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2663,1 +2708,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2675,8 +2720,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        double ra = 0;\n@@ -2685,1 +2723,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2688,1 +2726,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2696,0 +2736,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.max(id, x), x);\n+                Assert.assertEquals((double) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2697,1 +2760,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2707,1 +2770,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2721,8 +2784,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2731,1 +2787,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2734,1 +2790,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2743,1 +2801,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2752,1 +2810,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2764,8 +2822,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        double ra = 0;\n@@ -2774,1 +2825,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2777,1 +2828,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2785,0 +2838,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2786,1 +2862,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2796,1 +2872,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2810,8 +2886,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2820,1 +2889,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2823,1 +2892,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final double ADD_IDENTITY = (double)0;\n+    private static final double FIRST_NONZERO_IDENTITY = (double)0;\n+    private static final double MAX_IDENTITY = Double.NEGATIVE_INFINITY;\n+    private static final double MIN_IDENTITY = Double.POSITIVE_INFINITY;\n+    private static final double MUL_IDENTITY = (double)1;\n@@ -2387,1 +2393,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2396,1 +2402,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2411,0 +2417,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2413,9 +2420,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2429,0 +2430,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id + x), x);\n+                Assert.assertEquals((double) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2430,1 +2454,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2440,1 +2464,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2457,0 +2481,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2459,9 +2484,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2476,1 +2495,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2485,1 +2504,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2497,8 +2516,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        double ra = 0;\n@@ -2507,1 +2519,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2510,1 +2522,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2518,0 +2532,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id * x), x);\n+                Assert.assertEquals((double) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2519,1 +2556,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2529,1 +2566,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2543,8 +2580,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2553,1 +2583,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2556,1 +2586,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2565,1 +2597,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2574,1 +2606,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2586,8 +2618,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        double ra = 0;\n@@ -2596,1 +2621,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2599,1 +2624,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2607,0 +2634,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.min(id, x), x);\n+                Assert.assertEquals((double) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2608,1 +2658,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2618,1 +2668,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2632,8 +2682,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2642,1 +2685,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2645,1 +2688,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2654,1 +2699,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2663,1 +2708,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2675,8 +2720,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        double ra = 0;\n@@ -2685,1 +2723,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2688,1 +2726,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2696,0 +2736,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.max(id, x), x);\n+                Assert.assertEquals((double) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2697,1 +2760,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2707,1 +2770,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2721,8 +2784,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2731,1 +2787,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2734,1 +2790,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2743,1 +2801,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2752,1 +2810,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2764,8 +2822,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        double ra = 0;\n@@ -2774,1 +2825,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2777,1 +2828,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2785,0 +2838,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2786,1 +2862,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2796,1 +2872,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2810,8 +2886,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2820,1 +2889,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2823,1 +2892,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,7 @@\n+    \/\/ Identity values for reduction operations\n+    private static final double ADD_IDENTITY = (double)0;\n+    private static final double FIRST_NONZERO_IDENTITY = (double)0;\n+    private static final double MAX_IDENTITY = Double.NEGATIVE_INFINITY;\n+    private static final double MIN_IDENTITY = Double.POSITIVE_INFINITY;\n+    private static final double MUL_IDENTITY = (double)1;\n+\n@@ -2392,1 +2399,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2401,1 +2408,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2416,0 +2423,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2418,9 +2426,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                double v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2434,0 +2436,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((double) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id + x), x);\n+                Assert.assertEquals((double) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2435,1 +2460,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2445,1 +2470,1 @@\n-        double res = 0;\n+        double res = ADD_IDENTITY;\n@@ -2462,0 +2487,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2464,9 +2490,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                double v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2481,1 +2501,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2490,1 +2510,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2502,8 +2522,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        double ra = 0;\n@@ -2512,1 +2525,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2515,1 +2528,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                double v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2523,0 +2538,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((double) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) (id * x), x);\n+                Assert.assertEquals((double) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2524,1 +2562,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2534,1 +2572,1 @@\n-        double res = 1;\n+        double res = MUL_IDENTITY;\n@@ -2548,8 +2586,1 @@\n-        double ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2558,1 +2589,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2561,1 +2592,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                double v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2570,1 +2603,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2579,1 +2612,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2591,8 +2624,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        double ra = 0;\n@@ -2601,1 +2627,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2604,1 +2630,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                double v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2612,0 +2640,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.min(id, x), x);\n+                Assert.assertEquals((double) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2613,1 +2664,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2623,1 +2674,1 @@\n-        double res = Double.POSITIVE_INFINITY;\n+        double res = MIN_IDENTITY;\n@@ -2637,8 +2688,1 @@\n-        double ra = Double.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2647,1 +2691,1 @@\n-            ra = Double.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2650,1 +2694,3 @@\n-                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                double v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (double) Math.min(ra, v);\n@@ -2659,1 +2705,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2668,1 +2714,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2680,8 +2726,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        double ra = 0;\n@@ -2690,1 +2729,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2693,1 +2732,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                double v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2701,0 +2742,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((double) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((double) Math.max(id, x), x);\n+                Assert.assertEquals((double) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((double) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((double) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2702,1 +2766,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2712,1 +2776,1 @@\n-        double res = Double.NEGATIVE_INFINITY;\n+        double res = MAX_IDENTITY;\n@@ -2726,8 +2790,1 @@\n-        double ra = Double.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2736,1 +2793,1 @@\n-            ra = Double.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2739,1 +2796,3 @@\n-                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                double v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (double) Math.max(ra, v);\n@@ -2748,1 +2807,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2757,1 +2816,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2769,8 +2828,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        double ra = 0;\n@@ -2779,1 +2831,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2782,1 +2834,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2790,0 +2844,23 @@\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        double x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2791,1 +2868,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2801,1 +2878,1 @@\n-        double res = (double) 0;\n+        double res = FIRST_NONZERO_IDENTITY;\n@@ -2815,8 +2892,1 @@\n-        double ra = (double) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        double ra = 0;\n@@ -2825,1 +2895,1 @@\n-            ra = (double) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2828,1 +2898,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                double v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":191,"deletions":119,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final float ADD_IDENTITY = (float)0;\n+    private static final float FIRST_NONZERO_IDENTITY = (float)0;\n+    private static final float MAX_IDENTITY = Float.NEGATIVE_INFINITY;\n+    private static final float MIN_IDENTITY = Float.POSITIVE_INFINITY;\n+    private static final float MUL_IDENTITY = (float)1;\n@@ -2398,1 +2404,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2407,1 +2413,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2422,0 +2428,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2424,9 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2440,0 +2441,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id + x), x);\n+                Assert.assertEquals((float) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2441,1 +2465,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2451,1 +2475,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2468,0 +2492,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2470,9 +2495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2487,1 +2506,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2496,1 +2515,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2508,8 +2527,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        float ra = 0;\n@@ -2518,1 +2530,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2521,1 +2533,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2529,0 +2543,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id * x), x);\n+                Assert.assertEquals((float) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2530,1 +2567,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2540,1 +2577,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2554,8 +2591,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2564,1 +2594,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2567,1 +2597,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2576,1 +2608,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2585,1 +2617,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2597,8 +2629,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        float ra = 0;\n@@ -2607,1 +2632,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2610,1 +2635,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2618,0 +2645,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.min(id, x), x);\n+                Assert.assertEquals((float) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2619,1 +2669,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2629,1 +2679,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2643,8 +2693,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2653,1 +2696,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2656,1 +2699,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2665,1 +2710,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2674,1 +2719,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2686,8 +2731,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        float ra = 0;\n@@ -2696,1 +2734,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2699,1 +2737,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2707,0 +2747,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.max(id, x), x);\n+                Assert.assertEquals((float) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2708,1 +2771,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2718,1 +2781,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2732,8 +2795,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2742,1 +2798,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2745,1 +2801,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2754,1 +2812,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2763,1 +2821,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2775,8 +2833,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        float ra = 0;\n@@ -2785,1 +2836,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2788,1 +2839,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2796,0 +2849,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2797,1 +2873,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2807,1 +2883,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2821,8 +2897,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2831,1 +2900,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2834,1 +2903,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final float ADD_IDENTITY = (float)0;\n+    private static final float FIRST_NONZERO_IDENTITY = (float)0;\n+    private static final float MAX_IDENTITY = Float.NEGATIVE_INFINITY;\n+    private static final float MIN_IDENTITY = Float.POSITIVE_INFINITY;\n+    private static final float MUL_IDENTITY = (float)1;\n@@ -2398,1 +2404,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2407,1 +2413,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2422,0 +2428,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2424,9 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2440,0 +2441,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id + x), x);\n+                Assert.assertEquals((float) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2441,1 +2465,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2451,1 +2475,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2468,0 +2492,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2470,9 +2495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2487,1 +2506,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2496,1 +2515,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2508,8 +2527,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        float ra = 0;\n@@ -2518,1 +2530,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2521,1 +2533,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2529,0 +2543,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id * x), x);\n+                Assert.assertEquals((float) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2530,1 +2567,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2540,1 +2577,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2554,8 +2591,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2564,1 +2594,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2567,1 +2597,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2576,1 +2608,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2585,1 +2617,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2597,8 +2629,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        float ra = 0;\n@@ -2607,1 +2632,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2610,1 +2635,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2618,0 +2645,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.min(id, x), x);\n+                Assert.assertEquals((float) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2619,1 +2669,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2629,1 +2679,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2643,8 +2693,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2653,1 +2696,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2656,1 +2699,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2665,1 +2710,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2674,1 +2719,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2686,8 +2731,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        float ra = 0;\n@@ -2696,1 +2734,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2699,1 +2737,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2707,0 +2747,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.max(id, x), x);\n+                Assert.assertEquals((float) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2708,1 +2771,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2718,1 +2781,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2732,8 +2795,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2742,1 +2798,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2745,1 +2801,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2754,1 +2812,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2763,1 +2821,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2775,8 +2833,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        float ra = 0;\n@@ -2785,1 +2836,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2788,1 +2839,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2796,0 +2849,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2797,1 +2873,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2807,1 +2883,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2821,8 +2897,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2831,1 +2900,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2834,1 +2903,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final float ADD_IDENTITY = (float)0;\n+    private static final float FIRST_NONZERO_IDENTITY = (float)0;\n+    private static final float MAX_IDENTITY = Float.NEGATIVE_INFINITY;\n+    private static final float MIN_IDENTITY = Float.POSITIVE_INFINITY;\n+    private static final float MUL_IDENTITY = (float)1;\n@@ -2398,1 +2404,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2407,1 +2413,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2422,0 +2428,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2424,9 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2440,0 +2441,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id + x), x);\n+                Assert.assertEquals((float) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2441,1 +2465,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2451,1 +2475,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2468,0 +2492,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2470,9 +2495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2487,1 +2506,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2496,1 +2515,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2508,8 +2527,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        float ra = 0;\n@@ -2518,1 +2530,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2521,1 +2533,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2529,0 +2543,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id * x), x);\n+                Assert.assertEquals((float) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2530,1 +2567,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2540,1 +2577,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2554,8 +2591,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2564,1 +2594,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2567,1 +2597,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2576,1 +2608,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2585,1 +2617,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2597,8 +2629,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        float ra = 0;\n@@ -2607,1 +2632,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2610,1 +2635,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2618,0 +2645,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.min(id, x), x);\n+                Assert.assertEquals((float) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2619,1 +2669,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2629,1 +2679,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2643,8 +2693,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2653,1 +2696,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2656,1 +2699,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2665,1 +2710,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2674,1 +2719,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2686,8 +2731,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        float ra = 0;\n@@ -2696,1 +2734,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2699,1 +2737,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2707,0 +2747,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.max(id, x), x);\n+                Assert.assertEquals((float) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2708,1 +2771,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2718,1 +2781,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2732,8 +2795,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2742,1 +2798,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2745,1 +2801,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2754,1 +2812,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2763,1 +2821,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2775,8 +2833,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        float ra = 0;\n@@ -2785,1 +2836,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2788,1 +2839,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2796,0 +2849,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2797,1 +2873,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2807,1 +2883,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2821,8 +2897,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2831,1 +2900,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2834,1 +2903,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+    \/\/ Identity values for reduction operations\n+    private static final float ADD_IDENTITY = (float)0;\n+    private static final float FIRST_NONZERO_IDENTITY = (float)0;\n+    private static final float MAX_IDENTITY = Float.NEGATIVE_INFINITY;\n+    private static final float MIN_IDENTITY = Float.POSITIVE_INFINITY;\n+    private static final float MUL_IDENTITY = (float)1;\n@@ -2398,1 +2404,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2407,1 +2413,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2422,0 +2428,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2424,9 +2431,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2440,0 +2441,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id + x), x);\n+                Assert.assertEquals((float) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2441,1 +2465,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2451,1 +2475,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2468,0 +2492,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2470,9 +2495,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2487,1 +2506,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2496,1 +2515,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2508,8 +2527,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        float ra = 0;\n@@ -2518,1 +2530,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2521,1 +2533,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2529,0 +2543,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id * x), x);\n+                Assert.assertEquals((float) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2530,1 +2567,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2540,1 +2577,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2554,8 +2591,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2564,1 +2594,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2567,1 +2597,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2576,1 +2608,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2585,1 +2617,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2597,8 +2629,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        float ra = 0;\n@@ -2607,1 +2632,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2610,1 +2635,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2618,0 +2645,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.min(id, x), x);\n+                Assert.assertEquals((float) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2619,1 +2669,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2629,1 +2679,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2643,8 +2693,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2653,1 +2696,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2656,1 +2699,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2665,1 +2710,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2674,1 +2719,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2686,8 +2731,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        float ra = 0;\n@@ -2696,1 +2734,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2699,1 +2737,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2707,0 +2747,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.max(id, x), x);\n+                Assert.assertEquals((float) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2708,1 +2771,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2718,1 +2781,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2732,8 +2795,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2742,1 +2798,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2745,1 +2801,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2754,1 +2812,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2763,1 +2821,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2775,8 +2833,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        float ra = 0;\n@@ -2785,1 +2836,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2788,1 +2839,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2796,0 +2849,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2797,1 +2873,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2807,1 +2883,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2821,8 +2897,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2831,1 +2900,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2834,1 +2903,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":190,"deletions":119,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,7 @@\n+    \/\/ Identity values for reduction operations\n+    private static final float ADD_IDENTITY = (float)0;\n+    private static final float FIRST_NONZERO_IDENTITY = (float)0;\n+    private static final float MAX_IDENTITY = Float.NEGATIVE_INFINITY;\n+    private static final float MIN_IDENTITY = Float.POSITIVE_INFINITY;\n+    private static final float MUL_IDENTITY = (float)1;\n+\n@@ -2403,1 +2410,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2412,1 +2419,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2427,0 +2434,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2429,9 +2437,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                float v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -2445,0 +2447,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((float) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id + x), x);\n+                Assert.assertEquals((float) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2446,1 +2471,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2456,1 +2481,1 @@\n-        float res = 0;\n+        float res = ADD_IDENTITY;\n@@ -2473,0 +2498,1 @@\n+            ra = ADD_IDENTITY;\n@@ -2475,9 +2501,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                float v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -2492,1 +2512,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2501,1 +2521,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2513,8 +2533,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        float ra = 0;\n@@ -2523,1 +2536,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2526,1 +2539,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                float v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -2534,0 +2549,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((float) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) (id * x), x);\n+                Assert.assertEquals((float) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2535,1 +2573,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2545,1 +2583,1 @@\n-        float res = 1;\n+        float res = MUL_IDENTITY;\n@@ -2559,8 +2597,1 @@\n-        float ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2569,1 +2600,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -2572,1 +2603,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                float v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -2581,1 +2614,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2590,1 +2623,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2602,8 +2635,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        float ra = 0;\n@@ -2612,1 +2638,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2615,1 +2641,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                float v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2623,0 +2651,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.min(id, x), x);\n+                Assert.assertEquals((float) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2624,1 +2675,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2634,1 +2685,1 @@\n-        float res = Float.POSITIVE_INFINITY;\n+        float res = MIN_IDENTITY;\n@@ -2648,8 +2699,1 @@\n-        float ra = Float.POSITIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2658,1 +2702,1 @@\n-            ra = Float.POSITIVE_INFINITY;\n+            ra = MIN_IDENTITY;\n@@ -2661,1 +2705,3 @@\n-                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                float v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (float) Math.min(ra, v);\n@@ -2670,1 +2716,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2679,1 +2725,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2691,8 +2737,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        float ra = 0;\n@@ -2701,1 +2740,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2704,1 +2743,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                float v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2712,0 +2753,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((float) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((float) Math.max(id, x), x);\n+                Assert.assertEquals((float) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((float) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((float) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2713,1 +2777,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2723,1 +2787,1 @@\n-        float res = Float.NEGATIVE_INFINITY;\n+        float res = MAX_IDENTITY;\n@@ -2737,8 +2801,1 @@\n-        float ra = Float.NEGATIVE_INFINITY;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2747,1 +2804,1 @@\n-            ra = Float.NEGATIVE_INFINITY;\n+            ra = MAX_IDENTITY;\n@@ -2750,1 +2807,3 @@\n-                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                float v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (float) Math.max(ra, v);\n@@ -2759,1 +2818,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2768,1 +2827,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2780,8 +2839,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        float ra = 0;\n@@ -2790,1 +2842,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2793,1 +2845,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -2801,0 +2855,23 @@\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        float x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -2802,1 +2879,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2812,1 +2889,1 @@\n-        float res = (float) 0;\n+        float res = FIRST_NONZERO_IDENTITY;\n@@ -2826,8 +2903,1 @@\n-        float ra = (float) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        float ra = 0;\n@@ -2836,1 +2906,1 @@\n-            ra = (float) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -2839,1 +2909,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                float v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":191,"deletions":119,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final int ADD_IDENTITY = (int)0;\n+    private static final int AND_IDENTITY = (int)-1;\n+    private static final int FIRST_NONZERO_IDENTITY = (int)0;\n+    private static final int MAX_IDENTITY = Integer.MIN_VALUE;\n+    private static final int MIN_IDENTITY = Integer.MAX_VALUE;\n+    private static final int MUL_IDENTITY = (int)1;\n+    private static final int OR_IDENTITY = (int)0;\n+    private static final int SUADD_IDENTITY = (int)0;\n+    private static final int UMAX_IDENTITY = (int)0;   \/\/ Minimum unsigned value\n+    private static final int UMIN_IDENTITY = (int)-1;  \/\/ Maximum unsigned value\n+    private static final int XOR_IDENTITY = (int)0;\n+\n@@ -3658,1 +3670,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3667,1 +3679,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3679,8 +3691,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        int ra = 0;\n@@ -3689,1 +3694,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3692,1 +3697,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3700,0 +3707,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id & x), x);\n+                Assert.assertEquals((int) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3701,1 +3731,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3711,1 +3741,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3725,8 +3755,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -3735,1 +3758,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3738,1 +3761,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3747,1 +3772,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3756,1 +3781,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3771,0 +3796,1 @@\n+            ra = OR_IDENTITY;\n@@ -3773,9 +3799,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3789,0 +3809,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id | x), x);\n+                Assert.assertEquals((int) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3790,1 +3833,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3800,1 +3843,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3817,0 +3860,1 @@\n+            ra = OR_IDENTITY;\n@@ -3819,9 +3863,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3836,1 +3874,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3845,1 +3883,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3860,0 +3898,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3862,9 +3901,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3878,0 +3911,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id ^ x), x);\n+                Assert.assertEquals((int) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3879,1 +3935,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3889,1 +3945,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3906,0 +3962,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3908,9 +3965,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3925,1 +3976,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3934,1 +3985,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3949,0 +4000,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3951,9 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3967,0 +4013,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id + x), x);\n+                Assert.assertEquals((int) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3968,1 +4037,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3978,1 +4047,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3995,0 +4064,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3997,9 +4067,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4014,1 +4078,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4023,1 +4087,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4035,8 +4099,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        int ra = 0;\n@@ -4045,1 +4102,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4048,1 +4105,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4056,0 +4115,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id * x), x);\n+                Assert.assertEquals((int) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4057,1 +4139,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4067,1 +4149,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4081,8 +4163,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4091,1 +4166,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4094,1 +4169,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4103,1 +4180,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4112,1 +4189,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4124,8 +4201,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4134,1 +4204,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4137,1 +4207,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4145,0 +4217,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.min(id, x), x);\n+                Assert.assertEquals((int) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4146,1 +4241,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4156,1 +4251,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4170,8 +4265,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4180,1 +4268,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4183,1 +4271,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4192,1 +4282,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4201,1 +4291,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4213,8 +4303,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4223,1 +4306,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4226,1 +4309,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4234,0 +4319,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.max(id, x), x);\n+                Assert.assertEquals((int) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4235,1 +4343,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4245,1 +4353,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4259,8 +4367,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4269,1 +4370,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4272,1 +4373,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4281,1 +4384,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4290,1 +4393,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4302,8 +4405,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4312,1 +4408,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4315,1 +4411,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4323,0 +4421,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4324,1 +4445,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4334,1 +4455,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4348,8 +4469,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4358,1 +4472,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4361,1 +4475,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4370,1 +4486,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4379,1 +4495,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4391,8 +4507,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4401,1 +4510,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4404,1 +4513,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4412,0 +4523,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4413,1 +4547,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4423,1 +4557,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4437,8 +4571,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4447,1 +4574,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4450,1 +4577,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4459,1 +4588,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4597,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4480,8 +4609,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        int ra = 0;\n@@ -4490,1 +4612,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4493,1 +4615,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4501,0 +4625,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,1 +4649,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4512,1 +4659,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4526,8 +4673,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4536,1 +4676,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4539,1 +4679,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4596,1 +4738,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4605,1 +4747,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4620,0 +4762,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4622,9 +4765,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4638,0 +4775,23 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4639,1 +4799,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4649,1 +4809,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4665,0 +4825,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4667,9 +4828,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final int ADD_IDENTITY = (int)0;\n+    private static final int AND_IDENTITY = (int)-1;\n+    private static final int FIRST_NONZERO_IDENTITY = (int)0;\n+    private static final int MAX_IDENTITY = Integer.MIN_VALUE;\n+    private static final int MIN_IDENTITY = Integer.MAX_VALUE;\n+    private static final int MUL_IDENTITY = (int)1;\n+    private static final int OR_IDENTITY = (int)0;\n+    private static final int SUADD_IDENTITY = (int)0;\n+    private static final int UMAX_IDENTITY = (int)0;   \/\/ Minimum unsigned value\n+    private static final int UMIN_IDENTITY = (int)-1;  \/\/ Maximum unsigned value\n+    private static final int XOR_IDENTITY = (int)0;\n+\n@@ -3658,1 +3670,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3667,1 +3679,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3679,8 +3691,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        int ra = 0;\n@@ -3689,1 +3694,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3692,1 +3697,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3700,0 +3707,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id & x), x);\n+                Assert.assertEquals((int) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3701,1 +3731,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3711,1 +3741,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3725,8 +3755,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -3735,1 +3758,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3738,1 +3761,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3747,1 +3772,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3756,1 +3781,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3771,0 +3796,1 @@\n+            ra = OR_IDENTITY;\n@@ -3773,9 +3799,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3789,0 +3809,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id | x), x);\n+                Assert.assertEquals((int) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3790,1 +3833,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3800,1 +3843,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3817,0 +3860,1 @@\n+            ra = OR_IDENTITY;\n@@ -3819,9 +3863,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3836,1 +3874,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3845,1 +3883,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3860,0 +3898,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3862,9 +3901,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3878,0 +3911,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id ^ x), x);\n+                Assert.assertEquals((int) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3879,1 +3935,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3889,1 +3945,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3906,0 +3962,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3908,9 +3965,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3925,1 +3976,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3934,1 +3985,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3949,0 +4000,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3951,9 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3967,0 +4013,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id + x), x);\n+                Assert.assertEquals((int) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3968,1 +4037,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3978,1 +4047,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3995,0 +4064,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3997,9 +4067,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4014,1 +4078,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4023,1 +4087,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4035,8 +4099,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        int ra = 0;\n@@ -4045,1 +4102,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4048,1 +4105,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4056,0 +4115,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id * x), x);\n+                Assert.assertEquals((int) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4057,1 +4139,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4067,1 +4149,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4081,8 +4163,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4091,1 +4166,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4094,1 +4169,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4103,1 +4180,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4112,1 +4189,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4124,8 +4201,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4134,1 +4204,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4137,1 +4207,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4145,0 +4217,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.min(id, x), x);\n+                Assert.assertEquals((int) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4146,1 +4241,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4156,1 +4251,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4170,8 +4265,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4180,1 +4268,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4183,1 +4271,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4192,1 +4282,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4201,1 +4291,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4213,8 +4303,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4223,1 +4306,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4226,1 +4309,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4234,0 +4319,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.max(id, x), x);\n+                Assert.assertEquals((int) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4235,1 +4343,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4245,1 +4353,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4259,8 +4367,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4269,1 +4370,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4272,1 +4373,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4281,1 +4384,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4290,1 +4393,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4302,8 +4405,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4312,1 +4408,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4315,1 +4411,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4323,0 +4421,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4324,1 +4445,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4334,1 +4455,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4348,8 +4469,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4358,1 +4472,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4361,1 +4475,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4370,1 +4486,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4379,1 +4495,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4391,8 +4507,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4401,1 +4510,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4404,1 +4513,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4412,0 +4523,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4413,1 +4547,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4423,1 +4557,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4437,8 +4571,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4447,1 +4574,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4450,1 +4577,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4459,1 +4588,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4597,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4480,8 +4609,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        int ra = 0;\n@@ -4490,1 +4612,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4493,1 +4615,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4501,0 +4625,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,1 +4649,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4512,1 +4659,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4526,8 +4673,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4536,1 +4676,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4539,1 +4679,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4596,1 +4738,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4605,1 +4747,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4620,0 +4762,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4622,9 +4765,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4638,0 +4775,23 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4639,1 +4799,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4649,1 +4809,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4665,0 +4825,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4667,9 +4828,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final int ADD_IDENTITY = (int)0;\n+    private static final int AND_IDENTITY = (int)-1;\n+    private static final int FIRST_NONZERO_IDENTITY = (int)0;\n+    private static final int MAX_IDENTITY = Integer.MIN_VALUE;\n+    private static final int MIN_IDENTITY = Integer.MAX_VALUE;\n+    private static final int MUL_IDENTITY = (int)1;\n+    private static final int OR_IDENTITY = (int)0;\n+    private static final int SUADD_IDENTITY = (int)0;\n+    private static final int UMAX_IDENTITY = (int)0;   \/\/ Minimum unsigned value\n+    private static final int UMIN_IDENTITY = (int)-1;  \/\/ Maximum unsigned value\n+    private static final int XOR_IDENTITY = (int)0;\n+\n@@ -3658,1 +3670,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3667,1 +3679,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3679,8 +3691,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        int ra = 0;\n@@ -3689,1 +3694,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3692,1 +3697,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3700,0 +3707,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id & x), x);\n+                Assert.assertEquals((int) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3701,1 +3731,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3711,1 +3741,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3725,8 +3755,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -3735,1 +3758,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3738,1 +3761,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3747,1 +3772,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3756,1 +3781,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3771,0 +3796,1 @@\n+            ra = OR_IDENTITY;\n@@ -3773,9 +3799,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3789,0 +3809,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id | x), x);\n+                Assert.assertEquals((int) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3790,1 +3833,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3800,1 +3843,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3817,0 +3860,1 @@\n+            ra = OR_IDENTITY;\n@@ -3819,9 +3863,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3836,1 +3874,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3845,1 +3883,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3860,0 +3898,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3862,9 +3901,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3878,0 +3911,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id ^ x), x);\n+                Assert.assertEquals((int) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3879,1 +3935,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3889,1 +3945,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3906,0 +3962,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3908,9 +3965,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3925,1 +3976,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3934,1 +3985,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3949,0 +4000,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3951,9 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3967,0 +4013,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id + x), x);\n+                Assert.assertEquals((int) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3968,1 +4037,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3978,1 +4047,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3995,0 +4064,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3997,9 +4067,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4014,1 +4078,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4023,1 +4087,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4035,8 +4099,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        int ra = 0;\n@@ -4045,1 +4102,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4048,1 +4105,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4056,0 +4115,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id * x), x);\n+                Assert.assertEquals((int) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4057,1 +4139,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4067,1 +4149,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4081,8 +4163,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4091,1 +4166,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4094,1 +4169,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4103,1 +4180,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4112,1 +4189,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4124,8 +4201,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4134,1 +4204,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4137,1 +4207,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4145,0 +4217,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.min(id, x), x);\n+                Assert.assertEquals((int) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4146,1 +4241,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4156,1 +4251,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4170,8 +4265,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4180,1 +4268,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4183,1 +4271,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4192,1 +4282,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4201,1 +4291,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4213,8 +4303,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4223,1 +4306,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4226,1 +4309,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4234,0 +4319,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.max(id, x), x);\n+                Assert.assertEquals((int) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4235,1 +4343,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4245,1 +4353,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4259,8 +4367,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4269,1 +4370,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4272,1 +4373,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4281,1 +4384,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4290,1 +4393,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4302,8 +4405,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4312,1 +4408,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4315,1 +4411,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4323,0 +4421,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4324,1 +4445,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4334,1 +4455,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4348,8 +4469,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4358,1 +4472,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4361,1 +4475,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4370,1 +4486,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4379,1 +4495,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4391,8 +4507,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4401,1 +4510,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4404,1 +4513,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4412,0 +4523,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4413,1 +4547,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4423,1 +4557,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4437,8 +4571,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4447,1 +4574,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4450,1 +4577,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4459,1 +4588,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4597,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4480,8 +4609,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        int ra = 0;\n@@ -4490,1 +4612,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4493,1 +4615,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4501,0 +4625,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,1 +4649,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4512,1 +4659,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4526,8 +4673,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4536,1 +4676,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4539,1 +4679,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4596,1 +4738,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4605,1 +4747,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4620,0 +4762,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4622,9 +4765,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4638,0 +4775,23 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4639,1 +4799,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4649,1 +4809,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4665,0 +4825,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4667,9 +4828,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final int ADD_IDENTITY = (int)0;\n+    private static final int AND_IDENTITY = (int)-1;\n+    private static final int FIRST_NONZERO_IDENTITY = (int)0;\n+    private static final int MAX_IDENTITY = Integer.MIN_VALUE;\n+    private static final int MIN_IDENTITY = Integer.MAX_VALUE;\n+    private static final int MUL_IDENTITY = (int)1;\n+    private static final int OR_IDENTITY = (int)0;\n+    private static final int SUADD_IDENTITY = (int)0;\n+    private static final int UMAX_IDENTITY = (int)0;   \/\/ Minimum unsigned value\n+    private static final int UMIN_IDENTITY = (int)-1;  \/\/ Maximum unsigned value\n+    private static final int XOR_IDENTITY = (int)0;\n+\n@@ -3658,1 +3670,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3667,1 +3679,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3679,8 +3691,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        int ra = 0;\n@@ -3689,1 +3694,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3692,1 +3697,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3700,0 +3707,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id & x), x);\n+                Assert.assertEquals((int) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3701,1 +3731,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3711,1 +3741,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3725,8 +3755,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -3735,1 +3758,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3738,1 +3761,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3747,1 +3772,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3756,1 +3781,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3771,0 +3796,1 @@\n+            ra = OR_IDENTITY;\n@@ -3773,9 +3799,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3789,0 +3809,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id | x), x);\n+                Assert.assertEquals((int) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3790,1 +3833,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3800,1 +3843,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3817,0 +3860,1 @@\n+            ra = OR_IDENTITY;\n@@ -3819,9 +3863,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3836,1 +3874,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3845,1 +3883,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3860,0 +3898,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3862,9 +3901,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3878,0 +3911,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id ^ x), x);\n+                Assert.assertEquals((int) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3879,1 +3935,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3889,1 +3945,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3906,0 +3962,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3908,9 +3965,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3925,1 +3976,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3934,1 +3985,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3949,0 +4000,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3951,9 +4003,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3967,0 +4013,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id + x), x);\n+                Assert.assertEquals((int) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3968,1 +4037,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3978,1 +4047,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3995,0 +4064,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3997,9 +4067,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4014,1 +4078,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4023,1 +4087,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4035,8 +4099,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        int ra = 0;\n@@ -4045,1 +4102,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4048,1 +4105,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4056,0 +4115,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id * x), x);\n+                Assert.assertEquals((int) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4057,1 +4139,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4067,1 +4149,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4081,8 +4163,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4091,1 +4166,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4094,1 +4169,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4103,1 +4180,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4112,1 +4189,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4124,8 +4201,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4134,1 +4204,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4137,1 +4207,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4145,0 +4217,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.min(id, x), x);\n+                Assert.assertEquals((int) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4146,1 +4241,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4156,1 +4251,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4170,8 +4265,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4180,1 +4268,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4183,1 +4271,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4192,1 +4282,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4201,1 +4291,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4213,8 +4303,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4223,1 +4306,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4226,1 +4309,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4234,0 +4319,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.max(id, x), x);\n+                Assert.assertEquals((int) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4235,1 +4343,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4245,1 +4353,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4259,8 +4367,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4269,1 +4370,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4272,1 +4373,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4281,1 +4384,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4290,1 +4393,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4302,8 +4405,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4312,1 +4408,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4315,1 +4411,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4323,0 +4421,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4324,1 +4445,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4334,1 +4455,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4348,8 +4469,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4358,1 +4472,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4361,1 +4475,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4370,1 +4486,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4379,1 +4495,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4391,8 +4507,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4401,1 +4510,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4404,1 +4513,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4412,0 +4523,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4413,1 +4547,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4423,1 +4557,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4437,8 +4571,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4447,1 +4574,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4450,1 +4577,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4459,1 +4588,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4468,1 +4597,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4480,8 +4609,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        int ra = 0;\n@@ -4490,1 +4612,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4493,1 +4615,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4501,0 +4625,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4502,1 +4649,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4512,1 +4659,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4526,8 +4673,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4536,1 +4676,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4539,1 +4679,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4596,1 +4738,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4605,1 +4747,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4620,0 +4762,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4622,9 +4765,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4638,0 +4775,23 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4639,1 +4799,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4649,1 +4809,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4665,0 +4825,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4667,9 +4828,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final int ADD_IDENTITY = (int)0;\n+    private static final int AND_IDENTITY = (int)-1;\n+    private static final int FIRST_NONZERO_IDENTITY = (int)0;\n+    private static final int MAX_IDENTITY = Integer.MIN_VALUE;\n+    private static final int MIN_IDENTITY = Integer.MAX_VALUE;\n+    private static final int MUL_IDENTITY = (int)1;\n+    private static final int OR_IDENTITY = (int)0;\n+    private static final int SUADD_IDENTITY = (int)0;\n+    private static final int UMAX_IDENTITY = (int)0;   \/\/ Minimum unsigned value\n+    private static final int UMIN_IDENTITY = (int)-1;  \/\/ Maximum unsigned value\n+    private static final int XOR_IDENTITY = (int)0;\n+\n@@ -3663,1 +3676,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3672,1 +3685,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3684,8 +3697,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        int ra = 0;\n@@ -3694,1 +3700,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3697,1 +3703,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                int v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3705,0 +3713,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = AND_IDENTITY;\n+\n+        Assert.assertEquals((int) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id & x), x);\n+                Assert.assertEquals((int) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3706,1 +3737,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3716,1 +3747,1 @@\n-        int res = -1;\n+        int res = AND_IDENTITY;\n@@ -3730,8 +3761,1 @@\n-        int ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -3740,1 +3764,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3743,1 +3767,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                int v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3752,1 +3778,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3761,1 +3787,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3776,0 +3802,1 @@\n+            ra = OR_IDENTITY;\n@@ -3778,9 +3805,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                int v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3794,0 +3815,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = OR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id | x), x);\n+                Assert.assertEquals((int) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3795,1 +3839,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3805,1 +3849,1 @@\n-        int res = 0;\n+        int res = OR_IDENTITY;\n@@ -3822,0 +3866,1 @@\n+            ra = OR_IDENTITY;\n@@ -3824,9 +3869,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                int v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3841,1 +3880,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3850,1 +3889,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3865,0 +3904,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3867,9 +3907,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                int v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3883,0 +3917,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((int) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id ^ x), x);\n+                Assert.assertEquals((int) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3884,1 +3941,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3894,1 +3951,1 @@\n-        int res = 0;\n+        int res = XOR_IDENTITY;\n@@ -3911,0 +3968,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3913,9 +3971,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                int v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3930,1 +3982,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3939,1 +3991,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3954,0 +4006,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3956,9 +4009,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                int v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3972,0 +4019,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((int) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id + x), x);\n+                Assert.assertEquals((int) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3973,1 +4043,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -3983,1 +4053,1 @@\n-        int res = 0;\n+        int res = ADD_IDENTITY;\n@@ -4000,0 +4070,1 @@\n+            ra = ADD_IDENTITY;\n@@ -4002,9 +4073,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                int v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4019,1 +4084,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4028,1 +4093,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4040,8 +4105,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        int ra = 0;\n@@ -4050,1 +4108,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4053,1 +4111,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                int v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4061,0 +4121,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((int) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) (id * x), x);\n+                Assert.assertEquals((int) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4062,1 +4145,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4072,1 +4155,1 @@\n-        int res = 1;\n+        int res = MUL_IDENTITY;\n@@ -4086,8 +4169,1 @@\n-        int ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4096,1 +4172,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4099,1 +4175,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                int v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4108,1 +4186,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4117,1 +4195,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4129,8 +4207,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4139,1 +4210,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4142,1 +4213,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                int v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4150,0 +4223,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.min(id, x), x);\n+                Assert.assertEquals((int) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4151,1 +4247,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4161,1 +4257,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = MIN_IDENTITY;\n@@ -4175,8 +4271,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4185,1 +4274,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4188,1 +4277,3 @@\n-                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (int) Math.min(ra, v);\n@@ -4197,1 +4288,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4206,1 +4297,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4218,8 +4309,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4228,1 +4312,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4231,1 +4315,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                int v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4239,0 +4325,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((int) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) Math.max(id, x), x);\n+                Assert.assertEquals((int) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4240,1 +4349,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4250,1 +4359,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = MAX_IDENTITY;\n@@ -4264,8 +4373,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4274,1 +4376,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4277,1 +4379,3 @@\n-                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (int) Math.max(ra, v);\n@@ -4286,1 +4390,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4295,1 +4399,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4307,8 +4411,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        int ra = 0;\n@@ -4317,1 +4414,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4320,1 +4417,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                int v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4328,0 +4427,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4329,1 +4451,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4339,1 +4461,1 @@\n-        int res = Integer.MAX_VALUE;\n+        int res = UMIN_IDENTITY;\n@@ -4353,8 +4475,1 @@\n-        int ra = Integer.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4363,1 +4478,1 @@\n-            ra = Integer.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4366,1 +4481,3 @@\n-                ra = (int) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.minUnsigned(ra, v);\n@@ -4375,1 +4492,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4384,1 +4501,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4396,8 +4513,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        int ra = 0;\n@@ -4406,1 +4516,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4409,1 +4519,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                int v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4417,0 +4529,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4418,1 +4553,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4428,1 +4563,1 @@\n-        int res = Integer.MIN_VALUE;\n+        int res = UMAX_IDENTITY;\n@@ -4442,8 +4577,1 @@\n-        int ra = Integer.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4452,1 +4580,1 @@\n-            ra = Integer.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4455,1 +4583,3 @@\n-                ra = (int) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                int v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.maxUnsigned(ra, v);\n@@ -4464,1 +4594,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4473,1 +4603,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4485,8 +4615,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        int ra = 0;\n@@ -4495,1 +4618,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4498,1 +4621,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4506,0 +4631,23 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4507,1 +4655,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4517,1 +4665,1 @@\n-        int res = (int) 0;\n+        int res = FIRST_NONZERO_IDENTITY;\n@@ -4531,8 +4679,1 @@\n-        int ra = (int) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        int ra = 0;\n@@ -4541,1 +4682,1 @@\n-            ra = (int) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4544,1 +4685,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                int v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4601,1 +4744,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4610,1 +4753,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4625,0 +4768,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4627,9 +4771,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                int v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4643,0 +4781,23 @@\n+    @Test(dataProvider = \"intSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        int x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((int) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4644,1 +4805,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4654,1 +4815,1 @@\n-        int res = 0;\n+        int res = SUADD_IDENTITY;\n@@ -4670,0 +4831,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4672,9 +4834,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                ra = (int) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                int v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (int) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":413,"deletions":257,"binary":false,"changes":670,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final long ADD_IDENTITY = (long)0;\n+    private static final long AND_IDENTITY = (long)-1;\n+    private static final long FIRST_NONZERO_IDENTITY = (long)0;\n+    private static final long MAX_IDENTITY = Long.MIN_VALUE;\n+    private static final long MIN_IDENTITY = Long.MAX_VALUE;\n+    private static final long MUL_IDENTITY = (long)1;\n+    private static final long OR_IDENTITY = (long)0;\n+    private static final long SUADD_IDENTITY = (long)0;\n+    private static final long UMAX_IDENTITY = (long)0;   \/\/ Minimum unsigned value\n+    private static final long UMIN_IDENTITY = (long)-1;  \/\/ Maximum unsigned value\n+    private static final long XOR_IDENTITY = (long)0;\n+\n@@ -3680,1 +3692,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3689,1 +3701,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3701,8 +3713,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        long ra = 0;\n@@ -3711,1 +3716,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3714,1 +3719,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,0 +3729,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id & x), x);\n+                Assert.assertEquals((long) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3723,1 +3753,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3733,1 +3763,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3747,8 +3777,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -3757,1 +3780,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3760,1 +3783,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3769,1 +3794,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3778,1 +3803,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3793,0 +3818,1 @@\n+            ra = OR_IDENTITY;\n@@ -3795,9 +3821,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3811,0 +3831,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id | x), x);\n+                Assert.assertEquals((long) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3812,1 +3855,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3822,1 +3865,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3839,0 +3882,1 @@\n+            ra = OR_IDENTITY;\n@@ -3841,9 +3885,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3858,1 +3896,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3867,1 +3905,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3882,0 +3920,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3884,9 +3923,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3900,0 +3933,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id ^ x), x);\n+                Assert.assertEquals((long) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3901,1 +3957,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3911,1 +3967,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3928,0 +3984,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3930,9 +3987,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3947,1 +3998,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3956,1 +4007,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3971,0 +4022,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3973,9 +4025,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3989,0 +4035,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id + x), x);\n+                Assert.assertEquals((long) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3990,1 +4059,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4000,1 +4069,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4017,0 +4086,1 @@\n+            ra = ADD_IDENTITY;\n@@ -4019,9 +4089,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4036,1 +4100,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4045,1 +4109,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4057,8 +4121,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        long ra = 0;\n@@ -4067,1 +4124,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4070,1 +4127,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4078,0 +4137,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id * x), x);\n+                Assert.assertEquals((long) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,1 +4161,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4089,1 +4171,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4103,8 +4185,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4113,1 +4188,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4116,1 +4191,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4125,1 +4202,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4134,1 +4211,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4146,8 +4223,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4156,1 +4226,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4159,1 +4229,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4167,0 +4239,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.min(id, x), x);\n+                Assert.assertEquals((long) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4168,1 +4263,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4178,1 +4273,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4192,8 +4287,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4202,1 +4290,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4205,1 +4293,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4214,1 +4304,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4223,1 +4313,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4235,8 +4325,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4245,1 +4328,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4248,1 +4331,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4256,0 +4341,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.max(id, x), x);\n+                Assert.assertEquals((long) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4257,1 +4365,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4267,1 +4375,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4281,8 +4389,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4291,1 +4392,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4294,1 +4395,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4303,1 +4406,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4312,1 +4415,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4324,8 +4427,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4334,1 +4430,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4337,1 +4433,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4345,0 +4443,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4346,1 +4467,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4356,1 +4477,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4370,8 +4491,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4380,1 +4494,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4383,1 +4497,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4392,1 +4508,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4401,1 +4517,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4413,8 +4529,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4423,1 +4532,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4426,1 +4535,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4434,0 +4545,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4435,1 +4569,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4445,1 +4579,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4459,8 +4593,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4469,1 +4596,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4472,1 +4599,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4481,1 +4610,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4490,1 +4619,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4502,8 +4631,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        long ra = 0;\n@@ -4512,1 +4634,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4515,1 +4637,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4523,0 +4647,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4524,1 +4671,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4534,1 +4681,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4548,8 +4695,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4558,1 +4698,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4561,1 +4701,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4618,1 +4760,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4627,1 +4769,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4642,0 +4784,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4644,9 +4787,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4660,0 +4797,23 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4661,1 +4821,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4671,1 +4831,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4687,0 +4847,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4689,9 +4850,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final long ADD_IDENTITY = (long)0;\n+    private static final long AND_IDENTITY = (long)-1;\n+    private static final long FIRST_NONZERO_IDENTITY = (long)0;\n+    private static final long MAX_IDENTITY = Long.MIN_VALUE;\n+    private static final long MIN_IDENTITY = Long.MAX_VALUE;\n+    private static final long MUL_IDENTITY = (long)1;\n+    private static final long OR_IDENTITY = (long)0;\n+    private static final long SUADD_IDENTITY = (long)0;\n+    private static final long UMAX_IDENTITY = (long)0;   \/\/ Minimum unsigned value\n+    private static final long UMIN_IDENTITY = (long)-1;  \/\/ Maximum unsigned value\n+    private static final long XOR_IDENTITY = (long)0;\n+\n@@ -3680,1 +3692,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3689,1 +3701,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3701,8 +3713,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        long ra = 0;\n@@ -3711,1 +3716,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3714,1 +3719,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,0 +3729,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id & x), x);\n+                Assert.assertEquals((long) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3723,1 +3753,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3733,1 +3763,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3747,8 +3777,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -3757,1 +3780,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3760,1 +3783,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3769,1 +3794,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3778,1 +3803,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3793,0 +3818,1 @@\n+            ra = OR_IDENTITY;\n@@ -3795,9 +3821,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3811,0 +3831,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id | x), x);\n+                Assert.assertEquals((long) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3812,1 +3855,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3822,1 +3865,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3839,0 +3882,1 @@\n+            ra = OR_IDENTITY;\n@@ -3841,9 +3885,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3858,1 +3896,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3867,1 +3905,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3882,0 +3920,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3884,9 +3923,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3900,0 +3933,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id ^ x), x);\n+                Assert.assertEquals((long) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3901,1 +3957,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3911,1 +3967,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3928,0 +3984,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3930,9 +3987,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3947,1 +3998,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3956,1 +4007,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3971,0 +4022,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3973,9 +4025,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3989,0 +4035,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id + x), x);\n+                Assert.assertEquals((long) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3990,1 +4059,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4000,1 +4069,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4017,0 +4086,1 @@\n+            ra = ADD_IDENTITY;\n@@ -4019,9 +4089,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4036,1 +4100,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4045,1 +4109,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4057,8 +4121,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        long ra = 0;\n@@ -4067,1 +4124,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4070,1 +4127,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4078,0 +4137,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id * x), x);\n+                Assert.assertEquals((long) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,1 +4161,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4089,1 +4171,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4103,8 +4185,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4113,1 +4188,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4116,1 +4191,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4125,1 +4202,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4134,1 +4211,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4146,8 +4223,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4156,1 +4226,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4159,1 +4229,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4167,0 +4239,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.min(id, x), x);\n+                Assert.assertEquals((long) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4168,1 +4263,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4178,1 +4273,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4192,8 +4287,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4202,1 +4290,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4205,1 +4293,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4214,1 +4304,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4223,1 +4313,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4235,8 +4325,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4245,1 +4328,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4248,1 +4331,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4256,0 +4341,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.max(id, x), x);\n+                Assert.assertEquals((long) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4257,1 +4365,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4267,1 +4375,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4281,8 +4389,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4291,1 +4392,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4294,1 +4395,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4303,1 +4406,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4312,1 +4415,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4324,8 +4427,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4334,1 +4430,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4337,1 +4433,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4345,0 +4443,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4346,1 +4467,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4356,1 +4477,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4370,8 +4491,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4380,1 +4494,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4383,1 +4497,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4392,1 +4508,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4401,1 +4517,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4413,8 +4529,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4423,1 +4532,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4426,1 +4535,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4434,0 +4545,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4435,1 +4569,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4445,1 +4579,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4459,8 +4593,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4469,1 +4596,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4472,1 +4599,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4481,1 +4610,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4490,1 +4619,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4502,8 +4631,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        long ra = 0;\n@@ -4512,1 +4634,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4515,1 +4637,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4523,0 +4647,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4524,1 +4671,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4534,1 +4681,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4548,8 +4695,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4558,1 +4698,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4561,1 +4701,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4618,1 +4760,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4627,1 +4769,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4642,0 +4784,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4644,9 +4787,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4660,0 +4797,23 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4661,1 +4821,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4671,1 +4831,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4687,0 +4847,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4689,9 +4850,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final long ADD_IDENTITY = (long)0;\n+    private static final long AND_IDENTITY = (long)-1;\n+    private static final long FIRST_NONZERO_IDENTITY = (long)0;\n+    private static final long MAX_IDENTITY = Long.MIN_VALUE;\n+    private static final long MIN_IDENTITY = Long.MAX_VALUE;\n+    private static final long MUL_IDENTITY = (long)1;\n+    private static final long OR_IDENTITY = (long)0;\n+    private static final long SUADD_IDENTITY = (long)0;\n+    private static final long UMAX_IDENTITY = (long)0;   \/\/ Minimum unsigned value\n+    private static final long UMIN_IDENTITY = (long)-1;  \/\/ Maximum unsigned value\n+    private static final long XOR_IDENTITY = (long)0;\n+\n@@ -3680,1 +3692,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3689,1 +3701,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3701,8 +3713,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        long ra = 0;\n@@ -3711,1 +3716,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3714,1 +3719,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,0 +3729,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id & x), x);\n+                Assert.assertEquals((long) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3723,1 +3753,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3733,1 +3763,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3747,8 +3777,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -3757,1 +3780,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3760,1 +3783,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3769,1 +3794,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3778,1 +3803,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3793,0 +3818,1 @@\n+            ra = OR_IDENTITY;\n@@ -3795,9 +3821,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3811,0 +3831,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id | x), x);\n+                Assert.assertEquals((long) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3812,1 +3855,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3822,1 +3865,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3839,0 +3882,1 @@\n+            ra = OR_IDENTITY;\n@@ -3841,9 +3885,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3858,1 +3896,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3867,1 +3905,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3882,0 +3920,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3884,9 +3923,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3900,0 +3933,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id ^ x), x);\n+                Assert.assertEquals((long) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3901,1 +3957,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3911,1 +3967,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3928,0 +3984,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3930,9 +3987,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3947,1 +3998,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3956,1 +4007,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3971,0 +4022,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3973,9 +4025,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3989,0 +4035,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id + x), x);\n+                Assert.assertEquals((long) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3990,1 +4059,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4000,1 +4069,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4017,0 +4086,1 @@\n+            ra = ADD_IDENTITY;\n@@ -4019,9 +4089,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4036,1 +4100,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4045,1 +4109,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4057,8 +4121,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        long ra = 0;\n@@ -4067,1 +4124,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4070,1 +4127,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4078,0 +4137,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id * x), x);\n+                Assert.assertEquals((long) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,1 +4161,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4089,1 +4171,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4103,8 +4185,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4113,1 +4188,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4116,1 +4191,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4125,1 +4202,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4134,1 +4211,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4146,8 +4223,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4156,1 +4226,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4159,1 +4229,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4167,0 +4239,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.min(id, x), x);\n+                Assert.assertEquals((long) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4168,1 +4263,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4178,1 +4273,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4192,8 +4287,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4202,1 +4290,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4205,1 +4293,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4214,1 +4304,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4223,1 +4313,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4235,8 +4325,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4245,1 +4328,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4248,1 +4331,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4256,0 +4341,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.max(id, x), x);\n+                Assert.assertEquals((long) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4257,1 +4365,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4267,1 +4375,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4281,8 +4389,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4291,1 +4392,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4294,1 +4395,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4303,1 +4406,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4312,1 +4415,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4324,8 +4427,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4334,1 +4430,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4337,1 +4433,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4345,0 +4443,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4346,1 +4467,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4356,1 +4477,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4370,8 +4491,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4380,1 +4494,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4383,1 +4497,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4392,1 +4508,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4401,1 +4517,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4413,8 +4529,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4423,1 +4532,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4426,1 +4535,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4434,0 +4545,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4435,1 +4569,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4445,1 +4579,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4459,8 +4593,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4469,1 +4596,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4472,1 +4599,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4481,1 +4610,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4490,1 +4619,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4502,8 +4631,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        long ra = 0;\n@@ -4512,1 +4634,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4515,1 +4637,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4523,0 +4647,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4524,1 +4671,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4534,1 +4681,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4548,8 +4695,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4558,1 +4698,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4561,1 +4701,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4618,1 +4760,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4627,1 +4769,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4642,0 +4784,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4644,9 +4787,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4660,0 +4797,23 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4661,1 +4821,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4671,1 +4831,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4687,0 +4847,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4689,9 +4850,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final long ADD_IDENTITY = (long)0;\n+    private static final long AND_IDENTITY = (long)-1;\n+    private static final long FIRST_NONZERO_IDENTITY = (long)0;\n+    private static final long MAX_IDENTITY = Long.MIN_VALUE;\n+    private static final long MIN_IDENTITY = Long.MAX_VALUE;\n+    private static final long MUL_IDENTITY = (long)1;\n+    private static final long OR_IDENTITY = (long)0;\n+    private static final long SUADD_IDENTITY = (long)0;\n+    private static final long UMAX_IDENTITY = (long)0;   \/\/ Minimum unsigned value\n+    private static final long UMIN_IDENTITY = (long)-1;  \/\/ Maximum unsigned value\n+    private static final long XOR_IDENTITY = (long)0;\n+\n@@ -3680,1 +3692,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3689,1 +3701,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3701,8 +3713,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        long ra = 0;\n@@ -3711,1 +3716,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3714,1 +3719,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3722,0 +3729,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id & x), x);\n+                Assert.assertEquals((long) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3723,1 +3753,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3733,1 +3763,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3747,8 +3777,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -3757,1 +3780,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3760,1 +3783,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3769,1 +3794,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3778,1 +3803,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3793,0 +3818,1 @@\n+            ra = OR_IDENTITY;\n@@ -3795,9 +3821,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3811,0 +3831,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id | x), x);\n+                Assert.assertEquals((long) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3812,1 +3855,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3822,1 +3865,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3839,0 +3882,1 @@\n+            ra = OR_IDENTITY;\n@@ -3841,9 +3885,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3858,1 +3896,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3867,1 +3905,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3882,0 +3920,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3884,9 +3923,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3900,0 +3933,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id ^ x), x);\n+                Assert.assertEquals((long) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3901,1 +3957,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3911,1 +3967,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3928,0 +3984,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3930,9 +3987,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3947,1 +3998,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3956,1 +4007,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3971,0 +4022,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3973,9 +4025,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3989,0 +4035,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id + x), x);\n+                Assert.assertEquals((long) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3990,1 +4059,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4000,1 +4069,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4017,0 +4086,1 @@\n+            ra = ADD_IDENTITY;\n@@ -4019,9 +4089,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4036,1 +4100,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4045,1 +4109,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4057,8 +4121,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        long ra = 0;\n@@ -4067,1 +4124,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4070,1 +4127,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4078,0 +4137,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id * x), x);\n+                Assert.assertEquals((long) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4079,1 +4161,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4089,1 +4171,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4103,8 +4185,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4113,1 +4188,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4116,1 +4191,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4125,1 +4202,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4134,1 +4211,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4146,8 +4223,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4156,1 +4226,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4159,1 +4229,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4167,0 +4239,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.min(id, x), x);\n+                Assert.assertEquals((long) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4168,1 +4263,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4178,1 +4273,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4192,8 +4287,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4202,1 +4290,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4205,1 +4293,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4214,1 +4304,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4223,1 +4313,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4235,8 +4325,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4245,1 +4328,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4248,1 +4331,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4256,0 +4341,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.max(id, x), x);\n+                Assert.assertEquals((long) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4257,1 +4365,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4267,1 +4375,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4281,8 +4389,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4291,1 +4392,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4294,1 +4395,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4303,1 +4406,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4312,1 +4415,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4324,8 +4427,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4334,1 +4430,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4337,1 +4433,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4345,0 +4443,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4346,1 +4467,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4356,1 +4477,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4370,8 +4491,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4380,1 +4494,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4383,1 +4497,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4392,1 +4508,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4401,1 +4517,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4413,8 +4529,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4423,1 +4532,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4426,1 +4535,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4434,0 +4545,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4435,1 +4569,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4445,1 +4579,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4459,8 +4593,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4469,1 +4596,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4472,1 +4599,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4481,1 +4610,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4490,1 +4619,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4502,8 +4631,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        long ra = 0;\n@@ -4512,1 +4634,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4515,1 +4637,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4523,0 +4647,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4524,1 +4671,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4534,1 +4681,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4548,8 +4695,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4558,1 +4698,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4561,1 +4701,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4618,1 +4760,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4627,1 +4769,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4642,0 +4784,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4644,9 +4787,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4660,0 +4797,23 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4661,1 +4821,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4671,1 +4831,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4687,0 +4847,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4689,9 +4850,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final long ADD_IDENTITY = (long)0;\n+    private static final long AND_IDENTITY = (long)-1;\n+    private static final long FIRST_NONZERO_IDENTITY = (long)0;\n+    private static final long MAX_IDENTITY = Long.MIN_VALUE;\n+    private static final long MIN_IDENTITY = Long.MAX_VALUE;\n+    private static final long MUL_IDENTITY = (long)1;\n+    private static final long OR_IDENTITY = (long)0;\n+    private static final long SUADD_IDENTITY = (long)0;\n+    private static final long UMAX_IDENTITY = (long)0;   \/\/ Minimum unsigned value\n+    private static final long UMIN_IDENTITY = (long)-1;  \/\/ Maximum unsigned value\n+    private static final long XOR_IDENTITY = (long)0;\n+\n@@ -3685,1 +3698,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3694,1 +3707,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3706,8 +3719,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        long ra = 0;\n@@ -3716,1 +3722,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3719,1 +3725,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                long v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3727,0 +3735,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = AND_IDENTITY;\n+\n+        Assert.assertEquals((long) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id & x), x);\n+                Assert.assertEquals((long) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3728,1 +3759,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3738,1 +3769,1 @@\n-        long res = -1;\n+        long res = AND_IDENTITY;\n@@ -3752,8 +3783,1 @@\n-        long ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -3762,1 +3786,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3765,1 +3789,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                long v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3774,1 +3800,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3783,1 +3809,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3798,0 +3824,1 @@\n+            ra = OR_IDENTITY;\n@@ -3800,9 +3827,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                long v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3816,0 +3837,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = OR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id | x), x);\n+                Assert.assertEquals((long) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3817,1 +3861,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3827,1 +3871,1 @@\n-        long res = 0;\n+        long res = OR_IDENTITY;\n@@ -3844,0 +3888,1 @@\n+            ra = OR_IDENTITY;\n@@ -3846,9 +3891,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                long v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3863,1 +3902,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3872,1 +3911,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3887,0 +3926,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3889,9 +3929,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                long v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3905,0 +3939,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((long) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id ^ x), x);\n+                Assert.assertEquals((long) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3906,1 +3963,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3916,1 +3973,1 @@\n-        long res = 0;\n+        long res = XOR_IDENTITY;\n@@ -3933,0 +3990,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3935,9 +3993,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                long v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3952,1 +4004,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3961,1 +4013,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -3976,0 +4028,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3978,9 +4031,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                long v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3994,0 +4041,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((long) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id + x), x);\n+                Assert.assertEquals((long) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3995,1 +4065,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4005,1 +4075,1 @@\n-        long res = 0;\n+        long res = ADD_IDENTITY;\n@@ -4022,0 +4092,1 @@\n+            ra = ADD_IDENTITY;\n@@ -4024,9 +4095,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                long v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -4041,1 +4106,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4050,1 +4115,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4062,8 +4127,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        long ra = 0;\n@@ -4072,1 +4130,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4075,1 +4133,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                long v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4083,0 +4143,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((long) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) (id * x), x);\n+                Assert.assertEquals((long) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4084,1 +4167,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4094,1 +4177,1 @@\n-        long res = 1;\n+        long res = MUL_IDENTITY;\n@@ -4108,8 +4191,1 @@\n-        long ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4118,1 +4194,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4121,1 +4197,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                long v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4130,1 +4208,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4139,1 +4217,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4151,8 +4229,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4161,1 +4232,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4164,1 +4235,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                long v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4172,0 +4245,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.min(id, x), x);\n+                Assert.assertEquals((long) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4173,1 +4269,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4183,1 +4279,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = MIN_IDENTITY;\n@@ -4197,8 +4293,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4207,1 +4296,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4210,1 +4299,3 @@\n-                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (long) Math.min(ra, v);\n@@ -4219,1 +4310,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4228,1 +4319,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4240,8 +4331,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4250,1 +4334,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4253,1 +4337,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                long v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4261,0 +4347,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((long) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) Math.max(id, x), x);\n+                Assert.assertEquals((long) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4262,1 +4371,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4272,1 +4381,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = MAX_IDENTITY;\n@@ -4286,8 +4395,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4296,1 +4398,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4299,1 +4401,3 @@\n-                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (long) Math.max(ra, v);\n@@ -4308,1 +4412,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4317,1 +4421,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4329,8 +4433,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        long ra = 0;\n@@ -4339,1 +4436,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4342,1 +4439,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                long v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4350,0 +4449,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4351,1 +4473,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4361,1 +4483,1 @@\n-        long res = Long.MAX_VALUE;\n+        long res = UMIN_IDENTITY;\n@@ -4375,8 +4497,1 @@\n-        long ra = Long.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4385,1 +4500,1 @@\n-            ra = Long.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4388,1 +4503,3 @@\n-                ra = (long) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.minUnsigned(ra, v);\n@@ -4397,1 +4514,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4406,1 +4523,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4418,8 +4535,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        long ra = 0;\n@@ -4428,1 +4538,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4431,1 +4541,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                long v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4439,0 +4551,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4440,1 +4575,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4450,1 +4585,1 @@\n-        long res = Long.MIN_VALUE;\n+        long res = UMAX_IDENTITY;\n@@ -4464,8 +4599,1 @@\n-        long ra = Long.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4474,1 +4602,1 @@\n-            ra = Long.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4477,1 +4605,3 @@\n-                ra = (long) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                long v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.maxUnsigned(ra, v);\n@@ -4486,1 +4616,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4495,1 +4625,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4507,8 +4637,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        long ra = 0;\n@@ -4517,1 +4640,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4520,1 +4643,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4528,0 +4653,23 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4529,1 +4677,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4539,1 +4687,1 @@\n-        long res = (long) 0;\n+        long res = FIRST_NONZERO_IDENTITY;\n@@ -4553,8 +4701,1 @@\n-        long ra = (long) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        long ra = 0;\n@@ -4563,1 +4704,1 @@\n-            ra = (long) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4566,1 +4707,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                long v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4623,1 +4766,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4632,1 +4775,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4647,0 +4790,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4649,9 +4793,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                long v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4665,0 +4803,23 @@\n+    @Test(dataProvider = \"longSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        long x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((long) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4666,1 +4827,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4676,1 +4837,1 @@\n-        long res = 0;\n+        long res = SUADD_IDENTITY;\n@@ -4692,0 +4853,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4694,9 +4856,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                ra = (long) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                long v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (long) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":413,"deletions":257,"binary":false,"changes":670,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final short ADD_IDENTITY = (short)0;\n+    private static final short AND_IDENTITY = (short)-1;\n+    private static final short FIRST_NONZERO_IDENTITY = (short)0;\n+    private static final short MAX_IDENTITY = Short.MIN_VALUE;\n+    private static final short MIN_IDENTITY = Short.MAX_VALUE;\n+    private static final short MUL_IDENTITY = (short)1;\n+    private static final short OR_IDENTITY = (short)0;\n+    private static final short SUADD_IDENTITY = (short)0;\n+    private static final short UMAX_IDENTITY = (short)0;   \/\/ Minimum unsigned value\n+    private static final short UMIN_IDENTITY = (short)-1;  \/\/ Maximum unsigned value\n+    private static final short XOR_IDENTITY = (short)0;\n+\n@@ -3605,1 +3617,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3614,1 +3626,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3626,8 +3638,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        short ra = 0;\n@@ -3636,1 +3641,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3639,1 +3644,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3647,0 +3654,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id & x), x);\n+                Assert.assertEquals((short) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3648,1 +3678,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3658,1 +3688,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3672,8 +3702,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -3682,1 +3705,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3685,1 +3708,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3694,1 +3719,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3703,1 +3728,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3718,0 +3743,1 @@\n+            ra = OR_IDENTITY;\n@@ -3720,9 +3746,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3736,0 +3756,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id | x), x);\n+                Assert.assertEquals((short) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3737,1 +3780,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3747,1 +3790,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3764,0 +3807,1 @@\n+            ra = OR_IDENTITY;\n@@ -3766,9 +3810,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3783,1 +3821,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3792,1 +3830,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3807,0 +3845,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3809,9 +3848,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3825,0 +3858,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id ^ x), x);\n+                Assert.assertEquals((short) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3826,1 +3882,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3836,1 +3892,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3853,0 +3909,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3855,9 +3912,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3872,1 +3923,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3881,1 +3932,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3896,0 +3947,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3898,9 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3914,0 +3960,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id + x), x);\n+                Assert.assertEquals((short) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3915,1 +3984,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3925,1 +3994,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3942,0 +4011,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3944,9 +4014,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3961,1 +4025,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3970,1 +4034,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3982,8 +4046,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        short ra = 0;\n@@ -3992,1 +4049,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -3995,1 +4052,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4003,0 +4062,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id * x), x);\n+                Assert.assertEquals((short) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4004,1 +4086,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4014,1 +4096,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4028,8 +4110,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4038,1 +4113,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4041,1 +4116,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4050,1 +4127,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4059,1 +4136,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4071,8 +4148,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4081,1 +4151,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4084,1 +4154,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4092,0 +4164,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.min(id, x), x);\n+                Assert.assertEquals((short) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4093,1 +4188,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4103,1 +4198,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4117,8 +4212,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4127,1 +4215,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4130,1 +4218,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4139,1 +4229,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4148,1 +4238,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4160,8 +4250,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4170,1 +4253,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4173,1 +4256,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4181,0 +4266,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.max(id, x), x);\n+                Assert.assertEquals((short) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4182,1 +4290,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4192,1 +4300,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4206,8 +4314,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4216,1 +4317,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4219,1 +4320,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4228,1 +4331,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4237,1 +4340,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4249,8 +4352,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4259,1 +4355,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4262,1 +4358,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4270,0 +4368,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4271,1 +4392,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4281,1 +4402,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4295,8 +4416,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4305,1 +4419,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4308,1 +4422,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4317,1 +4433,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4326,1 +4442,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4338,8 +4454,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4348,1 +4457,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4351,1 +4460,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4359,0 +4470,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4360,1 +4494,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4370,1 +4504,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4384,8 +4518,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4394,1 +4521,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4397,1 +4524,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4406,1 +4535,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4415,1 +4544,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4427,8 +4556,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        short ra = 0;\n@@ -4437,1 +4559,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4440,1 +4562,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4448,0 +4572,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4449,1 +4596,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4459,1 +4606,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4473,8 +4620,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4483,1 +4623,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4486,1 +4626,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4543,1 +4685,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4552,1 +4694,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4567,0 +4709,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4569,9 +4712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4585,0 +4722,23 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4586,1 +4746,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4596,1 +4756,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4612,0 +4772,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4614,9 +4775,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final short ADD_IDENTITY = (short)0;\n+    private static final short AND_IDENTITY = (short)-1;\n+    private static final short FIRST_NONZERO_IDENTITY = (short)0;\n+    private static final short MAX_IDENTITY = Short.MIN_VALUE;\n+    private static final short MIN_IDENTITY = Short.MAX_VALUE;\n+    private static final short MUL_IDENTITY = (short)1;\n+    private static final short OR_IDENTITY = (short)0;\n+    private static final short SUADD_IDENTITY = (short)0;\n+    private static final short UMAX_IDENTITY = (short)0;   \/\/ Minimum unsigned value\n+    private static final short UMIN_IDENTITY = (short)-1;  \/\/ Maximum unsigned value\n+    private static final short XOR_IDENTITY = (short)0;\n+\n@@ -3605,1 +3617,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3614,1 +3626,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3626,8 +3638,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        short ra = 0;\n@@ -3636,1 +3641,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3639,1 +3644,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3647,0 +3654,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id & x), x);\n+                Assert.assertEquals((short) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3648,1 +3678,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3658,1 +3688,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3672,8 +3702,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -3682,1 +3705,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3685,1 +3708,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3694,1 +3719,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3703,1 +3728,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3718,0 +3743,1 @@\n+            ra = OR_IDENTITY;\n@@ -3720,9 +3746,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3736,0 +3756,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id | x), x);\n+                Assert.assertEquals((short) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3737,1 +3780,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3747,1 +3790,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3764,0 +3807,1 @@\n+            ra = OR_IDENTITY;\n@@ -3766,9 +3810,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3783,1 +3821,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3792,1 +3830,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3807,0 +3845,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3809,9 +3848,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3825,0 +3858,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id ^ x), x);\n+                Assert.assertEquals((short) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3826,1 +3882,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3836,1 +3892,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3853,0 +3909,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3855,9 +3912,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3872,1 +3923,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3881,1 +3932,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3896,0 +3947,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3898,9 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3914,0 +3960,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id + x), x);\n+                Assert.assertEquals((short) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3915,1 +3984,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3925,1 +3994,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3942,0 +4011,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3944,9 +4014,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3961,1 +4025,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3970,1 +4034,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3982,8 +4046,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        short ra = 0;\n@@ -3992,1 +4049,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -3995,1 +4052,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4003,0 +4062,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id * x), x);\n+                Assert.assertEquals((short) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4004,1 +4086,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4014,1 +4096,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4028,8 +4110,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4038,1 +4113,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4041,1 +4116,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4050,1 +4127,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4059,1 +4136,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4071,8 +4148,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4081,1 +4151,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4084,1 +4154,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4092,0 +4164,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.min(id, x), x);\n+                Assert.assertEquals((short) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4093,1 +4188,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4103,1 +4198,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4117,8 +4212,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4127,1 +4215,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4130,1 +4218,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4139,1 +4229,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4148,1 +4238,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4160,8 +4250,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4170,1 +4253,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4173,1 +4256,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4181,0 +4266,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.max(id, x), x);\n+                Assert.assertEquals((short) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4182,1 +4290,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4192,1 +4300,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4206,8 +4314,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4216,1 +4317,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4219,1 +4320,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4228,1 +4331,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4237,1 +4340,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4249,8 +4352,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4259,1 +4355,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4262,1 +4358,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4270,0 +4368,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4271,1 +4392,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4281,1 +4402,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4295,8 +4416,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4305,1 +4419,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4308,1 +4422,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4317,1 +4433,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4326,1 +4442,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4338,8 +4454,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4348,1 +4457,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4351,1 +4460,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4359,0 +4470,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4360,1 +4494,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4370,1 +4504,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4384,8 +4518,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4394,1 +4521,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4397,1 +4524,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4406,1 +4535,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4415,1 +4544,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4427,8 +4556,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        short ra = 0;\n@@ -4437,1 +4559,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4440,1 +4562,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4448,0 +4572,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4449,1 +4596,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4459,1 +4606,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4473,8 +4620,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4483,1 +4623,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4486,1 +4626,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4543,1 +4685,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4552,1 +4694,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4567,0 +4709,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4569,9 +4712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4585,0 +4722,23 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4586,1 +4746,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4596,1 +4756,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4612,0 +4772,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4614,9 +4775,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final short ADD_IDENTITY = (short)0;\n+    private static final short AND_IDENTITY = (short)-1;\n+    private static final short FIRST_NONZERO_IDENTITY = (short)0;\n+    private static final short MAX_IDENTITY = Short.MIN_VALUE;\n+    private static final short MIN_IDENTITY = Short.MAX_VALUE;\n+    private static final short MUL_IDENTITY = (short)1;\n+    private static final short OR_IDENTITY = (short)0;\n+    private static final short SUADD_IDENTITY = (short)0;\n+    private static final short UMAX_IDENTITY = (short)0;   \/\/ Minimum unsigned value\n+    private static final short UMIN_IDENTITY = (short)-1;  \/\/ Maximum unsigned value\n+    private static final short XOR_IDENTITY = (short)0;\n+\n@@ -3605,1 +3617,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3614,1 +3626,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3626,8 +3638,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        short ra = 0;\n@@ -3636,1 +3641,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3639,1 +3644,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3647,0 +3654,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id & x), x);\n+                Assert.assertEquals((short) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3648,1 +3678,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3658,1 +3688,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3672,8 +3702,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -3682,1 +3705,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3685,1 +3708,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3694,1 +3719,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3703,1 +3728,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3718,0 +3743,1 @@\n+            ra = OR_IDENTITY;\n@@ -3720,9 +3746,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3736,0 +3756,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id | x), x);\n+                Assert.assertEquals((short) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3737,1 +3780,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3747,1 +3790,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3764,0 +3807,1 @@\n+            ra = OR_IDENTITY;\n@@ -3766,9 +3810,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3783,1 +3821,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3792,1 +3830,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3807,0 +3845,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3809,9 +3848,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3825,0 +3858,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id ^ x), x);\n+                Assert.assertEquals((short) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3826,1 +3882,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3836,1 +3892,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3853,0 +3909,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3855,9 +3912,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3872,1 +3923,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3881,1 +3932,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3896,0 +3947,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3898,9 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3914,0 +3960,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id + x), x);\n+                Assert.assertEquals((short) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3915,1 +3984,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3925,1 +3994,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3942,0 +4011,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3944,9 +4014,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3961,1 +4025,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3970,1 +4034,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3982,8 +4046,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        short ra = 0;\n@@ -3992,1 +4049,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -3995,1 +4052,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4003,0 +4062,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id * x), x);\n+                Assert.assertEquals((short) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4004,1 +4086,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4014,1 +4096,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4028,8 +4110,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4038,1 +4113,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4041,1 +4116,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4050,1 +4127,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4059,1 +4136,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4071,8 +4148,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4081,1 +4151,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4084,1 +4154,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4092,0 +4164,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.min(id, x), x);\n+                Assert.assertEquals((short) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4093,1 +4188,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4103,1 +4198,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4117,8 +4212,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4127,1 +4215,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4130,1 +4218,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4139,1 +4229,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4148,1 +4238,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4160,8 +4250,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4170,1 +4253,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4173,1 +4256,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4181,0 +4266,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.max(id, x), x);\n+                Assert.assertEquals((short) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4182,1 +4290,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4192,1 +4300,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4206,8 +4314,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4216,1 +4317,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4219,1 +4320,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4228,1 +4331,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4237,1 +4340,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4249,8 +4352,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4259,1 +4355,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4262,1 +4358,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4270,0 +4368,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4271,1 +4392,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4281,1 +4402,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4295,8 +4416,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4305,1 +4419,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4308,1 +4422,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4317,1 +4433,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4326,1 +4442,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4338,8 +4454,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4348,1 +4457,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4351,1 +4460,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4359,0 +4470,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4360,1 +4494,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4370,1 +4504,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4384,8 +4518,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4394,1 +4521,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4397,1 +4524,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4406,1 +4535,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4415,1 +4544,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4427,8 +4556,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        short ra = 0;\n@@ -4437,1 +4559,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4440,1 +4562,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4448,0 +4572,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4449,1 +4596,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4459,1 +4606,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4473,8 +4620,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4483,1 +4623,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4486,1 +4626,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4543,1 +4685,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4552,1 +4694,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4567,0 +4709,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4569,9 +4712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4585,0 +4722,23 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4586,1 +4746,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4596,1 +4756,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4612,0 +4772,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4614,9 +4775,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-\n@@ -69,0 +68,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final short ADD_IDENTITY = (short)0;\n+    private static final short AND_IDENTITY = (short)-1;\n+    private static final short FIRST_NONZERO_IDENTITY = (short)0;\n+    private static final short MAX_IDENTITY = Short.MIN_VALUE;\n+    private static final short MIN_IDENTITY = Short.MAX_VALUE;\n+    private static final short MUL_IDENTITY = (short)1;\n+    private static final short OR_IDENTITY = (short)0;\n+    private static final short SUADD_IDENTITY = (short)0;\n+    private static final short UMAX_IDENTITY = (short)0;   \/\/ Minimum unsigned value\n+    private static final short UMIN_IDENTITY = (short)-1;  \/\/ Maximum unsigned value\n+    private static final short XOR_IDENTITY = (short)0;\n+\n@@ -3605,1 +3617,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3614,1 +3626,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3626,8 +3638,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        short ra = 0;\n@@ -3636,1 +3641,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3639,1 +3644,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3647,0 +3654,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id & x), x);\n+                Assert.assertEquals((short) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3648,1 +3678,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3658,1 +3688,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3672,8 +3702,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -3682,1 +3705,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3685,1 +3708,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3694,1 +3719,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3703,1 +3728,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3718,0 +3743,1 @@\n+            ra = OR_IDENTITY;\n@@ -3720,9 +3746,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3736,0 +3756,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id | x), x);\n+                Assert.assertEquals((short) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3737,1 +3780,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3747,1 +3790,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3764,0 +3807,1 @@\n+            ra = OR_IDENTITY;\n@@ -3766,9 +3810,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3783,1 +3821,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3792,1 +3830,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3807,0 +3845,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3809,9 +3848,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3825,0 +3858,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id ^ x), x);\n+                Assert.assertEquals((short) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3826,1 +3882,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3836,1 +3892,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3853,0 +3909,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3855,9 +3912,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3872,1 +3923,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3881,1 +3932,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3896,0 +3947,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3898,9 +3950,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3914,0 +3960,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id + x), x);\n+                Assert.assertEquals((short) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3915,1 +3984,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3925,1 +3994,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3942,0 +4011,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3944,9 +4014,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3961,1 +4025,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3970,1 +4034,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3982,8 +4046,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        short ra = 0;\n@@ -3992,1 +4049,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -3995,1 +4052,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4003,0 +4062,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id * x), x);\n+                Assert.assertEquals((short) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4004,1 +4086,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4014,1 +4096,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4028,8 +4110,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4038,1 +4113,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4041,1 +4116,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4050,1 +4127,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4059,1 +4136,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4071,8 +4148,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4081,1 +4151,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4084,1 +4154,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4092,0 +4164,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.min(id, x), x);\n+                Assert.assertEquals((short) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4093,1 +4188,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4103,1 +4198,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4117,8 +4212,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4127,1 +4215,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4130,1 +4218,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4139,1 +4229,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4148,1 +4238,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4160,8 +4250,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4170,1 +4253,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4173,1 +4256,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4181,0 +4266,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.max(id, x), x);\n+                Assert.assertEquals((short) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4182,1 +4290,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4192,1 +4300,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4206,8 +4314,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4216,1 +4317,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4219,1 +4320,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4228,1 +4331,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4237,1 +4340,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4249,8 +4352,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4259,1 +4355,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4262,1 +4358,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4270,0 +4368,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4271,1 +4392,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4281,1 +4402,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4295,8 +4416,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4305,1 +4419,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4308,1 +4422,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4317,1 +4433,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4326,1 +4442,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4338,8 +4454,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4348,1 +4457,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4351,1 +4460,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4359,0 +4470,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4360,1 +4494,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4370,1 +4504,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4384,8 +4518,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4394,1 +4521,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4397,1 +4524,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4406,1 +4535,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4415,1 +4544,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4427,8 +4556,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        short ra = 0;\n@@ -4437,1 +4559,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4440,1 +4562,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4448,0 +4572,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4449,1 +4596,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4459,1 +4606,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4473,8 +4620,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4483,1 +4623,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4486,1 +4626,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4543,1 +4685,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4552,1 +4694,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4567,0 +4709,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4569,9 +4712,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4585,0 +4722,23 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4586,1 +4746,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4596,1 +4756,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4612,0 +4772,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4614,9 +4775,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":413,"deletions":258,"binary":false,"changes":671,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,13 @@\n+    \/\/ Identity values for reduction operations\n+    private static final short ADD_IDENTITY = (short)0;\n+    private static final short AND_IDENTITY = (short)-1;\n+    private static final short FIRST_NONZERO_IDENTITY = (short)0;\n+    private static final short MAX_IDENTITY = Short.MIN_VALUE;\n+    private static final short MIN_IDENTITY = Short.MAX_VALUE;\n+    private static final short MUL_IDENTITY = (short)1;\n+    private static final short OR_IDENTITY = (short)0;\n+    private static final short SUADD_IDENTITY = (short)0;\n+    private static final short UMAX_IDENTITY = (short)0;   \/\/ Minimum unsigned value\n+    private static final short UMIN_IDENTITY = (short)-1;  \/\/ Maximum unsigned value\n+    private static final short XOR_IDENTITY = (short)0;\n+\n@@ -3610,1 +3623,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3619,1 +3632,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3631,8 +3644,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND);\n-            }\n-        }\n+        short ra = 0;\n@@ -3641,1 +3647,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3644,1 +3650,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND);\n+                short v = av.reduceLanes(VectorOperators.AND);\n+                r[i] = v;\n+                ra &= v;\n@@ -3652,0 +3660,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ANDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = AND_IDENTITY;\n+\n+        Assert.assertEquals((short) (id & id), id,\n+                            \"AND(AND_IDENTITY, AND_IDENTITY) != AND_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id & x), x);\n+                Assert.assertEquals((short) (x & id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id & x), x,\n+                                \"AND(AND_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x & id), x,\n+                                \"AND(\" + x + \", AND_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3653,1 +3684,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3663,1 +3694,1 @@\n-        short res = -1;\n+        short res = AND_IDENTITY;\n@@ -3677,8 +3708,1 @@\n-        short ra = -1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -3687,1 +3711,1 @@\n-            ra = -1;\n+            ra = AND_IDENTITY;\n@@ -3690,1 +3714,3 @@\n-                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+                short v = av.reduceLanes(VectorOperators.AND, vmask);\n+                r[i] = v;\n+                ra &= v;\n@@ -3699,1 +3725,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3708,1 +3734,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3723,0 +3749,1 @@\n+            ra = OR_IDENTITY;\n@@ -3725,9 +3752,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR);\n+                short v = av.reduceLanes(VectorOperators.OR);\n+                r[i] = v;\n+                ra |= v;\n@@ -3741,0 +3762,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = OR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id | id), id,\n+                            \"OR(OR_IDENTITY, OR_IDENTITY) != OR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id | x), x);\n+                Assert.assertEquals((short) (x | id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id | x), x,\n+                                \"OR(OR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x | id), x,\n+                                \"OR(\" + x + \", OR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3742,1 +3786,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3752,1 +3796,1 @@\n-        short res = 0;\n+        short res = OR_IDENTITY;\n@@ -3769,0 +3813,1 @@\n+            ra = OR_IDENTITY;\n@@ -3771,9 +3816,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+                short v = av.reduceLanes(VectorOperators.OR, vmask);\n+                r[i] = v;\n+                ra |= v;\n@@ -3788,1 +3827,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3797,1 +3836,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3812,0 +3851,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3814,9 +3854,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR);\n+                short v = av.reduceLanes(VectorOperators.XOR);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3830,0 +3864,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void XORReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = XOR_IDENTITY;\n+\n+        Assert.assertEquals((short) (id ^ id), id,\n+                            \"XOR(XOR_IDENTITY, XOR_IDENTITY) != XOR_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id ^ x), x);\n+                Assert.assertEquals((short) (x ^ id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id ^ x), x,\n+                                \"XOR(XOR_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x ^ id), x,\n+                                \"XOR(\" + x + \", XOR_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3831,1 +3888,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3841,1 +3898,1 @@\n-        short res = 0;\n+        short res = XOR_IDENTITY;\n@@ -3858,0 +3915,1 @@\n+            ra = XOR_IDENTITY;\n@@ -3860,9 +3918,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+                short v = av.reduceLanes(VectorOperators.XOR, vmask);\n+                r[i] = v;\n+                ra ^= v;\n@@ -3877,1 +3929,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3886,1 +3938,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3901,0 +3953,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3903,9 +3956,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD);\n+                short v = av.reduceLanes(VectorOperators.ADD);\n+                r[i] = v;\n+                ra += v;\n@@ -3919,0 +3966,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = ADD_IDENTITY;\n+\n+        Assert.assertEquals((short) (id + id), id,\n+                            \"ADD(ADD_IDENTITY, ADD_IDENTITY) != ADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id + x), x);\n+                Assert.assertEquals((short) (x + id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id + x), x,\n+                                \"ADD(ADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x + id), x,\n+                                \"ADD(\" + x + \", ADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -3920,1 +3990,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3930,1 +4000,1 @@\n-        short res = 0;\n+        short res = ADD_IDENTITY;\n@@ -3947,0 +4017,1 @@\n+            ra = ADD_IDENTITY;\n@@ -3949,9 +4020,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+                short v = av.reduceLanes(VectorOperators.ADD, vmask);\n+                r[i] = v;\n+                ra += v;\n@@ -3966,1 +4031,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3975,1 +4040,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -3987,8 +4052,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL);\n-            }\n-        }\n+        short ra = 0;\n@@ -3997,1 +4055,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4000,1 +4058,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL);\n+                short v = av.reduceLanes(VectorOperators.MUL);\n+                r[i] = v;\n+                ra *= v;\n@@ -4008,0 +4068,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MULReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MUL_IDENTITY;\n+\n+        Assert.assertEquals((short) (id * id), id,\n+                            \"MUL(MUL_IDENTITY, MUL_IDENTITY) != MUL_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) (id * x), x);\n+                Assert.assertEquals((short) (x * id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) (id * x), x,\n+                                \"MUL(MUL_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) (x * id), x,\n+                                \"MUL(\" + x + \", MUL_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4009,1 +4092,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4019,1 +4102,1 @@\n-        short res = 1;\n+        short res = MUL_IDENTITY;\n@@ -4033,8 +4116,1 @@\n-        short ra = 1;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4043,1 +4119,1 @@\n-            ra = 1;\n+            ra = MUL_IDENTITY;\n@@ -4046,1 +4122,3 @@\n-                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+                short v = av.reduceLanes(VectorOperators.MUL, vmask);\n+                r[i] = v;\n+                ra *= v;\n@@ -4055,1 +4133,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4064,1 +4142,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4076,8 +4154,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4086,1 +4157,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4089,1 +4160,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+                short v = av.reduceLanes(VectorOperators.MIN);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4097,0 +4170,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MIN_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.min(id, id), id,\n+                            \"MIN(MIN_IDENTITY, MIN_IDENTITY) != MIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.min(id, x), x);\n+                Assert.assertEquals((short) Math.min(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.min(id, x), x,\n+                                \"MIN(MIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.min(x, id), x,\n+                                \"MIN(\" + x + \", MIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4098,1 +4194,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4108,1 +4204,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = MIN_IDENTITY;\n@@ -4122,8 +4218,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4132,1 +4221,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = MIN_IDENTITY;\n@@ -4135,1 +4224,3 @@\n-                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.MIN, vmask);\n+                r[i] = v;\n+                ra = (short) Math.min(ra, v);\n@@ -4144,1 +4235,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4153,1 +4244,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4165,8 +4256,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4175,1 +4259,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4178,1 +4262,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+                short v = av.reduceLanes(VectorOperators.MAX);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4186,0 +4272,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = MAX_IDENTITY;\n+\n+        Assert.assertEquals((short) Math.max(id, id), id,\n+                            \"MAX(MAX_IDENTITY, MAX_IDENTITY) != MAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) Math.max(id, x), x);\n+                Assert.assertEquals((short) Math.max(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) Math.max(id, x), x,\n+                                \"MAX(MAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) Math.max(x, id), x,\n+                                \"MAX(\" + x + \", MAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4187,1 +4296,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4197,1 +4306,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = MAX_IDENTITY;\n@@ -4211,8 +4320,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4221,1 +4323,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = MAX_IDENTITY;\n@@ -4224,1 +4326,3 @@\n-                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.MAX, vmask);\n+                r[i] = v;\n+                ra = (short) Math.max(ra, v);\n@@ -4233,1 +4337,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4242,1 +4346,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4254,8 +4358,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN);\n-            }\n-        }\n+        short ra = 0;\n@@ -4264,1 +4361,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4267,1 +4364,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN));\n+                short v = av.reduceLanes(VectorOperators.UMIN);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4275,0 +4374,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMINReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMIN_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.minUnsigned(id, id), id,\n+                            \"UMIN(UMIN_IDENTITY, UMIN_IDENTITY) != UMIN_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.minUnsigned(id, x), x,\n+                                \"UMIN(UMIN_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.minUnsigned(x, id), x,\n+                                \"UMIN(\" + x + \", UMIN_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4276,1 +4398,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4286,1 +4408,1 @@\n-        short res = Short.MAX_VALUE;\n+        short res = UMIN_IDENTITY;\n@@ -4300,8 +4422,1 @@\n-        short ra = Short.MAX_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMIN, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4310,1 +4425,1 @@\n-            ra = Short.MAX_VALUE;\n+            ra = UMIN_IDENTITY;\n@@ -4313,1 +4428,3 @@\n-                ra = (short) VectorMath.minUnsigned(ra, av.reduceLanes(VectorOperators.UMIN, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMIN, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.minUnsigned(ra, v);\n@@ -4322,1 +4439,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4331,1 +4448,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4343,8 +4460,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX);\n-            }\n-        }\n+        short ra = 0;\n@@ -4353,1 +4463,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4356,1 +4466,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX));\n+                short v = av.reduceLanes(VectorOperators.UMAX);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4364,0 +4476,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void UMAXReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = UMAX_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.maxUnsigned(id, id), id,\n+                            \"UMAX(UMAX_IDENTITY, UMAX_IDENTITY) != UMAX_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(id, x), x,\n+                                \"UMAX(UMAX_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.maxUnsigned(x, id), x,\n+                                \"UMAX(\" + x + \", UMAX_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4365,1 +4500,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4375,1 +4510,1 @@\n-        short res = Short.MIN_VALUE;\n+        short res = UMAX_IDENTITY;\n@@ -4389,8 +4524,1 @@\n-        short ra = Short.MIN_VALUE;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.UMAX, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4399,1 +4527,1 @@\n-            ra = Short.MIN_VALUE;\n+            ra = UMAX_IDENTITY;\n@@ -4402,1 +4530,3 @@\n-                ra = (short) VectorMath.maxUnsigned(ra, av.reduceLanes(VectorOperators.UMAX, vmask));\n+                short v = av.reduceLanes(VectorOperators.UMAX, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.maxUnsigned(ra, v);\n@@ -4411,1 +4541,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4420,1 +4550,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4432,8 +4562,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n-            }\n-        }\n+        short ra = 0;\n@@ -4442,1 +4565,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4445,1 +4568,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4453,0 +4578,23 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void FIRST_NONZEROReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = FIRST_NONZERO_IDENTITY;\n+\n+        Assert.assertEquals(firstNonZero(id, id), id,\n+                            \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, FIRST_NONZERO_IDENTITY) != FIRST_NONZERO_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(firstNonZero(id, x), x);\n+                Assert.assertEquals(firstNonZero(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(firstNonZero(id, x), x,\n+                                \"FIRST_NONZERO(FIRST_NONZERO_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals(firstNonZero(x, id), x,\n+                                \"FIRST_NONZERO(\" + x + \", FIRST_NONZERO_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4454,1 +4602,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4464,1 +4612,1 @@\n-        short res = (short) 0;\n+        short res = FIRST_NONZERO_IDENTITY;\n@@ -4478,8 +4626,1 @@\n-        short ra = (short) 0;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n-            }\n-        }\n+        short ra = 0;\n@@ -4488,1 +4629,1 @@\n-            ra = (short) 0;\n+            ra = FIRST_NONZERO_IDENTITY;\n@@ -4491,1 +4632,3 @@\n-                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+                short v = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+                r[i] = v;\n+                ra = firstNonZero(ra, v);\n@@ -4548,1 +4691,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4557,1 +4700,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4572,0 +4715,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4574,9 +4718,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD));\n+                short v = av.reduceLanes(VectorOperators.SUADD);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n@@ -4590,0 +4728,23 @@\n+    @Test(dataProvider = \"shortSaturatingUnaryOpProvider\")\n+    static void SUADDReduceIdentityValueTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short id = SUADD_IDENTITY;\n+\n+        Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, id), id,\n+                            \"SUADD(SUADD_IDENTITY, SUADD_IDENTITY) != SUADD_IDENTITY\");\n+\n+        short x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x);\n+                Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(id, x), x,\n+                                \"SUADD(SUADD_IDENTITY, \" + x + \") != \" + x);\n+            Assert.assertEquals((short) VectorMath.addSaturatingUnsigned(x, id), x,\n+                                \"SUADD(\" + x + \", SUADD_IDENTITY) != \" + x);\n+        }\n+    }\n+\n@@ -4591,1 +4752,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4601,1 +4762,1 @@\n-        short res = 0;\n+        short res = SUADD_IDENTITY;\n@@ -4617,0 +4778,1 @@\n+            ra = SUADD_IDENTITY;\n@@ -4619,9 +4781,3 @@\n-                r[i] = av.reduceLanes(VectorOperators.SUADD, vmask);\n-            }\n-        }\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            ra = 0;\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                ra = (short) VectorMath.addSaturatingUnsigned(ra, av.reduceLanes(VectorOperators.SUADD, vmask));\n+                short v = av.reduceLanes(VectorOperators.SUADD, vmask);\n+                r[i] = v;\n+                ra = (short) VectorMath.addSaturatingUnsigned(ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":413,"deletions":257,"binary":false,"changes":670,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -514,10 +514,10 @@\n-gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n-gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n-gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n-gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n-gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n-gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"UMIN\" \"(\\$type\\$) VectorMath.minUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"UMAX\" \"(\\$type\\$) VectorMath.maxUnsigned\" \"BITWISE\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n+gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"AND_IDENTITY\"\n+gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"OR_IDENTITY\"\n+gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"XOR_IDENTITY\"\n+gen_reduction_op \"ADD\" \"+\" \"\" \"ADD_IDENTITY\"\n+gen_reduction_op \"MUL\" \"*\" \"\" \"MUL_IDENTITY\"\n+gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"MIN_IDENTITY\"\n+gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"MAX_IDENTITY\"\n+gen_reduction_op_func \"UMIN\" \"(\\$type\\$) VectorMath.minUnsigned\" \"BITWISE\" \"UMIN_IDENTITY\"\n+gen_reduction_op_func \"UMAX\" \"(\\$type\\$) VectorMath.maxUnsigned\" \"BITWISE\" \"UMAX_IDENTITY\"\n+gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"FIRST_NONZERO_IDENTITY\"\n@@ -530,1 +530,1 @@\n-gen_saturating_reduction_op \"SUADD\" \"(\\$type\\$) VectorMath.addSaturatingUnsigned\" \"BITWISE\" \"0\"\n+gen_saturating_reduction_op \"SUADD\" \"(\\$type\\$) VectorMath.addSaturatingUnsigned\" \"BITWISE\" \"SUADD_IDENTITY\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -5,8 +5,1 @@\n-        $type$ ra = [[TEST_INIT]];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n-            }\n-        }\n+        $type$ ra = 0;\n@@ -18,1 +11,3 @@\n-                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-Masked-op-func.template","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5,8 +5,1 @@\n-        $type$ ra = [[TEST_INIT]];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n-            }\n-        }\n+        $type$ ra = 0;\n@@ -18,1 +11,3 @@\n-                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                r[i] = v;\n+                ra [[TEST_OP]]= v;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-Masked-op.template","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,8 +3,1 @@\n-        $type$ ra = [[TEST_INIT]];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]]);\n-            }\n-        }\n+        $type$ ra = 0;\n@@ -16,1 +9,3 @@\n-                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]]));\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]]);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-op-func.template","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,8 +3,1 @@\n-        $type$ ra = [[TEST_INIT]];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]]);\n-            }\n-        }\n+        $type$ ra = 0;\n@@ -16,1 +9,3 @@\n-                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]]);\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]]);\n+                r[i] = v;\n+                ra [[TEST_OP]]= v;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Reduction-op.template","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5,8 +5,1 @@\n-        $type$ ra = [[TEST_INIT]];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n-            }\n-        }\n+        $type$ ra = 0;\n@@ -18,1 +11,3 @@\n-                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingReduction-Masked-op.template","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,8 +3,1 @@\n-        $type$ ra = [[TEST_INIT]];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                r[i] = av.reduceLanes(VectorOperators.[[TEST]]);\n-            }\n-        }\n+        $type$ ra = 0;\n@@ -16,1 +9,3 @@\n-                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]]));\n+                $type$ v = av.reduceLanes(VectorOperators.[[TEST]]);\n+                r[i] = v;\n+                ra = [[TEST_OP]](ra, v);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingReduction-op.template","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -8,0 +8,23 @@\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]ReduceIdentityValueTests(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ id = [[TEST_INIT]];\n+\n+        Assert.assertEquals([[TEST_OP]](id, id), id,\n+                            \"[[TEST]]([[TEST_INIT]], [[TEST_INIT]]) != [[TEST_INIT]]\");\n+\n+        $type$ x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals([[TEST_OP]](id, x), x);\n+                Assert.assertEquals([[TEST_OP]](x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals([[TEST_OP]](id, x), x,\n+                                \"[[TEST]]([[TEST_INIT]], \" + x + \") != \" + x);\n+            Assert.assertEquals([[TEST_OP]](x, id), x,\n+                                \"[[TEST]](\" + x + \", [[TEST_INIT]]) != \" + x);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-op-func.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -12,0 +12,23 @@\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]ReduceIdentityValueTests(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ id = [[TEST_INIT]];\n+\n+        Assert.assertEquals(($type$) (id [[TEST_OP]] id), id,\n+                            \"[[TEST]]([[TEST_INIT]], [[TEST_INIT]]) != [[TEST_INIT]]\");\n+\n+        $type$ x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals(($type$) (id [[TEST_OP]] x), x);\n+                Assert.assertEquals(($type$) (x [[TEST_OP]] id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(($type$) (id [[TEST_OP]] x), x,\n+                                \"[[TEST]]([[TEST_INIT]], \" + x + \") != \" + x);\n+            Assert.assertEquals(($type$) (x [[TEST_OP]] id), x,\n+                                \"[[TEST]](\" + x + \", [[TEST_INIT]]) != \" + x);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-op.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -8,0 +8,23 @@\n+\n+    @Test(dataProvider = \"$type$SaturatingUnaryOpProvider\")\n+    static void [[TEST]]ReduceIdentityValueTests(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ id = [[TEST_INIT]];\n+\n+        Assert.assertEquals([[TEST_OP]](id, id), id,\n+                            \"[[TEST]]([[TEST_INIT]], [[TEST_INIT]]) != [[TEST_INIT]]\");\n+\n+        $type$ x = 0;\n+        try {\n+            for (int i = 0; i < a.length; i++) {\n+                x = a[i];\n+                Assert.assertEquals([[TEST_OP]](id, x), x);\n+                Assert.assertEquals([[TEST_OP]](x, id), x);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals([[TEST_OP]](id, x), x,\n+                                \"[[TEST]]([[TEST_INIT]], \" + x + \") != \" + x);\n+            Assert.assertEquals([[TEST_OP]](x, id), x,\n+                                \"[[TEST]](\" + x + \", [[TEST_INIT]]) != \" + x);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingReduction-op.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,0 @@\n-\n@@ -91,0 +90,1 @@\n+\n@@ -97,1 +97,0 @@\n-\n@@ -99,0 +98,1 @@\n+\n@@ -101,0 +101,17 @@\n+\n+    \/\/ Identity values for reduction operations\n+    private static final $type$ ADD_IDENTITY = ($type$)0;\n+#if[BITWISE]\n+    private static final $type$ AND_IDENTITY = ($type$)-1;\n+#end[BITWISE]\n+    private static final $type$ FIRST_NONZERO_IDENTITY = ($type$)0;\n+    private static final $type$ MAX_IDENTITY = $Wideboxtype$.$MinValue$;\n+    private static final $type$ MIN_IDENTITY = $Wideboxtype$.$MaxValue$;\n+    private static final $type$ MUL_IDENTITY = ($type$)1;\n+#if[BITWISE]\n+    private static final $type$ OR_IDENTITY = ($type$)0;\n+    private static final $type$ SUADD_IDENTITY = ($type$)0;\n+    private static final $type$ UMAX_IDENTITY = ($type$)0;   \/\/ Minimum unsigned value\n+    private static final $type$ UMIN_IDENTITY = ($type$)-1;  \/\/ Maximum unsigned value\n+    private static final $type$ XOR_IDENTITY = ($type$)0;\n+#end[BITWISE]\n@@ -102,0 +119,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires test.thread.factory == null\n","filename":"test\/jdk\/jdk\/internal\/misc\/VM\/RuntimeArguments.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,2 +101,2 @@\n-                    Asserts.assertEquals(\"VM Error\", shutdownReason.get());\n-                    Asserts.assertEquals(\"Out of Memory\", dumpReason.get());\n+                    Asserts.assertEquals(\"CrashOnOutOfMemoryError\", shutdownReason.get());\n+                    Asserts.assertEquals(\"CrashOnOutOfMemoryError\", dumpReason.get());\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.jfr.consumer.EventStream;\n@@ -38,1 +39,1 @@\n-import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.TestClassLoader;\n@@ -55,0 +56,1 @@\n+    public static Object OBJECT;\n@@ -57,4 +59,4 @@\n-        Set<Instant> threadDumps = Collections.synchronizedSet(new LinkedHashSet<>());\n-        Set<Instant> classLoaderStatistics = Collections.synchronizedSet(new LinkedHashSet<>());\n-        Set<Instant> physicalMemory = Collections.synchronizedSet(new LinkedHashSet<>());\n-\n+        TestClassLoader loader = new TestClassLoader();\n+        Class<?> clazz = loader.loadClass(TestBackToBackSensitive.class.getName());\n+        String classLoaderName = loader.getClass().getName();\n+        OBJECT = clazz.getDeclaredConstructor().newInstance();\n@@ -62,13 +64,1 @@\n-        try (RecordingStream r1 = new RecordingStream(configuration)) {\n-            r1.setMaxSize(Long.MAX_VALUE);\n-            r1.onEvent(\"jdk.ThreadDump\", e -> threadDumps.add(e.getStartTime()));\n-            r1.onEvent(\"jdk.ClassLoaderStatistics\", e -> {\n-                RecordedClassLoader cl = e.getValue(\"classLoader\");\n-                if (cl != null) {\n-                    if (cl.getType().getName().contains(\"PlatformClassLoader\")) {\n-                        classLoaderStatistics.add(e.getStartTime());\n-                        System.out.println(\"Class loader\" + e);\n-                    }\n-                }\n-            });\n-            r1.onEvent(\"jdk.PhysicalMemory\", e -> physicalMemory.add(e.getStartTime()));\n+        try (Recording r1 = new Recording(configuration)) {\n@@ -76,1 +66,1 @@\n-            r1.startAsync();\n+            r1.start();\n@@ -89,0 +79,19 @@\n+            Path file = Path.of(\"file.jfr\");\n+            r1.dump(file);\n+            Set<Instant> threadDumps = new LinkedHashSet<>();\n+            Set<Instant> classLoaderStatistics = new LinkedHashSet<>();\n+            Set<Instant> physicalMemory = new LinkedHashSet<>();\n+            try (EventStream es = EventStream.openFile(file)) {\n+                es.onEvent(\"jdk.ThreadDump\", e -> threadDumps.add(e.getStartTime()));\n+                es.onEvent(\"jdk.ClassLoaderStatistics\", e -> {\n+                    RecordedClassLoader cl = e.getValue(\"classLoader\");\n+                    if (cl != null) {\n+                        if (cl.getType().getName().equals(classLoaderName)) {\n+                            classLoaderStatistics.add(e.getStartTime());\n+                            System.out.println(\"Class loader\" + e);\n+                        }\n+                    }\n+                });\n+                es.onEvent(\"jdk.PhysicalMemory\", e -> physicalMemory.add(e.getStartTime()));\n+                es.start();\n+            }\n@@ -96,1 +105,1 @@\n-            assertCount(r1, \"jdk.PhysicalMemory\", physicalMemory, 2 * chunkFiles);\n+            assertCount(\"jdk.PhysicalMemory\", physicalMemory, 2 * chunkFiles);\n@@ -103,2 +112,2 @@\n-            assertCount(r1, \"jdk.ThreadDump\", threadDumps, 2 + 2 + (chunkFiles - 2));\n-            assertCount(r1, \"jdk.ClassLoaderStatistics\", classLoaderStatistics, 2 + 2 + (chunkFiles - 2));\n+            assertCount(\"jdk.ThreadDump\", threadDumps, 2 + 2 + (chunkFiles - 2));\n+            assertCount(\"jdk.ClassLoaderStatistics\", classLoaderStatistics, 2 + 2 + (chunkFiles - 2));\n@@ -113,1 +122,1 @@\n-    private static void assertCount(RecordingStream stream, String eventName, Set<Instant> timestamps, long expected) throws Exception {\n+    private static void assertCount(String eventName, Set<Instant> timestamps, long expected) throws Exception {\n@@ -120,2 +129,0 @@\n-            System.out.println(\"Dumping failure file.\");\n-            stream.dump(Path.of(\"failure.jfr\"));\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestBackToBackSensitive.java","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that constructors are instrumented correctly.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=debug\n+ *      jdk.jfr.event.tracing.TestConstructors\n+ **\/\n+public class TestConstructors {\n+    static private void methodThatThrows() {\n+        throw new RuntimeException();\n+    }\n+\n+    public static class Cat {\n+        Cat() {\n+            new String();\n+            methodThatThrows();\n+            super();\n+            methodThatThrows();\n+        }\n+    }\n+\n+    public static class Dog {\n+        Dog() {\n+            super();\n+            methodThatThrows();\n+        }\n+    }\n+\n+    public static class Tiger {\n+        Tiger() {\n+            methodThatThrows();\n+            super();\n+        }\n+    }\n+\n+    public static class Zebra {\n+        Zebra(boolean shouldThrow) {\n+            this(shouldThrow ? 1 : 0);\n+        }\n+\n+        Zebra(int shouldThrow) {\n+            if (shouldThrow == 1) {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+\n+    public static class Snake {\n+        Snake() {\n+            try {\n+                throw new RuntimeException();\n+            } catch (Exception e) {\n+                \/\/ Ignore\n+            }\n+            super();\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.MethodTrace\").with(\"filter\", Dog.class.getName() + \";\" + Cat.class.getName() + \";\" + Tiger.class.getName() + \";\" + Zebra.class.getName() + \";\" + Snake.class.getName());\n+            r.start();\n+            try {\n+                new Cat();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Dog();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Tiger();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Zebra(true);\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Zebra(false);\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            try {\n+                new Snake();\n+            } catch (Exception e) {\n+                \/\/ ignore\n+            }\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            var methods = buildMethodMap(events);\n+            if (methods.size() != 5) {\n+                throw new Exception(\"Expected 5 different methods\");\n+            }\n+            assertMethodCount(methods, \"Cat\", 1);\n+            assertMethodCount(methods, \"Dog\", 1);\n+            assertMethodCount(methods, \"Snake\", 1);\n+            assertMethodCount(methods, \"Tiger\", 1);\n+            assertMethodCount(methods, \"Zebra\", 3);\n+        }\n+    }\n+\n+    private static void assertMethodCount(Map<String, Long> methods, String className, int expectedCount) throws Exception {\n+        String name = TestConstructors.class.getName() + \"$\" + className + \"::<init>\";\n+        Long count = methods.get(name);\n+        if (count == null) {\n+            throw new Exception(\"Could not find traced method \" + name);\n+        }\n+        if (count != expectedCount) {\n+            throw new Exception(\"Expected \" + expectedCount + \" trace event for \" + name);\n+        }\n+    }\n+\n+    private static Map<String, Long> buildMethodMap(List<RecordedEvent> events) {\n+        Map<String, Long> map = new TreeMap<>();\n+        for (RecordedEvent e : events) {\n+            RecordedMethod m = e.getValue(\"method\");\n+            String name = m.getType().getName() + \"::\" + m.getName();\n+            map.compute(name, (_, value) -> (value == null) ? 1 : value + 1);\n+        }\n+        for (var e : map.entrySet()) {\n+            System.out.println(e.getKey() + \" \" + e.getValue());\n+        }\n+        return map;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestConstructors.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -96,0 +96,2 @@\n+        assertMethod(map, \"deepException\", 1);\n+        assertMethod(map, \"whileTrue\", 1);\n@@ -108,0 +110,2 @@\n+        assertMethod(map, \"deepException\", 1);\n+        assertMethod(map, \"whileTrue\", 1);\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestInstrumentation.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374377\n+ * @summary This test confirms the PNGImageProducer decodes 8-bit interlaced\n+ * and non-interlaced PNGs correctly.\n+ *\/\n+\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.ImageOutputStream;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+\/**\n+ * The proposed change for 8374377 affects how 8-bit PNGs are decoded.\n+ * So this test confirms that 8-bit PNGs (both interlaced and non-interlaced)\n+ * are still decoded by the PNGImageDecoder so they match what ImageIO decodes.\n+ *\n+ * This test has never failed.\n+ *\/\n+public class PngImageDecoder8BitTest {\n+\n+    static BufferedImage createBufferedImage(Image img)\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n+        img.getSource().startProduction(new ImageConsumer() {\n+            private int imageWidth, imageHeight;\n+            private BufferedImage bi;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                imageWidth = width;\n+                imageHeight = height;\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setHints(int hintflags) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  byte[] pixels, int off, int scansize) {\n+                if (bi == null) {\n+                    bi = new BufferedImage(imageWidth, imageHeight,\n+                            BufferedImage.TYPE_BYTE_INDEXED,\n+                            (IndexColorModel) model);\n+                }\n+\n+                if (w == imageWidth && h == imageHeight) {\n+                    \/\/ this is how interlaced PNGs are decoded:\n+                    bi.getRaster().setDataElements(0, 0,\n+                            imageWidth, imageHeight, pixels);\n+                    return;\n+                }\n+\n+                if (h != 1) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires h = 1\");\n+                }\n+                if (off != 0) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires off = 0\");\n+                }\n+\n+                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  int[] pixels, int off, int scansize) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                future.complete(bi);\n+            }\n+        });\n+        return future.get();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BufferedImage expected = createImageData();\n+        for (boolean interlace : new boolean[] { false, true} ) {\n+            System.out.println(\"Testing interlacing = \"+ interlace);\n+            byte[] imageData = encodePNG(expected, interlace);\n+\n+            Image i = Toolkit.getDefaultToolkit().createImage(imageData);\n+            BufferedImage actual = createBufferedImage(i);\n+\n+            testCorrectness(expected, actual);\n+        }\n+        System.out.println(\"Confirmed that 8-bit PNGs decode correctly \" +\n+                \"whether we use interlacing or not.\");\n+    }\n+\n+    \/**\n+     * Create a large sample image stored as an 8-bit PNG.\n+     *\/\n+    private static BufferedImage createImageData() {\n+        BufferedImage bi = new BufferedImage(6000, 6000,\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        Random r = new Random(0);\n+        Graphics2D g = bi.createGraphics();\n+        for (int a = 0; a < 20000; a++) {\n+            g.setColor(new Color(r.nextInt(0xffffff)));\n+            int radius = 10 + r.nextInt(90);\n+            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n+                    radius, radius);\n+        }\n+        g.dispose();\n+        return bi;\n+    }\n+\n+    \/**\n+     * Encode an image as 8-bit PNG.\n+     *\/\n+    private static byte[] encodePNG(BufferedImage bi, boolean interlace)\n+            throws IOException {\n+        Iterator<ImageWriter> writers =\n+                ImageIO.getImageWritersByFormatName(\"png\");\n+        if (!writers.hasNext()) {\n+            throw new IllegalStateException(\"No PNG writers found\");\n+        }\n+        ImageWriter writer = writers.next();\n+\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        if (interlace) {\n+            param.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);\n+        }\n+\n+        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+             ImageOutputStream imageOut =\n+                     ImageIO.createImageOutputStream(byteOut)) {\n+            writer.setOutput(imageOut);\n+            writer.write(null, new IIOImage(bi, null, null), param);\n+            return byteOut.toByteArray();\n+        } finally {\n+            writer.dispose();\n+        }\n+    }\n+\n+    \/**\n+     * This throws an Error if the two images are not identical.\n+     * <p>\n+     * This unit test is intended to accompany a performance enhancement for\n+     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n+     * any accuracy.\n+     *\/\n+    private static void testCorrectness(BufferedImage expected,\n+                                        BufferedImage actual) {\n+        if (expected.getWidth() != actual.getWidth()) {\n+            throw new RuntimeException(\"expected.getWidth() = \" +\n+                    expected.getWidth() + \", actual.getWidth() = \" +\n+                    actual.getWidth());\n+        }\n+        if (expected.getHeight() != actual.getHeight()) {\n+            throw new RuntimeException(\"expected.getHeight() = \" +\n+                    expected.getHeight() + \", actual.getHeight() = \" +\n+                    actual.getHeight());\n+        }\n+        for (int y = 0; y < expected.getHeight(); y++) {\n+            for (int x = 0; x < expected.getWidth(); x++) {\n+                int argb1 = expected.getRGB(x, y);\n+                int argb2 = actual.getRGB(x, y);\n+                if (argb1 != argb2) {\n+                    throw new RuntimeException(\"x = \" + x + \", y = \" + y +\n+                            \" argb1 = \" + Integer.toUnsignedString(argb1, 16) +\n+                            \" argb2 = \" + Integer.toUnsignedString(argb2, 16));\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/png\/PngImageDecoder8BitTest.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        SSLContext ctx = new SimpleSSLContext().get();\n+        SSLContext ctx = SimpleSSLContext.findSSLContext();\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/RedirectOnPost.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,1 +252,1 @@\n-        AffinePoint publicKeyPoint = ECDSAOperations.toAffinePoint(publicKey,\n+        AffinePoint publicKeyPoint = AffinePoint.fromECPoint(publicKey,\n","filename":"test\/jdk\/sun\/security\/ec\/ECDSAPrimitive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,1 @@\n-                new HttpsConfigurator(new SimpleSSLContext().get()));\n+                new HttpsConfigurator(SimpleSSLContext.findSSLContext()));\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/HttpsCB.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.File;\n+import java.security.Security;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+\n+\/*\n+ * @test\n+ * @bug 8369282\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Chunghwa root are invalid\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Chunghwa after policyOn invalid\n+ * @run main\/othervm Chunghwa after policyOff valid\n+ * @run main\/othervm Chunghwa before policyOn valid\n+ * @run main\/othervm Chunghwa before policyOff valid\n+ *\/\n+\n+public class Chunghwa {\n+\n+    private static final String CERT_PATH = \"chains\" + File.separator + \"chunghwa\";\n+\n+    \/\/ The ePKI root has a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static final String ROOT_TO_TEST = \"chunghwaepkirootca\";\n+\n+    \/\/ Date after the restrictions take effect\n+    private static final ZonedDateTime DISTRUST_DATE =\n+            LocalDate.of(2026, 03, 18).atStartOfDay(ZoneOffset.UTC);\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        Distrust distrust = new Distrust(args);\n+\n+        X509TrustManager[] tms = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", null),\n+                distrust.getTMF(\"SunX509\", null)\n+        };\n+\n+        Date notBefore = distrust.getNotBefore(DISTRUST_DATE);\n+        distrust.testCertificateChain(CERT_PATH, notBefore, tms, ROOT_TO_TEST);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Chunghwa.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+Owner:   CN=HiPKI Root CA - G1,\n+         O=\"Chunghwa Telecom Co., Ltd.\", C=TW\n+Issuer:  OU=ePKI Root Certification Authority,\n+         O=\"Chunghwa Telecom Co., Ltd.\", C=TW\n+Serial number: 23fba648360e15e92ba78aedb67a0ae5\n+Valid from: Wed Dec 20 19:11:23 MST 2023 until: Tue Dec 19 08:59:59 MST 2034\n+Certificate fingerprints:\n+\t SHA1: 87:F1:DD:3B:8E:F1:E0:8C:A8:CA:CB:9B:CE:4E:26:5A:E4:4E:05:F2\n+\t SHA256: 68:07:C9:72:35:C5:EC:60:90:26:9A:4B:5F:ED:FA:B4:69:86:E4:2F:4D:67:D2:ED:DD:CF:6E:45:CF:0D:FA:80\n+Signature algorithm name: SHA256withRSA\n+Subject Public Key Algorithm: 4096-bit RSA key\n+Version: 3\n+\n+-----BEGIN CERTIFICATE-----\n+MIIGjDCCBHSgAwIBAgIQI\/umSDYOFekrp4rttnoK5TANBgkqhkiG9w0BAQsFADBe\n+MQswCQYDVQQGEwJUVzEjMCEGA1UECgwaQ2h1bmdod2EgVGVsZWNvbSBDby4sIEx0\n+ZC4xKjAoBgNVBAsMIWVQS0kgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAe\n+Fw0yMzEyMjEwMjExMjNaFw0zNDEyMTkxNTU5NTlaME8xCzAJBgNVBAYTAlRXMSMw\n+IQYDVQQKDBpDaHVuZ2h3YSBUZWxlY29tIENvLiwgTHRkLjEbMBkGA1UEAwwSSGlQ\n+S0kgUm9vdCBDQSAtIEcxMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA\n+9B5\/UnMyDHPkvRN0o9QwqNCuS9i233VHZvR85zkEHmpwINJaR3JnVfSl6J3VHiGh\n+8Ge6zCFovkRTv4354twvVcg3Px+kwJyz5HdcoEb+d\/oaoDjq7Zpy3iu9lFc6uux5\n+5199QmQ5eiY29yTw1S+6lZgRZq2XNdZ1AYDgr\/SEYYwNHl98h5ZeQa\/rh+r4XfEu\n+iAU+TCK72h8q3VJGZDnzQs7ZngyzsHeXZJzA9KMuH5UHsBffMNsAGJZMoYFL3QRt\n+U6M9\/Aes1MU3guvklQgZKILSQjqj2FPseYlgSGDIcpJQ3AOPgz+yQlda22rpEZfd\n+hSi8MEyr48KxRURHH+CKFgeW0iEPU8DtqX7UTuybCeyvQqww1r\/REEXgphaypcXT\n+T3OUM3ECoWqj1jOXTyFjHluP2cFeRXF3D4FdXyGarYPM+l7WjSNfGz1BryB1ZlpK\n+9p\/7qxj3ccC2HTHsOyDry+K49a6SsvfhhEvyovKTmiKe0xRvNlS9H15ZFblzqMF8\n+b3ti6RZsR1pl8w4Rm0bZ\/W3c1pzAtH2lsN0\/Vm+h+fbkEkj9Bn8SV7apI09bA8Pg\n+cSojt\/ewsTu8mL3WmKgMa\/aOEmem8rJY5AIJEzypuxC00jBF8ez3ABHfZfjcK0NV\n+vxaXxA\/VLGGEqnKG\/uY6fsI\/fe78LxQ+5oXdUG+3Se0CAwEAAaOCAVMwggFPMB8G\n+A1UdIwQYMBaAFB4M97Zn8uGSJglFwFU5Lnc\/QkqiMB0GA1UdDgQWBBTydxf6Xqj+\n+9j1x1Wi6yUYMONivsDAOBgNVHQ8BAf8EBAMCAYYwQAYDVR0fBDkwNzA1oDOgMYYv\n+aHR0cDovL2VjYS5oaW5ldC5uZXQvcmVwb3NpdG9yeS9DUkxfU0hBMi9DQS5jcmww\n+gYIGCCsGAQUFBwEBBHYwdDA7BggrBgEFBQcwAoYvaHR0cDovL2VjYS5oaW5ldC5u\n+ZXQvcmVwb3NpdG9yeS9DZXJ0cy9lQ0FHMS5jcnQwNQYIKwYBBQUHMAGGKWh0dHA6\n+Ly9vY3NwLmVjYS5oaW5ldC5uZXQvT0NTUC9vY3NwRzFzaGEyMBIGA1UdEwEB\/wQI\n+MAYBAf8CAQEwIgYDVR0gBBswGTAIBgZngQwBAgIwDQYLKwYBBAGBtyNkAAMwDQYJ\n+KoZIhvcNAQELBQADggIBACY9pps8fqk3p8Xqv\/qr26I1aFA4jOEG3VWd2bqn68Y9\n+InOMZozTMVh7iOnOfat7mEqn\/RNhikvR5MOV3qAeg4gwgNb1OMuGltwfXWGiuGeT\n+vhimsV6E2hhJFAmZyXtfuoV9vSrnr1a5pCWqhVYWSCvoAQ\/8Kv0tATKbIe21CYXz\n+NIo7O9QBSXt0BiaP9+CVQtJAYYuy2MNAcXgzgL4rownrYYAixhPmkxQE0Dt1gVbW\n+s2htBLJGse0z1fJDblY0Zar4t2ly+kIScx5DhRrrd8XKMK0YvID9Ythb+ao8m7Wd\n+Kymqr36benGL3GsvmSypLPlqZtfEqVITFhXwQiL8ruxoL+3WfNQJ09x0iV4xaP+E\n+bZSLLVzIiyhU49YdFHaqKyAJQvzgF2Za3DOwQWlP7OngtUx0ScEGHsoo78AM+Y0T\n+eLFxmr82kuyH18wZkUT9bLZlot11P2aC8VTprBGr+jEAMJjpmEjSA83ja\/ttmqgh\n+qjj29Jnw3Lgy91XIhzBFMxMYo+hhYeBRmBFWl5+Y5oxBgPVLZpDJvg2rKa8xdqim\n+KgvF0DMKHntE0hhVy7JfUCnKovNQ0pf0NodLfjpqcCS2GBZ1mNcsW2MG2uBPANcn\n+LRXmt7N4XX11mctQTADwt8yZZ+2HDrST4kghOz+FXgftrPBdtDtM0T6WJcHWR1uS\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/chunghwa\/chunghwaepkirootca-chain.pem","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -1,401 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.test;\n-\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toSet;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.io.UncheckedIOException;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.function.Consumer;\n-import java.util.spi.ToolProvider;\n-import java.util.stream.Stream;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-public class ExecutorTest extends JUnitAdapter {\n-\n-    private record Command(List<String> stdout, List<String> stderr) {\n-        Command {\n-            stdout.forEach(Objects::requireNonNull);\n-            stderr.forEach(Objects::requireNonNull);\n-        }\n-\n-        List<String> asExecutable() {\n-            final List<String> commandline = new ArrayList<>();\n-            if (TKit.isWindows()) {\n-                commandline.addAll(List.of(\"cmd\", \"\/C\"));\n-            } else {\n-                commandline.addAll(List.of(\"sh\", \"-c\"));\n-            }\n-            commandline.add(Stream.concat(createEchoCommands(stdout),\n-                    createEchoCommands(stderr).map(v -> v + \">&2\")).collect(joining(\" && \")));\n-            return commandline;\n-        }\n-\n-        private static Stream<String> createEchoCommands(List<String> lines) {\n-            return lines.stream().map(line -> {\n-                if (TKit.isWindows()) {\n-                    return \"(echo \" + line + \")\";\n-                } else {\n-                    return \"echo \" + line;\n-                }\n-            });\n-        }\n-\n-        ToolProvider asToolProvider() {\n-            return new ToolProvider() {\n-\n-                @Override\n-                public int run(PrintWriter out, PrintWriter err, String... args) {\n-                    stdout.forEach(out::println);\n-                    stderr.forEach(err::println);\n-                    return 0;\n-                }\n-\n-                @Override\n-                public String name() {\n-                    return \"test\";\n-                }\n-            };\n-        }\n-    }\n-\n-    private enum OutputData {\n-        EMPTY(List.of()),\n-        ONE_LINE(List.of(\"Jupiter\")),\n-        MANY(List.of(\"Uranus\", \"Saturn\", \"Earth\"));\n-\n-        OutputData(List<String> data) {\n-            data.forEach(Objects::requireNonNull);\n-            this.data = data;\n-        }\n-\n-        final List<String> data;\n-    }\n-\n-    private record CommandSpec(OutputData stdout, OutputData stderr) {\n-        CommandSpec {\n-            Objects.requireNonNull(stdout);\n-            Objects.requireNonNull(stderr);\n-        }\n-\n-        Command command() {\n-            return new Command(stdout.data.stream().map(line -> {\n-                return \"stdout.\" + line;\n-            }).toList(), stderr.data.stream().map(line -> {\n-                return \"stderr.\" + line;\n-            }).toList());\n-        }\n-    }\n-\n-    public enum OutputControl {\n-        DUMP(Executor::dumpOutput),\n-        SAVE_ALL(Executor::saveOutput),\n-        SAVE_FIRST_LINE(Executor::saveFirstLineOfOutput),\n-        DISCARD_STDOUT(Executor::discardStdout),\n-        DISCARD_STDERR(Executor::discardStderr),\n-        ;\n-\n-        OutputControl(Consumer<Executor> configureExector) {\n-            this.configureExector = Objects.requireNonNull(configureExector);\n-        }\n-\n-        Executor applyTo(Executor exec) {\n-            configureExector.accept(exec);\n-            return exec;\n-        }\n-\n-        static List<Set<OutputControl>> variants() {\n-            final List<Set<OutputControl>> variants = new ArrayList<>();\n-            for (final var withDump : BOOLEAN_VALUES) {\n-                variants.addAll(Stream.of(\n-                        Set.<OutputControl>of(),\n-                        Set.of(SAVE_ALL),\n-                        Set.of(SAVE_FIRST_LINE),\n-                        Set.of(DISCARD_STDOUT),\n-                        Set.of(DISCARD_STDERR),\n-                        Set.of(SAVE_ALL, DISCARD_STDOUT),\n-                        Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT),\n-                        Set.of(SAVE_ALL, DISCARD_STDERR),\n-                        Set.of(SAVE_FIRST_LINE, DISCARD_STDERR),\n-                        Set.of(SAVE_ALL, DISCARD_STDOUT, DISCARD_STDERR),\n-                        Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT, DISCARD_STDERR)\n-                ).map(v -> {\n-                    if (withDump) {\n-                        return Stream.concat(Stream.of(DUMP), v.stream()).collect(toSet());\n-                    } else {\n-                        return v;\n-                    }\n-                }).toList());\n-            }\n-            return variants.stream().map(options -> {\n-                return options.stream().filter(o -> {\n-                    return o.configureExector != NOP;\n-                }).collect(toSet());\n-            }).distinct().toList();\n-        }\n-\n-        private final Consumer<Executor> configureExector;\n-\n-        static final Set<OutputControl> SAVE = Set.of(SAVE_ALL, SAVE_FIRST_LINE);\n-    }\n-\n-    public record OutputTestSpec(boolean toolProvider, Set<OutputControl> outputControl, CommandSpec commandSpec) {\n-        public OutputTestSpec {\n-            outputControl.forEach(Objects::requireNonNull);\n-            if (outputControl.containsAll(OutputControl.SAVE)) {\n-                throw new IllegalArgumentException();\n-            }\n-            Objects.requireNonNull(commandSpec);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            final List<String> tokens = new ArrayList<>();\n-\n-            if (toolProvider) {\n-                tokens.add(\"tool-provider\");\n-            }\n-\n-            tokens.add(\"output=\" + format(outputControl));\n-            tokens.add(\"command=\" + commandSpec);\n-\n-            return String.join(\",\", tokens.toArray(String[]::new));\n-        }\n-\n-        void test() {\n-            final var command = commandSpec.command();\n-            final var commandWithDiscardedStreams = discardStreams(command);\n-\n-            final Executor.Result[] result = new Executor.Result[1];\n-            final var outputCapture = OutputCapture.captureOutput(() -> {\n-                result[0] = createExecutor(command).executeWithoutExitCodeCheck();\n-            });\n-\n-            assertEquals(0, result[0].getExitCode());\n-\n-            \/\/ If we dump the subprocesses's output, and the command produced both STDOUT and STDERR,\n-            \/\/ then the captured STDOUT may contain interleaved command's STDOUT and STDERR,\n-            \/\/ not in sequential order (STDOUT followed by STDERR).\n-            \/\/ In this case don't check the contents of the captured command's STDOUT.\n-            if (toolProvider || outputCapture.outLines().isEmpty() || (command.stdout().isEmpty() || command.stderr().isEmpty())) {\n-                assertEquals(expectedCapturedSystemOut(commandWithDiscardedStreams), outputCapture.outLines());\n-            }\n-            assertEquals(expectedCapturedSystemErr(commandWithDiscardedStreams), outputCapture.errLines());\n-\n-            assertEquals(expectedResultStdout(commandWithDiscardedStreams), result[0].stdout().getOutput());\n-            assertEquals(expectedResultStderr(commandWithDiscardedStreams), result[0].stderr().getOutput());\n-\n-            if (!saveOutput()) {\n-                assertNull(result[0].getOutput());\n-            } else {\n-                assertNotNull(result[0].getOutput());\n-                final var allExpectedOutput = expectedCommandOutput(command);\n-                assertEquals(allExpectedOutput.isEmpty(), result[0].getOutput().isEmpty());\n-                if (!allExpectedOutput.isEmpty()) {\n-                    if (outputControl.contains(OutputControl.SAVE_ALL)) {\n-                        assertEquals(allExpectedOutput, result[0].getOutput());\n-                    } else if (outputControl.contains(OutputControl.SAVE_FIRST_LINE)) {\n-                        assertEquals(1, result[0].getOutput().size());\n-                        assertEquals(allExpectedOutput.getFirst(), result[0].getFirstLineOfOutput());\n-                    } else {\n-                        throw new UnsupportedOperationException();\n-                    }\n-                }\n-            }\n-        }\n-\n-        private boolean dumpOutput() {\n-            return outputControl.contains(OutputControl.DUMP);\n-        }\n-\n-        private boolean saveOutput() {\n-            return !Collections.disjoint(outputControl, OutputControl.SAVE);\n-        }\n-\n-        private boolean discardStdout() {\n-            return outputControl.contains(OutputControl.DISCARD_STDOUT);\n-        }\n-\n-        private boolean discardStderr() {\n-            return outputControl.contains(OutputControl.DISCARD_STDERR);\n-        }\n-\n-        private static String format(Set<OutputControl> outputControl) {\n-            return outputControl.stream().map(OutputControl::name).sorted().collect(joining(\"+\"));\n-        }\n-\n-        private List<String> expectedCapturedSystemOut(Command command) {\n-            if (!dumpOutput() || (!toolProvider && !saveOutput())) {\n-                return List.of();\n-            } else if(saveOutput()) {\n-                return Stream.concat(command.stdout().stream(), command.stderr().stream()).toList();\n-            } else {\n-                return command.stdout();\n-            }\n-        }\n-\n-        private List<String> expectedCapturedSystemErr(Command command) {\n-            if (!dumpOutput() || (!toolProvider && !saveOutput())) {\n-                return List.of();\n-            } else if(saveOutput()) {\n-                return List.of();\n-            } else {\n-                return command.stderr();\n-            }\n-        }\n-\n-        private List<String> expectedResultStdout(Command command) {\n-            return expectedResultStream(command.stdout());\n-        }\n-\n-        private List<String> expectedResultStderr(Command command) {\n-            if (outputControl.contains(OutputControl.SAVE_FIRST_LINE) && !command.stdout().isEmpty()) {\n-                return List.of();\n-            }\n-            return expectedResultStream(command.stderr());\n-        }\n-\n-        private List<String> expectedResultStream(List<String> commandOutput) {\n-            Objects.requireNonNull(commandOutput);\n-            if (outputControl.contains(OutputControl.SAVE_ALL)) {\n-                return commandOutput;\n-            } else if (outputControl.contains(OutputControl.SAVE_FIRST_LINE)) {\n-                return commandOutput.stream().findFirst().map(List::of).orElseGet(List::of);\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        private Command discardStreams(Command command) {\n-            return new Command(discardStdout() ? List.of() : command.stdout(), discardStderr() ? List.of() : command.stderr());\n-        }\n-\n-        private record OutputCapture(byte[] out, byte[] err, Charset outCharset, Charset errCharset) {\n-            OutputCapture {\n-                Objects.requireNonNull(out);\n-                Objects.requireNonNull(err);\n-                Objects.requireNonNull(outCharset);\n-                Objects.requireNonNull(errCharset);\n-            }\n-\n-            List<String> outLines() {\n-                return toLines(out, outCharset);\n-            }\n-\n-            List<String> errLines() {\n-                return toLines(err, errCharset);\n-            }\n-\n-            private static List<String> toLines(byte[] buf, Charset charset) {\n-                try (var reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(buf), charset))) {\n-                    return reader.lines().filter(line -> {\n-                        return !line.contains(\"TRACE\");\n-                    }).toList();\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n-                }\n-            }\n-\n-            static OutputCapture captureOutput(Runnable runnable) {\n-                final var captureOut = new ByteArrayOutputStream();\n-                final var captureErr = new ByteArrayOutputStream();\n-\n-                final var out = System.out;\n-                final var err = System.err;\n-                try {\n-                    final var outCharset = System.out.charset();\n-                    final var errCharset = System.err.charset();\n-                    System.setOut(new PrintStream(captureOut, true, outCharset));\n-                    System.setErr(new PrintStream(captureErr, true, errCharset));\n-                    runnable.run();\n-                    return new OutputCapture(captureOut.toByteArray(), captureErr.toByteArray(), outCharset, errCharset);\n-                } finally {\n-                    try {\n-                        System.setOut(out);\n-                    } finally {\n-                        System.setErr(err);\n-                    }\n-                }\n-            }\n-        }\n-\n-        private List<String> expectedCommandOutput(Command command) {\n-            command = discardStreams(command);\n-            return Stream.of(command.stdout(), command.stderr()).flatMap(List::stream).toList();\n-        }\n-\n-        private Executor createExecutor(Command command) {\n-            final Executor exec;\n-            if (toolProvider) {\n-                exec = Executor.of(command.asToolProvider());\n-            } else {\n-                exec = Executor.of(command.asExecutable());\n-            }\n-\n-            outputControl.forEach(control -> control.applyTo(exec));\n-\n-            return exec;\n-        }\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testSavedOutput(OutputTestSpec spec) {\n-        spec.test();\n-    }\n-\n-    public static List<OutputTestSpec> testSavedOutput() {\n-        List<OutputTestSpec> testCases = new ArrayList<>();\n-        for (final var toolProvider : BOOLEAN_VALUES) {\n-            for (final var outputControl : OutputControl.variants()) {\n-                for (final var stdoutContent : List.of(OutputData.values())) {\n-                    for (final var stderrContent : List.of(OutputData.values())) {\n-                        final var commandSpec = new CommandSpec(stdoutContent, stderrContent);\n-                        testCases.add(new OutputTestSpec(toolProvider, outputControl, commandSpec));\n-                    }\n-                }\n-            }\n-        }\n-        return testCases;\n-    }\n-\n-    private static final List<Boolean> BOOLEAN_VALUES = List.of(Boolean.TRUE, Boolean.FALSE);\n-    private static final Consumer<Executor> NOP = exec -> {};\n-}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ExecutorTest.java","additions":0,"deletions":401,"binary":false,"changes":401,"status":"deleted"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.spi.ToolProvider;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class JPackageCommandTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testUseToolProvider(UseToolProviderTestSpec spec) {\n+        \/\/ Run the test with the new state to avoid UnsupportedOperationException\n+        \/\/ that will be thrown if it attempts to alter global variables in the default R\/O state.\n+        TKit.withNewState(spec::test);\n+    }\n+\n+    private static List<UseToolProviderTestSpec> testUseToolProvider() {\n+\n+        var testCases = new ArrayList<UseToolProviderTestSpec>();\n+\n+        for (var globalToolProvider : ExecutableSetterType.values()) {\n+            for (var instanceToolProvider : ExecutableSetterType.values()) {\n+                testCases.add(new UseToolProviderTestSpec(globalToolProvider, instanceToolProvider));\n+            }\n+        }\n+\n+        return testCases;\n+    }\n+\n+    record UseToolProviderTestSpec(ExecutableSetterType globalType, ExecutableSetterType instanceType) {\n+\n+        UseToolProviderTestSpec {\n+            Objects.requireNonNull(globalType);\n+            Objects.requireNonNull(instanceType);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s, global=%s\", instanceType, globalType);\n+        }\n+\n+        void test() {\n+\n+            final Optional<ToolProvider> global;\n+            switch (globalType) {\n+                case SET_CUSTOM_TOOL_PROVIDER -> {\n+                    global = Optional.of(createNewToolProvider(\"jpackage-mock-global\"));\n+                    JPackageCommand.useToolProviderByDefault(global.get());\n+                }\n+                case SET_DEFAULT_TOOL_PROVIDER -> {\n+                    global = Optional.of(JavaTool.JPACKAGE.asToolProvider());\n+                    JPackageCommand.useToolProviderByDefault();\n+                }\n+                case SET_PROCESS -> {\n+                    global = Optional.empty();\n+                    JPackageCommand.useExecutableByDefault();\n+                }\n+                case SET_NONE -> {\n+                    global = Optional.empty();\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+\n+            var cmd = new JPackageCommand();\n+\n+            final Optional<ToolProvider> instance;\n+            switch (instanceType) {\n+                case SET_CUSTOM_TOOL_PROVIDER -> {\n+                    instance = Optional.of(createNewToolProvider(\"jpackage-mock\"));\n+                    cmd.useToolProvider(instance.get());\n+                }\n+                case SET_DEFAULT_TOOL_PROVIDER -> {\n+                    instance = Optional.of(JavaTool.JPACKAGE.asToolProvider());\n+                    cmd.useToolProvider(true);\n+                }\n+                case SET_PROCESS -> {\n+                    instance = Optional.empty();\n+                    cmd.useToolProvider(false);\n+                }\n+                case SET_NONE -> {\n+                    instance = Optional.empty();\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+\n+            var actual = cmd.createExecutor().getToolProvider();\n+\n+            switch (instanceType) {\n+                case SET_CUSTOM_TOOL_PROVIDER -> {\n+                    assertSame(actual.get(), instance.get());\n+                    assertTrue(cmd.isWithToolProvider());\n+                }\n+                case SET_DEFAULT_TOOL_PROVIDER -> {\n+                    global.ifPresentOrElse(expected -> {\n+                        assertEquals(expected.name(), actual.orElseThrow().name());\n+                    }, () -> {\n+                        assertEquals(instance.get().name(), actual.get().name());\n+                    });\n+                    assertTrue(cmd.isWithToolProvider());\n+                }\n+                case SET_PROCESS -> {\n+                    assertFalse(actual.isPresent());\n+                    assertFalse(cmd.isWithToolProvider());\n+                }\n+                case SET_NONE -> {\n+                    switch (globalType) {\n+                        case SET_CUSTOM_TOOL_PROVIDER -> {\n+                            assertSame(global.get(), actual.get());\n+                            assertTrue(cmd.isWithToolProvider());\n+                        }\n+                        case SET_DEFAULT_TOOL_PROVIDER -> {\n+                            assertEquals(global.get().name(), actual.orElseThrow().name());\n+                            assertTrue(cmd.isWithToolProvider());\n+                        }\n+                        case SET_PROCESS, SET_NONE -> {\n+                            assertFalse(actual.isPresent());\n+                            assertFalse(cmd.isWithToolProvider());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static ToolProvider createNewToolProvider(String name) {\n+            return new ToolProvider() {\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public String name() {\n+                    return name;\n+                }\n+            };\n+        }\n+    }\n+\n+    enum ExecutableSetterType {\n+        SET_DEFAULT_TOOL_PROVIDER,\n+        SET_CUSTOM_TOOL_PROVIDER,\n+        SET_PROCESS,\n+        SET_NONE,\n+        ;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JPackageCommandTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,1 +216,1 @@\n-            jpackageExitCode = result.exitCode();\n+            jpackageExitCode = result.getExitCode();\n@@ -374,2 +374,1 @@\n-                        return new Executor.Result(actualJPackageExitCode,\n-                                this::getPrintableCommandLine).assertExitCodeIs(expectedExitCode);\n+                        return new Executor.Result(actualJPackageExitCode).assertExitCodeIs(expectedExitCode);\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.nio.file.Files;\n@@ -51,1 +50,1 @@\n-        String version, boolean macSigned, boolean macAppStore, Map<String, Map<String, String>> launchers) {\n+        String version, boolean macAppStore, Map<String, Map<String, String>> launchers) {\n@@ -70,1 +69,1 @@\n-        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, false, Map.of(mainLauncherName, Map.of()));\n+        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, Map.of(mainLauncherName, Map.of()));\n@@ -107,4 +106,0 @@\n-            xml.writeStartElement(\"signed\");\n-            xml.writeCharacters(Boolean.toString(macSigned));\n-            xml.writeEndElement();\n-\n@@ -135,1 +130,1 @@\n-                    Files.newInputStream(getPathInAppImage(appImageDir)));\n+                    getPathInAppImage(appImageDir).toFile());\n@@ -144,4 +139,0 @@\n-            var macSigned = Optional.ofNullable(xPath.evaluate(\n-                    \"\/jpackage-state\/signed\/text()\", doc)).map(\n-                            Boolean::parseBoolean).orElse(false);\n-\n@@ -175,1 +166,0 @@\n-                    macSigned,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AppImageFile.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,0 @@\n-import static java.util.stream.Collectors.joining;\n-\n-import java.io.BufferedReader;\n-import java.io.ByteArrayOutputStream;\n@@ -30,5 +26,0 @@\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.io.StringReader;\n@@ -36,1 +27,1 @@\n-import java.io.Writer;\n+import java.nio.charset.Charset;\n@@ -46,2 +37,2 @@\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CompletionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n@@ -49,1 +40,0 @@\n-import java.util.regex.Pattern;\n@@ -51,1 +41,1 @@\n-import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -53,1 +43,4 @@\n-import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import jdk.jpackage.internal.util.CommandLineFormat;\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedExitCodeException;\n+import jdk.jpackage.internal.util.RetryExecutor;\n@@ -55,0 +48,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -72,2 +66,1 @@\n-        outputStreamsControl = new OutputStreamsControl();\n-        winEnglishOutput = false;\n+        commandOutputControl.dumpStdout(TKit.state().out()).dumpStderr(TKit.state().err());\n@@ -96,0 +89,4 @@\n+    public Optional<ToolProvider> getToolProvider() {\n+        return Optional.ofNullable(toolProvider);\n+    }\n+\n@@ -121,9 +118,0 @@\n-    public Executor setWinRunWithEnglishOutput(boolean value) {\n-        if (!TKit.isWindows()) {\n-            throw new UnsupportedOperationException(\n-                    \"setWinRunWithEnglishOutput is only valid on Windows platform\");\n-        }\n-        winEnglishOutput = value;\n-        return this;\n-    }\n-\n@@ -139,8 +127,0 @@\n-    \/**\n-     * Configures this instance to save all stdout and stderr streams from the to be\n-     * executed command.\n-     * <p>\n-     * This function is mutually exclusive with {@link #saveFirstLineOfOutput()}.\n-     *\n-     * @return this\n-     *\/\n@@ -151,12 +131,0 @@\n-    \/**\n-     * Configures if all stdout and stderr streams from the to be executed command\n-     * should be saved.\n-     * <p>\n-     * If <code>v<\/code> is <code>true<\/code>, the function call is equivalent to\n-     * {@link #saveOutput()} call. If <code>v<\/code> is <code>false<\/code>, command\n-     * output will not be saved.\n-     *\n-     * @parameter v if both stdout and stderr streams should be saved\n-     *\n-     * @return this\n-     *\/\n@@ -164,1 +132,2 @@\n-        return setOutputControl(v, OutputControlOption.SAVE_ALL);\n+        commandOutputControl.saveOutput(v);\n+        return this;\n@@ -167,8 +136,0 @@\n-    \/**\n-     * Configures this instance to save the first line of a stream merged from\n-     * stdout and stderr streams from the to be executed command.\n-     * <p>\n-     * This function is mutually exclusive with {@link #saveOutput()}.\n-     *\n-     * @return this\n-     *\/\n@@ -176,1 +137,2 @@\n-        return setOutputControl(true, OutputControlOption.SAVE_FIRST_LINE);\n+        commandOutputControl.saveFirstLineOfOutput();\n+        return this;\n@@ -179,6 +141,0 @@\n-    \/**\n-     * Configures this instance to dump both stdout and stderr streams from the to\n-     * be executed command into {@link System.out}.\n-     *\n-     * @return this\n-     *\/\n@@ -190,1 +146,2 @@\n-        return setOutputControl(v, OutputControlOption.DUMP);\n+        commandOutputControl.dumpOutput(v);\n+        return this;\n@@ -194,1 +151,1 @@\n-        outputStreamsControl.stdout().discard(v);\n+        commandOutputControl.discardStdout(v);\n@@ -203,1 +160,1 @@\n-        outputStreamsControl.stderr().discard(v);\n+        commandOutputControl.discardStderr(v);\n@@ -211,2 +168,4 @@\n-    public interface Output {\n-        public List<String> getOutput();\n+    public Executor binaryOutput(boolean v) {\n+        commandOutputControl.binaryOutput(v);\n+        return this;\n+    }\n@@ -214,3 +173,3 @@\n-        public default String getFirstLineOfOutput() {\n-            return findFirstLineOfOutput().orElseThrow();\n-        }\n+    public Executor binaryOutput() {\n+        return binaryOutput(true);\n+    }\n@@ -218,3 +177,3 @@\n-        public default Optional<String> findFirstLineOfOutput() {\n-            return getOutput().stream().findFirst();\n-        }\n+    public Executor charset(Charset v) {\n+        commandOutputControl.charset(v);\n+        return this;\n@@ -223,1 +182,19 @@\n-    public record Result(int exitCode, CommandOutput output, Supplier<String> cmdline) implements Output {\n+    public Charset charset() {\n+        return commandOutputControl.charset();\n+    }\n+\n+    public Executor storeOutputInFiles(boolean v) {\n+        commandOutputControl.storeOutputInFiles(v);\n+        return this;\n+    }\n+\n+    public Executor storeOutputInFiles() {\n+        return storeOutputInFiles(true);\n+    }\n+\n+    public Executor processListener(Consumer<Process> v) {\n+        commandOutputControl.processListener(v);\n+        return this;\n+    }\n+\n+    public record Result(CommandOutputControl.Result base) {\n@@ -225,2 +202,1 @@\n-            Objects.requireNonNull(output);\n-            Objects.requireNonNull(cmdline);\n+            Objects.requireNonNull(base);\n@@ -229,2 +205,2 @@\n-        public Result(int exitCode, Supplier<String> cmdline) {\n-            this(exitCode, CommandOutput.EMPTY, cmdline);\n+        public Result(int exitCode) {\n+            this(new CommandOutputControl.Result(exitCode));\n@@ -233,1 +209,0 @@\n-        @Override\n@@ -235,1 +210,33 @@\n-            return output.lines().orElse(null);\n+            return base.content();\n+        }\n+\n+        public String getFirstLineOfOutput() {\n+            return getOutput().getFirst();\n+        }\n+\n+        public List<String> stdout() {\n+            return base.stdout();\n+        }\n+\n+        public List<String> stderr() {\n+            return base.stderr();\n+        }\n+\n+        public Optional<List<String>> findContent() {\n+            return base.findContent();\n+        }\n+\n+        public Optional<List<String>> findStdout() {\n+            return base.findStdout();\n+        }\n+\n+        public Optional<List<String>> findStderr() {\n+            return base.findStderr();\n+        }\n+\n+        public byte[] byteContent() {\n+            return base.byteContent();\n+        }\n+\n+        public byte[] byteStdout() {\n+            return base.byteStdout();\n@@ -238,2 +245,2 @@\n-        public Output stdout() {\n-            return createView(output.stdoutLines());\n+        public byte[] byteStderr() {\n+            return base.byteStderr();\n@@ -242,2 +249,2 @@\n-        public Output stderr() {\n-            return createView(output.stderrLines());\n+        public Optional<byte[]> findByteContent() {\n+            return base.findByteContent();\n@@ -246,4 +253,40 @@\n-        public Result assertExitCodeIs(int expectedExitCode) {\n-            TKit.assertEquals(expectedExitCode, exitCode, String.format(\n-                    \"Check command %s exited with %d code\",\n-                    cmdline.get(), expectedExitCode));\n+        public Optional<byte[]> findByteStdout() {\n+            return base.findByteStdout();\n+        }\n+\n+        public Optional<byte[]> findByteStderr() {\n+            return base.findByteStderr();\n+        }\n+\n+        public Result toCharacterResult(Charset charset, boolean keepByteContent) {\n+            try {\n+                return new Result(base.toCharacterResult(charset, keepByteContent));\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        public Result assertExitCodeIs(int main, int... other) {\n+            if (other.length != 0) {\n+                return assertExitCodeIs(IntStream.concat(IntStream.of(main), IntStream.of(other)).boxed().toList());\n+            } else {\n+                return assertExitCodeIs(List.of(main));\n+            }\n+        }\n+\n+        private Result assertExitCodeIs(List<Integer> expectedExitCodes) {\n+            Objects.requireNonNull(expectedExitCodes);\n+            switch (expectedExitCodes.size()) {\n+                case 0 -> {\n+                    throw new IllegalArgumentException();\n+                } case 1 -> {\n+                    long expectedExitCode = expectedExitCodes.getFirst();\n+                    TKit.assertEquals(expectedExitCode, getExitCode(), String.format(\n+                            \"Check command %s exited with %d code\",\n+                            base.execAttrs().printableCommandLine(), expectedExitCode));\n+                } default -> {\n+                    TKit.assertTrue(expectedExitCodes.contains(getExitCode()), String.format(\n+                            \"Check command %s exited with one of %s codes\",\n+                            base.execAttrs().printableCommandLine(), expectedExitCodes.stream().sorted().toList()));\n+                }\n+            }\n@@ -258,1 +301,1 @@\n-            return exitCode;\n+            return base.getExitCode();\n@@ -261,7 +304,2 @@\n-        private static Output createView(Optional<List<String>> lines) {\n-            return new Output() {\n-                @Override\n-                public List<String> getOutput() {\n-                    return lines.orElse(null);\n-                }\n-            };\n+        public String getPrintableCommandLine() {\n+            return base.execAttrs().printableCommandLine();\n@@ -277,5 +315,0 @@\n-        if (toolProvider != null && winEnglishOutput) {\n-            throw new IllegalArgumentException(\n-                    \"Can't change locale when using tool provider\");\n-        }\n-\n@@ -295,2 +328,2 @@\n-    public Result execute(int expectedCode) {\n-        return executeWithoutExitCodeCheck().assertExitCodeIs(expectedCode);\n+    Result execute(int mainExitCode, int... otherExitCodes) {\n+        return executeWithoutExitCodeCheck().assertExitCodeIs(mainExitCode, otherExitCodes);\n@@ -304,1 +337,1 @@\n-        return saveFirstLineOfOutput().execute().getFirstLineOfOutput();\n+        return saveFirstLineOfOutput().execute().getOutput().getFirst();\n@@ -311,7 +344,3 @@\n-    private static class BadResultException extends RuntimeException {\n-        BadResultException(Result v) {\n-            value = v;\n-        }\n-\n-        Result getValue() {\n-            return value;\n+    private static class FailedAttemptException extends Exception {\n+        FailedAttemptException(Exception cause) {\n+            super(Objects.requireNonNull(cause));\n@@ -320,1 +349,0 @@\n-        private final transient Result value;\n@@ -324,0 +352,13 @@\n+    public RetryExecutor<Result, UnexpectedExitCodeException> retryUntilExitCodeIs(\n+            int mainExpectedExitCode, int... otherExpectedExitCodes) {\n+        return new RetryExecutor<Result, UnexpectedExitCodeException>(UnexpectedExitCodeException.class).setExecutable(() -> {\n+            var result = executeWithoutExitCodeCheck();\n+            result.base().expectExitCode(mainExpectedExitCode, otherExpectedExitCodes);\n+            return result;\n+        }).setExceptionMapper((UnexpectedExitCodeException ex) -> {\n+            createResult(ex.getResult()).assertExitCodeIs(mainExpectedExitCode, otherExpectedExitCodes);\n+            \/\/ Unreachable, because the above `Result.assertExitCodeIs(...)` must throw.\n+            throw ExceptionBox.reachedUnreachable();\n+        });\n+    }\n+\n@@ -325,1 +366,1 @@\n-     * Executes the configured command {@code max} at most times and waits for\n+     * Executes the configured command at most {@code max} times and waits for\n@@ -335,11 +376,4 @@\n-        try {\n-            return tryRunMultipleTimes(() -> {\n-                Result result = executeWithoutExitCodeCheck();\n-                if (result.getExitCode() != expectedExitCode) {\n-                    throw new BadResultException(result);\n-                }\n-                return result;\n-            }, max, wait).assertExitCodeIs(expectedExitCode);\n-        } catch (BadResultException ex) {\n-            return ex.getValue().assertExitCodeIs(expectedExitCode);\n-        }\n+        return retryUntilExitCodeIs(expectedExitCode)\n+                .setAttemptTimeout(wait, TimeUnit.SECONDS)\n+                .setMaxAttemptsCount(max)\n+                .executeUnchecked();\n@@ -362,4 +396,1 @@\n-        RuntimeException lastException = null;\n-        int count = 0;\n-\n-        do {\n+        return new RetryExecutor<T, FailedAttemptException>(FailedAttemptException.class).setExecutable(() -> {\n@@ -369,7 +400,1 @@\n-                lastException = ex;\n-            }\n-\n-            try {\n-                Thread.sleep(wait * 1000);\n-            } catch (InterruptedException ex) {\n-                throw new RuntimeException(ex);\n+                throw new FailedAttemptException(ex);\n@@ -377,0 +402,3 @@\n+        }).setExceptionMapper((FailedAttemptException ex) -> {\n+            return (RuntimeException)ex.getCause();\n+        }).setAttemptTimeout(wait, TimeUnit.SECONDS).setMaxAttemptsCount(max).executeUnchecked();\n@@ -378,4 +406,0 @@\n-            count++;\n-        } while (count < max);\n-\n-        throw lastException;\n@@ -395,6 +419,0 @@\n-    private Executor setOutputControl(boolean set, OutputControlOption v) {\n-        outputStreamsControl.stdout().set(set, v);\n-        outputStreamsControl.stderr().set(set, v);\n-        return this;\n-    }\n-\n@@ -416,8 +434,0 @@\n-    private List<String> prefixCommandLineArgs() {\n-        if (winEnglishOutput) {\n-            return List.of(\"cmd.exe\", \"\/c\", \"chcp\", \"437\", \">nul\", \"2>&1\", \"&&\");\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n@@ -426,1 +436,0 @@\n-        command.addAll(prefixCommandLineArgs());\n@@ -434,2 +443,0 @@\n-        outputStreamsControl.applyTo(builder);\n-\n@@ -437,3 +444,1 @@\n-        outputStreamsControl.describe().ifPresent(desc -> {\n-            sb.append(\"; \").append(desc);\n-        });\n+        sb.append(\"; \").append(commandOutputControl.description());\n@@ -469,39 +474,1 @@\n-        trace(\"Execute \" + sb.toString() + \"...\");\n-        Process process = builder.start();\n-\n-        var stdoutGobbler = CompletableFuture.<Optional<List<String>>>supplyAsync(() -> {\n-            try {\n-                return processProcessStream(outputStreamsControl.stdout(), process.getInputStream());\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        });\n-\n-        var stderrGobbler = CompletableFuture.<Optional<List<String>>>supplyAsync(() -> {\n-            try {\n-                return processProcessStream(outputStreamsControl.stderr(), process.getErrorStream());\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        });\n-\n-        final CommandOutput output;\n-\n-        try {\n-            output = combine(stdoutGobbler.join(), stderrGobbler.join());\n-        } catch (CompletionException ex) {\n-            var cause = ex.getCause();\n-            switch (cause) {\n-                case UncheckedIOException uioex -> {\n-                    throw uioex.getCause();\n-                }\n-                default -> {\n-                    throw ExceptionBox.toUnchecked(ExceptionBox.unbox(cause));\n-                }\n-            }\n-        }\n-\n-        final int exitCode = process.waitFor();\n-        trace(\"Done. Exit code: \" + exitCode);\n-\n-        return createResult(exitCode, output);\n+        return execute(sb, commandOutputControl.createExecutable(builder));\n@@ -510,1 +477,1 @@\n-    private int runToolProvider(PrintStream out, PrintStream err) {\n+    private Result runToolProvider() throws IOException, InterruptedException {\n@@ -512,12 +479,1 @@\n-        outputStreamsControl.describe().ifPresent(desc -> {\n-            sb.append(\"; \").append(desc);\n-        });\n-        trace(\"Execute \" + sb + \"...\");\n-        final int exitCode = toolProvider.run(out, err, args.toArray(\n-                String[]::new));\n-        trace(\"Done. Exit code: \" + exitCode);\n-        return exitCode;\n-    }\n-\n-    private Result runToolProvider() throws IOException {\n-        final var toolProviderStreamConfig = ToolProviderStreamConfig.create(outputStreamsControl);\n+        sb.append(\"; \").append(commandOutputControl.description());\n@@ -525,6 +481,1 @@\n-        final var exitCode = runToolProvider(toolProviderStreamConfig);\n-\n-        final var output = combine(\n-                read(outputStreamsControl.stdout(), toolProviderStreamConfig.out()),\n-                read(outputStreamsControl.stderr(), toolProviderStreamConfig.err()));\n-        return createResult(exitCode, output);\n+        return execute(sb, commandOutputControl.createExecutable(toolProvider, args.toArray(String[]::new)));\n@@ -533,8 +484,2 @@\n-    private int runToolProvider(ToolProviderStreamConfig cfg) throws IOException {\n-        try {\n-            return runToolProvider(cfg.out().ps(), cfg.err().ps());\n-        } finally {\n-            cfg.out().ps().flush();\n-            cfg.err().ps().flush();\n-        }\n-    }\n+    private Result execute(StringBuilder traceMsg, CommandOutputControl.Executable exec) throws IOException, InterruptedException {\n+        Objects.requireNonNull(traceMsg);\n@@ -542,26 +487,1 @@\n-    private static Optional<List<String>> processProcessStream(OutputControl outputControl, InputStream in) throws IOException {\n-        List<String> outputLines = null;\n-        try (final var bufReader = new BufferedReader(new InputStreamReader(in))) {\n-            if (outputControl.dump() || outputControl.saveAll()) {\n-                outputLines = bufReader.lines().toList();\n-            } else if (outputControl.saveFirstLine()) {\n-                outputLines = Optional.ofNullable(bufReader.readLine()).map(List::of).orElseGet(List::of);\n-                \/\/ Read all input, or the started process may exit with an error (cmd.exe does so).\n-                bufReader.transferTo(Writer.nullWriter());\n-            } else {\n-                \/\/ This should be empty input stream, fetch it anyway.\n-                bufReader.transferTo(Writer.nullWriter());\n-            }\n-        } finally {\n-            if (outputControl.dump() && outputLines != null) {\n-                outputLines.forEach(System.out::println);\n-                if (outputControl.saveFirstLine()) {\n-                    outputLines = outputLines.stream().findFirst().map(List::of).orElseGet(List::of);\n-                }\n-            }\n-            if (!outputControl.save()) {\n-                outputLines = null;\n-            }\n-        }\n-        return Optional.ofNullable(outputLines);\n-    }\n+        trace(\"Execute \" + traceMsg + \"...\");\n@@ -569,14 +489,1 @@\n-    private static Optional<List<String>> read(OutputControl outputControl, CachingPrintStream cps) throws IOException {\n-        final var bufferAsString = cps.bufferContents();\n-        try (final var bufReader = new BufferedReader(new StringReader(bufferAsString.orElse(\"\")))) {\n-            if (outputControl.saveFirstLine()) {\n-                return Optional.of(bufReader.lines().findFirst().map(List::of).orElseGet(List::of));\n-            } else if (outputControl.saveAll()) {\n-                return Optional.of(bufReader.lines().toList());\n-            } else if (bufferAsString.isPresent()) {\n-                return Optional.of(List.of());\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-    }\n+        var result = exec.execute();\n@@ -584,16 +491,3 @@\n-    private CommandOutput combine(Optional<List<String>> out, Optional<List<String>> err) {\n-        if (out.isEmpty() && err.isEmpty()) {\n-            return new CommandOutput();\n-        } else if (out.isEmpty()) {\n-            return new CommandOutput(err, -1);\n-        } else if (err.isEmpty()) {\n-            return new CommandOutput(out, Integer.MAX_VALUE);\n-        } else {\n-            final var combined = Stream.of(out, err).map(Optional::orElseThrow).flatMap(List::stream);\n-            if (outputStreamsControl.stdout().saveFirstLine() && outputStreamsControl.stderr().saveFirstLine()) {\n-                return new CommandOutput(Optional.of(combined.findFirst().map(List::of).orElseGet(List::of)),\n-                        Integer.min(1, out.orElseThrow().size()));\n-            } else {\n-                return new CommandOutput(Optional.of(combined.toList()), out.orElseThrow().size());\n-            }\n-        }\n+        trace(\"Done. Exit code: \" + result.getExitCode());\n+\n+        return createResult(result);\n@@ -602,2 +496,3 @@\n-    private Result createResult(int exitCode, CommandOutput output) {\n-        return new Result(exitCode, output, this::getPrintableCommandLine);\n+    private Result createResult(CommandOutputControl.Result baseResult) {\n+        return new Result(baseResult.copyWithExecutableAttributes(\n+                new ExecutableAttributes(baseResult.execAttrs(), getPrintableCommandLine())));\n@@ -618,2 +513,1 @@\n-        var cmdline = Stream.of(prefixCommandLineArgs(), List.of(exec), args).flatMap(\n-                List::stream).toList();\n+        var cmdline = Stream.of(List.of(exec), args).flatMap(List::stream).toList();\n@@ -621,1 +515,1 @@\n-        return String.format(format, printCommandLine(cmdline), cmdline.size());\n+        return String.format(format, CommandLineFormat.DEFAULT.apply(cmdline), cmdline.size());\n@@ -624,172 +518,2 @@\n-    private static String printCommandLine(List<String> cmdline) {\n-        \/\/ Want command line printed in a way it can be easily copy\/pasted\n-        \/\/ to be executed manually\n-        Pattern regex = Pattern.compile(\"\\\\s\");\n-        return cmdline.stream().map(\n-                v -> (v.isEmpty() || regex.matcher(v).find()) ? \"\\\"\" + v + \"\\\"\" : v).collect(\n-                        Collectors.joining(\" \"));\n-    }\n-\n-    private static void trace(String msg) {\n-        TKit.trace(String.format(\"exec: %s\", msg));\n-    }\n-\n-    private static PrintStream nullPrintStream() {\n-        return new PrintStream(OutputStream.nullOutputStream());\n-    }\n-\n-    private record OutputStreamsControl(OutputControl stdout, OutputControl stderr) {\n-        OutputStreamsControl {\n-            Objects.requireNonNull(stdout);\n-            Objects.requireNonNull(stderr);\n-        }\n-\n-        OutputStreamsControl() {\n-            this(new OutputControl(), new OutputControl());\n-        }\n-\n-        void applyTo(ProcessBuilder pb) {\n-            pb.redirectOutput(stdout.asProcessBuilderRedirect());\n-            pb.redirectError(stderr.asProcessBuilderRedirect());\n-        }\n-\n-        Optional<String> describe() {\n-            final List<String> tokens = new ArrayList<>();\n-            if (stdout.save() || stderr.save()) {\n-                streamsLabel(\"save \", true).ifPresent(tokens::add);\n-            }\n-            if (stdout.dump() || stderr.dump()) {\n-                streamsLabel(\"inherit \", true).ifPresent(tokens::add);\n-            }\n-            streamsLabel(\"discard \", false).ifPresent(tokens::add);\n-            if (tokens.isEmpty()) {\n-                return Optional.empty();\n-            } else {\n-                return Optional.of(String.join(\"; \", tokens));\n-            }\n-        }\n-\n-        Optional<String> streamsLabel(String prefix, boolean negate) {\n-            Objects.requireNonNull(prefix);\n-            final var str = Stream.of(stdoutLabel(negate), stderrLabel(negate))\n-                    .filter(Optional::isPresent)\n-                    .map(Optional::orElseThrow)\n-                    .collect(joining(\"+\"));\n-            if (str.isEmpty()) {\n-                return Optional.empty();\n-            } else {\n-                return Optional.of(prefix + str);\n-            }\n-        }\n-\n-        private Optional<String> stdoutLabel(boolean negate) {\n-            if ((stdout.discard() && !negate) || (!stdout.discard() && negate)) {\n-                return Optional.of(\"out\");\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        private Optional<String> stderrLabel(boolean negate) {\n-            if ((stderr.discard() && !negate) || (!stderr.discard() && negate)) {\n-                return Optional.of(\"err\");\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-    }\n-\n-    private record CachingPrintStream(PrintStream ps, Optional<ByteArrayOutputStream> buf) {\n-        CachingPrintStream {\n-            Objects.requireNonNull(ps);\n-            Objects.requireNonNull(buf);\n-        }\n-\n-        Optional<String> bufferContents() {\n-            return buf.map(ByteArrayOutputStream::toString);\n-        }\n-\n-        static Builder build() {\n-            return new Builder();\n-        }\n-\n-        static final class Builder {\n-\n-            Builder save(boolean v) {\n-                save = v;\n-                return this;\n-            }\n-\n-            Builder discard(boolean v) {\n-                discard = v;\n-                return this;\n-            }\n-\n-            Builder dumpStream(PrintStream v) {\n-                dumpStream = v;\n-                return this;\n-            }\n-\n-            CachingPrintStream create() {\n-                final Optional<ByteArrayOutputStream> buf;\n-                if (save && !discard) {\n-                    buf = Optional.of(new ByteArrayOutputStream());\n-                } else {\n-                    buf = Optional.empty();\n-                }\n-\n-                final PrintStream ps;\n-                if (buf.isPresent() && dumpStream != null) {\n-                    ps = new PrintStream(new TeeOutputStream(List.of(buf.orElseThrow(), dumpStream)), true, dumpStream.charset());\n-                } else if (!discard) {\n-                    ps = buf.map(PrintStream::new).or(() -> Optional.ofNullable(dumpStream)).orElseGet(Executor::nullPrintStream);\n-                } else {\n-                    ps = nullPrintStream();\n-                }\n-\n-                return new CachingPrintStream(ps, buf);\n-            }\n-\n-            private boolean save;\n-            private boolean discard;\n-            private PrintStream dumpStream;\n-        }\n-    }\n-\n-    private record ToolProviderStreamConfig(CachingPrintStream out, CachingPrintStream err) {\n-        ToolProviderStreamConfig {\n-            Objects.requireNonNull(out);\n-            Objects.requireNonNull(err);\n-        }\n-\n-        static ToolProviderStreamConfig create(OutputStreamsControl cfg) {\n-            final var errCfgBuilder = cfg.stderr().buildCachingPrintStream(System.err);\n-            if (cfg.stderr().dump() && cfg.stderr().save()) {\n-                errCfgBuilder.dumpStream(System.out);\n-            }\n-            return new ToolProviderStreamConfig(\n-                    cfg.stdout().buildCachingPrintStream(System.out).create(), errCfgBuilder.create());\n-        }\n-    }\n-\n-    private static final class OutputControl {\n-\n-        boolean save() {\n-            return save.isPresent();\n-        }\n-\n-        boolean saveAll() {\n-            return save.orElse(null) == OutputControlOption.SAVE_ALL;\n-        }\n-\n-        boolean saveFirstLine() {\n-            return save.orElse(null) == OutputControlOption.SAVE_FIRST_LINE;\n-        }\n-\n-        boolean discard() {\n-            return discard || (!dump && save.isEmpty());\n-        }\n-\n-        boolean dump() {\n-            return !discard && dump;\n-        }\n+    private record ExecutableAttributes(CommandOutputControl.ExecutableAttributes base, String printableCommandLine)\n+            implements CommandOutputControl.ExecutableAttributes {\n@@ -797,72 +521,4 @@\n-        OutputControl dump(boolean v) {\n-            this.dump = v;\n-            return this;\n-        }\n-\n-        OutputControl discard(boolean v) {\n-            this.discard = v;\n-            return this;\n-        }\n-\n-        OutputControl saveAll(boolean v) {\n-            if (v) {\n-                save = Optional.of(OutputControlOption.SAVE_ALL);\n-            } else {\n-                save = Optional.empty();\n-            }\n-            return this;\n-        }\n-\n-        OutputControl saveFirstLine(boolean v) {\n-            if (v) {\n-                save = Optional.of(OutputControlOption.SAVE_FIRST_LINE);\n-            } else {\n-                save = Optional.empty();\n-            }\n-            return this;\n-        }\n-\n-        OutputControl set(boolean set, OutputControlOption v) {\n-            switch (v) {\n-            case DUMP -> dump(set);\n-            case SAVE_ALL -> saveAll(set);\n-            case SAVE_FIRST_LINE -> saveFirstLine(set);\n-            }\n-            return this;\n-        }\n-\n-        ProcessBuilder.Redirect asProcessBuilderRedirect() {\n-            if (discard()) {\n-                return ProcessBuilder.Redirect.DISCARD;\n-            } else if (dump && !save()) {\n-                return ProcessBuilder.Redirect.INHERIT;\n-            } else {\n-                return ProcessBuilder.Redirect.PIPE;\n-            }\n-        }\n-\n-        CachingPrintStream.Builder buildCachingPrintStream(PrintStream dumpStream) {\n-            Objects.requireNonNull(dumpStream);\n-            final var builder = CachingPrintStream.build().save(save()).discard(discard());\n-            if (dump()) {\n-                builder.dumpStream(dumpStream);\n-            }\n-            return builder;\n-        }\n-\n-        private boolean dump;\n-        private boolean discard;\n-        private Optional<OutputControlOption> save = Optional.empty();\n-    }\n-\n-    private static final class TeeOutputStream extends OutputStream {\n-\n-        public TeeOutputStream(Iterable<OutputStream> streams) {\n-            streams.forEach(Objects::requireNonNull);\n-            this.streams = streams;\n-        }\n-\n-        @Override\n-        public void write(int b) throws IOException {\n-            for (final var out : streams) {\n-                out.write(b);\n+        ExecutableAttributes {\n+            Objects.requireNonNull(base);\n+            if (printableCommandLine.isBlank()) {\n+                throw new IllegalArgumentException();\n@@ -873,4 +529,2 @@\n-        public void write(byte[] b) throws IOException {\n-            for (final var out : streams) {\n-                out.write(b);\n-            }\n+        public List<String> commandLine() {\n+            return base.commandLine();\n@@ -878,40 +532,0 @@\n-\n-        @Override\n-        public void write(byte[] b, int off, int len) throws IOException {\n-            for (final var out : streams) {\n-                out.write(b, off, len);\n-            }\n-        }\n-\n-        @Override\n-        public void flush() throws IOException {\n-            forEach(OutputStream::flush);\n-        }\n-\n-        @Override\n-        public void close() throws IOException {\n-            forEach(OutputStream::close);\n-        }\n-\n-        private void forEach(OutputStreamConsumer c) throws IOException {\n-            IOException firstEx = null;\n-            for (final var out : streams) {\n-                try {\n-                    c.accept(out);\n-                } catch (IOException e) {\n-                    if (firstEx == null) {\n-                        firstEx = e;\n-                    }\n-                }\n-            }\n-            if (firstEx != null) {\n-                throw firstEx;\n-            }\n-        }\n-\n-        @FunctionalInterface\n-        private static interface OutputStreamConsumer {\n-            void accept(OutputStream out) throws IOException;\n-        }\n-\n-        private final Iterable<OutputStream> streams;\n@@ -920,42 +534,2 @@\n-    private static final class CommandOutput {\n-        CommandOutput(Optional<List<String>> lines, int stdoutLineCount) {\n-            this.lines = Objects.requireNonNull(lines);\n-            this.stdoutLineCount = stdoutLineCount;\n-        }\n-\n-        CommandOutput() {\n-            this(Optional.empty(), 0);\n-        }\n-\n-        Optional<List<String>> lines() {\n-            return lines;\n-        }\n-\n-        Optional<List<String>> stdoutLines() {\n-            if (lines.isEmpty() || stdoutLineCount < 0) {\n-                return Optional.empty();\n-            }\n-\n-            final var theLines = lines.orElseThrow();\n-            if (stdoutLineCount == theLines.size()) {\n-                return lines;\n-            } else {\n-                return Optional.of(theLines.subList(0, Integer.min(stdoutLineCount, theLines.size())));\n-            }\n-        }\n-\n-        Optional<List<String>> stderrLines() {\n-            if (lines.isEmpty() || stdoutLineCount > lines.orElseThrow().size()) {\n-                return Optional.empty();\n-            } else if (stdoutLineCount == 0) {\n-                return lines;\n-            } else {\n-                final var theLines = lines.orElseThrow();\n-                return Optional.of(theLines.subList(stdoutLineCount, theLines.size()));\n-            }\n-        }\n-\n-        private final Optional<List<String>> lines;\n-        private final int stdoutLineCount;\n-\n-        static final CommandOutput EMPTY = new CommandOutput();\n+    private static void trace(String msg) {\n+        TKit.trace(String.format(\"exec: %s\", msg));\n@@ -966,1 +540,1 @@\n-    private OutputStreamsControl outputStreamsControl;\n+    private final CommandOutputControl commandOutputControl = new CommandOutputControl();\n@@ -970,1 +544,0 @@\n-    private boolean winEnglishOutput;\n@@ -972,4 +545,0 @@\n-\n-    private static enum OutputControlOption {\n-        SAVE_ALL, SAVE_FIRST_LINE, DUMP\n-    }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":192,"deletions":623,"binary":false,"changes":815,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.function.Consumer;\n@@ -318,2 +319,1 @@\n-        AppOutputVerifier av = assertMainLauncher(cmd, args);\n-        if (av != null) {\n+        assertMainLauncher(cmd, args).ifPresent(av -> {\n@@ -321,1 +321,1 @@\n-        }\n+        });\n@@ -326,2 +326,1 @@\n-        AppOutputVerifier av = assertMainLauncher(cmd, args);\n-        if (av != null) {\n+        return assertMainLauncher(cmd, args).map(av -> {\n@@ -329,3 +328,1 @@\n-        } else {\n-            return null;\n-        }\n+        }).orElseThrow();\n@@ -334,1 +331,1 @@\n-    public static AppOutputVerifier assertMainLauncher(JPackageCommand cmd,\n+    public static Optional<AppOutputVerifier> assertMainLauncher(JPackageCommand cmd,\n@@ -339,1 +336,1 @@\n-            return null;\n+            return Optional.empty();\n@@ -342,1 +339,1 @@\n-        return assertApp(launcherPath)\n+        return Optional.of(assertApp(launcherPath)\n@@ -348,1 +345,1 @@\n-                .orElseGet(() -> new String[0]));\n+                .orElseGet(() -> new String[0])));\n@@ -429,0 +426,5 @@\n+        public AppOutputVerifier processListener(Consumer<Process> v) {\n+            processListener = v;\n+            return this;\n+        }\n+\n@@ -482,0 +484,1 @@\n+                    .processListener(processListener)\n@@ -496,0 +499,1 @@\n+        private Consumer<Process> processListener;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -78,0 +79,1 @@\n+        toolProviderSource = new ToolProviderSource();\n@@ -81,0 +83,1 @@\n+        removeOldOutputBundle = true;\n@@ -85,1 +88,1 @@\n-        withToolProvider = cmd.withToolProvider;\n+        toolProviderSource = cmd.toolProviderSource.copy();\n@@ -92,0 +95,1 @@\n+        removeOldOutputBundle = cmd.removeOldOutputBundle;\n@@ -771,1 +775,1 @@\n-        defaultToolProvider.set(Optional.of(jpackageToolProvider));\n+        TKit.state().setProperty(DefaultToolProviderKey.VALUE, Objects.requireNonNull(jpackageToolProvider));\n@@ -779,1 +783,1 @@\n-        defaultToolProvider.set(Optional.empty());\n+        TKit.state().setProperty(DefaultToolProviderKey.VALUE, null);\n@@ -782,22 +786,8 @@\n-    \/**\n-     * Starts a new thread. In this thread calls\n-     * {@link #useToolProviderByDefault(ToolProvider)} with the specified\n-     * {@code jpackageToolProvider} and then calls {@code workload.run()}. Joins the\n-     * thread.\n-     * <p>\n-     * The idea is to run the {@code workload} in the context of the specified\n-     * jpackage {@code ToolProvider} without altering the global variable holding\n-     * the default jpackage {@code ToolProvider}. The global variable is\n-     * thread-local; setting its value in a new thread doesn't alter its copy in the\n-     * calling thread.\n-     *\n-     * @param jpackageToolProvider jpackage {@code ToolProvider}\n-     * @param workload             the workload to run\n-     *\/\n-    public static void withToolProvider(ToolProvider jpackageToolProvider, Runnable workload) {\n-        Objects.requireNonNull(jpackageToolProvider);\n-        Objects.requireNonNull(workload);\n-        ThrowingRunnable.toRunnable(Thread.ofVirtual().start(() -> {\n-            useToolProviderByDefault(jpackageToolProvider);\n-            workload.run();\n-        })::join).run();\n+    public JPackageCommand useToolProvider(boolean v) {\n+        verifyMutable();\n+        if (v) {\n+            toolProviderSource.useDefaultToolProvider();\n+        } else {\n+            toolProviderSource.useProcess();\n+        }\n+        return this;\n@@ -806,1 +796,1 @@\n-    public JPackageCommand useToolProvider(boolean v) {\n+    public JPackageCommand useToolProvider(ToolProvider v) {\n@@ -808,1 +798,1 @@\n-        withToolProvider = v;\n+        toolProviderSource.useToolProvider(v);\n@@ -859,0 +849,22 @@\n+    \/**\n+     * Configures this instance to optionally remove the existing output bundle\n+     * before running the jpackage command.\n+     *\n+     * @param v {@code true} to remove existing output bundle before running the\n+     *          jpackage command, and {@code false} otherwise\n+     * @return this\n+     *\/\n+    public JPackageCommand removeOldOutputBundle(boolean v) {\n+        verifyMutable();\n+        removeOldOutputBundle = v;\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this instance will remove existing output bundle\n+     * before running the jpackage command, and {@code false} otherwise.\n+     *\/\n+    public boolean isRemoveOldOutputBundle() {\n+        return removeOldOutputBundle;\n+    }\n+\n@@ -920,3 +932,1 @@\n-        return Optional.ofNullable(withToolProvider).orElseGet(() -> {\n-            return defaultToolProvider.get().isPresent();\n-        });\n+        return toolProviderSource.toolProvider().isPresent();\n@@ -930,1 +940,1 @@\n-    private Executor createExecutor() {\n+    Executor createExecutor() {\n@@ -937,8 +947,6 @@\n-        if (isWithToolProvider()) {\n-            exec.setToolProvider(defaultToolProvider.get().orElseGet(JavaTool.JPACKAGE::asToolProvider));\n-        } else {\n-            exec.setExecutable(JavaTool.JPACKAGE);\n-            if (TKit.isWindows()) {\n-                exec.setWindowsTmpDir(System.getProperty(\"java.io.tmpdir\"));\n-            }\n-        }\n+        toolProviderSource.toolProvider().ifPresentOrElse(exec::setToolProvider, () -> {\n+                    exec.setExecutable(JavaTool.JPACKAGE);\n+                    if (TKit.isWindows()) {\n+                        exec.setWindowsTmpDir(System.getProperty(\"java.io.tmpdir\"));\n+                    }\n+                });\n@@ -965,15 +973,12 @@\n-        if (hasArgument(\"--dest\")) {\n-            nullableOutputBundle().ifPresent(path -> {\n-                ThrowingRunnable.toRunnable(() -> {\n-                    if (Files.isDirectory(path)) {\n-                        TKit.deleteDirectoryRecursive(path, String.format(\n-                                \"Delete [%s] folder before running jpackage\",\n-                                path));\n-                    } else if (TKit.deleteIfExists(path)) {\n-                        TKit.trace(String.format(\n-                                \"Deleted [%s] file before running jpackage\",\n-                                path));\n-                    }\n-                }).run();\n-            });\n-        }\n+        nullableOutputBundle().filter(_ -> {\n+            return removeOldOutputBundle;\n+        }).ifPresent(path -> {\n+            ThrowingRunnable.toRunnable(() -> {\n+                if (Files.isDirectory(path)) {\n+                    TKit.deleteDirectoryRecursive(path,\n+                            String.format(\"Delete [%s] folder before running jpackage\", path));\n+                } else if (TKit.deleteIfExists(path)) {\n+                    TKit.trace(String.format(\"Deleted [%s] file before running jpackage\", path));\n+                }\n+            }).run();\n+        });\n@@ -1025,1 +1030,1 @@\n-        if (result.exitCode() == 0 && expectedExitCode.isPresent()) {\n+        if (result.getExitCode() == 0 && expectedExitCode.isPresent()) {\n@@ -1109,1 +1114,1 @@\n-    public static enum ReadOnlyPathAssert{\n+    public static enum ReadOnlyPathAssert {\n@@ -1377,1 +1382,1 @@\n-                return AppImageFile.load(Path.of(getArgumentValue(\"--app-image\"))).macSigned();\n+                return MacHelper.isBundleSigned(Path.of(getArgumentValue(\"--app-image\")));\n@@ -1398,7 +1403,2 @@\n-                boolean expectedValue = MacHelper.appImageSigned(this);\n-                boolean actualValue = aif.macSigned();\n-                TKit.assertEquals(expectedValue, actualValue,\n-                    \"Check for unexpected value of <signed> property in app image file\");\n-\n-                expectedValue = hasArgument(\"--mac-app-store\");\n-                actualValue = aif.macAppStore();\n+                var expectedValue = hasArgument(\"--mac-app-store\");\n+                var actualValue = aif.macAppStore();\n@@ -1429,1 +1429,1 @@\n-                if (AppImageFile.load(Path.of(appImage)).macSigned()) {\n+                if (MacHelper.isBundleSigned(Path.of(appImage))) {\n@@ -1728,1 +1728,64 @@\n-    private Boolean withToolProvider;\n+    private static final class ToolProviderSource {\n+\n+        ToolProviderSource copy() {\n+            return new ToolProviderSource(this);\n+        }\n+\n+        void useDefaultToolProvider() {\n+            customToolProvider = null;\n+            mode = Mode.USE_TOOL_PROVIDER;\n+        }\n+\n+        void useToolProvider(ToolProvider tp) {\n+            customToolProvider = Objects.requireNonNull(tp);\n+            mode = Mode.USE_TOOL_PROVIDER;\n+        }\n+\n+        void useProcess() {\n+            customToolProvider = null;\n+            mode = Mode.USE_PROCESS;\n+        }\n+\n+        Optional<ToolProvider> toolProvider() {\n+            switch (mode) {\n+                case USE_PROCESS -> {\n+                    return Optional.empty();\n+                }\n+                case USE_TOOL_PROVIDER -> {\n+                    if (customToolProvider != null) {\n+                        return Optional.of(customToolProvider);\n+                    } else {\n+                        return TKit.state().findProperty(DefaultToolProviderKey.VALUE).map(ToolProvider.class::cast).or(() -> {\n+                            return Optional.of(JavaTool.JPACKAGE.asToolProvider());\n+                        });\n+                    }\n+                }\n+                case INHERIT_DEFAULTS -> {\n+                    return TKit.state().findProperty(DefaultToolProviderKey.VALUE).map(ToolProvider.class::cast);\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        ToolProviderSource() {\n+            mode = Mode.INHERIT_DEFAULTS;\n+        }\n+\n+        private ToolProviderSource(ToolProviderSource other) {\n+            this.customToolProvider = other.customToolProvider;\n+            this.mode = other.mode;\n+        }\n+\n+        private enum Mode {\n+            INHERIT_DEFAULTS,\n+            USE_PROCESS,\n+            USE_TOOL_PROVIDER\n+        }\n+\n+        private ToolProvider customToolProvider;\n+        private Mode mode;\n+    }\n+\n+    private final ToolProviderSource toolProviderSource;\n@@ -1735,0 +1798,1 @@\n+    private boolean removeOldOutputBundle;\n@@ -1744,6 +1808,4 @@\n-    private static InheritableThreadLocal<Optional<ToolProvider>> defaultToolProvider = new InheritableThreadLocal<>() {\n-        @Override\n-        protected Optional<ToolProvider> initialValue() {\n-            return Optional.empty();\n-        }\n-    };\n+\n+    private enum DefaultToolProviderKey {\n+        VALUE\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":135,"deletions":73,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import javax.xml.parsers.ParserConfigurationException;\n@@ -370,1 +369,1 @@\n-    private void verifyMacEntitlements(JPackageCommand cmd) throws ParserConfigurationException, SAXException, IOException {\n+    private void verifyMacEntitlements(JPackageCommand cmd) throws SAXException, IOException {\n@@ -460,2 +459,4 @@\n-                var bytes = ResourceLocator.class.getResourceAsStream(resourceName).readAllBytes();\n-                return new PListReader(bytes).toMap(true);\n+                try (var in = ResourceLocator.class.getResourceAsStream(resourceName)) {\n+                    var bytes = in.readAllBytes();\n+                    return new PListReader(bytes).toMap(true);\n+                }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -726,1 +726,3 @@\n-                .discardStderr().saveFirstLineOfOutput().execute().findFirstLineOfOutput();\n+                .discardStderr()\n+                .saveFirstLineOfOutput()\n+                .execute().getOutput().stream().findFirst();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -48,0 +49,1 @@\n+import java.util.Arrays;\n@@ -52,1 +54,0 @@\n-import java.util.NoSuchElementException;\n@@ -57,0 +58,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -62,2 +64,0 @@\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n@@ -69,1 +69,0 @@\n-import jdk.jpackage.internal.RetryExecutor;\n@@ -71,0 +70,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -73,0 +73,1 @@\n+import jdk.jpackage.internal.util.RetryExecutor;\n@@ -92,18 +93,11 @@\n-        \/\/ Explode DMG assuming this can require interaction, thus use `yes`.\n-        String attachCMD[] = {\n-            \"sh\", \"-c\",\n-            String.join(\" \", \"yes\", \"|\", \"\/usr\/bin\/hdiutil\", \"attach\",\n-                    JPackageCommand.escapeAndJoin(cmd.outputBundle().toString()),\n-                    \"-mountroot\", PathUtils.normalizedAbsolutePathString(mountRoot),\n-                    \"-nobrowse\", \"-plist\")};\n-        RetryExecutor attachExecutor = new RetryExecutor();\n-        try {\n-            \/\/ 10 times with 6 second delays.\n-            attachExecutor.setMaxAttemptsCount(10)\n-                    .setAttemptTimeoutMillis(6000)\n-                    .setWriteOutputToFile(true)\n-                    .saveOutput(true)\n-                    .execute(attachCMD);\n-        } catch (IOException ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        \/\/ Explode the DMG assuming this can require interaction if the DMG has a license, thus use `yes`.\n+        final var attachExec = Executor.of(\"sh\", \"-c\", String.join(\" \",\n+                \"yes\",\n+                \"|\",\n+                \"\/usr\/bin\/hdiutil\",\n+                \"attach\",\n+                JPackageCommand.escapeAndJoin(cmd.outputBundle().toString()),\n+                \"-mountroot\", PathUtils.normalizedAbsolutePathString(mountRoot),\n+                \"-nobrowse\",\n+                \"-plist\"\n+        )).saveOutput().storeOutputInFiles().binaryOutput();\n@@ -111,1 +105,5 @@\n-        Path mountPoint = null;\n+        final var attachResult = attachExec.executeAndRepeatUntilExitCode(0, 10, 6);\n+\n+        final Path mountPoint;\n+\n+        boolean mountPointInitialized = false;\n@@ -113,0 +111,18 @@\n+            byte[] stdout = attachResult.byteStdout();\n+\n+            \/\/ If the DMG has a license, it will be printed to the stdout before the plist content.\n+            \/\/ All bytes before the XML declaration of the plist must be skipped.\n+            \/\/ We need to find the location of the {'<', '?', 'x', 'm', 'l'} byte array\n+            \/\/ (the XML declaration) in the captured binary stdout.\n+            \/\/ Instead of crafting an ad-hoc function that operates on byte arrays,\n+            \/\/ we will convert the byte array into a String instance using\n+            \/\/ an 8-bit character set (ISO-8859-1) and use the standard String#indexOf().\n+            var startPlistIndex = new String(stdout, StandardCharsets.ISO_8859_1).indexOf(\"<?xml\");\n+\n+            byte[] plistXml;\n+            if (startPlistIndex > 0) {\n+                plistXml = Arrays.copyOfRange(stdout, startPlistIndex, stdout.length);\n+            } else {\n+                plistXml = stdout;\n+            }\n+\n@@ -114,7 +130,8 @@\n-            mountPoint = readPList(attachExecutor.getOutput()).queryArrayValue(\"system-entities\", false).map(PListReader.class::cast).map(dict -> {\n-                try {\n-                    return dict.queryValue(\"mount-point\");\n-                } catch (NoSuchElementException ex) {\n-                    return (String)null;\n-                }\n-            }).filter(Objects::nonNull).map(Path::of).findFirst().orElseThrow();\n+            mountPoint = readPList(plistXml).queryArrayValue(\"system-entities\", false)\n+                    .map(PListReader.class::cast)\n+                    .map(dict -> {\n+                        return dict.findValue(\"mount-point\");\n+                    })\n+                    .filter(Optional::isPresent).map(Optional::get)\n+                    .map(Path::of).findFirst().orElseThrow();\n+            mountPointInitialized = true;\n@@ -122,1 +139,1 @@\n-            if (mountPoint == null) {\n+            if (!mountPointInitialized) {\n@@ -124,1 +141,1 @@\n-                attachExecutor.getOutput().forEach(TKit::trace);\n+                attachResult.toCharacterResult(attachExec.charset(), false).stdout().forEach(TKit::trace);\n@@ -141,5 +158,0 @@\n-            String detachCMD[] = {\n-                \"\/usr\/bin\/hdiutil\",\n-                \"detach\",\n-                \"-verbose\",\n-                mountPoint.toAbsolutePath().toString()};\n@@ -148,7 +160,5 @@\n-            RetryExecutor detachExecutor = new RetryExecutor();\n-            \/\/ Image can get detach even if we got resource busy error, so stop\n-            \/\/ trying to detach it if it is no longer attached.\n-            final Path mp = mountPoint;\n-            detachExecutor.setExecutorInitializer(exec -> {\n-                if (!Files.exists(mp)) {\n-                    detachExecutor.abort();\n+            new RetryExecutor<Void, RuntimeException>(RuntimeException.class).setExecutable(context -> {\n+                var exec = Executor.of(\"\/usr\/bin\/hdiutil\", \"detach\").storeOutputInFiles();\n+                if (context.isLastAttempt()) {\n+                    \/\/ The last attempt, force detach.\n+                    exec.addArgument(\"-force\");\n@@ -156,16 +166,11 @@\n-            });\n-            try {\n-                \/\/ 10 times with 6 second delays.\n-                detachExecutor.setMaxAttemptsCount(10)\n-                        .setAttemptTimeoutMillis(6000)\n-                        .setWriteOutputToFile(true)\n-                        .saveOutput(true)\n-                        .execute(detachCMD);\n-            } catch (IOException ex) {\n-                if (!detachExecutor.isAborted()) {\n-                    \/\/ Now force to detach if it still attached\n-                    if (Files.exists(mountPoint)) {\n-                        Executor.of(\"\/usr\/bin\/hdiutil\", \"detach\",\n-                                    \"-force\", \"-verbose\")\n-                                 .addArgument(mountPoint).execute();\n-                    }\n+                exec.addArgument(mountPoint);\n+\n+                \/\/ The image can get detached even if we get a resource busy error,\n+                \/\/ so execute the detach command without checking the exit code.\n+                var result = exec.executeWithoutExitCodeCheck();\n+\n+                if (result.getExitCode() == 0 || !Files.exists(mountPoint)) {\n+                    \/\/ Detached successfully!\n+                    return null;\n+                } else {\n+                    throw new RuntimeException(String.format(\"[%s] mount point still attached\", mountPoint));\n@@ -173,1 +178,1 @@\n-            }\n+            }).setMaxAttemptsCount(10).setAttemptTimeout(6, TimeUnit.SECONDS).execute();\n@@ -187,2 +192,1 @@\n-        return ThrowingSupplier.toSupplier(() -> readPList(Files.readAllLines(\n-                path))).get();\n+        return readPList(toFunction(Files::readAllBytes).apply(path));\n@@ -191,9 +195,4 @@\n-    public static PListReader readPList(List<String> lines) {\n-        return readPList(lines.stream());\n-    }\n-\n-    public static PListReader readPList(Stream<String> lines) {\n-        return ThrowingSupplier.toSupplier(() -> new PListReader(lines\n-                \/\/ Skip leading lines before xml declaration\n-                .dropWhile(Pattern.compile(\"\\\\s?<\\\\?xml\\\\b.+\\\\?>\").asPredicate().negate())\n-                .collect(Collectors.joining()).getBytes(StandardCharsets.UTF_8))).get();\n+    public static PListReader readPList(byte[] xml) {\n+        return ThrowingSupplier.toSupplier(() -> {\n+            return new PListReader(xml);\n+        }).get();\n@@ -284,1 +283,1 @@\n-        var runtimeImage = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of);\n+        var runtimeImageBundle = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of).flatMap(MacBundle::fromPath);\n@@ -287,1 +286,1 @@\n-        if (cmd.isRuntime() && Files.isDirectory(runtimeImage.orElseThrow().resolve(\"Contents\/_CodeSignature\"))) {\n+        if (cmd.isRuntime() && runtimeImageBundle.map(MacHelper::isBundleSigned).orElse(false)) {\n@@ -290,1 +289,1 @@\n-        } else if (appImage.map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n+        } else if (appImage.map(MacHelper::isBundleSigned).orElse(false)) {\n@@ -320,0 +319,8 @@\n+    static boolean isBundleSigned(Path bundleRoot) {\n+        return isBundleSigned(MacBundle.fromPath(bundleRoot).orElseThrow(IllegalArgumentException::new));\n+    }\n+\n+    static boolean isBundleSigned(MacBundle bundle) {\n+        return MacSignVerify.findSpctlSignOrigin(MacSignVerify.SpctlType.EXEC, bundle.root(), true).isPresent();\n+    }\n+\n@@ -402,1 +409,1 @@\n-        var plistPath = ApplicationLayout.macAppImage().resolveAt(predefinedAppImage).contentDirectory().resolve(\"Info.plist\");\n+        var plistPath = MacBundle.fromPath(predefinedAppImage).orElseThrow().infoPlistFile();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":84,"deletions":77,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1175,1 +1175,1 @@\n-            if (result.exitCode() == 0) {\n+            if (result.getExitCode() == 0) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -33,1 +32,0 @@\n-import java.util.NoSuchElementException;\n@@ -36,1 +34,0 @@\n-import java.util.Set;\n@@ -69,1 +66,1 @@\n-        \/\/ Let is fail in the following TKit.assertEquals() call with a proper log message.\n+        \/\/ Let it fail in the following TKit.assertEquals() call with a proper log message.\n@@ -95,1 +92,5 @@\n-        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"-d\", \"--entitlements\", \"-\", \"--xml\", path.toString()).saveOutput().dumpOutput();\n+        final var exec = Executor.of(\n+                \"\/usr\/bin\/codesign\",\n+                \"-d\",\n+                \"--entitlements\", \"-\",\n+                \"--xml\", path.toString()).saveOutput().dumpOutput().binaryOutput();\n@@ -97,2 +98,2 @@\n-        var xml = result.stdout().getOutput();\n-        if (xml.isEmpty()) {\n+        var xml = result.byteStdout();\n+        if (xml.length == 0) {\n@@ -138,9 +139,22 @@\n-        final var exec = Executor.of(\"\/usr\/sbin\/spctl\", \"-vv\", \"--raw\", \"--assess\", \"--type\", type.value(), path.toString()).saveOutput().discardStderr();\n-        final var result = exec.executeWithoutExitCodeCheck();\n-        TKit.assertTrue(Set.of(0, 3).contains(result.exitCode()),\n-                String.format(\"Check exit code of command %s is either 0 or 3\", exec.getPrintableCommandLine()));\n-        return toSupplier(() -> {\n-            try {\n-                return Optional.of(new PListReader(String.join(\"\", result.getOutput()).getBytes()).queryValue(\"assessment:originator\"));\n-            } catch (NoSuchElementException ex) {\n-                return Optional.<String>empty();\n+        return findSpctlSignOrigin(type, path, false);\n+    }\n+\n+    public static Optional<String> findSpctlSignOrigin(SpctlType type, Path path, boolean acceptBrokenSignature) {\n+        final var exec = Executor.of(\n+                \"\/usr\/sbin\/spctl\",\n+                \"-vv\",\n+                \"--raw\",\n+                \"--assess\",\n+                \"--type\", type.value(),\n+                path.toString()).saveOutput().discardStderr().binaryOutput();\n+        Executor.Result result;\n+        if (acceptBrokenSignature) {\n+            result = exec.executeWithoutExitCodeCheck();\n+            switch (result.getExitCode()) {\n+                case 0, 3 -> {\n+                    \/\/ NOP\n+                }\n+                default -> {\n+                    \/\/ No plist XML to process.\n+                    return Optional.empty();\n+                }\n@@ -148,1 +162,4 @@\n-        }).get();\n+        } else {\n+            result = exec.execute(0, 3);\n+        }\n+        return MacHelper.readPList(result.byteStdout()).findValue(\"assessment:originator\");\n@@ -176,1 +193,1 @@\n-            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            reportUnexpectedCommandOutcome(result);\n@@ -208,1 +225,1 @@\n-            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            reportUnexpectedCommandOutcome(result);\n@@ -267,1 +284,1 @@\n-                reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+                reportUnexpectedCommandOutcome(result);\n@@ -273,1 +290,1 @@\n-            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+            reportUnexpectedCommandOutcome(result);\n@@ -285,2 +302,1 @@\n-    private static void reportUnexpectedCommandOutcome(String printableCommandLine, Executor.Result result) {\n-        Objects.requireNonNull(printableCommandLine);\n+    private static void reportUnexpectedCommandOutcome(Executor.Result result) {\n@@ -289,1 +305,1 @@\n-                printableCommandLine, result.getExitCode()));\n+                result.getPrintableCommandLine(), result.getExitCode()));\n@@ -292,1 +308,1 @@\n-        TKit.assertUnexpected(String.format(\"Outcome of command %s\", printableCommandLine));\n+        TKit.assertUnexpected(String.format(\"Outcome of command %s\", result.getPrintableCommandLine()));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":42,"deletions":26,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n@@ -32,0 +35,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -37,0 +41,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -41,0 +47,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n@@ -50,0 +57,42 @@\n+        Objects.requireNonNull(builder);\n+\n+        var argList = List.of(args);\n+\n+        var ignoreLogfile = argList.contains(CMDLINE_ARG_PREFIX + \"ignore-logfile\");\n+\n+        List<String> filteredArgs;\n+        if (ignoreLogfile) {\n+            filteredArgs = argList.stream().filter(Predicate.isEqual(CMDLINE_ARG_PREFIX + \"ignore-logfile\").negate()).toList();\n+        } else {\n+            filteredArgs = argList;\n+        }\n+\n+        ThrowingRunnable<Exception> workload = () -> {\n+            run(builder, filteredArgs);\n+        };\n+\n+        try {\n+            Optional.ofNullable(TKit.getConfigProperty(\"logfile\")).filter(_ -> {\n+                return !ignoreLogfile;\n+            }).map(Path::of).ifPresentOrElse(logfile -> {\n+\n+                try (var out = new PrintStream(\n+                        Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND),\n+                        true,\n+                        System.out.charset())) {\n+\n+                    TKit.withOutput(workload, out, out);\n+\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+\n+            }, () -> {\n+                ThrowingRunnable.toRunnable(workload).run();\n+            });\n+        } catch (Exception ex) {\n+            throw ExceptionBox.unbox(ex);\n+        }\n+    }\n+\n+    private static void run(TestBuilder.Builder builder, List<String> args) throws Exception {\n@@ -53,1 +102,1 @@\n-            Deque<String> argsAsList = new ArrayDeque<>(List.of(args));\n+            Deque<String> argsAsList = new ArrayDeque<>(args);\n@@ -118,1 +167,1 @@\n-        TKit.withExtraLogStream(() -> runTests(orderedTests));\n+        runTests(orderedTests);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -729,1 +729,11 @@\n-                    Executor.Result result = cmd.execute(expectedJPackageExitCode);\n+                    var nullableOutputBundle = cmd.nullableOutputBundle();\n+\n+                    var oldOutputBundleSnapshot = nullableOutputBundle\n+                            .filter(Files::exists)\n+                            .filter(_ -> {\n+                                return !cmd.isRemoveOldOutputBundle();\n+                            })\n+                            .map(TKit.PathSnapshot::new);\n+\n+                    var result = cmd.execute(expectedJPackageExitCode);\n+\n@@ -733,2 +743,10 @@\n-                        cmd.nullableOutputBundle().ifPresent(outputBundle -> {\n-                            TKit.assertPathExists(outputBundle, false);\n+                        nullableOutputBundle.ifPresent(outputBundle -> {\n+                            oldOutputBundleSnapshot.ifPresentOrElse(snapshot -> {\n+                                \/\/ jpackage failed, but the output bundle exists.\n+                                \/\/ This output bundle existed before the jpackage was invoked.\n+                                \/\/ Verify jpackage didn't modify it.\n+                                new TKit.PathSnapshot(outputBundle).assertEquals(snapshot, String.format(\n+                                        \"Check jpackage didn't modify the old output bundle [%s]\", outputBundle));\n+                            }, () -> {\n+                                TKit.assertPathExists(outputBundle, false);\n+                            });\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.nio.file.StandardOpenOption;\n@@ -55,0 +54,1 @@\n+import java.util.HashMap;\n@@ -112,6 +112,14 @@\n-    static void withExtraLogStream(ThrowingRunnable<? extends Exception> action) {\n-        if (state().extraLogStream != null) {\n-            ThrowingRunnable.toRunnable(action).run();\n-        } else {\n-            try (PrintStream logStream = openLogStream()) {\n-                withExtraLogStream(action, logStream);\n+    public static void withOutput(ThrowingRunnable<? extends Exception> action, PrintStream out, PrintStream err) {\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(out);\n+        Objects.requireNonNull(err);\n+\n+        try {\n+            withState(action, stateBuilder -> {\n+                stateBuilder.out(out).err(err);\n+            });\n+        } finally {\n+            try {\n+                out.flush();\n+            } finally {\n+                err.flush();\n@@ -122,17 +130,3 @@\n-    static void withExtraLogStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.extraLogStream(logStream);\n-        });\n-    }\n-\n-    public static void withMainLogStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.mainLogStream(logStream);\n-        });\n-    }\n-\n-    public static void withStackTraceStream(ThrowingRunnable<? extends Exception> action, PrintStream logStream) {\n-        withNewState(action, stateBuilder -> {\n-            stateBuilder.stackTraceStream(logStream);\n-        });\n-    }\n+    public static void withState(ThrowingRunnable<? extends Exception> action, Consumer<State.Builder> stateBuilderMutator) {\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(stateBuilderMutator);\n@@ -140,2 +134,3 @@\n-    public static State state() {\n-        return STATE.get();\n+        var stateBuilder = state().buildCopy();\n+        stateBuilderMutator.accept(stateBuilder);\n+        withState(action, stateBuilder.create());\n@@ -144,2 +139,2 @@\n-    public static void state(State v) {\n-        STATE.set(Objects.requireNonNull(v));\n+    public static void withNewState(ThrowingRunnable<? extends Exception> action) {\n+        withState(action, _ -> {});\n@@ -148,1 +143,1 @@\n-    private static void withNewState(ThrowingRunnable<? extends Exception> action, Consumer<State.Builder> stateBuilderMutator) {\n+    public static void withState(ThrowingRunnable<? extends Exception> action, State state) {\n@@ -150,1 +145,3 @@\n-        Objects.requireNonNull(stateBuilderMutator);\n+        Objects.requireNonNull(state);\n+        ScopedValue.where(STATE, state).run(ThrowingRunnable.toRunnable(action));\n+    }\n@@ -152,10 +149,2 @@\n-        var oldState = state();\n-        var builder = oldState.buildCopy();\n-        stateBuilderMutator.accept(builder);\n-        var newState = builder.create();\n-        try {\n-            state(newState);\n-            ThrowingRunnable.toRunnable(action).run();\n-        } finally {\n-            state(oldState);\n-        }\n+    public static State state() {\n+        return STATE.orElse(DEFAULT_STATE);\n@@ -181,15 +170,9 @@\n-        withExtraLogStream(() -> {\n-            tests.stream().forEach(test -> {\n-                withNewState(() -> {\n-                    try {\n-                        if (modes.contains(RunTestMode.FAIL_FAST)) {\n-                            test.run();\n-                        } else {\n-                            ignoreExceptions(test).run();\n-                        }\n-                    } finally {\n-                        Optional.ofNullable(state().extraLogStream).ifPresent(PrintStream::flush);\n-                    }\n-                }, stateBuilder -> {\n-                    stateBuilder.currentTest(test);\n-                });\n+        tests.stream().forEach(test -> {\n+            withState(() -> {\n+                if (modes.contains(RunTestMode.FAIL_FAST)) {\n+                    test.run();\n+                } else {\n+                    ignoreExceptions(test).run();\n+                }\n+            }, stateBuilder -> {\n+                stateBuilder.currentTest(test);\n@@ -200,8 +183,0 @@\n-    static <T> T runAdhocTest(ThrowingSupplier<T, ? extends Exception> action) {\n-        final List<T> box = new ArrayList<>();\n-        runAdhocTest(() -> {\n-            box.add(action.get());\n-        });\n-        return box.getFirst();\n-    }\n-\n@@ -284,4 +259,1 @@\n-        state.mainLogStream.println(v);\n-        if (state.extraLogStream != null) {\n-            state.extraLogStream.println(v);\n-        }\n+        state.out.println(v);\n@@ -695,2 +667,1 @@\n-        Optional.ofNullable(state.extraLogStream).ifPresent(throwable::printStackTrace);\n-        throwable.printStackTrace(state.stackTraceStream);\n+        throwable.printStackTrace(state.err);\n@@ -1258,10 +1229,0 @@\n-    private static PrintStream openLogStream() {\n-        return state().logFile.map(logfile -> {\n-            try {\n-                return Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-        }).map(PrintStream::new).orElse(null);\n-    }\n-\n@@ -1379,1 +1340,0 @@\n-                Optional<Path> logFile,\n@@ -1381,3 +1341,3 @@\n-                PrintStream mainLogStream,\n-                PrintStream stackTraceStream,\n-                PrintStream extraLogStream,\n+                PrintStream out,\n+                PrintStream err,\n+                Map<Object, Object> properties,\n@@ -1389,3 +1349,3 @@\n-            Objects.requireNonNull(logFile);\n-            Objects.requireNonNull(mainLogStream);\n-            Objects.requireNonNull(stackTraceStream);\n+            Objects.requireNonNull(out);\n+            Objects.requireNonNull(err);\n+            Objects.requireNonNull(properties);\n@@ -1393,1 +1353,0 @@\n-            this.logFile = logFile;\n@@ -1395,3 +1354,3 @@\n-            this.mainLogStream = mainLogStream;\n-            this.stackTraceStream = stackTraceStream;\n-            this.extraLogStream = extraLogStream;\n+            this.out = out;\n+            this.err = err;\n+            this.properties = Collections.synchronizedMap(properties);\n@@ -1406,1 +1365,0 @@\n-\n@@ -1411,0 +1369,20 @@\n+        PrintStream out() {\n+            return out;\n+        }\n+\n+        PrintStream err() {\n+            return err;\n+        }\n+\n+        Optional<Object> findProperty(Object key) {\n+            return Optional.ofNullable(properties.get(Objects.requireNonNull(key)));\n+        }\n+\n+        void setProperty(Object key, Object value) {\n+            if (value == null) {\n+                properties.remove(Objects.requireNonNull(key));\n+            } else {\n+                properties.put(Objects.requireNonNull(key), value);\n+            }\n+        }\n+\n@@ -1419,1 +1397,0 @@\n-                logFile = Optional.ofNullable(getConfigProperty(\"logfile\")).map(Path::of);\n@@ -1421,3 +1398,2 @@\n-                mainLogStream = System.out;\n-                stackTraceStream = System.err;\n-                extraLogStream = null;\n+                out = System.out;\n+                err = System.err;\n@@ -1447,0 +1423,2 @@\n+                mutable = true;\n+\n@@ -1451,1 +1429,0 @@\n-                logFile = state.logFile;\n@@ -1453,3 +1430,4 @@\n-                mainLogStream = state.mainLogStream;\n-                stackTraceStream = state.stackTraceStream;\n-                extraLogStream = state.extraLogStream;\n+                out = state.out;\n+                err = state.err;\n+                properties.clear();\n+                properties.putAll(state.properties);\n@@ -1466,2 +1444,2 @@\n-            Builder logFile(Optional<Path> v) {\n-                logFile = v;\n+            Builder currentTest(TestInstance v) {\n+                currentTest = v;\n@@ -1471,2 +1449,2 @@\n-            Builder currentTest(TestInstance v) {\n-                currentTest = v;\n+            Builder out(PrintStream v) {\n+                out = v;\n@@ -1476,2 +1454,2 @@\n-            Builder mainLogStream(PrintStream v) {\n-                mainLogStream = v;\n+            Builder err(PrintStream v) {\n+                err = v;\n@@ -1481,2 +1459,6 @@\n-            Builder stackTraceStream(PrintStream v) {\n-                stackTraceStream = v;\n+            Builder property(Object key, Object value) {\n+                if (value == null) {\n+                    properties.remove(Objects.requireNonNull(key));\n+                } else {\n+                    properties.put(Objects.requireNonNull(key), value);\n+                }\n@@ -1486,2 +1468,2 @@\n-            Builder extraLogStream(PrintStream v) {\n-                extraLogStream = v;\n+            Builder mutable(boolean v) {\n+                mutable = v;\n@@ -1492,1 +1474,9 @@\n-                return new State(logFile, currentTest, mainLogStream, stackTraceStream, extraLogStream, trace, traceAsserts, verboseJPackage, verboseTestSetup);\n+                return new State(\n+                        currentTest,\n+                        out,\n+                        err,\n+                        mutable ? new HashMap<>(properties) : Map.copyOf(properties),\n+                        trace,\n+                        traceAsserts,\n+                        verboseJPackage,\n+                        verboseTestSetup);\n@@ -1495,1 +1485,0 @@\n-            private Optional<Path> logFile;\n@@ -1497,3 +1486,3 @@\n-            private PrintStream mainLogStream;\n-            private PrintStream stackTraceStream;\n-            private PrintStream extraLogStream;\n+            private PrintStream out;\n+            private PrintStream err;\n+            private Map<Object, Object> properties = new HashMap<>();\n@@ -1506,0 +1495,2 @@\n+\n+            private boolean mutable = true;\n@@ -1509,1 +1500,0 @@\n-        private final Optional<Path> logFile;\n@@ -1511,3 +1501,4 @@\n-        private final PrintStream mainLogStream;\n-        private final PrintStream stackTraceStream;\n-        private final PrintStream extraLogStream;\n+        private final PrintStream out;\n+        private final PrintStream err;\n+\n+        private final Map<Object, Object> properties;\n@@ -1523,6 +1514,2 @@\n-    private static final InheritableThreadLocal<State> STATE = new InheritableThreadLocal<>() {\n-        @Override\n-        protected State initialValue() {\n-            return State.build().initDefaults().create();\n-        }\n-    };\n+    private static final ScopedValue<State> STATE = ScopedValue.newInstance();\n+    private static final State DEFAULT_STATE = State.build().initDefaults().mutable(false).create();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":112,"deletions":125,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -84,1 +82,1 @@\n-            if (result.exitCode() == 1605) {\n+            if (result.getExitCode() == 1605) {\n@@ -87,1 +85,1 @@\n-                return result.exitCode();\n+                return result.getExitCode();\n@@ -93,1 +91,1 @@\n-            if ((result.exitCode() == 1618) || (result.exitCode() == 1603 && isUnpack)) {\n+            if ((result.getExitCode() == 1618) || (result.getExitCode() == 1603 && isUnpack)) {\n@@ -103,1 +101,1 @@\n-        return result.exitCode();\n+        return result.getExitCode();\n@@ -309,85 +307,0 @@\n-    public static void killProcess(long pid) {\n-        Executor.of(\"taskkill\", \"\/F\", \"\/PID\", Long.toString(pid)).dumpOutput(true).execute();\n-    }\n-\n-    public static void killAppLauncherProcess(JPackageCommand cmd,\n-            String launcherName, int expectedCount) {\n-        var pids = findAppLauncherPIDs(cmd, launcherName);\n-        try {\n-            TKit.assertEquals(expectedCount, pids.length, String.format(\n-                    \"Check [%d] %s app launcher processes found running\",\n-                    expectedCount, Optional.ofNullable(launcherName).map(\n-                            str -> \"[\" + str + \"]\").orElse(\"<main>\")));\n-        } finally {\n-            if (pids.length != 0) {\n-                killProcess(pids[0]);\n-            }\n-        }\n-    }\n-\n-    private static long[] findAppLauncherPIDs(JPackageCommand cmd, String launcherName) {\n-        \/\/ Get the list of PIDs and PPIDs of app launcher processes. Run setWinRunWithEnglishOutput(true) for JDK-8344275.\n-        \/\/ powershell -NoLogo -NoProfile -NonInteractive -Command\n-        \/\/   \"Get-CimInstance Win32_Process -Filter \\\"Name = 'foo.exe'\\\" | select ProcessID,ParentProcessID\"\n-        String command = \"Get-CimInstance Win32_Process -Filter \\\\\\\"Name = '\"\n-                + cmd.appLauncherPath(launcherName).getFileName().toString()\n-                + \"'\\\\\\\" | select ProcessID,ParentProcessID\";\n-        List<String> output = Executor.of(\"powershell\", \"-NoLogo\", \"-NoProfile\", \"-NonInteractive\", \"-Command\", command)\n-                .dumpOutput(true).saveOutput().setWinRunWithEnglishOutput(true).executeAndGetOutput();\n-\n-        if (output.size() < 1) {\n-            return new long[0];\n-        }\n-\n-        String[] headers = Stream.of(output.get(1).split(\"\\\\s+\", 2)).map(\n-                String::trim).map(String::toLowerCase).toArray(String[]::new);\n-        Pattern pattern;\n-        if (headers[0].equals(\"parentprocessid\") && headers[1].equals(\n-                \"processid\")) {\n-            pattern = Pattern.compile(\"^\\\\s+(?<ppid>\\\\d+)\\\\s+(?<pid>\\\\d+)$\");\n-        } else if (headers[1].equals(\"parentprocessid\") && headers[0].equals(\n-                \"processid\")) {\n-            pattern = Pattern.compile(\"^\\\\s+(?<pid>\\\\d+)\\\\s+(?<ppid>\\\\d+)$\");\n-        } else {\n-            throw new RuntimeException(\n-                    \"Unrecognizable output of \\'Get-CimInstance Win32_Process\\' command\");\n-        }\n-\n-        List<long[]> processes = output.stream().skip(3).map(line -> {\n-            Matcher m = pattern.matcher(line);\n-            long[] pids = null;\n-            if (m.matches()) {\n-                pids = new long[]{Long.parseLong(m.group(\"pid\")), Long.\n-                    parseLong(m.group(\"ppid\"))};\n-            }\n-            return pids;\n-        }).filter(Objects::nonNull).toList();\n-\n-        switch (processes.size()) {\n-            case 2 -> {\n-                final long parentPID;\n-                final long childPID;\n-                if (processes.get(0)[0] == processes.get(1)[1]) {\n-                    parentPID = processes.get(0)[0];\n-                    childPID = processes.get(1)[0];\n-                } else if (processes.get(1)[0] == processes.get(0)[1]) {\n-                    parentPID = processes.get(1)[0];\n-                    childPID = processes.get(0)[0];\n-                } else {\n-                    TKit.assertUnexpected(\"App launcher processes unrelated\");\n-                    return null; \/\/ Unreachable\n-                }\n-                return new long[]{parentPID, childPID};\n-            }\n-            case 1 -> {\n-                return new long[]{processes.get(0)[0]};\n-            }\n-            default -> {\n-                TKit.assertUnexpected(String.format(\n-                        \"Unexpected number of running processes [%d]\",\n-                        processes.size()));\n-                return null; \/\/ Unreachable\n-            }\n-        }\n-    }\n-\n@@ -465,1 +378,1 @@\n-        if (status.exitCode() == 1) {\n+        if (status.getExitCode() == 1) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":6,"deletions":93,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.io.PrintStream;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * An action.\n+ *\/\n+@FunctionalInterface\n+public interface CommandAction {\n+\n+    public record Context(PrintStream out, PrintStream err, List<String> args) {\n+\n+        public Context {\n+            Objects.requireNonNull(out);\n+            Objects.requireNonNull(err);\n+            args.forEach(Objects::requireNonNull);\n+        }\n+\n+        public Optional<String> findOptionValue(String option) {\n+            Objects.requireNonNull(option);\n+            var idx = args.indexOf(option);\n+            if (idx >= 0 && idx + 1 < args.size()) {\n+                return Optional.of(args.get(idx + 1));\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        public String optionValue(String option) {\n+            return findOptionValue(option).orElseThrow(() -> {\n+                throw new MockIllegalStateException(String.format(\"No option %s\", option));\n+            });\n+        }\n+\n+        public MockIllegalStateException unexpectedArguments() {\n+            return new MockIllegalStateException(String.format(\"Unexpected arguments: %s\", args));\n+        }\n+    }\n+\n+    \/**\n+     * Runs the action in the given context.\n+     *\n+     * @param context the context\n+     * @return an {@code Optional} wrapping the exit code, indicating it is the last\n+     *         action in the sequence or an empty {@code Optional} otherwise\n+     * @throws Exception                 simulates a failure\n+     * @throws MockIllegalStateException if error in internal mock logic occurred.\n+     *                                   E.g.: if the action was called unexpectedly\n+     *\/\n+    Optional<Integer> run(Context context) throws Exception, MockIllegalStateException;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandAction.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n+\n+\/**\n+ * Specification of a {@link CommandAction}.\n+ * <p>\n+ * Comprised of a human-readable description and an associated action.\n+ *\/\n+public interface CommandActionSpec {\n+\n+    String description();\n+    CommandAction action();\n+\n+    public static CommandActionSpec create(String description, CommandAction action) {\n+        return new Internal.DefaultCommandActionSpec(description, action);\n+    }\n+\n+    public static CommandActionSpec create(String description, ThrowingSupplier<Integer, Exception> action) {\n+        Objects.requireNonNull(action);\n+        return create(description, _ -> {\n+            return Optional.of(action.get());\n+        });\n+    }\n+\n+    public static CommandActionSpec create(String description, ThrowingRunnable<Exception> action) {\n+        Objects.requireNonNull(action);\n+        return create(description, _ -> {\n+            action.run();\n+            return Optional.empty();\n+        });\n+    }\n+\n+    @SuppressWarnings(\"overloads\")\n+    public static CommandActionSpec create(String description, ThrowingConsumer<CommandAction.Context, Exception> action) {\n+        Objects.requireNonNull(action);\n+        return create(description, context -> {\n+            action.accept(context);\n+            return Optional.empty();\n+        });\n+    }\n+\n+    final class Internal {\n+\n+        private Internal() {\n+        }\n+\n+        private record DefaultCommandActionSpec(String description, CommandAction action) implements CommandActionSpec {\n+            DefaultCommandActionSpec {\n+                Objects.requireNonNull(description);\n+                Objects.requireNonNull(action);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return description();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandActionSpec.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\/**\n+ * A sequence of actions.\n+ *\/\n+public record CommandActionSpecs(List<CommandActionSpec> specs) {\n+\n+    public CommandActionSpecs {\n+        Objects.requireNonNull(specs);\n+    }\n+\n+    public CommandActionSpecs andThen(CommandActionSpecs other) {\n+        return build().append(this).append(other).create();\n+    }\n+\n+    public Stream<CommandAction> actions() {\n+        return specs.stream().map(CommandActionSpec::action);\n+    }\n+\n+    public CommandMock.Builder toCommandMockBuilder() {\n+        return new CommandMock.Builder().mutate(builder -> {\n+            builder.actions().append(this);\n+        });\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return specs.toString();\n+    }\n+\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    public static final class Builder {\n+\n+        public CommandActionSpecs create() {\n+            return new CommandActionSpecs(List.copyOf(specs));\n+        }\n+\n+        public Builder stdout(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s>>1\", content), context -> {\n+                var out = context.out();\n+                content.forEach(out::println);\n+            }));\n+        }\n+\n+        public Builder stdout(String... str) {\n+            return stdout(List.of(str));\n+        }\n+\n+        public Builder stderr(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s>>2\", content), context -> {\n+                var err = context.err();\n+                content.forEach(err::println);\n+            }));\n+        }\n+\n+        public Builder stderr(String... str) {\n+            return stderr(List.of(str));\n+        }\n+\n+        public Builder printToStdout(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s(no-eol)>>1\", content), context -> {\n+                var out = context.out();\n+                content.forEach(out::print);\n+            }));\n+        }\n+\n+        public Builder printToStdout(String... str) {\n+            return printToStdout(List.of(str));\n+        }\n+\n+        public Builder printToStderr(List<String> content) {\n+            Objects.requireNonNull(content);\n+            return action(CommandActionSpec.create(String.format(\"%s(no-eol)>>2\", content), context -> {\n+                var err = context.err();\n+                content.forEach(err::print);\n+            }));\n+        }\n+\n+        public Builder printToStderr(String... str) {\n+            return printToStderr(List.of(str));\n+        }\n+\n+        public Builder argsListener(Consumer<List<String>> listener) {\n+            Objects.requireNonNull(listener);\n+            return action(CommandActionSpec.create(\"args-listener\", context -> {\n+                listener.accept(context.args());\n+            }));\n+        }\n+\n+        public Builder exit(int exitCode) {\n+            return action(CommandActionSpec.create(String.format(\"exit(%d)\", exitCode), () -> {\n+                return exitCode;\n+            }));\n+        }\n+\n+        public Builder exit() {\n+            return exit(0);\n+        }\n+\n+        public Builder exit(CommandMockExit exit) {\n+            switch (exit) {\n+                case SUCCEED -> {\n+                    return exit();\n+                }\n+                case EXIT_1 -> {\n+                    return exit(1);\n+                }\n+                case THROW_MOCK_IO_EXCEPTION -> {\n+                    return action(CommandActionSpec.create(\"<I\/O error>\", () -> {\n+                        throw new MockingToolProvider.RethrowableException(new MockIOException(\"Kaput!\"));\n+                    }));\n+                }\n+                default -> {\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        public Builder append(Builder other) {\n+            return append(other.specs);\n+        }\n+\n+        public Builder append(CommandActionSpecs other) {\n+            return append(other.specs());\n+        }\n+\n+        public Builder append(List<CommandActionSpec> other) {\n+            specs.addAll(other);\n+            return this;\n+        }\n+\n+        public Builder action(CommandActionSpec v) {\n+            specs.add(Objects.requireNonNull(v));\n+            return this;\n+        }\n+\n+        public Builder copy() {\n+            return new Builder().append(this);\n+        }\n+\n+        public CommandMock.Builder toCommandMockBuilder() {\n+            return new CommandMock.Builder().mutate(builder -> {\n+                builder.actions(this);\n+            });\n+        }\n+\n+        private final List<CommandActionSpec> specs = new ArrayList<>();\n+    }\n+\n+    public static final CommandActionSpecs UNREACHABLE = new CommandActionSpecs(List.of());\n+}\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandActionSpecs.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Command mock.\n+ *\/\n+public sealed interface CommandMock permits ToolProviderCommandMock, VerbatimCommandMock, CompletableCommandMock {\n+\n+    public static CommandMock ioerror(String name) {\n+        return CommandActionSpecs.build()\n+                .exit(CommandMockExit.THROW_MOCK_IO_EXCEPTION)\n+                .toCommandMockBuilder().name(Objects.requireNonNull(name)).create();\n+    }\n+\n+    public static CommandMock fail(String name) {\n+        return CommandActionSpecs.build()\n+                .exit(CommandMockExit.EXIT_1)\n+                .toCommandMockBuilder().name(Objects.requireNonNull(name)).create();\n+    }\n+\n+    public static CommandMock succeed(String name) {\n+        return CommandActionSpecs.build()\n+                .exit(CommandMockExit.SUCCEED)\n+                .toCommandMockBuilder().name(Objects.requireNonNull(name)).create();\n+    }\n+\n+    public static CommandMock unreachable() {\n+        return MockingToolProvider.UNREACHABLE;\n+    }\n+\n+    public final class Builder {\n+\n+        public ToolProviderCommandMock create() {\n+\n+            var actionSpecs = Optional.ofNullable(scriptBuilder)\n+                    .map(CommandActionSpecs.Builder::create)\n+                    .orElse(CommandActionSpecs.UNREACHABLE);\n+            if (actionSpecs.equals(CommandActionSpecs.UNREACHABLE)) {\n+                return (ToolProviderCommandMock)unreachable();\n+            }\n+\n+            var theName = Optional.ofNullable(name).orElse(\"mock\");\n+            var script = actionSpecs.actions().toList();\n+            switch (repeat) {\n+                case 0 -> {\n+                    return MockingToolProvider.create(theName, script);\n+                }\n+                case -1 -> {\n+                    return MockingToolProvider.createLoop(theName, script);\n+                }\n+                default -> {\n+                    var repeatedScript = IntStream.rangeClosed(0, repeat)\n+                            .mapToObj(i -> script)\n+                            .flatMap(List::stream)\n+                            .toList();\n+                    return MockingToolProvider.create(theName, repeatedScript);\n+                }\n+            }\n+        }\n+\n+        public Builder name(String v) {\n+            name = v;\n+            return this;\n+        }\n+\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        public Builder repeat(int v) {\n+            repeat = Integer.max(-1, v);\n+            return this;\n+        }\n+\n+        public Builder noRepeats() {\n+            return repeat(0);\n+        }\n+\n+        public Builder repeatInfinitely() {\n+            return repeat(-1);\n+        }\n+\n+        public Builder actions(CommandActionSpecs.Builder v) {\n+            scriptBuilder = Optional.ofNullable(v).orElseGet(CommandActionSpecs::build);\n+            return this;\n+        }\n+\n+        public CommandActionSpecs.Builder actions() {\n+            if (scriptBuilder == null) {\n+                scriptBuilder = CommandActionSpecs.build();\n+            }\n+            return scriptBuilder;\n+        }\n+\n+        private String name;\n+        private int repeat = -1;\n+        private CommandActionSpecs.Builder scriptBuilder;\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandMock.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+\n+public enum CommandMockExit {\n+    \/**\n+     * Exit normally with \"0\" exit code.\n+     *\/\n+    SUCCEED(true, true),\n+    \/**\n+     * Exit normally with \"1\" exit code.\n+     *\/\n+    EXIT_1(false, true),\n+    \/**\n+     * Throw {@link MockIOException}. This simulates a situation when an I\/O error\n+     * occurs starting a subprocess with {@link ProcessBuilder#start()}.\n+     * {@link CommandOutputControl.Executable#execute()} will handle I\/O errors and\n+     * let them out.\n+     *\/\n+    THROW_MOCK_IO_EXCEPTION(false, false),\n+    ;\n+\n+    CommandMockExit(boolean succeed, boolean exitNormally) {\n+        this.succeed = succeed;\n+        this.exitNormally = exitNormally;\n+    }\n+\n+    public boolean succeed() {\n+        return succeed;\n+    }\n+\n+    public boolean exitNormally() {\n+        return exitNormally;\n+    }\n+\n+    private final boolean succeed;\n+    private final boolean exitNormally;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandMockExit.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+\/**\n+ * Specification of a {@link CommandMock}.\n+ *\/\n+public record CommandMockSpec(Path name, Path mockName, CommandActionSpecs actions) {\n+\n+    public CommandMockSpec {\n+        Objects.requireNonNull(name);\n+        Objects.requireNonNull(mockName);\n+        Objects.requireNonNull(actions);\n+    }\n+\n+    public CommandMockSpec(Path name, CommandActionSpecs actions) {\n+        this(name, Path.of(name.toString() + \"-mock\"), actions);\n+    }\n+\n+    public CommandMockSpec(String name, CommandActionSpecs actions) {\n+        this(Path.of(name), actions);\n+    }\n+\n+    public CommandMockSpec(String name, String mockName, CommandActionSpecs actions) {\n+        this(Path.of(name), Path.of(mockName), actions);\n+    }\n+\n+    public CommandMock.Builder toCommandMockBuilder() {\n+        return actions.toCommandMockBuilder().name(mockName.toString());\n+    }\n+\n+    public boolean isDefaultMockName() {\n+        return (name.getFileName().toString() + \"-mock\").equals(mockName.getFileName().toString());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"mock-of(%s)%s\", name, actions);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CommandMockSpec.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+\/**\n+ * Command mock that runs a finite sequence of actions.\n+ *\/\n+public sealed interface CompletableCommandMock extends CommandMock permits ToolProviderCompletableCommandMock {\n+\n+    boolean completed();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/CompletableCommandMock.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.io.IOException;\n+\n+\/**\n+ * Simulates I\/O error.\n+ *\n+ * @see CommandMockExit#THROW_MOCK_IO_EXCEPTION\n+ *\/\n+public final class MockIOException extends IOException {\n+\n+    MockIOException(String msg) {\n+        super(msg);\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/MockIOException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+\/**\n+ * Indicates command mock internal error.\n+ *\/\n+public final class MockIllegalStateException extends IllegalStateException {\n+\n+    public MockIllegalStateException(String msg) {\n+        super(msg);\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/MockIllegalStateException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\/**\n+ * A command simulator implementing {@code ToolProvider}.\n+ * <p>\n+ * Iterates over actions and runs them. Each action is write to stdout\/stderr, create a file, etc.\n+ *\/\n+abstract sealed class MockingToolProvider implements ToolProviderCommandMock {\n+\n+    MockingToolProvider(String name, Iterator<CommandAction> actionIter) {\n+        this.name = Objects.requireNonNull(name);\n+        this.actionIter = Objects.requireNonNull(actionIter);\n+    }\n+\n+    static ToolProviderCommandMock createLoop(String name, Iterable<CommandAction> actions) {\n+        return new MockingToolProvider.NonCompletable(name, actions);\n+    }\n+\n+    static MockingToolProvider create(String name, Iterable<CommandAction> actions) {\n+        return new MockingToolProvider.Completable(name, actions);\n+    }\n+\n+    public boolean completed() {\n+        return !actionIter.hasNext();\n+    }\n+\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public int run(PrintStream out, PrintStream err, String... args) {\n+        var context = new CommandAction.Context(out, err, List.of(args));\n+        try {\n+            while (actionIter.hasNext()) {\n+                var action = actionIter.next();\n+                var reply = action.run(context);\n+                if (reply.isPresent()) {\n+                    return reply.get();\n+                }\n+            }\n+        } catch (RethrowableException ex) {\n+            \/\/ Let the checked exception out.\n+            throwAny(ex.getCause());\n+            \/\/ Unreachable\n+            return 0;\n+        } catch (Exception ex) {\n+            throw ExceptionBox.toUnchecked(ex);\n+        }\n+\n+        \/\/ No more actions to execute, but still expect it to keep going.\n+        throw new MockIllegalStateException(\"No more actions to execute\");\n+    }\n+\n+    @Override\n+    public int run(PrintWriter out, PrintWriter err, String... args) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    static final class RethrowableException extends Exception {\n+\n+        RethrowableException(Exception ex) {\n+            super(Objects.requireNonNull(ex));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Throwable> void throwAny(Throwable e) throws E {\n+        throw (E)e;\n+    }\n+\n+    private static final class LoopIterator<T> implements Iterator<T> {\n+\n+        LoopIterator(Iterable<T> iterable) {\n+            this.iterable = Objects.requireNonNull(iterable);\n+            rewind();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return iter != null;\n+        }\n+\n+        @Override\n+        public T next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            } else if (iter.hasNext()) {\n+                return iter.next();\n+            } else {\n+                rewind();\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                } else {\n+                    return iter.next();\n+                }\n+            }\n+        }\n+\n+        private void rewind() {\n+            iter = Objects.requireNonNull(iterable.iterator());\n+            if (!iter.hasNext()) {\n+                iter = null;\n+            }\n+        }\n+\n+        private final Iterable<T> iterable;\n+        private Iterator<T> iter;\n+    }\n+\n+    static final class NonCompletable extends MockingToolProvider {\n+\n+        NonCompletable(String name, Iterable<CommandAction> actions) {\n+            super(name, new LoopIterator<>(actions));\n+        }\n+\n+    }\n+\n+    static final class Completable extends MockingToolProvider implements ToolProviderCompletableCommandMock {\n+\n+        Completable(String name, Iterable<CommandAction> actions) {\n+            super(name, actions.iterator());\n+        }\n+\n+    }\n+\n+    private final String name;\n+    private final Iterator<CommandAction> actionIter;\n+\n+    static ToolProviderCommandMock UNREACHABLE = new MockingToolProvider.NonCompletable(\"<unreachable>\", List.of());\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/MockingToolProvider.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.IdentityWrapper;\n+\n+\/**\n+ * Script of command mocks.\n+ *\/\n+public interface Script {\n+\n+    \/**\n+     * Returns a command mock for the given command line.\n+     *\n+     * @param cmdline the command line for which to look up a command mock\n+     *\n+     * @return a command mock matching the given command line\n+     * @throws ScriptException if an internal script error occures\n+     *\/\n+    CommandMock map(List<String> cmdline) throws ScriptException;\n+\n+    \/**\n+     * Returns command mocks registered with this object that have not completed yet.\n+     *\n+     * @See {@link CompletableCommandMock#completed()}\n+     *\n+     * @return the command mocks registered with this object that have not completed yet\n+     *\/\n+    Collection<CompletableCommandMock> incompleteMocks();\n+\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    public static <T> Predicate<List<String>> cmdlinePredicate(\n+            Predicate<T> pred,\n+            Function<String, T> conv,\n+            Function<List<String>, Stream<String>> toStream) {\n+\n+        Objects.requireNonNull(pred);\n+        Objects.requireNonNull(conv);\n+        Objects.requireNonNull(toStream);\n+\n+        return cmdline -> {\n+            return toStream.apply(cmdline).map(conv).filter(pred).findFirst().isPresent();\n+        };\n+    }\n+\n+    public static Predicate<List<String>> cmdlineContains(String arg) {\n+        return cmdlinePredicate(Predicate.isEqual(Objects.requireNonNull(arg)), x -> x, List::stream);\n+    }\n+\n+    public static Predicate<List<String>> cmdlineContains(Path arg) {\n+        return cmdlinePredicate(Predicate.<Path>isEqual(Objects.requireNonNull(arg)), Path::of, List::stream);\n+    }\n+\n+    public static Predicate<List<String>> cmdlineStartsWith(String arg) {\n+        return cmdlinePredicate(Predicate.isEqual(Objects.requireNonNull(arg)), x -> x, cmdline -> {\n+            return cmdline.stream().limit(1);\n+        });\n+    }\n+\n+    public static Predicate<List<String>> cmdlineStartsWith(Path arg) {\n+        return cmdlinePredicate(Predicate.<Path>isEqual(Objects.requireNonNull(arg)), Path::of, cmdline -> {\n+            return cmdline.stream().limit(1);\n+        });\n+    }\n+\n+    public final class ScriptException extends RuntimeException {\n+\n+        ScriptException(RuntimeException cause) {\n+            super(Objects.requireNonNull(cause));\n+        }\n+\n+        ScriptException(String msg) {\n+            super(Objects.requireNonNull(msg));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    public final class Builder {\n+\n+        public Script createSequence() {\n+            return new SequenceScript(List.copyOf(instructions), completableMocks());\n+        }\n+\n+        public Script createLoop() {\n+            return new LoopScript(List.copyOf(instructions), completableMocks());\n+        }\n+\n+        public Builder map(Predicate<List<String>> pred, CommandMock mock) {\n+            Objects.requireNonNull(pred);\n+            Objects.requireNonNull(mock);\n+            if (mock instanceof CompletableCommandMock completable) {\n+                completableMocks.add(new IdentityWrapper<>(completable));\n+            }\n+            instruction(cmdline -> {\n+                if (pred.test(cmdline)) {\n+                    return new CommandMockResult(Optional.of(mock));\n+                } else {\n+                    return new CommandMockResult(Optional.empty());\n+                }\n+            });\n+            return this;\n+        }\n+\n+        public Builder map(Predicate<List<String>> pred, CommandMock.Builder mock) {\n+            Optional.ofNullable(commandMockBuilderMutator).ifPresent(mock::mutate);\n+            return map(pred, mock.create());\n+        }\n+\n+        public Builder map(Predicate<List<String>> pred, CommandMockSpec mock) {\n+            return map(pred, mock.toCommandMockBuilder());\n+        }\n+\n+        public Builder map(CommandMockSpec mock) {\n+            return map(cmdlineStartsWith(mock.name()), mock.toCommandMockBuilder());\n+        }\n+\n+        public Builder use(CommandMock mock) {\n+            return map(_ -> true, mock);\n+        }\n+\n+        public Builder use(Predicate<List<String>> pred, CommandMock.Builder mock) {\n+            return map(_ -> true, mock);\n+        }\n+\n+        public Builder use(Predicate<List<String>> pred, CommandMockSpec mock) {\n+            return map(_ -> true, mock);\n+        }\n+\n+        public Builder branch(Predicate<List<String>> pred, Script script) {\n+            Objects.requireNonNull(pred);\n+            Objects.requireNonNull(script);\n+            instruction(cmdline -> {\n+                if (pred.test(cmdline)) {\n+                    return new ScriptResult(script);\n+                } else {\n+                    return new CommandMockResult(Optional.empty());\n+                }\n+            });\n+            return this;\n+        }\n+\n+        public Builder commandMockBuilderMutator(Consumer<CommandMock.Builder> v) {\n+            commandMockBuilderMutator = v;\n+            return this;\n+        }\n+\n+        public Builder mutate(Consumer<Script.Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        private Builder instruction(Function<List<String>, Result> instruction) {\n+            instructions.add(Objects.requireNonNull(instruction));\n+            return this;\n+        }\n+\n+        private Collection<CompletableCommandMock> completableMocks() {\n+            return completableMocks.stream().map(IdentityWrapper::value).toList();\n+        }\n+\n+        private static RuntimeException noMapping(List<String> cmdline) {\n+            return new ScriptException(String.format(\"Mapping for %s command line not found\", cmdline));\n+        }\n+\n+        private sealed interface Result {\n+        }\n+\n+        private record CommandMockResult(Optional<CommandMock> value) implements Result {\n+            CommandMockResult {\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+\n+        private record ScriptResult(Script value) implements Result {\n+            ScriptResult {\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+\n+        private abstract static class AbstractScript implements Script {\n+\n+            AbstractScript(Collection<CompletableCommandMock> completableMocks) {\n+                this.completableMocks = Objects.requireNonNull(completableMocks);\n+            }\n+\n+            @Override\n+            public Collection<CompletableCommandMock> incompleteMocks() {\n+                return completableMocks.stream().filter(Predicate.not(CompletableCommandMock::completed)).toList();\n+            }\n+\n+            private final Collection<CompletableCommandMock> completableMocks;\n+        }\n+\n+        private static final class LoopScript extends AbstractScript {\n+\n+            LoopScript(List<Function<List<String>, Result>> instructions,\n+                    Collection<CompletableCommandMock> completableMocks) {\n+                super(completableMocks);\n+                this.instructions = Objects.requireNonNull(instructions);\n+            }\n+\n+            @Override\n+            public CommandMock map(List<String> cmdline) {\n+                for (var instruction : instructions) {\n+                    switch (instruction.apply(cmdline)) {\n+                        case CommandMockResult result -> {\n+                            var mock = result.value();\n+                            if (mock.isPresent()) {\n+                                return mock.get();\n+                            }\n+                        }\n+                        case ScriptResult result -> {\n+                            return result.value().map(cmdline);\n+                        }\n+                    }\n+                }\n+\n+                throw noMapping(cmdline);\n+            }\n+\n+            private final List<Function<List<String>, Result>> instructions;\n+        }\n+\n+        private static final class SequenceScript extends AbstractScript {\n+\n+            SequenceScript(List<Function<List<String>, Result>> instructions,\n+                    Collection<CompletableCommandMock> completableMocks) {\n+                super(completableMocks);\n+                this.iter = instructions.iterator();\n+            }\n+\n+            @Override\n+            public CommandMock map(List<String> cmdline) {\n+                if (!iter.hasNext()) {\n+                    throw new ScriptException(\"No more mappings\");\n+                } else {\n+                    switch (iter.next().apply(cmdline)) {\n+                        case CommandMockResult result -> {\n+                            var mock = result.value();\n+                            if (mock.isPresent()) {\n+                                return mock.get();\n+                            }\n+                        }\n+                        case ScriptResult result -> {\n+                            return result.value().map(cmdline);\n+                        }\n+                    }\n+                }\n+\n+                throw noMapping(cmdline);\n+            }\n+\n+            private final Iterator<Function<List<String>, Result>> iter;\n+        }\n+\n+        private Consumer<CommandMock.Builder> commandMockBuilderMutator = CommandMock.Builder::noRepeats;\n+        private final List<Function<List<String>, Result>> instructions = new ArrayList<>();\n+        private final Set<IdentityWrapper<CompletableCommandMock>> completableMocks = new HashSet<>();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/Script.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Specification of a {@link Script}.\n+ *\/\n+public record ScriptSpec(List<Item> items, boolean loop) {\n+\n+    public ScriptSpec {\n+        Objects.requireNonNull(items);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var sb = new StringBuilder();\n+        sb.append(items.toString());\n+        if (loop) {\n+            \/\/ Append \"Clockwise Gapped Circle Arrow\" Unicode symbol.\n+            sb.append('(').appendCodePoint(0x27F3).append(')');\n+        }\n+        return sb.toString();\n+    }\n+\n+    public Script create() {\n+        var script = Script.build();\n+        items.forEach(item -> {\n+            item.applyTo(script, loop);\n+        });\n+        if (loop) {\n+            return script.createLoop();\n+        } else {\n+            return script.createSequence();\n+        }\n+    }\n+\n+    public Collection<Path> commandNames() {\n+        return items.stream().map(Item::mockSpec).map(CommandMockSpec::name).distinct().toList();\n+    }\n+\n+    private record Item(CommandMockSpec mockSpec, int repeatCount, boolean detailedDescription) {\n+\n+        private Item {\n+            Objects.requireNonNull(mockSpec);\n+            if (repeatCount < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder();\n+            if (detailedDescription) {\n+                sb.append(mockSpec);\n+            } else if (mockSpec.isDefaultMockName()) {\n+                sb.append(mockSpec.name());\n+            } else {\n+                sb.append(mockSpec.mockName());\n+            }\n+            if (repeatCount > 0) {\n+                sb.append('(').append(repeatCount + 1).append(')');\n+            }\n+            return sb.toString();\n+        }\n+\n+        void applyTo(Script.Builder script, boolean loopScript) {\n+            var pred = Script.cmdlineStartsWith(mockSpec.name());\n+\n+            var mockBuilder = mockSpec.toCommandMockBuilder();\n+            if (loopScript) {\n+                script.map(pred, mockBuilder.repeat(repeatCount).create());\n+            } else {\n+                mockBuilder.repeat(0);\n+                IntStream.rangeClosed(0, repeatCount).forEach(_ -> {\n+                    script.map(pred, mockBuilder.create());\n+                });\n+            }\n+        }\n+\n+    }\n+\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    public static final class Builder {\n+\n+        private Builder() {\n+        }\n+\n+        public ScriptSpec create() {\n+            return new ScriptSpec(List.copyOf(items), loop);\n+        }\n+\n+        public Builder loop(boolean v) {\n+            loop = v;\n+            return this;\n+        }\n+\n+        public Builder loop() {\n+            return loop(true);\n+        }\n+\n+        public final class ItemBuilder {\n+\n+            private ItemBuilder(CommandMockSpec mockSpec) {\n+                this.mockSpec = Objects.requireNonNull(mockSpec);\n+            }\n+\n+            public Builder add() {\n+                items.add(new Item(mockSpec, repeat, detailedDescription));\n+                return Builder.this;\n+            }\n+\n+            public ItemBuilder repeat(int v) {\n+                if (repeat < 0) {\n+                    throw new IllegalArgumentException();\n+                }\n+                repeat = v;\n+                return this;\n+            }\n+\n+            public ItemBuilder detailedDescription(boolean v) {\n+                detailedDescription = v;\n+                return this;\n+            }\n+\n+            public ItemBuilder detailedDescription() {\n+                return detailedDescription(true);\n+            }\n+\n+            private final CommandMockSpec mockSpec;\n+            private int repeat;\n+            private boolean detailedDescription;\n+        }\n+\n+        public Builder add(CommandMockSpec mockSpec) {\n+            return build(mockSpec).add();\n+        }\n+\n+        public Builder addLoop(CommandMockSpec mockSpec) {\n+            return build(mockSpec).add();\n+        }\n+\n+        public ItemBuilder build(CommandMockSpec mockSpec) {\n+            return new ItemBuilder(mockSpec);\n+        }\n+\n+        private final List<Item> items = new ArrayList<>();\n+        private boolean loop;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ScriptSpec.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+\/**\n+ * Specification of a {@link Script} bound to a specific directory.\n+ *\/\n+public class ScriptSpecInDir {\n+\n+    public ScriptSpecInDir() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return scriptSpec.toString();\n+    }\n+\n+    public boolean isPathInDir(Path path) {\n+        return path.startsWith(dir);\n+    }\n+\n+    public ScriptSpecInDir dir(Path v) {\n+        dir = v;\n+        return this;\n+    }\n+\n+    public ScriptSpecInDir scriptSpec(ScriptSpec v) {\n+        scriptSpec = v;\n+        return this;\n+    }\n+\n+    public ScriptSpec scriptSpec() {\n+        Objects.requireNonNull(dir);\n+        return Objects.requireNonNull(scriptSpec);\n+    }\n+\n+    public Script create() {\n+        return scriptSpec().create();\n+    }\n+\n+    private ScriptSpec scriptSpec;\n+    private Path dir;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ScriptSpecInDir.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+import java.util.spi.ToolProvider;\n+\n+public sealed interface ToolProviderCommandMock extends CommandMock, ToolProvider\n+    permits ToolProviderCompletableCommandMock, MockingToolProvider {\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ToolProviderCommandMock.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+public sealed interface ToolProviderCompletableCommandMock extends ToolProviderCommandMock, CompletableCommandMock\n+    permits MockingToolProvider.Completable {\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/ToolProviderCompletableCommandMock.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test.mock;\n+\n+public enum VerbatimCommandMock implements CommandMock {\n+\n+    INSTANCE\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/mock\/VerbatimCommandMock.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+public class LibProvidersLookupTest {\n+\n+    @ParameterizedTest\n+    @EnumSource(value = CommandMockExit.class)\n+    public void test_supported(CommandMockExit exit) {\n+\n+        var ldd = CommandActionSpecs.build().exit(exit).toCommandMockBuilder().name(\"ldd-mock\").create();\n+\n+        Globals.main(() -> {\n+            Globals.instance().executorFactory(() -> {\n+                return new Executor().mapper(executor -> {\n+                    return executor.copy().mapper(null).toolProvider(ldd);\n+                });\n+            });\n+\n+            boolean actual = LibProvidersLookup.supported();\n+            assertEquals(exit.exitNormally(), actual);\n+\n+            return 0;\n+        });\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LibProvidersLookupTest.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_RPM;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.Script;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class LinuxPackageArchTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(Runnable test) {\n+        test.run();\n+    }\n+\n+    private static List<Runnable> test() {\n+        var data = new ArrayList<Runnable>();\n+\n+        \/\/ \"foo\" stdout interleaved with \"bar\" stderr\n+        var fooArch = CommandActionSpecs.build()\n+                .printToStdout(\"f\").printToStderr(\"b\")\n+                .printToStdout(\"o\").printToStderr(\"a\")\n+                .printToStdout(\"o\").printToStderr(\"r\");\n+\n+        for (var exit : CommandMockExit.values()) {\n+            var dpkg = fooArch.copy().printToStdout(\"-deb\").exit(exit).create();\n+\n+            data.add(new DebTestSpec(dpkg, Optional.of(\"foo-deb\").filter(_ -> {\n+                return exit.succeed();\n+            })));\n+        }\n+\n+        for (var rpmbuildExit : CommandMockExit.values()) {\n+            var rpmbuild = fooArch.copy().printToStdout(\"-rpmbuild\").exit(rpmbuildExit).create();\n+            for (var rpmExit : CommandMockExit.values()) {\n+                var rpm = fooArch.copy().printToStdout(\"-rpm\").exit(rpmExit).create();\n+                Optional<String> expect;\n+                if (rpmbuildExit.succeed()) {\n+                    expect = Optional.of(\"foo-rpmbuild\");\n+                    rpm = CommandActionSpecs.UNREACHABLE;\n+                } else {\n+                    if (rpmExit.succeed()) {\n+                        expect = Optional.of(\"foo-rpm\");\n+                    } else {\n+                        expect = Optional.empty();\n+                    }\n+                }\n+\n+                data.add(new RpmTestSpec(rpmbuild, rpm, expect));\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    record RpmTestSpec(CommandActionSpecs rpmbuild, CommandActionSpecs rpm, Optional<String> expect) implements Runnable {\n+\n+        RpmTestSpec {\n+            Objects.requireNonNull(rpm);\n+            Objects.requireNonNull(rpmbuild);\n+            Objects.requireNonNull(expect);\n+        }\n+\n+        @Override\n+        public void run() {\n+\n+            \/\/ Create an executor factory that will:\n+            \/\/  - Substitute the \"rpm\" command with `rpm` mock.\n+            \/\/  - Substitute the \"rpmbuild\" command with `rpmbuild` mock.\n+            \/\/  - Throw if a command with the name other than \"rpm\" and \"rpmbuild\" is requested for execution.\n+\n+            var script = Script.build()\n+                    \/\/ LinuxPackageArch must run the \"rpmbuild\" command first. Put its mapping at the first position.\n+                    .map(new CommandMockSpec(\"rpmbuild\", rpmbuild))\n+                    \/\/ LinuxPackageArch may optionally run the \"rpm\" command. Put its mapping after the \"rpmbuild\" command mapping.\n+                    .map(new CommandMockSpec(\"rpm\", rpm))\n+                    \/\/ Create a sequential script: after every Script#map() call, the script will advance the current mapping.\n+                    \/\/ This means each mapping in the script will be considered only once.\n+                    \/\/ If \"rpm\" and \"rpmbuild\" commands are executed in reverse order, the second Script#map() will throw.\n+                    .createSequence();\n+\n+            test(expect, LINUX_RPM, script);\n+        }\n+    }\n+\n+    record DebTestSpec(CommandActionSpecs dpkg, Optional<String> expect) implements Runnable {\n+\n+        DebTestSpec {\n+            Objects.requireNonNull(dpkg);\n+            Objects.requireNonNull(expect);\n+        }\n+\n+        @Override\n+        public void run() {\n+            var script = Script.build().map(new CommandMockSpec(\"dpkg\", dpkg)).createSequence();\n+\n+            test(expect, LINUX_DEB, script);\n+        }\n+    }\n+\n+    private static void test(Optional<String> expectedArch, StandardPackageType pkgType, Script script) {\n+\n+        Globals.main(() -> {\n+\n+            MockUtils.buildJPackage().script(script).applyToGlobals();\n+\n+            Result<LinuxPackageArch> arch = LinuxPackageArch.create(pkgType);\n+\n+            assertEquals(arch.hasValue(), expectedArch.isPresent());\n+            expectedArch.ifPresent(v -> {\n+                assertEquals(v, arch.orElseThrow().value());\n+            });\n+\n+            assertEquals(List.of(), script.incompleteMocks());\n+\n+            return 0;\n+        });\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxPackageArchTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.Script;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class LinuxSystemEnvironmentTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_detectNativePackageType(DetectNativePackageTypeTestSpec test) {\n+        test.run();\n+    }\n+\n+    private static List<DetectNativePackageTypeTestSpec> test_detectNativePackageType() {\n+        var data = new ArrayList<DetectNativePackageTypeTestSpec>();\n+        for (var rpmExit : CommandMockExit.values()) {\n+            for (var debExit : CommandMockExit.values()) {\n+                CommandActionSpecs deb = CommandActionSpecs.build().exit(debExit).create();\n+                CommandActionSpecs rpm;\n+                Optional<StandardPackageType> expected;\n+                if (debExit.succeed()) {\n+                    expected = Optional.of(StandardPackageType.LINUX_DEB);\n+                    rpm = CommandActionSpecs.UNREACHABLE;\n+                } else {\n+                    rpm = CommandActionSpecs.build().exit(rpmExit).create();\n+                    if (rpmExit.succeed()) {\n+                        expected = Optional.of(StandardPackageType.LINUX_RPM);\n+                    } else {\n+                        expected = Optional.empty();\n+                    }\n+                }\n+                data.add(new DetectNativePackageTypeTestSpec(expected, rpm, deb));\n+            }\n+        }\n+        return data;\n+    }\n+\n+    record DetectNativePackageTypeTestSpec(Optional<StandardPackageType> expect, CommandActionSpecs rpm, CommandActionSpecs deb) {\n+\n+        DetectNativePackageTypeTestSpec {\n+            Objects.requireNonNull(expect);\n+            Objects.requireNonNull(rpm);\n+            Objects.requireNonNull(deb);\n+        }\n+\n+        void run() {\n+\n+            var script = Script.build()\n+                    .map(new CommandMockSpec(\"rpm\", rpm))\n+                    .map(new CommandMockSpec(\"dpkg\", deb))\n+                    .createLoop();\n+\n+            Globals.main(() -> {\n+\n+                MockUtils.buildJPackage().script(script).applyToGlobals();\n+\n+                var actual = LinuxSystemEnvironment.detectNativePackageType();\n+\n+                assertEquals(expect, actual);\n+\n+                assertEquals(List.of(), script.incompleteMocks());\n+\n+                return 0;\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxSystemEnvironmentTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,32 @@\n+\n+\/* @test\n+ * @summary Test LinuxSystemEnvironment\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxSystemEnvironmentTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxSystemEnvironmentTest\n+ *\/\n+\n+\/* @test\n+ * @summary Test LibProvidersLookup\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LibProvidersLookupTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LibProvidersLookupTest\n+ *\/\n+\n+\/* @test\n+ * @summary Test LinuxPackageArch\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxPackageArchTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxPackageArchTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/junit.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_DMG;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.MacPackagingPipeline.MacBuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedResultException;\n+import jdk.jpackage.internal.util.FileUtils;\n+import jdk.jpackage.internal.util.RetryExecutor;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.test.mock.CommandActionSpec;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.MockIllegalStateException;\n+import jdk.jpackage.test.mock.ScriptSpec;\n+import jdk.jpackage.test.mock.ScriptSpecInDir;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MacDmgPackagerTest {\n+\n+    \/**\n+     * Exercise branches in {@link MacDmgPackager#buildDMG()}.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(DmgScript scriptSpec, @TempDir Path workDir) {\n+        scriptSpec.run(workDir);\n+    }\n+\n+    private static List<DmgScript> test() {\n+        var data = new ArrayList<DmgScript>();\n+\n+        var succeed = CommandActionSpecs.build().exit().create();\n+        var fail = CommandActionSpecs.build().exit(1).create();\n+\n+        \/\/ Test create\n+        for (var createFullSucceed : List.of(true, false)) {\n+            var dmgScript = new DmgScript();\n+\n+            var scriptBuilder = ScriptSpec.build();\n+\n+            if (createFullSucceed) {\n+                \/\/ `hdiutil create -srcfolder` succeeds\n+                scriptBuilder.add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create\", dmgScript.hdiutilCreate().exit().create()));\n+            } else {\n+                \/\/ `hdiutil create -srcfolder` fails\n+                scriptBuilder.add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create\", fail));\n+                scriptBuilder.add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create-empty\", dmgScript.hdiutilCreateEmpty().exit().create()));\n+            }\n+\n+            scriptBuilder\n+                    \/\/ `hdiutil attach` succeeds\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-attach\", succeed))\n+                    \/\/ `osascript` succeeds\n+                    .add(new CommandMockSpec(\"osascript\", succeed))\n+                    \/\/ `hdiutil detach` succeeds\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach().exit().create()))\n+                    \/\/ `hdiutil convert` succeeds\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+\n+            data.add(dmgScript.scriptSpec(scriptBuilder.create()));\n+        }\n+\n+        \/\/ Test detach\n+        for (var detachResult : DetachResult.values()) {\n+            var dmgScript = new DmgScript();\n+\n+            var scriptBuilder = ScriptSpec.build()\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-create\", dmgScript.hdiutilCreate().exit().create()))\n+                    .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-attach\", succeed))\n+                    .add(new CommandMockSpec(\"osascript\", succeed));\n+\n+            switch (detachResult) {\n+                case ALL_FAIL -> {\n+                    dmgScript.expect(UnexpectedResultException.class);\n+                    scriptBuilder.build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", fail)).repeat(9).add();\n+                }\n+                case LAST_SUCCEED -> {\n+                    scriptBuilder\n+                            .build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", fail)).repeat(8).add()\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach().exit().create()))\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+                }\n+                case FIRST_SUCCEED_WITH_EXIT_1 -> {\n+                    scriptBuilder\n+                            .build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach().exit(1).create()))\n+                                    .detailedDescription().add()\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+                }\n+                case FIRST_SUCCEED_MOUNT_POINT_REMAINS -> {\n+                    scriptBuilder\n+                            .build(new CommandMockSpec(\"hdiutil\", \"hdiutil-detach\", dmgScript.hdiutilDetach(false).exit().create()))\n+                                    .detailedDescription().add()\n+                            .add(new CommandMockSpec(\"hdiutil\", \"hdiutil-convert\", dmgScript.hdiutilConvert().exit().create()));\n+                }\n+            }\n+\n+            data.add(dmgScript.scriptSpec(scriptBuilder.create()));\n+        }\n+\n+        return data;\n+    }\n+\n+    private enum DetachResult {\n+        ALL_FAIL,\n+        LAST_SUCCEED,\n+        \/\/ The first `hdiutil detach` attempt exits with exit code \"1\" but deletes the mounted directory.\n+        FIRST_SUCCEED_WITH_EXIT_1,\n+        \/\/ The first `hdiutil detach` attempt exits with exit code \"0\" and the mounted directory stays undeleted.\n+        FIRST_SUCCEED_MOUNT_POINT_REMAINS,\n+        ;\n+    }\n+\n+    private static MacDmgSystemEnvironment createSysEnv(ScriptSpec scriptSpec) {\n+        return new MacDmgSystemEnvironment(\n+                Path.of(\"hdiutil\"),\n+                Path.of(\"osascript\"),\n+                Stream.of(\"SetFile\").map(Path::of).filter(scriptSpec.commandNames()::contains).findFirst()\n+        );\n+    }\n+\n+    private static RuntimeBuilder createRuntimeBuilder() {\n+        return new RuntimeBuilder() {\n+            @Override\n+            public void create(AppImageLayout appImageLayout) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    private static void runPackagingMock(Path workDir, MacDmgSystemEnvironment sysEnv) {\n+\n+        var app = new ApplicationBuilder()\n+                .appImageLayout(MacPackagingPipeline.APPLICATION_LAYOUT)\n+                .runtimeBuilder(createRuntimeBuilder())\n+                .name(\"foo\")\n+                .create();\n+\n+        var macApp = new MacApplicationBuilder(app).create();\n+\n+        var macDmgPkg = new MacDmgPackageBuilder(new MacPackageBuilder(new PackageBuilder(macApp, MAC_DMG))).create();\n+\n+        var buildEnv = new BuildEnvBuilder(workDir.resolve(\"build-root\")).appImageDirFor(macDmgPkg).create();\n+\n+        var packager = new MacDmgPackager(buildEnv, macDmgPkg, workDir, sysEnv);\n+\n+        var pipelineBuilder = MacPackagingPipeline.build(Optional.of(packager.pkg()));\n+        packager.accept(pipelineBuilder);\n+\n+        \/\/ Disable actions of tasks filling an application image.\n+        Stream.concat(\n+                Stream.of(BuildApplicationTaskID.values()),\n+                Stream.of(MacBuildApplicationTaskID.values())\n+        ).forEach(taskId -> {\n+            pipelineBuilder.task(taskId).noaction().add();\n+        });\n+\n+        var contentMock = new ContentMock();\n+\n+        \/\/ Fill application image with content mock.\n+        pipelineBuilder.task(BuildApplicationTaskID.CONTENT).applicationAction(env -> {\n+            contentMock.create(env.resolvedLayout().contentDirectory());\n+        }).add();\n+\n+        pipelineBuilder.create().execute(buildEnv, packager.pkg(), packager.outputDir());\n+\n+        var outputDmg = packager.outputDir().resolve(packager.pkg().packageFileNameWithSuffix());\n+\n+        contentMock.verifyStoredInFile(outputDmg);\n+    }\n+\n+    private static final class DmgScript extends ScriptSpecInDir {\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder();\n+            sb.append(super.toString());\n+            Optional.ofNullable(expectedErrorType).ifPresent(type -> {\n+                sb.append(\"; \").append(type.getCanonicalName());\n+            });\n+            return sb.toString();\n+        }\n+\n+        @Override\n+        public DmgScript scriptSpec(ScriptSpec v) {\n+            super.scriptSpec(v);\n+            return this;\n+        }\n+\n+        DmgScript expect(Class<? extends Exception> v) {\n+            expectedErrorType = v;\n+            return this;\n+        }\n+\n+        void run(Path workDir) {\n+\n+            var script = dir(Objects.requireNonNull(workDir)).create();\n+\n+            ExecutorFactory executorFactory = MockUtils.buildJPackage()\n+                    .script(script).listener(System.out::println).createExecutorFactory();\n+\n+            var objectFactory = ObjectFactory.build()\n+                    .executorFactory(executorFactory)\n+                    .retryExecutorFactory(new RetryExecutorFactory() {\n+                        @Override\n+                        public <T, E extends Exception> RetryExecutor<T, E> retryExecutor(Class<? extends E> exceptionType) {\n+                            return RetryExecutorFactory.DEFAULT.<T, E>retryExecutor(exceptionType).setSleepFunction(_ -> {\n+                                \/\/ Don't \"sleep\" to make the test run faster.\n+                            });\n+                        }\n+                    })\n+                    .create();\n+\n+            Globals.main(() -> {\n+                Globals.instance().objectFactory(objectFactory);\n+                if (expectedErrorType == null) {\n+                    runPackagingMock(workDir, createSysEnv(scriptSpec()));\n+                } else {\n+                    var ex = assertThrows(Exception.class, () -> {\n+                        runPackagingMock(workDir, createSysEnv(scriptSpec()));\n+                    });\n+                    var cause = ExceptionBox.unbox(ex);\n+                    assertEquals(expectedErrorType, cause.getClass());\n+                }\n+                return 0;\n+            });\n+\n+            assertEquals(List.of(), script.incompleteMocks());\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilCreate(boolean empty) {\n+            CommandActionSpec action = CommandActionSpec.create(\"create\", context -> {\n+                var dstDmg = Path.of(context.optionValue(\"-ov\"));\n+                assertTrue(isPathInDir(dstDmg));\n+\n+                var volumeName = context.optionValue(\"-volname\");\n+\n+                if (empty) {\n+                    createDmg(new CreateDmgResult(dstDmg, volumeName, Optional.empty()));\n+                    Files.createFile(dstDmg);\n+                } else {\n+                    var srcDir = Path.of(context.optionValue(\"-srcfolder\"));\n+                    assertTrue(isPathInDir(srcDir));\n+\n+                    createDmg(new CreateDmgResult(dstDmg, volumeName, Optional.of(srcDir)));\n+\n+                    try (var walk = Files.walk(srcDir)) {\n+                        var paths = walk.map(srcDir::relativize).map(Path::toString).toList();\n+                        Files.write(dstDmg, paths);\n+                    }\n+                }\n+            });\n+            return CommandActionSpecs.build().action(action);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilCreate() {\n+            return hdiutilCreate(false);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilCreateEmpty() {\n+            return hdiutilCreate(true);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilDetach() {\n+            return hdiutilDetach(true);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilDetach(boolean deleteMountPoint) {\n+            var sb = new StringBuilder();\n+            sb.append(\"detach\");\n+            if (!deleteMountPoint) {\n+                sb.append(\"(rm-mount-point)\");\n+            }\n+            CommandActionSpec action = CommandActionSpec.create(sb.toString(), context -> {\n+                var mountPoint = Path.of(context.args().getLast());\n+                assertTrue(isPathInDir(mountPoint));\n+\n+                try (var walk = Files.walk(mountPoint)) {\n+                    var dstDmg = dmg().dmg();\n+                    var paths = Stream.concat(\n+                            walk.map(mountPoint::relativize),\n+                            Files.readAllLines(dstDmg).stream().filter(Predicate.not(String::isEmpty)).map(Path::of)\n+                    ).sorted().map(Path::toString).toList();\n+                    Files.write(dstDmg, paths);\n+                }\n+\n+                if (deleteMountPoint) {\n+                    FileUtils.deleteRecursive(mountPoint);\n+                }\n+            });\n+            return CommandActionSpecs.build().action(action);\n+        }\n+\n+        CommandActionSpecs.Builder hdiutilConvert() {\n+            CommandActionSpec action = CommandActionSpec.create(\"convert\", context -> {\n+                var srcDmg = Path.of(context.args().get(1));\n+                assertTrue(isPathInDir(srcDmg));\n+\n+                var dstDmg = Path.of(context.args().getLast());\n+                assertTrue(isPathInDir(dstDmg));\n+\n+                Files.copy(srcDmg, dstDmg);\n+            });\n+            return CommandActionSpecs.build().action(action);\n+        }\n+\n+        private void createDmg(CreateDmgResult v) {\n+            if (dmg != null) {\n+                throw new MockIllegalStateException(\"The DMG already set\");\n+            } else {\n+                dmg = Objects.requireNonNull(v);\n+            }\n+        }\n+\n+        private CreateDmgResult dmg() {\n+            if (dmg == null) {\n+                throw new MockIllegalStateException(\"The DMG not set\");\n+            } else {\n+                return dmg;\n+            }\n+        }\n+\n+        private record CreateDmgResult(Path dmg, String volumeName, Optional<Path> srcFolder) {\n+            CreateDmgResult {\n+                Objects.requireNonNull(dmg);\n+                Objects.requireNonNull(volumeName);\n+                Objects.requireNonNull(srcFolder);\n+            }\n+        }\n+\n+        private CreateDmgResult dmg;\n+        private Class<? extends Exception> expectedErrorType;\n+    }\n+\n+    private static final class ContentMock {\n+\n+        void create(Path dir) throws IOException {\n+            Files.createDirectories(dir.resolve(\"foo\/bar\"));\n+            Files.writeString(dir.resolve(\"foo\/bar\/buz\"), \"Hello!\");\n+            if (!OperatingSystem.isWindows()) {\n+                Files.createSymbolicLink(dir.resolve(\"symlink\"), Path.of(\"foo\"));\n+            }\n+        }\n+\n+        void verifyStoredInFile(Path file) {\n+            try {\n+                var expectedPaths = Stream.of(\n+                        Stream.of(Path.of(\"\")),\n+                        DMG_ICON_FILES.stream(),\n+                        Stream.of(\n+                                Stream.of(\"foo\/bar\/buz\"),\n+                                Stream.of(\"symlink\").filter(_ -> {\n+                                    return !OperatingSystem.isWindows();\n+                                })\n+                        ).flatMap(x -> x).map(Path::of).map(Path.of(\"foo.app\/Contents\")::resolve)\n+                ).flatMap(x -> x).mapMulti(EXPAND_PATH).sorted().distinct().toList();\n+                var actualPaths = Files.readAllLines(file).stream().map(Path::of).toList();\n+                assertEquals(expectedPaths, actualPaths);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+    private final static BiConsumer<Path, Consumer<Path>> EXPAND_PATH = (path, sink) -> {\n+        do {\n+            sink.accept(path);\n+            path = path.getParent();\n+        } while (path != null);\n+    };\n+\n+    private final static List<Path> DMG_ICON_FILES = Stream.of(\n+            \".VolumeIcon.icns\",\n+            \".background\/background.tiff\"\n+    ).map(Path::of).collect(Collectors.toUnmodifiableList());\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacDmgPackagerTest.java","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.util.RetryExecutor;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CommandMockSpec;\n+import jdk.jpackage.test.mock.Script;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MacDmgSystemEnvironmentTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void test_findSetFileUtility(FindSetFileUtilityTestSpec test) {\n+        test.run();\n+    }\n+\n+    private static List<FindSetFileUtilityTestSpec> test_findSetFileUtility() {\n+        var data = new ArrayList<FindSetFileUtilityTestSpec>();\n+\n+        var succeed = CommandActionSpecs.build().exit().create();\n+\n+        for (var failureCause : List.of(CommandMockExit.EXIT_1, CommandMockExit.THROW_MOCK_IO_EXCEPTION)) {\n+\n+            var fail = CommandActionSpecs.build().exit(failureCause).create();\n+\n+            for (var i = 0; i != MacDmgSystemEnvironment.SETFILE_KNOWN_PATHS.size(); i++) {\n+\n+                var expected = MacDmgSystemEnvironment.SETFILE_KNOWN_PATHS.get(i);\n+\n+                var mocks = new ArrayList<CommandMockSpec>();\n+\n+                MacDmgSystemEnvironment.SETFILE_KNOWN_PATHS.subList(0, i).stream().map(failureSetFilePath -> {\n+                    return new CommandMockSpec(failureSetFilePath, fail);\n+                }).forEach(mocks::add);\n+\n+                mocks.add(new CommandMockSpec(expected, succeed));\n+\n+                data.add(new FindSetFileUtilityTestSpec(Optional.of(expected), mocks));\n+            }\n+\n+            var lastMocks = data.getLast().mockSpecs();\n+            var lastSucceedMock = lastMocks.getLast();\n+            var lastFailMock = new CommandMockSpec(lastSucceedMock.name(), lastSucceedMock.mockName(), fail);\n+\n+            var mocks = new ArrayList<>(lastMocks);\n+            mocks.set(mocks.size() - 1, lastFailMock);\n+\n+            for (var xcrunOutout : List.<Map.Entry<Optional<String>, Boolean>>of(\n+                    \/\/ Use the path to the command of the current process\n+                    \/\/ as an output mock for the \/usr\/bin\/xcrun command.\n+                    \/\/ MacDmgSystemEnvironment.findSetFileUtility() reads the command output\n+                    \/\/ and checks whether it is an executable file,\n+                    \/\/ so the hardcoded value is not an option for the output mock.\n+                    Map.entry(Optional.of(ProcessHandle.current().info().command().orElseThrow()), true),\n+                    \/\/ \"\/usr\/bin\/xcrun\" outputs a path to non-executable file.\n+                    Map.entry(Optional.of(\"\/dev\/null\"), false),\n+                    \/\/ \"\/usr\/bin\/xcrun\" outputs '\\0' making subsequent Path.of(\"\\0\") fail.\n+                    Map.entry(Optional.of(\"\\0\"), false),\n+                    \/\/ \"\/usr\/bin\/xcrun\" doesn't output anything.\n+                    Map.entry(Optional.empty(), false)\n+            )) {\n+\n+\n+                mocks.add(new CommandMockSpec(\"\/usr\/bin\/xcrun\", CommandActionSpecs.build().mutate(builder -> {\n+                    xcrunOutout.getKey().ifPresent(builder::stdout);\n+                }).exit(CommandMockExit.SUCCEED).create()));\n+\n+                Optional<String> expected;\n+                if (xcrunOutout.getValue()) {\n+                    expected = xcrunOutout.getKey();\n+                } else {\n+                    expected = Optional.empty();\n+                }\n+\n+                data.add(new FindSetFileUtilityTestSpec(expected.map(Path::of), List.copyOf(mocks)));\n+\n+                mocks.removeLast();\n+            }\n+\n+            \/\/ The last test case: \"\/usr\/bin\/xcrun\" fails\n+            mocks.add(new CommandMockSpec(\"\/usr\/bin\/xcrun\", fail));\n+            data.add(new FindSetFileUtilityTestSpec(Optional.empty(), mocks));\n+        }\n+\n+        return data;\n+    }\n+\n+    record FindSetFileUtilityTestSpec(Optional<Path> expected, List<CommandMockSpec> mockSpecs) {\n+\n+        FindSetFileUtilityTestSpec {\n+            Objects.requireNonNull(expected);\n+            Objects.requireNonNull(mockSpecs);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var tokens = new ArrayList<String>();\n+            expected.ifPresent(v -> {\n+                tokens.add(String.format(\"expect=%s\", v));\n+            });\n+            tokens.add(mockSpecs.toString());\n+            return tokens.stream().collect(Collectors.joining(\", \"));\n+        }\n+\n+        void run() {\n+\n+            var script = Script.build().mutate(builder -> {\n+                mockSpecs.forEach(builder::map);\n+            }).createSequence();\n+\n+            Globals.main(() -> {\n+                MockUtils.buildJPackage().script(script).applyToGlobals();\n+\n+                var actual = MacDmgSystemEnvironment.findSetFileUtility();\n+\n+                assertEquals(expected, actual);\n+                assertEquals(List.of(), script.incompleteMocks());\n+\n+                return 0;\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacDmgSystemEnvironmentTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,22 @@\n+\n+\/* @test\n+ * @summary Test MacDmgSystemEnvironmentTest\n+ * @requires (os.family == \"mac\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacDmgSystemEnvironmentTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacDmgSystemEnvironmentTest\n+ *\/\n+\n+\/* @test\n+ * @summary Test MacDmgPackagerTest\n+ * @requires (os.family == \"mac\")\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.mock.*\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacDmgPackagerTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacDmgPackagerTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/junit.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n@@ -517,1 +516,0 @@\n-                \"<signed>true<\/signed>\",\n@@ -549,2 +547,1 @@\n-                .addExtra(MAC_APP_STORE, false)\n-                .addExtra(MAC_SIGNED, true)).create());\n+                .addExtra(MAC_APP_STORE, false)).create());\n@@ -583,1 +580,0 @@\n-                        \"<signed>true<\/signed>\",\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.mock.CommandMock.ioerror;\n+import static jdk.jpackage.test.mock.CommandMock.succeed;\n@@ -27,0 +31,7 @@\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n@@ -28,0 +39,3 @@\n+import java.util.Set;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n@@ -29,0 +43,2 @@\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+import jdk.jpackage.internal.model.AppImageBundleType;\n@@ -30,0 +46,11 @@\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.test.Annotations;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.JavaAppDesc;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMock;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.Script;\n@@ -33,1 +60,1 @@\n-public class DefaultBundlingEnvironmentTest {\n+public class DefaultBundlingEnvironmentTest extends JUnitAdapter {\n@@ -58,0 +85,196 @@\n+\n+    \/**\n+     * Tests that commands executed to initialize the system environment are\n+     * executed only once.\n+     * @throws IOException\n+     *\/\n+    @Annotations.Test\n+    @Annotations.ParameterSupplier\n+    public void testInitializedOnce(StandardBundlingOperation op) throws IOException {\n+\n+        List<List<String>> executedCommands = Collections.synchronizedList(new ArrayList<>());\n+\n+        var script = createMockScript(op);\n+\n+        ToolProvider jpackage = MockUtils.buildJPackage()\n+                .os(op.os())\n+                .script(script)\n+                .listener(executedCommands::add).create();\n+\n+        var inputDir = TKit.createTempDirectory(\"input\");\n+        var appDesc = JavaAppDesc.parse(null);\n+        HelloApp.createBundle(appDesc, inputDir);\n+\n+        \/\/\n+        \/\/ The command line should fail as the main class name is not specified and it is not set in the main jar.\n+        \/\/\n+        \/\/ Run native packaging twice.\n+        \/\/ It can execute commands required to configure the system environment in the first iteration.\n+        \/\/ It must not execute a single command in the second iteration.\n+        \/\/\n+        \/\/ Run app image packaging once.\n+        \/\/ It must not execute a single command because app image packaging should not require native commands (Unless\n+        \/\/ it is macOS where it will sign the app image with an ad hoc signature\n+        \/\/ using the codesign tool. But: #1 - it is not a variable part of the system environment;\n+        \/\/ #2 - jpackage should bail out earlier).\n+        \/\/\n+\n+        final var type = op.bundleTypeValue();\n+        final int iterationCount;\n+        if (op.bundleType() instanceof AppImageBundleType) {\n+            iterationCount = 1;\n+        } else {\n+            iterationCount = 2;\n+        }\n+\n+        for (var i = 0; i != iterationCount; i++) {\n+            var result = new Executor().toolProvider(jpackage).saveOutput().args(\n+                    \"--type=\" + type,\n+                    \"--input\", inputDir.toString(),\n+                    \"--main-jar\", appDesc.jarFileName()).execute();\n+\n+            assertEquals(1, result.getExitCode());\n+\n+            \/\/ Assert it bailed out with the expected error.\n+            assertEquals(List.of(\n+                    I18N.format(\"message.error-header\", I18N.format(\"error.no-main-class-with-main-jar\", appDesc.jarFileName())),\n+                    I18N.format(\"message.advice-header\", I18N.format(\"error.no-main-class-with-main-jar.advice\", appDesc.jarFileName()))\n+            ), result.stderr());\n+\n+            TKit.trace(\"The list of executed commands:\");\n+            executedCommands.forEach(cmdline -> {\n+                TKit.trace(\"  \" + cmdline);\n+            });\n+            TKit.trace(\"Done\");\n+\n+            if (i == 0) {\n+                executedCommands.clear();\n+            }\n+        }\n+\n+        assertEquals(List.of(), executedCommands);\n+        assertEquals(List.of(), script.incompleteMocks());\n+    }\n+\n+    public static List<Object[]> testInitializedOnce() {\n+        return StandardBundlingOperation.ofPlatform(OperatingSystem.current())\n+                .filter(StandardBundlingOperation::isCreateBundle).map(v -> {\n+                    return new Object[] {v};\n+                }).toList();\n+    }\n+\n+    private static Script createMockScript(StandardBundlingOperation op) {\n+\n+        if (op.bundleType() instanceof AppImageBundleType) {\n+            return Script.build().createSequence();\n+        }\n+\n+        switch (op.os()) {\n+            case WINDOWS -> {\n+                return createWinMockScript();\n+            }\n+            case LINUX -> {\n+                return createLinuxMockScript(op.packageType());\n+            }\n+            case MACOS -> {\n+                return createMacMockScript();\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+    private static Script createWinMockScript() {\n+\n+        \/\/ Make \"candle.exe\" and \"light.exe\" always fail.\n+        var candle = ioerror(\"candle-mock\");\n+        var light = ioerror(\"light-mock\");\n+\n+        \/\/ Make the \"wix.exe\" functional.\n+        var wix = CommandActionSpecs.build()\n+                .stdout(\"5.0.2+aa65968c\")\n+                .exit(CommandMockExit.SUCCEED)\n+                .toCommandMockBuilder().name(\"wix-mock\").create();\n+\n+        var script = Script.build()\n+                .map(Script.cmdlineStartsWith(\"candle.exe\"), candle)\n+                .map(Script.cmdlineStartsWith(\"light.exe\"), light)\n+                .map(Script.cmdlineStartsWith(\"wix.exe\"), wix)\n+                .createLoop();\n+\n+        return script;\n+    }\n+\n+    private static Script createMacMockScript() {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        var setfilePaths = (List<Path>)toSupplier(() -> {\n+            return Class.forName(String.join(\".\",\n+                    DefaultBundlingEnvironmentTest.class.getPackageName(),\n+                    \"MacDmgSystemEnvironment\"\n+            )).getDeclaredField(\"SETFILE_KNOWN_PATHS\").get(null);\n+        }).get();\n+\n+        var script = Script.build();\n+\n+        for (var setfilePath: setfilePaths) {\n+            script.map(Script.cmdlineStartsWith(setfilePath), ioerror(setfilePath.toString() + \"-mock\"));\n+        }\n+\n+        script.map(Script.cmdlineStartsWith(\"\/usr\/bin\/xcrun\"), succeed(\"\/usr\/bin\/xcrun-mock\"));\n+\n+        return script.createLoop();\n+    }\n+\n+    private static Script createLinuxMockScript(PackageType pkgType) {\n+\n+        final Map<String, CommandMock> mocks = new HashMap<>();\n+\n+        var script = Script.build();\n+\n+        final Set<String> debCommandNames = Set.of(\"dpkg\", \"dpkg-deb\", \"fakeroot\");\n+        final Set<String> rpmCommandNames = Set.of(\"rpm\", \"rpmbuild\");\n+\n+        final Set<String> succeedCommandNames;\n+        switch (pkgType) {\n+            case StandardPackageType.LINUX_DEB -> {\n+                succeedCommandNames = debCommandNames;\n+                \/\/ Simulate \"dpkg --print-architecture\".\n+                var dpkg = CommandActionSpecs.build()\n+                        .stdout(\"foo-arch\")\n+                        .exit(CommandMockExit.SUCCEED)\n+                        .toCommandMockBuilder().name(\"dpkg-mock\").create();\n+                mocks.put(\"dpkg\", dpkg);\n+            }\n+            case StandardPackageType.LINUX_RPM -> {\n+                succeedCommandNames = rpmCommandNames;\n+                \/\/ Simulate \"rpmbuild --version\" prints the minimal acceptable version.\n+                var rpmbuild = CommandActionSpecs.build()\n+                        .stdout(\"RPM version 4.10\")\n+                        .exit(CommandMockExit.SUCCEED)\n+                        .toCommandMockBuilder().name(\"rpmbuild-mock\").create();\n+                mocks.put(\"rpmbuild\", rpmbuild);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        script.map(Script.cmdlineStartsWith(\"ldd\"), succeed(\"ldd-mock\"));\n+\n+        for (var commandName : succeedCommandNames) {\n+            if (!mocks.containsKey(commandName)) {\n+                mocks.put(commandName, succeed(commandName + \"-mock\"));\n+            }\n+        }\n+\n+        Stream.of(debCommandNames, rpmCommandNames).flatMap(Set::stream).forEach(commandName -> {\n+            var mock = Optional.ofNullable(mocks.get(commandName)).orElseGet(() -> {\n+                return ioerror(commandName + \"-mock\");\n+            });\n+            script.map(Script.cmdlineStartsWith(commandName), mock);\n+        });\n+\n+        return script.createLoop();\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DefaultBundlingEnvironmentTest.java","additions":225,"deletions":2,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.stream.Stream;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-\n-public class EnquoterTest {\n-\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testForShellLiterals(String expected, String input) {\n-        var actual = Enquoter.forShellLiterals().applyTo(input);\n-        assertEquals(expected, actual);\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testForPropertyValues(String expected, String input) {\n-        var actual = Enquoter.forPropertyValues().applyTo(input);\n-        assertEquals(expected, actual);\n-    }\n-\n-    private static Stream<org.junit.jupiter.params.provider.Arguments> testForShellLiterals() {\n-        return Stream.of(\n-                makeArguments(\"''\", \"\"),\n-                makeArguments(\"'foo'\", \"foo\"),\n-                makeArguments(\"' foo '\", \" foo \"),\n-                makeArguments(\"'foo bar'\", \"foo bar\"),\n-                makeArguments(\"'foo\\\\' bar'\", \"foo' bar\")\n-        );\n-    }\n-\n-    private static Stream<org.junit.jupiter.params.provider.Arguments> testForPropertyValues() {\n-        return Stream.of(\n-                makeArguments(\"\", \"\"),\n-                makeArguments(\"foo\", \"foo\"),\n-                makeArguments(\"\\\" foo \\\"\", \" foo \"),\n-                makeArguments(\"\\\"foo bar\\\"\", \"foo bar\"),\n-                makeArguments(\"\\\"foo' bar\\\"\", \"foo' bar\")\n-        );\n-    }\n-\n-    static org.junit.jupiter.params.provider.Arguments makeArguments(Object ... args) {\n-        return org.junit.jupiter.params.provider.Arguments.of(args);\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/EnquoterTest.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedResultException;\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.CommandMockExit;\n+import jdk.jpackage.test.mock.CompletableCommandMock;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class ExecutorTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_retryOnKnownErrorMessage(RetryOnKnownErrorMessageTestSpec test) {\n+        test.run();\n+    }\n+\n+    private static Stream<RetryOnKnownErrorMessageTestSpec> test_retryOnKnownErrorMessage() {\n+        var data = new ArrayList<RetryOnKnownErrorMessageTestSpec.Builder>();\n+\n+        final var subject = \"French fries\";\n+\n+        Supplier<RetryOnKnownErrorMessageTestSpec.Builder> build = () -> {\n+            return RetryOnKnownErrorMessageTestSpec.build().subject(subject);\n+        };\n+\n+        for (var exit : Stream.of(CommandMockExit.values()).filter(CommandMockExit::exitNormally).toList()) {\n+            \/\/ These should succeed as there is no \"French fries\" in stderr.\n+            Stream.of(\n+                    build.get().mock(CommandActionSpecs.build().stderr(\"Coleslaw\").exit(exit)),\n+                    build.get().mock(CommandActionSpecs.build().stdout(subject).exit(exit)),\n+                    build.get()\n+                            \/\/ Fail in the first attempt (triggering text in the stderr)\n+                            .mock(CommandActionSpecs.build().stderr(subject).exit())\n+                            \/\/ Fail in the second attempt (same reason)\n+                            .repeatLastMoc()\n+                            \/\/ Pass in the next attempt (no triggering text in the stderr)\n+                            .mock(CommandActionSpecs.build().stderr(\"Coleslaw\").exit(exit)),\n+                   build.get()\n+                           \/\/ Fail in the first attempt (triggering text in the stderr)\n+                           .mock(CommandActionSpecs.build().stderr(subject))\n+                           \/\/ Fail in the second attempt (error running the command)\n+                           .mock(CommandActionSpecs.build().exit(CommandMockExit.THROW_MOCK_IO_EXCEPTION))\n+                           \/\/ Pass in the next attempt (no triggering text in the stderr)\n+                           .mock(CommandActionSpecs.build().exit(exit))\n+            ).map(RetryOnKnownErrorMessageTestSpec.Builder::success).forEach(data::add);\n+        }\n+\n+        \/\/ These should fail as there is \"French fries\" in stderr.\n+        data.addAll(List.of(\n+                \/\/ Try once and fail.\n+                build.get().mock(CommandActionSpecs.build().stderr(subject).exit()),\n+                \/\/ Try twice and fail.\n+                build.get().mock(CommandActionSpecs.build().stderr(subject).exit()).repeatLastMoc()\n+        ));\n+\n+        return data.stream().map(RetryOnKnownErrorMessageTestSpec.Builder::create);\n+    }\n+\n+    record RetryOnKnownErrorMessageTestSpec(List<CommandActionSpecs> mockSpecs, String subject, boolean success) {\n+\n+        RetryOnKnownErrorMessageTestSpec {\n+            Objects.requireNonNull(mockSpecs);\n+            Objects.requireNonNull(subject);\n+\n+            if (mockSpecs.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        void run() {\n+            var mock = mockSpecs.stream()\n+                    .reduce(CommandActionSpecs::andThen)\n+                    .orElseThrow().toCommandMockBuilder()\n+                    \/\/ Ensure attempts to run the command more times than expected will fail.\n+                    .noRepeats().create();\n+\n+            var retry = new Executor().toolProvider(mock).retryOnKnownErrorMessage(subject)\n+                    .setAttemptTimeout(null)\n+                    .setMaxAttemptsCount(mockSpecs.size());\n+\n+            if (success) {\n+                assertDoesNotThrow(retry::execute);\n+            } else {\n+                assertThrowsExactly(UnexpectedResultException.class, retry::execute);\n+            }\n+\n+            assertTrue(((CompletableCommandMock)mock).completed());\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static final class Builder {\n+\n+            RetryOnKnownErrorMessageTestSpec create() {\n+                return new RetryOnKnownErrorMessageTestSpec(mockSpecs, subject, success);\n+            }\n+\n+            public Builder mock(CommandActionSpecs v) {\n+                mockSpecs.add(Objects.requireNonNull(v));\n+                return this;\n+            }\n+\n+            public Builder mock(CommandActionSpecs.Builder v) {\n+                return mock(v.create());\n+            }\n+\n+            public Builder repeatLastMoc() {\n+                return mock(mockSpecs.getLast());\n+            }\n+\n+            public Builder subject(String v) {\n+                subject = v;\n+                return this;\n+            }\n+\n+            public Builder success(boolean v) {\n+                success = v;\n+                return this;\n+            }\n+\n+            public Builder success() {\n+                return success(true);\n+            }\n+\n+            private final List<CommandActionSpecs> mockSpecs = new ArrayList<>();\n+            private String subject;\n+            private boolean success;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/ExecutorTest.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.io.PrintWriter;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+import java.util.spi.ToolProvider;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.CliBundlingEnvironment;\n+import jdk.jpackage.internal.cli.Main;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.test.mock.Script;\n+import jdk.jpackage.test.mock.ToolProviderCommandMock;\n+import jdk.jpackage.test.mock.VerbatimCommandMock;\n+\n+\/**\n+ * Bridges \"jdk.jpackage.internal\" and \"jdk.jpackage.test.mock\" packages.\n+ *\/\n+public final class MockUtils {\n+\n+    private MockUtils() {\n+    }\n+\n+    public static JPackageToolProviderBuilder buildJPackage() {\n+        return new JPackageToolProviderBuilder();\n+    }\n+\n+    public static final class JPackageToolProviderBuilder {\n+\n+        public ToolProvider create() {\n+            return createJPackageToolProvider(os(), createObjectFactory());\n+        }\n+\n+        public Consumer<Globals> createGlobalsMutator() {\n+            var objectFactory = createObjectFactory();\n+            return globals -> {\n+                globals.objectFactory(objectFactory);\n+            };\n+        }\n+\n+        public void applyToGlobals() {\n+            createGlobalsMutator().accept(Globals.instance());\n+        }\n+\n+        ExecutorFactory createExecutorFactory() {\n+            var commandMocksExecutorFactory = Optional.ofNullable(script).map(MockUtils::withCommandMocks).map(mapper -> {\n+                return mapper.apply(ExecutorFactory.DEFAULT);\n+            }).orElse(ExecutorFactory.DEFAULT);\n+\n+            var recordingExecutorFactory = Optional.ofNullable(listener).map(MockUtils::withCommandListener).map(mapper -> {\n+                return mapper.apply(commandMocksExecutorFactory);\n+            }).orElse(commandMocksExecutorFactory);\n+\n+            return recordingExecutorFactory;\n+        }\n+\n+        ObjectFactory createObjectFactory() {\n+            var executorFactory = createExecutorFactory();\n+            if (executorFactory == ExecutorFactory.DEFAULT) {\n+                return ObjectFactory.DEFAULT;\n+            } else {\n+                return ObjectFactory.build().executorFactory(executorFactory).create();\n+            }\n+        }\n+\n+        public JPackageToolProviderBuilder listener(Consumer<List<String>> v) {\n+            listener = v;\n+            return this;\n+        }\n+\n+        public JPackageToolProviderBuilder script(Script v) {\n+            script = v;\n+            return this;\n+        }\n+\n+        public JPackageToolProviderBuilder os(OperatingSystem v) {\n+            os = v;\n+            return this;\n+        }\n+\n+        private OperatingSystem os() {\n+            return Optional.ofNullable(os).orElseGet(OperatingSystem::current);\n+        }\n+\n+        private Consumer<List<String>> listener;\n+        private OperatingSystem os;\n+        private Script script;\n+    }\n+\n+    public static ToolProvider createJPackageToolProvider(OperatingSystem os, Script script) {\n+        return buildJPackage()\n+                .os(Objects.requireNonNull(os))\n+                .script(Objects.requireNonNull(script))\n+                .create();\n+    }\n+\n+    public static ToolProvider createJPackageToolProvider(Script script) {\n+        return createJPackageToolProvider(OperatingSystem.current(), script);\n+    }\n+\n+    private static UnaryOperator<ExecutorFactory> withCommandListener(Consumer<List<String>> listener) {\n+        Objects.requireNonNull(listener);\n+        return executorFactory -> {\n+            Objects.requireNonNull(executorFactory);\n+            return () -> {\n+                var executor = executorFactory.executor();\n+\n+                Optional<UnaryOperator<Executor>> oldMapper = executor.mapper();\n+\n+                UnaryOperator<Executor> newMapper = exec -> {\n+                    listener.accept(exec.commandLine());\n+                    return exec;\n+                };\n+\n+                return executor.mapper(oldMapper.map(newMapper::compose).orElse(newMapper)::apply);\n+            };\n+        };\n+    }\n+\n+    private static UnaryOperator<ExecutorFactory> withCommandMocks(Script script) {\n+        return executorFactory -> {\n+            Objects.requireNonNull(executorFactory);\n+            return () -> {\n+                var executor = executorFactory.executor();\n+\n+                Optional<UnaryOperator<Executor>> oldMapper = executor.mapper();\n+\n+                UnaryOperator<Executor> newMapper = exec -> {\n+                    var commandLine = exec.commandLine();\n+                    var mock = Objects.requireNonNull(script.map(commandLine));\n+                    switch (mock) {\n+                        case VerbatimCommandMock.INSTANCE -> {\n+                            \/\/ No mock for this command line.\n+                            return exec;\n+                        }\n+                        case ToolProviderCommandMock tp -> {\n+                            \/\/ Create a copy of the executor with the old mapper to prevent further recursion.\n+                            var copy = exec.copy().mapper(oldMapper.orElse(null));\n+                            copy.toolProvider(tp);\n+                            copy.args().clear();\n+                            copy.args(commandLine.subList(1, commandLine.size()));\n+                            return copy;\n+                        }\n+                        default -> {\n+                            \/\/ Unreachable because there are no other cases for this switch.\n+                            throw ExceptionBox.reachedUnreachable();\n+                        }\n+                    }\n+                };\n+\n+                return executor.mapper(oldMapper.map(newMapper::compose).orElse(newMapper)::apply);\n+            };\n+        };\n+    }\n+\n+    public static CliBundlingEnvironment createBundlingEnvironment(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+\n+        String bundlingEnvironmentClassName;\n+        switch (os) {\n+            case WINDOWS -> {\n+                bundlingEnvironmentClassName = \"WinBundlingEnvironment\";\n+            }\n+            case LINUX -> {\n+                bundlingEnvironmentClassName = \"LinuxBundlingEnvironment\";\n+            }\n+            case MACOS -> {\n+                bundlingEnvironmentClassName = \"MacBundlingEnvironment\";\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        return toSupplier(() -> {\n+            var ctor = Class.forName(String.join(\".\",\n+                    DefaultBundlingEnvironment.class.getPackageName(),\n+                    bundlingEnvironmentClassName\n+            )).getConstructor();\n+            return (CliBundlingEnvironment)ctor.newInstance();\n+        }).get();\n+    }\n+\n+    static ToolProvider createJPackageToolProvider(OperatingSystem os, ObjectFactory of) {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(of);\n+\n+        var impl = new Main.Provider(DefaultBundlingEnvironment.runOnce(() -> {\n+            return createBundlingEnvironment(os);\n+        }));\n+\n+        return new ToolProvider() {\n+\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+                return Globals.main(() -> {\n+                    Globals.instance().objectFactory(of);\n+                    return impl.run(out, err, args);\n+                });\n+            }\n+\n+            @Override\n+            public String name() {\n+                return impl.name();\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/MockUtils.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -636,1 +636,6 @@\n-                    new PackageType() {},\n+                    new PackageType() {\n+                        @Override\n+                        public String label() {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    },\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import static jdk.jpackage.internal.model.ExecutableAttributesWithCapturedOutput.augmentResultWithOutput;\n@@ -46,0 +47,1 @@\n+import java.util.spi.ToolProvider;\n@@ -49,0 +51,2 @@\n+import jdk.jpackage.internal.Globals;\n+import jdk.jpackage.internal.MockUtils;\n@@ -50,0 +54,1 @@\n+import jdk.jpackage.internal.model.ExecutableAttributesWithCapturedOutput;\n@@ -51,0 +56,3 @@\n+import jdk.jpackage.internal.util.CommandOutputControl;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedExitCodeException;\n+import jdk.jpackage.internal.util.CommandOutputControl.UnexpectedResultException;\n@@ -52,0 +60,2 @@\n+import jdk.jpackage.test.Annotations;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -54,0 +64,3 @@\n+import jdk.jpackage.test.mock.CommandActionSpecs;\n+import jdk.jpackage.test.mock.Script;\n+import jdk.jpackage.test.mock.VerbatimCommandMock;\n@@ -58,1 +71,1 @@\n-public class MainTest extends JUnitAdapter.TestSrcInitializer {\n+public class MainTest extends JUnitAdapter {\n@@ -81,0 +94,65 @@\n+    \/**\n+     * Run app image packaging and simulate jlink failure.\n+     * <p>\n+     * The test verifies that jpackage prints an error message with jlink exit code,\n+     * command line, and output.\n+     *\/\n+    @Annotations.Test\n+    public void testFailedCommandOutput() {\n+\n+        var jlinkMockExitCode = 17;\n+\n+        var jlinkArgs = new ArrayList<String>();\n+\n+        var jlinkMock = CommandActionSpecs.build()\n+                .stdout(\"It\").stderr(\"fell\").stdout(\"apart\")\n+                .argsListener(jlinkArgs::addAll)\n+                .exit(jlinkMockExitCode).create().toCommandMockBuilder().name(\"jlink-mock\").create();\n+\n+        var script = Script.build()\n+                \/\/ Replace jlink with the mock.\n+                .map(Script.cmdlineStartsWith(\"jlink\"), jlinkMock)\n+                \/\/ Don't mock other external commands.\n+                .map(_ -> true, VerbatimCommandMock.INSTANCE)\n+                .createLoop();\n+\n+        var jpackageExitCode = 1;\n+\n+        var jpackageToolProviderMock = new ToolProvider() {\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+                var globalsMutator = MockUtils.buildJPackage().script(script).createGlobalsMutator();\n+                return Globals.main(() -> {\n+                    globalsMutator.accept(Globals.instance());\n+\n+                    var result = ExecutionResult.create(args);\n+\n+                    var jlinkMockAttrs = new CommandOutputControl.ToolProviderAttributes(jlinkMock.name(), jlinkArgs);\n+\n+                    result.stdout().forEach(out::println);\n+                    result.stderr().forEach(err::println);\n+\n+                    assertEquals(jpackageExitCode, result.exitCode());\n+                    assertEquals(List.of(), result.stdout());\n+                    assertEquals(List.of(\n+                            I18N.format(\"message.error-header\", I18N.format(\"error.command-failed-unexpected-exit-code\",\n+                                    jlinkMockExitCode, jlinkMockAttrs.printableCommandLine())),\n+                            I18N.format(\"message.failed-command-output-header\"),\n+                            \"It\", \"fell\", \"apart\"), result.stderr());\n+\n+                    return jpackageExitCode;\n+                });\n+            }\n+\n+            @Override\n+            public String name() {\n+                return \"jpackage-mock\";\n+            }\n+        };\n+\n+        JPackageCommand.helloAppImage()\n+                .ignoreDefaultVerbose(true)\n+                .useToolProvider(jpackageToolProviderMock)\n+                .execute(jpackageExitCode);\n+    }\n+\n@@ -168,0 +246,43 @@\n+\n+            var execAttrs = new CommandOutputControl.ProcessAttributes(Optional.of(12345L), List.of(\"foo\", \"--bar\"));\n+            for (var makeCause : List.<UnaryOperator<Exception>>of(\n+                    ex -> ex,\n+                    ExceptionBox::toUnchecked\n+            )) {\n+\n+                for (var expect : List.of(\n+                        Map.entry(\n+                                augmentResultWithOutput(\n+                                        CommandOutputControl.Result.build().exitCode(135).execAttrs(execAttrs).create(),\n+                                        \"The quick brown fox\\njumps over the lazy dog\"\n+                                ).unexpected(\"Kaput!\"),\n+                                ExceptionFormatter.FAILED_COMMAND_UNEXPECTED_OUTPUT_MESSAGE\n+                        ),\n+                        Map.entry(\n+                                new UnexpectedExitCodeException(augmentResultWithOutput(\n+                                        CommandOutputControl.Result.build().exitCode(135).create(),\n+                                        \"The quick brown fox\\njumps\"\n+                                )),\n+                                ExceptionFormatter.FAILED_COMMAND_UNEXPECTED_EXIT_CODE_MESSAGE\n+                        ),\n+                        Map.entry(\n+                                augmentResultWithOutput(\n+                                        CommandOutputControl.Result.build().create(),\n+                                        \"The quick brown fox\\njumps\"\n+                                ).unexpected(\"Timed out!\"),\n+                                ExceptionFormatter.FAILED_COMMAND_TIMEDOUT_MESSAGE\n+                        )\n+                )) {\n+                    var cause = makeCause.apply(expect.getKey());\n+                    var expectedOutput = new ArrayList<ExceptionFormatter>();\n+                    if (verbose) {\n+                        expectedOutput.add(ExceptionFormatter.STACK_TRACE);\n+                    }\n+                    expectedOutput.add(expect.getValue());\n+                    if (!verbose) {\n+                        expectedOutput.add(ExceptionFormatter.FAILED_COMMAND_OUTPUT);\n+                    }\n+                    data.add(new ErrorReporterTestSpec(cause, expect.getKey(), verbose, expectedOutput));\n+                }\n+            }\n+\n@@ -353,1 +474,18 @@\n-        })\n+        }),\n+        FAILED_COMMAND_OUTPUT(ex -> {\n+            var result = failedCommandResult(ex);\n+            var commandOutput = ((ExecutableAttributesWithCapturedOutput)result.execAttrs()).printableOutput();\n+\n+            var sink = new StringWriter();\n+            var pw = new PrintWriter(sink);\n+\n+            pw.println(I18N.format(\"message.failed-command-output-header\"));\n+            try (var lines = new BufferedReader(new StringReader(commandOutput)).lines()) {\n+                lines.forEach(pw::println);\n+            }\n+\n+            return sink.toString();\n+        }),\n+        FAILED_COMMAND_UNEXPECTED_OUTPUT_MESSAGE(errorMessage(CommandFailureType.UNEXPECTED_OUTPUT::getMessage)),\n+        FAILED_COMMAND_UNEXPECTED_EXIT_CODE_MESSAGE(errorMessage(CommandFailureType.UNEXPECTED_EXIT_CODE::getMessage)),\n+        FAILED_COMMAND_TIMEDOUT_MESSAGE(errorMessage(CommandFailureType.TIMEDOUT::getMessage)),\n@@ -372,0 +510,36 @@\n+        private static CommandOutputControl.Result failedCommandResult(Exception ex) {\n+            Objects.requireNonNull(ex);\n+            if (ex instanceof UnexpectedResultException urex) {\n+                return urex.getResult();\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private enum CommandFailureType {\n+            UNEXPECTED_OUTPUT,\n+            UNEXPECTED_EXIT_CODE,\n+            TIMEDOUT,\n+            ;\n+\n+            String getMessage(Exception ex) {\n+                var result = failedCommandResult(ex);\n+                var printableCommandLine = result.execAttrs().printableCommandLine();\n+                switch (this) {\n+                    case TIMEDOUT -> {\n+                        return I18N.format(\"error.command-failed-timed-out\", printableCommandLine);\n+                    }\n+                    case UNEXPECTED_EXIT_CODE -> {\n+                        return I18N.format(\"error.command-failed-unexpected-exit-code\", result.getExitCode(), printableCommandLine);\n+                    }\n+                    case UNEXPECTED_OUTPUT -> {\n+                        return I18N.format(\"error.command-failed-unexpected-output\", printableCommandLine);\n+                    }\n+                    default -> {\n+                        \/\/ Unreachable\n+                        throw ExceptionBox.reachedUnreachable();\n+                    }\n+                }\n+            }\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/MainTest.java","additions":177,"deletions":3,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n-ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --foo]; errors=[message.error-header+[error.jlink.failed, Error: unknown option: --foo]])\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.excludes","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,2 @@\n-                JPackageCommand.withToolProvider(jpackageToolProviderMock, () -> {\n+                TKit.withNewState(() -> {\n+                    JPackageCommand.useToolProviderByDefault(jpackageToolProviderMock);\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,2 @@\n+import jdk.jpackage.internal.model.AppImageBundleType;\n+import jdk.jpackage.internal.model.BundleType;\n@@ -178,0 +180,9 @@\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void test_TYPE_valid(OperatingSystem appImageOS) {\n+\n+        var spec = new StandardOptionContext(appImageOS).mapOptionSpec(StandardOption.TYPE.getSpec());\n+\n+        test_TYPE_valid(spec, appImageOS);\n+    }\n+\n@@ -183,5 +194,1 @@\n-        Stream.of(StandardBundlingOperation.values()).forEach(bundlingOperation -> {\n-            var pkgTypeStr = bundlingOperation.packageTypeValue();\n-            var pkgType = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(pkgTypeStr)).orElseThrow();\n-            assertSame(bundlingOperation.packageType(), pkgType);\n-        });\n+        test_TYPE_valid(spec, OperatingSystem.current());\n@@ -339,0 +346,12 @@\n+    private void test_TYPE_valid(OptionSpec<BundleType> spec, OperatingSystem appImageOS) {\n+        Stream.of(StandardBundlingOperation.values()).filter(bundlingOperation -> {\n+            \/\/ Skip app image bundle type if it is from another platform.\n+            return !(bundlingOperation.bundleType() instanceof AppImageBundleType)\n+                    || (bundlingOperation.os() == appImageOS);\n+        }).forEach(bundlingOperation -> {\n+            var bundleTypeStr = bundlingOperation.bundleTypeValue();\n+            var bundleType = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(bundleTypeStr)).orElseThrow();\n+            assertSame(bundlingOperation.bundleType(), bundleType);\n+        });\n+    }\n+\n@@ -344,0 +363,1 @@\n+                Arguments.of(\"  foo \\\"a b c\\\" v=' John Smith ' 'H e ll o' \", List.of(\"foo\", \"a b c\", \"v= John Smith \", \"H e ll o\")),\n@@ -346,1 +366,24 @@\n-                Arguments.of(\"\", List.of())\n+                Arguments.of(\"   \", List.of()),\n+                Arguments.of(\" foo  \", List.of(\"foo\")),\n+                Arguments.of(\"\", List.of()),\n+                Arguments.of(\"'fo\\\"o'\\\\ buzz \\\"b a r\\\"\", List.of(\"fo\\\"o\\\\ buzz\", \"b a r\")),\n+                Arguments.of(\"a\\\\ 'b\\\"c'\\\\ d\", List.of(\"a\\\\ b\\\"c\\\\ d\")),\n+                Arguments.of(\"\\\"a 'bc' d\\\"\", List.of(\"a 'bc' d\")),\n+                Arguments.of(\"\\'a 'bc' d\\'\", List.of(\"a bc d\")),\n+                Arguments.of(\"\\\"a \\\\'bc\\\\' d\\\"\", List.of(\"a 'bc' d\")),\n+                Arguments.of(\"\\'a \\\\'bc\\\\' d\\'\", List.of(\"a 'bc' d\")),\n+                Arguments.of(\"'a b c' 'd e f'\", List.of(\"a b c\", \"d e f\")),\n+                Arguments.of(\"'a b c' \\\"'d e f'  h\", List.of(\"a b c\", \"'d e f'  h\")),\n+                Arguments.of(\"'a b c' \\\"'d e f' \\t  \", List.of(\"a b c\", \"'d e f'\")),\n+                Arguments.of(\" a='' '' \\t '\\\\'\\\\'' \\\"\\\" \\\"\\\\\\\"\\\\\\\"\\\" \", List.of(\"a=\", \"\", \"\\'\\'\", \"\", \"\\\"\\\"\")),\n+                Arguments.of(\"' \\'foo '\", List.of(\" foo\", \"\")),\n+                Arguments.of(\"' \\'foo ' bar\", List.of(\" foo\", \" bar\")),\n+                Arguments.of(\"' \\'foo\\\\ '\", List.of(\" foo\\\\ \")),\n+                Arguments.of(\"'fo\\\"o buzz \\\"b a r\\\"\", List.of(\"fo\\\"o buzz \\\"b a r\\\"\")),\n+                Arguments.of(\"'\", List.of(\"\")),\n+                Arguments.of(\"' f g  \", List.of(\" f g\")),\n+                Arguments.of(\"' f g\", List.of(\" f g\")),\n+                Arguments.of(\"'\\\\'\", List.of(\"'\")),\n+                Arguments.of(\"'\\\\'  \", List.of(\"'\")),\n+                Arguments.of(\"'\\\\' a \", List.of(\"' a\")),\n+                Arguments.of(\"\\\"\" + \"\\\\\\\"\".repeat(10000) + \"A\", List.of(\"\\\"\".repeat(10000) + \"A\"))\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardOptionTest.java","additions":50,"deletions":7,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import jdk.jpackage.internal.cli.Validator.ParsedValue;\n+import jdk.jpackage.internal.cli.Validator.ValidatorException;\n@@ -155,0 +157,25 @@\n+    static final class RecordingValidator<T, U extends Exception> implements Validator<T, U> {\n+\n+        RecordingValidator(Validator<T, U> validator) {\n+            this.validator = Objects.requireNonNull(validator);\n+        }\n+\n+        @Override\n+        public List<U> validate(OptionName optionName, ParsedValue<T> optionValue) {\n+            counter++;\n+            return validator.validate(optionName, optionValue);\n+        }\n+\n+        int counter() {\n+            return counter;\n+        }\n+\n+        void resetCounter() {\n+            counter = 0;\n+        }\n+\n+        private final Validator<T, U> validator;\n+        private int counter;\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/TestUtils.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.Objects;\n@@ -38,0 +37,1 @@\n+import java.util.stream.Stream;\n@@ -39,0 +39,1 @@\n+import jdk.jpackage.internal.cli.TestUtils.RecordingValidator;\n@@ -190,13 +191,1 @@\n-    public void test_andThen() {\n-\n-        Function<String, Validator<String, Exception>> createFailingValidator = exceptionMessage -> {\n-            Objects.requireNonNull(exceptionMessage);\n-            var exceptionFactory = OptionValueExceptionFactory.build().ctor(TestException::new).messageFormatter((_, _) -> {\n-                return exceptionMessage;\n-            }).create();\n-\n-            return Validator.<String, Exception>build()\n-                    .predicate(_ -> false)\n-                    .formatString(\"\")\n-                    .exceptionFactory(exceptionFactory).create();\n-        };\n+    public void test_and() {\n@@ -208,1 +197,1 @@\n-        var pass = Validator.<String, RuntimeException>build().predicate(_ -> true).create();\n+        var pass = new RecordingValidator<>(Validator.<String, RuntimeException>build().predicate(_ -> true).create());\n@@ -210,3 +199,3 @@\n-        var foo = createFailingValidator.apply(\"foo\");\n-        var bar = createFailingValidator.apply(\"bar\");\n-        var buz = createFailingValidator.apply(\"buz\");\n+        var foo = failingValidator(\"foo\");\n+        var bar = failingValidator(\"bar\");\n+        var buz = failingValidator(\"buz\");\n@@ -218,1 +207,2 @@\n-        ),  validate.apply(foo.andThen(bar).andThen(pass).andThen(buz)));\n+        ), validate.apply(foo.and(bar).and(pass).and(buz)));\n+        assertEquals(1, pass.counter());\n@@ -220,0 +210,1 @@\n+        pass.resetCounter();\n@@ -224,1 +215,26 @@\n-        ),  validate.apply(pass.andThen(bar).andThen(buz).andThen(foo)));\n+        ), validate.apply(pass.and(bar).and(buz).and(foo)));\n+        assertEquals(1, pass.counter());\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"foo\")\n+        ), validate.apply(foo.and(foo)));\n+\n+        pass.resetCounter();\n+        assertExceptionListEquals(List.of(\n+        ), validate.apply(pass.and(pass)));\n+        assertEquals(2, pass.counter());\n+    }\n+\n+    @Test\n+    public void test_or() {\n+\n+        Function<Validator<String, ? extends Exception>, List<? extends Exception>> validate = validator -> {\n+            return validator.validate(OptionName.of(\"a\"), ParsedValue.create(\"str\", StringToken.of(\"str\")));\n+        };\n+\n+        var pass = new RecordingValidator<>(Validator.<String, RuntimeException>build().predicate(_ -> true).create());\n+\n+        var foo = new RecordingValidator<>(failingValidator(\"foo\"));\n+        var bar = new RecordingValidator<>(failingValidator(\"bar\"));\n+        var buz = new RecordingValidator<>(failingValidator(\"buz\"));\n@@ -226,0 +242,30 @@\n+        Runnable resetCounters = () -> {\n+            Stream.of(pass, foo, bar, buz).forEach(RecordingValidator::resetCounter);\n+        };\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"bar\"),\n+                new TestException(\"buz\")\n+        ), validate.apply(foo.or(bar).or(buz)));\n+        assertEquals(1, foo.counter());\n+        assertEquals(1, bar.counter());\n+        assertEquals(1, buz.counter());\n+\n+        resetCounters.run();\n+        assertExceptionListEquals(List.of(\n+        ), validate.apply(foo.or(bar).or(pass).or(buz)));\n+        assertEquals(1, foo.counter());\n+        assertEquals(1, bar.counter());\n+        assertEquals(1, pass.counter());\n+        assertEquals(0, buz.counter());\n+\n+        resetCounters.run();\n+        assertExceptionListEquals(List.of(\n+        ), validate.apply(pass.or(bar).or(buz).or(foo)));\n+        assertEquals(1, pass.counter());\n+        assertEquals(0, bar.counter());\n+        assertEquals(0, buz.counter());\n+        assertEquals(0, foo.counter());\n+\n+        resetCounters.run();\n@@ -229,1 +275,7 @@\n-        ),  validate.apply(foo.andThen(foo)));\n+        ), validate.apply(foo.or(foo)));\n+        assertEquals(2, foo.counter());\n+\n+        resetCounters.run();\n+        assertExceptionListEquals(List.of(\n+        ),  validate.apply(pass.or(pass)));\n+        assertEquals(1, pass.counter());\n@@ -272,0 +324,11 @@\n+    private static Validator<String, Exception> failingValidator(String exceptionMessage) {\n+        var exceptionFactory = OptionValueExceptionFactory.build().ctor(TestException::new).messageFormatter((_, _) -> {\n+            return exceptionMessage;\n+        }).create();\n+\n+        return Validator.<String, Exception>build()\n+                .predicate(_ -> false)\n+                .formatString(\"\")\n+                .exceptionFactory(exceptionFactory).create();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/ValidatorTest.java","additions":85,"deletions":22,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,1867 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static java.util.stream.Collectors.joining;\n+import static jdk.jpackage.internal.util.CommandOutputControlTestUtils.isInterleave;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static jdk.jpackage.test.JUnitUtils.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.MessageDigest;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledIf;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.EnumSource.Mode;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class CommandOutputControlTest {\n+\n+    @DisabledIf(\"cherryPickSavedOutputTestCases\")\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSavedOutput(OutputTestSpec spec) {\n+        spec.test();\n+    }\n+\n+    \/**\n+     * Runs cherry-picked {@link OutputTestSpec} test cases.\n+     * <p>\n+     * This test method is mutual exclusive with\n+     * {@link #testSavedOutput(OutputTestSpec)} and is aimed for debugging\n+     * {@code OutputTestSpec} test cases.\n+     * <p>\n+     * It is disabled by default. To enable it, manually edit {@link #testSomeSavedOutput()}.\n+     *\n+     * @see #testSomeSavedOutput()\n+     *\n+     * @param spec the test case\n+     *\/\n+    @EnabledIf(\"cherryPickSavedOutputTestCases\")\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSomeSavedOutput(OutputTestSpec spec) {\n+        System.out.println(spec);\n+        spec.test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testDumpStreams(OutputTestSpec spec) {\n+        spec.test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testCharset(CharsetTestSpec spec) throws IOException, InterruptedException {\n+        spec.test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_description(CommandOutputControlSpec spec) {\n+        \/\/ This test is mostly for coverage.\n+        var desc = spec.create().description();\n+        assertFalse(desc.isBlank());\n+    }\n+\n+    @Test\n+    public void test_copy() {\n+        var orig = new CommandOutputControl();\n+        var copy = orig.copy();\n+        assertNotSame(orig, copy);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names = \"SAVE_NOTHING\", mode = Mode.EXCLUDE)\n+    public void test_flag(OutputControl flag) {\n+        var coc = new CommandOutputControl();\n+        assertFalse(flag.get(coc));\n+        flag.set(coc);\n+        assertTrue(flag.get(coc));\n+        if (flag.canUnset()) {\n+            flag.unset(coc);\n+            assertFalse(flag.get(coc));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_mutual_exclusive_flags(List<OutputControl> controls) {\n+        if (controls.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        var coc = new CommandOutputControl();\n+        for (var c : controls) {\n+            c.set(coc);\n+        }\n+\n+        for (var c : controls.subList(0, controls.size() - 1)) {\n+            assertFalse(c.get(coc));\n+        }\n+        assertTrue(controls.getLast().get(coc));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_ExecutableAttributes(boolean toolProvider) {\n+        var coc = new CommandOutputControl();\n+        CommandOutputControl.Executable exec;\n+        if (toolProvider) {\n+            exec = coc.createExecutable(new ToolProvider() {\n+\n+                @Override\n+                public String name() {\n+                    return \"runme\";\n+                }\n+\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    fail(\"Should never be called\");\n+                    return 0;\n+                }\n+\n+            }, \"--foo\", \"--baz=10\");\n+        } else {\n+            exec = coc.createExecutable(new ProcessBuilder(\"runme\", \"--foo\", \"--baz=10\"));\n+        }\n+\n+        assertEquals(\"runme --foo --baz=10\", exec.attributes().printableCommandLine());\n+    }\n+\n+    @Test\n+    public void test_Result_single_arg_ctor() {\n+        var result = new CommandOutputControl.Result(7);\n+        assertFalse(result.findContent().isPresent());\n+        assertFalse(result.findStdout().isPresent());\n+        assertFalse(result.findStderr().isPresent());\n+        assertEquals(7, result.getExitCode());\n+        assertSame(Objects.requireNonNull(CommandOutputControl.EMPTY_EXECUTABLE_ATTRIBUTES), result.execAttrs());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Result_unexpected(boolean customMessage) throws IOException {\n+        var result = new CommandOutputControl.Result(7);\n+\n+        if (customMessage) {\n+            assertEquals(\"Kaput!\", result.unexpected(\"Kaput!\").getMessage());\n+        } else {\n+            assertEquals(\"Unexpected result from executing the command <unknown>\", result.unexpected().getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void test_Result_expectExitCode() throws IOException {\n+        var result = new CommandOutputControl.Result(7);\n+\n+        assertSame(result, result.expectExitCode(7));\n+        assertSame(result, result.expectExitCode(7, 2));\n+        assertSame(result, result.expectExitCode(2, 7));\n+\n+        assertSame(result, result.expectExitCode(List.of(7)));\n+        assertSame(result, result.expectExitCode(Set.of(7, 2)));\n+        assertSame(result, result.expectExitCode(List.of(2, 7)));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Result_expectExitCode_negative(boolean collection) {\n+        var result = new CommandOutputControl.Result(3);\n+\n+        var ex = assertThrowsExactly(CommandOutputControl.UnexpectedExitCodeException.class, () -> {\n+            if (collection) {\n+                result.expectExitCode(List.of(17, 12));\n+            } else {\n+                result.expectExitCode(17, 12);\n+            }\n+        });\n+\n+        assertNull(ex.getCause());\n+        assertSame(result, ex.getResult());\n+        assertEquals(\"Unexpected exit code 3 from executing the command <unknown>\", ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_Result_toCharacterResult(ToCharacterResultTestSpec spec) throws IOException, InterruptedException {\n+        spec.test();\n+    }\n+\n+    @Test\n+    public void test_Result_toCharacterResult_nop() throws IOException, InterruptedException {\n+\n+        var charset = StandardCharsets.UTF_8;\n+\n+        var emptyResult = new CommandOutputControl.Result(7);\n+        assertSame(emptyResult, emptyResult.toCharacterResult(charset, true));\n+        assertSame(emptyResult, emptyResult.toCharacterResult(charset, false));\n+\n+        var coc = new CommandOutputControl().saveOutput(true);\n+\n+        var result = coc.createExecutable(new Command(List.of(\"foo\"), List.of()).asToolProvider()).execute();\n+\n+        assertSame(result, result.toCharacterResult(charset, true));\n+        assertSame(result, result.toCharacterResult(charset, false));\n+    }\n+\n+    @Test\n+    public void test_Result_toCharacterResult_copyWithExecutableAttributes() {\n+\n+        var empty = new CommandOutputControl.Result(0);\n+\n+        var execAttrs = new CommandOutputControl.ExecutableAttributes() {\n+            @Override\n+            public List<String> commandLine() {\n+                return List.of(\"foo\");\n+            }\n+        };\n+\n+        var copy = empty.copyWithExecutableAttributes(execAttrs);\n+\n+        assertSame(empty.exitCode(), copy.exitCode());\n+        assertSame(empty.output(), copy.output());\n+        assertSame(empty.byteOutput(), copy.byteOutput());\n+        assertSame(execAttrs, copy.execAttrs());\n+    }\n+\n+    @Test\n+    public void test_UnexpectedExitCodeException_no_exit_code() {\n+\n+        var resultWithoutExitCode = CommandOutputControl.Result.build().create();\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            new CommandOutputControl.UnexpectedExitCodeException(resultWithoutExitCode);\n+        });\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            new CommandOutputControl.UnexpectedExitCodeException(resultWithoutExitCode, \"Kaput!\");\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ExecutableType.class)\n+    public void test_timeout_expires(ExecutableType mode) throws InterruptedException, IOException {\n+\n+        final var toolProvider = (mode == ExecutableType.TOOL_PROVIDER);\n+        final var storeOutputInFiles = (mode == ExecutableType.PROCESS_BUILDER_WITH_STREAMS_IN_FILES);\n+\n+        var actions = List.<CommandAction>of(\n+                CommandAction.echoStdout(\"The quick brown fox jumps\"),\n+                CommandAction.sleep(5),\n+                CommandAction.echoStdout(\"over the lazy dog\")\n+        );\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true).storeOutputInFiles(storeOutputInFiles);\n+\n+        CommandOutputControl.Executable exec;\n+\n+        InterruptibleToolProvider tp;\n+\n+        if (toolProvider) {\n+            tp = new InterruptibleToolProvider(Command.createToolProvider(actions));\n+            exec = coc.createExecutable(tp);\n+        } else {\n+            var cmdline = Command.createShellCommandLine(actions);\n+            tp = null;\n+            exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+        }\n+\n+        var result = exec.execute(1, TimeUnit.SECONDS);\n+        assertFalse(result.exitCode().isPresent());\n+\n+        var getExitCodeEx = assertThrowsExactly(IllegalStateException.class, result::getExitCode);\n+        assertEquals((\"Exit code is unavailable for timed-out command\"), getExitCodeEx.getMessage());\n+\n+        \/\/ We want to check that the saved output contains only the text emitted before the \"sleep\" action.\n+        \/\/ It works for a subprocess, but in the case of a ToolProvider, sometimes the timing is such\n+        \/\/ that it gets interrupted before having written anything to the stdout, and the saved output is empty.\n+        \/\/ This happens when the test case is executed together with other test cases\n+        \/\/ and never when it is executed individually.\n+        if (!toolProvider || !result.content().isEmpty()) {\n+            assertEquals(List.of(\"The quick brown fox jumps\"), result.content());\n+        }\n+\n+        if (toolProvider) {\n+            assertTrue(tp.interrupted());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_timeout(boolean toolProvider) throws InterruptedException, IOException {\n+\n+        var actions = List.<CommandAction>of(\n+                CommandAction.echoStdout(\"Sphinx of black quartz,\"),\n+                CommandAction.echoStdout(\"judge my vow\")\n+        );\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true);\n+\n+        CommandOutputControl.Executable exec;\n+\n+        if (toolProvider) {\n+            var tp = Command.createToolProvider(actions);\n+            exec = coc.createExecutable(tp);\n+        } else {\n+            var cmdline = Command.createShellCommandLine(actions);\n+            exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+        }\n+\n+        var result = exec.execute(10, TimeUnit.SECONDS);\n+        assertTrue(result.exitCode().isPresent());\n+        assertEquals(List.of(\"Sphinx of black quartz,\", \"judge my vow\"), result.content());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_passthrough_exceptions(boolean withTimeout) throws IOException {\n+\n+        var expected = new RuntimeException(\"Kaput!\");\n+\n+        var exec = new CommandOutputControl().createExecutable(new ToolProvider() {\n+\n+            @Override\n+            public String name() {\n+                return \"foo\";\n+            }\n+\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+                throw expected;\n+            }\n+        });\n+\n+        var actual = assertThrowsExactly(expected.getClass(), () -> {\n+            if (withTimeout) {\n+                exec.execute(10, TimeUnit.SECONDS);\n+            } else {\n+                exec.execute();\n+            }\n+        });\n+\n+        assertSame(expected, actual);\n+    }\n+\n+    @Test\n+    public void test_externally_terminated() throws InterruptedException, IOException {\n+        var cmdline = Command.createShellCommandLine(List.<CommandAction>of(\n+                CommandAction.echoStderr(\"The five boxing wizards\"),\n+                CommandAction.sleep(10),\n+                CommandAction.echoStderr(\"jump quickly\")\n+        ));\n+\n+        var processDestroyer = Slot.<CompletableFuture<Void>>createEmpty();\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true).processListener(process -> {\n+            \/\/ Once we are notified the process has been started, schedule its destruction.\n+            \/\/ Give it a second to warm up and print some output and then destroy it.\n+            processDestroyer.set(CompletableFuture.runAsync(toRunnable(() -> {\n+                Thread.sleep(Duration.ofSeconds(1));\n+                \/\/ On Windows, CommandAction#sleep is implemented with the \"ping\" command.\n+                \/\/ By some reason, when the parent \"cmd\" process is destroyed,\n+                \/\/ the child \"ping\" command stays alive, and the test waits when it completes,\n+                \/\/ making it last for at least 10 seconds.\n+                \/\/ To optimize the test work time, destroy the entire subprocess tree.\n+                \/\/ Even though this is essential on Windows keep this logic on all platforms for simplicity.\n+                var descendants = List.<ProcessHandle>of();\n+                try (var descendantsStream = process.descendants()) {\n+                    descendants = descendantsStream.toList();\n+                } finally {\n+                    process.destroyForcibly();\n+                }\n+                descendants.forEach(ProcessHandle::destroyForcibly);\n+            })));\n+        });\n+        var exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+\n+        var result = exec.execute();\n+        assertNotEquals(0, result.getExitCode());\n+        assertEquals(List.of(\"The five boxing wizards\"), result.content());\n+        processDestroyer.get().join();\n+    }\n+\n+    @DisabledOnOs(value = OS.MAC, disabledReason = \"Closing a stream doesn't consistently cause a trouble as it should\")\n+    @ParameterizedTest\n+    @EnumSource(OutputStreams.class)\n+    public void test_close_streams(OutputStreams action) throws InterruptedException, IOException {\n+        var cmdline = Command.createShellCommandLine(List.<CommandAction>of(\n+                CommandAction.echoStdout(\"Hello stdout\"),\n+                CommandAction.echoStderr(\"Bye stderr\")\n+        ));\n+\n+        var coc = new CommandOutputControl().saveOutput(true).dumpOutput(true).processListener(toConsumer(process -> {\n+            \/\/ Close process output stream(s). This should make corresponding stream gobbler(s) throw IOException.\n+            switch (action) {\n+                case STDOUT -> {\n+                    process.getInputStream().close();\n+                }\n+                case STDERR -> {\n+                    process.getErrorStream().close();\n+                }\n+                case STDOUT_AND_STDERR -> {\n+                    process.getInputStream().close();\n+                    process.getErrorStream().close();\n+                }\n+            }\n+        }));\n+        var exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+\n+        var ex = assertThrows(IOException.class, exec::execute);\n+        System.out.println(\"test_close_streams: \" + action);\n+        ex.printStackTrace(System.out);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_interleaved(boolean customDumpStreams) throws IOException, InterruptedException {\n+        var cmdline = Command.createShellCommandLine(List.<CommandAction>of(\n+                CommandAction.echoStdout(\"Eat some more\"),\n+                CommandAction.echoStderr(\"of these\"),\n+                CommandAction.echoStdout(\"soft French pastries\"),\n+                CommandAction.echoStderr(\"and drink some tea\")\n+        ));\n+\n+        var coc = new CommandOutputControl();\n+        var exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+\n+        coc.saveOutput(true).dumpOutput(true);\n+\n+        CommandOutputControl.Result result;\n+\n+        if (customDumpStreams) {\n+            \/\/ Execute the command so that its stdout and stderr are dumped to the same sink.\n+            var sink = new ByteArrayOutputStream();\n+            var ps = new PrintStream(sink);\n+\n+            coc.dumpStdout(ps).dumpStderr(ps);\n+\n+            result = exec.execute();\n+\n+            var commandStdout = List.of(\"Eat some more\", \"soft French pastries\");\n+            var commandStderr = List.of(\"of these\", \"and drink some tea\");\n+\n+            var sinkContent = toStringList(sink.toByteArray(), StandardCharsets.US_ASCII);\n+\n+            if (!isInterleave(sinkContent, commandStdout, commandStderr)) {\n+                fail(String.format(\"Unexpected combined output=%s; stdout=%s; stderr=%s\",\n+                        sinkContent, commandStdout, commandStderr));\n+            }\n+\n+            \/\/ CommandOutputControl was not configured to redirect stderr in stdout,\n+            \/\/ hence the output is ordered: stdout goes first, stderr follows.\n+            assertEquals(Stream.of(commandStdout, commandStderr).flatMap(List::stream).toList(), result.content());\n+\n+            \/\/ Saved stdout an stderr can be accessed individually.\n+            assertEquals(commandStdout, result.stdout());\n+            assertEquals(commandStderr, result.stderr());\n+        } else {\n+            \/\/ Execute the command so that its stdout and stderr are dumped into System.out.\n+            coc.redirectStderr(true);\n+            result = exec.execute();\n+\n+            \/\/ CommandOutputControl was configured to redirect stderr in stdout,\n+            \/\/ hence the output is interleaved.\n+            assertEquals(List.of(\"Eat some more\", \"of these\", \"soft French pastries\", \"and drink some tea\"), result.content());\n+\n+            \/\/ Saved stdout an stderr can NOT be accessed individually because they are interleaved.\n+            assertTrue(result.findStdout().isEmpty());\n+            assertTrue(result.findStderr().isEmpty());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true})\n+    public void stressTest(boolean binaryOutput, @TempDir Path workDir) throws Exception {\n+\n+        \/\/ Execute multiple subprocesses asynchronously.\n+        \/\/ Each subprocess writes a few chunks of data each larger than the default buffer size (8192 bytes)\n+\n+        final var chunkCount = 5;\n+        final var subprocessCount = 100;\n+        final var subprocessExecutor = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        final var md = MessageDigest.getInstance(\"MD5\");\n+\n+        var cmdline = Command.createShellCommandLine(IntStream.range(0, chunkCount).mapToObj(chunk -> {\n+            byte[] bytes = new byte[10 * 1024]; \/\/ 10K to exceed the default BufferedOutputStream's buffer size of 8192.\n+            new Random().nextBytes(bytes);\n+            md.update(bytes);\n+            var path = workDir.resolve(Integer.toString(chunk));\n+            try {\n+                Files.write(path, bytes);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            return path;\n+        }).map(CommandAction::cat).toList());\n+\n+        final var digest = HexFormat.of().formatHex(md.digest());\n+\n+        \/\/ Schedule to start every subprocess in a separate virtual thread.\n+        \/\/ Start and suspend threads, waiting until all scheduled threads have started.\n+        \/\/ After all scheduled threads start, resume them.\n+        \/\/ This should result in starting all scheduled subprocesses simultaneously.\n+\n+        var readyLatch = new CountDownLatch(subprocessCount);\n+        var startLatch = new CountDownLatch(1);\n+\n+        var futures = IntStream.range(0, subprocessCount).mapToObj(_ -> {\n+            return CompletableFuture.supplyAsync(toSupplier(() -> {\n+\n+                var exec = new CommandOutputControl()\n+                        .saveOutput(true)\n+                        .binaryOutput(binaryOutput)\n+                        .createExecutable(new ProcessBuilder(cmdline));\n+\n+                readyLatch.countDown();\n+                startLatch.await();\n+\n+                var result = exec.execute();\n+\n+                var localMd = MessageDigest.getInstance(\"MD5\");\n+                localMd.update(result.byteContent());\n+\n+                return HexFormat.of().formatHex(localMd.digest());\n+\n+            }), subprocessExecutor);\n+        }).toList();\n+\n+        readyLatch.await();\n+        startLatch.countDown();\n+\n+        CompletableFuture.allOf(futures.toArray(CompletableFuture[]::new)).join();\n+\n+        futures.forEach(future -> {\n+            var actualDigest = future.join();\n+            assertEquals(digest, actualDigest);\n+        });\n+    }\n+\n+    public enum OutputStreams {\n+        STDOUT,\n+        STDERR,\n+        STDOUT_AND_STDERR\n+    }\n+\n+    private static List<CommandOutputControlSpec> test_description() {\n+        List<CommandOutputControlSpec> testCases = new ArrayList<>();\n+        testCases.add(new CommandOutputControlSpec(Set.of()));\n+        for (var outputControl : OutputControl.variants()) {\n+            testCases.add(new CommandOutputControlSpec(outputControl));\n+        }\n+        return testCases;\n+    }\n+\n+    private static List<List<OutputControl>> test_mutual_exclusive_flags() {\n+        List<List<OutputControl>> data = new ArrayList<>();\n+\n+        var flags = List.of(OutputControl.SAVE_ALL, OutputControl.SAVE_FIRST_LINE, OutputControl.SAVE_NOTHING);\n+\n+        List<OutputControl> seq = new ArrayList<>();\n+        for (var _1 : flags) {\n+            seq.add(_1);\n+            var flags2 = flags.stream().filter(Predicate.isEqual(_1).negate()).toList();\n+            for (var _2 : flags2) {\n+                seq.add(_2);\n+                var flags3 = flags2.stream().filter(Predicate.isEqual(_2).negate()).toList();\n+                for (var _3 : flags3) {\n+                    seq.add(_3);\n+                    data.add(List.copyOf(seq));\n+                    seq.removeLast();\n+                }\n+                seq.removeLast();\n+            }\n+            seq.removeLast();\n+        }\n+\n+        return data;\n+    }\n+\n+    public record ToCharacterResultTestSpec(OutputTestSpec execSpec, boolean keepByteContent) {\n+\n+        public ToCharacterResultTestSpec {\n+            Objects.requireNonNull(execSpec);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final List<String> tokens = new ArrayList<>();\n+\n+            tokens.add(execSpec.toString());\n+            if (keepByteContent) {\n+                tokens.add(\"keepByteContent\");\n+            }\n+\n+            return String.join(\", \", tokens.toArray(String[]::new));\n+        }\n+\n+        void test() throws IOException, InterruptedException {\n+            var coc = execSpec.cocSpec().create();\n+\n+            var command = execSpec.commandSpec().command().asToolProvider();\n+\n+            var expected = coc.binaryOutput(false).createExecutable(command).execute();\n+\n+            var byteResult = coc.binaryOutput(true).createExecutable(command).execute();\n+\n+            var actual = byteResult.toCharacterResult(coc.charset(), keepByteContent);\n+\n+            CommandOutputControl.Result expectedByteContent;\n+            if (keepByteContent) {\n+                expectedByteContent = byteResult;\n+            } else {\n+                expectedByteContent = expected;\n+            }\n+\n+            assertArrayEquals(expectedByteContent.findByteContent().orElse(null), actual.findByteContent().orElse(null));\n+            assertArrayEquals(expectedByteContent.findByteStdout().orElse(null), actual.findByteStdout().orElse(null));\n+            assertArrayEquals(expectedByteContent.findByteStderr().orElse(null), actual.findByteStderr().orElse(null));\n+\n+            assertEquals(expected.findContent(), actual.findContent());\n+            assertEquals(expected.findStdout(), actual.findStdout());\n+            assertEquals(expected.findStderr(), actual.findStderr());\n+\n+            assertSame(byteResult.execAttrs(), actual.execAttrs());\n+            assertEquals(expected.exitCode(), actual.exitCode());\n+        }\n+    }\n+\n+    private static Stream<ToCharacterResultTestSpec> test_Result_toCharacterResult() {\n+        List<OutputTestSpec> testCases = new ArrayList<>();\n+\n+        var skip = Set.of(OutputControl.BINARY_OUTPUT, OutputControl.DUMP, OutputControl.SAVE_FIRST_LINE);\n+\n+        for (var outputControl : OutputControl.variants().stream().filter(spec -> {\n+            return !skip.stream().anyMatch(spec::contains);\n+        }).toList()) {\n+            for (var stdoutContent : List.of(OutputData.EMPTY, OutputData.MANY)) {\n+                for (var stderrContent : List.of(OutputData.EMPTY, OutputData.MANY)) {\n+                    var commandSpec = new CommandSpec(stdoutContent, stderrContent);\n+                    testCases.add(new OutputTestSpec(false, new CommandOutputControlSpec(outputControl), commandSpec));\n+                }\n+            }\n+        }\n+\n+        return testCases.stream().flatMap(execSpec -> {\n+            return Stream.of(true, false).map(keepByteContent -> {\n+                return new ToCharacterResultTestSpec(execSpec, keepByteContent);\n+            });\n+        });\n+    }\n+\n+    private static boolean cherryPickSavedOutputTestCases() {\n+        return !testSomeSavedOutput().isEmpty();\n+    }\n+\n+    \/**\n+     * Returns test cases for {@link #testSomeSavedOutput(OutputTestSpec)}.\n+     * <p>\n+     * Aimed to simplify debugging of {@link #OutputTestSpec} test cases.\n+     * <p>\n+     * The total number of {@code #OutputTestSpec} test cases is ~1500. When some\n+     * fail and need debugging, it is a waste of time to run them all. This method\n+     * allows running only selected test cases. It works this way:\n+     * <ul>\n+     * <li>Run CommandOutputControlTest test.\n+     * <li>If some {@linke #testSavedOutput(OutputTestSpec)} invocations fail,\n+     * capture their IDs (test case ID is an index starting from 1).\n+     * <li>Replace \"\/* 10, 67, 456 *&#47;\" comment in the body of this method with\n+     * the captured test case IDs.\n+     * <li>Rerun CommandOutputControlTest test. This time, it will run\n+     * {@link #testSomeSavedOutput(OutputTestSpec)} method instead of\n+     * {@link #testSavedOutput(OutputTestSpec)} with the list of the captured test\n+     * case IDs.\n+     * <\/ul>\n+     *\/\n+    private static List<OutputTestSpec> testSomeSavedOutput() {\n+        var testIds = List.<Integer>of(\/* 10, 67, 456 *\/);\n+        if (testIds.isEmpty()) {\n+            return List.of();\n+        } else {\n+            var allTestCases = testSavedOutput();\n+            return testIds.stream().map(testId -> {\n+                return allTestCases.get(testId - 1);\n+            }).toList();\n+        }\n+    }\n+\n+    private static List<OutputTestSpec> testSavedOutput() {\n+        List<OutputTestSpec> testCases = new ArrayList<>();\n+        for (final var executableType : List.of(ExecutableType.values())) {\n+            for (var outputControl : OutputControl.variants()) {\n+                for (final var stdoutContent : List.of(OutputData.values())) {\n+                    for (final var stderrContent : List.of(OutputData.values())) {\n+\n+                        if (outputControl.contains(OutputControl.BINARY_OUTPUT)\n+                                && (stdoutContent == OutputData.ONE_LINE || stderrContent == OutputData.ONE_LINE)) {\n+                            \/\/ Skip a test case if it runs a command writing\n+                            \/\/ a single line in stdout or stderr, and handles command output as a byte stream.\n+                            \/\/ It duplicates test cases that write multiple lines in stdout or stderr.\n+                            continue;\n+                        }\n+\n+                        final var commandSpec = new CommandSpec(stdoutContent, stderrContent);\n+                        boolean toolProvider;\n+                        switch (executableType) {\n+                            case PROCESS_BUILDER -> {\n+                                toolProvider = false;\n+                            }\n+                            case PROCESS_BUILDER_WITH_STREAMS_IN_FILES -> {\n+                                outputControl = new SetBuilder<OutputControl>()\n+                                        .add(outputControl)\n+                                        .add(OutputControl.STORE_STREAMS_IN_FILES)\n+                                        .create();\n+                                toolProvider = false;\n+                            }\n+                            case TOOL_PROVIDER -> {\n+                                toolProvider = true;\n+                            }\n+                            default -> {\n+                                \/\/ Unreachable\n+                                throw ExceptionBox.reachedUnreachable();\n+                            }\n+                        }\n+                        testCases.add(new OutputTestSpec(\n+                                toolProvider,\n+                                new CommandOutputControlSpec(outputControl),\n+                                commandSpec));\n+                    }\n+                }\n+            }\n+        }\n+        return testCases;\n+    }\n+\n+    private static List<OutputTestSpec> testDumpStreams() {\n+        List<OutputTestSpec> testCases = new ArrayList<>();\n+        final var commandSpec = new CommandSpec(OutputData.MANY, OutputData.MANY);\n+        for (var discardStdout : withAndWithout(OutputControl.DISCARD_STDOUT)) {\n+            for (var discardStderr : withAndWithout(OutputControl.DISCARD_STDERR)) {\n+                for (var redirectStderr : withAndWithout(OutputControl.REDIRECT_STDERR)) {\n+                    for (var binaryOutput : withAndWithout(OutputControl.BINARY_OUTPUT)) {\n+                        for (var dumpStdout : withAndWithout(OutputControl.DUMP_STDOUT_IN_SYSTEM_OUT)) {\n+                            for (var dumpStderr : withAndWithout(OutputControl.DUMP_STDERR_IN_SYSTEM_ERR)) {\n+\n+                                if (dumpStderr.isEmpty() && dumpStdout.isEmpty()) {\n+                                    \/\/ Output dumping disabled\n+                                    continue;\n+                                }\n+\n+                                if (discardStderr.isPresent() && discardStdout.isPresent()) {\n+                                    \/\/ Output dumping enabled, but all stream discarded\n+                                    continue;\n+                                }\n+\n+                                if (dumpStderr.isPresent() == discardStderr.isPresent() && dumpStdout.isEmpty()) {\n+                                    \/\/ Stderr dumping enabled but discarded, stdout dumping disabled\n+                                    continue;\n+                                }\n+\n+                                if (dumpStdout.isPresent() == discardStdout.isPresent() && dumpStderr.isEmpty()) {\n+                                    \/\/ Stdout dumping enabled but discarded, stderr dumping disabled\n+                                    continue;\n+                                }\n+\n+                                final var outputControl = new HashSet<OutputControl>();\n+                                outputControl.add(OutputControl.DUMP);\n+                                discardStdout.ifPresent(outputControl::add);\n+                                discardStderr.ifPresent(outputControl::add);\n+                                redirectStderr.ifPresent(outputControl::add);\n+                                binaryOutput.ifPresent(outputControl::add);\n+                                dumpStdout.ifPresent(outputControl::add);\n+                                dumpStderr.ifPresent(outputControl::add);\n+\n+                                testCases.add(new OutputTestSpec(\n+                                        false,\n+                                        new CommandOutputControlSpec(outputControl),\n+                                        commandSpec));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return testCases;\n+    }\n+\n+    private static List<CharsetTestSpec> testCharset() {\n+        List<CharsetTestSpec> testCases = new ArrayList<>();\n+\n+        for (boolean toolProvider : BOOLEAN_VALUES) {\n+            for (var redirectStderr : withAndWithout(OutputControl.REDIRECT_STDERR)) {\n+                for (var charset : withAndWithout(OutputControl.CHARSET_UTF16LE)) {\n+                    var stdoutSink = new CharsetTestSpec.DumpOutputSink(StandardCharsets.US_ASCII, OutputStreams.STDOUT);\n+                    var stderrSink = new CharsetTestSpec.DumpOutputSink(StandardCharsets.UTF_32LE, OutputStreams.STDERR);\n+                    var outputControl = new HashSet<CommandOutputControlMutator>();\n+                    redirectStderr.ifPresent(outputControl::add);\n+                    charset.ifPresent(outputControl::add);\n+                    outputControl.add(stdoutSink);\n+                    outputControl.add(stderrSink);\n+                    testCases.add(new CharsetTestSpec(toolProvider, new CommandOutputControlSpec(outputControl)));\n+                }\n+            }\n+        }\n+\n+        return testCases;\n+    }\n+\n+    private enum ExecutableType {\n+        TOOL_PROVIDER,\n+        PROCESS_BUILDER,\n+        PROCESS_BUILDER_WITH_STREAMS_IN_FILES,\n+        ;\n+    }\n+\n+    private sealed interface CommandAction {\n+        static SleepCommandAction sleep(int seconds) {\n+            return new SleepCommandAction(seconds);\n+        }\n+\n+        static EchoCommandAction echoStdout(String str) {\n+            return new EchoCommandAction(str, false);\n+        }\n+\n+        static EchoCommandAction echoStderr(String str) {\n+            return new EchoCommandAction(str, true);\n+        }\n+\n+        static WriteCommandAction writeStdout(byte[] binary) {\n+            return new WriteCommandAction(binary, false);\n+        }\n+\n+        static WriteCommandAction writeStderr(byte[] binary) {\n+            return new WriteCommandAction(binary, true);\n+        }\n+\n+        static CatCommandAction cat(Path file) {\n+            return new CatCommandAction(file);\n+        }\n+    }\n+\n+    private record EchoCommandAction(String value, boolean stderr) implements CommandAction {\n+        EchoCommandAction {\n+            Objects.requireNonNull(value);\n+        }\n+    }\n+\n+    private record WriteCommandAction(byte[] value, boolean stderr) implements CommandAction {\n+        WriteCommandAction {\n+            Objects.requireNonNull(value);\n+        }\n+    }\n+\n+    private record CatCommandAction(Path file) implements CommandAction {\n+        CatCommandAction {\n+            Objects.requireNonNull(file);\n+        }\n+    }\n+\n+    private record SleepCommandAction(int seconds) implements CommandAction {\n+        SleepCommandAction {\n+            if (seconds < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private record Command(List<String> stdout, List<String> stderr) {\n+        Command {\n+            stdout.forEach(Objects::requireNonNull);\n+            stderr.forEach(Objects::requireNonNull);\n+        }\n+\n+        List<String> asExecutable() {\n+            return createShellCommandLine(actions());\n+        }\n+\n+        ToolProvider asToolProvider() {\n+            return createToolProvider(actions());\n+        }\n+\n+        \/\/\n+        \/\/ Type of shell for which to create a command line.\n+        \/\/ On Unix it is always the \"sh\".\n+        \/\/ On Windows, it is \"cmd\" by default and \"powershell\" when a command needs to write binary data to output stream(s).\n+        \/\/ Extra complexity on Windows is because \"powershell\" is times slower than \"cmd\",\n+        \/\/ and the latter doesn't support binary output.\n+        \/\/\n+        private enum ShellType {\n+            SH(OperatingSystem.LINUX, OperatingSystem.MACOS),\n+            CMD(OperatingSystem.WINDOWS),\n+            POWERSHELL(OperatingSystem.WINDOWS),\n+            ;\n+\n+            ShellType(OperatingSystem... os) {\n+                if (os.length == 0) {\n+                    throw new IllegalArgumentException();\n+                }\n+                this.os = Set.of(os);\n+            }\n+\n+            boolean isSupportedOnCurrentOS() {\n+                return os.contains(OperatingSystem.current());\n+            }\n+\n+            private final Set<OperatingSystem> os;\n+        }\n+\n+        private List<CommandAction> actions() {\n+            return Stream.<CommandAction>concat(\n+                    stdout.stream().map(CommandAction::echoStdout),\n+                    stderr.stream().map(CommandAction::echoStderr)\n+            ).toList();\n+        }\n+\n+        static List<String> createShellCommandLine(List<? extends CommandAction> actions) {\n+            final var shellType = detectShellType(actions);\n+            final List<String> commandline = new ArrayList<>();\n+            final String commandSeparator;\n+            switch (shellType) {\n+                case SH -> {\n+                    commandline.addAll(List.of(\"sh\", \"-c\"));\n+                    commandSeparator = \" && \";\n+                }\n+                case CMD -> {\n+                    commandline.addAll(List.of(\"cmd\", \"\/C\"));\n+                    commandSeparator = \" && \";\n+                }\n+                case POWERSHELL -> {\n+                    commandline.addAll(List.of(\"powershell\", \"-NoProfile\", \"-Command\"));\n+                    commandSeparator = \"; \";\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+            commandline.add(actions.stream().map(action -> {\n+                return Command.toString(action, shellType);\n+            }).collect(joining(commandSeparator)));\n+            return commandline;\n+        }\n+\n+        static ToolProvider createToolProvider(List<? extends CommandAction> actions) {\n+            var copiedActions = List.copyOf(actions);\n+            return new ToolProvider() {\n+\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public int run(PrintStream out, PrintStream err, String... args) {\n+                    for (var action : copiedActions) {\n+                        switch (action) {\n+                            case EchoCommandAction echo -> {\n+                                if (echo.stderr()) {\n+                                    err.println(echo.value());\n+                                } else {\n+                                    out.println(echo.value());\n+                                }\n+                            }\n+                            case WriteCommandAction write -> {\n+                                try {\n+                                    if (write.stderr()) {\n+                                        err.write(write.value());\n+                                    } else {\n+                                        out.write(write.value());\n+                                    }\n+                                } catch (IOException ex) {\n+                                    throw new UncheckedIOException(ex);\n+                                }\n+                            }\n+                            case SleepCommandAction sleep -> {\n+                                toRunnable(() -> {\n+                                    synchronized (this) {\n+                                        var millis = Duration.ofSeconds(sleep.seconds()).toMillis();\n+                                        this.wait(millis);\n+                                    }\n+                                }).run();\n+                            }\n+                            case CatCommandAction _ -> {\n+                                \/\/ Not used, no point to implement.\n+                                throw new UnsupportedOperationException();\n+                            }\n+                        }\n+                    }\n+                    return 0;\n+                }\n+\n+                @Override\n+                public String name() {\n+                    return \"test\";\n+                }\n+            };\n+        }\n+\n+        private static ShellType detectShellType(List<? extends CommandAction> actions) {\n+            var supportedShellTypes = Stream.of(ShellType.values())\n+                    .filter(ShellType::isSupportedOnCurrentOS)\n+                    .collect(Collectors.toCollection(HashSet::new));\n+            for (var action : actions) {\n+                if (action instanceof WriteCommandAction) {\n+                    supportedShellTypes.remove(ShellType.CMD);\n+                }\n+            }\n+            return supportedShellTypes.stream()\n+                    .sorted(Comparator.comparingInt(Enum::ordinal))\n+                    .findFirst().orElseThrow();\n+        }\n+\n+        private static String toString(CommandAction action, ShellType shellType) {\n+            switch (action) {\n+                case EchoCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+                case WriteCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+                case SleepCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+                case CatCommandAction a -> {\n+                    return toString(a, shellType);\n+                }\n+            }\n+        }\n+\n+        private static String toString(EchoCommandAction echo, ShellType shellType) {\n+            String str;\n+            switch (shellType) {\n+                case SH -> {\n+                    str = \"echo \" + echo.value();\n+                    if (echo.stderr()) {\n+                        str += \">&2\";\n+                    }\n+                }\n+                case CMD -> {\n+                    str = \"(echo \" + echo.value() + \")\";\n+                    if (echo.stderr()) {\n+                        str += \">&2\";\n+                    }\n+                }\n+                case POWERSHELL -> {\n+                    str = String.format(\"[Console]::%s.WriteLine(\\\\\\\"%s\\\\\\\")\",\n+                            echo.stderr() ? \"Error\" : \"Out\", echo.value());\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+            return str;\n+        }\n+\n+        private static String toString(WriteCommandAction write, ShellType shellType) {\n+            String str;\n+            switch (shellType) {\n+                case SH -> {\n+                    \/\/ Convert byte[] to octal string to make it work with POSIX printf.\n+                    \/\/ POSIX printf doesn't recognize hex strings, so can't use handy HexFormat.\n+                    var sb = new StringBuilder();\n+                    sb.append(\"printf \");\n+                    for (var b : write.value()) {\n+                        sb.append(\"\\\\\\\\\").append(Integer.toOctalString(b & 0xFF));\n+                    }\n+                    if (write.stderr()) {\n+                        sb.append(\">&2\");\n+                    }\n+                    str = sb.toString();\n+                }\n+                case CMD -> {\n+                    throw new UnsupportedOperationException(\"Can't output binary data with 'cmd'\");\n+                }\n+                case POWERSHELL -> {\n+                    var base64 = Base64.getEncoder().encodeToString(write.value());\n+                    str = String.format(\n+                            \"$base64 = '%s'; \" +\n+                            \"$bytes = [Convert]::FromBase64String($base64); \" +\n+                            \"[Console]::%s().Write($bytes, 0, $bytes.Length)\",\n+                            base64, write.stderr() ? \"OpenStandardError\" : \"OpenStandardOutput\");\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+            return str;\n+        }\n+\n+        private static String toString(SleepCommandAction sleep, ShellType shellType) {\n+            switch (shellType) {\n+                case SH -> {\n+                    return \"sleep \" + sleep.seconds();\n+                }\n+                case CMD -> {\n+                    \/\/ The standard way to sleep in \"cmd\" is to use the \"ping\" command.\n+                    \/\/ It sends packets every second.\n+                    \/\/ To wait N seconds, it should send N+1 packets.\n+                    \/\/ The \"timeout\" command works only in a console.\n+                    return String.format(\"(ping -n %d localhost > nul)\", sleep.seconds() + 1);\n+                }\n+                case POWERSHELL -> {\n+                    return \"Start-Sleep -Seconds \" + sleep.seconds();\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        private static String toString(CatCommandAction cat, ShellType shellType) {\n+            switch (shellType) {\n+                case SH -> {\n+                    return \"cat \" + cat.file();\n+                }\n+                case CMD -> {\n+                    return \"type \" + cat.file();\n+                }\n+                case POWERSHELL -> {\n+                    \/\/ Not used, no point to implement.\n+                    throw new UnsupportedOperationException();\n+                }\n+                default -> {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    private enum OutputData {\n+        EMPTY(List.of()),\n+        ONE_LINE(List.of(\"Jupiter\")),\n+        MANY(List.of(\"Uranus\", \"Saturn\", \"Earth\"));\n+\n+        OutputData(List<String> data) {\n+            data.forEach(Objects::requireNonNull);\n+            this.data = data;\n+        }\n+\n+        final List<String> data;\n+    }\n+\n+    private record CommandSpec(OutputData stdout, OutputData stderr) {\n+        CommandSpec {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[stdout=%s, stderr=%s]\", stdout, stderr);\n+        }\n+\n+        Command command() {\n+            return new Command(stdout.data.stream().map(line -> {\n+                return \"stdout.\" + line;\n+            }).toList(), stderr.data.stream().map(line -> {\n+                return \"stderr.\" + line;\n+            }).toList());\n+        }\n+    }\n+\n+    public interface CommandOutputControlMutator {\n+        String name();\n+        void mutate(CommandOutputControl coc);\n+\n+        static <T extends CommandOutputControlMutator> Function<T, Set<T>> addToSet(Set<T> set) {\n+            return m -> {\n+                return new SetBuilder<T>().add(set).add(m).create();\n+            };\n+        }\n+    }\n+\n+    public enum OutputControl implements CommandOutputControlMutator {\n+        DUMP(CommandOutputControl::dumpOutput, CommandOutputControl::isDumpOutput),\n+        SAVE_ALL(CommandOutputControl::saveOutput, CommandOutputControl::isSaveOutput),\n+        SAVE_FIRST_LINE(CommandOutputControl::saveFirstLineOfOutput, CommandOutputControl::isSaveFirstLineOfOutput),\n+        SAVE_NOTHING(coc -> {\n+            coc.saveOutput(false);\n+        }, coc -> {\n+            return !coc.isSaveOutput() && !coc.isSaveFirstLineOfOutput();\n+        }),\n+        DISCARD_STDOUT(CommandOutputControl::discardStdout, CommandOutputControl::isDiscardStdout),\n+        DISCARD_STDERR(CommandOutputControl::discardStderr, CommandOutputControl::isDiscardStderr),\n+        REDIRECT_STDERR(CommandOutputControl::redirectStderr, CommandOutputControl::isRedirectStderr),\n+        STORE_STREAMS_IN_FILES(CommandOutputControl::storeOutputInFiles, CommandOutputControl::isStoreOutputInFiles),\n+        BINARY_OUTPUT(CommandOutputControl::binaryOutput, CommandOutputControl::isBinaryOutput),\n+        DUMP_STDOUT_IN_SYSTEM_OUT(coc -> {\n+            coc.dumpStdout(new PrintStreamWrapper(System.out));\n+        }, coc -> {\n+            return coc.dumpStdout() instanceof PrintStreamWrapper;\n+        }),\n+        DUMP_STDERR_IN_SYSTEM_ERR(coc -> {\n+            coc.dumpStderr(new PrintStreamWrapper(System.err));\n+        }, coc -> {\n+            return coc.dumpStderr() instanceof PrintStreamWrapper;\n+        }),\n+        CHARSET_UTF16LE(coc -> {\n+            coc.charset(StandardCharsets.UTF_16LE);\n+        }, coc -> {\n+            return coc.charset() == StandardCharsets.UTF_16LE;\n+        }),\n+        ;\n+\n+        OutputControl(Consumer<CommandOutputControl> setter, Function<CommandOutputControl, Boolean> getter) {\n+            this.setter = Objects.requireNonNull(setter);\n+            this.unsetter = null;\n+            this.getter = Objects.requireNonNull(getter);\n+        }\n+\n+        OutputControl(BiConsumer<CommandOutputControl, Boolean> setter, Function<CommandOutputControl, Boolean> getter) {\n+            Objects.requireNonNull(setter);\n+            this.setter = coc -> {\n+                setter.accept(coc, true);\n+            };\n+            this.unsetter = coc -> {\n+                setter.accept(coc, false);\n+            };\n+            this.getter = Objects.requireNonNull(getter);\n+        }\n+\n+        @Override\n+        public void mutate(CommandOutputControl coc) {\n+            set(coc);\n+        }\n+\n+        CommandOutputControl set(CommandOutputControl coc) {\n+            setter.accept(coc);\n+            return coc;\n+        }\n+\n+        CommandOutputControl unset(CommandOutputControl coc) {\n+            Objects.requireNonNull(unsetter).accept(coc);\n+            return coc;\n+        }\n+\n+        boolean canUnset() {\n+            return unsetter != null;\n+        }\n+\n+        boolean get(CommandOutputControl coc) {\n+            return getter.apply(coc);\n+        }\n+\n+        static List<Set<OutputControl>> variants() {\n+            final List<Set<OutputControl>> variants = new ArrayList<>();\n+            for (final var binaryOutput : withAndWithout(BINARY_OUTPUT)) {\n+                for (final var redirectStderr : withAndWithout(REDIRECT_STDERR)) {\n+                    for (final var withDump : withAndWithout(DUMP)) {\n+                        variants.addAll(Stream.of(\n+                                Set.<OutputControl>of(),\n+                                Set.of(SAVE_ALL),\n+                                Set.of(SAVE_FIRST_LINE),\n+                                Set.of(DISCARD_STDOUT),\n+                                Set.of(DISCARD_STDERR),\n+                                Set.of(SAVE_ALL, DISCARD_STDOUT),\n+                                Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT),\n+                                Set.of(SAVE_ALL, DISCARD_STDERR),\n+                                Set.of(SAVE_FIRST_LINE, DISCARD_STDERR),\n+                                Set.of(SAVE_ALL, DISCARD_STDOUT, DISCARD_STDERR),\n+                                Set.of(SAVE_FIRST_LINE, DISCARD_STDOUT, DISCARD_STDERR)\n+                        ).map(v -> {\n+                            return withDump.map(CommandOutputControlMutator.addToSet(v)).orElse(v);\n+                        }).map(v -> {\n+                            return redirectStderr.filter(_ -> {\n+                                return !v.containsAll(List.of(DISCARD_STDOUT, DISCARD_STDERR));\n+                            }).map(CommandOutputControlMutator.addToSet(v)).orElse(v);\n+                        }).map(v -> {\n+                            return binaryOutput.map(CommandOutputControlMutator.addToSet(v)).orElse(v);\n+                        }).toList());\n+                    }\n+                }\n+            }\n+            return variants.stream().distinct().toList();\n+        }\n+\n+        private static final class PrintStreamWrapper extends PrintStream {\n+            PrintStreamWrapper(PrintStream out) {\n+                super(out, true);\n+            }\n+        }\n+\n+        private final Consumer<CommandOutputControl> setter;\n+        private final Consumer<CommandOutputControl> unsetter;\n+        private final Function<CommandOutputControl, Boolean> getter;\n+\n+        static final Set<OutputControl> SAVE = Set.of(SAVE_ALL, SAVE_FIRST_LINE);\n+    }\n+\n+    public record CommandOutputControlSpec(Set<? extends CommandOutputControlMutator> outputControl) {\n+        public CommandOutputControlSpec {\n+            outputControl.forEach(Objects::requireNonNull);\n+            if (outputControl.containsAll(OutputControl.SAVE)) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return outputControl.stream().map(CommandOutputControlMutator::name).sorted().collect(joining(\"+\"));\n+        }\n+\n+        boolean contains(OutputControl v) {\n+            return outputControl.contains(Objects.requireNonNull(v));\n+        }\n+\n+        boolean dumpOutput() {\n+            return contains(OutputControl.DUMP);\n+        }\n+\n+        boolean saveOutput() {\n+            return !Collections.disjoint(outputControl, OutputControl.SAVE);\n+        }\n+\n+        boolean discardStdout() {\n+            return contains(OutputControl.DISCARD_STDOUT);\n+        }\n+\n+        boolean discardStderr() {\n+            return contains(OutputControl.DISCARD_STDERR);\n+        }\n+\n+        boolean redirectStderr() {\n+            return contains(OutputControl.REDIRECT_STDERR);\n+        }\n+\n+        CommandOutputControl create() {\n+            final CommandOutputControl coc = new CommandOutputControl();\n+            outputControl.forEach(control -> control.mutate(coc));\n+            return coc;\n+        }\n+    }\n+\n+    public record OutputTestSpec(boolean toolProvider, CommandOutputControlSpec cocSpec, CommandSpec commandSpec) {\n+        public OutputTestSpec {\n+            Objects.requireNonNull(cocSpec);\n+            Objects.requireNonNull(commandSpec);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final List<String> tokens = new ArrayList<>();\n+\n+            if (toolProvider) {\n+                tokens.add(\"tool-provider\");\n+            }\n+\n+            tokens.add(\"output=\" + cocSpec.toString());\n+            tokens.add(\"command=\" + commandSpec);\n+\n+            return String.join(\", \", tokens.toArray(String[]::new));\n+        }\n+\n+        void test() {\n+            final var command = commandSpec.command();\n+\n+            final Slot<CommandOutputControl.Result> result = Slot.createEmpty();\n+            final var dumpCapture = DumpCapture.captureDump(toRunnable(() -> {\n+                result.set(createExecutable(command).execute());\n+            }));\n+\n+            assertEquals(0, result.get().getExitCode());\n+\n+            verifyDump(dumpCapture, command);\n+            if (contains(OutputControl.BINARY_OUTPUT)) {\n+                verifyByteResultContent(result.get(), command, StandardCharsets.UTF_8);\n+            } else {\n+                verifyResultContent(result.get(), command);\n+            }\n+        }\n+\n+        private boolean contains(OutputControl v) {\n+            return cocSpec.contains(v);\n+        }\n+\n+        private boolean dumpOutput() {\n+            return cocSpec.dumpOutput();\n+        }\n+\n+        private boolean saveOutput() {\n+            return cocSpec.saveOutput();\n+        }\n+\n+        private boolean discardStdout() {\n+            return cocSpec.discardStdout();\n+        }\n+\n+        private boolean discardStderr() {\n+            return cocSpec.discardStderr();\n+        }\n+\n+        private boolean redirectStderr() {\n+            return cocSpec.redirectStderr();\n+        }\n+\n+        private boolean replaceStdoutWithStderr() {\n+            return redirectStderr() && discardStdout() && !discardStderr();\n+        }\n+\n+        private boolean stdoutInherited() {\n+            if (toolProvider || saveOutput() || replaceStdoutWithStderr()) {\n+                return false;\n+            }\n+            return dumpOutput() && !discardStdout() && !contains(OutputControl.DUMP_STDOUT_IN_SYSTEM_OUT);\n+        }\n+\n+        private boolean stderrInherited() {\n+            if (toolProvider || saveOutput() || redirectStderr()) {\n+                return false;\n+            }\n+            return dumpOutput() && !discardStderr() && !contains(OutputControl.DUMP_STDERR_IN_SYSTEM_ERR);\n+        }\n+\n+        private void verifyDump(DumpCapture dumpCapture, Command command) {\n+            if (!dumpOutput()) {\n+                assertEquals(List.of(), dumpCapture.outLines());\n+                assertEquals(List.of(), dumpCapture.errLines());\n+                return;\n+            }\n+\n+            if (replaceStdoutWithStderr()) {\n+                \/\/ STDERR replaces STDOUT\n+                assertEquals(command.stderr(), dumpCapture.outLines());\n+                assertEquals(List.of(), dumpCapture.errLines());\n+                return;\n+            }\n+\n+            verifyDumpedStdout(dumpCapture, command);\n+            verifyDumpedStderr(dumpCapture, command);\n+        }\n+\n+        private void verifyDumpedStdout(DumpCapture dumpCapture, Command command) {\n+            if (stdoutInherited()) {\n+                \/\/ A subprocess wrote its STDOUT into a file descriptor associated\n+                \/\/ with the Java process's STDOUT, not into System.out. Can't capture it.\n+                assertEquals(List.of(), dumpCapture.outLines());\n+                return;\n+            }\n+\n+            if (redirectStderr() && !discardStderr()) {\n+                \/\/ Interleaved STDOUT and STDERR\n+                if (!isInterleave(dumpCapture.outLines(), command.stdout(), command.stderr())) {\n+                    fail(String.format(\"Unexpected combined output=%s; stdout=%s; stderr=%s\",\n+                            dumpCapture.outLines(), command.stdout(), command.stderr()));\n+                }\n+            } else if (discardStdout()) {\n+                assertEquals(List.of(), dumpCapture.outLines());\n+            } else {\n+                assertEquals(command.stdout(), dumpCapture.outLines());\n+            }\n+        }\n+\n+        private void verifyDumpedStderr(DumpCapture dumpCapture, Command command) {\n+            if (stderrInherited()) {\n+                \/\/ A subprocess wrote its STDERR into a file descriptor associated\n+                \/\/ with the Java process's STDERR, not into System.err. Can't capture it.\n+                assertEquals(List.of(), dumpCapture.errLines());\n+                return;\n+            }\n+\n+            if (redirectStderr() || discardStderr()) {\n+                assertEquals(List.of(), dumpCapture.errLines());\n+            } else {\n+                assertEquals(command.stderr(), dumpCapture.errLines());\n+            }\n+        }\n+\n+        private void verifyResultContent(CommandOutputControl.Result result, Command command) {\n+            Objects.requireNonNull(result);\n+            Objects.requireNonNull(command);\n+\n+            assertTrue(result.findByteContent().isEmpty());\n+            assertTrue(result.findByteStdout().isEmpty());\n+            assertTrue(result.findByteStderr().isEmpty());\n+\n+            if (!saveOutput()) {\n+                assertTrue(result.findContent().isEmpty());\n+                assertTrue(result.findStdout().isEmpty());\n+                assertTrue(result.findStderr().isEmpty());\n+                return;\n+            }\n+\n+            assertTrue(result.findContent().isPresent());\n+\n+            command = filterSavedStreams(command);\n+\n+            var content = result.content();\n+\n+            if (contains(OutputControl.SAVE_FIRST_LINE)) {\n+                assertTrue(content.size() <= 2, String.format(\"The number of saved lines must be less than or equal to two. Actual: %d\", result.content().size()));\n+            }\n+\n+            if (!redirectStderr()) {\n+                var stdout = result.stdout();\n+                var stderr = result.stderr();\n+\n+                assertEquals(command.stdout(), stdout);\n+                assertEquals(command.stderr(), stderr);\n+                assertEquals(Stream.of(\n+                        stdout,\n+                        stderr\n+                ).flatMap(List::stream).toList(), content);\n+            } else {\n+                assertEquals(discardStderr(), result.findStdout().isPresent());\n+                assertTrue(result.findStderr().isEmpty());\n+                if (contains(OutputControl.SAVE_FIRST_LINE)) {\n+                    assertTrue(List.of(command.stdout(), command.stderr()).contains(result.content()),\n+                            String.format(\"Saved content %s is either %s or %s\",\n+                                    content, command.stdout(), command.stderr()));\n+                } else if (contains(OutputControl.SAVE_ALL)) {\n+                    if (!isInterleave(content, command.stdout(), command.stderr())) {\n+                        fail(String.format(\"Unexpected combined saved content=%s; stdout=%s; stderr=%s\",\n+                                content, command.stdout(), command.stderr()));\n+                    }\n+                } else {\n+                    \/\/ Unreachable\n+                    throw ExceptionBox.reachedUnreachable();\n+                }\n+            }\n+        }\n+\n+        private void verifyByteResultContent(CommandOutputControl.Result result, Command command, Charset charset) {\n+            Objects.requireNonNull(result);\n+            Objects.requireNonNull(command);\n+            Objects.requireNonNull(charset);\n+\n+            assertTrue(result.findContent().isEmpty());\n+            assertTrue(result.findStdout().isEmpty());\n+            assertTrue(result.findStderr().isEmpty());\n+\n+            if (!saveOutput()) {\n+                assertTrue(result.findByteContent().isEmpty());\n+                assertTrue(result.findByteStdout().isEmpty());\n+                assertTrue(result.findByteStderr().isEmpty());\n+                return;\n+            }\n+\n+            assertTrue(result.findByteContent().isPresent());\n+\n+            command = filterSavedStreams(command);\n+\n+            if (!redirectStderr()) {\n+                assertEquals(command.stdout(), toStringList(result.byteStdout(), charset));\n+                assertEquals(command.stderr(), toStringList(result.byteStderr(), charset));\n+                assertEquals(Stream.of(\n+                        command.stdout(),\n+                        command.stderr()\n+                ).flatMap(List::stream).toList(), toStringList(result.byteContent(), charset));\n+            } else {\n+                assertEquals(discardStderr(), result.findByteStdout().isPresent());\n+                assertTrue(result.findByteStderr().isEmpty());\n+\n+                var combined = toStringList(result.byteContent(), charset);\n+                if (!isInterleave(combined, command.stdout(), command.stderr())) {\n+                    fail(String.format(\"Unexpected combined saved content=%s; stdout=%s; stderr=%s\",\n+                            combined, command.stdout(), command.stderr()));\n+                }\n+            }\n+        }\n+\n+        private List<String> expectedSavedStream(List<String> commandOutput) {\n+            Objects.requireNonNull(commandOutput);\n+            if (contains(OutputControl.SAVE_ALL) || (contains(OutputControl.SAVE_FIRST_LINE) && contains(OutputControl.BINARY_OUTPUT))) {\n+                return commandOutput;\n+            } else if (contains(OutputControl.SAVE_FIRST_LINE)) {\n+                return commandOutput.stream().findFirst().map(List::of).orElseGet(List::of);\n+            } else {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        private Command filterSavedStreams(Command command) {\n+            return new Command(\n+                    (discardStdout() ? List.of() : expectedSavedStream(command.stdout())),\n+                    (discardStderr() ? List.of() : expectedSavedStream(command.stderr())));\n+        }\n+\n+        private record DumpCapture(byte[] out, byte[] err, Charset outCharset, Charset errCharset) {\n+            DumpCapture {\n+                Objects.requireNonNull(out);\n+                Objects.requireNonNull(err);\n+                Objects.requireNonNull(outCharset);\n+                Objects.requireNonNull(errCharset);\n+            }\n+\n+            List<String> outLines() {\n+                return toStringList(out, outCharset);\n+            }\n+\n+            List<String> errLines() {\n+                return toStringList(err, errCharset);\n+            }\n+\n+            static DumpCapture captureDump(Runnable runnable) {\n+                final var captureOut = new ByteArrayOutputStream();\n+                final var captureErr = new ByteArrayOutputStream();\n+\n+                final var out = System.out;\n+                final var err = System.err;\n+                try {\n+                    final var outCharset = System.out.charset();\n+                    final var errCharset = System.err.charset();\n+                    System.setOut(new PrintStream(captureOut, true, outCharset));\n+                    System.setErr(new PrintStream(captureErr, true, errCharset));\n+                    runnable.run();\n+                    return new DumpCapture(captureOut.toByteArray(), captureErr.toByteArray(), outCharset, errCharset);\n+                } finally {\n+                    try {\n+                        System.setOut(out);\n+                    } finally {\n+                        System.setErr(err);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private CommandOutputControl.Executable createExecutable(Command command) {\n+            final var coc = cocSpec.create();\n+            if (toolProvider) {\n+                return coc.createExecutable(command.asToolProvider());\n+            } else {\n+                return coc.createExecutable(new ProcessBuilder(command.asExecutable()));\n+            }\n+        }\n+    }\n+\n+    record CharsetTestSpec(boolean toolProvider, CommandOutputControlSpec cocSpec) {\n+\n+        void test() throws IOException, InterruptedException {\n+            if (cocSpec.outputControl().stream().noneMatch(DumpOutputSink.class::isInstance)) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            final var expectedString = \"veni-vidi-vici\";\n+\n+            var coc = cocSpec.create().dumpOutput(true);\n+\n+            CommandOutputControl.Executable exec;\n+            if (toolProvider) {\n+                var tp = Command.createToolProvider(Stream.of(expectedString).<CommandAction>mapMulti((str, sink) -> {\n+                    sink.accept(CommandAction.echoStdout(str));\n+                    sink.accept(CommandAction.echoStderr(str));\n+                }).toList());\n+                exec = coc.createExecutable(tp);\n+            } else {\n+                var cmdline = Command.createShellCommandLine(Stream.of(expectedString).map(str -> {\n+                    return (str + System.lineSeparator()).getBytes(coc.charset());\n+                }).<CommandAction>mapMulti((bytes, sink) -> {\n+                    sink.accept(CommandAction.writeStdout(bytes));\n+                    sink.accept(CommandAction.writeStderr(bytes));\n+                }).toList());\n+                exec = coc.createExecutable(new ProcessBuilder(cmdline));\n+            }\n+\n+            exec.execute();\n+\n+            for (var outputContolMutator : cocSpec.outputControl()) {\n+                if (outputContolMutator instanceof DumpOutputSink sink) {\n+                    var actual = sink.lines();\n+                    List<String> expected;\n+                    if (cocSpec.redirectStderr()) {\n+                        switch (sink.streams()) {\n+                            case STDERR -> {\n+                                expected = List.of();\n+                            }\n+                            default -> {\n+                                expected = List.of(expectedString, expectedString);\n+                            }\n+                        }\n+                    } else {\n+                        expected = List.of(expectedString);\n+                    }\n+                    assertEquals(expected, actual);\n+                }\n+            }\n+\n+        }\n+\n+        record DumpOutputSink(Charset charset, ByteArrayOutputStream buffer, OutputStreams streams) implements CommandOutputControlMutator {\n+            DumpOutputSink {\n+                Objects.requireNonNull(charset);\n+                Objects.requireNonNull(buffer);\n+                Objects.requireNonNull(streams);\n+            }\n+\n+            DumpOutputSink(Charset charset, OutputStreams streams) {\n+                this(charset, new ByteArrayOutputStream(), streams);\n+            }\n+\n+            List<String> lines() {\n+                var str = buffer.toString(charset);\n+                return new BufferedReader(new StringReader(str)).lines().toList();\n+            }\n+\n+            @Override\n+            public String name() {\n+                return String.format(\"DUMP-%s-%s\", streams, charset.name());\n+            }\n+\n+            @Override\n+            public void mutate(CommandOutputControl coc) {\n+                var ps = new PrintStream(buffer, false, charset);\n+                switch (streams) {\n+                    case STDOUT -> {\n+                        coc.dumpStdout(ps);\n+                    }\n+                    case STDERR -> {\n+                        coc.dumpStderr(ps);\n+                    }\n+                    case STDOUT_AND_STDERR -> {\n+                        \/\/ Easy to implement, but not used.\n+                        throw new IllegalArgumentException();\n+                    }\n+                    default -> {\n+                        \/\/ Unreachable\n+                        throw ExceptionBox.reachedUnreachable();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final class InterruptibleToolProvider implements ToolProvider {\n+\n+        InterruptibleToolProvider(ToolProvider impl) {\n+            this.impl = impl;\n+        }\n+\n+        @Override\n+        public String name() {\n+            return impl.name();\n+        }\n+\n+        @Override\n+        public int run(PrintStream out, PrintStream err, String... args) {\n+            return run(_ -> {\n+                return impl.run(out, err, args);\n+            }, args);\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            return run(_ -> {\n+                return impl.run(out, err, args);\n+            }, args);\n+        }\n+\n+        boolean interrupted() {\n+            return interrupted.join();\n+        }\n+\n+        private int run(Function<String[], Integer> workload, String... args) {\n+            boolean interruptedValue = false;\n+            try {\n+                return workload.apply(args);\n+            } catch (ExceptionBox ex) {\n+                if (ex.getCause() instanceof InterruptedException) {\n+                    interruptedValue = true;\n+                    return 1;\n+                } else {\n+                    throw ex;\n+                }\n+            } finally {\n+                interrupted.complete(interruptedValue);\n+            }\n+        }\n+\n+        private final ToolProvider impl;\n+        private final CompletableFuture<Boolean> interrupted = new CompletableFuture<>();\n+    }\n+\n+    private static List<String> toStringList(byte[] data, Charset charset) {\n+        try (var bufReader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(data), charset))) {\n+            return bufReader.lines().toList();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static <T> List<Optional<T>> withAndWithout (T value) {\n+        return List.of(Optional.empty(), Optional.of(value));\n+    }\n+\n+    private static final List<Boolean> BOOLEAN_VALUES = List.of(true, false);\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/CommandOutputControlTest.java","additions":1867,"deletions":0,"binary":false,"changes":1867,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class CommandOutputControlTestUtils {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_isInterleave(TestSpec test) {\n+        test.run();\n+    }\n+\n+    private static Stream<TestSpec> test_isInterleave() {\n+        var data = new ArrayList<TestSpec>();\n+\n+        data.addAll(List.of(\n+                interleaved(\"Toaday\", \"Today\", \"a\"),\n+                interleaved(\"Todanaay\", \"Today\", \"ana\"),\n+                interleaved(\"aaaababaaa\", \"aaaba\", \"aabaa\"),\n+                interleaved(\"xxxxxxxxxxxyxxyx\", \"xxxxxxxy\", \"xxxxxyxx\"),\n+                interleaved(\"xyxxxxyxxxxxxxxx\", \"yxxxxxxx\", \"xxxyxxxx\"),\n+                interleaved(\"xxxxxxxyxxxxyxxx\", \"xxxyxxxx\", \"xxxxxxyx\"),\n+                interleaved(\"cbdddcdaadacdbddbdcdddccdabbadba\", \"cdddaaddbcdcdbab\", \"bdcadcbddddcabda\"),\n+                interleaved(\"ddbdcacddddbddbdbddadcaaccdcabab\", \"dbccdddbbddacdaa\", \"ddaddbdddacaccbb\"),\n+                interleaved(\"adccbacbacaacddadddcdbbddbbddddd\", \"acbcaacddddbdbdd\", \"dcabcadadcbdbddd\"),\n+                interleaved(\"abdbdabdaacdcdbddddadbbccddcddac\", \"addbaccbdddbcdda\", \"bbadaddddabcdcdc\"),\n+                interleaved(\"cdaacbddaabdddbddbddbddadbacccdc\", \"dabdadddbddabccc\", \"cacdabdbddbddacd\"),\n+                notInterleaved(\"Toady\", \"Today\", \"a\"),\n+                notInterleaved(\"\", \"Today\", \"a\")\n+        ));\n+\n+        data.addAll(generateTestData(\"abcdefghijklmnopqrstuvwxyz\", 10));\n+        data.addAll(generateTestData(\"xxxxxxxy\", 8));\n+        data.addAll(generateTestData(\"aaabbbcccddddddd\", 50));\n+\n+        return data.stream().flatMap(test -> {\n+            return Stream.of(test, test.flip());\n+        });\n+    }\n+\n+    private static List<TestSpec> generateTestData(String src, int iteration) {\n+\n+        var srcCodePoints = new ArrayList<Integer>();\n+        src.codePoints().mapToObj(Integer::valueOf).forEach(srcCodePoints::add);\n+\n+        var data = new ArrayList<TestSpec>();\n+\n+        Function<List<Integer>, String> toString = codePoints -> {\n+            var arr = codePoints.stream().mapToInt(Integer::intValue).toArray();\n+            return new String(arr, 0, arr.length);\n+        };\n+\n+        for (int i = 0; i < 10; i++) {\n+            Collections.shuffle(srcCodePoints);\n+            var a = List.copyOf(srcCodePoints);\n+\n+            Collections.shuffle(srcCodePoints);\n+            var b = List.copyOf(srcCodePoints);\n+\n+            var zip = new int[srcCodePoints.size() * 2];\n+            for (int codePointIdx = 0; codePointIdx != a.size(); codePointIdx++) {\n+                var dstIdx = codePointIdx * 2;\n+                zip[dstIdx] = a.get(codePointIdx);\n+                zip[dstIdx + 1] = b.get(codePointIdx);\n+            }\n+\n+            data.add(interleaved(toString.apply(Arrays.stream(zip).boxed().toList()), toString.apply(a), toString.apply(b)));\n+        }\n+\n+        return data;\n+    }\n+\n+    public record TestSpec(String combined, String a, String b, boolean expected) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(combined);\n+            Objects.requireNonNull(a);\n+            Objects.requireNonNull(b);\n+        }\n+\n+        TestSpec flip() {\n+            return new TestSpec(combined, b, a, expected);\n+        }\n+\n+        void run() {\n+            assertEquals(expected, isInterleave(\n+                    combined.chars().mapToObj(Integer::valueOf).toList(),\n+                    a.chars().mapToObj(Integer::valueOf).toList(),\n+                    b.chars().mapToObj(Integer::valueOf).toList()),\n+                    String.format(\"combined: %s; a=%s; b=%s\", combined, a, b));\n+        }\n+    }\n+\n+    private static TestSpec interleaved(String combined, String a, String b) {\n+        return new TestSpec(combined, a, b, true);\n+    }\n+\n+    private static TestSpec notInterleaved(String combined, String a, String b) {\n+        return new TestSpec(combined, a, b, false);\n+    }\n+\n+    \/\/ Solves the standard \"Find if a string C is an interleave of strings A and B.\"\n+    \/\/ problem but use containers instead of strings.\n+    static <T> boolean isInterleave(List<T> combined, List<T> a, List<T> b) {\n+\n+        if (a.size() + b.size() != combined.size()) {\n+            return false;\n+        }\n+\n+        final var n = a.size();\n+        final var m = b.size();\n+\n+        var prev = new boolean[m + 1];\n+        final var cur = new boolean[m + 1];\n+\n+        prev[0] = true;\n+\n+        for (int j = 1; j <= m; j++) {\n+            prev[j] = prev[j - 1] && Objects.equals(b.get(j - 1), combined.get(j - 1));\n+        }\n+\n+        for (int i = 1; i <= n; i++) {\n+            cur[0] = prev[0] && Objects.equals(a.get(i - 1), combined.get(i - 1));\n+\n+            for (int j = 1; j <= m; j++) {\n+                int k = i + j;\n+                cur[j] = (prev[j] && Objects.equals(a.get(i - 1), combined.get(k - 1)))\n+                        || (cur[j - 1] && Objects.equals(b.get(j - 1), combined.get(k - 1)));\n+            }\n+\n+            prev = cur.clone();\n+        }\n+\n+        return prev[m];\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/CommandOutputControlTestUtils.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+\n+public class EnquoterTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testForShellLiterals(String expected, String input) {\n+        var actual = Enquoter.forShellLiterals().applyTo(input);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testForPropertyValues(String expected, String input) {\n+        var actual = Enquoter.forPropertyValues().applyTo(input);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testIdentity(String input) {\n+        var actual = Enquoter.identity().applyTo(input);\n+        assertEquals(input, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testIdentity\")\n+    public void testNoEscaper(String input) {\n+        var actual = Enquoter.identity().setEnquotePredicate(_ -> true).applyTo(input);\n+        assertEquals('\"' + input + '\"', actual);\n+    }\n+\n+    private static Stream<Arguments> testForShellLiterals() {\n+        return Stream.of(\n+                Arguments.of(\"''\", \"\"),\n+                Arguments.of(\"'foo'\", \"foo\"),\n+                Arguments.of(\"' foo '\", \" foo \"),\n+                Arguments.of(\"'foo bar'\", \"foo bar\"),\n+                Arguments.of(\"'foo\\\\' bar'\", \"foo' bar\")\n+        );\n+    }\n+\n+    private static Stream<Arguments> testForPropertyValues() {\n+        return Stream.of(\n+                Arguments.of(\"\", \"\"),\n+                Arguments.of(\"foo\", \"foo\"),\n+                Arguments.of(\"\\\" foo \\\"\", \" foo \"),\n+                Arguments.of(\"\\\"foo bar\\\"\", \"foo bar\"),\n+                Arguments.of(\"\\\"foo' bar\\\"\", \"foo' bar\")\n+        );\n+    }\n+\n+    private static Stream<String> testIdentity() {\n+        return Stream.of(\"\", \"foo\", \" foo \", \"foo bar\", \"foo' bar\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/EnquoterTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.RetryExecutor.Context;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class RetryExecutorTest {\n+\n+    @Test\n+    public void test_defaults() {\n+\n+        var executor = new AttemptCounter<Void, Exception>(context -> {\n+            throw new AttemptFailedException();\n+        });\n+\n+        var defaultTimeout = Duration.ofSeconds(2);\n+        var defaultAttemptCount = 5;\n+\n+        var timeout = Slot.<Duration>createEmpty();\n+\n+        assertThrowsExactly(AttemptFailedException.class, new RetryExecutor<Void, Exception>(Exception.class)\n+                .setExecutable(executor)\n+                .setSleepFunction(t -> {\n+                    assertEquals(defaultTimeout, t);\n+                    timeout.set(t);\n+                    return;\n+                })::execute);\n+\n+        assertEquals(defaultTimeout, timeout.get());\n+        assertEquals(defaultAttemptCount, executor.count());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2, 3, -4})\n+    public void test_N_attempts_fail(int maxAttemptsCount) throws AttemptFailedException {\n+\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class)\n+                .setMaxAttemptsCount(maxAttemptsCount)\n+                .setAttemptTimeout(null)\n+                .setExecutable(context -> {\n+                    if (context.attempt() == (maxAttemptsCount - 1)) {\n+                        assertTrue(context.isLastAttempt());\n+                    } else {\n+                        assertFalse(context.isLastAttempt());\n+                    }\n+                    throw new AttemptFailedException(\"Attempt: \" + context.attempt());\n+                });\n+\n+        if (maxAttemptsCount <= 0) {\n+            assertNull(retry.execute());\n+        } else {\n+            var ex = assertThrowsExactly(AttemptFailedException.class, retry::execute);\n+            assertEquals(\"Attempt: \" + (maxAttemptsCount - 1), ex.getMessage());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {1, 2, 3})\n+    public void test_N_attempts_last_succeed(int maxAttemptsCount) throws AttemptFailedException {\n+        test_N_attempts_M_succeed(maxAttemptsCount, maxAttemptsCount - 1, false);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {2, 3})\n+    public void test_N_attempts_first_succeed(int maxAttemptsCount) throws AttemptFailedException {\n+        test_N_attempts_M_succeed(maxAttemptsCount, 0, false);\n+    }\n+\n+    @Test\n+    public void test_N_attempts_2nd_succeed() throws AttemptFailedException {\n+        test_N_attempts_M_succeed(4, 1, false);\n+    }\n+\n+    @Test\n+    public void test_N_attempts_2nd_succeed_unchecked() throws AttemptFailedException {\n+        test_N_attempts_M_succeed(4, 1, true);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_null_executor(boolean dynamic) {\n+        var retry = new RetryExecutor<Void, AttemptFailedException>(AttemptFailedException.class)\n+                .setAttemptTimeout(null).setMaxAttemptsCount(1000);\n+\n+        if (dynamic) {\n+            int maxAttemptsCount = 3;\n+            var executor = new AttemptCounter<Void, AttemptFailedException>(context -> {\n+                assertTrue(context.attempt() <= (maxAttemptsCount - 1));\n+                if (context.attempt() == (maxAttemptsCount - 1)) {\n+                    context.executor().setExecutable((ThrowingSupplier<Void, AttemptFailedException>)null);\n+                }\n+                throw new AttemptFailedException(\"foo\");\n+            });\n+\n+            retry.setExecutable(executor);\n+\n+            var ex = assertThrowsExactly(IllegalStateException.class, retry::execute);\n+            assertEquals(\"No executable\", ex.getMessage());\n+            assertEquals(3, executor.count());\n+        } else {\n+            var ex = assertThrowsExactly(IllegalStateException.class, retry::execute);\n+            assertEquals(\"No executable\", ex.getMessage());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_unexpected_exception(boolean executeUnchecked) {\n+        var cause = new UnsupportedOperationException(\"foo\");\n+\n+        var executor = new AttemptCounter<Void, IOException>(context -> {\n+            assertEquals(0, context.attempt());\n+            throw cause;\n+        });\n+\n+        var retry = new RetryExecutor<Void, IOException>(IOException.class).setExecutable(executor)\n+                .setMaxAttemptsCount(10).setAttemptTimeout(null);\n+\n+        UnsupportedOperationException ex;\n+        if (executeUnchecked) {\n+            ex = assertThrowsExactly(UnsupportedOperationException.class, retry::executeUnchecked);\n+        } else {\n+            ex = assertThrowsExactly(UnsupportedOperationException.class, retry::execute);\n+        }\n+        assertSame(cause, ex);\n+        assertEquals(1, executor.count());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_dynamic(boolean abort) {\n+        int maxAttemptsCount = 4;\n+\n+        var secondExecutor = new AttemptCounter<String, AttemptFailedException>(context -> {\n+            throw new AttemptFailedException(\"bar\");\n+        });\n+\n+        var firstExecutor = new AttemptCounter<String, AttemptFailedException>(context -> {\n+            assertTrue(context.attempt() <= (maxAttemptsCount - 1));\n+            if (context.attempt() == (maxAttemptsCount - 1)) {\n+                if (abort) {\n+                    context.executor().setMaxAttemptsCount(maxAttemptsCount);\n+                } else {\n+                    \/\/ Let it go two more times.\n+                    context.executor().setMaxAttemptsCount(maxAttemptsCount + 2);\n+                }\n+                context.executor().setExecutable(secondExecutor);\n+            }\n+            throw new AttemptFailedException(\"foo\");\n+        });\n+\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class)\n+                .setExecutable(firstExecutor)\n+                .setMaxAttemptsCount(1000000)\n+                .setAttemptTimeout(null);\n+\n+        var ex = assertThrowsExactly(AttemptFailedException.class, retry::execute);\n+        if (abort) {\n+            assertEquals(\"foo\", ex.getMessage());\n+            assertEquals(0, secondExecutor.count());\n+        } else {\n+            assertEquals(\"bar\", ex.getMessage());\n+            assertEquals(2, secondExecutor.count());\n+        }\n+        assertEquals(maxAttemptsCount, firstExecutor.count());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_supplier_executor(boolean isNull) throws Exception {\n+        var retry = new RetryExecutor<String, Exception>(Exception.class).setMaxAttemptsCount(1);\n+        if (isNull) {\n+            retry.setExecutable((ThrowingSupplier<String, Exception>)null);\n+            var ex = assertThrowsExactly(IllegalStateException.class, retry::execute);\n+            assertEquals(\"No executable\", ex.getMessage());\n+        } else {\n+            retry.setExecutable(() -> \"Hello\");\n+            assertEquals(\"Hello\", retry.execute());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_executeUnchecked_fail(boolean withExceptionMapper) throws AttemptFailedException {\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class).setExecutable(() -> {\n+            throw new AttemptFailedException(\"kaput!\");\n+        }).setMaxAttemptsCount(1);\n+\n+        Class<? extends Exception> expectedExceptionType;\n+        if (withExceptionMapper) {\n+            retry.setExceptionMapper((AttemptFailedException ex) -> {\n+                assertEquals(\"kaput!\", ex.getMessage());\n+                return new UncheckedAttemptFailedException(ex);\n+            });\n+            expectedExceptionType = UncheckedAttemptFailedException.class;\n+        } else {\n+            expectedExceptionType = ExceptionBox.class;\n+        }\n+\n+        var ex = assertThrowsExactly(expectedExceptionType, retry::executeUnchecked);\n+        assertEquals(AttemptFailedException.class, ex.getCause().getClass());\n+        assertEquals(\"kaput!\", ex.getCause().getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_setSleepFunction(boolean withTimeout) {\n+\n+        var timeout = Slot.<Duration>createEmpty();\n+\n+        assertDoesNotThrow(new RetryExecutor<Void, AttemptFailedException>(AttemptFailedException.class)\n+                .setMaxAttemptsCount(2)\n+                .mutate(retry -> {\n+                    if (withTimeout) {\n+                        retry.setAttemptTimeout(Duration.ofDays(100));\n+                    } else {\n+                        retry.setAttemptTimeout(null);\n+                    }\n+                })\n+                .setExecutable(context -> {\n+                    if (context.isLastAttempt()) {\n+                        return null;\n+                    } else {\n+                        throw new AttemptFailedException();\n+                    }\n+                })\n+                .setSleepFunction(timeout::set)::execute);\n+\n+        assertEquals(withTimeout, timeout.find().isPresent());\n+        if (withTimeout) {\n+            assertEquals(Duration.ofDays(100), timeout.get());\n+        }\n+    }\n+\n+    private static void test_N_attempts_M_succeed(int maxAttempts, int failedAttempts, boolean unchecked) throws AttemptFailedException {\n+\n+        var countingExecutor = new AttemptCounter<String, AttemptFailedException>(context -> {\n+            if (context.attempt() == failedAttempts) {\n+                return \"You made it!\";\n+            } else {\n+                throw new AttemptFailedException();\n+            }\n+        });\n+\n+        var retry = new RetryExecutor<String, AttemptFailedException>(AttemptFailedException.class)\n+                .setMaxAttemptsCount(maxAttempts)\n+                .setAttemptTimeout(null)\n+                .setExecutable(countingExecutor);\n+\n+        assertEquals(\"You made it!\", unchecked ? retry.execute() : retry.executeUnchecked());\n+        assertEquals(failedAttempts, countingExecutor.count() - 1);\n+    }\n+\n+    private static final class AttemptCounter<T, E extends Exception> implements ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> {\n+\n+        AttemptCounter(ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> impl) {\n+            this.impl = Objects.requireNonNull(impl);\n+        }\n+\n+        @Override\n+        public T apply(Context<RetryExecutor<T, E>> context) throws E {\n+            counter++;\n+            return impl.apply(context);\n+        }\n+\n+        int count() {\n+            return counter;\n+        }\n+\n+        private int counter;\n+        private final ThrowingFunction<Context<RetryExecutor<T, E>>, T, E> impl;\n+    }\n+\n+    private static final class AttemptFailedException extends Exception {\n+\n+        AttemptFailedException(String msg) {\n+            super(msg);\n+        }\n+\n+        AttemptFailedException() {\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    private static final class UncheckedAttemptFailedException extends RuntimeException {\n+\n+        UncheckedAttemptFailedException(AttemptFailedException ex) {\n+            super(ex);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/RetryExecutorTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -37,0 +36,1 @@\n+import jdk.jpackage.internal.util.TeeOutputStream;\n@@ -73,3 +73,7 @@\n-        try (PrintStream ps = new PrintStream(buf, true, StandardCharsets.UTF_8)) {\n-            TKit.withExtraLogStream(runnable, ps);\n-        }\n+        var ps = new PrintStream(buf, false, TKit.state().out().charset());\n+\n+        final var out = new PrintStream(new TeeOutputStream(List.of(TKit.state().out(), ps)), true, ps.charset());\n+\n+        TKit.withOutput(runnable, out, TKit.state().err());\n+\n+        ps.flush();\n@@ -78,1 +82,1 @@\n-                final var reader = new InputStreamReader(in, StandardCharsets.UTF_8);\n+                final var reader = new InputStreamReader(in, ps.charset());\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,1 @@\n-        var appVerifier = HelloApp.assertMainLauncher(cmd);\n-        if (appVerifier != null) {\n+        HelloApp.assertMainLauncher(cmd).ifPresent(appVerifier -> {\n@@ -56,1 +55,1 @@\n-        }\n+        });\n@@ -64,2 +63,1 @@\n-        var appVerifier = HelloApp.assertMainLauncher(cmd);\n-        if (appVerifier != null) {\n+        HelloApp.assertMainLauncher(cmd).ifPresent(appVerifier -> {\n@@ -68,1 +66,1 @@\n-        }\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/ArgumentsFilteringTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,1 @@\n-        org.w3c.dom.Document doc\n-                = b.parse(Files.newInputStream(distributionFile));\n+        org.w3c.dom.Document doc = b.parse(distributionFile.toFile());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/HostArchPkgTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -136,2 +137,1 @@\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\");\n-        Files.createFile(appImageDir.resolve(\"foo\"));\n+        Path appImageDir = createInvalidAppImage();\n@@ -148,2 +148,1 @@\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\");\n-        Files.createFile(appImageDir.resolve(\"foo\"));\n+        Path appImageDir = createInvalidAppImage();\n@@ -230,0 +229,15 @@\n+    private static Path createInvalidAppImage() throws IOException {\n+        Path appImageDir = TKit.createTempDirectory(\"appimage\");\n+        if (TKit.isOSX()) {\n+            \/\/ Create minimal macOS bundle to prevent jpackage bail out early\n+            \/\/ with \"error.parameter-not-mac-bundle\" error.\n+            var bundle = new MacBundle(appImageDir);\n+            Files.createDirectories(bundle.macOsDir());\n+            Files.createFile(bundle.infoPlistFile());\n+        } else {\n+            Files.createFile(appImageDir.resolve(\"foo\"));\n+        }\n+\n+        return appImageDir;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.io.PrintWriter;\n@@ -37,1 +36,0 @@\n-import java.util.spi.ToolProvider;\n@@ -39,1 +37,0 @@\n-import jdk.jpackage.internal.util.function.ThrowingRunnable;\n@@ -45,1 +42,0 @@\n-import jdk.jpackage.test.JavaTool;\n@@ -69,1 +65,1 @@\n-        APP_JAR.set(HelloApp.createBundle(JavaAppDesc.parse(\"Hello!\"), TKit.workDir()));\n+        var appJar = HelloApp.createBundle(JavaAppDesc.parse(\"Hello!\"), TKit.workDir());\n@@ -72,1 +68,1 @@\n-        \/\/ Run test cases from InternalAsyncTest class asynchronously.\n+        \/\/ Run test cases from AsyncInnerTest class asynchronously.\n@@ -82,2 +78,0 @@\n-            var runArg = String.format(\"--jpt-run=%s\", AsyncInnerTest.class.getName());\n-\n@@ -87,3 +81,1 @@\n-                    consumer.accept(new Workload(() -> {\n-                        Main.main(runArg, String.format(\"--jpt-include=%s\", id));\n-                    }, id));\n+                    consumer.accept(new Workload(id, appJar));\n@@ -102,4 +94,2 @@\n-                TKit.trace(String.format(\"[%s] STDOUT BEGIN\\n%s\", result.id(), result.stdoutBuffer()));\n-                TKit.trace(String.format(\"[%s] STDOUT END\", result.id()));\n-                TKit.trace(String.format(\"[%s] STDERR BEGIN\\n%s\", result.id(), result.stderrBuffer()));\n-                TKit.trace(String.format(\"[%s] STDERR END\", result.id()));\n+                TKit.trace(String.format(\"[%s] OUTPUT BEGIN\\n%s\", result.testCaseId(), result.testOutput()));\n+                TKit.trace(String.format(\"[%s] OUTPUT END\", result.testCaseId()));\n@@ -145,1 +135,1 @@\n-    private record Result(String stdoutBuffer, String stderrBuffer, String id, Optional<Exception> exception) {\n+    private record Result(String testOutput, String testCaseId, Optional<Exception> exception) {\n@@ -148,3 +138,2 @@\n-            Objects.requireNonNull(stdoutBuffer);\n-            Objects.requireNonNull(stderrBuffer);\n-            Objects.requireNonNull(id);\n+            Objects.requireNonNull(testOutput);\n+            Objects.requireNonNull(testCaseId);\n@@ -157,4 +146,3 @@\n-            ByteArrayOutputStream stdoutBuffer,\n-            ByteArrayOutputStream stderrBuffer,\n-            ThrowingRunnable<? extends Exception> runnable,\n-            String id) implements Callable<Result>  {\n+            String testCaseId,\n+            ByteArrayOutputStream outputSink,\n+            Path appJar) implements Callable<Result> {\n@@ -163,8 +151,3 @@\n-            Objects.requireNonNull(stdoutBuffer);\n-            Objects.requireNonNull(stderrBuffer);\n-            Objects.requireNonNull(runnable);\n-            Objects.requireNonNull(id);\n-        }\n-\n-        Workload(ThrowingRunnable<? extends Exception> runnable, String id) {\n-            this(new ByteArrayOutputStream(), new ByteArrayOutputStream(), runnable, id);\n+            Objects.requireNonNull(testCaseId);\n+            Objects.requireNonNull(outputSink);\n+            Objects.requireNonNull(appJar);\n@@ -173,2 +156,2 @@\n-        private String stdoutBufferAsString() {\n-            return new String(stdoutBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        Workload(String testCaseId, Path appJar) {\n+            this(testCaseId, new ByteArrayOutputStream(), appJar);\n@@ -177,2 +160,2 @@\n-        private String stderrBufferAsString() {\n-            return new String(stderrBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        private String testOutput() {\n+            return new String(outputSink.toByteArray(), StandardCharsets.UTF_8);\n@@ -183,20 +166,1 @@\n-            \/\/ Reset the current test inherited in the state from the parent thread.\n-            TKit.state(DEFAULT_STATE);\n-\n-            var defaultToolProvider = JavaTool.JPACKAGE.asToolProvider();\n-\n-            JPackageCommand.useToolProviderByDefault(new ToolProvider() {\n-\n-                @Override\n-                public int run(PrintWriter out, PrintWriter err, String... args) {\n-                    try (var bufOut = new PrintWriter(stdoutBuffer, true, StandardCharsets.UTF_8);\n-                            var bufErr = new PrintWriter(stderrBuffer, true, StandardCharsets.UTF_8)) {\n-                        return defaultToolProvider.run(bufOut, bufErr, args);\n-                    }\n-                }\n-\n-                @Override\n-                public String name() {\n-                    return defaultToolProvider.name();\n-                }\n-            });\n+            var runArg = String.format(\"--jpt-run=%s\", AsyncInnerTest.class.getName());\n@@ -205,5 +169,9 @@\n-            try (var bufOut = new PrintStream(stdoutBuffer, true, StandardCharsets.UTF_8);\n-                    var bufErr = new PrintStream(stderrBuffer, true, StandardCharsets.UTF_8)) {\n-                TKit.withStackTraceStream(() -> {\n-                    TKit.withMainLogStream(runnable, bufOut);\n-                }, bufErr);\n+            try {\n+                try (var out = new PrintStream(outputSink, false, System.out.charset())) {\n+                    ScopedValue.where(APP_JAR, appJar).run(() -> {\n+                        TKit.withOutput(() -> {\n+                            JPackageCommand.useToolProviderByDefault();\n+                            Main.main(\"--jpt-ignore-logfile\", runArg, String.format(\"--jpt-include=%s\", testCaseId));\n+                        }, out, out);\n+                    });\n+                }\n@@ -213,1 +181,1 @@\n-            return new Result(stdoutBufferAsString(), stderrBufferAsString(), id, err);\n+            return new Result(testOutput(), testCaseId, err);\n@@ -217,1 +185,0 @@\n-\n@@ -219,2 +186,1 @@\n-    private static final TKit.State DEFAULT_STATE = TKit.state();\n-    private static final InheritableThreadLocal<Path> APP_JAR = new InheritableThreadLocal<>();\n+    private static final ScopedValue<Path> APP_JAR = ScopedValue.newInstance();\n","filename":"test\/jdk\/tools\/jpackage\/share\/AsyncTest.java","additions":31,"deletions":65,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE;\n@@ -35,0 +36,1 @@\n+import java.util.function.Consumer;\n@@ -44,0 +46,1 @@\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -179,8 +182,3 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public void testVerbose() {\n-        JPackageCommand cmd = JPackageCommand.helloAppImage()\n-                \/\/ Disable default logic adding `--verbose` option\n-                \/\/ to jpackage command line.\n-                .ignoreDefaultVerbose(true)\n-                .saveConsoleOutput(true)\n-                .setFakeRuntime().executePrerequisiteActions();\n+    @Parameter(\"false\")\n+    @Parameter(\"true\")\n+    public void testQuiet(boolean appImage) {\n@@ -188,12 +186,3 @@\n-        List<String> expectedVerboseOutputStrings = new ArrayList<>();\n-        expectedVerboseOutputStrings.add(\"Creating app package:\");\n-        if (TKit.isWindows()) {\n-            expectedVerboseOutputStrings.add(\n-                    \"Succeeded in building Windows Application Image package\");\n-        } else if (TKit.isLinux()) {\n-            expectedVerboseOutputStrings.add(\n-                    \"Succeeded in building Linux Application Image package\");\n-        } else if (TKit.isOSX()) {\n-            expectedVerboseOutputStrings.add(\"Preparing Info.plist:\");\n-            expectedVerboseOutputStrings.add(\n-                    \"Succeeded in building Mac Application Image package\");\n+        ConfigurationTarget target;\n+        if (appImage) {\n+            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n@@ -201,1 +190,1 @@\n-            TKit.throwUnknownPlatformError();\n+            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n@@ -204,3 +193,7 @@\n-        TKit.deleteDirectoryContentsRecursive(cmd.outputDir());\n-        List<String> nonVerboseOutput = cmd.execute().getOutput();\n-        List<String>[] verboseOutput = (List<String>[])new List<?>[1];\n+        target.addInitializer(cmd -> {\n+            \/\/ Disable the default logic adding `--verbose` option to jpackage command line.\n+            cmd.ignoreDefaultVerbose(true)\n+            .useToolProvider(true)\n+            .saveConsoleOutput(true)\n+            .setFakeRuntime();\n+        });\n@@ -208,8 +201,9 @@\n-        \/\/ Directory clean up is not 100% reliable on Windows because of\n-        \/\/ antivirus software that can lock .exe files. Setup\n-        \/\/ different output directory instead of cleaning the default one for\n-        \/\/ verbose jpackage run.\n-        TKit.withTempDirectory(\"verbose-output\", tempDir -> {\n-            cmd.setArgumentValue(\"--dest\", tempDir);\n-            cmd.addArgument(\"--verbose\");\n-            verboseOutput[0] = cmd.execute().getOutput();\n+        Consumer<Executor.Result> asserter = result -> {\n+            TKit.assertStringListEquals(List.of(), result.getOutput(), \"Check output is empty\");\n+        };\n+\n+        target.cmd().map(JPackageCommand::execute).ifPresent(asserter);\n+        target.test().ifPresent(test -> {\n+            test.addBundleVerifier((_, result) -> {\n+                asserter.accept(result);\n+            }).run(CREATE);\n@@ -217,0 +211,21 @@\n+    }\n+\n+    @Test\n+    @Parameter(\"false\")\n+    @Parameter(\"true\")\n+    public void testVerbose(boolean appImage) {\n+\n+        ConfigurationTarget target;\n+        if (appImage) {\n+            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n+        } else {\n+            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n+        }\n+\n+        target.addInitializer(cmd -> {\n+            \/\/ Disable the default logic adding `--verbose` option to jpackage command line.\n+            cmd.ignoreDefaultVerbose(true)\n+                    .useToolProvider(true)\n+                    .addArgument(\"--verbose\")\n+                    .saveConsoleOutput(true)\n+                    .setFakeRuntime();\n@@ -218,2 +233,10 @@\n-        TKit.assertTrue(nonVerboseOutput.size() < verboseOutput[0].size(),\n-                \"Check verbose output is longer than regular\");\n+            List<CannedFormattedString> verboseContent;\n+            if (appImage) {\n+                verboseContent = List.of(\n+                        JPackageStringBundle.MAIN.cannedFormattedString(\"message.create-app-image\"),\n+                        JPackageStringBundle.MAIN.cannedFormattedString(\"message.app-image-created\"));\n+            } else {\n+                verboseContent = List.of(\n+                        JPackageStringBundle.MAIN.cannedFormattedString(\"message.create-package\"),\n+                        JPackageStringBundle.MAIN.cannedFormattedString(\"message.package-created\"));\n+            }\n@@ -221,4 +244,1 @@\n-        expectedVerboseOutputStrings.forEach(str -> {\n-            TKit.assertTextStream(str).label(\"regular output\")\n-                    .predicate(String::contains).negate()\n-                    .apply(nonVerboseOutput);\n+            cmd.validateOutput(verboseContent.toArray(CannedFormattedString[]::new));\n@@ -227,3 +247,3 @@\n-        expectedVerboseOutputStrings.forEach(str -> {\n-            TKit.assertTextStream(str).label(\"verbose output\")\n-                    .apply(verboseOutput[0]);\n+        target.cmd().ifPresent(JPackageCommand::execute);\n+        target.test().ifPresent(test -> {\n+            test.run(CREATE);\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":62,"deletions":42,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -444,4 +444,1 @@\n-                    .error(\"ERR_CannotParseOptions\", \"foo\"),\n-            \/\/ invalid jlink option\n-            testSpec().addArgs(\"--jlink-options\", \"--foo\")\n-                    .error(\"error.jlink.failed\", \"Error: unknown option: --foo\")\n+                    .error(\"ERR_CannotParseOptions\", \"foo\")\n@@ -649,1 +646,6 @@\n-                        .error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\")\n+                        .error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"),\n+                \/\/ Predefined app image must be a valid macOS bundle.\n+                testSpec().noAppDesc().nativeType().addArgs(\"--app-image\", Token.EMPTY_DIR.token())\n+                        .error(\"error.parameter-not-mac-bundle\", JPackageCommand.cannedArgument(cmd -> {\n+                            return Path.of(cmd.getArgumentValue(\"--app-image\"));\n+                        }, Token.EMPTY_DIR.token()), \"--app-image\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+ * For DMG license should be displayed on command line when \"hdiutil attach\"\n+ * is called.\n+ *\n@@ -99,0 +102,1 @@\n+        initMacDmgLicenseVerifier(test.forTypes(PackageType.MAC_DMG));\n@@ -134,0 +138,27 @@\n+    private static PackageTest initMacDmgLicenseVerifier(PackageTest test) {\n+        return test\n+        .addBundleVerifier(cmd -> {\n+            verifyLicenseFileInDMGPackage(cmd);\n+        });\n+    }\n+\n+    private static void verifyLicenseFileInDMGPackage(JPackageCommand cmd)\n+            throws IOException {\n+        \/\/ DMG should have license, so attach with \"no\", since we only need license.\n+        \/\/ With \"no\" attach will be canceled.\n+        final var attachExec = Executor.of(\"sh\", \"-c\", String.join(\" \",\n+                \"no\",\n+                \"|\",\n+                \"\/usr\/bin\/hdiutil\",\n+                \"attach\",\n+                JPackageCommand.escapeAndJoin(cmd.outputBundle().toString())\n+        )).saveOutput().storeOutputInFiles();\n+\n+        \/\/ Expected exit code is 1, since we canceling license.\n+        final var attachResult = attachExec.executeAndRepeatUntilExitCode(1, 10, 6);\n+        TKit.assertStringListEquals(Files.readAllLines(LICENSE_FILE),\n+                attachResult.stdout(), String.format(\n+                \"Check output of \\\"hdiutil attach\\\" has the same license as contents of source license file [%s]\",\n+                LICENSE_FILE));\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/LicenseTest.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,2 +243,1 @@\n-            var appVerifier = HelloApp.assertMainLauncher(cmd);\n-            if (appVerifier != null) {\n+            HelloApp.assertMainLauncher(cmd).ifPresent(appVerifier -> {\n@@ -252,1 +251,1 @@\n-            }\n+            });\n","filename":"test\/jdk\/tools\/jpackage\/share\/MainClassTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.spi.ToolProvider;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.JavaTool;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Test how jpackage handles errors writing output bundle\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror OutputErrorTest.java\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=OutputErrorTest\n+ *\/\n+\n+public final class OutputErrorTest {\n+\n+    @Test\n+    @Parameter(\"DIR\")\n+    \/\/ \"Locked file error\" reliably works only on Windows\n+    @Parameter(value = \"LOCKED_FILE\", ifOS = OperatingSystem.WINDOWS)\n+    public void testPackage(ExistingOutputBundleType existingOutputBundleType) {\n+\n+        new PackageTest().configureHelloApp().addInitializer(cmd -> {\n+\n+            cmd.setFakeRuntime();\n+            cmd.setArgumentValue(\"--dest\", TKit.createTempDirectory(\"output\"));\n+            cmd.removeOldOutputBundle(false);\n+            cmd.validateOutput(JPackageCommand.makeError(JPackageStringBundle.MAIN.cannedFormattedString(\n+                    \"error.output-bundle-cannot-be-overwritten\", cmd.outputBundle().toAbsolutePath())));\n+\n+            var outputBundle = cmd.outputBundle();\n+\n+            switch (existingOutputBundleType) {\n+                case DIR -> {\n+                    Files.createDirectories(outputBundle);\n+                    Files.writeString(outputBundle.resolve(\"foo.txt\"), \"Hello\");\n+                }\n+                case LOCKED_FILE -> {\n+                    Files.writeString(outputBundle, \"Hello\");\n+                    cmd.useToolProvider(createToolProviderWithLockedFile(\n+                            JavaTool.JPACKAGE.asToolProvider(), outputBundle));\n+                }\n+            }\n+\n+        }).setExpectedExitCode(1).run();\n+    }\n+\n+    enum ExistingOutputBundleType {\n+        DIR,\n+        LOCKED_FILE,\n+        ;\n+    }\n+\n+    private static ToolProvider createToolProviderWithLockedFile(ToolProvider tp, Path lockedFile) {\n+        Objects.requireNonNull(tp);\n+        if (!Files.isRegularFile(lockedFile)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new ToolProvider() {\n+\n+            @Override\n+            public String name() {\n+                return \"jpackage-mock\";\n+            }\n+\n+            @SuppressWarnings(\"try\")\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+                try {\n+                    var lastModifiedTime = Files.getLastModifiedTime(lockedFile);\n+                    try (var fos = new FileOutputStream(lockedFile.toFile()); var lock = fos.getChannel().lock()) {\n+                        Files.setLastModifiedTime(lockedFile, lastModifiedTime);\n+                        return tp.run(out, err, args);\n+                    }\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/OutputErrorTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,1 +232,1 @@\n-            final var imageDir = result.stdout().getOutput().stream().map(String::stripLeading).filter(str -> {\n+            final var imageDir = result.stdout().stream().map(String::stripLeading).filter(str -> {\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n-\n@@ -27,0 +25,3 @@\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n@@ -30,0 +31,1 @@\n+import jdk.jpackage.test.TKit;\n@@ -49,1 +51,1 @@\n-    public void test() throws InterruptedException {\n+    public void test() throws InterruptedException, ExecutionException {\n@@ -57,0 +59,3 @@\n+        var state = TKit.state();\n+        var f = new CompletableFuture<Process>();\n+\n@@ -59,1 +64,3 @@\n-            HelloApp.executeLauncher(cmd);\n+            TKit.withState(() -> {\n+                HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n+            }, state);\n@@ -62,2 +69,13 @@\n-        \/\/ Wait a bit to let the app start\n-        Thread.sleep(Duration.ofSeconds(10));\n+        var mainLauncherProcess = f.get();\n+\n+        Optional<ProcessHandle> childProcess = Optional.empty();\n+\n+        try {\n+            \/\/ Wait a bit to let the app start\n+            Thread.sleep(Duration.ofSeconds(10));\n+\n+            try (var children = mainLauncherProcess.children()) {\n+                childProcess = children.filter(p -> {\n+                    return mainLauncherProcess.info().command().equals(p.info().command());\n+                }).findFirst();\n+            }\n@@ -65,2 +83,6 @@\n-        \/\/ Find the main app launcher process and kill it\n-        killAppLauncherProcess(cmd, null, 2);\n+            TKit.assertTrue(childProcess.isPresent(),\n+                    String.format(\"Check the main launcher process with PID=%d restarted\", mainLauncherProcess.pid()));\n+        } finally {\n+            \/\/ Kill the main app launcher process\n+            TKit.trace(\"About to kill the main launcher process...\");\n+            mainLauncherProcess.destroyForcibly();\n@@ -68,2 +90,2 @@\n-        \/\/ Wait a bit and check if child app launcher process is still running (it must NOT)\n-        Thread.sleep(Duration.ofSeconds(5));\n+            \/\/ Wait a bit and check if child app launcher process is still running (it must NOT)\n+            Thread.sleep(Duration.ofSeconds(5));\n@@ -71,1 +93,5 @@\n-        killAppLauncherProcess(cmd, null, 0);\n+            childProcess.ifPresent(p -> {\n+                TKit.assertTrue(!p.isAlive(), String.format(\n+                        \"Check restarted main launcher process with PID=%d is not alive\", p.pid()));\n+            });\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8301247Test.java","additions":38,"deletions":12,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import static jdk.jpackage.test.WindowsHelper.killProcess;\n@@ -55,1 +54,1 @@\n-        long childPid = 0;\n+        Optional<ProcessHandle> child = Optional.empty();\n@@ -72,1 +71,1 @@\n-            childPid = Long.parseLong(pidStr.split(\"=\", 2)[1]);\n+            var childPid = Long.parseLong(pidStr.split(\"=\", 2)[1]);\n@@ -78,4 +77,3 @@\n-            Optional<ProcessHandle> processHandle = ProcessHandle.of(childPid);\n-            boolean isAlive = processHandle.isPresent()\n-                    && processHandle.get().isAlive();\n-            TKit.assertTrue(isAlive, \"Check child process is alive\");\n+            child = ProcessHandle.of(childPid);\n+            boolean isAlive = child.map(ProcessHandle::isAlive).orElse(false);\n+            TKit.assertTrue(isAlive, String.format(\"Check child process with PID=%d is alive\", childPid));\n@@ -83,4 +81,2 @@\n-            if (childPid != 0) {\n-                \/\/ Kill only a specific child instance\n-                killProcess(childPid);\n-            }\n+            TKit.trace(\"About to kill the child process...\");\n+            child.ifPresent(ProcessHandle::destroyForcibly);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinChildProcessTest.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,3 +183,2 @@\n-            Document doc = XmlUtils.initDocumentBuilder().parse(\n-                    Files.newInputStream(TKit.SRC_ROOT.resolve(\n-                            \"windows\/classes\/jdk\/jpackage\/internal\/resources\/main.wxs\")));\n+            Document doc = XmlUtils.initDocumentBuilder().parse(TKit.SRC_ROOT.resolve(\n+                    \"windows\/classes\/jdk\/jpackage\/internal\/resources\/main.wxs\").toFile());\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongVersionTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n@@ -29,0 +28,3 @@\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n@@ -33,0 +35,1 @@\n+import jdk.jpackage.test.TKit;\n@@ -50,1 +53,1 @@\n-    public static void test() throws InterruptedException, IOException {\n+    public static void test() throws InterruptedException, IOException, ExecutionException {\n@@ -80,1 +83,1 @@\n-        void apply(JPackageCommand cmd, CfgFile origCfgFile) throws InterruptedException {\n+        void apply(JPackageCommand cmd, CfgFile origCfgFile) throws InterruptedException, ExecutionException {\n@@ -95,0 +98,3 @@\n+            var state = TKit.state();\n+            var f = new CompletableFuture<Process>();\n+\n@@ -97,1 +103,3 @@\n-                HelloApp.executeLauncher(cmd);\n+                TKit.withState(() -> {\n+                    HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n+                }, state);\n@@ -100,5 +108,27 @@\n-            \/\/ Wait a bit to let the app start\n-            Thread.sleep(Duration.ofSeconds(10));\n-\n-            \/\/ Find the main app launcher process and kill it\n-            killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n+            var mainLauncherProcess = f.get();\n+\n+            try {\n+                \/\/ Wait a bit to let the app start\n+                Thread.sleep(Duration.ofSeconds(10));\n+\n+                try (var children = mainLauncherProcess.children()) {\n+                    Optional<String> childPid = children.filter(p -> {\n+                        return mainLauncherProcess.info().command().equals(p.info().command());\n+                    }).map(ProcessHandle::pid).map(Object::toString).findFirst();\n+\n+                    Optional<String> expectedChildPid;\n+                    if (expectedNoRestarted) {\n+                        expectedChildPid = Optional.empty();\n+                    } else {\n+                        expectedChildPid = childPid.or(() -> {\n+                            return Optional.of(\"<some>\");\n+                        });\n+                    }\n+                    TKit.assertEquals(expectedChildPid, childPid, String.format(\n+                            \"Check the main launcher process with PID=%d restarted\",\n+                            mainLauncherProcess.pid()));\n+                }\n+            } finally {\n+                TKit.trace(\"About to kill the main launcher process...\");\n+                mainLauncherProcess.destroyForcibly();\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,4 +224,1 @@\n-            SSLContext sslContext = new SimpleSSLContext().get();\n-            if (sslContext == null) {\n-                throw new AssertionError(\"Could not create a SSLContext\");\n-            }\n+            SSLContext sslContext = SimpleSSLContext.findSSLContext();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ErrorTranslationTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-    @Test\n","filename":"test\/langtools\/jdk\/jshell\/IdGeneratorTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import org.junit.jupiter.api.Test;\n@@ -41,1 +40,0 @@\n-    @Test\n","filename":"test\/langtools\/jdk\/jshell\/KullaCompletenessStressTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,2 @@\n-        \"Test2b\", \"Test3b\", \"Test4b\", \"Test5b\"\n+        \"Test2b\", \"Test3b\", \"Test4b\", \"Test5b\",\n+        \"Test6a\"\n@@ -185,0 +186,5 @@\n+            case \"Test6a<init>\": cexpected=4; break;\n+            case \"test6aPrimitiveArray\":  expected = 0; break;\n+            case \"test6aRefArray\": expected = 0; break;\n+            case \"test6aMethod\": cexpected = 4; break;\n+\n@@ -356,0 +362,12 @@\n+    static class Test6a {\n+        Test6a(){}\n+        long l = 0;\n+        \/\/ Cast expressions inside new array dimensions:\n+        int[] test6aPrimitiveArray = new int[(@A @A @B @B int) l];\n+        Integer[] test6aRefArray   = new Integer[(@A @A @B @B int) l];\n+        private void test6aMethod() {\n+            int[] primitiveArray = new int[(@A @A @B @B int) l];\n+            Integer[] refArray   = new Integer[(@A @A @B @B int) l];\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/TestNewCastArray.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+    private boolean generateBaseArchive = false;\n+    private String[] baseArchiveOptions = new String[0];\n@@ -347,1 +349,1 @@\n-        if (wb.isSharingEnabled()) {\n+        if (wb.isSharingEnabled() && !generateBaseArchive) {\n@@ -360,0 +362,1 @@\n+                opts.addSuffix(baseArchiveOptions);\n@@ -368,0 +371,10 @@\n+    public CDSAppTester setGenerateBaseArchive(boolean b) {\n+        this.generateBaseArchive = b;\n+        return this;\n+    }\n+\n+    public CDSAppTester setBaseArchiveOptions(String... opts) {\n+        this.baseArchiveOptions = opts;\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+    private Tester tester;\n@@ -63,0 +64,1 @@\n+        super();\n@@ -64,0 +66,1 @@\n+        this.tester = new Tester(name);\n@@ -104,0 +107,10 @@\n+    public SimpleCDSAppTester setGenerateBaseArchive(boolean b) {\n+        tester.setGenerateBaseArchive(b);\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester setBaseArchiveOptions(String... opts) {\n+        tester.setBaseArchiveOptions(opts);\n+        return this;\n+    }\n+\n@@ -184,1 +197,6 @@\n-        (new Tester(name)).runStaticWorkflow();\n+        tester.runStaticWorkflow();\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester runDynamicWorkflow() throws Exception {\n+        tester.runDynamicWorkflow();\n@@ -189,1 +207,1 @@\n-        (new Tester(name)).runAOTWorkflow();\n+        tester.runAOTWorkflow();\n@@ -194,1 +212,1 @@\n-        (new Tester(name)).run(args);\n+        tester.run(args);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/SimpleCDSAppTester.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -126,0 +126,6 @@\n+static void\n+fatal(const char* msg) {\n+  LOG(\"FATAL ERROR: %s\\n\", msg);\n+  abort();\n+}\n+\n@@ -316,0 +322,11 @@\n+static char*\n+get_method_name(jvmtiEnv *jvmti, jmethodID method) {\n+  char*  mname = nullptr;\n+  jvmtiError err;\n+\n+  err = jvmti->GetMethodName(method, &mname, nullptr, nullptr);\n+  check_jvmti_error(err, \"get_method_name: error in JVMTI GetMethodName call\");\n+\n+  return mname;\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.io.File;\n@@ -28,4 +29,7 @@\n-import java.util.*;\n-import java.io.*;\n-import java.security.*;\n-import javax.net.ssl.*;\n+import java.security.KeyStore;\n+import java.util.Collections;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -42,11 +46,1 @@\n-    private final SSLContext ssl;\n-\n-    \/\/ Made `public` for backward compatibility\n-    public SimpleSSLContext() throws IOException {\n-        this.ssl = findSSLContext(DEFAULT_KEY_STORE_FILE_REL_PATH, DEFAULT_PROTOCOL);\n-    }\n-\n-    \/\/ Kept for backward compatibility\n-    public SimpleSSLContext(String keyStoreFileRelPath) throws IOException {\n-        this.ssl = findSSLContext(Objects.requireNonNull(keyStoreFileRelPath), DEFAULT_PROTOCOL);\n-    }\n+    private SimpleSSLContext() {}\n@@ -139,16 +133,0 @@\n-    \/\/ Kept for backward compatibility\n-    public static SSLContext getContext(String protocol) throws IOException {\n-        try {\n-            return protocol == null || protocol.isEmpty()\n-                    ? findSSLContext()\n-                    : findSSLContext(protocol);\n-        } catch (RuntimeException re) {\n-            throw new IOException(re);\n-        }\n-    }\n-\n-    \/\/ Kept for backward compatibility\n-    public SSLContext get() {\n-        return ssl;\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/net\/SimpleSSLContext.java","additions":10,"deletions":32,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.awt.image;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.Hashtable;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 20)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class PNGImageDecoder_8bit_uninterlaced {\n+\n+    byte[] pngImageData;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        pngImageData = createImageData(2_500);\n+    }\n+\n+    @Benchmark\n+    public void measurePNGImageDecoder(Blackhole bh) throws Exception {\n+        Image img = Toolkit.getDefaultToolkit().createImage(pngImageData);\n+        BufferedImage bi = createBufferedImage(img);\n+        bi.flush();\n+        bh.consume(bi);\n+    }\n+\n+    \/**\n+     * Create a large sample image stored as an 8-bit PNG.\n+     *\n+     * @return the byte representation of the PNG image.\n+     *\/\n+    private static byte[] createImageData(int squareSize) throws Exception {\n+        BufferedImage bi = new BufferedImage(squareSize, squareSize,\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        Random r = new Random(0);\n+        Graphics2D g = bi.createGraphics();\n+        for (int a = 0; a < 20000; a++) {\n+            g.setColor(new Color(r.nextInt(0xffffff)));\n+            int radius = 10 + r.nextInt(90);\n+            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n+                    radius, radius);\n+        }\n+        g.dispose();\n+\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            ImageIO.write(bi, \"png\", out);\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    static BufferedImage createBufferedImage(Image img)\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n+        img.getSource().startProduction(new ImageConsumer() {\n+            private int imageWidth, imageHeight;\n+            private BufferedImage bi;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                imageWidth = width;\n+                imageHeight = height;\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setHints(int hintflags) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  byte[] pixels, int off, int scansize) {\n+                if (bi == null) {\n+                    bi = new BufferedImage(imageWidth, imageHeight,\n+                            BufferedImage.TYPE_BYTE_INDEXED,\n+                            (IndexColorModel) model);\n+                }\n+                if (h != 1)\n+                    throw new UnsupportedOperationException(\n+                            \"this test expects sequential rows of pixels\");\n+                if (off != 0)\n+                    throw new UnsupportedOperationException(\n+                            \"this test expects the incoming pixels to start \" +\n+                                    \"at index zero\");\n+\n+                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  int[] pixels, int off, int scansize) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                future.complete(bi);\n+            }\n+        });\n+        return future.get();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/awt\/image\/PNGImageDecoder_8bit_uninterlaced.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.RandomAccessFile;\n@@ -84,0 +85,25 @@\n+    @State(Scope.Benchmark)\n+    @Warmup(iterations = 3, time = 2)\n+    @Measurement(iterations = 5, time = 5)\n+    @BenchmarkMode(Mode.SampleTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @Threads(1)\n+    @Fork(value = 10)\n+    public static class OpenFileForWritingBench {\n+        final byte[] payload = \"something\".getBytes();\n+        final String path = System.getProperty(\"os.name\", \"unknown\").toLowerCase().contains(\"win\") ? \"NUL\" : \"\/dev\/null\";\n+\n+        @Benchmark\n+        public void testFileOutputStream() throws IOException {\n+            try (FileOutputStream f = new FileOutputStream(path)) {\n+                f.write(payload);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testRandomAccessFile() throws IOException {\n+            try (RandomAccessFile f = new RandomAccessFile(path, \"rw\")) {\n+                f.write(payload);\n+            }\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/FileWrite.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class FromJavaStringTest {\n+\n+    private String str;\n+    private MemorySegment strSegment;\n+    private int lengthBytes;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\", \"451\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        while (LOREM.length() < size) {\n+            LOREM += LOREM;\n+        }\n+        str = LOREM.substring(0, size);\n+        strSegment = arena.allocateFrom(str);\n+        lengthBytes = str.getBytes(UTF_8).length;\n+    }\n+\n+    @Benchmark\n+    public void segment_setString() {\n+        strSegment.setString(0, str, UTF_8);\n+    }\n+\n+    @Benchmark\n+    public void segment_copyStringRaw() {\n+        MemorySegment.copy(str, UTF_8, 0, strSegment, 0, str.length());\n+    }\n+\n+    @Benchmark\n+    public void segment_copyStringBytes() {\n+        byte[] bytes = str.getBytes(UTF_8);\n+        MemorySegment.copy(bytes, 0, strSegment, JAVA_BYTE, 0, bytes.length);\n+    }\n+\n+    static String LOREM =\n+            \"\"\"\n+            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+             dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+             ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+             fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+             mollit anim id est laborum.\n+            \"\"\";\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FromJavaStringTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -50,0 +53,1 @@\n+    private int length;\n@@ -64,1 +68,3 @@\n-        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n+        var s = LOREM.substring(0, size);\n+        strSegment = arena.allocateFrom(s);\n+        length = s.getBytes(UTF_8).length;\n@@ -68,1 +74,1 @@\n-    public String panama_readString() {\n+    public String segment_getString() {\n@@ -72,0 +78,5 @@\n+    @Benchmark\n+    public String segment_getStringLength() {\n+        return strSegment.getString(0, UTF_8, length);\n+    }\n+\n@@ -77,0 +88,7 @@\n+    @Benchmark\n+    public String segment_copyStringBytes() {\n+        byte[] bytes = new byte[length];\n+        MemorySegment.copy(strSegment, JAVA_BYTE, 0, bytes, 0, length);\n+        return new String(bytes, UTF_8);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}