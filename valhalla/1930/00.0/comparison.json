{"files":[{"patch":"@@ -183,0 +183,1 @@\n+          --with-native-debug-symbols-level=1\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+          --with-native-debug-symbols-level=1\n","filename":".github\/workflows\/build-linux.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+          --with-native-debug-symbols-level=1\n","filename":".github\/workflows\/build-macos.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6643,8 +6643,4 @@\n-\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes char[] to byte[] in ISO-8859-1\n-\/\/\n-\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n-\/\/\n-\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n-\/\/   Encodes char[] to byte[] in ASCII\n+\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n+\/\/     return the number of characters copied.\n+\/\/ - java\/lang\/StringUTF16.compress\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6892,1 +6892,1 @@\n-          jccb(Assembler::less, L_check_fill_32_bytes);\n+          jcc(Assembler::less, L_check_fill_32_bytes);\n@@ -7057,40 +7057,26 @@\n-\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n-\/\/\n-\/\/ @IntrinsicCandidate\n-\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n-\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n-\/\/     int i = 0;\n-\/\/     for (; i < len; i++) {\n-\/\/         char c = sa[sp++];\n-\/\/         if (c > '\\u00FF')\n-\/\/             break;\n-\/\/         da[dp++] = (byte) c;\n-\/\/     }\n-\/\/     return i;\n-\/\/ }\n-\/\/\n-\/\/ @IntrinsicCandidate\n-\/\/ int java.lang.StringCoding.encodeISOArray0(\n-\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n-\/\/   int i = 0;\n-\/\/   for (; i < len; i++) {\n-\/\/     char c = StringUTF16.getChar(sa, sp++);\n-\/\/     if (c > '\\u00FF')\n-\/\/       break;\n-\/\/     da[dp++] = (byte) c;\n-\/\/   }\n-\/\/   return i;\n-\/\/ }\n-\/\/\n-\/\/ @IntrinsicCandidate\n-\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n-\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n-\/\/   int i = 0;\n-\/\/   for (; i < len; i++) {\n-\/\/     char c = sa[sp++];\n-\/\/     if (c >= '\\u0080')\n-\/\/       break;\n-\/\/     da[dp++] = (byte) c;\n-\/\/   }\n-\/\/   return i;\n-\/\/ }\n+\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n+   \/\/@IntrinsicCandidate\n+   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n+   \/\/byte[] da, int dp, int len) {\n+   \/\/  int i = 0;\n+   \/\/  for (; i < len; i++) {\n+   \/\/    char c = StringUTF16.getChar(sa, sp++);\n+   \/\/    if (c > '\\u00FF')\n+   \/\/      break;\n+   \/\/    da[dp++] = (byte)c;\n+   \/\/  }\n+   \/\/  return i;\n+   \/\/}\n+   \/\/\n+   \/\/@IntrinsicCandidate\n+   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n+   \/\/    byte[] da, int dp, int len) {\n+   \/\/  int i = 0;\n+   \/\/  for (; i < len; i++) {\n+   \/\/    char c = sa[sp++];\n+   \/\/    if (c >= '\\u0080')\n+   \/\/      break;\n+   \/\/    da[dp++] = (byte)c;\n+   \/\/  }\n+   \/\/  return i;\n+   \/\/}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":27,"deletions":41,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2647,2 +2647,2 @@\n-static bool is_ndd_demotable(const MachNode* mdef) {\n-  return ((mdef->flags() & Node::PD::Flag_ndd_demotable) != 0);\n+static bool is_ndd_demotable_opr1(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_opr1) != 0);\n@@ -2651,2 +2651,2 @@\n-static bool is_ndd_demotable_commutative(const MachNode* mdef) {\n-  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_commutative) != 0);\n+static bool is_ndd_demotable_opr2(const MachNode* mdef) {\n+  return ((mdef->flags() & Node::PD::Flag_ndd_demotable_opr2) != 0);\n@@ -2655,2 +2655,3 @@\n-static bool is_demotion_candidate(const MachNode* mdef) {\n-  return (is_ndd_demotable(mdef) || is_ndd_demotable_commutative(mdef));\n+#ifdef ASSERT\n+static bool is_ndd_demotable(const MachNode* mdef) {\n+  return (is_ndd_demotable_opr1(mdef) || is_ndd_demotable_opr2(mdef));\n@@ -2658,0 +2659,1 @@\n+#endif\n@@ -2667,2 +2669,2 @@\n-    assert(oper_index != 1 || !is_demotion_candidate(mdef), \"%s\", mdef->Name());\n-    assert(oper_index != 2 || !is_ndd_demotable_commutative(mdef), \"%s\", mdef->Name());\n+    assert(oper_index != 1 || !is_ndd_demotable_opr1(mdef), \"%s\", mdef->Name());\n+    assert(oper_index != 2 || !is_ndd_demotable_opr2(mdef), \"%s\", mdef->Name());\n@@ -2676,1 +2678,0 @@\n-    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n@@ -2683,1 +2684,1 @@\n-    assert(!is_demotion_candidate(mdef), \"%s\", mdef->Name());\n+    assert(!is_ndd_demotable(mdef), \"%s\", mdef->Name());\n@@ -2695,1 +2696,1 @@\n-    return is_demotion_candidate(mdef);\n+    return is_ndd_demotable_opr1(mdef);\n@@ -2700,1 +2701,1 @@\n-    return is_ndd_demotable_commutative(mdef);\n+    return is_ndd_demotable_opr2(mdef);\n@@ -2902,3 +2903,3 @@\n-    Flag_ndd_demotable        = Node::_last_flag << 12,\n-    Flag_ndd_demotable_commutative = Node::_last_flag << 13,\n-    _last_flag                = Flag_ndd_demotable_commutative\n+    Flag_ndd_demotable_opr1   = Node::_last_flag << 12,\n+    Flag_ndd_demotable_opr2   = Node::_last_flag << 13,\n+    _last_flag                = Flag_ndd_demotable_opr2\n@@ -9961,1 +9962,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -9989,1 +9990,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -10032,1 +10033,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -10089,1 +10090,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -10144,1 +10145,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -10251,1 +10252,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -10279,1 +10280,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -10322,1 +10323,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -10378,1 +10379,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -10433,1 +10434,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -11148,1 +11149,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11162,1 +11163,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11205,1 +11206,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11263,1 +11264,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11277,1 +11278,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11320,1 +11321,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11392,1 +11393,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr2);\n@@ -11420,1 +11421,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11461,1 +11462,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr2);\n@@ -11489,1 +11490,1 @@\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_ndd_demotable_opr1);\n@@ -11534,1 +11535,1 @@\n-  flag(PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11576,1 +11577,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11628,1 +11629,1 @@\n-  flag(PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11670,1 +11671,1 @@\n-  flag(PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -11945,1 +11946,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -11974,1 +11975,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12081,1 +12082,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12188,1 +12189,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12296,1 +12297,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12325,1 +12326,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12432,1 +12433,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12539,1 +12540,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12711,1 +12712,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12776,1 +12777,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12843,1 +12844,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12908,1 +12909,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -12986,1 +12987,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13079,1 +13080,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13123,1 +13124,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13323,1 +13324,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13352,1 +13353,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13366,1 +13367,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13410,1 +13411,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13486,1 +13487,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13512,1 +13513,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -13543,1 +13544,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13589,1 +13590,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13668,1 +13669,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13724,1 +13725,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -13768,1 +13769,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -13971,1 +13972,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -14026,1 +14027,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -14040,1 +14041,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -14085,1 +14086,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -14164,1 +14165,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -14190,1 +14191,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -14221,1 +14222,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1);\n@@ -14267,1 +14268,1 @@\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_commutative);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag, PD::Flag_ndd_demotable_opr1, PD::Flag_ndd_demotable_opr2);\n@@ -16935,1 +16936,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n@@ -16987,1 +16988,1 @@\n-  flag(PD::Flag_ndd_demotable);\n+  flag(PD::Flag_ndd_demotable_opr1);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":77,"deletions":76,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-    *((narrowOop*)field_addr_in_buffer) = checked_cast<narrowOop>(addr);\n+    *((narrowOop*)field_addr_in_buffer) = CompressedOops::narrow_oop_cast(addr);\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2178,1 +2178,0 @@\n-    DynamicArchive::setup_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -993,2 +993,0 @@\n-\n-  DynamicArchive::make_array_klasses_shareable();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+#include \"cppstdlib\/cstdlib.hpp\"\n@@ -84,1 +85,0 @@\n-#include <stdlib.h>\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -4344,4 +4344,0 @@\n-bool jdk_internal_foreign_abi_NativeEntryPoint::is_instance(oop obj) {\n-  return obj != nullptr && is_subclass(obj->klass());\n-}\n-\n@@ -4384,4 +4380,0 @@\n-bool jdk_internal_foreign_abi_ABIDescriptor::is_instance(oop obj) {\n-  return obj != nullptr && is_subclass(obj->klass());\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1188,7 +1188,0 @@\n-  \/\/ Testers\n-  static bool is_subclass(Klass* klass) {\n-    return vmClasses::NativeEntryPoint_klass() != nullptr &&\n-      klass->is_subclass_of(vmClasses::NativeEntryPoint_klass());\n-  }\n-  static bool is_instance(oop obj);\n-\n@@ -1225,7 +1218,0 @@\n-\n-  \/\/ Testers\n-  static bool is_subclass(Klass* klass) {\n-    return vmClasses::ABIDescriptor_klass() != nullptr &&\n-      klass->is_subclass_of(vmClasses::ABIDescriptor_klass());\n-  }\n-  static bool is_instance(oop obj);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n+   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n@@ -437,1 +437,1 @@\n-   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n+   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n@@ -443,1 +443,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n+   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1385,0 +1385,1 @@\n+  SET_ADDRESS(_extrs, ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr());\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1210,1 +1210,1 @@\n-Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n+Node* MinMaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1218,1 +1218,1 @@\n-Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n+Node* MinMaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n@@ -1226,1 +1226,1 @@\n-Node* MaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn) {\n+Node* MinMaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn) {\n@@ -1258,1 +1258,1 @@\n-Node* MaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn) {\n+Node* MinMaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn) {\n@@ -1305,1 +1305,1 @@\n-Node* MaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n+Node* MinMaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n@@ -1342,1 +1342,1 @@\n-Node* MaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n+Node* MinMaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n@@ -1416,1 +1416,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1449,1 +1449,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1579,1 +1579,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1611,1 +1611,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1625,1 +1625,1 @@\n-int MaxNode::opposite_opcode() const {\n+int MinMaxNode::opposite_opcode() const {\n@@ -1636,1 +1636,1 @@\n-Node* MaxNode::find_identity_operation(Node* operation, Node* operand) {\n+Node* MinMaxNode::find_identity_operation(Node* operation, Node* operand) {\n@@ -1660,1 +1660,1 @@\n-Node* MaxNode::Identity(PhaseGVN* phase) {\n+Node* MinMaxNode::Identity(PhaseGVN* phase) {\n@@ -1665,1 +1665,1 @@\n-  Node* identity_1 = MaxNode::find_identity_operation(in(2), in(1));\n+  Node* identity_1 = MinMaxNode::find_identity_operation(in(2), in(1));\n@@ -1670,1 +1670,1 @@\n-  Node* identity_2 = MaxNode::find_identity_operation(in(1), in(2));\n+  Node* identity_2 = MinMaxNode::find_identity_operation(in(1), in(2));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -678,3 +678,0 @@\n-  develop(bool, VerifyIntrinsicChecks, false,                               \\\n-          \"Verify in intrinsic that Java level checks work as expected\")    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,1 +450,2 @@\n-    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline || StressIncrementalInlining, \"we're doing late inlining\");\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || cg->is_virtual_late_inline() ||\n+           AlwaysIncrementalInline || StressIncrementalInlining, \"we're doing late inlining\");\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1070,0 +1070,9 @@\n+bool CallNode::is_call_to_multianewarray_stub() const {\n+  if (_name != nullptr &&\n+      strstr(_name, \"multianewarray\") != nullptr &&\n+      strstr(_name, \"C2 runtime\") != nullptr) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -780,0 +780,1 @@\n+  bool is_call_to_multianewarray_stub() const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1115,2 +1115,0 @@\n-  Node *hook = new Node(1);\n-\n@@ -1132,1 +1130,3 @@\n-      hook->init_req(0, x);       \/\/ Add a use to x to prevent him from dying\n+      \/\/ Add a use to x to prevent it from dying\n+      Node* hook = new Node(1);\n+      hook->init_req(0, x);\n@@ -1188,0 +1188,1 @@\n+  Node* hook = new Node(1);\n@@ -1410,2 +1411,0 @@\n-  Node *hook = new Node(1);\n-\n@@ -1429,1 +1428,3 @@\n-      hook->init_req(0, x);       \/\/ Add a use to x to prevent him from dying\n+      \/\/ Add a use to x to prevent it from dying\n+      Node* hook = new Node(1);\n+      hook->init_req(0, x);\n@@ -1435,1 +1436,1 @@\n-        hook->set_req(0, x);    \/\/ Add a use to x to prevent him from dying\n+        hook->set_req(0, x);    \/\/ Add a use to x to prevent it from dying\n@@ -1485,0 +1486,2 @@\n+  \/\/ Add a use to x to prevent him from dying\n+  Node* hook = new Node(1);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1081,0 +1081,33 @@\n+\n+      \/\/ If new_load is a Load but not from an AddP, it means that the load is folded into another\n+      \/\/ load. And since this load is not from a field, we cannot create a unique type for it.\n+      \/\/ For example:\n+      \/\/\n+      \/\/   if (b) {\n+      \/\/       Holder h1 = new Holder();\n+      \/\/       Object o = ...;\n+      \/\/       h.o = o.getClass();\n+      \/\/   } else {\n+      \/\/       Holder h2 = ...;\n+      \/\/   }\n+      \/\/   Holder h = Phi(h1, h2);\n+      \/\/   Object r = h.o;\n+      \/\/\n+      \/\/ Then, splitting r through the merge point results in:\n+      \/\/\n+      \/\/   if (b) {\n+      \/\/       Holder h1 = new Holder();\n+      \/\/       Object o = ...;\n+      \/\/       h.o = o.getClass();\n+      \/\/       Object o1 = h.o;\n+      \/\/   } else {\n+      \/\/       Holder h2 = ...;\n+      \/\/       Object o2 = h2.o;\n+      \/\/   }\n+      \/\/   Object r = Phi(o1, o2);\n+      \/\/\n+      \/\/ In this case, o1 is folded to o.getClass() which is a Load but not from an AddP, but from\n+      \/\/ an OopHandle that is loaded from the Klass of o.\n+      if (!new_addp->is_AddP()) {\n+        continue;\n+      }\n@@ -2156,2 +2189,2 @@\n-      assert(strncmp(name, \"C2 Runtime multianewarray\", 25) == 0 ||\n-             strncmp(name, \"C2 Runtime load_unknown_inline\", 30) == 0 ||\n+      assert(call->as_CallStaticJava()->is_call_to_multianewarray_stub() ||\n+             strncmp(name, \"load_unknown_inline\", 19) == 0 ||\n@@ -2882,2 +2915,2 @@\n-    assert(strncmp(name, \"C2 Runtime multianewarray\", 25) == 0 ||\n-           strncmp(name, \"C2 Runtime load_unknown_inline\", 30) == 0 ||\n+    assert(alloc->as_CallStaticJava()->is_call_to_multianewarray_stub() ||\n+           strncmp(name, \"load_unknown_inline\", 19) == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -971,5 +971,1 @@\n-void LibraryCallKit::generate_string_range_check(Node* array,\n-                                                 Node* offset,\n-                                                 Node* count,\n-                                                 bool char_count,\n-                                                 bool halt_on_oob) {\n+void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n@@ -993,11 +989,4 @@\n-    if (halt_on_oob) {\n-      bailout = _gvn.transform(bailout)->as_Region();\n-      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n-      Node* halt = _gvn.transform(new HaltNode(bailout, frame, \"unexpected guard failure in intrinsic\"));\n-      C->root()->add_req(halt);\n-    } else {\n-      PreserveJVMState pjvms(this);\n-      set_control(_gvn.transform(bailout));\n-      uncommon_trap(Deoptimization::Reason_intrinsic,\n-                    Deoptimization::Action_maybe_recompile);\n-    }\n+    PreserveJVMState pjvms(this);\n+    set_control(_gvn.transform(bailout));\n+    uncommon_trap(Deoptimization::Reason_intrinsic,\n+                  Deoptimization::Action_maybe_recompile);\n@@ -1161,1 +1150,0 @@\n-\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1173,7 +1161,1 @@\n-  if (VerifyIntrinsicChecks) {\n-    ba = must_be_not_null(ba, true);\n-    generate_string_range_check(ba, offset, len, false, true);\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n+  ba = must_be_not_null(ba, true);\n@@ -1181,0 +1163,5 @@\n+  \/\/ Range checks\n+  generate_string_range_check(ba, offset, len, false);\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -6954,3 +6941,0 @@\n-\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n-\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6967,8 +6951,2 @@\n-  \/\/ Cast source & target arrays to not-null\n-  if (VerifyIntrinsicChecks) {\n-    src = must_be_not_null(src, true);\n-    dst = must_be_not_null(dst, true);\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n+  src = must_be_not_null(src, true);\n+  dst = must_be_not_null(dst, true);\n@@ -6991,9 +6969,0 @@\n-  \/\/ Check source & target bounds\n-  if (VerifyIntrinsicChecks) {\n-    generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n-    generate_string_range_check(dst, dst_offset, length, false, true);\n-    if (stopped()) {\n-      return true;\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":13,"deletions":44,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -175,2 +175,1 @@\n-                                    Node* length, bool char_count,\n-                                    bool halt_on_oob = false);\n+                                    Node* length, bool char_count);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3261,1 +3261,1 @@\n-        Node* repl = MaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        Node* repl = MinMaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n@@ -3265,1 +3265,1 @@\n-        Node* repl = MaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        Node* repl = MinMaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4190,1 +4190,0 @@\n-    _adr_type(at),\n@@ -4198,0 +4197,1 @@\n+  DEBUG_ONLY(_adr_type = at; adr_type();)\n@@ -4221,0 +4221,5 @@\n+const TypePtr* LoadStoreNode::adr_type() const {\n+  const TypePtr* cross_check = DEBUG_ONLY(_adr_type) NOT_DEBUG(nullptr);\n+  return MemNode::calculate_adr_type(in(MemNode::Address)->bottom_type(), cross_check);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -823,5 +823,0 @@\n-  virtual const TypePtr *adr_type() const {\n-    Node* ctrl = in(0);\n-    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n-    return ctrl->in(MemNode::Memory)->adr_type();\n-  }\n@@ -840,1 +835,0 @@\n-  const TypePtr* _adr_type;     \/\/ What kind of memory is being addressed?\n@@ -843,0 +837,3 @@\n+#ifdef ASSERT\n+  const TypePtr* _adr_type;     \/\/ What kind of memory is being addressed?\n+#endif \/\/ ASSERT\n@@ -850,1 +847,1 @@\n-  virtual const class TypePtr *adr_type() const { return _adr_type; }  \/\/ returns bottom_type of address\n+  virtual const TypePtr* adr_type() const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+class MinMaxNode;\n@@ -825,0 +826,1 @@\n+      DEFINE_CLASS_ID(MinMax,      Add, 0)\n@@ -1006,0 +1008,1 @@\n+  DEFINE_CLASS_QUERY(MinMax)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -765,16 +765,28 @@\n-void PhaseGVN::dead_loop_check( Node *n ) {\n-  \/\/ Phi may reference itself in a loop\n-  if (n != nullptr && !n->is_dead_loop_safe() && !n->is_CFG()) {\n-    \/\/ Do 2 levels check and only data inputs.\n-    bool no_dead_loop = true;\n-    uint cnt = n->req();\n-    for (uint i = 1; i < cnt && no_dead_loop; i++) {\n-      Node *in = n->in(i);\n-      if (in == n) {\n-        no_dead_loop = false;\n-      } else if (in != nullptr && !in->is_dead_loop_safe()) {\n-        uint icnt = in->req();\n-        for (uint j = 1; j < icnt && no_dead_loop; j++) {\n-          if (in->in(j) == n || in->in(j) == in)\n-            no_dead_loop = false;\n-        }\n+void PhaseGVN::dead_loop_check(Node* n) {\n+  \/\/ Phi may reference itself in a loop.\n+  if (n == nullptr || n->is_dead_loop_safe() || n->is_CFG()) {\n+    return;\n+  }\n+\n+  \/\/ Do 2 levels check and only data inputs.\n+  for (uint i = 1; i < n->req(); i++) {\n+    Node* in = n->in(i);\n+    if (in == n) {\n+      n->dump_bfs(100, nullptr, \"\");\n+      fatal(\"Dead loop detected, node references itself: %s (%d)\",\n+            n->Name(), n->_idx);\n+    }\n+\n+    if (in == nullptr || in->is_dead_loop_safe()) {\n+      continue;\n+    }\n+    for (uint j = 1; j < in->req(); j++) {\n+      if (in->in(j) == n) {\n+        n->dump_bfs(100, nullptr, \"\");\n+        fatal(\"Dead loop detected, node input references current node: %s (%d) -> %s (%d)\",\n+              in->Name(), in->_idx, n->Name(), n->_idx);\n+      }\n+      if (in->in(j) == in) {\n+        n->dump_bfs(100, nullptr, \"\");\n+        fatal(\"Dead loop detected, node input references itself: %s (%d)\",\n+              in->Name(), in->_idx);\n@@ -783,2 +795,0 @@\n-    if (!no_dead_loop) { n->dump_bfs(100, nullptr, \"\"); }\n-    assert(no_dead_loop, \"dead loop detected\");\n@@ -2658,0 +2668,9 @@\n+  \/\/ Check for Max\/Min(A, Max\/Min(B, C)) where A == B or A == C\n+  if (use->is_MinMax()) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == use->Opcode()) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":37,"deletions":18,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,0 @@\n-#include \"utilities\/checkedCast.hpp\"\n@@ -1212,1 +1211,1 @@\n-  int  pos = 0;\n+  size_t pos = 0;\n@@ -1217,1 +1216,1 @@\n-  int  quote_c        = 0;\n+  char quote_c        = 0;\n@@ -1220,2 +1219,8 @@\n-  int c = getc(stream);\n-  while(c != EOF && pos < (int)(sizeof(token)-1)) {\n+  int c_or_eof = getc(stream);\n+  while (c_or_eof != EOF && pos < (sizeof(token) - 1)) {\n+    \/\/ We have checked the c_or_eof for EOF. getc should only ever return the\n+    \/\/ EOF or an unsigned char converted to an int. We cast down to a char to\n+    \/\/ avoid the char to int promotions we would otherwise do in the comparisons\n+    \/\/ below (which would be incorrect if we ever compared to a non-ascii char),\n+    \/\/ and the int to char conversions we would otherwise do in the assignments.\n+    const char c = static_cast<char>(c_or_eof);\n@@ -1229,1 +1234,1 @@\n-          token[pos++] = checked_cast<char>(c);\n+          token[pos++] = c;\n@@ -1249,1 +1254,1 @@\n-        token[pos++] = checked_cast<char>(c);\n+        token[pos++] = c;\n@@ -1252,1 +1257,1 @@\n-    c = getc(stream);\n+    c_or_eof = getc(stream);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -202,2 +202,1 @@\n-\/\/ C2 stubs are provided with names in the format \"C2 Runtime\n-\/\/ <stubname> _blob\".\n+\/\/ C2 stubs are provided with names in the format \"<stubname>_blob (C2 runtime)\".\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1391,8 +1391,0 @@\n-\/\/ This provides a workaround for static_assert(false) in discarded or\n-\/\/ otherwise uninstantiated places.  Instead use\n-\/\/   static_assert(DependentAlwaysFalse<T>, \"...\")\n-\/\/ See http:\/\/wg21.link\/p2593r1. Some, but not all, compiler versions we're\n-\/\/ using have implemented that change as a DR:\n-\/\/ https:\/\/cplusplus.github.io\/CWG\/issues\/2518.html\n-template<typename T> inline constexpr bool DependentAlwaysFalse = false;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1477,0 +1477,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n@@ -1495,0 +1496,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1440,0 +1440,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n@@ -1463,0 +1464,1 @@\n+     * @throws ArithmeticException if the divisor is zero\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -2195,2 +2196,2 @@\n-            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n-                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n+            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n@@ -2353,2 +2354,2 @@\n-            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-                string.copyToSegmentRaw(segment, offset);\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength) {\n+                string.copyToSegmentRaw(segment, offset, srcIndex, srcLength);\n@@ -2358,2 +2359,2 @@\n-            public boolean bytesCompatible(String string, Charset charset) {\n-                return string.bytesCompatible(charset);\n+            public boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars) {\n+                return string.bytesCompatible(charset, srcIndex, numChars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -452,3 +452,5 @@\n-     * Encodes as many ASCII codepoints as possible from the source\n-     * character array into the destination byte array, assuming that\n-     * the encoding is ASCII compatible.\n+     * Encodes as many ASCII codepoints as possible from the source array into\n+     * the destination byte array, assuming that the encoding is ASCII\n+     * compatible.\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -456,7 +458,1 @@\n-     * @param sa the source character array\n-     * @param sp the index of the source array to start reading from\n-     * @param da the target byte array\n-     * @param dp the index of the target array to start writing to\n-     * @param len the total number of characters to be encoded\n-     * @return the total number of characters successfully encoded\n-     * @throws NullPointerException if any of the provided arrays is null\n+     * @return the number of bytes successfully encoded, or 0 if none\n@@ -464,1 +460,1 @@\n-    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n+    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n@@ -648,1 +644,1 @@\n-    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength);\n@@ -653,1 +649,1 @@\n-    boolean bytesCompatible(String string, Charset charset);\n+    boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -40,4 +40,0 @@\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n-import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -181,0 +177,8 @@\n+     * Each lint category has a logical name (a string), which is the string used e.g. in a {@code SuppressWarning} annotation.\n+     * To ensure automation, the enum field name for a lint category string {@code C} should be obtained by:\n+     * <ol>\n+     *    <li>capitalize all the letters in {@code C}, and<\/li>\n+     *    <li>replacing any occurrence of {@code -} with {@code _}<\/li>\n+     * <\/ol>\n+     * For instance, the lint category string {@code dangling-doc-comments} corresponds to the enum field\n+     * {@code DANGLING_DOC_COMMENTS}.\n@@ -334,1 +338,1 @@\n-        RAW(\"rawtypes\"),\n+        RAWTYPES(\"rawtypes\"),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1128,0 +1128,1 @@\n+            scan(tree.dims);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-    public static final String LOAD_UNKNOWN_INLINE = \"C2 Runtime load_unknown_inline\";\n-    public static final String STORE_UNKNOWN_INLINE = \"C2 Runtime store_unknown_inline\";\n+    public static final String LOAD_UNKNOWN_INLINE = \"load_unknown_inline_blob \\\\(C2 runtime\\\\)\";\n+    public static final String STORE_UNKNOWN_INLINE = \"store_unknown_inline_blob \\\\(C2 runtime\\\\)\";\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeRegexes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -572,2 +572,0 @@\n-java\/nio\/channels\/AsyncCloseAndInterrupt.java                   8368290 macosx-26.0.1\n-\n@@ -728,1 +726,0 @@\n-jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java             8371014 aix-ppc64,linux-ppc64le\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.io.Serial;\n@@ -53,1 +54,0 @@\n-@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -59,0 +59,1 @@\n+        @Serial\n@@ -74,0 +75,1 @@\n+        @Serial\n@@ -81,1 +83,1 @@\n-    public Object[][] recordClasses() {\n+    public static Object[][] recordClasses() {\n@@ -128,1 +130,1 @@\n-    public Object[][] notSerRecordClasses() {\n+    public static Object[][] notSerRecordClasses() {\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/RecordClassTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+    private boolean generateBaseArchive = false;\n+    private String[] baseArchiveOptions = new String[0];\n@@ -347,1 +349,1 @@\n-        if (wb.isSharingEnabled()) {\n+        if (wb.isSharingEnabled() && !generateBaseArchive) {\n@@ -360,0 +362,1 @@\n+                opts.addSuffix(baseArchiveOptions);\n@@ -368,0 +371,10 @@\n+    public CDSAppTester setGenerateBaseArchive(boolean b) {\n+        this.generateBaseArchive = b;\n+        return this;\n+    }\n+\n+    public CDSAppTester setBaseArchiveOptions(String... opts) {\n+        this.baseArchiveOptions = opts;\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+    private Tester tester;\n@@ -62,0 +63,1 @@\n+    @SuppressWarnings(\"initialization\")\n@@ -64,0 +66,1 @@\n+        this.tester = new Tester(name);\n@@ -104,0 +107,10 @@\n+    public SimpleCDSAppTester setGenerateBaseArchive(boolean b) {\n+        tester.setGenerateBaseArchive(b);\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester setBaseArchiveOptions(String... opts) {\n+        tester.setBaseArchiveOptions(opts);\n+        return this;\n+    }\n+\n@@ -184,1 +197,6 @@\n-        (new Tester(name)).runStaticWorkflow();\n+        tester.runStaticWorkflow();\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester runDynamicWorkflow() throws Exception {\n+        tester.runDynamicWorkflow();\n@@ -189,1 +207,1 @@\n-        (new Tester(name)).runAOTWorkflow();\n+        tester.runAOTWorkflow();\n@@ -194,1 +212,1 @@\n-        (new Tester(name)).run(args);\n+        tester.run(args);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/SimpleCDSAppTester.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"}]}