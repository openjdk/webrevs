{"files":[{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.combo;\n-\n-import javax.tools.StandardJavaFileManager;\n-import java.util.Optional;\n-\n-\/**\n- * This class is the common superclass of all combo test instances. It defines few helper methods\n- * to build compilation tasks using the shared context object, as well as entry points for\n- * signalling test failures.\n- *\/\n-public abstract class ComboInstance<X extends ComboInstance<X>> {\n-\n-    \/** The test instance result status. *\/\n-    private ResultStatus resultStatus = ResultStatus.PASSED;\n-\n-    \/** The test instance execution environment. *\/\n-    private ComboTestHelper<X>.Env env;\n-\n-    \/**\n-     * Entry point for executing a combo test instance; first, the test environment is saved\n-     * in the corresponding field, then the instance is run (see {@link ComboInstance#doWork()}.\n-     * During execution, the result status will be updated to match the test outcome.\n-     *\/\n-    final void run(ComboTestHelper<X>.Env env) {\n-        try {\n-            this.env = env;\n-            doWork();\n-            if (resultStatus.isSuccess()) {\n-                env.info().passCount++;\n-            }\n-        } catch (Throwable ex) {\n-            resultStatus = ResultStatus.ERROR;\n-            env.info().errCount++;\n-            env.info().lastError = Optional.of(ex);\n-        } finally {\n-            this.env = null;\n-        }\n-    }\n-\n-    \/**\n-     * Retrieve a unique ID associated with this test instance.\n-     *\/\n-    public int id() {\n-        return env.info().comboCount;\n-    }\n-\n-    \/**\n-     * Retrieve shared file manager.\n-     *\/\n-    public StandardJavaFileManager fileManager() {\n-        return env.fileManager();\n-    }\n-\n-    \/**\n-     * Create a new compilation task using shared compilation context.\n-     *\/\n-    protected ComboTask newCompilationTask() {\n-        return new ComboTask(env);\n-    }\n-\n-    \/**\n-     * Main test execution entry point; subclasses must implement this method to define the test\n-     * logic.\n-     *\/\n-    protected abstract void doWork() throws Throwable;\n-\n-    \/**\n-     * Report a test failure.\n-     *\/\n-    protected void fail() {\n-        \/\/dump some default info (such as dimension bindings)\n-        fail(\"Combo instance failed; \" + env.bindings);\n-    }\n-\n-    \/**\n-     * Report a test failure with corresponding failure message.\n-     *\/\n-    protected void fail(String msg) {\n-        resultStatus = ResultStatus.FAILED;\n-        env.info().failCount++;\n-        env.info().lastFailure = Optional.of(msg);\n-    }\n-\n-    \/**\n-     * The status associated with this test instance execution.\n-     *\/\n-    enum ResultStatus {\n-        \/** Test passed. *\/\n-        PASSED(true),\n-        \/** Test failed. *\/\n-        FAILED(false),\n-        \/** Test thrown unexpected error\/exception. *\/\n-        ERROR(false);\n-\n-        boolean success;\n-\n-        ResultStatus(boolean success) {\n-            this.success = success;\n-        }\n-\n-        boolean isSuccess() {\n-            return success;\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/combo\/ComboInstance.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.combo;\n-\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * A combo parameter represents an 'hole' in a template that can be replaced with a given string.\n- * The schema of such holes is defined in {@link ComboParameter#pattern}; the main routine for\n- * replacing holes in a template scheme is {@link ComboParameter#expandTemplate(String, Resolver)}.\n- *\/\n-public interface ComboParameter {\n-\n-    \/**\n-     * A combo parameter can take the form:\n-     * <p>\n-     * #{MAJOR}\n-     * #{MAJOR.}\n-     * #{MAJOR.MINOR}\n-     * <p>\n-     * where MAJOR can be IDENTIFIER or IDENTIFIER[NUMERIC_INDEX]\n-     * and MINOR can be an identifier.\n-     *\/\n-    Pattern pattern = Pattern.compile(\"#\\\\{([A-Z_][A-Z0-9_]*(?:\\\\[\\\\d+\\\\])?)(?:\\\\.([A-Z0-9_]*))?\\\\}\");\n-\n-    \/**\n-     * Entry point for the customizable replacement logic. Subclasses must implement this method to\n-     * specify how a given template hole should be expanded. An optional contextual argument is passed\n-     * in as parameter, to make expansion more flexible.\n-     *\/\n-    String expand(String optParameter);\n-\n-    \/**\n-     * Helper class for defining 'constant' combo parameters - i.e. parameters that always expand\n-     * as a given string value - regardless of the context.\n-     *\/\n-    class Constant<D> implements ComboParameter {\n-\n-        D data;\n-\n-        public Constant(D data) {\n-            this.data = data;\n-        }\n-\n-        @Override\n-        public String expand(String _unused) {\n-            return String.valueOf(data);\n-        }\n-    }\n-\n-    \/**\n-     * Helper interface used to lookup parameters given a parameter name.\n-     *\/\n-    interface Resolver {\n-        ComboParameter lookup(String name);\n-    }\n-\n-    \/**\n-     * Main routine for replacing holes in a template string. Holes are repeatedly searches, their\n-     * corresponding parameters retrieved, and replaced through expansion; since an expansion can\n-     * lead to more holes, the process has to be applied until a fixed point is reached.\n-     *\/\n-    static String expandTemplate(String template, Resolver resolver) {\n-        CharSequence in = template;\n-        StringBuffer out = new StringBuffer();\n-        while (true) {\n-            boolean more = false;\n-            Matcher m = pattern.matcher(in);\n-            while (m.find()) {\n-                String parameterName = m.group(1);\n-                String minor = m.group(2);\n-                ComboParameter parameter = resolver.lookup(parameterName);\n-                if (parameter == null) {\n-                    throw new IllegalStateException(\"Unhandled parameter name \" + parameterName);\n-                }\n-\n-                String replacement = parameter.expand(minor);\n-                more |= pattern.matcher(replacement).find();\n-                m.appendReplacement(out, replacement);\n-            }\n-            m.appendTail(out);\n-            if (!more)\n-                return out.toString();\n-            else {\n-                in = out;\n-                out = new StringBuffer();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/combo\/ComboParameter.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,462 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.combo;\n-\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.util.JavacTask;\n-import com.sun.source.util.TaskListener;\n-import com.sun.tools.javac.api.JavacTool;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.List;\n-import jdk.test.lib.combo.ComboParameter.Resolver;\n-\n-import javax.lang.model.element.Element;\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticListener;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-\n-import java.io.IOException;\n-import java.io.Writer;\n-import java.net.URI;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.util.ArrayList;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.StreamSupport;\n-\n-\/**\n- * This class represents a compilation task associated with a combo test instance. This is a small\n- * wrapper around {@link JavacTask} which allows for fluent setup style and which makes use of\n- * the shared compilation context to speedup performances.\n- *\/\n-public class ComboTask {\n-\n-    \/** Sources to be compiled in this task. *\/\n-    private List<JavaFileObject> sources = List.nil();\n-\n-    \/** Options associated with this task. *\/\n-    private List<String> options = List.nil();\n-\n-    \/** Diagnostic collector. *\/\n-    private DiagnosticCollector diagsCollector = new DiagnosticCollector();\n-\n-    \/** Output writer. *\/\n-    private Writer out;\n-\n-    \/** Listeners associated with this task. *\/\n-    private List<TaskListener> listeners = List.nil();\n-\n-    \/** Underlying javac task object. *\/\n-    private JavacTask task;\n-\n-    \/** Combo execution environment. *\/\n-    private ComboTestHelper<?>.Env env;\n-\n-    ComboTask(ComboTestHelper<?>.Env env) {\n-        this.env = env;\n-    }\n-\n-    \/**\n-     * Add a new source to this task.\n-     *\/\n-    public ComboTask withSource(JavaFileObject comboSource) {\n-        sources = sources.prepend(comboSource);\n-        return this;\n-    }\n-\n-    \/**\n-     * Add a new template source with given name to this task; the template is replaced with\n-     * corresponding combo parameters (as defined in the combo test environment).\n-     *\/\n-    public ComboTask withSourceFromTemplate(String name, String template) {\n-        return withSource(new ComboTemplateSource(name, template));\n-    }\n-\n-    \/**\n-     * Add a new template source with default name (\"Test\") to this task; the template is replaced with\n-     * corresponding combo parameters (as defined in the combo test environment).\n-     *\/\n-    public ComboTask withSourceFromTemplate(String template) {\n-        return withSource(new ComboTemplateSource(\"Test\", template));\n-    }\n-\n-    \/**\n-     * Add a new template source with given name to this task; the template is replaced with\n-     * corresponding combo parameters (as defined in the combo test environment). A custom resolver\n-     * is used to add combo parameter mappings to the current combo test environment.\n-     *\/\n-    public ComboTask withSourceFromTemplate(String name, String template, Resolver resolver) {\n-        return withSource(new ComboTemplateSource(name, template, resolver));\n-    }\n-\n-    \/**\n-     * Add a new template source with default name (\"Test\") to this task; the template is replaced with\n-     * corresponding combo parameters (as defined in the combo test environment). A custom resolver\n-     * is used to add combo parameter mappings to the current combo test environment.\n-     *\/\n-    public ComboTask withSourceFromTemplate(String template, Resolver resolver) {\n-        return withSource(new ComboTemplateSource(\"Test\", template, resolver));\n-    }\n-\n-    \/**\n-     * Add a new option to this task.\n-     *\/\n-    public ComboTask withOption(String opt) {\n-        options = options.append(opt);\n-        return this;\n-    }\n-\n-    \/**\n-     * Add a set of options to this task.\n-     *\/\n-    public ComboTask withOptions(String[] opts) {\n-        for (String opt : opts) {\n-            options = options.append(opt);\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Add a set of options to this task.\n-     *\/\n-    public ComboTask withOptions(Iterable<? extends String> opts) {\n-        for (String opt : opts) {\n-            options = options.append(opt);\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Set the output writer associated with this task.\n-     *\/\n-    public ComboTask withWriter(Writer out) {\n-        this.out = out;\n-        return this;\n-    }\n-\n-    \/**\n-     * Add a task listener to this task.\n-     *\/\n-    public ComboTask withListener(TaskListener listener) {\n-        listeners = listeners.prepend(listener);\n-        return this;\n-    }\n-\n-    \/**\n-     * Parse the sources associated with this task.\n-     *\/\n-    public Result<Iterable<? extends CompilationUnitTree>> parse() throws IOException {\n-        return new Result<>(getTask().parse());\n-    }\n-\n-    \/**\n-     * Parse and analyzes the sources associated with this task.\n-     *\/\n-    public Result<Iterable<? extends Element>> analyze() throws IOException {\n-        return new Result<>(getTask().analyze());\n-    }\n-\n-    \/**\n-     * Parse, analyze and perform code generation for the sources associated with this task.\n-     *\/\n-    public Result<Iterable<? extends JavaFileObject>> generate() throws IOException {\n-        return new Result<>(getTask().generate());\n-    }\n-\n-    \/**\n-     * Parse, analyze, perform code generation for the sources associated with this task and finally\n-     * executes them\n-     *\/\n-    public <Z> Optional<Z> execute(Function<ExecutionTask, Z> executionFunc) throws IOException {\n-        Result<Iterable<? extends JavaFileObject>> generationResult = generate();\n-        Iterable<? extends JavaFileObject> jfoIterable = generationResult.get();\n-        if (generationResult.hasErrors()) {\n-            \/\/ we have nothing else to do\n-            return Optional.empty();\n-        }\n-        java.util.List<URL> urlList = new ArrayList<>();\n-        for (JavaFileObject jfo : jfoIterable) {\n-            String urlStr = jfo.toUri().toURL().toString();\n-            urlStr = urlStr.substring(0, urlStr.length() - jfo.getName().length());\n-            urlList.add(new URL(urlStr));\n-        }\n-        return Optional.of(\n-                executionFunc.apply(\n-                        new ExecutionTask(new URLClassLoader(urlList.toArray(new URL[urlList.size()])))));\n-    }\n-\n-    \/**\n-     * Fork a new compilation task; if possible the compilation context from previous executions is\n-     * retained (see comments in ReusableContext as to when it's safe to do so); otherwise a brand\n-     * new context is created.\n-     *\/\n-    public JavacTask getTask() {\n-        if (task == null) {\n-            ReusableContext context = env.context();\n-            String opts = options == null ? \"\" :\n-                    StreamSupport.stream(options.spliterator(), false).collect(Collectors.joining());\n-            context.clear();\n-            if (!context.polluted && (context.opts == null || context.opts.equals(opts))) {\n-                \/\/we can reuse former context\n-                env.info().ctxReusedCount++;\n-            } else {\n-                env.info().ctxDroppedCount++;\n-                \/\/it's not safe to reuse context - create a new one\n-                context = env.setContext(new ReusableContext());\n-            }\n-            context.opts = opts;\n-            JavacTask javacTask = ((JavacTool)env.javaCompiler()).getTask(out, env.fileManager(),\n-                    diagsCollector, options, null, sources, context);\n-            javacTask.setTaskListener(context);\n-            for (TaskListener l : listeners) {\n-                javacTask.addTaskListener(l);\n-            }\n-            task = javacTask;\n-        }\n-        return task;\n-    }\n-\n-    \/**\n-     * This class represents an execution task. It allows the execution of one or more classes previously\n-     * added to a given class loader. This class uses reflection to execute any given static public method\n-     * in any given class. It's not restricted to the execution of the {@code main} method\n-     *\/\n-    public class ExecutionTask {\n-        private ClassLoader classLoader;\n-        private String methodName = \"main\";\n-        private Class<?>[] parameterTypes = new Class<?>[]{String[].class};\n-        private Object[] args = new String[0];\n-        private Consumer<Throwable> handler;\n-        private Class<?> c;\n-\n-        private ExecutionTask(ClassLoader classLoader) {\n-            this.classLoader = classLoader;\n-        }\n-\n-        \/**\n-         * Set the name of the class to be loaded.\n-         *\/\n-        public ExecutionTask withClass(String className) {\n-            Assert.check(className != null, \"class name value is null, impossible to proceed\");\n-            try {\n-                c = classLoader.loadClass(className);\n-            } catch (Throwable t) {\n-                throw new IllegalStateException(t);\n-            }\n-            return this;\n-        }\n-\n-        \/**\n-         * Set the name of the method to be executed along with the parameter types to\n-         * reflectively obtain the method.\n-         *\/\n-        public ExecutionTask withMethod(String methodName, Class<?>... parameterTypes) {\n-            this.methodName = methodName;\n-            this.parameterTypes = parameterTypes;\n-            return this;\n-        }\n-\n-        \/**\n-         * Set the arguments to be passed to the method.\n-         *\/\n-        public ExecutionTask withArguments(Object... args) {\n-            this.args = args;\n-            return this;\n-        }\n-\n-        \/**\n-         * Set a handler to handle any exception thrown.\n-         *\/\n-        public ExecutionTask withHandler(Consumer<Throwable> handler) {\n-            this.handler = handler;\n-            return this;\n-        }\n-\n-        \/**\n-         * Executes the given method in the given class. Returns true if the execution was\n-         * successful, false otherwise.\n-         *\/\n-        public Object run() {\n-            try {\n-                java.lang.reflect.Method meth = c.getMethod(methodName, parameterTypes);\n-                meth.invoke(null, (Object)args);\n-                return true;\n-            } catch (Throwable t) {\n-                if (handler != null) {\n-                    handler.accept(t);\n-                }\n-                return false;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * This class is used to help clients accessing the results of a given compilation task.\n-     * Contains several helper methods to inspect diagnostics generated during the task execution.\n-     *\/\n-    public class Result<D> {\n-\n-        \/** The underlying compilation results. *\/\n-        private final D data;\n-\n-        public Result(D data) {\n-            this.data = data;\n-        }\n-\n-        public D get() {\n-            return data;\n-        }\n-\n-        \/**\n-         * Did this task generate any error diagnostics?\n-         *\/\n-        public boolean hasErrors() {\n-            return diagsCollector.diagsByKind.containsKey(Diagnostic.Kind.ERROR);\n-        }\n-\n-        \/**\n-         * Did this task generate any warning diagnostics?\n-         *\/\n-        public boolean hasWarnings() {\n-            return diagsCollector.diagsByKind.containsKey(Diagnostic.Kind.WARNING);\n-        }\n-\n-        \/**\n-         * Did this task generate any note diagnostics?\n-         *\/\n-        public boolean hasNotes() {\n-            return diagsCollector.diagsByKind.containsKey(Diagnostic.Kind.NOTE);\n-        }\n-\n-        \/**\n-         * Did this task generate any diagnostic with given key?\n-         *\/\n-        public boolean containsKey(String key) {\n-            return diagsCollector.diagsByKeys.containsKey(key);\n-        }\n-\n-        \/**\n-         * Retrieve the list of diagnostics of a given kind.\n-         *\/\n-        public List<Diagnostic<? extends JavaFileObject>> diagnosticsForKind(Diagnostic.Kind kind) {\n-            List<Diagnostic<? extends JavaFileObject>> diags = diagsCollector.diagsByKind.get(kind);\n-            return diags != null ? diags : List.nil();\n-        }\n-\n-        \/**\n-         * Retrieve the list of diagnostics with given key.\n-         *\/\n-        public List<Diagnostic<? extends JavaFileObject>> diagnosticsForKey(String key) {\n-            List<Diagnostic<? extends JavaFileObject>> diags = diagsCollector.diagsByKeys.get(key);\n-            return diags != null ? diags : List.nil();\n-        }\n-\n-        \/**\n-         * Dump useful info associated with this task.\n-         *\/\n-        public String compilationInfo() {\n-            return \"instance#\" + env.info().comboCount + \":[ options = \" + options\n-                    + \", diagnostics = \" + diagsCollector.diagsByKeys.keySet()\n-                    + \", dimensions = \" + env.bindings\n-                    + \", sources = \\n\" + sources.stream().map(s -> {\n-                try {\n-                    return s.getCharContent(true);\n-                } catch (IOException ex) {\n-                    return \"\";\n-                }\n-            }).collect(Collectors.joining(\",\")) + \"]\";\n-        }\n-    }\n-\n-    \/**\n-     * This class represents a Java source file whose contents are defined in terms of a template\n-     * string. The holes in such template are expanded using corresponding combo parameter\n-     * instances which can be retrieved using a resolver object.\n-     *\/\n-    class ComboTemplateSource extends SimpleJavaFileObject {\n-\n-        String source;\n-        Map<String, ComboParameter> localParametersCache = new HashMap<>();\n-\n-        protected ComboTemplateSource(String name, String template) {\n-            this(name, template, null);\n-        }\n-\n-        protected ComboTemplateSource(String name, String template, Resolver resolver) {\n-            super(URI.create(\"myfo:\/\" + env.info().comboCount + \"\/\" + name + \".java\"), Kind.SOURCE);\n-            source = ComboParameter.expandTemplate(template, pname -> resolveParameter(pname, resolver));\n-        }\n-\n-        @Override\n-        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-            return source;\n-        }\n-\n-        \/**\n-         * Combo parameter resolver function. First parameters are looked up in the global environment,\n-         * then the local environment is looked up as a fallback.\n-         *\/\n-        ComboParameter resolveParameter(String pname, Resolver resolver) {\n-            \/\/first search the env\n-            ComboParameter parameter = env.parametersCache.get(pname);\n-            if (parameter == null) {\n-                \/\/then lookup local cache\n-                parameter = localParametersCache.get(pname);\n-                if (parameter == null && resolver != null) {\n-                    \/\/if still null and we have a custom resolution function, try that\n-                    parameter = resolver.lookup(pname);\n-                    if (parameter != null) {\n-                       \/\/if a match was found, store it in the local cache to aviod redundant recomputation\n-                       localParametersCache.put(pname, parameter);\n-                    }\n-                }\n-            }\n-            return parameter;\n-        }\n-    }\n-\n-    \/**\n-     * Helper class to collect all diagnostic generated during the execution of a given compilation task.\n-     *\/\n-    class DiagnosticCollector implements DiagnosticListener<JavaFileObject> {\n-\n-        Map<Diagnostic.Kind, List<Diagnostic<? extends JavaFileObject>>> diagsByKind = new HashMap<>();\n-        Map<String, List<Diagnostic<? extends JavaFileObject>>> diagsByKeys = new HashMap<>();\n-\n-        public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n-            List<Diagnostic<? extends JavaFileObject>> diags =\n-                    diagsByKeys.getOrDefault(diagnostic.getCode(), List.nil());\n-            diagsByKeys.put(diagnostic.getCode(), diags.prepend(diagnostic));\n-            Diagnostic.Kind kind = diagnostic.getKind();\n-            diags = diagsByKind.getOrDefault(kind, List.nil());\n-            diagsByKind.put(kind, diags.prepend(diagnostic));\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/combo\/ComboTask.java","additions":0,"deletions":462,"binary":false,"changes":462,"status":"deleted"},{"patch":"@@ -1,540 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.combo;\n-\n-import javax.tools.JavaCompiler;\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.ToolProvider;\n-\n-import java.util.stream.Stream;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Stack;\n-import java.util.function.Consumer;\n-import java.util.function.Predicate;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-\n-\n-\/**\n- * An helper class for defining combinatorial (aka \"combo\" tests). A combo test is made up of one\n- * or more 'dimensions' - each of which represent a different axis of the test space. For instance,\n- * if we wanted to test class\/interface declaration, one dimension could be the keyword used for\n- * the declaration (i.e. 'class' vs. 'interface') while another dimension could be the class\/interface\n- * modifiers (i.e. 'public', 'pachake-private' etc.). A combo test consists in running a test instance\n- * for each point in the test space; that is, for any combination of the combo test dimension:\n- * <p>\n- * 'public' 'class'\n- * 'public' interface'\n- * 'package-private' 'class'\n- * 'package-private' 'interface'\n- * ...\n- * <p>\n- * A new test instance {@link ComboInstance} is created, and executed, after its dimensions have been\n- * initialized accordingly. Each instance can either pass, fail or throw an unexpected error; this helper\n- * class defines several policies for how failures should be handled during a combo test execution\n- * (i.e. should errors be ignored? Do we want the first failure to result in a failure of the whole\n- * combo test?).\n- * <p>\n- * Additionally, this helper class allows to specify filter methods that can be used to throw out\n- * illegal combinations of dimensions - for instance, in the example above, we might want to exclude\n- * all combinations involving 'protected' and 'private' modifiers, which are disallowed for toplevel\n- * declarations.\n- * <p>\n- * While combo tests can be used for a variety of workloads, typically their main task will consist\n- * in performing some kind of javac compilation. For this purpose, this framework defines an optimized\n- * javac context {@link ReusableContext} which can be shared across multiple combo instances,\n- * when the framework detects it's safe to do so. This allows to reduce the overhead associated with\n- * compiler initialization when the test space is big.\n- *\/\n-public class ComboTestHelper<X extends ComboInstance<X>> {\n-\n-    \/** Failure mode. *\/\n-    FailMode failMode = FailMode.FAIL_FAST;\n-\n-    \/** Ignore mode. *\/\n-    IgnoreMode ignoreMode = IgnoreMode.IGNORE_NONE;\n-\n-    \/** Combo test instance filter. *\/\n-    Optional<Predicate<X>> optFilter = Optional.empty();\n-\n-    \/** Combo test dimensions. *\/\n-    List<DimensionInfo<?>> dimensionInfos = new ArrayList<>();\n-\n-    \/** Combo test stats. *\/\n-    Info info = new Info();\n-\n-    \/** Shared JavaCompiler used across all combo test instances. *\/\n-    JavaCompiler comp = ToolProvider.getSystemJavaCompiler();\n-\n-    \/** Shared file manager used across all combo test instances. *\/\n-    StandardJavaFileManager fm = comp.getStandardFileManager(null, null, null);\n-\n-    \/** Shared context used across all combo instances. *\/\n-    ReusableContext context = new ReusableContext();\n-\n-    \/**\n-     * Set failure mode for this combo test.\n-     *\/\n-    public ComboTestHelper<X> withFailMode(FailMode failMode) {\n-        this.failMode = failMode;\n-        return this;\n-    }\n-\n-    \/**\n-     * Set ignore mode for this combo test.\n-     *\/\n-    public ComboTestHelper<X> withIgnoreMode(IgnoreMode ignoreMode) {\n-        this.ignoreMode = ignoreMode;\n-        return this;\n-    }\n-\n-    \/**\n-     * Set a filter for combo test instances to be ignored.\n-     *\/\n-    public ComboTestHelper<X> withFilter(Predicate<X> filter) {\n-        optFilter = Optional.of(optFilter.map(filter::and).orElse(filter));\n-        return this;\n-    }\n-\n-    \/**\n-     * Adds a new dimension to this combo test, with a given name an array of values.\n-     *\/\n-    @SafeVarargs\n-    public final <D> ComboTestHelper<X> withDimension(String name, D... dims) {\n-        return withDimension(name, null, dims);\n-    }\n-\n-    \/**\n-     * Adds a new dimension to this combo test, with a given name, an array of values and a\n-     * coresponding setter to be called in order to set the dimension value on the combo test instance\n-     * (before test execution).\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    @SafeVarargs\n-    public final <D> ComboTestHelper<X> withDimension(String name, DimensionSetter<X, D> setter, D... dims) {\n-        dimensionInfos.add(new BasicDimensionInfo<>(name, dims, setter));\n-        return this;\n-    }\n-\n-    public enum ArrayDimensionKind {\n-        PERMUTATIONS,\n-        COMBINATIONS;\n-    }\n-\n-    \/**\n-     * Adds a new array dimension to this combo test, with a given base name. This allows to specify\n-     * multiple dimensions at once; the names of the underlying dimensions will be generated from the\n-     * base name, using standard array bracket notation - i.e. \"DIM[0]\", \"DIM[1]\", etc.\n-     *\/\n-    @SafeVarargs\n-    public final <D> ComboTestHelper<X> withArrayDimension(String name, int size, D... dims) {\n-        return withArrayDimension(name, null, size, ArrayDimensionKind.PERMUTATIONS, dims);\n-    }\n-\n-    @SafeVarargs\n-    public final <D> ComboTestHelper<X> withArrayDimension(String name, int size, ArrayDimensionKind kind, D... dims) {\n-        return withArrayDimension(name, null, size, kind, dims);\n-    }\n-\n-    \/**\n-     * Adds a new array dimension to this combo test, with a given base name, an array of values and a\n-     * coresponding array setter to be called in order to set the dimension value on the combo test\n-     * instance (before test execution). This allows to specify multiple dimensions at once; the names\n-     * of the underlying dimensions will be generated from the base name, using standard array bracket\n-     * notation - i.e. \"DIM[0]\", \"DIM[1]\", etc.\n-     *\/\n-    @SafeVarargs\n-    public final <D> ComboTestHelper<X> withArrayDimension(String name, ArrayDimensionSetter<X, D> setter, int size, D... dims) {\n-        return withArrayDimension(name, setter, size, ArrayDimensionKind.PERMUTATIONS, dims);\n-    }\n-\n-    @SafeVarargs\n-    public final <D> ComboTestHelper<X> withArrayDimension(String name, ArrayDimensionSetter<X, D> setter, int size, ArrayDimensionKind kind, D... dims) {\n-        if (kind == ArrayDimensionKind.PERMUTATIONS) {\n-            for (int i = 0 ; i < size ; i++) {\n-                dimensionInfos.add(new ArrayDimensionInfo<>(name, dims, i, setter));\n-            }\n-        } else {\n-            DependentArrayDimensionInfo<D> prev = null;\n-            for (int i = 0 ; i < size ; i++) {\n-                prev = new DependentArrayDimensionInfo<>(prev, name, dims, i, setter);\n-                dimensionInfos.add(prev);\n-            }\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Returns the stat object associated with this combo test.\n-     *\/\n-    public Info info() {\n-        return info;\n-    }\n-\n-    \/**\n-     * Runs this combo test. This will generate the combinatorial explosion of all dimensions, and\n-     * execute a new test instance (built using given supplier) for each such combination.\n-     *\/\n-    public void run(Supplier<X> instanceBuilder) {\n-        run(instanceBuilder, null);\n-    }\n-\n-    \/**\n-     * Runs this combo test. This will generate the combinatorial explosion of all dimensions, and\n-     * execute a new test instance (built using given supplier) for each such combination. Before\n-     * executing the test instance entry point, the supplied initialization method is called on\n-     * the test instance; this is useful for ad-hoc test instance initialization once all the dimension\n-     * values have been set.\n-     *\/\n-    public void run(Supplier<X> instanceBuilder, Consumer<X> initAction) {\n-        runInternal(0, new Stack<>(), instanceBuilder, Optional.ofNullable(initAction));\n-        end();\n-    }\n-\n-    \/**\n-     * Generate combinatorial explosion of all dimension values and create a new test instance\n-     * for each combination.\n-     *\/\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    private void runInternal(int index, Stack<DimensionBinding<?>> bindings, Supplier<X> instanceBuilder, Optional<Consumer<X>> initAction) {\n-        if (index == dimensionInfos.size()) {\n-            runCombo(instanceBuilder, initAction, bindings);\n-        } else {\n-            DimensionInfo<?> dinfo = dimensionInfos.get(index);\n-            for (Object d : dinfo.dimensions(bindings)) {\n-                bindings.push(new DimensionBinding(d, dinfo));\n-                runInternal(index + 1, bindings, instanceBuilder, initAction);\n-                bindings.pop();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Run a new test instance using supplied dimension bindings. All required setters and initialization\n-     * method are executed before calling the instance main entry point. Also checks if the instance\n-     * is compatible with the specified test filters; if not, the test is simply skipped.\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    private void runCombo(Supplier<X> instanceBuilder, Optional<Consumer<X>> initAction, List<DimensionBinding<?>> bindings) {\n-        X x = instanceBuilder.get();\n-        for (DimensionBinding<?> binding : bindings) {\n-            binding.init(x);\n-        }\n-        initAction.ifPresent(action -> action.accept(x));\n-        info.comboCount++;\n-        if (!optFilter.isPresent() || optFilter.get().test(x)) {\n-            x.run(new Env(bindings));\n-            if (failMode.shouldStop(ignoreMode, info)) {\n-                end();\n-            }\n-        } else {\n-            info.skippedCount++;\n-        }\n-    }\n-\n-    \/**\n-     * This method is executed upon combo test completion (either normal or erroneous). Closes down\n-     * all pending resources and dumps useful stats info.\n-     *\/\n-    private void end() {\n-        try {\n-            fm.close();\n-            if (info.hasFailures()) {\n-                throw new AssertionError(\"Failure when executing combo:\" + info.lastFailure.orElse(\"\"));\n-            } else if (info.hasErrors()) {\n-                throw new AssertionError(\"Unexpected exception while executing combo\", info.lastError.get());\n-            }\n-        } catch (IOException ex) {\n-            throw new AssertionError(\"Failure when closing down shared file manager; \", ex);\n-        } finally {\n-            info.dump();\n-        }\n-    }\n-\n-    \/**\n-     * Functional interface for specifying combo test instance setters.\n-     *\/\n-    public interface DimensionSetter<X extends ComboInstance<X>, D> {\n-        void set(X x, D d);\n-    }\n-\n-    \/**\n-     * Functional interface for specifying combo test instance array setters. The setter method\n-     * receives an extra argument for the index of the array element to be set.\n-     *\/\n-    public interface ArrayDimensionSetter<X extends ComboInstance<X>, D> {\n-        void set(X x, D d, int index);\n-    }\n-\n-    \/**\n-     * Dimension descriptor; each dimension has a name, an array of value and an optional setter\n-     * to be called on the associated combo test instance.\n-     *\/\n-    abstract class DimensionInfo<D> {\n-        String name;\n-        Optional<DimensionSetter<X, D>> optSetter;\n-\n-        DimensionInfo(String name, DimensionSetter<X, D> setter) {\n-            this.name = name;\n-            this.optSetter = Optional.ofNullable(setter);\n-        }\n-\n-        abstract Iterable<D> dimensions(Stack<DimensionBinding<?>> bindings);\n-    }\n-\n-    class BasicDimensionInfo<D> extends DimensionInfo<D> {\n-        D[] dims;\n-\n-        BasicDimensionInfo(String name, D[] dims, DimensionSetter<X, D> setter) {\n-            super(name, setter);\n-            this.dims = dims;\n-        }\n-\n-        @Override\n-        public Iterable<D> dimensions(Stack<DimensionBinding<?>> bindings) {\n-            return new ArrayIterable<D>(0, dims);\n-        }\n-    }\n-\n-    \/**\n-     * Array dimension descriptor. The dimension name is derived from a base name and an index using\n-     * standard bracket notation; ; the setter accepts an additional 'index' argument to point\n-     * to the array element to be initialized.\n-     *\/\n-    class ArrayDimensionInfo<D> extends BasicDimensionInfo<D> {\n-        public ArrayDimensionInfo(String name, D[] dims, int index, ArrayDimensionSetter<X, D> setter) {\n-            super(String.format(\"%s[%d]\", name, index), dims,\n-                    setter != null ? (x, d) -> setter.set(x, d, index) : null);\n-        }\n-    }\n-\n-    \/**\n-     * Dependent array dimension descriptor. The dimension name is derived from a base name and an index using\n-     * standard bracket notation; ; the setter accepts an additional 'index' argument to point\n-     * to the array element to be initialized.\n-     *\/\n-    class DependentArrayDimensionInfo<D> extends BasicDimensionInfo<D> {\n-\n-        DependentArrayDimensionInfo<D> prev;\n-\n-        public DependentArrayDimensionInfo(DependentArrayDimensionInfo<D> prev, String name, D[] dims, int index, ArrayDimensionSetter<X, D> setter) {\n-            super(String.format(\"%s[%d]\", name, index), dims,\n-                    setter != null ? (x, d) -> setter.set(x, d, index) : null);\n-            this.prev = prev;\n-        }\n-\n-        @Override\n-        public Iterable<D> dimensions(Stack<DimensionBinding<?>> bindings) {\n-            if (bindings.peek().info == prev) {\n-                Object d = bindings.peek().d;\n-                for (int i = 0 ; i < dims.length ; i++) {\n-                    if (dims[i] == d) {\n-                        return new ArrayIterable<>(i, dims);\n-                    }\n-                }\n-                throw new IllegalStateException(\"BAD\");\n-            } else {\n-                return super.dimensions(bindings);\n-            }\n-        }\n-    }\n-\n-    static class ArrayIterable<D> implements Iterable<D> {\n-        int start;\n-        D[] dims;\n-\n-        public ArrayIterable(int start, D[] dims) {\n-            this.start = start;\n-            this.dims = dims;\n-        }\n-\n-        public Iterator<D> iterator() {\n-           return new Iterator<D>() {\n-                private int curr = start;\n-\n-                public boolean hasNext() {\n-                   return dims.length > curr;\n-                }\n-\n-                public D next() {\n-                   return dims[curr++];\n-                }\n-            };\n-        }\n-    }\n-\n-    \/**\n-     * Failure policies for a combo test run.\n-     *\/\n-    public enum FailMode {\n-        \/** Combo test fails when first failure is detected. *\/\n-        FAIL_FAST,\n-        \/** Combo test fails after all instances have been executed. *\/\n-        FAIL_AFTER;\n-\n-        boolean shouldStop(IgnoreMode ignoreMode, Info info) {\n-            switch (this) {\n-                case FAIL_FAST:\n-                    return !ignoreMode.canIgnore(info);\n-                default:\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Ignore policies for a combo test run.\n-     *\/\n-    public enum IgnoreMode {\n-        \/** No error or failure is ignored. *\/\n-        IGNORE_NONE,\n-        \/** Only errors are ignored. *\/\n-        IGNORE_ERRORS,\n-        \/** Only failures are ignored. *\/\n-        IGNORE_FAILURES,\n-        \/** Both errors and failures are ignored. *\/\n-        IGNORE_ALL;\n-\n-        boolean canIgnore(Info info) {\n-            switch (this) {\n-                case IGNORE_ERRORS:\n-                    return info.failCount == 0;\n-                case IGNORE_FAILURES:\n-                    return info.errCount == 0;\n-                case IGNORE_ALL:\n-                    return true;\n-                default:\n-                    return info.failCount == 0 && info.errCount == 0;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A dimension binding. This is essentially a pair of a dimension value and its corresponding\n-     * dimension info.\n-     *\/\n-    class DimensionBinding<D> {\n-        D d;\n-        DimensionInfo<D> info;\n-\n-        DimensionBinding(D d, DimensionInfo<D> info) {\n-            this.d = d;\n-            this.info = info;\n-        }\n-\n-        void init(X x) {\n-            info.optSetter.ifPresent(setter -> setter.set(x, d));\n-        }\n-\n-        public String toString() {\n-            return String.format(\"(%s -> %s)\", info.name, d);\n-        }\n-    }\n-\n-    \/**\n-     * This class is used to keep track of combo tests stats; info such as numbero of failures\/errors,\n-     * number of times a context has been shared\/dropped are all recorder here.\n-     *\/\n-    public static class Info {\n-        int failCount;\n-        int errCount;\n-        int passCount;\n-        int comboCount;\n-        int skippedCount;\n-        int ctxReusedCount;\n-        int ctxDroppedCount;\n-        Optional<String> lastFailure = Optional.empty();\n-        Optional<Throwable> lastError = Optional.empty();\n-\n-        void dump() {\n-            System.err.println(String.format(\"%d total checks executed\", comboCount));\n-            System.err.println(String.format(\"%d successes found\", passCount));\n-            System.err.println(String.format(\"%d failures found\", failCount));\n-            System.err.println(String.format(\"%d errors found\", errCount));\n-            System.err.println(String.format(\"%d skips found\", skippedCount));\n-            System.err.println(String.format(\"%d contexts shared\", ctxReusedCount));\n-            System.err.println(String.format(\"%d contexts dropped\", ctxDroppedCount));\n-        }\n-\n-        public int getComboCount() { return comboCount; }\n-\n-        public boolean hasFailures() {\n-            return failCount != 0;\n-        }\n-\n-        public boolean hasErrors() {\n-            return errCount != 0;\n-        }\n-    }\n-\n-    \/**\n-     * THe execution environment for a given combo test instance. An environment contains the\n-     * bindings for all the dimensions, along with the combo parameter cache (this is non-empty\n-     * only if one or more dimensions are subclasses of the {@code ComboParameter} interface).\n-     *\/\n-    class Env {\n-        List<DimensionBinding<?>> bindings;\n-        Map<String, ComboParameter> parametersCache = new HashMap<>();\n-\n-        @SuppressWarnings({\"Unchecked\", \"rawtypes\"})\n-        Env(List<DimensionBinding<?>> bindings) {\n-            this.bindings = bindings;\n-            for (DimensionBinding<?> binding : bindings) {\n-                if (binding.d instanceof ComboParameter) {\n-                    parametersCache.put(binding.info.name, (ComboParameter)binding.d);\n-                };\n-            }\n-        }\n-\n-        Info info() {\n-            return ComboTestHelper.this.info();\n-        }\n-\n-        StandardJavaFileManager fileManager() {\n-            return fm;\n-        }\n-\n-        JavaCompiler javaCompiler() {\n-            return comp;\n-        }\n-\n-        ReusableContext context() {\n-            return context;\n-        }\n-\n-        ReusableContext setContext(ReusableContext context) {\n-            return ComboTestHelper.this.context = context;\n-        }\n-    }\n-}\n-\n-\n-\n","filename":"test\/lib\/jdk\/test\/lib\/combo\/ComboTestHelper.java","additions":0,"deletions":540,"binary":false,"changes":540,"status":"deleted"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.combo;\n-\n-import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.util.JavacTask;\n-import com.sun.source.util.TaskEvent;\n-import com.sun.source.util.TaskEvent.Kind;\n-import com.sun.source.util.TaskListener;\n-import com.sun.source.util.TreeScanner;\n-import com.sun.tools.javac.api.MultiTaskListener;\n-import com.sun.tools.javac.code.Kinds;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.code.Type.ClassType;\n-import com.sun.tools.javac.code.TypeTag;\n-import com.sun.tools.javac.code.Types;\n-import com.sun.tools.javac.comp.Annotate;\n-import com.sun.tools.javac.comp.Check;\n-import com.sun.tools.javac.comp.CompileStates;\n-import com.sun.tools.javac.comp.Enter;\n-import com.sun.tools.javac.comp.Modules;\n-import com.sun.tools.javac.main.Arguments;\n-import com.sun.tools.javac.main.JavaCompiler;\n-import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Log;\n-\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticListener;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-\/**\n- * A reusable context is a context that can be used safely across multiple compilation rounds\n- * arising from execution of a combo test. It achieves reuse by replacing some components\n- * (most notably JavaCompiler and Log) with reusable counterparts, and by exposing a method\n- * to cleanup leftovers from previous compilation.\n- * <p>\n- * There are, however, situations in which reusing the context is not safe: (i) when different\n- * compilations are using different sets of compiler options (as most option values are cached\n- * inside components themselves) and (ii) when the compilation unit happens to redefine classes\n- * in the java.* packages.\n- *\/\n-class ReusableContext extends Context implements TaskListener {\n-\n-    Set<CompilationUnitTree> roots = new HashSet<>();\n-\n-    String opts;\n-    boolean polluted = false;\n-\n-    ReusableContext() {\n-        super();\n-        put(Log.logKey, ReusableLog.factory);\n-        put(JavaCompiler.compilerKey, ReusableJavaCompiler.factory);\n-    }\n-\n-    void clear() {\n-        drop(Arguments.argsKey);\n-        drop(DiagnosticListener.class);\n-        drop(Log.outKey);\n-        drop(Log.errKey);\n-        drop(JavaFileManager.class);\n-        drop(JavacTask.class);\n-\n-        if (ht.get(Log.logKey) instanceof ReusableLog) {\n-            \/\/log already inited - not first round\n-            ((ReusableLog)Log.instance(this)).clear();\n-            Enter.instance(this).newRound();\n-            ((ReusableJavaCompiler)ReusableJavaCompiler.instance(this)).clear();\n-            Types.instance(this).newRound();\n-            Check.instance(this).newRound();\n-            Modules.instance(this).newRound();\n-            Annotate.instance(this).newRound();\n-            CompileStates.instance(this).clear();\n-            MultiTaskListener.instance(this).clear();\n-\n-            \/\/find if any of the roots have redefined java.* classes\n-            Symtab syms = Symtab.instance(this);\n-            pollutionScanner.scan(roots, syms);\n-            roots.clear();\n-        }\n-    }\n-\n-    \/**\n-     * This scanner detects as to whether the shared context has been polluted. This happens\n-     * whenever a compiled program redefines a core class (in 'java.*' package) or when\n-     * (typically because of cyclic inheritance) the symbol kind of a core class has been touched.\n-     *\/\n-    TreeScanner<Void, Symtab> pollutionScanner = new TreeScanner<Void, Symtab>() {\n-        @Override\n-        public Void visitClass(ClassTree node, Symtab syms) {\n-            Symbol sym = ((JCClassDecl)node).sym;\n-            if (sym != null) {\n-                syms.removeClass(sym.packge().modle, sym.flatName());\n-                Type sup = supertype(sym);\n-                if (isCoreClass(sym) ||\n-                        (sup != null && isCoreClass(sup.tsym) && sup.tsym.kind != Kinds.Kind.TYP)) {\n-                    polluted = true;\n-                }\n-            }\n-            return super.visitClass(node, syms);\n-        }\n-\n-        private boolean isCoreClass(Symbol s) {\n-            return s.flatName().toString().startsWith(\"java.\");\n-        }\n-\n-        private Type supertype(Symbol s) {\n-            if (s.type == null ||\n-                    !s.type.hasTag(TypeTag.CLASS)) {\n-                return null;\n-            } else {\n-                ClassType ct = (ClassType)s.type;\n-                return ct.supertype_field;\n-            }\n-        }\n-    };\n-\n-    @Override\n-    public void finished(TaskEvent e) {\n-        if (e.getKind() == Kind.PARSE) {\n-            roots.add(e.getCompilationUnit());\n-        }\n-    }\n-\n-    @Override\n-    public void started(TaskEvent e) {\n-        \/\/do nothing\n-    }\n-\n-    <T> void drop(Key<T> k) {\n-        ht.remove(k);\n-    }\n-\n-    <T> void drop(Class<T> c) {\n-        ht.remove(key(c));\n-    }\n-\n-    \/**\n-     * Reusable JavaCompiler; exposes a method to clean up the component from leftovers associated with\n-     * previous compilations.\n-     *\/\n-    static class ReusableJavaCompiler extends JavaCompiler {\n-\n-        static Factory<JavaCompiler> factory = ReusableJavaCompiler::new;\n-\n-        ReusableJavaCompiler(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public void close() {\n-            \/\/do nothing\n-        }\n-\n-        void clear() {\n-            newRound();\n-        }\n-\n-        @Override\n-        protected void checkReusable() {\n-            \/\/do nothing - it's ok to reuse the compiler\n-        }\n-    }\n-\n-    \/**\n-     * Reusable Log; exposes a method to clean up the component from leftovers associated with\n-     * previous compilations.\n-     *\/\n-    static class ReusableLog extends Log {\n-\n-        static Factory<Log> factory = ReusableLog::new;\n-\n-        Context context;\n-\n-        ReusableLog(Context context) {\n-            super(context);\n-            this.context = context;\n-        }\n-\n-        void clear() {\n-            recorded.clear();\n-            sourceMap.clear();\n-            nerrors = 0;\n-            nwarnings = 0;\n-            \/\/Set a fake listener that will lazily lookup the context for the 'real' listener. Since\n-            \/\/this field is never updated when a new task is created, we cannot simply reset the field\n-            \/\/or keep old value. This is a hack to workaround the limitations in the current infrastructure.\n-            diagListener = new DiagnosticListener<JavaFileObject>() {\n-                DiagnosticListener<JavaFileObject> cachedListener;\n-\n-                @Override\n-                @SuppressWarnings(\"unchecked\")\n-                public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n-                    if (cachedListener == null) {\n-                        cachedListener = context.get(DiagnosticListener.class);\n-                    }\n-                    cachedListener.report(diagnostic);\n-                }\n-            };\n-        }\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/combo\/ReusableContext.java","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"}]}