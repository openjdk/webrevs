{"files":[{"patch":"@@ -4524,0 +4524,3 @@\n+        if (types.isNonNullable(clazztype)) {\n+            tree.strict = true;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,3 +65,4 @@\n-        UNLAMBDA(10),\n-        STRICT_FIELDS_PROXIES(11),\n-        GENERATE(12);\n+        NULL_CHECKS_WRITER(10),\n+        UNLAMBDA(11),\n+        STRICT_FIELDS_PROXIES(12),\n+        GENERATE(13);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.tree.*;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.ListBuffer;\n+\n+import static com.sun.tools.javac.code.TypeTag.VOID;\n+\n+\/** This pass generates null checks for the compiler to check for assertions on\n+ *  null restricted types.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class NullChecksWriter extends TreeTranslator {\n+\n+    protected static final Context.Key<NullChecksWriter> nullChecksWriterKey = new Context.Key<>();\n+\n+    public static NullChecksWriter instance(Context context) {\n+        NullChecksWriter instance = context.get(nullChecksWriterKey);\n+        if (instance == null)\n+            instance = new NullChecksWriter(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private TreeMaker make;\n+    private final Attr attr;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected NullChecksWriter(Context context) {\n+        context.put(nullChecksWriterKey, this);\n+        make = TreeMaker.instance(context);\n+        types = Types.instance(context);\n+        attr = Attr.instance(context);\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        try {\n+            this.make = make;\n+            return translate(cdef);\n+        } finally {\n+            \/\/ note that recursive invocations of this method fail hard\n+            this.make = null;\n+        }\n+    }\n+\n+    \/* ************************************************************************\n+     * Visitor methods\n+     *************************************************************************\/\n+\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+        super.visitVarDef(tree);\n+        if (tree.init != null) {\n+            if (types.isNonNullable(tree.sym.type)) {\n+                tree.init = attr.makeNullCheck(tree.init, true);\n+            }\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitAssign(JCAssign tree) {\n+        \/\/ could be null for indexed array accesses, we should deal with those later\n+        super.visitAssign(tree);\n+        Symbol lhsSym = TreeInfo.symbolFor(tree.lhs);\n+        Symbol rhsSym = TreeInfo.symbolFor(tree.rhs);\n+        if (lhsSym != null &&\n+                rhsSym != null &&\n+                types.isNonNullable(lhsSym.type)) {\n+            tree.rhs = attr.makeNullCheck(tree.rhs, true);\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitAssignop(JCAssignOp tree) {\n+        super.visitAssignop(tree);\n+        Symbol lhsSym = TreeInfo.symbolFor(tree.lhs);\n+        Symbol rhsSym = TreeInfo.symbolFor(tree.rhs);\n+        if (lhsSym != null &&\n+                rhsSym != null &&\n+                types.isNonNullable(lhsSym.type)) {\n+            tree.rhs = attr.makeNullCheck(tree.rhs, true);\n+        }\n+        result = tree;\n+    }\n+\n+    public void visitTypeCast(JCTypeCast tree) {\n+        super.visitTypeCast(tree);\n+        if (tree.strict) {\n+            tree.expr = attr.makeNullCheck(tree.expr, true);\n+        }\n+        result = tree;\n+    }\n+\n+    Type returnType = null;\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        super.visitMethodDef(tree);\n+        Type prevRetType = returnType;\n+        try {\n+            returnType = tree.sym.type.getReturnType();\n+            ListBuffer<JCStatement> paramNullChecks = new ListBuffer<>();\n+            for (JCVariableDecl param : tree.params) {\n+                if (types.isNonNullable(param.sym.type)) {\n+                    paramNullChecks.add(make.at(tree.body.pos())\n+                            .Exec(attr.makeNullCheck(make.at(tree.body.pos()).Ident(param), true)));\n+                }\n+            }\n+            if (!paramNullChecks.isEmpty()) {\n+                tree.body.stats = tree.body.stats.prependList(paramNullChecks.toList());\n+            }\n+            result = tree;\n+        } finally {\n+            returnType = prevRetType;\n+        }\n+    }\n+\n+    @Override\n+    public void visitReturn(JCReturn tree) {\n+        super.visitReturn(tree);\n+        if (tree.expr != null && returnType != null && !returnType.hasTag(VOID)) {\n+            Symbol sym = TreeInfo.symbolFor(tree.expr);\n+            if (sym != null && types.isNonNullable(returnType)) {\n+                tree.expr = attr.makeNullCheck(tree.expr, true);\n+            }\n+        }\n+        result = tree;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -181,21 +181,0 @@\n-    JCExpression generateNullCheckIfNeeded(JCExpression tree) {\n-        if (expectedNullness == NullMarker.NOT_NULL && !types.isNonNullable(tree.type)) {\n-            return attr.makeNullCheck(tree, true);\n-        }\n-        return tree;\n-    }\n-\n-    \/** Translate method argument list, casting each argument\n-     *  to its corresponding type in a list of target types.\n-     *  @param _args               The method argument list.\n-     *  @param parameters          The list of target types.\n-     *  @param varargsElement      The erasure of the varargs element type,\n-     *                             or null if translating a non-varargs invocation\n-     *\/\n-    <T extends JCTree> List<T> translateArgs(List<T> _args,\n-                                             List<Type> parameters,\n-                                             Type varargsElement) {\n-        return translateArgs(_args, parameters, parameters.map(t -> NullMarker.UNSPECIFIED),\n-                varargsElement, NullMarker.UNSPECIFIED);\n-    }\n-\n@@ -204,6 +183,4 @@\n-     *  @param _args                      The method argument list.\n-     *  @param parameters                 The list of target types (after erasure).\n-     *  @param paramsNullMarkers          The list of null markers of the target types\n-     *  @param varargsElement             The erasure of the varargs element type,\n-     *                                    or null if translating a non-varargs invocation\n-     *  @param varargsElementNullMarker   The null marker of the varargs element type\n+     *  @param _args            The method argument list.\n+     *  @param parameters       The list of target types.\n+     *  @param varargsElement   The erasure of the varargs element type,\n+     *  or null if translating a non-varargs invocation\n@@ -213,3 +190,1 @@\n-                                           List<NullMarker> paramsNullMarkers,\n-                                           Type varargsElement,\n-                                           NullMarker varargsElementNullMarker) {\n+                                           Type varargsElement) {\n@@ -219,1 +194,1 @@\n-            args.head = translate(args.head, parameters.head, paramsNullMarkers.head);\n+            args.head = translate(args.head, parameters.head);\n@@ -222,1 +197,0 @@\n-            paramsNullMarkers = paramsNullMarkers.tail;\n@@ -228,1 +202,1 @@\n-                args.head = translate(args.head, varargsElement, varargsElementNullMarker);\n+                args.head = translate(args.head, varargsElement);\n@@ -232,1 +206,1 @@\n-            args.head = translate(args.head, parameter, paramsNullMarkers.head);\n+            args.head = translate(args.head, parameter);\n@@ -468,2 +442,0 @@\n-    private NullMarker expectedNullness = NullMarker.UNSPECIFIED;\n-\n@@ -473,4 +445,0 @@\n-        return translate(tree, pt, NullMarker.UNSPECIFIED);\n-    }\n-\n-    public <T extends JCTree> T translate(T tree, Type pt, NullMarker expectedNullness) {\n@@ -478,1 +446,0 @@\n-        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -481,1 +448,0 @@\n-            this.expectedNullness = expectedNullness;\n@@ -485,1 +451,0 @@\n-            this.expectedNullness = prevExpectedNullness;\n@@ -492,4 +457,0 @@\n-        return translate(trees, pt, NullMarker.UNSPECIFIED);\n-    }\n-\n-    public <T extends JCTree> List<T> translate(List<T> trees, Type pt, NullMarker expectedNullness) {\n@@ -497,1 +458,0 @@\n-        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -501,1 +461,0 @@\n-            this.expectedNullness = expectedNullness;\n@@ -505,1 +464,0 @@\n-            this.expectedNullness = prevExpectedNullness;\n@@ -535,1 +493,1 @@\n-        tree.init = translate(tree.init, tree.sym.erasure(types), tree.type.getNullMarker());\n+        tree.init = translate(tree.init, tree.sym.erasure(types));\n@@ -892,1 +850,0 @@\n-        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -923,1 +880,0 @@\n-        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -954,1 +910,0 @@\n-        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -974,2 +929,0 @@\n-        List<NullMarker> paramsNullMarkers = meth.type.getParameterTypes().map(t->t.getNullMarker());\n-        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -992,1 +945,1 @@\n-        tree.args = translateArgs(tree.args, argtypes, paramsNullMarkers, tree.varargsElement, varargsElementNullMarker);\n+        tree.args = translateArgs(tree.args, argtypes, tree.varargsElement);\n@@ -997,1 +950,0 @@\n-        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1019,1 +971,0 @@\n-        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -1023,1 +974,1 @@\n-            tree.args, argtypes, tree.constructor.type.getParameterTypes().map(t->t.getNullMarker()), tree.varargsElement, varargsElementNullMarker);\n+            tree.args, argtypes, tree.varargsElement);\n@@ -1045,1 +996,1 @@\n-        tree.expr = translate(tree.expr, pt, expectedNullness);\n+        tree.expr = translate(tree.expr, pt);\n@@ -1051,3 +1002,0 @@\n-        if (types.isNonNullable(tree.lhs.type) && !types.isNonNullable(tree.rhs.type)) {\n-            tree.rhs = attr.makeNullCheck(tree.rhs);\n-        }\n@@ -1058,1 +1006,0 @@\n-        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1091,3 +1038,1 @@\n-        if (types.isNonNullable(tree.clazz.type) && !types.isNonNullable(tree.expr.type)) {\n-            tree.expr = attr.makeNullCheck(tree.expr);\n-        }\n+        \/\/ the information in tree.clazz.type is lost, so probably we need to do this one here\n@@ -1116,1 +1061,0 @@\n-        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1137,1 +1081,0 @@\n-        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1160,1 +1103,0 @@\n-            result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1183,2 +1125,1 @@\n-            result = generateNullCheckIfNeeded(tree);\n-            result = retype((JCExpression) result, tree.sym.erasure(types), pt);\n+            result = retype(tree, tree.sym.erasure(types), pt);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":14,"deletions":73,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1708,0 +1708,7 @@\n+            if (shouldStop(CompileState.NULL_CHECKS_WRITER))\n+                return;\n+            for (JCTree def : cdefs) {\n+                NullChecksWriter.instance(context).translateTopLevelClass(def, localMake);\n+            }\n+            compileStates.put(env, CompileState.NULL_CHECKS_WRITER);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3786,1 +3786,1 @@\n-            JCExpression t = term(EXPR | TYPE);\n+            JCExpression t = term(EXPR | TYPE | ALLOW_BANGS);\n@@ -4272,1 +4272,1 @@\n-        JCExpression t = term(EXPR | TYPE);\n+        JCExpression t = term(EXPR | TYPE | ALLOW_BANGS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2266,0 +2266,1 @@\n+        public boolean strict = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,0 +79,23 @@\n+                \/\/ local variables\n+                \"\"\"\n+                import java.util.*;\n+                class Test {\n+                    public static void main(String... args) {\n+                        List<String> list = new ArrayList<>();\n+                        list.add(null);\n+                        for (String! s : list) {\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \/*\"\"\"\n+                class Test {\n+                    record R(String x) {}\n+                    static void m(Object obj) {\n+                        if (obj instanceof R(String! x)) {}  \/\/ should not match not throw NPE\n+                    }\n+                    public static void main(String... args) {\n+                        m(new R(null));\n+                    }\n+                }\n+                \"\"\",*\/\n@@ -114,1 +137,1 @@\n-                \"\"\"\n+                \/*\"\"\"\n@@ -133,1 +156,1 @@\n-                \"\"\",\n+                \"\"\",*\/\n@@ -146,0 +169,2 @@\n+                            \/\/ as the outer is inserted after the fact, we are checking the outer class argument not `o`,\n+                            \/\/ need to fix this\n@@ -169,63 +194,0 @@\n-                \"\"\",\n-                \"\"\"\n-                class Test {\n-                    class Inner {\n-                        class MyPrivilegedAction<T> {\n-                            MyPrivilegedAction(String s, Object!... o) {}\n-                        }\n-                    }\n-                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n-                    boolean isSystemProperty(Inner inner, Object o) {\n-                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o) {} );\n-                    }\n-                    void doTest() {\n-                        Inner inner = new Inner();\n-                        isSystemProperty(inner, null);\n-                    }\n-                    public static void main(String... args) {\n-                        Test test = new Test();\n-                        test.doTest();\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                class Test {\n-                    class Inner {\n-                        class MyPrivilegedAction<T> {\n-                            MyPrivilegedAction(String s, Object!... o) {}\n-                        }\n-                    }\n-                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n-                    boolean isSystemProperty(Inner inner, Object o) {\n-                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o, o) {} );\n-                    }\n-                    void doTest() {\n-                        Inner inner = new Inner();\n-                        isSystemProperty(inner, null);\n-                    }\n-                    public static void main(String... args) {\n-                        Test test = new Test();\n-                        test.doTest();\n-                    }\n-                }\n-                \"\"\",\n-                \"\"\"\n-                class Test {\n-                    class Inner {\n-                        class MyPrivilegedAction<T> {\n-                            MyPrivilegedAction(String s, Object!... o) {}\n-                        }\n-                    }\n-                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n-                    boolean isSystemProperty(Inner inner, Object o) {\n-                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", new Object(), o) {} );\n-                    }\n-                    void doTest() {\n-                        Inner inner = new Inner();\n-                        isSystemProperty(inner, null);\n-                    }\n-                    public static void main(String... args) {\n-                        Test test = new Test();\n-                        test.doTest();\n-                    }\n-                }\n@@ -245,0 +207,1 @@\n+                        \/\/ same issue as with inner classes\n@@ -353,9 +316,13 @@\n-            String output = new JavaTask(tb)\n-                    .classpath(out.toString())\n-                    .classArgs(\"Test\")\n-                    .vmOptions(\"--enable-preview\")\n-                    .run(Task.Expect.FAIL)\n-                    .writeAll()\n-                    .getOutput(Task.OutputKind.STDERR);\n-            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError.getName())) {\n-                throw new AssertionError(expectedError.getName() + \" expected\");\n+            try {\n+                String output = new JavaTask(tb)\n+                        .classpath(out.toString())\n+                        .classArgs(\"Test\")\n+                        .vmOptions(\"--enable-preview\")\n+                        .run(Task.Expect.FAIL)\n+                        .writeAll()\n+                        .getOutput(Task.OutputKind.STDERR);\n+                if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError.getName())) {\n+                    throw new AssertionError(expectedError.getName() + \" expected\");\n+                }\n+            } catch (Throwable t) {\n+                throw new AssertionError(\"failing for test case \" + testCode);\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":41,"deletions":74,"binary":false,"changes":115,"status":"modified"}]}