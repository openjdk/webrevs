{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,5 +183,7 @@\n-  UTIL_LOOKUP_PROGS(JAVAC_CHECK, javac, , NOFIXPATH)\n-  UTIL_LOOKUP_PROGS(JAVA_CHECK, java, , NOFIXPATH)\n-  BINARY=\"$JAVAC_CHECK\"\n-  if test \"x$JAVAC_CHECK\" = x; then\n-    BINARY=\"$JAVA_CHECK\"\n+  UTIL_LOOKUP_PROGS(JAVAC_CHECK, javac)\n+  UTIL_GET_EXECUTABLE(JAVAC_CHECK) # Will setup JAVAC_CHECK_EXECUTABLE\n+  UTIL_LOOKUP_PROGS(JAVA_CHECK, java)\n+  UTIL_GET_EXECUTABLE(JAVA_CHECK) # Will setup JAVA_CHECK_EXECUTABLE\n+  BINARY=\"$JAVAC_CHECK_EXECUTABLE\"\n+  if test \"x$JAVAC_CHECK_EXECUTABLE\" = x; then\n+    BINARY=\"$JAVA_CHECK_EXECUTABLE\"\n","filename":"make\/autoconf\/boot-jdk.m4","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -408,0 +408,8 @@\n+\n+  UTIL_ARG_WITH(NAME: jcov-modules, TYPE: string,\n+      DEFAULT: [], RESULT: JCOV_MODULES_COMMMA_SEPARATED,\n+      DESC: [which modules to include in jcov (comma-separated)],\n+      OPTIONAL: true)\n+\n+  # Replace \",\"  with \" \".\n+  JCOV_MODULES=${JCOV_MODULES_COMMMA_SEPARATED\/\/,\/ }\n@@ -412,0 +420,1 @@\n+  AC_SUBST(JCOV_MODULES)\n","filename":"make\/autoconf\/jdk-options.m4","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        \"linux-x64\", \"linux-x86\", \"macosx-x64\", \"macosx-aarch64\",\n+        \"macosx-x64\", \"macosx-aarch64\",\n@@ -246,2 +246,2 @@\n-        \"linux-aarch64\", \"linux-arm32\", \"linux-ppc64le\", \"linux-s390x\",\n-        \"linux-riscv64\"\n+        \"linux-x64\", \"linux-aarch64\",\n+        \"linux-arm32\", \"linux-ppc64le\", \"linux-s390x\", \"linux-riscv64\"\n@@ -286,3 +286,0 @@\n-    common.configure_args_64bit = [\"--with-target-bits=64\"];\n-    common.configure_args_32bit = [\"--with-target-bits=32\"];\n-\n@@ -415,27 +412,0 @@\n-\n-        \"linux-x64\": {\n-            target_os: \"linux\",\n-            target_cpu: \"x64\",\n-            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\", \"tidy\"],\n-            configure_args: concat(\n-                (input.build_cpu == \"x64\" ? common.configure_args_64bit\n-                 : \"--openjdk-target=x86_64-linux-gnu\"),\n-                \"--with-zlib=system\", \"--disable-dtrace\",\n-                (isWsl(input) ? [ \"--host=x86_64-unknown-linux-gnu\",\n-                    \"--build=x86_64-unknown-linux-gnu\" ] : [])),\n-        },\n-\n-        \"linux-x86\": {\n-            target_os: \"linux\",\n-            target_cpu: \"x86\",\n-            build_cpu: \"x64\",\n-            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n-            configure_args: concat(common.configure_args_32bit, [\n-                \"--with-jvm-variants=minimal,server\",\n-                \"--with-zlib=system\",\n-                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n-                \"--enable-libffi-bundling\",\n-                \"--enable-fallback-linker\"\n-            ])\n-        },\n-\n@@ -446,1 +416,2 @@\n-            configure_args: concat(common.configure_args_64bit, \"--with-zlib=system\",\n+            configure_args: [\n+                \"--with-zlib=system\",\n@@ -451,1 +422,2 @@\n-                \"SETFILE=\/usr\/bin\/SetFile\"),\n+                \"SETFILE=\/usr\/bin\/SetFile\"\n+            ],\n@@ -458,2 +430,3 @@\n-            configure_args: concat(common.configure_args_64bit,\n-                \"--with-macosx-version-max=11.00.00\"),\n+            configure_args: [\n+                \"--with-macosx-version-max=11.00.00\"\n+            ],\n@@ -466,1 +439,1 @@\n-            configure_args: concat(common.configure_args_64bit),\n+            configure_args: [],\n@@ -478,1 +451,13 @@\n-        \"linux-aarch64\": {\n+        \"linux-x64\": {\n+          target_os: \"linux\",\n+          target_cpu: \"x64\",\n+          dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\", \"tidy\"],\n+          configure_args: concat(\n+              \"--with-zlib=system\",\n+              \"--disable-dtrace\",\n+              (cross_compiling ? [ \"--openjdk-target=x86_64-linux-gnu\" ] : []),\n+              (isWsl(input) ? [ \"--host=x86_64-unknown-linux-gnu\",\n+                  \"--build=x86_64-unknown-linux-gnu\" ] : [])),\n+        },\n+\n+       \"linux-aarch64\": {\n@@ -495,2 +480,4 @@\n-                \"--openjdk-target=arm-linux-gnueabihf\", \"--with-freetype=bundled\",\n-                \"--with-abi-profile=arm-vfp-hflt\", \"--disable-warnings-as-errors\"\n+                \"--openjdk-target=arm-linux-gnueabihf\",\n+                \"--with-freetype=bundled\",\n+                \"--with-abi-profile=arm-vfp-hflt\",\n+                \"--disable-warnings-as-errors\"\n@@ -506,1 +493,2 @@\n-                \"--openjdk-target=ppc64le-linux-gnu\", \"--with-freetype=bundled\",\n+                \"--openjdk-target=ppc64le-linux-gnu\",\n+                \"--with-freetype=bundled\",\n@@ -517,1 +505,2 @@\n-                \"--openjdk-target=s390x-linux-gnu\", \"--with-freetype=bundled\",\n+                \"--openjdk-target=s390x-linux-gnu\",\n+                \"--with-freetype=bundled\",\n@@ -528,1 +517,2 @@\n-                \"--openjdk-target=riscv64-linux-gnu\", \"--with-freetype=bundled\",\n+                \"--openjdk-target=riscv64-linux-gnu\",\n+                \"--with-freetype=bundled\",\n@@ -589,1 +579,1 @@\n-            configure_args: concat(common.configure_args_64bit, [\n+            configure_args: [\n@@ -594,1 +584,1 @@\n-            ])\n+            ]\n@@ -601,1 +591,1 @@\n-            configure_args: concat(common.configure_args_64bit, [\n+            configure_args: [\n@@ -606,1 +596,1 @@\n-            ])\n+            ]\n@@ -614,1 +604,2 @@\n-            configure_args:  concat(common.configure_args_32bit, [\n+            configure_args: [\n+                \"--with-target-bits=32\",\n@@ -619,1 +610,1 @@\n-            ])\n+            ]\n@@ -638,2 +629,4 @@\n-            configure_args: concat(common.configure_args_64bit,\n-                \"--with-zlib=system\", \"--disable-precompiled-headers\"),\n+            configure_args: [\n+                \"--with-zlib=system\",\n+                \"--disable-precompiled-headers\"\n+            ],\n@@ -696,3 +689,0 @@\n-        \"linux-x86\": {\n-            platform: \"linux-x86\",\n-        },\n@@ -1092,1 +1082,1 @@\n-        macosx: \"Xcode14.3.1+1.0\",\n+        macosx: \"Xcode15.4+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":46,"deletions":56,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+      aotCodeCache.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-\t$(RM) $(JMH_UNPACKED_DIR)\/*.xml\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -683,0 +683,3 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    return true;\n+  }\n@@ -867,0 +870,3 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    return false;\n+  }\n@@ -2170,1 +2176,1 @@\n-  mov(rscratch1, entry_point);\n+  mov(rscratch1, RuntimeAddress(entry_point));\n@@ -3343,1 +3349,6 @@\n-  BLOCK_COMMENT(msg);\n+  \/\/ Skip AOT caching C strings in scratch buffer.\n+  const char* str = (code_section()->scratch_emit()) ? msg : AOTCodeCache::add_C_string(msg);\n+  BLOCK_COMMENT(str);\n+  \/\/ load msg into r0 so we can access it from the signal handler\n+  \/\/ ExternalAddress enables saving and restoring via the code cache\n+  lea(c_rarg0, ExternalAddress((address) str));\n@@ -3345,1 +3356,0 @@\n-  emit_int64((uintptr_t)msg);\n@@ -5457,0 +5467,29 @@\n+static Register pick_different_tmp(Register dst, Register src) {\n+  auto tmps = RegSet::of(r0, r1, r2) - RegSet::of(src, dst);\n+  return *tmps.begin();\n+}\n+\n+void MacroAssembler::encode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift <= CompressedKlassPointers::max_shift(), \"unexpected compressed klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst, subtract it formthe src and shift down\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    sub(dst, src, dst);\n+    lsr(dst, dst, shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    sub(dst, src, tmp);\n+    lsr(dst, dst, shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5458,0 +5497,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    encode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -5494,0 +5538,22 @@\n+void MacroAssembler::decode_klass_not_null_for_aot(Register dst, Register src) {\n+  \/\/ we have to load the klass base from the AOT constants area but\n+  \/\/ not the shift because it is not allowed to change\n+  int shift = CompressedKlassPointers::shift();\n+  assert(shift >= 0 && shift <= CompressedKlassPointers::max_shift(), \"unexpected compressed klass shift!\");\n+  if (dst != src) {\n+    \/\/ we can load the base into dst then add the offset with a suitable shift\n+    lea(dst, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(dst, dst);\n+    add(dst, dst, src, LSL,  shift);\n+  } else {\n+    \/\/ we need an extra register in order to load the coop base\n+    Register tmp = pick_different_tmp(dst, src);\n+    RegSet regs = RegSet::of(tmp);\n+    push(regs, sp);\n+    lea(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    ldr(tmp, tmp);\n+    add(dst, tmp,  src, LSL,  shift);\n+    pop(regs, sp);\n+  }\n+}\n+\n@@ -5497,0 +5563,5 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    decode_klass_not_null_for_aot(dst, src);\n+    return;\n+  }\n+\n@@ -6984,1 +7055,1 @@\n-  mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));\n+  mov(lr, ExternalAddress(CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper)));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":75,"deletions":4,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -978,0 +979,2 @@\n+  void decode_klass_not_null_for_aot(Register dst, Register src);\n+  void encode_klass_not_null_for_aot(Register dst, Register src);\n@@ -1373,0 +1376,4 @@\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      \/\/ To calculate far_codestub_branch_size correctly.\n+      return true;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -63,0 +64,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -66,1 +73,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -249,2 +255,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  return ut_blob;\n@@ -286,0 +294,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -289,1 +303,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -387,1 +400,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -818,34 +819,0 @@\n-  if (VerifyAdapterCalls &&\n-      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n-#if 0\n-    \/\/ So, let's test for cascading c2i\/i2c adapters right now.\n-    \/\/  assert(Interpreter::contains($return_addr) ||\n-    \/\/         StubRoutines::contains($return_addr),\n-    \/\/         \"i2c adapter must return to an interpreter frame\");\n-    __ block_comment(\"verify_i2c { \");\n-    Label L_ok;\n-    if (Interpreter::code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  Interpreter::code()->code_start(), Interpreter::code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::initial_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::initial_stubs_code()->code_begin(),\n-                  StubRoutines::initial_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::final_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::final_stubs_code()->code_begin(),\n-                  StubRoutines::final_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    const char* msg = \"i2c adapter must return to an interpreter frame\";\n-    __ block_comment(msg);\n-    __ stop(msg);\n-    __ bind(L_ok);\n-    __ block_comment(\"} verify_i2ce \");\n-#endif\n-  }\n-\n@@ -986,11 +953,11 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n-                                                            int comp_args_on_stack,\n-                                                            const GrowableArray<SigEntry>* sig,\n-                                                            const VMRegPair* regs,\n-                                                            const GrowableArray<SigEntry>* sig_cc,\n-                                                            const VMRegPair* regs_cc,\n-                                                            const GrowableArray<SigEntry>* sig_cc_ro,\n-                                                            const VMRegPair* regs_cc_ro,\n-                                                            AdapterFingerPrint* fingerprint,\n-                                                            AdapterBlob*& new_adapter,\n-                                                            bool allocate_code_blob) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n+                                            int comp_args_on_stack,\n+                                            const GrowableArray<SigEntry>* sig,\n+                                            const VMRegPair* regs,\n+                                            const GrowableArray<SigEntry>* sig_cc,\n+                                            const VMRegPair* regs_cc,\n+                                            const GrowableArray<SigEntry>* sig_cc_ro,\n+                                            const VMRegPair* regs_cc_ro,\n+                                            AdapterHandlerEntry* handler,\n+                                            AdapterBlob*& new_adapter,\n+                                            bool allocate_code_blob) {\n@@ -1055,1 +1022,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,\n+                            c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -2499,0 +2467,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -2862,0 +2836,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n@@ -2890,0 +2866,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -2893,3 +2876,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3004,1 +2984,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return sp_blob;\n@@ -3019,0 +3002,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -3021,2 +3010,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3095,1 +3082,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return rs_blob;\n@@ -3251,1 +3241,0 @@\n-  ResourceMark rm;\n@@ -3255,0 +3244,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -3281,1 +3276,1 @@\n-  __ mov(rscratch1, runtime_entry);\n+  __ lea(rscratch1, RuntimeAddress(runtime_entry));\n@@ -3314,0 +3309,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":52,"deletions":55,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -208,1 +209,1 @@\n-  const ptrdiff_t estimate = 144;\n+  const ptrdiff_t estimate = AOTCodeCache::is_on_for_dump() ? 148 : 144;\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,9 @@\n-    z_cg(Z_locals, _z_ijava_state_neg(locals), Z_fp);\n+\n+    \/\/ _z_ijava_state_neg(locals)) is fp relativized, so we need to\n+    \/\/ extract the pointer.\n+\n+    z_lg(Z_R1_scratch, Address(Z_fp, _z_ijava_state_neg(locals)));\n+    z_sllg(Z_R1_scratch, Z_R1_scratch, Interpreter::logStackElementSize);\n+    z_agr(Z_R1_scratch, Z_fp);\n+\n+    z_cgr(Z_locals, Z_R1_scratch);\n@@ -571,1 +579,4 @@\n-  z_stg(Z_SP, _z_ijava_state_neg(top_frame_sp), Z_fp);\n+  assert_different_registers(Z_R1, method);\n+  z_sgrk(Z_R1, Z_SP, Z_fp);\n+  z_srag(Z_R1, Z_R1, Interpreter::logStackElementSize);\n+  z_stg(Z_R1, _z_ijava_state_neg(top_frame_sp), Z_fp);\n@@ -687,0 +698,2 @@\n+  z_sllg(Z_locals, Z_locals, Interpreter::logStackElementSize);\n+  z_agr(Z_locals, Z_fp);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -5763,1 +5763,1 @@\n-  vblendvps(dst, dst, xtmp, permv, vec_enc, false, permv);\n+  vblendvps(dst, dst, xtmp, permv, vec_enc, true, permv);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -376,1 +377,3 @@\n-  lea(c_rarg0, ExternalAddress((address) msg));\n+  \/\/ Skip AOT caching C strings in scratch buffer.\n+  const char* str = (code_section()->scratch_emit()) ? msg : AOTCodeCache::add_C_string(msg);\n+  lea(c_rarg0, ExternalAddress((address) str));\n@@ -5734,1 +5737,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    }\n@@ -5766,1 +5773,5 @@\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      movptr(tmp, ExternalAddress(CompressedKlassPointers::base_addr()));\n+    } else {\n+      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -59,0 +60,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_uncommon_trap_blob();\n+  }\n+\n@@ -62,1 +69,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::uncommon_trap_id);\n@@ -231,2 +237,4 @@\n-  return UncommonTrapBlob::create(&buffer, oop_maps,\n-                                                 SimpleRuntimeFrame::framesize >> 1);\n+  UncommonTrapBlob *ut_blob = UncommonTrapBlob::create(&buffer, oop_maps,\n+                                                       SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ut_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::uncommon_trap_id, name);\n+  return ut_blob;\n@@ -268,0 +276,6 @@\n+  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  if (blob != nullptr) {\n+    return blob->as_exception_blob();\n+  }\n+\n@@ -271,1 +285,0 @@\n-  const char* name = OptoRuntime::stub_name(OptoStubId::exception_id);\n@@ -366,1 +379,3 @@\n-  return ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  ExceptionBlob* ex_blob = ExceptionBlob::create(&buffer, oop_maps, SimpleRuntimeFrame::framesize >> 1);\n+  AOTCodeCache::store_code_blob(*ex_blob, AOTCodeEntry::C2Blob, (uint)OptoStubId::exception_id, name);\n+  return ex_blob;\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -1083,13 +1084,0 @@\n-static void range_check(MacroAssembler* masm, Register pc_reg, Register temp_reg,\n-                        address code_start, address code_end,\n-                        Label& L_ok) {\n-  Label L_fail;\n-  __ lea(temp_reg, AddressLiteral(code_start, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::belowEqual, L_fail);\n-  __ lea(temp_reg, AddressLiteral(code_end, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::below, L_ok);\n-  __ bind(L_fail);\n-}\n-\n@@ -1127,35 +1115,0 @@\n-  if (VerifyAdapterCalls &&\n-      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n-    \/\/ So, let's test for cascading c2i\/i2c adapters right now.\n-    \/\/  assert(Interpreter::contains($return_addr) ||\n-    \/\/         StubRoutines::contains($return_addr),\n-    \/\/         \"i2c adapter must return to an interpreter frame\");\n-    __ block_comment(\"verify_i2c { \");\n-    \/\/ Pick up the return address\n-    __ movptr(rax, Address(rsp, 0));\n-    Label L_ok;\n-    if (Interpreter::code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  Interpreter::code()->code_start(),\n-                  Interpreter::code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::initial_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::initial_stubs_code()->code_begin(),\n-                  StubRoutines::initial_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::final_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::final_stubs_code()->code_begin(),\n-                  StubRoutines::final_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    const char* msg = \"i2c adapter must return to an interpreter frame\";\n-    __ block_comment(msg);\n-    __ stop(msg);\n-    __ bind(L_ok);\n-    __ block_comment(\"} verify_i2ce \");\n-  }\n-\n@@ -1323,11 +1276,11 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n-                                                            int comp_args_on_stack,\n-                                                            const GrowableArray<SigEntry>* sig,\n-                                                            const VMRegPair* regs,\n-                                                            const GrowableArray<SigEntry>* sig_cc,\n-                                                            const VMRegPair* regs_cc,\n-                                                            const GrowableArray<SigEntry>* sig_cc_ro,\n-                                                            const VMRegPair* regs_cc_ro,\n-                                                            AdapterFingerPrint* fingerprint,\n-                                                            AdapterBlob*& new_adapter,\n-                                                            bool allocate_code_blob) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n+                                            int comp_args_on_stack,\n+                                            const GrowableArray<SigEntry>* sig,\n+                                            const VMRegPair* regs,\n+                                            const GrowableArray<SigEntry>* sig_cc,\n+                                            const VMRegPair* regs_cc,\n+                                            const GrowableArray<SigEntry>* sig_cc_ro,\n+                                            const VMRegPair* regs_cc_ro,\n+                                            AdapterHandlerEntry* handler,\n+                                            AdapterBlob*& new_adapter,\n+                                            bool allocate_code_blob) {\n@@ -1390,1 +1343,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,\n+                            c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n@@ -2925,0 +2879,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n+  if (blob != nullptr) {\n+    _deopt_blob = blob->as_deoptimization_blob();\n+    return;\n+  }\n+\n@@ -3276,0 +3236,2 @@\n+\n+  AOTCodeCache::store_code_blob(*_deopt_blob, AOTCodeEntry::SharedBlob, (uint)SharedStubId::deopt_id, name);\n@@ -3288,0 +3250,7 @@\n+  \/\/ Allocate space for the code.  Setup code generation tools.\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_safepoint_blob();\n+  }\n+\n@@ -3291,3 +3260,0 @@\n-\n-  \/\/ Allocate space for the code.  Setup code generation tools.\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3453,1 +3419,4 @@\n-  return SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+  SafepointBlob* sp_blob = SafepointBlob::create(&buffer, oop_maps, frame_size_in_words);\n+\n+  AOTCodeCache::store_code_blob(*sp_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return sp_blob;\n@@ -3468,0 +3437,6 @@\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n@@ -3470,2 +3445,0 @@\n-\n-  const char* name = SharedRuntime::stub_name(id);\n@@ -3540,1 +3513,4 @@\n-  return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+  RuntimeStub* rs_blob = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);\n+\n+  AOTCodeCache::store_code_blob(*rs_blob, AOTCodeEntry::SharedBlob, (uint)id, name);\n+  return rs_blob;\n@@ -3578,1 +3554,0 @@\n-  ResourceMark rm;\n@@ -3582,0 +3557,6 @@\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::SharedBlob, (uint)id, name);\n+  if (blob != nullptr) {\n+    return blob->as_runtime_stub();\n+  }\n+\n+  ResourceMark rm;\n@@ -3639,0 +3620,2 @@\n+  AOTCodeCache::store_code_blob(*stub, AOTCodeEntry::SharedBlob, (uint)id, name);\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":51,"deletions":68,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1871,2 +1871,1 @@\n-    \/\/ No relocation needed\n-    __ mov64(r10, (int64_t) $meth$$method);\n+    __ lea(r10, RuntimeAddress((address)$meth$$method));\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,11 +65,11 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n-                                                            int comp_args_on_stack,\n-                                                            const GrowableArray <SigEntry>* sig,\n-                                                            const VMRegPair* regs,\n-                                                            const GrowableArray <SigEntry>* sig_cc,\n-                                                            const VMRegPair* regs_cc,\n-                                                            const GrowableArray <SigEntry>* sig_cc_ro,\n-                                                            const VMRegPair* regs_cc_ro,\n-                                                            AdapterFingerPrint* fingerprint,\n-                                                            AdapterBlob*& new_adapter,\n-                                                            bool allocate_code_blob) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int comp_args_on_stack,\n+                                            const GrowableArray <SigEntry>* sig,\n+                                            const VMRegPair* regs,\n+                                            const GrowableArray <SigEntry>* sig_cc,\n+                                            const VMRegPair* regs_cc,\n+                                            const GrowableArray <SigEntry>* sig_cc_ro,\n+                                            const VMRegPair* regs_cc_ro,\n+                                            AdapterHandlerEntry* handler,\n+                                            AdapterBlob*& new_adapter,\n+                                            bool allocate_code_blob) {\n@@ -79,9 +79,8 @@\n-  return AdapterHandlerLibrary::new_entry(\n-    fingerprint,\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub));\n+  handler->set_entry_points(CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            nullptr);\n+  return;\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -725,1 +726,1 @@\n-    ((CodeBuffer*)this)->print();\n+    ((CodeBuffer*)this)->print_on(tty);\n@@ -864,1 +865,1 @@\n-    this->print();\n+    this->print_on(tty);\n@@ -952,1 +953,1 @@\n-    this->print();\n+    this->print_on(tty);\n@@ -1069,1 +1070,1 @@\n-void CodeSection::print(const char* name) {\n+void CodeSection::print_on(outputStream* st, const char* name) {\n@@ -1071,1 +1072,1 @@\n-  tty->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)\",\n+  st->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)\",\n@@ -1073,1 +1074,1 @@\n-  tty->print_cr(\" %7s.locs = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d) point=%d\",\n+  st->print_cr(\" %7s.locs = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d) point=%d\",\n@@ -1077,1 +1078,1 @@\n-    iter.print();\n+    iter.print_on(st);\n@@ -1081,2 +1082,2 @@\n-void CodeBuffer::print() {\n-  tty->print_cr(\"CodeBuffer:\");\n+void CodeBuffer::print_on(outputStream* st) {\n+  st->print_cr(\"CodeBuffer:%s\", name());\n@@ -1086,1 +1087,1 @@\n-    cs->print(code_section_name(n));\n+    cs->print_on(st, code_section_name(n));\n@@ -1090,98 +1091,4 @@\n-\/\/ ----- CHeapString -----------------------------------------------------------\n-\n-class CHeapString : public CHeapObj<mtCode> {\n- public:\n-  CHeapString(const char* str) : _string(os::strdup(str)) {}\n- ~CHeapString() {\n-    os::free((void*)_string);\n-    _string = nullptr;\n-  }\n-  const char* string() const { return _string; }\n-\n- private:\n-  const char* _string;\n-};\n-\n-\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n-\n-class AsmRemarkCollection : public CHeapObj<mtCode> {\n- public:\n-  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n- ~AsmRemarkCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  AsmRemarkCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(uint offset, const char* remark);\n-  const char* lookup(uint offset) const;\n-  const char* next(uint offset) const;\n-\n-  bool is_empty() const { return _remarks == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* remark, uint offset) :\n-        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    uint offset;\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _remarks;\n-  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n-  \/\/ does not change the state of the list per se), supportig a simplistic\n-  \/\/ iteration scheme.\n-  mutable Cell* _next;\n-};\n-\n-\/\/ ----- DbgStringCollection ---------------------------------------------------\n-\n-class DbgStringCollection : public CHeapObj<mtCode> {\n- public:\n-  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n- ~DbgStringCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  DbgStringCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(const char* str);\n-  const char* lookup(const char* str) const;\n-\n-  bool is_empty() const { return _strings == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* dbgstr) :\n-        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _strings;\n-};\n+CHeapString::~CHeapString() {\n+  os::free((void*)_string);\n+  _string = nullptr;\n+}\n@@ -1213,1 +1120,1 @@\n-  precond(is_empty());\n+  precond(_remarks == nullptr || is_empty());\n@@ -1219,1 +1126,1 @@\n-  if (_remarks->clear() == 0) {\n+  if (_remarks != nullptr && _remarks->clear() == 0) {\n@@ -1265,1 +1172,1 @@\n-  precond(is_empty());\n+  precond(_strings == nullptr || is_empty());\n@@ -1271,1 +1178,1 @@\n-  if (_strings->clear() == 0) {\n+  if (_strings != nullptr && _strings->clear() == 0) {\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":19,"deletions":112,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -99,0 +100,1 @@\n+  friend class AOTCodeReader;\n@@ -293,1 +295,1 @@\n-  void print(const char* name);\n+  void print_on(outputStream* st, const char* name);\n@@ -300,2 +302,123 @@\n-class AsmRemarkCollection;\n-class DbgStringCollection;\n+\/\/ ----- CHeapString -----------------------------------------------------------\n+\n+class CHeapString : public CHeapObj<mtCode> {\n+ public:\n+  CHeapString(const char* str) : _string(os::strdup(str)) {}\n+  ~CHeapString();\n+  const char* string() const { return _string; }\n+\n+ private:\n+  const char* _string;\n+};\n+\n+\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n+\n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+ public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+ ~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_remarks != nullptr) {\n+      Cell* tmp = _remarks;\n+      do {\n+        if(!function(tmp->offset, tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _remarks);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n+\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+ public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+ ~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+  template<typename Function>\n+  bool iterate(Function function) const { \/\/ lambda enabled API\n+    if (_strings != nullptr) {\n+      Cell* tmp = _strings;\n+      do {\n+        if (!function(tmp->string())) {\n+          return false;\n+        }\n+        tmp = tmp->next;\n+      } while (tmp != _strings);\n+    }\n+    return true;\n+  }\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n+};\n@@ -324,0 +447,3 @@\n+  template<typename Function>\n+  inline bool iterate(Function function) const { return _remarks->iterate(function); }\n+\n@@ -346,0 +472,3 @@\n+  template<typename Function>\n+  bool iterate(Function function) const { return _strings->iterate(function); }\n+\n@@ -396,0 +525,1 @@\n+  friend class AOTCodeReader;\n@@ -752,1 +882,1 @@\n-  void    print();\n+  void    print_on(outputStream* st);\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":134,"deletions":4,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -211,0 +212,7 @@\n+  if ((int)id >= 0) {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+    if (blob != nullptr) {\n+      return blob;\n+    }\n+  }\n+\n@@ -244,0 +252,3 @@\n+  if (blob != nullptr && (int)id >= 0) {\n+    AOTCodeCache::store_code_blob(*blob, AOTCodeEntry::C1Blob, (uint)id, name, 0, nullptr);\n+  }\n@@ -278,1 +289,7 @@\n-  for (int id = 0; id < limit; id++) {\n+  for (int id = 0; id <= (int)C1StubId::forward_exception_id; id++) {\n+    if (!generate_blob_for(blob, (C1StubId) id)) {\n+      return false;\n+    }\n+  }\n+  AOTCodeCache::init_early_c1_table();\n+  for (int id = (int)C1StubId::forward_exception_id+1; id < limit; id++) {\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  friend class AOTCodeAddressTable;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -166,0 +167,1 @@\n+  _ac_region(\"ac\", MAX_SHARED_DELTA),\n@@ -309,1 +311,2 @@\n-  size_t buffer_size = LP64_ONLY(CompressedClassSpaceSize) NOT_LP64(256 * M);\n+  \/\/ AOTCodeCache::max_aot_code_size() accounts for aot code region.\n+  size_t buffer_size = LP64_ONLY(CompressedClassSpaceSize) NOT_LP64(256 * M) + AOTCodeCache::max_aot_code_size();\n@@ -313,1 +316,1 @@\n-                                             mtClassShared);\n+                                             mtNone);\n@@ -535,0 +538,7 @@\n+  } else if (ref->msotype() == MetaspaceObj::AdapterHandlerEntryType) {\n+    if (AOTCodeCache::is_dumping_adapter()) {\n+      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)ref->obj();\n+      return AdapterHandlerLibrary::is_abstract_method_adapter(entry) ? set_to_null : make_a_copy;\n+    } else {\n+      return set_to_null;\n+    }\n@@ -708,0 +718,5 @@\n+bool ArchiveBuilder::has_been_archived(address src_addr) const {\n+  SourceObjInfo* p = _src_obj_table.get(src_addr);\n+  return (p != nullptr);\n+}\n+\n@@ -976,0 +991,9 @@\n+void ArchiveBuilder::start_ac_region() {\n+  ro_region()->pack();\n+  start_dump_region(&_ac_region);\n+}\n+\n+void ArchiveBuilder::end_ac_region() {\n+  _ac_region.pack();\n+}\n+\n@@ -1085,2 +1109,3 @@\n-  ro_region()->pack();\n-\n+  if (!ro_region()->is_packed()) {\n+    ro_region()->pack();\n+  }\n@@ -1530,0 +1555,1 @@\n+  write_region(mapinfo, MetaspaceShared::ac, &_ac_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n@@ -1582,0 +1608,1 @@\n+  _ac_region.print(total_reserved);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -426,0 +426,7 @@\n+  if (FLAG_IS_DEFAULT(AOTCache) && AOTAdapterCaching) {\n+    log_debug(aot,codecache,init)(\"AOTCache is not specified - AOTAdapterCaching is ignored\");\n+  }\n+  if (FLAG_IS_DEFAULT(AOTCache) && AOTStubCaching) {\n+    log_debug(aot,codecache,init)(\"AOTCache is not specified - AOTStubCaching is ignored\");\n+  }\n+\n@@ -541,1 +548,1 @@\n-    if (is_dumping_preimage_static_archive()) {\n+    if (is_dumping_preimage_static_archive() || is_dumping_final_static_archive()) {\n@@ -667,0 +674,8 @@\n+bool CDSConfig::is_using_only_default_archive() {\n+  return is_using_archive() &&\n+         input_static_archive_path() != nullptr &&\n+         default_archive_path() != nullptr &&\n+         strcmp(input_static_archive_path(), default_archive_path()) == 0 &&\n+         input_dynamic_archive_path() == nullptr;\n+}\n+\n@@ -872,0 +887,19 @@\n+\n+\/\/ AOT code generation and its archiving is disabled by default.\n+\/\/ We enable it only in the final image dump after the metadata and heap are dumped.\n+\/\/ This affects only JITed code because it may have embedded oops and metadata pointers\n+\/\/ which AOT code encodes as offsets in final CDS archive regions.\n+\n+static bool _is_dumping_aot_code = false;\n+\n+bool CDSConfig::is_dumping_aot_code() {\n+  return _is_dumping_aot_code;\n+}\n+\n+void CDSConfig::disable_dumping_aot_code() {\n+  _is_dumping_aot_code = false;\n+}\n+\n+void CDSConfig::enable_dumping_aot_code() {\n+  _is_dumping_aot_code = true;\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  static bool is_using_only_default_archive()                NOT_CDS_RETURN_(false);\n@@ -197,0 +198,6 @@\n+  \/\/ --- AOT code\n+\n+  static bool is_dumping_aot_code()                          NOT_CDS_RETURN_(false);\n+  static void disable_dumping_aot_code()                     NOT_CDS_RETURN;\n+  static void enable_dumping_aot_code()                      NOT_CDS_RETURN;\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+          constraint(AOTConfigurationConstraintFunc, AtParse)               \\\n@@ -118,0 +119,1 @@\n+          constraint(AOTCacheConstraintFunc, AtParse)                       \\\n@@ -130,0 +132,19 @@\n+  \/* AOT Code flags *\/                                                      \\\n+                                                                            \\\n+  product(bool, AOTAdapterCaching, false, DIAGNOSTIC,                       \\\n+          \"Enable saving and restoring i2c2i adapters in AOT cache\")        \\\n+                                                                            \\\n+  product(bool, AOTStubCaching, false, DIAGNOSTIC,                          \\\n+          \"Enable saving and restoring stubs and code blobs in AOT cache\")  \\\n+                                                                            \\\n+  product(uint, AOTCodeMaxSize, 10*M, DIAGNOSTIC,                           \\\n+          \"Buffer size in bytes for AOT code caching\")                      \\\n+          range(1*M, max_jint)                                              \\\n+                                                                            \\\n+  product(bool, AbortVMOnAOTCodeFailure, false, DIAGNOSTIC,                 \\\n+          \"Abort VM on the first occurrence of AOT code load or store \"     \\\n+          \"failure. By default VM will continue execute without AOT code.\") \\\n+                                                                            \\\n+  develop(bool, TestAOTAdapterLinkFailure, false,                           \\\n+          \"Test failure of adapter linking when loading from AOT cache.\")   \\\n+\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -290,0 +290,2 @@\n+  case MetaspaceObj::AdapterHandlerEntryType:\n+  case MetaspaceObj::AdapterFingerPrintType:\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    log_info(cds)(\"optimized module handling: disabled because extra module path(s) are specified\");\n+    MetaspaceShared::report_loading_error(\"optimized module handling: disabled because extra module path(s) are specified\");\n@@ -900,1 +900,1 @@\n-    \"rw\", \"ro\", \"bm\", \"hp\"\n+    \"rw\", \"ro\", \"bm\", \"hp\", \"ac\"\n@@ -986,0 +986,3 @@\n+  } else {\n+     log_info(cds)(\"Shared file region (%s) %d: %8zu\"\n+                   \" bytes\", region_name(region), region, size);\n@@ -1187,1 +1190,1 @@\n-static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\", \"Heap\" };\n+static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\", \"Heap\", \"Code\" };\n@@ -1329,1 +1332,1 @@\n-    log_info(cds)(\"failed to map relocation bitmap\");\n+    MetaspaceShared::report_loading_error(\"failed to map relocation bitmap\");\n@@ -1350,0 +1353,36 @@\n+bool FileMapInfo::map_aot_code_region(ReservedSpace rs) {\n+  FileMapRegion* r = region_at(MetaspaceShared::ac);\n+  assert(r->used() > 0 && r->used_aligned() == rs.size(), \"must be\");\n+\n+  char* requested_base = rs.base();\n+  assert(requested_base != nullptr, \"should be inside code cache\");\n+\n+  char* mapped_base;\n+  if (MetaspaceShared::use_windows_memory_mapping()) {\n+    if (!read_region(MetaspaceShared::ac, requested_base, r->used_aligned(), \/* do_commit = *\/ true)) {\n+      log_info(cds)(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n+                    p2i(requested_base));\n+      return false;\n+    }\n+    mapped_base = requested_base;\n+  } else {\n+    \/\/ We do not execute in-place in the AOT code region.\n+    \/\/ AOT code is copied to the CodeCache for execution.\n+    bool read_only = false, allow_exec = false;\n+    mapped_base = map_memory(_fd, _full_path, r->file_offset(),\n+                             requested_base, r->used_aligned(), read_only, allow_exec, mtClassShared);\n+  }\n+  if (mapped_base == nullptr) {\n+    log_info(cds)(\"failed to map aot code region\");\n+    return false;\n+  } else {\n+    assert(mapped_base == requested_base, \"must be\");\n+    r->set_mapped_from_file(true);\n+    r->set_mapped_base(mapped_base);\n+    log_info(cds)(\"Mapped static  region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n+                  MetaspaceShared::ac, p2i(r->mapped_base()), p2i(r->mapped_end()),\n+                  shared_region_name[MetaspaceShared::ac]);\n+    return true;\n+  }\n+}\n+\n@@ -1491,1 +1530,1 @@\n-        log_info(cds)(\"Cannot use CDS heap data. Selected GC not compatible -XX:-UseCompressedOops\");\n+        MetaspaceShared::report_loading_error(\"Cannot use CDS heap data. Selected GC not compatible -XX:-UseCompressedOops\");\n@@ -1493,1 +1532,1 @@\n-        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n+        MetaspaceShared::report_loading_error(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n@@ -1505,2 +1544,4 @@\n-      MetaspaceShared::unrecoverable_loading_error(\"CDS archive has aot-linked classes but the archived \"\n-                                                   \"heap objects cannot be loaded. Try increasing your heap size.\");\n+      log_error(cds)(\"%s has aot-linked classes but the archived \"\n+                     \"heap objects cannot be loaded. Try increasing your heap size.\",\n+                     CDSConfig::type_of_archive_being_loaded());\n+      MetaspaceShared::unrecoverable_loading_error();\n@@ -1672,1 +1713,1 @@\n-    log_info(cds)(\"UseSharedSpaces: Unable to allocate java heap region for archive heap.\");\n+    MetaspaceShared::report_loading_error(\"UseSharedSpaces: Unable to allocate java heap region for archive heap.\");\n@@ -1707,1 +1748,1 @@\n-      log_info(cds)(\"UseSharedSpaces: mapped heap region is corrupt\");\n+      MetaspaceShared::report_loading_error(\"UseSharedSpaces: mapped heap region is corrupt\");\n@@ -1731,1 +1772,1 @@\n-      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n+      MetaspaceShared::report_loading_error(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n@@ -1844,1 +1885,1 @@\n-    log_info(cds)(\"CDS is disabled because early JVMTI ClassFileLoadHook is in use.\");\n+    MetaspaceShared::report_loading_error(\"CDS is disabled because early JVMTI ClassFileLoadHook is in use.\");\n@@ -1850,1 +1891,1 @@\n-      log_info(cds)(\"Loading static archive failed.\");\n+      MetaspaceShared::report_loading_error(\"Loading static archive failed.\");\n@@ -1853,1 +1894,1 @@\n-      log_info(cds)(\"Loading dynamic archive failed.\");\n+      MetaspaceShared::report_loading_error(\"Loading dynamic archive failed.\");\n@@ -1868,0 +1909,1 @@\n+    const char* archive_type = CDSConfig::type_of_archive_being_loaded();\n@@ -1870,1 +1912,2 @@\n-      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\");\n+      log_error(cds)(\"%s has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\",\n+                     archive_type);\n@@ -1874,1 +1917,2 @@\n-      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\");\n+      log_error(cds)(\"%s has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\",\n+                     archive_type);\n@@ -1878,1 +1922,2 @@\n-      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when archived full module graph is not used.\");\n+      log_error(cds)(\"%s has aot-linked classes. It cannot be used when archived full module graph is not used.\",\n+                     archive_type);\n@@ -1884,1 +1929,2 @@\n-      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\", prop);\n+      log_error(cds)(\"%s has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\",\n+                     archive_type, prop);\n@@ -1890,1 +1936,1 @@\n-      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used with JDWP agent\");\n+      log_error(cds)(\"%s has aot-linked classes. It cannot be used with JDWP agent\", archive_type);\n@@ -1950,2 +1996,2 @@\n-      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when the \"\n-                     \"java.system.class.loader property is specified.\");\n+      log_error(cds)(\"%s has aot-linked classes. It cannot be used when the \"\n+                     \"java.system.class.loader property is specified.\", CDSConfig::type_of_archive_being_loaded());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":67,"deletions":21,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -409,0 +409,1 @@\n+  bool  map_aot_code_region(ReservedSpace rs);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -496,0 +497,2 @@\n+  AdapterHandlerLibrary::serialize_shared_table_header(soc);\n+\n@@ -614,0 +617,4 @@\n+  if (AOTCodeCache::is_dumping_adapter()) {\n+    AdapterHandlerLibrary::dump_aot_adapter_table();\n+  }\n+\n@@ -935,1 +942,1 @@\n-      log_info(cds)(\"archivedBootLayer not available, disabling full module graph\");\n+      report_loading_error(\"archivedBootLayer not available, disabling full module graph\");\n@@ -1003,0 +1010,11 @@\n+  if (AOTCodeCache::is_on_for_dump() && CDSConfig::is_dumping_final_static_archive()) {\n+    CDSConfig::enable_dumping_aot_code();\n+    {\n+      builder.start_ac_region();\n+      \/\/ Write the contents to AOT code region and close AOTCodeCache before packing the region\n+      AOTCodeCache::close();\n+      builder.end_ac_region();\n+    }\n+    CDSConfig::disable_dumping_aot_code();\n+  }\n+\n@@ -1110,4 +1128,1 @@\n-  log_error(cds)(\"An error has occurred while processing the %s.\", CDSConfig::type_of_archive_being_loaded());\n-  if (message != nullptr) {\n-    log_error(cds)(\"%s\", message);\n-  }\n+  report_loading_error(message);\n@@ -1124,0 +1139,24 @@\n+void MetaspaceShared::report_loading_error(const char* format, ...) {\n+  \/\/ If the user doesn't specify any CDS options, we will try to load the default CDS archive, which\n+  \/\/ may fail due to incompatible VM options. Print at the info level to avoid excessive verbosity.\n+  \/\/ However, if the user has specified a CDS archive (or AOT cache), they would be interested in\n+  \/\/ knowing that the loading fails, so we print at the error level.\n+  Log(cds) log;\n+  LogStream ls_error(log.error());\n+  LogStream ls_info(log.info());\n+  LogStream& ls = (!CDSConfig::is_using_archive()) || CDSConfig::is_using_only_default_archive() ? ls_info : ls_error;\n+\n+  static bool printed_error = false;\n+  if (!printed_error) { \/\/ No need for locks. Loading error checks happen only in main thread.\n+    ls.print_cr(\"An error has occurred while processing the %s. Run with -Xlog:cds for details.\", CDSConfig::type_of_archive_being_loaded());\n+    printed_error = true;\n+  }\n+\n+  if (format != nullptr) {\n+    va_list ap;\n+    va_start(ap, format);\n+    ls.vprint_cr(format, ap);\n+    va_end(ap);\n+  }\n+}\n+\n@@ -1185,1 +1224,0 @@\n-    log_info(cds)(\"Unable to map shared spaces\");\n@@ -1188,2 +1226,6 @@\n-    } else if (RequireSharedSpaces) {\n-      MetaspaceShared::unrecoverable_loading_error(\"Unable to map shared spaces\");\n+    } else {\n+      if (RequireSharedSpaces) {\n+        MetaspaceShared::unrecoverable_loading_error(\"Unable to map shared spaces\");\n+      } else {\n+        report_loading_error(\"Unable to map shared spaces\");\n+      }\n@@ -1704,2 +1746,2 @@\n-    log_info(cds)(\"Unable to map CDS archive -- core_region_alignment() expected: %zu\"\n-                  \" actual: %zu\", mapinfo->core_region_alignment(), core_region_alignment());\n+    report_loading_error(\"Unable to map CDS archive -- core_region_alignment() expected: %zu\"\n+                         \" actual: %zu\", mapinfo->core_region_alignment(), core_region_alignment());\n@@ -1779,0 +1821,1 @@\n+  AOTCodeCache::initialize();\n@@ -1830,0 +1873,5 @@\n+    if (AOTCodeCache::is_on_for_use()) {\n+      tty->print_cr(\"\\n\\nAOT Code\");\n+      AOTCodeCache::print_on(tty);\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":58,"deletions":10,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    ac = 4,  \/\/ aot code\n@@ -71,1 +72,1 @@\n-    n_regions = 4              \/\/ total number of regions\n+    n_regions = 5              \/\/ total number of regions\n@@ -112,1 +113,2 @@\n-  static void unrecoverable_loading_error(const char* message = nullptr);\n+  static void unrecoverable_loading_error(const char* message = nullptr) ATTRIBUTE_PRINTF(1, 0);\n+  static void report_loading_error(const char* format, ...) ATTRIBUTE_PRINTF(1, 0);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+#if INCLUDE_CDS\n@@ -117,1 +118,2 @@\n-      if (SystemDictionaryShared::add_verification_constraint(klass,\n+      bool skip_assignability_check = false;\n+      SystemDictionaryShared::add_verification_constraint(klass,\n@@ -119,3 +121,4 @@\n-              from.is_object())) {\n-        \/\/ If add_verification_constraint() returns true, the resolution\/check should be\n-        \/\/ delayed until runtime.\n+              from.is_object(), &skip_assignability_check);\n+      if (skip_assignability_check) {\n+        \/\/ We are not able to resolve name() or from.name(). The actual assignability check\n+        \/\/ will be delayed until runtime.\n@@ -125,1 +128,1 @@\n-\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -228,6 +228,3 @@\n-    \/\/ If dumping static archive then don't fall back to the old verifier on\n-    \/\/ verification failure. If a class fails verification with the split verifier,\n-    \/\/ it might fail the CDS runtime verifier constraint check. In that case, we\n-    \/\/ don't want to share the class. We only archive classes that pass the split\n-    \/\/ verifier.\n-    bool can_failover = !CDSConfig::is_dumping_static_archive() &&\n+    \/\/ If dumping {classic, final} static archive, don't bother to run the old verifier, as\n+    \/\/ the class will be excluded from the archive anyway.\n+    bool can_failover = !(CDSConfig::is_dumping_classic_static_archive() || CDSConfig::is_dumping_final_static_archive()) &&\n@@ -242,3 +239,4 @@\n-      \/\/ Exclude any classes that fail over during dynamic dumping\n-      if (CDSConfig::is_dumping_dynamic_archive()) {\n-        SystemDictionaryShared::warn_excluded(klass, \"Failed over class verification while dynamic dumping\");\n+      \/\/ Exclude any classes that are verified with the old verifier, as the old verifier\n+      \/\/ doesn't call SystemDictionaryShared::add_verification_constraint()\n+      if (CDSConfig::is_dumping_archive()) {\n+        SystemDictionaryShared::warn_excluded(klass, \"Verified with old verifier\");\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,1730 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"cds\/aotCacheAccess.hpp\"\n+#include \"cds\/cds_globals.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/javaAssertions.hpp\"\n+#include \"code\/aotCodeCache.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"gc\/shared\/gcConfig.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"runtime\/flags\/flagSetting.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n+#if INCLUDE_G1GC\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+#endif\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahRuntime.hpp\"\n+#endif\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n+#endif\n+\n+#include <sys\/stat.h>\n+#include <errno.h>\n+\n+const char* aot_code_entry_kind_name[] = {\n+#define DECL_KIND_STRING(kind) XSTR(kind),\n+  DO_AOTCODEENTRY_KIND(DECL_KIND_STRING)\n+#undef DECL_KIND_STRING\n+};\n+\n+static void report_load_failure() {\n+  if (AbortVMOnAOTCodeFailure) {\n+    vm_exit_during_initialization(\"Unable to use AOT Code Cache.\", nullptr);\n+  }\n+  log_info(aot, codecache, init)(\"Unable to use AOT Code Cache.\");\n+  AOTAdapterCaching = false;\n+  AOTStubCaching = false;\n+}\n+\n+static void report_store_failure() {\n+  if (AbortVMOnAOTCodeFailure) {\n+    tty->print_cr(\"Unable to create AOT Code Cache.\");\n+    vm_abort(false);\n+  }\n+  log_info(aot, codecache, exit)(\"Unable to create AOT Code Cache.\");\n+  AOTAdapterCaching = false;\n+  AOTStubCaching = false;\n+}\n+\n+bool AOTCodeCache::is_dumping_adapter() {\n+  return AOTAdapterCaching && is_on_for_dump();\n+}\n+\n+bool AOTCodeCache::is_using_adapter()   {\n+  return AOTAdapterCaching && is_on_for_use();\n+}\n+\n+bool AOTCodeCache::is_dumping_stub() {\n+  return AOTStubCaching && is_on_for_dump();\n+}\n+\n+bool AOTCodeCache::is_using_stub()   {\n+  return AOTStubCaching && is_on_for_use();\n+}\n+\n+static uint32_t encode_id(AOTCodeEntry::Kind kind, int id) {\n+  assert(AOTCodeEntry::is_valid_entry_kind(kind), \"invalid AOTCodeEntry kind %d\", (int)kind);\n+  \/\/ There can be a conflict of id between an Adapter and *Blob, but that should not cause any functional issue\n+  \/\/ becasue both id and kind are used to find an entry, and that combination should be unique\n+  if (kind == AOTCodeEntry::Adapter) {\n+    return id;\n+  } else if (kind == AOTCodeEntry::SharedBlob) {\n+    return id;\n+  } else if (kind == AOTCodeEntry::C1Blob) {\n+    return (int)SharedStubId::NUM_STUBIDS + id;\n+  } else {\n+    \/\/ kind must be AOTCodeEntry::C2Blob\n+    return (int)SharedStubId::NUM_STUBIDS + COMPILER1_PRESENT((int)C1StubId::NUM_STUBIDS) + id;\n+  }\n+}\n+\n+static uint _max_aot_code_size = 0;\n+uint AOTCodeCache::max_aot_code_size() {\n+  return _max_aot_code_size;\n+}\n+\n+void AOTCodeCache::initialize() {\n+#if defined(ZERO) || !(defined(AMD64) || defined(AARCH64))\n+  log_info(aot, codecache, init)(\"AOT Code Cache is not supported on this platform.\");\n+  AOTAdapterCaching = false;\n+  return;\n+#else\n+  if (FLAG_IS_DEFAULT(AOTCache)) {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is not used: AOTCache is not specified.\");\n+    AOTAdapterCaching = false;\n+    return; \/\/ AOTCache must be specified to dump and use AOT code\n+  }\n+\n+  bool is_dumping = false;\n+  bool is_using   = false;\n+  if (CDSConfig::is_dumping_final_static_archive() && CDSConfig::is_dumping_aot_linked_classes()) {\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+    is_dumping = true;\n+  } else if (CDSConfig::is_using_archive() && CDSConfig::is_using_aot_linked_classes()) {\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTStubCaching, true);\n+    is_using = true;\n+  } else {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is not used: AOT Class Linking is not used.\");\n+    return; \/\/ nothing to do\n+  }\n+  if (!AOTAdapterCaching && !AOTStubCaching) {\n+    return; \/\/ AOT code caching disabled on command line\n+  }\n+  _max_aot_code_size = AOTCodeMaxSize;\n+  if (!FLAG_IS_DEFAULT(AOTCodeMaxSize)) {\n+    if (!is_aligned(AOTCodeMaxSize, os::vm_allocation_granularity())) {\n+      _max_aot_code_size = align_up(AOTCodeMaxSize, os::vm_allocation_granularity());\n+      log_debug(aot,codecache,init)(\"Max AOT Code Cache size is aligned up to %uK\", (int)(max_aot_code_size()\/K));\n+    }\n+  }\n+  size_t aot_code_size = is_using ? AOTCacheAccess::get_aot_code_region_size() : 0;\n+  if (is_using && aot_code_size == 0) {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is empty\");\n+    return;\n+  }\n+  if (!open_cache(is_dumping, is_using)) {\n+    if (is_using) {\n+      report_load_failure();\n+    } else {\n+      report_store_failure();\n+    }\n+    return;\n+  }\n+  if (is_dumping) {\n+    FLAG_SET_DEFAULT(ForceUnreachable, true);\n+  }\n+  FLAG_SET_DEFAULT(DelayCompilerStubsGeneration, false);\n+#endif \/\/ defined(AMD64) || defined(AARCH64)\n+}\n+\n+void AOTCodeCache::init2() {\n+  if (!is_on()) {\n+    return;\n+  }\n+  if (!verify_vm_config()) {\n+    close();\n+    report_load_failure();\n+  }\n+\n+  \/\/ initialize the table of external routines so we can save\n+  \/\/ generated code blobs that reference them\n+  init_extrs_table();\n+  init_early_stubs_table();\n+}\n+\n+AOTCodeCache* AOTCodeCache::_cache = nullptr;\n+\n+bool AOTCodeCache::open_cache(bool is_dumping, bool is_using) {\n+  AOTCodeCache* cache = new AOTCodeCache(is_dumping, is_using);\n+  if (cache->failed()) {\n+    delete cache;\n+    _cache = nullptr;\n+    return false;\n+  }\n+  _cache = cache;\n+  return true;\n+}\n+\n+void AOTCodeCache::close() {\n+  if (is_on()) {\n+    delete _cache; \/\/ Free memory\n+    _cache = nullptr;\n+  }\n+}\n+\n+#define DATA_ALIGNMENT HeapWordSize\n+\n+AOTCodeCache::AOTCodeCache(bool is_dumping, bool is_using) :\n+  _load_header(nullptr),\n+  _load_buffer(nullptr),\n+  _store_buffer(nullptr),\n+  _C_store_buffer(nullptr),\n+  _write_position(0),\n+  _load_size(0),\n+  _store_size(0),\n+  _for_use(is_using),\n+  _for_dump(is_dumping),\n+  _closing(false),\n+  _failed(false),\n+  _lookup_failed(false),\n+  _table(nullptr),\n+  _load_entries(nullptr),\n+  _search_entries(nullptr),\n+  _store_entries(nullptr),\n+  _C_strings_buf(nullptr),\n+  _store_entries_cnt(0)\n+{\n+  \/\/ Read header at the begining of cache\n+  if (_for_use) {\n+    \/\/ Read cache\n+    size_t load_size = AOTCacheAccess::get_aot_code_region_size();\n+    ReservedSpace rs = MemoryReserver::reserve(load_size, mtCode);\n+    if (!rs.is_reserved()) {\n+      log_warning(aot, codecache, init)(\"Failed to reserved %u bytes of memory for mapping AOT code region into AOT Code Cache\", (uint)load_size);\n+      set_failed();\n+      return;\n+    }\n+    if (!AOTCacheAccess::map_aot_code_region(rs)) {\n+      log_warning(aot, codecache, init)(\"Failed to read\/mmap cached code region into AOT Code Cache\");\n+      set_failed();\n+      return;\n+    }\n+\n+    _load_size = (uint)load_size;\n+    _load_buffer = (char*)rs.base();\n+    assert(is_aligned(_load_buffer, DATA_ALIGNMENT), \"load_buffer is not aligned\");\n+    log_debug(aot, codecache, init)(\"Mapped %u bytes at address \" INTPTR_FORMAT \" at AOT Code Cache\", _load_size, p2i(_load_buffer));\n+\n+    _load_header = (Header*)addr(0);\n+    if (!_load_header->verify_config(_load_size)) {\n+      set_failed();\n+      return;\n+    }\n+    log_info (aot, codecache, init)(\"Loaded %u AOT code entries from AOT Code Cache\", _load_header->entries_count());\n+    log_debug(aot, codecache, init)(\"  Adapters:  total=%u\", _load_header->adapters_count());\n+    log_debug(aot, codecache, init)(\"  Shared Blobs: total=%u\", _load_header->shared_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C1 Blobs: total=%u\", _load_header->C1_blobs_count());\n+    log_debug(aot, codecache, init)(\"  C2 Blobs: total=%u\", _load_header->C2_blobs_count());\n+    log_debug(aot, codecache, init)(\"  AOT code cache size: %u bytes\", _load_header->cache_size());\n+\n+    \/\/ Read strings\n+    load_strings();\n+  }\n+  if (_for_dump) {\n+    _C_store_buffer = NEW_C_HEAP_ARRAY(char, max_aot_code_size() + DATA_ALIGNMENT, mtCode);\n+    _store_buffer = align_up(_C_store_buffer, DATA_ALIGNMENT);\n+    \/\/ Entries allocated at the end of buffer in reverse (as on stack).\n+    _store_entries = (AOTCodeEntry*)align_up(_C_store_buffer + max_aot_code_size(), DATA_ALIGNMENT);\n+    log_debug(aot, codecache, init)(\"Allocated store buffer at address \" INTPTR_FORMAT \" of size %u\", p2i(_store_buffer), max_aot_code_size());\n+  }\n+  _table = new AOTCodeAddressTable();\n+}\n+\n+void AOTCodeCache::init_extrs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_extrs();\n+  }\n+}\n+\n+void AOTCodeCache::init_early_stubs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_stubs();\n+  }\n+}\n+\n+void AOTCodeCache::init_shared_blobs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_shared_blobs();\n+  }\n+}\n+\n+void AOTCodeCache::init_early_c1_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_early_c1();\n+  }\n+}\n+\n+AOTCodeCache::~AOTCodeCache() {\n+  if (_closing) {\n+    return; \/\/ Already closed\n+  }\n+  \/\/ Stop any further access to cache.\n+  _closing = true;\n+\n+  MutexLocker ml(Compile_lock);\n+  if (for_dump()) { \/\/ Finalize cache\n+    finish_write();\n+  }\n+  _load_buffer = nullptr;\n+  if (_C_store_buffer != nullptr) {\n+    FREE_C_HEAP_ARRAY(char, _C_store_buffer);\n+    _C_store_buffer = nullptr;\n+    _store_buffer = nullptr;\n+  }\n+  if (_table != nullptr) {\n+    delete _table;\n+    _table = nullptr;\n+  }\n+}\n+\n+void AOTCodeCache::Config::record() {\n+  _flags = 0;\n+#ifdef ASSERT\n+  _flags |= debugVM;\n+#endif\n+  if (UseCompressedOops) {\n+    _flags |= compressedOops;\n+  }\n+  if (UseCompressedClassPointers) {\n+    _flags |= compressedClassPointers;\n+  }\n+  if (UseTLAB) {\n+    _flags |= useTLAB;\n+  }\n+  if (JavaAssertions::systemClassDefault()) {\n+    _flags |= systemClassAssertions;\n+  }\n+  if (JavaAssertions::userClassDefault()) {\n+    _flags |= userClassAssertions;\n+  }\n+  if (EnableContended) {\n+    _flags |= enableContendedPadding;\n+  }\n+  if (RestrictContended) {\n+    _flags |= restrictContendedPadding;\n+  }\n+  _compressedOopShift    = CompressedOops::shift();\n+  _compressedOopBase     = CompressedOops::base();\n+  _compressedKlassShift  = CompressedKlassPointers::shift();\n+  _contendedPaddingWidth = ContendedPaddingWidth;\n+  _objectAlignment       = ObjectAlignmentInBytes;\n+  _gc                    = (uint)Universe::heap()->kind();\n+}\n+\n+bool AOTCodeCache::Config::verify() const {\n+#ifdef ASSERT\n+  if ((_flags & debugVM) == 0) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created by product VM, it can't be used by debug VM\");\n+    return false;\n+  }\n+#else\n+  if ((_flags & debugVM) != 0) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created by debug VM, it can't be used by product VM\");\n+    return false;\n+  }\n+#endif\n+\n+  CollectedHeap::Name aot_gc = (CollectedHeap::Name)_gc;\n+  if (aot_gc != Universe::heap()->kind()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with different GC: %s vs current %s\", GCConfig::hs_err_name(aot_gc), GCConfig::hs_err_name());\n+    return false;\n+  }\n+\n+  if (((_flags & compressedOops) != 0) != UseCompressedOops) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedOops = %s\", UseCompressedOops ? \"false\" : \"true\");\n+    return false;\n+  }\n+  if (((_flags & compressedClassPointers) != 0) != UseCompressedClassPointers) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedClassPointers = %s\", UseCompressedClassPointers ? \"false\" : \"true\");\n+    return false;\n+  }\n+\n+  if (((_flags & systemClassAssertions) != 0) != JavaAssertions::systemClassDefault()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::systemClassDefault() = %s\", JavaAssertions::systemClassDefault() ? \"disabled\" : \"enabled\");\n+    return false;\n+  }\n+  if (((_flags & userClassAssertions) != 0) != JavaAssertions::userClassDefault()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::userClassDefault() = %s\", JavaAssertions::userClassDefault() ? \"disabled\" : \"enabled\");\n+    return false;\n+  }\n+\n+  if (((_flags & enableContendedPadding) != 0) != EnableContended) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with EnableContended = %s\", EnableContended ? \"false\" : \"true\");\n+    return false;\n+  }\n+  if (((_flags & restrictContendedPadding) != 0) != RestrictContended) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with RestrictContended = %s\", RestrictContended ? \"false\" : \"true\");\n+    return false;\n+  }\n+  if (_compressedOopShift != (uint)CompressedOops::shift()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with different CompressedOops::shift(): %d vs current %d\", _compressedOopShift, CompressedOops::shift());\n+    return false;\n+  }\n+  if (_compressedKlassShift != (uint)CompressedKlassPointers::shift()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedKlassPointers::shift() = %d vs current %d\", _compressedKlassShift, CompressedKlassPointers::shift());\n+    return false;\n+  }\n+  if (_contendedPaddingWidth != (uint)ContendedPaddingWidth) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ContendedPaddingWidth = %d vs current %d\", _contendedPaddingWidth, ContendedPaddingWidth);\n+    return false;\n+  }\n+  if (_objectAlignment != (uint)ObjectAlignmentInBytes) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ObjectAlignmentInBytes = %d vs current %d\", _objectAlignment, ObjectAlignmentInBytes);\n+    return false;\n+  }\n+\n+  \/\/ This should be the last check as it only disables AOTStubCaching\n+  if ((_compressedOopBase == nullptr || CompressedOops::base() == nullptr) && (_compressedOopBase != CompressedOops::base())) {\n+    log_debug(aot, codecache, init)(\"AOTStubCaching is disabled: incompatible CompressedOops::base(): %p vs current %p\", _compressedOopBase, CompressedOops::base());\n+    AOTStubCaching = false;\n+  }\n+\n+  return true;\n+}\n+\n+bool AOTCodeCache::Header::verify_config(uint load_size) const {\n+  if (_version != AOT_CODE_VERSION) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: different AOT Code version %d vs %d recorded in AOT Code header\", AOT_CODE_VERSION, _version);\n+    return false;\n+  }\n+  if (load_size < _cache_size) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: AOT Code Cache size %d < %d recorded in AOT Code header\", load_size, _cache_size);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+AOTCodeCache* AOTCodeCache::open_for_use() {\n+  if (AOTCodeCache::is_on_for_use()) {\n+    return AOTCodeCache::cache();\n+  }\n+  return nullptr;\n+}\n+\n+AOTCodeCache* AOTCodeCache::open_for_dump() {\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    AOTCodeCache* cache = AOTCodeCache::cache();\n+    cache->clear_lookup_failed(); \/\/ Reset bit\n+    return cache;\n+  }\n+  return nullptr;\n+}\n+\n+void copy_bytes(const char* from, address to, uint size) {\n+  assert(size > 0, \"sanity\");\n+  bool by_words = true;\n+  if ((size > 2 * HeapWordSize) && (((intptr_t)from | (intptr_t)to) & (HeapWordSize - 1)) == 0) {\n+    \/\/ Use wordwise copies if possible:\n+    Copy::disjoint_words((HeapWord*)from,\n+                         (HeapWord*)to,\n+                         ((size_t)size + HeapWordSize-1) \/ HeapWordSize);\n+  } else {\n+    by_words = false;\n+    Copy::conjoint_jbytes(from, to, (size_t)size);\n+  }\n+  log_trace(aot, codecache)(\"Copied %d bytes as %s from \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, size, (by_words ? \"HeapWord\" : \"bytes\"), p2i(from), p2i(to));\n+}\n+\n+AOTCodeReader::AOTCodeReader(AOTCodeCache* cache, AOTCodeEntry* entry) {\n+  _cache = cache;\n+  _entry = entry;\n+  _load_buffer = cache->cache_buffer();\n+  _read_position = 0;\n+  _lookup_failed = false;\n+}\n+\n+void AOTCodeReader::set_read_position(uint pos) {\n+  if (pos == _read_position) {\n+    return;\n+  }\n+  assert(pos < _cache->load_size(), \"offset:%d >= file size:%d\", pos, _cache->load_size());\n+  _read_position = pos;\n+}\n+\n+bool AOTCodeCache::set_write_position(uint pos) {\n+  if (pos == _write_position) {\n+    return true;\n+  }\n+  if (_store_size < _write_position) {\n+    _store_size = _write_position; \/\/ Adjust during write\n+  }\n+  assert(pos < _store_size, \"offset:%d >= file size:%d\", pos, _store_size);\n+  _write_position = pos;\n+  return true;\n+}\n+\n+static char align_buffer[256] = { 0 };\n+\n+bool AOTCodeCache::align_write() {\n+  \/\/ We are not executing code from cache - we copy it by bytes first.\n+  \/\/ No need for big alignment (or at all).\n+  uint padding = DATA_ALIGNMENT - (_write_position & (DATA_ALIGNMENT - 1));\n+  if (padding == DATA_ALIGNMENT) {\n+    return true;\n+  }\n+  uint n = write_bytes((const void*)&align_buffer, padding);\n+  if (n != padding) {\n+    return false;\n+  }\n+  log_trace(aot, codecache)(\"Adjust write alignment in AOT Code Cache\");\n+  return true;\n+}\n+\n+\/\/ Check to see if AOT code cache has required space to store \"nbytes\" of data\n+address AOTCodeCache::reserve_bytes(uint nbytes) {\n+  assert(for_dump(), \"Code Cache file is not created\");\n+  uint new_position = _write_position + nbytes;\n+  if (new_position >= (uint)((char*)_store_entries - _store_buffer)) {\n+    log_warning(aot,codecache)(\"Failed to ensure %d bytes at offset %d in AOT Code Cache. Increase AOTCodeMaxSize.\",\n+                               nbytes, _write_position);\n+    set_failed();\n+    report_store_failure();\n+    return nullptr;\n+  }\n+  address buffer = (address)(_store_buffer + _write_position);\n+  log_trace(aot, codecache)(\"Reserved %d bytes at offset %d in AOT Code Cache\", nbytes, _write_position);\n+  _write_position += nbytes;\n+  if (_store_size < _write_position) {\n+    _store_size = _write_position;\n+  }\n+  return buffer;\n+}\n+\n+uint AOTCodeCache::write_bytes(const void* buffer, uint nbytes) {\n+  assert(for_dump(), \"Code Cache file is not created\");\n+  if (nbytes == 0) {\n+    return 0;\n+  }\n+  uint new_position = _write_position + nbytes;\n+  if (new_position >= (uint)((char*)_store_entries - _store_buffer)) {\n+    log_warning(aot, codecache)(\"Failed to write %d bytes at offset %d to AOT Code Cache. Increase AOTCodeMaxSize.\",\n+                                nbytes, _write_position);\n+    set_failed();\n+    report_store_failure();\n+    return 0;\n+  }\n+  copy_bytes((const char* )buffer, (address)(_store_buffer + _write_position), nbytes);\n+  log_trace(aot, codecache)(\"Wrote %d bytes at offset %d to AOT Code Cache\", nbytes, _write_position);\n+  _write_position += nbytes;\n+  if (_store_size < _write_position) {\n+    _store_size = _write_position;\n+  }\n+  return nbytes;\n+}\n+\n+void* AOTCodeEntry::operator new(size_t x, AOTCodeCache* cache) {\n+  return (void*)(cache->add_entry());\n+}\n+\n+static bool check_entry(AOTCodeEntry::Kind kind, uint id, AOTCodeEntry* entry) {\n+  if (entry->kind() == kind) {\n+    assert(entry->id() == id, \"sanity\");\n+    return true; \/\/ Found\n+  }\n+  return false;\n+}\n+\n+AOTCodeEntry* AOTCodeCache::find_entry(AOTCodeEntry::Kind kind, uint id) {\n+  assert(_for_use, \"sanity\");\n+  uint count = _load_header->entries_count();\n+  if (_load_entries == nullptr) {\n+    \/\/ Read it\n+    _search_entries = (uint*)addr(_load_header->entries_offset()); \/\/ [id, index]\n+    _load_entries = (AOTCodeEntry*)(_search_entries + 2 * count);\n+    log_debug(aot, codecache, init)(\"Read %d entries table at offset %d from AOT Code Cache\", count, _load_header->entries_offset());\n+  }\n+  \/\/ Binary search\n+  int l = 0;\n+  int h = count - 1;\n+  while (l <= h) {\n+    int mid = (l + h) >> 1;\n+    int ix = mid * 2;\n+    uint is = _search_entries[ix];\n+    if (is == id) {\n+      int index = _search_entries[ix + 1];\n+      AOTCodeEntry* entry = &(_load_entries[index]);\n+      if (check_entry(kind, id, entry)) {\n+        return entry; \/\/ Found\n+      }\n+      \/\/ Linear search around to handle id collission\n+      for (int i = mid - 1; i >= l; i--) { \/\/ search back\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n+      for (int i = mid + 1; i <= h; i++) { \/\/ search forward\n+        ix = i * 2;\n+        is = _search_entries[ix];\n+        if (is != id) {\n+          break;\n+        }\n+        index = _search_entries[ix + 1];\n+        AOTCodeEntry* entry = &(_load_entries[index]);\n+        if (check_entry(kind, id, entry)) {\n+          return entry; \/\/ Found\n+        }\n+      }\n+      break; \/\/ Not found match\n+    } else if (is < id) {\n+      l = mid + 1;\n+    } else {\n+      h = mid - 1;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+extern \"C\" {\n+  static int uint_cmp(const void *i, const void *j) {\n+    uint a = *(uint *)i;\n+    uint b = *(uint *)j;\n+    return a > b ? 1 : a < b ? -1 : 0;\n+  }\n+}\n+\n+bool AOTCodeCache::finish_write() {\n+  if (!align_write()) {\n+    return false;\n+  }\n+  uint strings_offset = _write_position;\n+  int strings_count = store_strings();\n+  if (strings_count < 0) {\n+    return false;\n+  }\n+  if (!align_write()) {\n+    return false;\n+  }\n+  uint strings_size = _write_position - strings_offset;\n+\n+  uint entries_count = 0; \/\/ Number of entrant (useful) code entries\n+  uint entries_offset = _write_position;\n+\n+  uint store_count = _store_entries_cnt;\n+  if (store_count > 0) {\n+    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header),  DATA_ALIGNMENT);\n+    uint code_count = store_count;\n+    uint search_count = code_count * 2;\n+    uint search_size = search_count * sizeof(uint);\n+    uint entries_size = (uint)align_up(code_count * sizeof(AOTCodeEntry), DATA_ALIGNMENT); \/\/ In bytes\n+    \/\/ _write_position includes size of code and strings\n+    uint code_alignment = code_count * DATA_ALIGNMENT; \/\/ We align_up code size when storing it.\n+    uint total_size = header_size + _write_position + code_alignment + search_size + entries_size;\n+    assert(total_size < max_aot_code_size(), \"AOT Code size (\" UINT32_FORMAT \" bytes) is greater than AOTCodeMaxSize(\" UINT32_FORMAT \" bytes).\", total_size, max_aot_code_size());\n+\n+    \/\/ Create ordered search table for entries [id, index];\n+    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n+    \/\/ Allocate in AOT Cache buffer\n+    char* buffer = (char *)AOTCacheAccess::allocate_aot_code_region(total_size + DATA_ALIGNMENT);\n+    char* start = align_up(buffer, DATA_ALIGNMENT);\n+    char* current = start + header_size; \/\/ Skip header\n+\n+    AOTCodeEntry* entries_address = _store_entries; \/\/ Pointer to latest entry\n+    uint adapters_count = 0;\n+    uint shared_blobs_count = 0;\n+    uint C1_blobs_count = 0;\n+    uint C2_blobs_count = 0;\n+    uint max_size = 0;\n+    \/\/ AOTCodeEntry entries were allocated in reverse in store buffer.\n+    \/\/ Process them in reverse order to cache first code first.\n+    for (int i = store_count - 1; i >= 0; i--) {\n+      entries_address[i].set_next(nullptr); \/\/ clear pointers before storing data\n+      uint size = align_up(entries_address[i].size(), DATA_ALIGNMENT);\n+      if (size > max_size) {\n+        max_size = size;\n+      }\n+      copy_bytes((_store_buffer + entries_address[i].offset()), (address)current, size);\n+      entries_address[i].set_offset(current - start); \/\/ New offset\n+      current += size;\n+      uint n = write_bytes(&(entries_address[i]), sizeof(AOTCodeEntry));\n+      if (n != sizeof(AOTCodeEntry)) {\n+        FREE_C_HEAP_ARRAY(uint, search);\n+        return false;\n+      }\n+      search[entries_count*2 + 0] = entries_address[i].id();\n+      search[entries_count*2 + 1] = entries_count;\n+      entries_count++;\n+      AOTCodeEntry::Kind kind = entries_address[i].kind();\n+      if (kind == AOTCodeEntry::Adapter) {\n+        adapters_count++;\n+      } else if (kind == AOTCodeEntry::SharedBlob) {\n+        shared_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C1Blob) {\n+        C1_blobs_count++;\n+      } else if (kind == AOTCodeEntry::C2Blob) {\n+        C2_blobs_count++;\n+      }\n+    }\n+    if (entries_count == 0) {\n+      log_info(aot, codecache, exit)(\"AOT Code Cache was not created: no entires\");\n+      FREE_C_HEAP_ARRAY(uint, search);\n+      return true; \/\/ Nothing to write\n+    }\n+    assert(entries_count <= store_count, \"%d > %d\", entries_count, store_count);\n+    \/\/ Write strings\n+    if (strings_count > 0) {\n+      copy_bytes((_store_buffer + strings_offset), (address)current, strings_size);\n+      strings_offset = (current - start); \/\/ New offset\n+      current += strings_size;\n+    }\n+\n+    uint new_entries_offset = (current - start); \/\/ New offset\n+    \/\/ Sort and store search table\n+    qsort(search, entries_count, 2*sizeof(uint), uint_cmp);\n+    search_size = 2 * entries_count * sizeof(uint);\n+    copy_bytes((const char*)search, (address)current, search_size);\n+    FREE_C_HEAP_ARRAY(uint, search);\n+    current += search_size;\n+\n+    \/\/ Write entries\n+    entries_size = entries_count * sizeof(AOTCodeEntry); \/\/ New size\n+    copy_bytes((_store_buffer + entries_offset), (address)current, entries_size);\n+    current += entries_size;\n+    uint size = (current - start);\n+    assert(size <= total_size, \"%d > %d\", size , total_size);\n+\n+    log_debug(aot, codecache, exit)(\"  Adapters:  total=%u\", adapters_count);\n+    log_debug(aot, codecache, exit)(\"  Shared Blobs:  total=%d\", shared_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C1 Blobs:      total=%d\", C1_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  C2 Blobs:      total=%d\", C2_blobs_count);\n+    log_debug(aot, codecache, exit)(\"  AOT code cache size: %u bytes, max entry's size: %u bytes\", size, max_size);\n+\n+    \/\/ Finalize header\n+    AOTCodeCache::Header* header = (AOTCodeCache::Header*)start;\n+    header->init(size, (uint)strings_count, strings_offset,\n+                 entries_count, new_entries_offset,\n+                 adapters_count, shared_blobs_count,\n+                 C1_blobs_count, C2_blobs_count);\n+\n+    log_info(aot, codecache, exit)(\"Wrote %d AOT code entries to AOT Code Cache\", entries_count);\n+  }\n+  return true;\n+}\n+\n+\/\/------------------Store\/Load AOT code ----------------------\n+\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, uint id, const char* name, int entry_offset_count, int* entry_offsets) {\n+  AOTCodeCache* cache = open_for_dump();\n+  if (cache == nullptr) {\n+    return false;\n+  }\n+  assert(AOTCodeEntry::is_valid_entry_kind(entry_kind), \"invalid entry_kind %d\", entry_kind);\n+\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !is_dumping_adapter()) {\n+    return false;\n+  }\n+  if (AOTCodeEntry::is_blob(entry_kind) && !is_dumping_stub()) {\n+    return false;\n+  }\n+  log_debug(aot, codecache, stubs)(\"Writing blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n+\n+#ifdef ASSERT\n+  LogStreamHandle(Trace, aot, codecache, stubs) log;\n+  if (log.is_enabled()) {\n+    FlagSetting fs(PrintRelocations, true);\n+    blob.print_on(&log);\n+  }\n+#endif\n+  \/\/ we need to take a lock to prevent race between compiler threads generating AOT code\n+  \/\/ and the main thread generating adapter\n+  MutexLocker ml(Compile_lock);\n+  if (!cache->align_write()) {\n+    return false;\n+  }\n+  uint entry_position = cache->_write_position;\n+\n+  \/\/ Write name\n+  uint name_offset = cache->_write_position - entry_position;\n+  uint name_size = (uint)strlen(name) + 1; \/\/ Includes '\/0'\n+  uint n = cache->write_bytes(name, name_size);\n+  if (n != name_size) {\n+    return false;\n+  }\n+\n+  \/\/ Write CodeBlob\n+  if (!cache->align_write()) {\n+    return false;\n+  }\n+  uint blob_offset = cache->_write_position - entry_position;\n+  address archive_buffer = cache->reserve_bytes(blob.size());\n+  if (archive_buffer == nullptr) {\n+    return false;\n+  }\n+  CodeBlob::archive_blob(&blob, archive_buffer);\n+\n+  uint reloc_data_size = blob.relocation_size();\n+  n = cache->write_bytes((address)blob.relocation_begin(), reloc_data_size);\n+  if (n != reloc_data_size) {\n+    return false;\n+  }\n+\n+  bool has_oop_maps = false;\n+  if (blob.oop_maps() != nullptr) {\n+    if (!cache->write_oop_map_set(blob)) {\n+      return false;\n+    }\n+    has_oop_maps = true;\n+  }\n+\n+#ifndef PRODUCT\n+  \/\/ Write asm remarks\n+  if (!cache->write_asm_remarks(blob)) {\n+    return false;\n+  }\n+  if (!cache->write_dbg_strings(blob)) {\n+    return false;\n+  }\n+#endif \/* PRODUCT *\/\n+\n+  if (!cache->write_relocations(blob)) {\n+    return false;\n+  }\n+\n+  \/\/ Write entries offsets\n+  n = cache->write_bytes(&entry_offset_count, sizeof(int));\n+  if (n != sizeof(int)) {\n+    return false;\n+  }\n+  for (int i = 0; i < entry_offset_count; i++) {\n+    uint32_t off = (uint32_t)entry_offsets[i];\n+    n = cache->write_bytes(&off, sizeof(uint32_t));\n+    if (n != sizeof(uint32_t)) {\n+      return false;\n+    }\n+  }\n+  uint entry_size = cache->_write_position - entry_position;\n+  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, encode_id(entry_kind, id),\n+                                                entry_position, entry_size, name_offset, name_size,\n+                                                blob_offset, has_oop_maps, blob.content_begin());\n+  log_debug(aot, codecache, stubs)(\"Wrote code blob '%s' (id=%u, kind=%s) to AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n+  return true;\n+}\n+\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, uint id, const char* name, int entry_offset_count, int* entry_offsets) {\n+  AOTCodeCache* cache = open_for_use();\n+  if (cache == nullptr) {\n+    return nullptr;\n+  }\n+  assert(AOTCodeEntry::is_valid_entry_kind(entry_kind), \"invalid entry_kind %d\", entry_kind);\n+\n+  if (AOTCodeEntry::is_adapter(entry_kind) && !is_using_adapter()) {\n+    return nullptr;\n+  }\n+  if (AOTCodeEntry::is_blob(entry_kind) && !is_using_stub()) {\n+    return nullptr;\n+  }\n+  log_debug(aot, codecache, stubs)(\"Reading blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n+\n+  AOTCodeEntry* entry = cache->find_entry(entry_kind, encode_id(entry_kind, id));\n+  if (entry == nullptr) {\n+    return nullptr;\n+  }\n+  AOTCodeReader reader(cache, entry);\n+  CodeBlob* blob = reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+\n+  log_debug(aot, codecache, stubs)(\"Read blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n+  return blob;\n+}\n+\n+CodeBlob* AOTCodeReader::compile_code_blob(const char* name, int entry_offset_count, int* entry_offsets) {\n+  uint entry_position = _entry->offset();\n+\n+  \/\/ Read name\n+  uint name_offset = entry_position + _entry->name_offset();\n+  uint name_size = _entry->name_size(); \/\/ Includes '\/0'\n+  const char* stored_name = addr(name_offset);\n+\n+  if (strncmp(stored_name, name, (name_size - 1)) != 0) {\n+    log_warning(aot, codecache, stubs)(\"Saved blob's name '%s' is different from the expected name '%s'\",\n+                                       stored_name, name);\n+    ((AOTCodeCache*)_cache)->set_failed();\n+    report_load_failure();\n+    return nullptr;\n+  }\n+\n+  \/\/ Read archived code blob\n+  uint offset = entry_position + _entry->blob_offset();\n+  CodeBlob* archived_blob = (CodeBlob*)addr(offset);\n+  offset += archived_blob->size();\n+\n+  address reloc_data = (address)addr(offset);\n+  offset += archived_blob->relocation_size();\n+  set_read_position(offset);\n+\n+  ImmutableOopMapSet* oop_maps = nullptr;\n+  if (_entry->has_oop_maps()) {\n+    oop_maps = read_oop_map_set();\n+  }\n+\n+#ifndef PRODUCT\n+  AsmRemarks asm_remarks;\n+  read_asm_remarks(asm_remarks);\n+  DbgStrings dbg_strings;\n+  read_dbg_strings(dbg_strings);\n+#endif \/\/ PRODUCT\n+\n+  CodeBlob* code_blob = CodeBlob::create(archived_blob,\n+                                         stored_name,\n+                                         reloc_data,\n+                                         oop_maps\n+#ifndef PRODUCT\n+                                         , asm_remarks\n+                                         , dbg_strings\n+#endif\n+                                        );\n+  if (code_blob == nullptr) { \/\/ no space left in CodeCache\n+    return nullptr;\n+  }\n+\n+  fix_relocations(code_blob);\n+\n+  \/\/ Read entries offsets\n+  offset = read_position();\n+  int stored_count = *(int*)addr(offset);\n+  assert(stored_count == entry_offset_count, \"entry offset count mismatch, count in AOT code cache=%d, expected=%d\", stored_count, entry_offset_count);\n+  offset += sizeof(int);\n+  set_read_position(offset);\n+  for (int i = 0; i < stored_count; i++) {\n+    uint32_t off = *(uint32_t*)addr(offset);\n+    offset += sizeof(uint32_t);\n+    const char* entry_name = (_entry->kind() == AOTCodeEntry::Adapter) ? AdapterHandlerEntry::entry_name(i) : \"\";\n+    log_trace(aot, codecache, stubs)(\"Reading adapter '%s:%s' (0x%x) offset: 0x%x from AOT Code Cache\",\n+                                      stored_name, entry_name, _entry->id(), off);\n+    entry_offsets[i] = off;\n+  }\n+\n+#ifdef ASSERT\n+  LogStreamHandle(Trace, aot, codecache, stubs) log;\n+  if (log.is_enabled()) {\n+    FlagSetting fs(PrintRelocations, true);\n+    code_blob->print_on(&log);\n+  }\n+#endif\n+  return code_blob;\n+}\n+\n+\/\/ ------------ process code and data --------------\n+\n+bool AOTCodeCache::write_relocations(CodeBlob& code_blob) {\n+  GrowableArray<uint> reloc_data;\n+  RelocIterator iter(&code_blob);\n+  LogStreamHandle(Trace, aot, codecache, reloc) log;\n+  while (iter.next()) {\n+    int idx = reloc_data.append(0); \/\/ default value\n+    switch (iter.type()) {\n+      case relocInfo::none:\n+        break;\n+      case relocInfo::runtime_call_type: {\n+        \/\/ Record offset of runtime destination\n+        CallRelocation* r = (CallRelocation*)iter.reloc();\n+        address dest = r->destination();\n+        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n+          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n+        }\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::runtime_call_w_cp_type:\n+        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        break;\n+      case relocInfo::external_word_type: {\n+        \/\/ Record offset of runtime target\n+        address target = ((external_word_Relocation*)iter.reloc())->target();\n+        reloc_data.at_put(idx, _table->id_for_address(target, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::internal_word_type:\n+        break;\n+      case relocInfo::section_word_type:\n+        break;\n+      case relocInfo::post_call_nop_type:\n+        break;\n+      default:\n+        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        break;\n+    }\n+    if (log.is_enabled()) {\n+      iter.print_current_on(&log);\n+    }\n+  }\n+\n+  \/\/ Write additional relocation data: uint per relocation\n+  \/\/ Write the count first\n+  int count = reloc_data.length();\n+  write_bytes(&count, sizeof(int));\n+  for (GrowableArrayIterator<uint> iter = reloc_data.begin();\n+       iter != reloc_data.end(); ++iter) {\n+    uint value = *iter;\n+    int n = write_bytes(&value, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void AOTCodeReader::fix_relocations(CodeBlob* code_blob) {\n+  LogStreamHandle(Trace, aot, reloc) log;\n+  uint offset = read_position();\n+  int count = *(int*)addr(offset);\n+  offset += sizeof(int);\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== extra relocations count=%d\", count);\n+  }\n+  uint* reloc_data = (uint*)addr(offset);\n+  offset += (count * sizeof(uint));\n+  set_read_position(offset);\n+\n+  RelocIterator iter(code_blob);\n+  int j = 0;\n+  while (iter.next()) {\n+    switch (iter.type()) {\n+      case relocInfo::none:\n+        break;\n+      case relocInfo::runtime_call_type: {\n+        address dest = _cache->address_for_id(reloc_data[j]);\n+        if (dest != (address)-1) {\n+          ((CallRelocation*)iter.reloc())->set_destination(dest);\n+        }\n+        break;\n+      }\n+      case relocInfo::runtime_call_w_cp_type:\n+        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        break;\n+      case relocInfo::external_word_type: {\n+        address target = _cache->address_for_id(reloc_data[j]);\n+        \/\/ Add external address to global table\n+        int index = ExternalsRecorder::find_index(target);\n+        \/\/ Update index in relocation\n+        Relocation::add_jint(iter.data(), index);\n+        external_word_Relocation* reloc = (external_word_Relocation*)iter.reloc();\n+        assert(reloc->target() == target, \"sanity\");\n+        reloc->set_value(target); \/\/ Patch address in the code\n+        break;\n+      }\n+      case relocInfo::internal_word_type: {\n+        internal_word_Relocation* r = (internal_word_Relocation*)iter.reloc();\n+        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), code_blob->content_begin());\n+        break;\n+      }\n+      case relocInfo::section_word_type: {\n+        section_word_Relocation* r = (section_word_Relocation*)iter.reloc();\n+        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), code_blob->content_begin());\n+        break;\n+      }\n+      case relocInfo::post_call_nop_type:\n+        break;\n+      default:\n+        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        break;\n+    }\n+    if (log.is_enabled()) {\n+      iter.print_current_on(&log);\n+    }\n+    j++;\n+  }\n+  assert(j == count, \"sanity\");\n+}\n+\n+bool AOTCodeCache::write_oop_map_set(CodeBlob& cb) {\n+  ImmutableOopMapSet* oopmaps = cb.oop_maps();\n+  int oopmaps_size = oopmaps->nr_of_bytes();\n+  if (!write_bytes(&oopmaps_size, sizeof(int))) {\n+    return false;\n+  }\n+  uint n = write_bytes(oopmaps, oopmaps->nr_of_bytes());\n+  if (n != (uint)oopmaps->nr_of_bytes()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+ImmutableOopMapSet* AOTCodeReader::read_oop_map_set() {\n+  uint offset = read_position();\n+  int size = *(int *)addr(offset);\n+  offset += sizeof(int);\n+  ImmutableOopMapSet* oopmaps = (ImmutableOopMapSet *)addr(offset);\n+  offset += size;\n+  set_read_position(offset);\n+  return oopmaps;\n+}\n+\n+#ifndef PRODUCT\n+bool AOTCodeCache::write_asm_remarks(CodeBlob& cb) {\n+  \/\/ Write asm remarks\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.asm_remarks().iterate([&] (uint offset, const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"asm remark offset=%d, str='%s'\", offset, str);\n+    uint n = write_bytes(&offset, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+    }\n+    const char* cstr = add_C_string(str);\n+    int id = _table->id_for_C_string((address)cstr);\n+    assert(id != -1, \"asm remark string '%s' not found in AOTCodeAddressTable\", str);\n+    n = write_bytes(&id, sizeof(int));\n+    if (n != sizeof(int)) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_asm_remarks(AsmRemarks& asm_remarks) {\n+  \/\/ Read asm remarks\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    uint remark_offset = *(uint *)addr(offset);\n+    offset += sizeof(uint);\n+    int remark_string_id = *(uint *)addr(offset);\n+    offset += sizeof(int);\n+    const char* remark = (const char*)_cache->address_for_C_string(remark_string_id);\n+    asm_remarks.insert(remark_offset, remark);\n+  }\n+  set_read_position(offset);\n+}\n+\n+bool AOTCodeCache::write_dbg_strings(CodeBlob& cb) {\n+  \/\/ Write dbg strings\n+  uint* count_ptr = (uint *)reserve_bytes(sizeof(uint));\n+  if (count_ptr == nullptr) {\n+    return false;\n+  }\n+  uint count = 0;\n+  bool result = cb.dbg_strings().iterate([&] (const char* str) -> bool {\n+    log_trace(aot, codecache, stubs)(\"dbg string=%s\", str);\n+    const char* cstr = add_C_string(str);\n+    int id = _table->id_for_C_string((address)cstr);\n+    assert(id != -1, \"db string '%s' not found in AOTCodeAddressTable\", str);\n+    uint n = write_bytes(&id, sizeof(int));\n+    if (n != sizeof(int)) {\n+      return false;\n+    }\n+    count += 1;\n+    return true;\n+  });\n+  *count_ptr = count;\n+  return result;\n+}\n+\n+void AOTCodeReader::read_dbg_strings(DbgStrings& dbg_strings) {\n+  \/\/ Read dbg strings\n+  uint offset = read_position();\n+  uint count = *(uint *)addr(offset);\n+  offset += sizeof(uint);\n+  for (uint i = 0; i < count; i++) {\n+    int string_id = *(uint *)addr(offset);\n+    offset += sizeof(int);\n+    const char* str = (const char*)_cache->address_for_C_string(string_id);\n+    dbg_strings.insert(str);\n+  }\n+  set_read_position(offset);\n+}\n+#endif \/\/ PRODUCT\n+\n+\/\/======================= AOTCodeAddressTable ===============\n+\n+\/\/ address table ids for generated routines, external addresses and C\n+\/\/ string addresses are partitioned into positive integer ranges\n+\/\/ defined by the following positive base and max values\n+\/\/ i.e. [_extrs_base, _extrs_base + _extrs_max -1],\n+\/\/      [_blobs_base, _blobs_base + _blobs_max -1],\n+\/\/      ...\n+\/\/      [_c_str_base, _c_str_base + _c_str_max -1],\n+\n+#define _extrs_max 100\n+#define _stubs_max 3\n+\n+#define _shared_blobs_max 20\n+#define _C1_blobs_max 10\n+#define _blobs_max (_shared_blobs_max+_C1_blobs_max)\n+#define _all_max (_extrs_max+_stubs_max+_blobs_max)\n+\n+#define _extrs_base 0\n+#define _stubs_base (_extrs_base + _extrs_max)\n+#define _shared_blobs_base (_stubs_base + _stubs_max)\n+#define _C1_blobs_base (_shared_blobs_base + _shared_blobs_max)\n+#define _blobs_end  (_shared_blobs_base + _blobs_max)\n+\n+#define SET_ADDRESS(type, addr)                           \\\n+  {                                                       \\\n+    type##_addr[type##_length++] = (address) (addr);      \\\n+    assert(type##_length <= type##_max, \"increase size\"); \\\n+  }\n+\n+static bool initializing_extrs = false;\n+\n+void AOTCodeAddressTable::init_extrs() {\n+  if (_extrs_complete || initializing_extrs) return; \/\/ Done already\n+\n+  assert(_blobs_end <= _all_max, \"AOTCodeAddress table ranges need adjusting\");\n+\n+  initializing_extrs = true;\n+  _extrs_addr = NEW_C_HEAP_ARRAY(address, _extrs_max, mtCode);\n+\n+  _extrs_length = 0;\n+\n+  \/\/ Record addresses of VM runtime methods\n+  SET_ADDRESS(_extrs, SharedRuntime::fixup_callers_callsite);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method_abstract);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method_ic_miss);\n+  SET_ADDRESS(_extrs, SharedRuntime::allocate_inline_types);\n+#if defined(AARCH64)\n+  SET_ADDRESS(_extrs, JavaThread::aarch64_get_thread_helper);\n+#endif\n+  {\n+    \/\/ Required by Shared blobs\n+    SET_ADDRESS(_extrs, Deoptimization::fetch_unroll_info);\n+    SET_ADDRESS(_extrs, Deoptimization::unpack_frames);\n+    SET_ADDRESS(_extrs, SafepointSynchronize::handle_polling_page_exception);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_opt_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_virtual_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::resolve_static_call_C);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_delayed_StackOverflowError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_AbstractMethodError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_IncompatibleClassChangeError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_NullPointerException_at_call);\n+  }\n+\n+#ifdef COMPILER1\n+  {\n+    \/\/ Required by C1 blobs\n+    SET_ADDRESS(_extrs, static_cast<int (*)(oopDesc*)>(SharedRuntime::dtrace_object_alloc));\n+    SET_ADDRESS(_extrs, SharedRuntime::exception_handler_for_return_address);\n+    SET_ADDRESS(_extrs, SharedRuntime::register_finalizer);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::exception_handler_for_pc);\n+    SET_ADDRESS(_extrs, Runtime1::check_abort_on_vm_exception);\n+    SET_ADDRESS(_extrs, Runtime1::new_instance);\n+    SET_ADDRESS(_extrs, Runtime1::counter_overflow);\n+    SET_ADDRESS(_extrs, Runtime1::new_type_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_object_array);\n+    SET_ADDRESS(_extrs, Runtime1::new_multi_array);\n+    SET_ADDRESS(_extrs, Runtime1::throw_range_check_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_index_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_div0_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_null_pointer_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_array_store_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_class_cast_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_incompatible_class_change_error);\n+    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n+    SET_ADDRESS(_extrs, Runtime1::monitorenter);\n+    SET_ADDRESS(_extrs, Runtime1::monitorexit);\n+    SET_ADDRESS(_extrs, Runtime1::deoptimize);\n+    SET_ADDRESS(_extrs, Runtime1::access_field_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_klass_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_mirror_patching);\n+    SET_ADDRESS(_extrs, Runtime1::move_appendix_patching);\n+    SET_ADDRESS(_extrs, Runtime1::predicate_failed_trap);\n+    SET_ADDRESS(_extrs, Runtime1::unimplemented_entry);\n+    SET_ADDRESS(_extrs, Runtime1::new_null_free_array);\n+    SET_ADDRESS(_extrs, Runtime1::load_flat_array);\n+    SET_ADDRESS(_extrs, Runtime1::store_flat_array);\n+    SET_ADDRESS(_extrs, Runtime1::substitutability_check);\n+    SET_ADDRESS(_extrs, Runtime1::buffer_inline_args);\n+    SET_ADDRESS(_extrs, Runtime1::buffer_inline_args_no_receiver);\n+    SET_ADDRESS(_extrs, Runtime1::throw_identity_exception);\n+    SET_ADDRESS(_extrs, Runtime1::throw_illegal_monitor_state_exception);\n+    SET_ADDRESS(_extrs, Thread::current);\n+    SET_ADDRESS(_extrs, CompressedKlassPointers::base_addr());\n+#ifndef PRODUCT\n+    SET_ADDRESS(_extrs, os::breakpoint);\n+#endif\n+  }\n+#endif\n+\n+#ifdef COMPILER2\n+  {\n+    \/\/ Required by C2 blobs\n+    SET_ADDRESS(_extrs, Deoptimization::uncommon_trap);\n+    SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_instance_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::new_array_nozero_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray2_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray3_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray4_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarray5_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::multianewarrayN_C);\n+#if INCLUDE_JVMTI\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_start);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_end);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_mount);\n+    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_unmount);\n+#endif\n+    SET_ADDRESS(_extrs, OptoRuntime::complete_monitor_locking_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notify_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::monitor_notifyAll_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::rethrow_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::slow_arraycopy_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::register_finalizer_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::load_unknown_inline_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::store_unknown_inline_C);\n+#if defined(AARCH64)\n+    SET_ADDRESS(_extrs, JavaThread::verify_cross_modify_fence_failure);\n+#endif \/\/ AARCH64\n+  }\n+#endif \/\/ COMPILER2\n+\n+#if INCLUDE_G1GC\n+  SET_ADDRESS(_extrs, G1BarrierSetRuntime::write_ref_field_post_entry);\n+  SET_ADDRESS(_extrs, G1BarrierSetRuntime::write_ref_field_pre_entry);\n+#endif\n+#if INCLUDE_SHENANDOAHGC\n+  SET_ADDRESS(_extrs, ShenandoahRuntime::write_ref_field_pre);\n+  SET_ADDRESS(_extrs, ShenandoahRuntime::load_reference_barrier_phantom);\n+  SET_ADDRESS(_extrs, ShenandoahRuntime::load_reference_barrier_phantom_narrow);\n+#endif\n+#if INCLUDE_ZGC\n+  SET_ADDRESS(_extrs, ZBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded_addr());\n+#if defined(AMD64)\n+  SET_ADDRESS(_extrs, &ZPointerLoadShift);\n+#endif\n+#endif\n+#ifndef ZERO\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n+  SET_ADDRESS(_extrs, MacroAssembler::debug64);\n+#endif\n+#endif \/\/ ZERO\n+\n+  if (UseCompressedOops) {\n+    SET_ADDRESS(_extrs, CompressedOops::base_addr());\n+  }\n+\n+  _extrs_complete = true;\n+  log_debug(aot, codecache, init)(\"External addresses recorded\");\n+}\n+\n+static bool initializing_early_stubs = false;\n+\n+void AOTCodeAddressTable::init_early_stubs() {\n+  if (_complete || initializing_early_stubs) return; \/\/ Done already\n+  initializing_early_stubs = true;\n+  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n+  _stubs_length = 0;\n+  SET_ADDRESS(_stubs, StubRoutines::forward_exception_entry());\n+\n+  {\n+    \/\/ Required by C1 blobs\n+#if defined(AMD64) && !defined(ZERO)\n+    SET_ADDRESS(_stubs, StubRoutines::x86::double_sign_flip());\n+    SET_ADDRESS(_stubs, StubRoutines::x86::d2l_fixup());\n+#endif \/\/ AMD64\n+  }\n+\n+  _early_stubs_complete = true;\n+  log_info(aot, codecache, init)(\"Early stubs recorded\");\n+}\n+\n+static bool initializing_shared_blobs = false;\n+\n+void AOTCodeAddressTable::init_shared_blobs() {\n+  if (_complete || initializing_shared_blobs) return; \/\/ Done already\n+  initializing_shared_blobs = true;\n+  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n+  _shared_blobs_addr = blobs_addr;\n+  _C1_blobs_addr = _shared_blobs_addr + _shared_blobs_max;\n+  _shared_blobs_length = _C1_blobs_length = 0;\n+\n+  \/\/ clear the address table\n+  memset(blobs_addr, 0, sizeof(address)* _blobs_max);\n+\n+  \/\/ Record addresses of generated code blobs\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_handle_wrong_method_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::get_ic_miss_stub());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_reexecution());\n+  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception_in_tls());\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->uncommon_trap());\n+    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->implicit_exception_uncommon_trap());\n+  }\n+#endif\n+\n+  _shared_blobs_complete = true;\n+  log_debug(aot, codecache, init)(\"Early shared blobs recorded\");\n+  _complete = true;\n+}\n+\n+void AOTCodeAddressTable::init_early_c1() {\n+#ifdef COMPILER1\n+  \/\/ Runtime1 Blobs\n+  for (int i = 0; i <= (int)C1StubId::forward_exception_id; i++) {\n+    C1StubId id = (C1StubId)i;\n+    if (Runtime1::blob_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    if (Runtime1::entry_for(id) == nullptr) {\n+      log_info(aot, codecache, init)(\"C1 blob %s is missing entry\", Runtime1::name_for(id));\n+      continue;\n+    }\n+    address entry = Runtime1::entry_for(id);\n+    SET_ADDRESS(_C1_blobs, entry);\n+  }\n+#endif \/\/ COMPILER1\n+  assert(_C1_blobs_length <= _C1_blobs_max, \"increase _C1_blobs_max to %d\", _C1_blobs_length);\n+  _early_c1_complete = true;\n+}\n+\n+#undef SET_ADDRESS\n+\n+AOTCodeAddressTable::~AOTCodeAddressTable() {\n+  if (_extrs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _extrs_addr);\n+  }\n+  if (_shared_blobs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _shared_blobs_addr);\n+  }\n+}\n+\n+#ifdef PRODUCT\n+#define MAX_STR_COUNT 200\n+#else\n+#define MAX_STR_COUNT 500\n+#endif\n+#define _c_str_max  MAX_STR_COUNT\n+static const int _c_str_base = _all_max;\n+\n+static const char* _C_strings_in[MAX_STR_COUNT] = {nullptr}; \/\/ Incoming strings\n+static const char* _C_strings[MAX_STR_COUNT]    = {nullptr}; \/\/ Our duplicates\n+static int _C_strings_count = 0;\n+static int _C_strings_s[MAX_STR_COUNT] = {0};\n+static int _C_strings_id[MAX_STR_COUNT] = {0};\n+static int _C_strings_used = 0;\n+\n+void AOTCodeCache::load_strings() {\n+  uint strings_count  = _load_header->strings_count();\n+  if (strings_count == 0) {\n+    return;\n+  }\n+  uint strings_offset = _load_header->strings_offset();\n+  uint* string_lengths = (uint*)addr(strings_offset);\n+  strings_offset += (strings_count * sizeof(uint));\n+  uint strings_size = _load_header->entries_offset() - strings_offset;\n+  \/\/ We have to keep cached strings longer than _cache buffer\n+  \/\/ because they are refernced from compiled code which may\n+  \/\/ still be executed on VM exit after _cache is freed.\n+  char* p = NEW_C_HEAP_ARRAY(char, strings_size+1, mtCode);\n+  memcpy(p, addr(strings_offset), strings_size);\n+  _C_strings_buf = p;\n+  assert(strings_count <= MAX_STR_COUNT, \"sanity\");\n+  for (uint i = 0; i < strings_count; i++) {\n+    _C_strings[i] = p;\n+    uint len = string_lengths[i];\n+    _C_strings_s[i] = i;\n+    _C_strings_id[i] = i;\n+    p += len;\n+  }\n+  assert((uint)(p - _C_strings_buf) <= strings_size, \"(\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \") = %d > %d \", p2i(p), p2i(_C_strings_buf), (uint)(p - _C_strings_buf), strings_size);\n+  _C_strings_count = strings_count;\n+  _C_strings_used  = strings_count;\n+  log_debug(aot, codecache, init)(\"  Loaded %d C strings of total length %d at offset %d from AOT Code Cache\", _C_strings_count, strings_size, strings_offset);\n+}\n+\n+int AOTCodeCache::store_strings() {\n+  if (_C_strings_used > 0) {\n+    uint offset = _write_position;\n+    uint length = 0;\n+    uint* lengths = (uint *)reserve_bytes(sizeof(uint) * _C_strings_used);\n+    if (lengths == nullptr) {\n+      return -1;\n+    }\n+    for (int i = 0; i < _C_strings_used; i++) {\n+      const char* str = _C_strings[_C_strings_s[i]];\n+      uint len = (uint)strlen(str) + 1;\n+      length += len;\n+      assert(len < 1000, \"big string: %s\", str);\n+      lengths[i] = len;\n+      uint n = write_bytes(str, len);\n+      if (n != len) {\n+        return -1;\n+      }\n+    }\n+    log_debug(aot, codecache, exit)(\"  Wrote %d C strings of total length %d at offset %d to AOT Code Cache\",\n+                                   _C_strings_used, length, offset);\n+  }\n+  return _C_strings_used;\n+}\n+\n+const char* AOTCodeCache::add_C_string(const char* str) {\n+  if (is_on_for_dump() && str != nullptr) {\n+    return _cache->_table->add_C_string(str);\n+  }\n+  return str;\n+}\n+\n+const char* AOTCodeAddressTable::add_C_string(const char* str) {\n+  if (_extrs_complete) {\n+    LogStreamHandle(Trace, aot, codecache, stringtable) log; \/\/ ctor outside lock\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ Check previous strings address\n+    for (int i = 0; i < _C_strings_count; i++) {\n+      if (_C_strings_in[i] == str) {\n+        return _C_strings[i]; \/\/ Found previous one - return our duplicate\n+      } else if (strcmp(_C_strings[i], str) == 0) {\n+        return _C_strings[i];\n+      }\n+    }\n+    \/\/ Add new one\n+    if (_C_strings_count < MAX_STR_COUNT) {\n+      \/\/ Passed in string can be freed and used space become inaccessible.\n+      \/\/ Keep original address but duplicate string for future compare.\n+      _C_strings_id[_C_strings_count] = -1; \/\/ Init\n+      _C_strings_in[_C_strings_count] = str;\n+      const char* dup = os::strdup(str);\n+      _C_strings[_C_strings_count++] = dup;\n+      if (log.is_enabled()) {\n+        log.print_cr(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n+      }\n+      return dup;\n+    } else {\n+      fatal(\"Number of C strings >= MAX_STR_COUNT\");\n+    }\n+  }\n+  return str;\n+}\n+\n+int AOTCodeAddressTable::id_for_C_string(address str) {\n+  if (str == nullptr) {\n+    return -1;\n+  }\n+  MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n+  for (int i = 0; i < _C_strings_count; i++) {\n+    if (_C_strings[i] == (const char*)str) { \/\/ found\n+      int id = _C_strings_id[i];\n+      if (id >= 0) {\n+        assert(id < _C_strings_used, \"%d >= %d\", id , _C_strings_used);\n+        return id; \/\/ Found recorded\n+      }\n+      \/\/ Not found in recorded, add new\n+      id = _C_strings_used++;\n+      _C_strings_s[id] = i;\n+      _C_strings_id[i] = id;\n+      return id;\n+    }\n+  }\n+  return -1;\n+}\n+\n+address AOTCodeAddressTable::address_for_C_string(int idx) {\n+  assert(idx < _C_strings_count, \"sanity\");\n+  return (address)_C_strings[idx];\n+}\n+\n+static int search_address(address addr, address* table, uint length) {\n+  for (int i = 0; i < (int)length; i++) {\n+    if (table[i] == addr) {\n+      return i;\n+    }\n+  }\n+  return -1;\n+}\n+\n+address AOTCodeAddressTable::address_for_id(int idx) {\n+  if (!_extrs_complete) {\n+    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n+  }\n+  if (idx == -1) {\n+    return (address)-1;\n+  }\n+  uint id = (uint)idx;\n+  \/\/ special case for symbols based relative to os::init\n+  if (id > (_c_str_base + _c_str_max)) {\n+    return (address)os::init + idx;\n+  }\n+  if (idx < 0) {\n+    fatal(\"Incorrect id %d for AOT Code Cache addresses table\", id);\n+  }\n+  \/\/ no need to compare unsigned id against 0\n+  if (\/* id >= _extrs_base && *\/ id < _extrs_length) {\n+    return _extrs_addr[id - _extrs_base];\n+  }\n+  if (id >= _stubs_base && id < _stubs_base + _stubs_length) {\n+    return _stubs_addr[id - _stubs_base];\n+  }\n+  if (id >= _shared_blobs_base && id < _shared_blobs_base + _shared_blobs_length) {\n+    return _shared_blobs_addr[id - _shared_blobs_base];\n+  }\n+  if (id >= _C1_blobs_base && id < _C1_blobs_base + _C1_blobs_length) {\n+    return _C1_blobs_addr[id - _C1_blobs_base];\n+  }\n+  if (id >= _c_str_base && id < (_c_str_base + (uint)_C_strings_count)) {\n+    return address_for_C_string(id - _c_str_base);\n+  }\n+  fatal(\"Incorrect id %d for AOT Code Cache addresses table\", id);\n+  return nullptr;\n+}\n+\n+int AOTCodeAddressTable::id_for_address(address addr, RelocIterator reloc, CodeBlob* code_blob) {\n+  if (!_extrs_complete) {\n+    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n+  }\n+  int id = -1;\n+  if (addr == (address)-1) { \/\/ Static call stub has jump to itself\n+    return id;\n+  }\n+  \/\/ Seach for C string\n+  id = id_for_C_string(addr);\n+  if (id >= 0) {\n+    return id + _c_str_base;\n+  }\n+  if (StubRoutines::contains(addr)) {\n+    \/\/ Search in stubs\n+    id = search_address(addr, _stubs_addr, _stubs_length);\n+    if (id < 0) {\n+      StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n+      if (desc == nullptr) {\n+        desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+      }\n+      const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n+      fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n+    } else {\n+      return id + _stubs_base;\n+    }\n+  } else {\n+    CodeBlob* cb = CodeCache::find_blob(addr);\n+    if (cb != nullptr) {\n+      \/\/ Search in code blobs\n+      int id_base = _shared_blobs_base;\n+      id = search_address(addr, _shared_blobs_addr, _blobs_max);\n+      if (id < 0) {\n+        fatal(\"Address \" INTPTR_FORMAT \" for Blob:%s is missing in AOT Code Cache addresses table\", p2i(addr), cb->name());\n+      } else {\n+        return id_base + id;\n+      }\n+    } else {\n+      \/\/ Search in runtime functions\n+      id = search_address(addr, _extrs_addr, _extrs_length);\n+      if (id < 0) {\n+        ResourceMark rm;\n+        const int buflen = 1024;\n+        char* func_name = NEW_RESOURCE_ARRAY(char, buflen);\n+        int offset = 0;\n+        if (os::dll_address_to_function_name(addr, func_name, buflen, &offset)) {\n+          if (offset > 0) {\n+            \/\/ Could be address of C string\n+            uint dist = (uint)pointer_delta(addr, (address)os::init, 1);\n+            log_debug(aot, codecache)(\"Address \" INTPTR_FORMAT \" (offset %d) for runtime target '%s' is missing in AOT Code Cache addresses table\",\n+                                      p2i(addr), dist, (const char*)addr);\n+            assert(dist > (uint)(_all_max + MAX_STR_COUNT), \"change encoding of distance\");\n+            return dist;\n+          }\n+          reloc.print_current_on(tty);\n+          code_blob->print_on(tty);\n+          code_blob->print_code_on(tty);\n+          fatal(\"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n+        } else {\n+          reloc.print_current_on(tty);\n+          code_blob->print_on(tty);\n+          code_blob->print_code_on(tty);\n+          os::find(addr, tty);\n+          fatal(\"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n+        }\n+      } else {\n+        return _extrs_base + id;\n+      }\n+    }\n+  }\n+  return id;\n+}\n+\n+void AOTCodeCache::print_on(outputStream* st) {\n+  AOTCodeCache* cache = open_for_use();\n+  if (cache != nullptr) {\n+    uint count = cache->_load_header->entries_count();\n+    uint* search_entries = (uint*)cache->addr(cache->_load_header->entries_offset()); \/\/ [id, index]\n+    AOTCodeEntry* load_entries = (AOTCodeEntry*)(search_entries + 2 * count);\n+\n+    for (uint i = 0; i < count; i++) {\n+      \/\/ Use search_entries[] to order ouput\n+      int index = search_entries[2*i + 1];\n+      AOTCodeEntry* entry = &(load_entries[index]);\n+\n+      uint entry_position = entry->offset();\n+      uint name_offset = entry->name_offset() + entry_position;\n+      const char* saved_name = cache->addr(name_offset);\n+\n+      st->print_cr(\"%4u: entry_idx:%4u Kind:%u Id:%u size=%u '%s'\",\n+                   i, index, entry->kind(), entry->id(), entry->size(), saved_name);\n+    }\n+  } else {\n+    st->print_cr(\"failed to map code cache\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":1730,"deletions":0,"binary":false,"changes":1730,"status":"added"},{"patch":"@@ -0,0 +1,412 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CODE_AOTCODECACHE_HPP\n+#define SHARE_CODE_AOTCODECACHE_HPP\n+\n+\/*\n+ * AOT Code Cache collects code from Code Cache and corresponding metadata\n+ * during application training run.\n+ * In following \"production\" runs this code and data can be loaded into\n+ * Code Cache skipping its generation.\n+ *\/\n+\n+class CodeBuffer;\n+class RelocIterator;\n+class AOTCodeCache;\n+class AdapterBlob;\n+class ExceptionBlob;\n+class ImmutableOopMapSet;\n+class AsmRemarks;\n+class DbgStrings;\n+\n+enum class vmIntrinsicID : int;\n+enum CompLevel : signed char;\n+\n+#define DO_AOTCODEENTRY_KIND(Fn) \\\n+  Fn(None) \\\n+  Fn(Adapter) \\\n+  Fn(SharedBlob) \\\n+  Fn(C1Blob) \\\n+  Fn(C2Blob) \\\n+\n+\/\/ Descriptor of AOT Code Cache's entry\n+class AOTCodeEntry {\n+public:\n+  enum Kind : s1 {\n+#define DECL_KIND_ENUM(kind) kind,\n+    DO_AOTCODEENTRY_KIND(DECL_KIND_ENUM)\n+#undef DECL_KIND_ENUM\n+    Kind_count\n+  };\n+\n+private:\n+  AOTCodeEntry* _next;\n+  Kind   _kind;\n+  uint   _id;          \/\/ Adapter's id, vmIntrinsic::ID for stub or name's hash for nmethod\n+  uint   _offset;      \/\/ Offset to entry\n+  uint   _size;        \/\/ Entry size\n+  uint   _name_offset; \/\/ Code blob name\n+  uint   _name_size;\n+  uint   _blob_offset; \/\/ Start of code in cache\n+  bool   _has_oop_maps;\n+  address _dumptime_content_start_addr; \/\/ CodeBlob::content_begin() at dump time; used for applying relocations\n+\n+public:\n+  AOTCodeEntry(Kind kind,         uint id,\n+               uint offset,       uint size,\n+               uint name_offset,  uint name_size,\n+               uint blob_offset,  bool has_oop_maps,\n+               address dumptime_content_start_addr) {\n+    _next         = nullptr;\n+    _kind         = kind;\n+    _id           = id;\n+    _offset       = offset;\n+    _size         = size;\n+    _name_offset  = name_offset;\n+    _name_size    = name_size;\n+    _blob_offset  = blob_offset;\n+    _has_oop_maps = has_oop_maps;\n+    _dumptime_content_start_addr = dumptime_content_start_addr;\n+  }\n+  void* operator new(size_t x, AOTCodeCache* cache);\n+  \/\/ Delete is a NOP\n+  void operator delete( void *ptr ) {}\n+\n+  AOTCodeEntry* next()        const { return _next; }\n+  void set_next(AOTCodeEntry* next) { _next = next; }\n+\n+  Kind kind()         const { return _kind; }\n+  uint id()           const { return _id; }\n+\n+  uint offset()       const { return _offset; }\n+  void set_offset(uint off) { _offset = off; }\n+\n+  uint size()         const { return _size; }\n+  uint name_offset()  const { return _name_offset; }\n+  uint name_size()    const { return _name_size; }\n+  uint blob_offset()  const { return _blob_offset; }\n+  bool has_oop_maps() const { return _has_oop_maps; }\n+  address dumptime_content_start_addr() const { return _dumptime_content_start_addr; }\n+\n+  static bool is_valid_entry_kind(Kind kind) { return kind > None && kind < Kind_count; }\n+  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n+  static bool is_adapter(Kind kind) { return kind == Adapter; }\n+};\n+\n+\/\/ Addresses of stubs, blobs and runtime finctions called from compiled code.\n+class AOTCodeAddressTable : public CHeapObj<mtCode> {\n+private:\n+  address* _extrs_addr;\n+  address* _stubs_addr;\n+  address* _shared_blobs_addr;\n+  address* _C1_blobs_addr;\n+  uint     _extrs_length;\n+  uint     _stubs_length;\n+  uint     _shared_blobs_length;\n+  uint     _C1_blobs_length;\n+\n+  bool _extrs_complete;\n+  bool _early_stubs_complete;\n+  bool _shared_blobs_complete;\n+  bool _early_c1_complete;\n+  bool _complete;\n+\n+public:\n+  AOTCodeAddressTable() :\n+    _extrs_addr(nullptr),\n+    _shared_blobs_addr(nullptr),\n+    _C1_blobs_addr(nullptr),\n+    _extrs_length(0),\n+    _stubs_length(0),\n+    _shared_blobs_length(0),\n+    _C1_blobs_length(0),\n+    _extrs_complete(false),\n+    _early_stubs_complete(false),\n+    _shared_blobs_complete(false),\n+    _early_c1_complete(false),\n+    _complete(false)\n+  { }\n+  ~AOTCodeAddressTable();\n+  void init_extrs();\n+  void init_early_stubs();\n+  void init_shared_blobs();\n+  void init_early_c1();\n+  const char* add_C_string(const char* str);\n+  int  id_for_C_string(address str);\n+  address address_for_C_string(int idx);\n+  int  id_for_address(address addr, RelocIterator iter, CodeBlob* code_blob);\n+  address address_for_id(int id);\n+};\n+\n+class AOTCodeCache : public CHeapObj<mtCode> {\n+\n+\/\/ Classes used to describe AOT code cache.\n+protected:\n+  class Config {\n+    address _compressedOopBase;\n+    uint _compressedOopShift;\n+    uint _compressedKlassShift;\n+    uint _contendedPaddingWidth;\n+    uint _objectAlignment;\n+    uint _gc;\n+    enum Flags {\n+      none                     = 0,\n+      debugVM                  = 1,\n+      compressedOops           = 2,\n+      compressedClassPointers  = 4,\n+      useTLAB                  = 8,\n+      systemClassAssertions    = 16,\n+      userClassAssertions      = 32,\n+      enableContendedPadding   = 64,\n+      restrictContendedPadding = 128\n+    };\n+    uint _flags;\n+\n+  public:\n+    void record();\n+    bool verify() const;\n+  };\n+\n+  class Header : public CHeapObj<mtCode> {\n+  private:\n+    enum {\n+      AOT_CODE_VERSION = 1\n+    };\n+    uint   _version;         \/\/ AOT code version (should match when reading code cache)\n+    uint   _cache_size;      \/\/ cache size in bytes\n+    uint   _strings_count;   \/\/ number of recorded C strings\n+    uint   _strings_offset;  \/\/ offset to recorded C strings\n+    uint   _entries_count;   \/\/ number of recorded entries\n+    uint   _entries_offset;  \/\/ offset of AOTCodeEntry array describing entries\n+    uint   _adapters_count;\n+    uint   _shared_blobs_count;\n+    uint   _C1_blobs_count;\n+    uint   _C2_blobs_count;\n+    Config _config;\n+\n+public:\n+    void init(uint cache_size,\n+              uint strings_count,  uint strings_offset,\n+              uint entries_count,  uint entries_offset,\n+              uint adapters_count, uint shared_blobs_count,\n+              uint C1_blobs_count, uint C2_blobs_count) {\n+      _version        = AOT_CODE_VERSION;\n+      _cache_size     = cache_size;\n+      _strings_count  = strings_count;\n+      _strings_offset = strings_offset;\n+      _entries_count  = entries_count;\n+      _entries_offset = entries_offset;\n+      _adapters_count = adapters_count;\n+      _shared_blobs_count = shared_blobs_count;\n+      _C1_blobs_count = C1_blobs_count;\n+      _C2_blobs_count = C2_blobs_count;\n+      _config.record();\n+    }\n+\n+\n+    uint cache_size()     const { return _cache_size; }\n+    uint strings_count()  const { return _strings_count; }\n+    uint strings_offset() const { return _strings_offset; }\n+    uint entries_count()  const { return _entries_count; }\n+    uint entries_offset() const { return _entries_offset; }\n+    uint adapters_count() const { return _adapters_count; }\n+    uint shared_blobs_count()    const { return _shared_blobs_count; }\n+    uint C1_blobs_count() const { return _C1_blobs_count; }\n+    uint C2_blobs_count() const { return _C2_blobs_count; }\n+\n+    bool verify_config(uint load_size)  const;\n+    bool verify_vm_config() const { \/\/ Called after Universe initialized\n+      return _config.verify();\n+    }\n+  };\n+\n+\/\/ Continue with AOTCodeCache class definition.\n+private:\n+  Header* _load_header;\n+  char*   _load_buffer;    \/\/ Aligned buffer for loading cached code\n+  char*   _store_buffer;   \/\/ Aligned buffer for storing cached code\n+  char*   _C_store_buffer; \/\/ Original unaligned buffer\n+\n+  uint   _write_position;  \/\/ Position in _store_buffer\n+  uint   _load_size;       \/\/ Used when reading cache\n+  uint   _store_size;      \/\/ Used when writing cache\n+  bool   _for_use;         \/\/ AOT cache is open for using AOT code\n+  bool   _for_dump;        \/\/ AOT cache is open for dumping AOT code\n+  bool   _closing;         \/\/ Closing cache file\n+  bool   _failed;          \/\/ Failed read\/write to\/from cache (cache is broken?)\n+  bool   _lookup_failed;   \/\/ Failed to lookup for info (skip only this code load)\n+\n+  AOTCodeAddressTable* _table;\n+\n+  AOTCodeEntry* _load_entries;   \/\/ Used when reading cache\n+  uint*         _search_entries; \/\/ sorted by ID table [id, index]\n+  AOTCodeEntry* _store_entries;  \/\/ Used when writing cache\n+  const char*   _C_strings_buf;  \/\/ Loaded buffer for _C_strings[] table\n+  uint          _store_entries_cnt;\n+\n+  static AOTCodeCache* open_for_use();\n+  static AOTCodeCache* open_for_dump();\n+\n+  bool set_write_position(uint pos);\n+  bool align_write();\n+  address reserve_bytes(uint nbytes);\n+  uint write_bytes(const void* buffer, uint nbytes);\n+  const char* addr(uint offset) const { return _load_buffer + offset; }\n+  static AOTCodeAddressTable* addr_table() {\n+    return is_on() && (cache()->_table != nullptr) ? cache()->_table : nullptr;\n+  }\n+\n+  void set_lookup_failed()     { _lookup_failed = true; }\n+  void clear_lookup_failed()   { _lookup_failed = false; }\n+  bool lookup_failed()   const { return _lookup_failed; }\n+\n+public:\n+  AOTCodeCache(bool is_dumping, bool is_using);\n+  ~AOTCodeCache();\n+\n+  const char* cache_buffer() const { return _load_buffer; }\n+  bool failed() const { return _failed; }\n+  void set_failed()   { _failed = true; }\n+\n+  static uint max_aot_code_size();\n+\n+  uint load_size() const { return _load_size; }\n+  uint write_position() const { return _write_position; }\n+\n+  void load_strings();\n+  int store_strings();\n+\n+  static void init_extrs_table() NOT_CDS_RETURN;\n+  static void init_early_stubs_table() NOT_CDS_RETURN;\n+  static void init_shared_blobs_table() NOT_CDS_RETURN;\n+  static void init_early_c1_table() NOT_CDS_RETURN;\n+\n+  address address_for_C_string(int idx) const { return _table->address_for_C_string(idx); }\n+  address address_for_id(int id) const { return _table->address_for_id(id); }\n+\n+  bool for_use()  const { return _for_use  && !_failed; }\n+  bool for_dump() const { return _for_dump && !_failed; }\n+\n+  bool closing()          const { return _closing; }\n+\n+  AOTCodeEntry* add_entry() {\n+    _store_entries_cnt++;\n+    _store_entries -= 1;\n+    return _store_entries;\n+  }\n+\n+  AOTCodeEntry* find_entry(AOTCodeEntry::Kind kind, uint id);\n+\n+  bool finish_write();\n+\n+  bool write_relocations(CodeBlob& code_blob);\n+  bool write_oop_map_set(CodeBlob& cb);\n+#ifndef PRODUCT\n+  bool write_asm_remarks(CodeBlob& cb);\n+  bool write_dbg_strings(CodeBlob& cb);\n+#endif \/\/ PRODUCT\n+\n+  static bool store_code_blob(CodeBlob& blob,\n+                              AOTCodeEntry::Kind entry_kind,\n+                              uint id, const char* name,\n+                              int entry_offset_count = 0,\n+                              int* entry_offsets = nullptr) NOT_CDS_RETURN_(false);\n+\n+  static CodeBlob* load_code_blob(AOTCodeEntry::Kind kind,\n+                                  uint id, const char* name,\n+                                  int entry_offset_count = 0,\n+                                  int* entry_offsets = nullptr) NOT_CDS_RETURN_(nullptr);\n+\n+  static uint store_entries_cnt() {\n+    if (is_on_for_dump()) {\n+      return cache()->_store_entries_cnt;\n+    }\n+    return -1;\n+  }\n+\n+\/\/ Static access\n+\n+private:\n+  static AOTCodeCache*  _cache;\n+\n+  static bool open_cache(bool is_dumping, bool is_using);\n+  static bool verify_vm_config() {\n+    if (is_on_for_use()) {\n+      return _cache->_load_header->verify_vm_config();\n+    }\n+    return true;\n+  }\n+public:\n+  static AOTCodeCache* cache() { return _cache; }\n+  static void initialize() NOT_CDS_RETURN;\n+  static void init2() NOT_CDS_RETURN;\n+  static void close() NOT_CDS_RETURN;\n+  static bool is_on() CDS_ONLY({ return _cache != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n+  static bool is_on_for_use()  { return is_on() && _cache->for_use(); }\n+  static bool is_on_for_dump() { return is_on() && _cache->for_dump(); }\n+\n+  static bool is_dumping_adapter() NOT_CDS_RETURN_(false);\n+  static bool is_using_adapter() NOT_CDS_RETURN_(false);\n+\n+  static bool is_dumping_stub() NOT_CDS_RETURN_(false);\n+  static bool is_using_stub() NOT_CDS_RETURN_(false);\n+\n+  static const char* add_C_string(const char* str) NOT_CDS_RETURN_(str);\n+\n+  static void print_on(outputStream* st) NOT_CDS_RETURN;\n+};\n+\n+\/\/ Concurent AOT code reader\n+class AOTCodeReader {\n+private:\n+  const AOTCodeCache*  _cache;\n+  const AOTCodeEntry*  _entry;\n+  const char*          _load_buffer; \/\/ Loaded cached code buffer\n+  uint  _read_position;              \/\/ Position in _load_buffer\n+  uint  read_position() const { return _read_position; }\n+  void  set_read_position(uint pos);\n+  const char* addr(uint offset) const { return _load_buffer + offset; }\n+\n+  bool _lookup_failed;       \/\/ Failed to lookup for info (skip only this code load)\n+  void set_lookup_failed()     { _lookup_failed = true; }\n+  void clear_lookup_failed()   { _lookup_failed = false; }\n+  bool lookup_failed()   const { return _lookup_failed; }\n+\n+  AOTCodeEntry* aot_code_entry() { return (AOTCodeEntry*)_entry; }\n+public:\n+  AOTCodeReader(AOTCodeCache* cache, AOTCodeEntry* entry);\n+\n+  CodeBlob* compile_code_blob(const char* name, int entry_offset_count, int* entry_offsets);\n+\n+  ImmutableOopMapSet* read_oop_map_set();\n+\n+  void fix_relocations(CodeBlob* code_blob);\n+#ifndef PRODUCT\n+  void read_asm_remarks(AsmRemarks& asm_remarks);\n+  void read_dbg_strings(DbgStrings& dbg_strings);\n+#endif \/\/ PRODUCT\n+};\n+\n+#endif \/\/ SHARE_CODE_AOTCODECACHE_HPP\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":412,"deletions":0,"binary":false,"changes":412,"status":"added"},{"patch":"@@ -82,0 +82,3 @@\n+#ifdef COMPILER2\n+const ExceptionBlob::Vptr            ExceptionBlob::_vpntr;\n+#endif \/\/ COMPILER2\n@@ -84,1 +87,1 @@\n-const CodeBlob::Vptr* CodeBlob::vptr() const {\n+const CodeBlob::Vptr* CodeBlob::vptr(CodeBlobKind kind) {\n@@ -103,1 +106,5 @@\n-  return array[(size_t)_kind];\n+  return array[(size_t)kind];\n+}\n+\n+const CodeBlob::Vptr* CodeBlob::vptr() const {\n+  return vptr(_kind);\n@@ -186,0 +193,13 @@\n+void CodeBlob::restore_mutable_data(address reloc_data) {\n+  \/\/ Relocation data is now stored as part of the mutable data area; allocate it before copy relocations\n+  if (_mutable_data_size > 0) {\n+    _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+    if (_mutable_data == nullptr) {\n+      vm_exit_out_of_memory(_mutable_data_size, OOM_MALLOC_ERROR, \"codebuffer: no space for mutable data\");\n+    }\n+  }\n+  if (_relocation_size > 0) {\n+    memcpy((address)relocation_begin(), reloc_data, relocation_size());\n+  }\n+}\n+\n@@ -220,0 +240,85 @@\n+void CodeBlob::prepare_for_archiving_impl() {\n+  set_name(nullptr);\n+  _oop_maps = nullptr;\n+  _mutable_data = nullptr;\n+#ifndef PRODUCT\n+  asm_remarks().clear();\n+  dbg_strings().clear();\n+#endif \/* PRODUCT *\/\n+}\n+\n+void CodeBlob::prepare_for_archiving() {\n+  vptr(_kind)->prepare_for_archiving(this);\n+}\n+\n+void CodeBlob::archive_blob(CodeBlob* blob, address archive_buffer) {\n+  blob->copy_to(archive_buffer);\n+  CodeBlob* archived_blob = (CodeBlob*)archive_buffer;\n+  archived_blob->prepare_for_archiving();\n+}\n+\n+void CodeBlob::post_restore_impl() {\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+}\n+\n+void CodeBlob::post_restore() {\n+  vptr(_kind)->post_restore(this);\n+}\n+\n+CodeBlob* CodeBlob::restore(address code_cache_buffer,\n+                            const char* name,\n+                            address archived_reloc_data,\n+                            ImmutableOopMapSet* archived_oop_maps)\n+{\n+  copy_to(code_cache_buffer);\n+  CodeBlob* code_blob = (CodeBlob*)code_cache_buffer;\n+  code_blob->set_name(name);\n+  code_blob->restore_mutable_data(archived_reloc_data);\n+  code_blob->set_oop_maps(archived_oop_maps);\n+  return code_blob;\n+}\n+\n+CodeBlob* CodeBlob::create(CodeBlob* archived_blob,\n+                           const char* name,\n+                           address archived_reloc_data,\n+                           ImmutableOopMapSet* archived_oop_maps\n+#ifndef PRODUCT\n+                           , AsmRemarks& archived_asm_remarks\n+                           , DbgStrings& archived_dbg_strings\n+#endif \/\/ PRODUCT\n+                          )\n+{\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  CodeCache::gc_on_allocation();\n+\n+  CodeBlob* blob = nullptr;\n+  unsigned int size = archived_blob->size();\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    address code_cache_buffer = (address)CodeCache::allocate(size, CodeBlobType::NonNMethod);\n+    if (code_cache_buffer != nullptr) {\n+      blob = archived_blob->restore(code_cache_buffer,\n+                                    name,\n+                                    archived_reloc_data,\n+                                    archived_oop_maps);\n+#ifndef PRODUCT\n+      blob->use_remarks(archived_asm_remarks);\n+      archived_asm_remarks.clear();\n+      blob->use_strings(archived_dbg_strings);\n+      archived_dbg_strings.clear();\n+#endif \/\/ PRODUCT\n+\n+      assert(blob != nullptr, \"sanity check\");\n+      \/\/ Flush the code block\n+      ICache::invalidate_range(blob->code_begin(), blob->code_size());\n+      CodeCache::commit(blob); \/\/ Count adapters\n+    }\n+  }\n+  if (blob != nullptr) {\n+    blob->post_restore();\n+  }\n+  return blob;\n+}\n+\n@@ -754,1 +859,1 @@\n-  st->print_cr(\"[CodeBlob (\" INTPTR_FORMAT \")]\", p2i(this));\n+  st->print_cr(\"[CodeBlob kind:%d (\" INTPTR_FORMAT \")]\", (int)_kind, p2i(this));\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":108,"deletions":3,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -102,0 +102,5 @@\n+class AdapterBlob;\n+class ExceptionBlob;\n+class DeoptimizationBlob;\n+class SafepointBlob;\n+class UncommonTrapBlob;\n@@ -107,0 +112,3 @@\n+private:\n+  void restore_mutable_data(address reloc_data);\n+\n@@ -145,0 +153,6 @@\n+    virtual void prepare_for_archiving(CodeBlob* instance) const {\n+      instance->prepare_for_archiving_impl();\n+    };\n+    virtual void post_restore(CodeBlob* instance) const {\n+      instance->post_restore_impl();\n+    };\n@@ -147,0 +161,1 @@\n+  static const Vptr* vptr(CodeBlobKind kind);\n@@ -156,0 +171,1 @@\n+\n@@ -158,0 +174,3 @@\n+  void prepare_for_archiving_impl();\n+  void post_restore_impl();\n+\n@@ -194,0 +213,4 @@\n+  AdapterBlob* as_adapter_blob() const        { assert(is_adapter_blob(), \"must be adapter blob\"); return (AdapterBlob*) this; }\n+  ExceptionBlob* as_exception_blob() const    { assert(is_exception_stub(), \"must be exception stub\"); return (ExceptionBlob*) this; }\n+  DeoptimizationBlob* as_deoptimization_blob() const { assert(is_deoptimization_stub(), \"must be deopt stub\"); return (DeoptimizationBlob*) this; }\n+  SafepointBlob* as_safepoint_blob() const    { assert(is_safepoint_stub(), \"must be safepoint stub\"); return (SafepointBlob*) this; }\n@@ -196,0 +219,1 @@\n+  UncommonTrapBlob* as_uncommon_trap_blob() const { assert(is_uncommon_trap_stub(), \"must be uncommon trap stub\"); return (UncommonTrapBlob*) this; }\n@@ -250,0 +274,1 @@\n+  void set_oop_maps(ImmutableOopMapSet* p)       { _oop_maps = p; }\n@@ -284,0 +309,21 @@\n+\n+  void copy_to(address buffer) {\n+    memcpy(buffer, this, this->size());\n+  }\n+\n+  \/\/ methods to archive a blob into AOT code cache\n+  void prepare_for_archiving();\n+  static void archive_blob(CodeBlob* blob, address archive_buffer);\n+\n+  \/\/ methods to restore a blob from AOT code cache into the CodeCache\n+  void post_restore();\n+  CodeBlob* restore(address code_cache_buffer, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps);\n+  static CodeBlob* create(CodeBlob* archived_blob,\n+                          const char* name,\n+                          address archived_reloc_data,\n+                          ImmutableOopMapSet* archived_oop_maps\n+#ifndef PRODUCT\n+                          , AsmRemarks& archived_asm_remarks\n+                          , DbgStrings& archived_dbg_strings\n+#endif \/\/ PRODUCT\n+                         );\n@@ -650,0 +696,12 @@\n+\n+  void post_restore_impl() {\n+    trace_new_stub(this, \"ExceptionBlob\");\n+  }\n+\n+  class Vptr : public SingletonBlob::Vptr {\n+    void post_restore(CodeBlob* instance) const override {\n+      ((ExceptionBlob*)instance)->post_restore_impl();\n+    }\n+  };\n+\n+  static const Vptr _vpntr;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"code\/relocInfo.hpp\"\n@@ -1341,2 +1342,3 @@\n-    int metadata_size = align_up(code_buffer->total_metadata_size(), wordSize);\n-    JVMCI_ONLY( _jvmci_data_size = 0; )\n+    uint16_t metadata_size;\n+    CHECKED_CAST(metadata_size, uint16_t, align_up(code_buffer->total_metadata_size(), wordSize));\n+    JVMCI_ONLY( _metadata_size = metadata_size; )\n@@ -1515,3 +1517,4 @@\n-    uint16_t metadata_size = (uint16_t)align_up(code_buffer->total_metadata_size(), wordSize);\n-    JVMCI_ONLY(CHECKED_CAST(_jvmci_data_size, uint16_t, align_up(compiler->is_jvmci() ? jvmci_data->size() : 0, oopSize)));\n-    int jvmci_data_size = 0 JVMCI_ONLY(+ _jvmci_data_size);\n+    uint16_t metadata_size;\n+    CHECKED_CAST(metadata_size, uint16_t, align_up(code_buffer->total_metadata_size(), wordSize));\n+    JVMCI_ONLY( _metadata_size = metadata_size; )\n+    int jvmci_data_size = 0 JVMCI_ONLY( + align_up(compiler->is_jvmci() ? jvmci_data->size() : 0, oopSize));\n@@ -1521,0 +1524,1 @@\n+\n@@ -1667,0 +1671,4 @@\n+  \/\/ Enter a critical section to prevent a race with deopts that patch code and updates the relocation info.\n+  \/\/ Unfortunately, we have to lock the NMethodState_lock before the tty lock due to the deadlock rules and\n+  \/\/ cannot lock in a more finely grained manner.\n+  ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n@@ -2056,0 +2064,11 @@\n+\n+      \/\/ Update the relocation info for the patched entry.\n+      \/\/ First, get the old relocation info...\n+      RelocIterator iter(this, verified_entry_point(), verified_entry_point() + 8);\n+      if (iter.next() && iter.addr() == verified_entry_point()) {\n+        Relocation* old_reloc = iter.reloc();\n+        \/\/ ...then reset the iterator to update it.\n+        RelocIterator iter(this, verified_entry_point(), verified_entry_point() + 8);\n+        relocInfo::change_reloc_info_for_address(&iter, verified_entry_point(), old_reloc->type(),\n+                                                 relocInfo::relocType::runtime_call_type);\n+      }\n@@ -3264,1 +3283,1 @@\n-  iter.print();\n+  iter.print_on(tty);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -245,1 +245,3 @@\n-  uint16_t _jvmci_data_size;\n+  \/\/ _metadata_size is not specific to JVMCI. In the non-JVMCI case, it can be derived as:\n+  \/\/ _metadata_size = mutable_data_size - relocation_size\n+  uint16_t _metadata_size;\n@@ -545,2 +547,2 @@\n-  Metadata** metadata_end       () const { return (Metadata**) (mutable_data_end() - _jvmci_data_size); }\n-  address jvmci_data_begin      () const { return               mutable_data_end() - _jvmci_data_size; }\n+  Metadata** metadata_end       () const { return (Metadata**) (mutable_data_begin() + _relocation_size + _metadata_size); }\n+  address jvmci_data_begin      () const { return               mutable_data_begin() + _relocation_size + _metadata_size; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -182,0 +182,23 @@\n+RelocIterator::RelocIterator(CodeBlob* cb) {\n+  initialize_misc();\n+  if (cb->is_nmethod()) {\n+    _code = cb->as_nmethod();\n+  } else {\n+    _code = nullptr;\n+  }\n+  _current = cb->relocation_begin() - 1;\n+  _end     = cb->relocation_end();\n+  _addr    = cb->content_begin();\n+\n+  _section_start[CodeBuffer::SECT_CONSTS] = cb->content_begin();\n+  _section_start[CodeBuffer::SECT_INSTS ] = cb->code_begin();\n+  _section_start[CodeBuffer::SECT_STUBS ] = cb->code_end();\n+\n+  _section_end  [CodeBuffer::SECT_CONSTS] = cb->code_begin();\n+  _section_end  [CodeBuffer::SECT_INSTS ] = cb->code_end();\n+  _section_end  [CodeBuffer::SECT_STUBS ] = cb->code_end();\n+\n+  assert(!has_current(), \"just checking\");\n+  set_limits(nullptr, nullptr);\n+}\n+\n@@ -184,0 +207,3 @@\n+  if (_section_start[n] == nullptr) {\n+    return false;\n+  }\n@@ -474,1 +500,3 @@\n-  p = pack_1_int_to(p, index);\n+  \/\/ Use 4 bytes to store index to be able patch it when\n+  \/\/ updating relocations in AOTCodeReader::read_relocations().\n+  p = add_jint(p, index);\n@@ -769,0 +797,8 @@\n+void internal_word_Relocation::fix_relocation_after_aot_load(address orig_base_addr, address current_base_addr) {\n+  address target = _target;\n+  if (target == nullptr) {\n+    target = this->target();\n+    target = current_base_addr + (target - orig_base_addr);\n+  }\n+  set_value(target);\n+}\n@@ -782,6 +818,1 @@\n-\/\/---------------------------------------------------------------------------------\n-\/\/ Non-product code\n-\n-#ifndef PRODUCT\n-\n-static const char* reloc_type_string(relocInfo::relocType t) {\n+const char* relocInfo::type_name(relocInfo::relocType t) {\n@@ -805,2 +836,1 @@\n-\n-void RelocIterator::print_current() {\n+void RelocIterator::print_current_on(outputStream* st) {\n@@ -808,1 +838,1 @@\n-    tty->print_cr(\"(no relocs)\");\n+    st->print_cr(\"(no relocs)\");\n@@ -811,2 +841,2 @@\n-  tty->print(\"relocInfo@\" INTPTR_FORMAT \" [type=%d(%s) addr=\" INTPTR_FORMAT \" offset=%d\",\n-             p2i(_current), type(), reloc_type_string((relocInfo::relocType) type()), p2i(_addr), _current->addr_offset());\n+  st->print(\"relocInfo@\" INTPTR_FORMAT \" [type=%d(%s) addr=\" INTPTR_FORMAT \" offset=%d\",\n+             p2i(_current), type(), relocInfo::type_name((relocInfo::relocType) type()), p2i(_addr), _current->addr_offset());\n@@ -814,1 +844,1 @@\n-    tty->print(\" format=%d\", current()->format());\n+    st->print(\" format=%d\", current()->format());\n@@ -816,1 +846,1 @@\n-    tty->print(\" data=%d\", data()[0]);\n+    st->print(\" data=%d\", data()[0]);\n@@ -818,1 +848,1 @@\n-    tty->print(\" data={\");\n+    st->print(\" data={\");\n@@ -820,1 +850,1 @@\n-      tty->print(\"%04x\", data()[i] & 0xFFFF);\n+      st->print(\"%04x\", data()[i] & 0xFFFF);\n@@ -822,1 +852,1 @@\n-    tty->print(\"}\");\n+    st->print(\"}\");\n@@ -824,1 +854,1 @@\n-  tty->print(\"]\");\n+  st->print(\"]\");\n@@ -837,1 +867,1 @@\n-      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n@@ -842,1 +872,1 @@\n-        tty->print(\"oop_value=\" INTPTR_FORMAT \": \", p2i(oop_value));\n+        st->print(\"oop_value=\" INTPTR_FORMAT \": \", p2i(oop_value));\n@@ -844,1 +874,1 @@\n-          oop_value->print_value_on(tty);\n+          oop_value->print_value_on(st);\n@@ -860,1 +890,1 @@\n-      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n@@ -863,2 +893,2 @@\n-        tty->print(\"metadata_value=\" INTPTR_FORMAT \": \", p2i(metadata_value));\n-        metadata_value->print_value_on(tty);\n+        st->print(\"metadata_value=\" INTPTR_FORMAT \": \", p2i(metadata_value));\n+        metadata_value->print_value_on(st);\n@@ -873,1 +903,1 @@\n-      tty->print(\" | [target=\" INTPTR_FORMAT \"]\", p2i(r->value())); \/\/value==target\n+      st->print(\" | [target=\" INTPTR_FORMAT \"]\", p2i(r->value())); \/\/value==target\n@@ -879,1 +909,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n@@ -883,1 +913,1 @@\n-        tty->print(\" Blob::%s\", cb->name());\n+        st->print(\" Blob::%s\", cb->name());\n@@ -892,1 +922,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \"]\", p2i(dest));\n+      st->print(\" | [destination=\" INTPTR_FORMAT \"]\", p2i(dest));\n@@ -899,1 +929,1 @@\n-          tty->print(\" Stub::%s\", desc->name());\n+          st->print(\" Stub::%s\", desc->name());\n@@ -904,1 +934,1 @@\n-          tty->print(\" %s\", cb->name());\n+          st->print(\" %s\", cb->name());\n@@ -911,1 +941,1 @@\n-            tty->print(\" %s\", buf);\n+            st->print(\" %s\", buf);\n@@ -913,1 +943,1 @@\n-              tty->print(\"+%d\", offset);\n+              st->print(\"+%d\", offset);\n@@ -923,1 +953,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \" cached_value=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [destination=\" INTPTR_FORMAT \" cached_value=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n@@ -927,1 +957,1 @@\n-        tty->print(\" Blob::%s\", cb->name());\n+        st->print(\" Blob::%s\", cb->name());\n@@ -934,1 +964,1 @@\n-      tty->print(\" | [static_call=\" INTPTR_FORMAT \"]\", p2i(r->static_call()));\n+      st->print(\" | [static_call=\" INTPTR_FORMAT \"]\", p2i(r->static_call()));\n@@ -940,1 +970,1 @@\n-      tty->print(\" | [trampoline owner=\" INTPTR_FORMAT \"]\", p2i(r->owner()));\n+      st->print(\" | [trampoline owner=\" INTPTR_FORMAT \"]\", p2i(r->owner()));\n@@ -946,1 +976,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n@@ -950,1 +980,1 @@\n-        tty->print(\" Blob::%s\", cb->name());\n+        st->print(\" Blob::%s\", cb->name());\n@@ -957,1 +987,1 @@\n-  tty->cr();\n+  st->cr();\n@@ -961,1 +991,1 @@\n-void RelocIterator::print() {\n+void RelocIterator::print_on(outputStream* st) {\n@@ -972,1 +1002,1 @@\n-    tty->print(\"         @\" INTPTR_FORMAT \": \", p2i(scan));\n+    st->print(\"         @\" INTPTR_FORMAT \": \", p2i(scan));\n@@ -976,1 +1006,1 @@\n-      tty->print(\"%04x\", *(short*)scan & 0xFFFF);\n+      st->print(\"%04x\", *(short*)scan & 0xFFFF);\n@@ -979,1 +1009,1 @@\n-    tty->cr();\n+    st->cr();\n@@ -982,1 +1012,1 @@\n-    print_current();\n+    print_current_on(st);\n@@ -988,0 +1018,5 @@\n+\/\/---------------------------------------------------------------------------------\n+\/\/ Non-product code\n+\n+#ifndef PRODUCT\n+\n@@ -993,1 +1028,1 @@\n-  iter.print();\n+  iter.print_on(tty);\n@@ -998,1 +1033,1 @@\n-  cb->print();\n+  cb->print_on(tty);\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":81,"deletions":46,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -733,1 +733,0 @@\n-#ifdef ASSERT\n@@ -742,1 +741,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahRuntime.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+#endif\n@@ -132,0 +136,2 @@\n+  SHENANDOAHGC_ONLY(static_field(CompilerToVM::Data, shenandoah_in_cset_fast_test_addr, address))                                    \\\n+  SHENANDOAHGC_ONLY(static_field(CompilerToVM::Data, shenandoah_region_size_bytes_shift,int))                                        \\\n@@ -901,0 +907,7 @@\n+  SHENANDOAHGC_ONLY(declare_function(ShenandoahRuntime::load_reference_barrier_strong))         \\\n+  SHENANDOAHGC_ONLY(declare_function(ShenandoahRuntime::load_reference_barrier_strong_narrow))  \\\n+  SHENANDOAHGC_ONLY(declare_function(ShenandoahRuntime::load_reference_barrier_weak))           \\\n+  SHENANDOAHGC_ONLY(declare_function(ShenandoahRuntime::load_reference_barrier_weak_narrow))    \\\n+  SHENANDOAHGC_ONLY(declare_function(ShenandoahRuntime::load_reference_barrier_phantom))        \\\n+  SHENANDOAHGC_ONLY(declare_function(ShenandoahRuntime::load_reference_barrier_phantom_narrow)) \\\n+  SHENANDOAHGC_ONLY(declare_function(ShenandoahRuntime::write_barrier_pre))                     \\\n@@ -947,0 +960,9 @@\n+#if INCLUDE_SHENANDOAHGC\n+\n+#define VM_INT_CONSTANTS_JVMCI_SHENANDOAH(declare_constant, declare_constant_with_value, declare_preprocessor_constant) \\\n+   declare_constant_with_value(\"ShenandoahThreadLocalData::gc_state_offset\", in_bytes(ShenandoahThreadLocalData::gc_state_offset())) \\\n+   declare_constant_with_value(\"ShenandoahThreadLocalData::satb_mark_queue_index_offset\", in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset())) \\\n+   declare_constant_with_value(\"ShenandoahThreadLocalData::satb_mark_queue_buffer_offset\", in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset())) \\\n+   declare_constant_with_value(\"ShenandoahThreadLocalData::card_table_offset\", in_bytes(ShenandoahThreadLocalData::card_table_offset())) \\\n+\n+#endif\n@@ -1069,0 +1091,5 @@\n+#if INCLUDE_SHENANDOAHGC\n+  VM_INT_CONSTANTS_JVMCI_SHENANDOAH(GENERATE_VM_INT_CONSTANT_ENTRY,\n+                                    GENERATE_VM_INT_CONSTANT_WITH_VALUE_ENTRY,\n+                                    GENERATE_PREPROCESSOR_VM_INT_CONSTANT_ENTRY)\n+#endif\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -318,1 +318,3 @@\n-  f(RecordComponent)\n+  f(RecordComponent) \\\n+  f(AdapterHandlerEntry) \\\n+  f(AdapterFingerPrint)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+  static address  base_addr()        { return  (address)&_base; }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2802,0 +2802,1 @@\n+  assert_lock_strong(CodeCache_lock);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -405,0 +406,1 @@\n+  it->push(&_adapter);\n@@ -418,0 +420,3 @@\n+  if (AOTCodeCache::is_dumping_adapter() && _adapter != nullptr) {\n+    _adapter->remove_unshareable_info();\n+  }\n@@ -423,0 +428,6 @@\n+  if (_adapter != nullptr) {\n+    assert(_adapter->is_linked(), \"must be\");\n+    _from_compiled_entry = _adapter->get_c2i_entry();\n+    _from_compiled_inline_entry = _adapter->get_c2i_inline_entry();\n+    _from_compiled_inline_ro_entry = _adapter->get_c2i_inline_ro_entry();\n+  }\n@@ -1180,1 +1191,3 @@\n-  _adapter = nullptr;\n+  if (!AOTCodeCache::is_dumping_adapter() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+    _adapter = nullptr;\n+  }\n@@ -1225,1 +1238,5 @@\n-    return;\n+    if (adapter()->is_shared()) {\n+      assert(adapter()->is_linked(), \"Adapter is shared but not linked\");\n+    } else {\n+      return;\n+    }\n@@ -1232,1 +1249,1 @@\n-  assert(adapter() == nullptr, \"init'd to null\");\n+  assert(adapter() == nullptr || adapter()->is_linked(), \"init'd to null or restored from cache\");\n@@ -1256,1 +1273,4 @@\n-  (void) make_adapters(h_method, CHECK);\n+  if (_adapter == nullptr) {\n+    (void) make_adapters(h_method, CHECK);\n+    assert(adapter()->is_linked(), \"Adapter must have been linked\");\n+  }\n@@ -1548,0 +1568,5 @@\n+  if (m->adapter() != nullptr) {\n+    m->set_from_compiled_entry(m->adapter()->get_c2i_entry());\n+    m->set_from_compiled_inline_entry(m->adapter()->get_c2i_inline_entry());\n+    m->set_from_compiled_inline_ro_entry(m->adapter()->get_c2i_inline_ro_entry());\n+  }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -647,0 +648,1 @@\n+      _stub_id(-1),\n@@ -925,1 +927,2 @@\n-                 const char *stub_name,\n+                 const char* stub_name,\n+                 int stub_id,\n@@ -937,0 +940,1 @@\n+      _stub_id(stub_id),\n@@ -989,0 +993,10 @@\n+  \/\/ try to reuse an existing stub\n+  {\n+    CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, _stub_id, stub_name);\n+    if (blob != nullptr) {\n+      RuntimeStub* rs = blob->as_runtime_stub();\n+      _stub_entry_point = rs->entry_point();\n+      return;\n+    }\n+  }\n+\n@@ -5752,2 +5766,4 @@\n-void igv_print() {\n-  Compile::current()->igv_print_method_to_file();\n+\/\/ Use in debugger (gdb\/rr): p igv_print($sp, $fp, $pc).\n+void igv_print(void* sp, void* fp, void* pc) {\n+  frame fr(sp, fp, pc);\n+  Compile::current()->igv_print_method_to_file(nullptr, false, &fr);\n@@ -5757,2 +5773,3 @@\n-void igv_print(const char* phase_name) {\n-  Compile::current()->igv_print_method_to_file(phase_name);\n+void igv_print(const char* phase_name, void* sp, void* fp, void* pc) {\n+  frame fr(sp, fp, pc);\n+  Compile::current()->igv_print_method_to_file(phase_name, false, &fr);\n@@ -5764,1 +5781,3 @@\n-void igv_print(bool network) {\n+\/\/ Use in debugger (gdb\/rr): p igv_print(true, $sp, $fp, $pc).\n+void igv_print(bool network, void* sp, void* fp, void* pc) {\n+  frame fr(sp, fp, pc);\n@@ -5766,1 +5785,1 @@\n-    Compile::current()->igv_print_method_to_network();\n+    Compile::current()->igv_print_method_to_network(nullptr, &fr);\n@@ -5768,1 +5787,1 @@\n-    Compile::current()->igv_print_method_to_file();\n+    Compile::current()->igv_print_method_to_file(nullptr, false, &fr);\n@@ -5772,2 +5791,4 @@\n-\/\/ Same as igv_print(bool network) above but with a specified phase name.\n-void igv_print(bool network, const char* phase_name) {\n+\/\/ Same as igv_print(bool network, ...) above but with a specified phase name.\n+\/\/ Use in debugger (gdb\/rr): p igv_print(true, \"MyPhase\", $sp, $fp, $pc).\n+void igv_print(bool network, const char* phase_name, void* sp, void* fp, void* pc) {\n+  frame fr(sp, fp, pc);\n@@ -5775,1 +5796,1 @@\n-    Compile::current()->igv_print_method_to_network(phase_name);\n+    Compile::current()->igv_print_method_to_network(phase_name, &fr);\n@@ -5777,1 +5798,1 @@\n-    Compile::current()->igv_print_method_to_file(phase_name);\n+    Compile::current()->igv_print_method_to_file(phase_name, false, &fr);\n@@ -5789,2 +5810,4 @@\n-void igv_append() {\n-  Compile::current()->igv_print_method_to_file(\"Debug\", true);\n+\/\/ Use in debugger (gdb\/rr): p igv_append($sp, $fp, $pc).\n+void igv_append(void* sp, void* fp, void* pc) {\n+  frame fr(sp, fp, pc);\n+  Compile::current()->igv_print_method_to_file(nullptr, true, &fr);\n@@ -5793,3 +5816,5 @@\n-\/\/ Same as igv_append() above but with a specified phase name.\n-void igv_append(const char* phase_name) {\n-  Compile::current()->igv_print_method_to_file(phase_name, true);\n+\/\/ Same as igv_append(...) above but with a specified phase name.\n+\/\/ Use in debugger (gdb\/rr): p igv_append(\"MyPhase\", $sp, $fp, $pc).\n+void igv_append(const char* phase_name, void* sp, void* fp, void* pc) {\n+  frame fr(sp, fp, pc);\n+  Compile::current()->igv_print_method_to_file(phase_name, true, &fr);\n@@ -5798,1 +5823,1 @@\n-void Compile::igv_print_method_to_file(const char* phase_name, bool append) {\n+void Compile::igv_print_method_to_file(const char* phase_name, bool append, const frame* fr) {\n@@ -5806,1 +5831,1 @@\n-  _debug_file_printer->print_graph(phase_name);\n+  _debug_file_printer->print_graph(phase_name, fr);\n@@ -5809,1 +5834,1 @@\n-void Compile::igv_print_method_to_network(const char* phase_name) {\n+void Compile::igv_print_method_to_network(const char* phase_name, const frame* fr) {\n@@ -5812,1 +5837,1 @@\n-  igv_print_graph_to_network(phase_name, empty_list);\n+  igv_print_graph_to_network(phase_name, empty_list, fr);\n@@ -5815,1 +5840,1 @@\n-void Compile::igv_print_graph_to_network(const char* name, GrowableArray<const Node*>& visible_nodes) {\n+void Compile::igv_print_graph_to_network(const char* name, GrowableArray<const Node*>& visible_nodes, const frame* fr) {\n@@ -5822,1 +5847,1 @@\n-  _debug_network_printer->print(name, C->root(), visible_nodes);\n+  _debug_network_printer->print(name, C->root(), visible_nodes, fr);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":48,"deletions":23,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+  int                   _stub_id;               \/\/ unique id for stub or -1\n@@ -580,0 +581,1 @@\n+  int               stub_id() const             { return _stub_id; }\n@@ -695,1 +697,1 @@\n-      _igv_printer->print_graph(graph_name);\n+      _igv_printer->print_graph(graph_name, nullptr);\n@@ -699,3 +701,3 @@\n-  void igv_print_method_to_file(const char* phase_name = \"Debug\", bool append = false);\n-  void igv_print_method_to_network(const char* phase_name = \"Debug\");\n-  void igv_print_graph_to_network(const char* name, GrowableArray<const Node*>& visible_nodes);\n+  void igv_print_method_to_file(const char* phase_name = nullptr, bool append = false, const frame* fr = nullptr);\n+  void igv_print_method_to_network(const char* phase_name = nullptr, const frame* fr = nullptr);\n+  void igv_print_graph_to_network(const char* name, GrowableArray<const Node*>& visible_nodes, const frame* fr);\n@@ -1169,1 +1171,1 @@\n-          int is_fancy_jump, bool pass_tls,\n+          int stub_id, int is_fancy_jump, bool pass_tls,\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1784,2 +1784,2 @@\n-  PrintBFS(const Node* start, const int max_distance, const Node* target, const char* options, outputStream* st)\n-  : _start(start), _max_distance(max_distance), _target(target), _options(options), _output(st),\n+  PrintBFS(const Node* start, const int max_distance, const Node* target, const char* options, outputStream* st, const frame* fr)\n+    : _start(start), _max_distance(max_distance), _target(target), _options(options), _output(st), _frame(fr),\n@@ -1806,0 +1806,1 @@\n+  const frame* _frame;\n@@ -2067,1 +2068,1 @@\n-      C->igv_print_graph_to_network(\"PrintBFS\", _print_list);\n+      C->igv_print_graph_to_network(nullptr, _print_list, _frame);\n@@ -2112,0 +2113,2 @@\n+  _output->print_cr(\"        (use preferably with dump_bfs(int, Node*, char*, void*, void*, void*)\");\n+  _output->print_cr(\"         to produce a C2 stack trace along with the graph dump, see examples below)\");\n@@ -2161,0 +2164,3 @@\n+    _output->print_cr(\"  find_node(741)->dump_bfs(7, find_node(741), \\\"c+A!\\\", $sp, $fp, $pc)\");\n+    _output->print_cr(\"    same as above, but printing the resulting subgraph\");\n+    _output->print_cr(\"    along with a C2 stack trace on IGV\");\n@@ -2419,2 +2425,2 @@\n-void Node::dump_bfs(const int max_distance, Node* target, const char* options, outputStream* st) const {\n-  PrintBFS bfs(this, max_distance, target, options, st);\n+void Node::dump_bfs(const int max_distance, Node* target, const char* options, outputStream* st, const frame* fr) const {\n+  PrintBFS bfs(this, max_distance, target, options, st, fr);\n@@ -2429,0 +2435,7 @@\n+\/\/ Call this from debugger, with stack handling register arguments for IGV dumps.\n+\/\/ Example: p find_node(741)->dump_bfs(7, find_node(741), \"c+A!\", $sp, $fp, $pc).\n+void Node::dump_bfs(const int max_distance, Node* target, const char* options, void* sp, void* fp, void* pc) const {\n+  frame fr(sp, fp, pc);\n+  dump_bfs(max_distance, target, options, tty, &fr);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1315,1 +1315,1 @@\n-  void dump_bfs(const int max_distance, Node* target, const char* options, outputStream* st) const;\n+  void dump_bfs(const int max_distance, Node* target, const char* options, outputStream* st, const frame* fr = nullptr) const;\n@@ -1318,0 +1318,1 @@\n+  void dump_bfs(const int max_distance, Node* target, const char* options, void* sp, void* fp, void* pc) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -3595,0 +3596,1 @@\n+        AOTCodeCache::store_code_blob(*rs, AOTCodeEntry::C2Blob, C->stub_id(), stub_name);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+#define C2_STUB_ID(name) OptoStubId::name ## _id\n@@ -158,1 +159,1 @@\n-    generate_stub(env,                                                  \\\n+    generate_stub(env,                                                \\\n@@ -162,3 +163,4 @@\n-                  fancy_jump,                                           \\\n-                  pass_tls,                                             \\\n-                  pass_retpc);                                          \\\n+                  (int)C2_STUB_ID(name),                              \\\n+                  fancy_jump,                                         \\\n+                  pass_tls,                                           \\\n+                  pass_retpc);                                        \\\n@@ -170,3 +172,3 @@\n-  STUB_FIELD_NAME(name) =                                               \\\n-    generate_stub(env,                                                  \\\n-                  notify_jvmti_vthread_Type,                            \\\n+  STUB_FIELD_NAME(name) =                                             \\\n+    generate_stub(env,                                                \\\n+                  notify_jvmti_vthread_Type,                          \\\n@@ -175,4 +177,5 @@\n-                  0,                                                    \\\n-                  true,                                                 \\\n-                  false);                                               \\\n-  if (STUB_FIELD_NAME(name) == nullptr) { return false; }               \\\n+                  (int)C2_STUB_ID(name),                              \\\n+                  0,                                                  \\\n+                  true,                                               \\\n+                  false);                                             \\\n+  if (STUB_FIELD_NAME(name) == nullptr) { return false; }             \\\n@@ -283,2 +286,2 @@\n-                                   const char *name, int is_fancy_jump,\n-                                   bool pass_tls,\n+                                   const char *name, int stub_id,\n+                                   int is_fancy_jump, bool pass_tls,\n@@ -291,1 +294,1 @@\n-  Compile C(env, gen, C_function, name, is_fancy_jump, pass_tls, return_pc, directive);\n+  Compile C(env, gen, C_function, name, stub_id, is_fancy_jump, pass_tls, return_pc, directive);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  friend class AOTCodeAddressTable;\n@@ -220,1 +221,1 @@\n-  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int is_fancy_jump, bool pass_tls, bool return_pc);\n+  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int stub_id, int is_fancy_jump, bool pass_tls, bool return_pc);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -991,0 +991,4 @@\n+      if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+        oop carrier_thread = java_lang_VirtualThread::carrier_thread(thread_oop);\n+        java_thread = carrier_thread == nullptr ? nullptr : java_lang_Thread::thread(carrier_thread);\n+      }\n@@ -1117,0 +1121,4 @@\n+    if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+      oop carrier_thread = java_lang_VirtualThread::carrier_thread(thread_oop);\n+      java_thread = carrier_thread == nullptr ? nullptr : java_lang_Thread::thread(carrier_thread);\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1575,1 +1575,1 @@\n-\/\/ merge_cp_p. The number of entries in *merge_cp_p is returned via\n+\/\/ merge_cp_p. The number of entries in merge_cp_p is returned via\n@@ -1577,2 +1577,2 @@\n-\/\/ in *merge_cp_p. Also creates a map of indices from entries in\n-\/\/ scratch_cp to the corresponding entry in *merge_cp_p. Index map\n+\/\/ in merge_cp_p. Also creates a map of indices from entries in\n+\/\/ scratch_cp to the corresponding entry in merge_cp_p. Index map\n@@ -1580,1 +1580,1 @@\n-\/\/ different location in *merged_cp_p.\n+\/\/ different location in merged_cp_p.\n@@ -1582,2 +1582,2 @@\n-       const constantPoolHandle& scratch_cp, constantPoolHandle *merge_cp_p,\n-       int *merge_cp_length_p, TRAPS) {\n+       const constantPoolHandle& scratch_cp, constantPoolHandle& merge_cp_p,\n+       int& merge_cp_length_p, TRAPS) {\n@@ -1585,8 +1585,0 @@\n-  if (merge_cp_p == nullptr) {\n-    assert(false, \"caller must provide scratch constantPool\");\n-    return false; \/\/ robustness\n-  }\n-  if (merge_cp_length_p == nullptr) {\n-    assert(false, \"caller must provide scratch CP length\");\n-    return false; \/\/ robustness\n-  }\n@@ -1596,1 +1588,1 @@\n-  if ((*merge_cp_p)->length() < old_cp->length()) {\n+  if (merge_cp_p->length() < old_cp->length()) {\n@@ -1624,1 +1616,1 @@\n-        (*merge_cp_p)->temp_unresolved_klass_at_put(old_i,\n+        merge_cp_p->temp_unresolved_klass_at_put(old_i,\n@@ -1630,1 +1622,1 @@\n-        \/\/ just copy the entry to *merge_cp_p, but double and long take\n+        \/\/ just copy the entry to merge_cp_p, but double and long take\n@@ -1632,1 +1624,1 @@\n-        ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i);\n+        ConstantPool::copy_entry_to(old_cp, old_i, merge_cp_p, old_i);\n@@ -1637,2 +1629,2 @@\n-        \/\/ just copy the entry to *merge_cp_p\n-        ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i);\n+        \/\/ just copy the entry to merge_cp_p\n+        ConstantPool::copy_entry_to(old_cp, old_i, merge_cp_p, old_i);\n@@ -1643,2 +1635,2 @@\n-    ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_false);\n-    (*merge_cp_p)->extend_operands(scratch_cp, CHECK_false);\n+    ConstantPool::copy_operands(old_cp, merge_cp_p, CHECK_false);\n+    merge_cp_p->extend_operands(scratch_cp, CHECK_false);\n@@ -1648,1 +1640,1 @@\n-    (*merge_cp_length_p) = old_i;\n+    merge_cp_length_p = old_i;\n@@ -1653,1 +1645,1 @@\n-  log_debug(redefine, class, constantpool)(\"after pass 0: merge_cp_len=%d\", *merge_cp_length_p);\n+  log_debug(redefine, class, constantpool)(\"after pass 0: merge_cp_len=%d\", merge_cp_length_p);\n@@ -1677,1 +1669,1 @@\n-      bool match = scratch_cp->compare_entry_to(scratch_i, *merge_cp_p, scratch_i);\n+      bool match = scratch_cp->compare_entry_to(scratch_i, merge_cp_p, scratch_i);\n@@ -1683,1 +1675,1 @@\n-      int found_i = scratch_cp->find_matching_entry(scratch_i, *merge_cp_p);\n+      int found_i = scratch_cp->find_matching_entry(scratch_i, merge_cp_p);\n@@ -1695,2 +1687,2 @@\n-      \/\/ referenced entries to *merge_cp_p.\n-      append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p);\n+      \/\/ referenced entries to merge_cp_p.\n+      append_entry(scratch_cp, scratch_i, &merge_cp_p, &merge_cp_length_p);\n@@ -1702,1 +1694,1 @@\n-     *merge_cp_length_p, scratch_i, _index_map_count);\n+     merge_cp_length_p, scratch_i, _index_map_count);\n@@ -1724,1 +1716,1 @@\n-        scratch_cp->find_matching_entry(scratch_i, *merge_cp_p);\n+        scratch_cp->find_matching_entry(scratch_i, merge_cp_p);\n@@ -1726,1 +1718,1 @@\n-        \/\/ Found a matching entry somewhere else in *merge_cp_p so\n+        \/\/ Found a matching entry somewhere else in merge_cp_p so\n@@ -1733,2 +1725,2 @@\n-      \/\/ referenced entries to *merge_cp_p.\n-      append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p);\n+      \/\/ referenced entries to merge_cp_p.\n+      append_entry(scratch_cp, scratch_i, &merge_cp_p, &merge_cp_length_p);\n@@ -1739,1 +1731,1 @@\n-       *merge_cp_length_p, scratch_i, _index_map_count);\n+       merge_cp_length_p, scratch_i, _index_map_count);\n@@ -1741,1 +1733,1 @@\n-  finalize_operands_merge(*merge_cp_p, CHECK_false);\n+  finalize_operands_merge(merge_cp_p, CHECK_false);\n@@ -1818,2 +1810,2 @@\n-  bool result = merge_constant_pools(old_cp, scratch_cp, &merge_cp,\n-                  &merge_cp_length, THREAD);\n+  bool result = merge_constant_pools(old_cp, scratch_cp, merge_cp,\n+                  merge_cp_length, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":29,"deletions":37,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -444,2 +444,2 @@\n-    const constantPoolHandle& scratch_cp, constantPoolHandle *merge_cp_p,\n-    int *merge_cp_length_p, TRAPS);\n+    const constantPoolHandle& scratch_cp, constantPoolHandle& merge_cp_p,\n+    int& merge_cp_length_p, TRAPS);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -941,2 +941,1 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n-\n+  assert_lock_strong(CodeCache_lock);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -705,0 +705,3 @@\n+  product(bool, PrintVMInfoAtExit, false, DIAGNOSTIC,                       \\\n+          \"Executes the VM.info diagnostic command at exit\")                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -147,1 +148,1 @@\n-\n+  AOTCodeCache::init2();     \/\/ depends on universe_init\n@@ -158,0 +159,2 @@\n+  AOTCodeCache::init_shared_blobs_table();  \/\/ need this after generate_stubs\n+  SharedRuntime::init_adapter_library(); \/\/ do this after AOTCodeCache::init_shared_blobs_table\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-bool JavaThread::java_suspend() {\n+bool JavaThread::java_suspend(bool register_vthread_SR) {\n@@ -1206,1 +1206,1 @@\n-  return this->handshake_state()->suspend();\n+  return this->handshake_state()->suspend(register_vthread_SR);\n@@ -1209,1 +1209,1 @@\n-bool JavaThread::java_resume() {\n+bool JavaThread::java_resume(bool register_vthread_SR) {\n@@ -1212,1 +1212,1 @@\n-  return this->handshake_state()->resume();\n+  return this->handshake_state()->resume(register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -702,2 +702,2 @@\n-  bool java_suspend();\n-  bool java_resume();\n+  bool java_suspend(bool register_vthread_SR);\n+  bool java_resume(bool register_vthread_SR);\n@@ -714,2 +714,2 @@\n-  inline void set_carrier_thread_suspended();\n-  inline void clear_carrier_thread_suspended();\n+  inline bool set_carrier_thread_suspended();\n+  inline bool clear_carrier_thread_suspended();\n@@ -718,1 +718,1 @@\n-    return _carrier_thread_suspended;\n+    return Atomic::load(&_carrier_thread_suspended);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.inline.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -155,2 +158,0 @@\n-  AdapterHandlerLibrary::initialize();\n-\n@@ -176,0 +177,4 @@\n+void SharedRuntime::init_adapter_library() {\n+  AdapterHandlerLibrary::initialize();\n+}\n+\n@@ -2267,1 +2272,2 @@\n-static int _hits;    \/\/ number of successful lookups\n+static int _archived_hits; \/\/ number of successful lookups in archived table\n+static int _runtime_hits;  \/\/ number of successful lookups in runtime table\n@@ -2273,1 +2279,1 @@\n-class AdapterFingerPrint : public CHeapObj<mtCode> {\n+class AdapterFingerPrint : public MetaspaceObj {\n@@ -2284,6 +2290,50 @@\n-  union {\n-    int  _compact[_compact_int_count];\n-    int* _fingerprint;\n-  } _value;\n-  int _length; \/\/ A negative length indicates the fingerprint is in the compact form,\n-               \/\/ Otherwise _value._fingerprint is the array.\n+  int _length;\n+  int _value[_compact_int_count];\n+\n+  \/\/ Private construtor. Use allocate() to get an instance.\n+  AdapterFingerPrint(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n+    \/\/ Pack the BasicTypes with 8 per int\n+    int total_args_passed = (sig != nullptr) ? sig->length() : 0;\n+    _length = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    int sig_index = 0;\n+    BasicType prev_bt = T_ILLEGAL;\n+    int vt_count = 0;\n+    for (int index = 0; index < _length; index++) {\n+      int value = 0;\n+      for (int byte = 0; byte < _basic_types_per_int; byte++) {\n+        BasicType bt = T_ILLEGAL;\n+        if (sig_index < total_args_passed) {\n+          bt = sig->at(sig_index++)._bt;\n+          if (bt == T_METADATA) {\n+            \/\/ Found start of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+            if (sig_index == 1 && has_ro_adapter) {\n+              \/\/ With a ro_adapter, replace receiver inline type delimiter by T_VOID to prevent matching\n+              \/\/ with other adapters that have the same inline type as first argument and no receiver.\n+              bt = T_VOID;\n+            }\n+            vt_count++;\n+          } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+            \/\/ Found end of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n+            vt_count--;\n+            assert(vt_count >= 0, \"invalid vt_count\");\n+          } else if (vt_count == 0) {\n+            \/\/ Widen fields that are not part of a scalarized inline type argument\n+            bt = adapter_encoding(bt);\n+          }\n+          prev_bt = bt;\n+        }\n+        int bt_val = (bt == T_ILLEGAL) ? 0 : bt;\n+        assert((bt_val & _basic_type_mask) == bt_val, \"must fit in 4 bits\");\n+        value = (value << _basic_type_bits) | bt_val;\n+      }\n+      _value[index] = value;\n+    }\n+    assert(vt_count == 0, \"invalid vt_count\");\n+  }\n+\n+  \/\/ Call deallocate instead\n+  ~AdapterFingerPrint() {\n+    FreeHeap(this);\n+  }\n@@ -2326,19 +2376,6 @@\n- public:\n-  AdapterFingerPrint(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n-    \/\/ The fingerprint is based on the BasicType signature encoded\n-    \/\/ into an array of ints with eight entries per int.\n-    int total_args_passed = (sig != nullptr) ? sig->length() : 0;\n-    int* ptr;\n-    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n-    if (len <= _compact_int_count) {\n-      assert(_compact_int_count == 3, \"else change next line\");\n-      _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;\n-      \/\/ Storing the signature encoded as signed chars hits about 98%\n-      \/\/ of the time.\n-      _length = -len;\n-      ptr = _value._compact;\n-    } else {\n-      _length = len;\n-      _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);\n-      ptr = _value._fingerprint;\n-    }\n+  void* operator new(size_t size, size_t fp_size) throw() {\n+    assert(fp_size >= size, \"sanity check\");\n+    void* p = AllocateHeap(fp_size, mtCode);\n+    memset(p, 0, fp_size);\n+    return p;\n+  }\n@@ -2346,29 +2383,12 @@\n-    \/\/ Now pack the BasicTypes with 8 per int\n-    int sig_index = 0;\n-    BasicType prev_bt = T_ILLEGAL;\n-    int vt_count = 0;\n-    for (int index = 0; index < len; index++) {\n-      int value = 0;\n-      for (int byte = 0; byte < _basic_types_per_int; byte++) {\n-        BasicType bt = T_ILLEGAL;\n-        if (sig_index < total_args_passed) {\n-          bt = sig->at(sig_index++)._bt;\n-          if (bt == T_METADATA) {\n-            \/\/ Found start of inline type in signature\n-            assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n-            if (sig_index == 1 && has_ro_adapter) {\n-              \/\/ With a ro_adapter, replace receiver inline type delimiter by T_VOID to prevent matching\n-              \/\/ with other adapters that have the same inline type as first argument and no receiver.\n-              bt = T_VOID;\n-            }\n-            vt_count++;\n-          } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n-            \/\/ Found end of inline type in signature\n-            assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n-            vt_count--;\n-            assert(vt_count >= 0, \"invalid vt_count\");\n-          } else if (vt_count == 0) {\n-            \/\/ Widen fields that are not part of a scalarized inline type argument\n-            bt = adapter_encoding(bt);\n-          }\n-          prev_bt = bt;\n+public:\n+  template<typename Function>\n+  void iterate_args(Function function) {\n+    for (int i = 0; i < length(); i++) {\n+      unsigned val = (unsigned)value(i);\n+      \/\/ args are packed so that first\/lower arguments are in the highest\n+      \/\/ bits of each int value, so iterate from highest to the lowest\n+      int first_entry = _basic_types_per_int * _basic_type_bits;\n+      for (int j = first_entry; j >= 0; j -= _basic_type_bits) {\n+        unsigned v = (val >> j) & _basic_type_mask;\n+        if (v == 0) {\n+          continue;\n@@ -2376,3 +2396,1 @@\n-        int bt_val = (bt == T_ILLEGAL) ? 0 : bt;\n-        assert((bt_val & _basic_type_mask) == bt_val, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt_val;\n+        function(v);\n@@ -2380,2 +2398,0 @@\n-      ptr[index] = value;\n-    assert(vt_count == 0, \"invalid vt_count\");\n@@ -2385,4 +2401,13 @@\n-  ~AdapterFingerPrint() {\n-    if (_length > 0) {\n-      FREE_C_HEAP_ARRAY(int, _value._fingerprint);\n-    }\n+  static int allocation_size(const GrowableArray<SigEntry>* sig) {\n+    int total_args_passed = (sig != nullptr) ? sig->length() : 0;\n+    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    return sizeof(AdapterFingerPrint) + (len > _compact_int_count ? (len - _compact_int_count) * sizeof(int) : 0);\n+  }\n+\n+  static AdapterFingerPrint* allocate(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n+    int size_in_bytes = allocation_size(sig);\n+    return new (size_in_bytes) AdapterFingerPrint(sig, has_ro_adapter);\n+  }\n+\n+  static void deallocate(AdapterFingerPrint* fp) {\n+    fp->~AdapterFingerPrint();\n@@ -2392,4 +2417,1 @@\n-    if (_length < 0) {\n-      return _value._compact[index];\n-    }\n-    return _value._fingerprint[index];\n+    return _value[index];\n@@ -2397,0 +2419,1 @@\n+\n@@ -2403,1 +2426,1 @@\n-    return _length <= 0;\n+    return _length <= _compact_int_count;\n@@ -2410,1 +2433,2 @@\n-      hash = (hash << 8) ^ v ^ (hash >> 5);\n+      \/\/Add arithmetic operation to the hash, like +3 to improve hashing\n+      hash = ((hash << 8) ^ v ^ (hash >> 5)) + 3;\n@@ -2424,3 +2448,0 @@\n-#ifndef PRODUCT\n-  \/\/ Reconstitutes the basic type arguments from the fingerprint,\n-  \/\/ producing strings like LIJDF\n@@ -2430,21 +2451,7 @@\n-    for (int i = 0; i < length(); i++) {\n-      unsigned val = (unsigned)value(i);\n-      \/\/ args are packed so that first\/lower arguments are in the highest\n-      \/\/ bits of each int value, so iterate from highest to the lowest\n-      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n-        unsigned v = (val >> j) & _basic_type_mask;\n-        if (v == 0) {\n-          assert(i == length() - 1, \"Only expect zeroes in the last word\");\n-          continue;\n-        }\n-        if (long_prev) {\n-          long_prev = false;\n-          if (v == T_VOID) {\n-            st.print(\"J\");\n-          } else {\n-            st.print(\"L\");\n-          }\n-        } else if (v == T_LONG) {\n-          long_prev = true;\n-        } else if (v != T_VOID){\n-          st.print(\"%c\", type2char((BasicType)v));\n+    iterate_args([&] (int arg) {\n+      if (long_prev) {\n+        long_prev = false;\n+        if (arg == T_VOID) {\n+          st.print(\"J\");\n+        } else {\n+          st.print(\"L\");\n@@ -2453,1 +2460,6 @@\n-    }\n+      if (arg == T_LONG) {\n+        long_prev = true;\n+      } else if (arg != T_VOID) {\n+        st.print(\"%c\", type2char((BasicType)arg));\n+      }\n+    });\n@@ -2459,1 +2471,0 @@\n-#endif \/\/ !product\n@@ -2464,6 +2475,0 @@\n-    }\n-    if (_length < 0) {\n-      assert(_compact_int_count == 3, \"else change next line\");\n-      return _value._compact[0] == other->_value._compact[0] &&\n-             _value._compact[1] == other->_value._compact[1] &&\n-             _value._compact[2] == other->_value._compact[2];\n@@ -2472,1 +2477,1 @@\n-        if (_value._fingerprint[i] != other->_value._fingerprint[i]) {\n+        if (_value[i] != other->_value[i]) {\n@@ -2480,0 +2485,5 @@\n+  \/\/ methods required by virtue of being a MetaspaceObj\n+  void metaspace_pointers_do(MetaspaceClosure* it) { return; \/* nothing to do here *\/ }\n+  int size() const { return (int)heap_word_size(sizeof(AdapterFingerPrint) + (_length > _compact_int_count ? (_length - _compact_int_count) * sizeof(int) : 0)); }\n+  MetaspaceObj::Type type() const { return AdapterFingerPrintType; }\n+\n@@ -2490,0 +2500,11 @@\n+#if INCLUDE_CDS\n+static inline bool adapter_fp_equals_compact_hashtable_entry(AdapterHandlerEntry* entry, AdapterFingerPrint* fp, int len_unused) {\n+  return AdapterFingerPrint::equals(entry->fingerprint(), fp);\n+}\n+\n+class ArchivedAdapterTable : public OffsetCompactHashtable<\n+  AdapterFingerPrint*,\n+  AdapterHandlerEntry*,\n+  adapter_fp_equals_compact_hashtable_entry> {};\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -2496,0 +2517,1 @@\n+static GrowableArray<AdapterHandlerEntry*>* _adapter_handler_list = nullptr;\n@@ -2498,1 +2520,1 @@\n-static AdapterHandlerEntry* lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n+AdapterHandlerEntry* AdapterHandlerLibrary::lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter) {\n@@ -2501,3 +2523,9 @@\n-  AdapterFingerPrint fp(sig, has_ro_adapter);\n-  AdapterHandlerEntry** entry = _adapter_handler_table->get(&fp);\n-  if (entry != nullptr) {\n+  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(sig, has_ro_adapter);\n+  AdapterHandlerEntry* entry = nullptr;\n+#if INCLUDE_CDS\n+  \/\/ if we are building the archive then the archived adapter table is\n+  \/\/ not valid and we need to use the ones added to the runtime table\n+  if (!AOTCodeCache::is_dumping_adapter()) {\n+    \/\/ Search archived table first. It is read-only table so can be searched without lock\n+    entry = _aot_adapter_handler_table.lookup(fp, fp->compute_hash(), 0 \/* unused *\/);\n+    if (entry != nullptr) {\n@@ -2505,2 +2533,4 @@\n-    if (fp.is_compact()) _compact++;\n-    _hits++;\n+      if (fp->is_compact()) {\n+        _compact++;\n+      }\n+      _archived_hits++;\n@@ -2508,1 +2538,1 @@\n-    return *entry;\n+    }\n@@ -2510,1 +2540,17 @@\n-  return nullptr;\n+#endif \/\/ INCLUDE_CDS\n+  if (entry == nullptr) {\n+    assert_lock_strong(AdapterHandlerLibrary_lock);\n+    AdapterHandlerEntry** entry_p = _adapter_handler_table->get(fp);\n+    if (entry_p != nullptr) {\n+      entry = *entry_p;\n+      assert(entry->fingerprint()->equals(fp), \"fingerprint mismatch key fp %s %s (hash=%d) != found fp %s %s (hash=%d)\",\n+             entry->fingerprint()->as_basic_args_string(), entry->fingerprint()->as_string(), entry->fingerprint()->compute_hash(),\n+             fp->as_basic_args_string(), fp->as_string(), fp->compute_hash());\n+  #ifndef PRODUCT\n+      if (fp->is_compact()) _compact++;\n+      _runtime_hits++;\n+  #endif\n+    }\n+  }\n+  AdapterFingerPrint::deallocate(fp);\n+  return entry;\n@@ -2522,2 +2568,3 @@\n-  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d compact %d\",\n-                _lookups, _equals, _hits, _compact);\n+  int total_hits = _archived_hits + _runtime_hits;\n+  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d (archived=%d+runtime=%d) compact %d\",\n+                _lookups, _equals, total_hits, _archived_hits, _runtime_hits, _compact);\n@@ -2535,1 +2582,4 @@\n-const int AdapterHandlerLibrary_size = 48*K;\n+#if INCLUDE_CDS\n+ArchivedAdapterTable AdapterHandlerLibrary::_aot_adapter_handler_table;\n+#endif \/\/ INCLUDE_CDS\n+static const int AdapterHandlerLibrary_size = 48*K;\n@@ -2539,0 +2589,1 @@\n+  assert(_buffer != nullptr, \"should be initialized\");\n@@ -2561,0 +2612,14 @@\n+void AdapterHandlerLibrary::create_abstract_method_handler() {\n+  assert_lock_strong(AdapterHandlerLibrary_lock);\n+  \/\/ Create a special handler for abstract methods.  Abstract methods\n+  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n+  \/\/ throw AbstractMethodError just in case.\n+  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n+  \/\/ AbstractMethodError for invalid invocations.\n+  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  _abstract_method_handler = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(nullptr));\n+  _abstract_method_handler->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n+                                             wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n+                                             wrong_method_abstract, wrong_method_abstract);\n+}\n+\n@@ -2562,0 +2627,17 @@\n+  {\n+    ResourceMark rm;\n+    MutexLocker mu(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table = new (mtCode) AdapterHandlerTable();\n+    _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n+    create_abstract_method_handler();\n+  }\n+\n+#if INCLUDE_CDS\n+  \/\/ Link adapters in AOT Cache to their code in AOT Code Cache\n+  if (!_aot_adapter_handler_table.empty()) {\n+    link_aot_adapters();\n+    lookup_simple_adapters();\n+    return;\n+  }\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -2569,1 +2651,0 @@\n-    _adapter_handler_table = new (mtCode) AdapterHandlerTable();\n@@ -2572,12 +2653,0 @@\n-    \/\/ Create a special handler for abstract methods.  Abstract methods\n-    \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-    \/\/ throw AbstractMethodError just in case.\n-    \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-    \/\/ AbstractMethodError for invalid invocations.\n-    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(nullptr),\n-                                                                SharedRuntime::throw_AbstractMethodError_entry(),\n-                                                                wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n-                                                                wrong_method_abstract, wrong_method_abstract);\n-    _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n-\n@@ -2611,4 +2680,4 @@\n-          obj_arg_blob != nullptr &&\n-          int_arg_blob != nullptr &&\n-          obj_int_arg_blob != nullptr &&\n-          obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n+           obj_arg_blob != nullptr &&\n+           int_arg_blob != nullptr &&\n+           obj_int_arg_blob != nullptr &&\n+           obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n@@ -2616,1 +2685,0 @@\n-  return;\n@@ -2626,10 +2694,2 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,\n-                                                      address i2c_entry,\n-                                                      address c2i_entry,\n-                                                      address c2i_inline_entry,\n-                                                      address c2i_inline_ro_entry,\n-                                                      address c2i_unverified_entry,\n-                                                      address c2i_unverified_inline_entry,\n-                                                      address c2i_no_clinit_check_entry) {\n-  return new AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,\n-                              c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n+AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint) {\n+  return AdapterHandlerEntry::allocate(fingerprint);\n@@ -2921,0 +2981,138 @@\n+void CompiledEntrySignature::initialize_from_fingerprint(AdapterFingerPrint* fingerprint) {\n+  int value_object_count = 0;\n+  bool is_receiver = true;\n+  BasicType prev_bt = T_ILLEGAL;\n+  bool long_prev = false;\n+  bool has_scalarized_arguments = false;\n+\n+  fingerprint->iterate_args([&] (int arg) {\n+    BasicType bt = (BasicType)arg;\n+    if (long_prev) {\n+      long_prev = false;\n+      BasicType bt_to_add;\n+      if (bt == T_VOID) {\n+        bt_to_add = T_LONG;\n+      } else {\n+        bt_to_add = T_OBJECT; \/\/ it could be T_ARRAY; it shouldn't matter\n+      }\n+      SigEntry::add_entry(_sig_cc, bt_to_add);\n+      SigEntry::add_entry(_sig_cc_ro, bt_to_add);\n+      if (value_object_count == 0) {\n+        SigEntry::add_entry(_sig, bt_to_add);\n+      }\n+    }\n+    switch (bt) {\n+      case T_VOID:\n+        if (is_receiver) {\n+          \/\/ 'this' when ro adapter is available\n+          assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+          value_object_count++;\n+          has_scalarized_arguments = true;\n+          _has_inline_recv = true;\n+          SigEntry::add_entry(_sig, T_OBJECT);\n+          SigEntry::add_entry(_sig_cc, T_METADATA);\n+          SigEntry::add_entry(_sig_cc_ro, T_METADATA);\n+        } else if (prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+          assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n+          value_object_count--;\n+          SigEntry::add_entry(_sig_cc, T_VOID);\n+          SigEntry::add_entry(_sig_cc_ro, T_VOID);\n+          assert(value_object_count >= 0, \"invalid value object count\");\n+        } else {\n+          \/\/ Nothing to add for _sig: We already added an addition T_VOID in add_entry() when adding T_LONG or T_DOUBLE.\n+        }\n+        break;\n+      case T_INT:\n+      case T_FLOAT:\n+      case T_DOUBLE:\n+        if (value_object_count == 0) {\n+          SigEntry::add_entry(_sig, bt);\n+        }\n+        SigEntry::add_entry(_sig_cc, bt);\n+        SigEntry::add_entry(_sig_cc_ro, bt);\n+        break;\n+      case T_LONG:\n+        long_prev = true;\n+        break;\n+      case T_BOOLEAN:\n+      case T_CHAR:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_OBJECT:\n+      case T_ARRAY:\n+        assert(value_object_count > 0 && !is_receiver, \"must be value object field\");\n+        SigEntry::add_entry(_sig_cc, bt);\n+        SigEntry::add_entry(_sig_cc_ro, bt);\n+        break;\n+      case T_METADATA:\n+        assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+        value_object_count++;\n+        has_scalarized_arguments = true;\n+        SigEntry::add_entry(_sig, T_OBJECT);\n+        SigEntry::add_entry(_sig_cc, T_METADATA);\n+        SigEntry::add_entry(_sig_cc_ro, T_METADATA);\n+        break;\n+      default: {\n+        fatal(\"Unexpected BasicType: %s\", basictype_to_str(bt));\n+      }\n+    }\n+    prev_bt = bt;\n+    is_receiver = false;\n+  });\n+\n+  if (long_prev) {\n+    \/\/ If previous bt was T_LONG and we reached the end of the signature, we know that it must be a T_OBJECT.\n+    SigEntry::add_entry(_sig, T_OBJECT);\n+    SigEntry::add_entry(_sig_cc, T_OBJECT);\n+    SigEntry::add_entry(_sig_cc_ro, T_OBJECT);\n+  }\n+  assert(value_object_count == 0, \"invalid value object count\");\n+\n+  _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig->length());\n+  _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);\n+\n+  \/\/ Compute the scalarized calling conventions if there are scalarized inline types in the signature\n+  if (has_scalarized_arguments) {\n+    _regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc->length());\n+    _args_on_stack_cc = SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);\n+\n+    _regs_cc_ro = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc_ro->length());\n+    _args_on_stack_cc_ro = SharedRuntime::java_calling_convention(_sig_cc_ro, _regs_cc_ro);\n+\n+    _c1_needs_stack_repair = (_args_on_stack_cc < _args_on_stack) || (_args_on_stack_cc_ro < _args_on_stack);\n+    _c2_needs_stack_repair = (_args_on_stack_cc > _args_on_stack) || (_args_on_stack_cc > _args_on_stack_cc_ro);\n+  } else {\n+    \/\/ No scalarized args\n+    _sig_cc = _sig;\n+    _regs_cc = _regs;\n+    _args_on_stack_cc = _args_on_stack;\n+\n+    _sig_cc_ro = _sig;\n+    _regs_cc_ro = _regs;\n+    _args_on_stack_cc_ro = _args_on_stack;\n+  }\n+\n+#ifdef ASSERT\n+  {\n+    AdapterFingerPrint* compare_fp = AdapterFingerPrint::allocate(_sig_cc, _has_inline_recv);\n+    assert(fingerprint->equals(compare_fp), \"sanity check\");\n+    AdapterFingerPrint::deallocate(compare_fp);\n+  }\n+#endif\n+}\n+\n+const char* AdapterHandlerEntry::_entry_names[] = {\n+  \"i2c\", \"c2i\", \"c2i_unverified\", \"c2i_no_clinit_check\"\n+};\n+\n+#ifdef ASSERT\n+void AdapterHandlerLibrary::verify_adapter_sharing(CompiledEntrySignature& ces, AdapterHandlerEntry* cached_entry) {\n+  AdapterBlob* comparison_blob = nullptr;\n+  AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, ces, false, true);\n+  assert(comparison_blob == nullptr, \"no blob should be created when creating an adapter for comparison\");\n+  assert(comparison_entry->compare_code(cached_entry), \"code must match\");\n+  \/\/ Release the one just created\n+  AdapterHandlerEntry::deallocate(comparison_entry);\n+}\n+#endif \/* ASSERT*\/\n+\n@@ -2935,1 +3133,1 @@\n-  AdapterBlob* new_adapter = nullptr;\n+  AdapterBlob* adapter_blob = nullptr;\n@@ -2959,4 +3157,4 @@\n-      entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(nullptr),\n-                                               SharedRuntime::throw_AbstractMethodError_entry(),\n-                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n-                                               wrong_method_abstract, wrong_method_abstract);\n+      entry = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(nullptr));\n+      entry->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n+                              wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n+                              wrong_method_abstract, wrong_method_abstract);\n@@ -2973,0 +3171,1 @@\n+      assert(entry->is_linked(), \"AdapterHandlerEntry must have been linked\");\n@@ -2974,7 +3173,2 @@\n-      if (VerifyAdapterSharing) {\n-        AdapterBlob* comparison_blob = nullptr;\n-        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, ces, false);\n-        assert(comparison_blob == nullptr, \"no blob should be created when creating an adapter for comparison\");\n-        assert(comparison_entry->compare_code(entry), \"code must match\");\n-        \/\/ Release the one just created and return the original\n-        delete comparison_entry;\n+      if (!entry->is_shared() && VerifyAdapterSharing) {\n+        verify_adapter_sharing(ces, entry);\n@@ -2983,1 +3177,2 @@\n-      return entry;\n+    } else {\n+      entry = create_adapter(adapter_blob, ces, \/* allocate_code_blob *\/ true);\n@@ -2985,2 +3180,0 @@\n-\n-    entry = create_adapter(new_adapter, ces, \/* allocate_code_blob *\/ true);\n@@ -2990,2 +3183,2 @@\n-  if (new_adapter != nullptr) {\n-    post_adapter_creation(new_adapter, entry);\n+  if (adapter_blob != nullptr) {\n+    post_adapter_creation(adapter_blob, entry);\n@@ -2996,3 +3189,43 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& new_adapter,\n-                                                           CompiledEntrySignature& ces,\n-                                                           bool allocate_code_blob) {\n+AdapterBlob* AdapterHandlerLibrary::lookup_aot_cache(AdapterHandlerEntry* handler) {\n+  ResourceMark rm;\n+  const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n+  const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+  int offsets[AdapterHandlerEntry::ENTRIES_COUNT];\n+\n+  AdapterBlob* adapter_blob = nullptr;\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::Adapter, id, name, AdapterHandlerEntry::ENTRIES_COUNT, offsets);\n+  if (blob != nullptr) {\n+    adapter_blob = blob->as_adapter_blob();\n+    address i2c_entry = adapter_blob->content_begin();\n+    assert(offsets[0] == 0, \"sanity check\");\n+    handler->set_entry_points(i2c_entry, i2c_entry + offsets[1], i2c_entry + offsets[2], i2c_entry + offsets[3],\n+                              i2c_entry + offsets[4], i2c_entry + offsets[5], i2c_entry + offsets[6]);\n+  }\n+  return adapter_blob;\n+}\n+\n+#ifndef PRODUCT\n+void AdapterHandlerLibrary::print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler, AdapterBlob* adapter_blob) {\n+  ttyLocker ttyl;\n+  ResourceMark rm;\n+  int insts_size = adapter_blob->code_size();\n+  handler->print_adapter_on(tty);\n+  st->print_cr(\"i2c argument handler for: %s %s (%d bytes generated)\",\n+                handler->fingerprint()->as_basic_args_string(),\n+                handler->fingerprint()->as_string(), insts_size);\n+  st->print_cr(\"c2i argument handler starts at \" INTPTR_FORMAT, p2i(handler->get_c2i_entry()));\n+  if (Verbose || PrintStubCode) {\n+    address first_pc = handler->base_address();\n+    if (first_pc != nullptr) {\n+      Disassembler::decode(first_pc, first_pc + insts_size, st, &adapter_blob->asm_remarks());\n+      st->cr();\n+    }\n+  }\n+}\n+#endif \/\/ PRODUCT\n+\n+bool AdapterHandlerLibrary::generate_adapter_code(AdapterBlob*& adapter_blob,\n+                                                  AdapterHandlerEntry* handler,\n+                                                  CompiledEntrySignature& ces,\n+                                                  bool allocate_code_blob,\n+                                                  bool is_transient) {\n@@ -3003,6 +3236,0 @@\n-  \/\/ StubRoutines::_final_stubs_code is initialized after this function can be called. As a result,\n-  \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated prior\n-  \/\/ to all StubRoutines::_final_stubs_code being set. Checks refer to runtime range checks generated\n-  \/\/ in an I2C stub that ensure that an I2C stub is called from an interpreter frame or stubs.\n-  bool contains_all_checks = StubRoutines::final_stubs_code() != nullptr;\n-\n@@ -3013,16 +3240,15 @@\n-                                          sizeof(buffer_locs)\/sizeof(relocInfo));\n-\n-  \/\/ Make a C heap allocated version of the fingerprint to store in the adapter\n-  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(ces.sig_cc(), ces.has_inline_recv());\n-  MacroAssembler _masm(&buffer);\n-  AdapterHandlerEntry* entry = SharedRuntime::generate_i2c2i_adapters(&_masm,\n-                                                ces.args_on_stack(),\n-                                                ces.sig(),\n-                                                ces.regs(),\n-                                                ces.sig_cc(),\n-                                                ces.regs_cc(),\n-                                                ces.sig_cc_ro(),\n-                                                ces.regs_cc_ro(),\n-                                                fingerprint,\n-                                                new_adapter,\n-                                                allocate_code_blob);\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+  MacroAssembler masm(&buffer);\n+\n+  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n+  SharedRuntime::generate_i2c2i_adapters(&masm,\n+                                         ces.args_on_stack(),\n+                                         ces.sig(),\n+                                         ces.regs(),\n+                                         ces.sig_cc(),\n+                                         ces.regs_cc(),\n+                                         ces.sig_cc_ro(),\n+                                         ces.regs_cc_ro(),\n+                                         handler,\n+                                         adapter_blob,\n+                                         allocate_code_blob);\n@@ -3034,1 +3260,1 @@\n-    entry->set_sig_cc(heap_sig);\n+    handler->set_sig_cc(heap_sig);\n@@ -3036,1 +3262,0 @@\n-\n@@ -3039,3 +3264,3 @@\n-    entry->save_code(buf->code_begin(), buffer.insts_size());\n-    if (!allocate_code_blob) {\n-      return entry;\n+    handler->save_code(buf->code_begin(), buffer.insts_size());\n+    if (is_transient) {\n+      return true;\n@@ -3046,2 +3271,1 @@\n-  NOT_PRODUCT(int insts_size = buffer.insts_size());\n-  if (new_adapter == nullptr) {\n+  if (adapter_blob == nullptr) {\n@@ -3051,1 +3275,1 @@\n-    return nullptr;\n+    return false;\n@@ -3053,1 +3277,18 @@\n-  entry->relocate(new_adapter->content_begin());\n+  if (!is_transient && AOTCodeCache::is_dumping_adapter()) {\n+    \/\/ try to save generated code\n+    const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n+    const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+    int entry_offset[AdapterHandlerEntry::ENTRIES_COUNT];\n+    assert(AdapterHandlerEntry::ENTRIES_COUNT == 7, \"sanity\");\n+    address i2c_entry = handler->get_i2c_entry();\n+    entry_offset[0] = 0; \/\/ i2c_entry offset\n+    entry_offset[1] = handler->get_c2i_entry() - i2c_entry;\n+    entry_offset[2] = handler->get_c2i_inline_entry() - i2c_entry;\n+    entry_offset[3] = handler->get_c2i_inline_ro_entry() - i2c_entry;\n+    entry_offset[4] = handler->get_c2i_unverified_entry() - i2c_entry;\n+    entry_offset[5] = handler->get_c2i_unverified_inline_entry() - i2c_entry;\n+    entry_offset[6] = handler->get_c2i_no_clinit_check_entry() - i2c_entry;\n+    bool success = AOTCodeCache::store_code_blob(*adapter_blob, AOTCodeEntry::Adapter, id, name, AdapterHandlerEntry::ENTRIES_COUNT, entry_offset);\n+    assert(success || !AOTCodeCache::is_dumping_adapter(), \"caching of adapter must be disabled\");\n+  }\n+  handler->relocate(adapter_blob->content_begin());\n@@ -3057,12 +3298,66 @@\n-    ttyLocker ttyl;\n-    entry->print_adapter_on(tty);\n-    tty->print_cr(\"i2c argument handler #%d for: %s %s (%d bytes generated)\",\n-                  _adapter_handler_table->number_of_entries(), fingerprint->as_basic_args_string(),\n-                  fingerprint->as_string(), insts_size);\n-    tty->print_cr(\"c2i argument handler starts at \" INTPTR_FORMAT, p2i(entry->get_c2i_entry()));\n-    if (Verbose || PrintStubCode) {\n-      address first_pc = entry->base_address();\n-      if (first_pc != nullptr) {\n-        Disassembler::decode(first_pc, first_pc + insts_size, tty\n-                             NOT_PRODUCT(COMMA &new_adapter->asm_remarks()));\n-        tty->cr();\n+    print_adapter_handler_info(tty, handler, adapter_blob);\n+  }\n+#endif\n+  return true;\n+}\n+\n+AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& adapter_blob,\n+                                                           CompiledEntrySignature& ces,\n+                                                           bool allocate_code_blob,\n+                                                           bool is_transient) {\n+  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(ces.sig_cc(), ces.has_inline_recv());\n+#ifdef ASSERT\n+  \/\/ Verify that we can successfully restore the compiled entry signature object.\n+  CompiledEntrySignature ces_verify;\n+  ces_verify.initialize_from_fingerprint(fp);\n+#endif\n+  AdapterHandlerEntry* handler = AdapterHandlerLibrary::new_entry(fp);\n+  if (!generate_adapter_code(adapter_blob, handler, ces, allocate_code_blob, is_transient)) {\n+    AdapterHandlerEntry::deallocate(handler);\n+    return nullptr;\n+  }\n+  if (!is_transient) {\n+    assert_lock_strong(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table->put(fp, handler);\n+  }\n+  return handler;\n+}\n+\n+#if INCLUDE_CDS\n+void AdapterHandlerEntry::remove_unshareable_info() {\n+#ifdef ASSERT\n+   _saved_code = nullptr;\n+   _saved_code_length = 0;\n+#endif \/\/ ASSERT\n+  set_entry_points(nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, false);\n+}\n+\n+class CopyAdapterTableToArchive : StackObj {\n+private:\n+  CompactHashtableWriter* _writer;\n+  ArchiveBuilder* _builder;\n+public:\n+  CopyAdapterTableToArchive(CompactHashtableWriter* writer) : _writer(writer),\n+                                                             _builder(ArchiveBuilder::current())\n+  {}\n+\n+  bool do_entry(AdapterFingerPrint* fp, AdapterHandlerEntry* entry) {\n+    LogStreamHandle(Trace, cds) lsh;\n+    if (ArchiveBuilder::current()->has_been_archived((address)entry)) {\n+      assert(ArchiveBuilder::current()->has_been_archived((address)fp), \"must be\");\n+      AdapterFingerPrint* buffered_fp = ArchiveBuilder::current()->get_buffered_addr(fp);\n+      assert(buffered_fp != nullptr,\"sanity check\");\n+      AdapterHandlerEntry* buffered_entry = ArchiveBuilder::current()->get_buffered_addr(entry);\n+      assert(buffered_entry != nullptr,\"sanity check\");\n+\n+      uint hash = fp->compute_hash();\n+      u4 delta = _builder->buffer_to_offset_u4((address)buffered_entry);\n+      _writer->add(hash, delta);\n+      if (lsh.is_enabled()) {\n+        address fp_runtime_addr = (address)buffered_fp + ArchiveBuilder::current()->buffer_to_requested_delta();\n+        address entry_runtime_addr = (address)buffered_entry + ArchiveBuilder::current()->buffer_to_requested_delta();\n+        log_trace(cds)(\"Added fp=%p (%s), entry=%p to the archived adater table\", buffered_fp, buffered_fp->as_basic_args_string(), buffered_entry);\n+      }\n+    } else {\n+      if (lsh.is_enabled()) {\n+        log_trace(cds)(\"Skipping adapter handler %p (fp=%s) as it is not archived\", entry, fp->as_basic_args_string());\n@@ -3071,0 +3366,27 @@\n+    return true;\n+  }\n+};\n+\n+void AdapterHandlerLibrary::dump_aot_adapter_table() {\n+  CompactHashtableStats stats;\n+  CompactHashtableWriter writer(_adapter_handler_table->number_of_entries(), &stats);\n+  CopyAdapterTableToArchive copy(&writer);\n+  _adapter_handler_table->iterate(&copy);\n+  writer.dump(&_aot_adapter_handler_table, \"archived adapter table\");\n+}\n+\n+void AdapterHandlerLibrary::serialize_shared_table_header(SerializeClosure* soc) {\n+  _aot_adapter_handler_table.serialize_header(soc);\n+}\n+\n+AdapterBlob* AdapterHandlerLibrary::link_aot_adapter_handler(AdapterHandlerEntry* handler) {\n+#ifdef ASSERT\n+  if (TestAOTAdapterLinkFailure) {\n+    return nullptr;\n+  }\n+#endif\n+  AdapterBlob* blob = lookup_aot_cache(handler);\n+#ifndef PRODUCT\n+  \/\/ debugging support\n+  if ((blob != nullptr) && (PrintAdapterHandlers || PrintStubCode)) {\n+    print_adapter_handler_info(tty, handler, blob);\n@@ -3073,0 +3395,2 @@\n+  return blob;\n+}\n@@ -3074,5 +3398,28 @@\n-  \/\/ Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)\n-  \/\/ The checks are inserted only if -XX:+VerifyAdapterCalls is specified.\n-  if (contains_all_checks || !VerifyAdapterCalls) {\n-    assert_lock_strong(AdapterHandlerLibrary_lock);\n-    _adapter_handler_table->put(fingerprint, entry);\n+\/\/ This method is used during production run to link archived adapters (stored in AOT Cache)\n+\/\/ to their code in AOT Code Cache\n+void AdapterHandlerEntry::link() {\n+  AdapterBlob* adapter_blob = nullptr;\n+  ResourceMark rm;\n+  assert(_fingerprint != nullptr, \"_fingerprint must not be null\");\n+  bool generate_code = false;\n+  \/\/ Generate code only if AOTCodeCache is not available, or\n+  \/\/ caching adapters is disabled, or we fail to link\n+  \/\/ the AdapterHandlerEntry to its code in the AOTCodeCache\n+  if (AOTCodeCache::is_using_adapter()) {\n+    adapter_blob = AdapterHandlerLibrary::link_aot_adapter_handler(this);\n+    if (adapter_blob == nullptr) {\n+      log_warning(cds)(\"Failed to link AdapterHandlerEntry (fp=%s) to its code in the AOT code cache\", _fingerprint->as_basic_args_string());\n+      generate_code = true;\n+    }\n+  } else {\n+    generate_code = true;\n+  }\n+  if (generate_code) {\n+    CompiledEntrySignature ces;\n+    ces.initialize_from_fingerprint(_fingerprint);\n+    if (!AdapterHandlerLibrary::generate_adapter_code(adapter_blob, this, ces, true, false)) {\n+      \/\/ Don't throw exceptions during VM initialization because java.lang.* classes\n+      \/\/ might not have been initialized, causing problems when constructing the\n+      \/\/ Java exception object.\n+      vm_exit_during_initialization(\"Out of space in CodeCache for adapters\");\n+    }\n@@ -3080,1 +3427,5 @@\n-  return entry;\n+  \/\/ Outside of the lock\n+  if (adapter_blob != nullptr) {\n+    post_adapter_creation(adapter_blob, this);\n+  }\n+  assert(_linked, \"AdapterHandlerEntry must now be linked\");\n@@ -3083,0 +3434,53 @@\n+void AdapterHandlerLibrary::link_aot_adapters() {\n+  _aot_adapter_handler_table.iterate([](AdapterHandlerEntry* entry) {\n+    assert(!entry->is_linked(), \"AdapterHandlerEntry is already linked!\");\n+    entry->link();\n+  });\n+}\n+\n+\/\/ This method is called during production run to lookup simple adapters\n+\/\/ in the archived adapter handler table\n+void AdapterHandlerLibrary::lookup_simple_adapters() {\n+  assert(!_aot_adapter_handler_table.empty(), \"archived adapter handler table is empty\");\n+\n+  MutexLocker mu(AdapterHandlerLibrary_lock);\n+  ResourceMark rm;\n+  CompiledEntrySignature no_args;\n+  no_args.compute_calling_conventions();\n+  _no_arg_handler = lookup(no_args.sig_cc(), no_args.has_inline_recv());\n+\n+  CompiledEntrySignature obj_args;\n+  SigEntry::add_entry(obj_args.sig(), T_OBJECT);\n+  obj_args.compute_calling_conventions();\n+  _obj_arg_handler = lookup(obj_args.sig_cc(), obj_args.has_inline_recv());\n+\n+  CompiledEntrySignature int_args;\n+  SigEntry::add_entry(int_args.sig(), T_INT);\n+  int_args.compute_calling_conventions();\n+  _int_arg_handler = lookup(int_args.sig_cc(), int_args.has_inline_recv());\n+\n+  CompiledEntrySignature obj_int_args;\n+  SigEntry::add_entry(obj_int_args.sig(), T_OBJECT);\n+  SigEntry::add_entry(obj_int_args.sig(), T_INT);\n+  obj_int_args.compute_calling_conventions();\n+  _obj_int_arg_handler = lookup(obj_int_args.sig_cc(), obj_int_args.has_inline_recv());\n+\n+  CompiledEntrySignature obj_obj_args;\n+  SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT);\n+  SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT);\n+  obj_obj_args.compute_calling_conventions();\n+  _obj_obj_arg_handler = lookup(obj_obj_args.sig_cc(), obj_obj_args.has_inline_recv());\n+\n+  assert(_no_arg_handler != nullptr &&\n+         _obj_arg_handler != nullptr &&\n+         _int_arg_handler != nullptr &&\n+         _obj_int_arg_handler != nullptr &&\n+         _obj_obj_arg_handler != nullptr, \"Initial adapters not found in archived adapter handler table\");\n+  assert(_no_arg_handler->is_linked() &&\n+         _obj_arg_handler->is_linked() &&\n+         _int_arg_handler->is_linked() &&\n+         _obj_int_arg_handler->is_linked() &&\n+         _obj_obj_arg_handler->is_linked(), \"Initial adapters not in linked state\");\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -3116,0 +3520,8 @@\n+void AdapterHandlerEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n+  LogStreamHandle(Trace, cds) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Iter(AdapterHandlerEntry): %p(%s)\", this, _fingerprint->as_basic_args_string());\n+    lsh.cr();\n+  }\n+  it->push(&_fingerprint);\n+}\n@@ -3118,1 +3530,4 @@\n-  delete _fingerprint;\n+  if (_fingerprint != nullptr) {\n+    AdapterFingerPrint::deallocate(_fingerprint);\n+    _fingerprint = nullptr;\n+  }\n@@ -3125,0 +3540,1 @@\n+  FreeHeap(this);\n@@ -3439,2 +3855,3 @@\n-  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n-    return (found = (b == CodeCache::find_blob(a->get_i2c_entry())));\n+#if INCLUDE_CDS\n+  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+    return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n@@ -3442,2 +3859,9 @@\n-  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n-  _adapter_handler_table->iterate(findblob);\n+  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+#endif \/\/ INCLUDE_CDS\n+  if (!found) {\n+    auto findblob_runtime_table = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+      return (found = (b == CodeCache::find_blob(a->get_i2c_entry())));\n+    };\n+    assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table->iterate(findblob_runtime_table);\n+  }\n@@ -3447,0 +3871,9 @@\n+const char* AdapterHandlerLibrary::name(AdapterFingerPrint* fingerprint) {\n+  return fingerprint->as_basic_args_string();\n+}\n+\n+uint32_t AdapterHandlerLibrary::id(AdapterFingerPrint* fingerprint) {\n+  unsigned int hash = fingerprint->compute_hash();\n+  return hash;\n+}\n+\n@@ -3449,2 +3882,3 @@\n-  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n-    if (b == CodeCache::find_blob(a->get_i2c_entry())) {\n+#if INCLUDE_CDS\n+  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+    if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n@@ -3453,1 +3887,1 @@\n-      a->print_adapter_on(st);\n+      handler->print_adapter_on(st);\n@@ -3457,0 +3891,1 @@\n+\n@@ -3459,2 +3894,16 @@\n-  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n-  _adapter_handler_table->iterate(findblob);\n+  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+#endif \/\/ INCLUDE_CDS\n+  if (!found) {\n+    auto findblob_runtime_table = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+      if (b == CodeCache::find_blob(a->get_i2c_entry())) {\n+        found = true;\n+        st->print(\"Adapter for signature: \");\n+        a->print_adapter_on(st);\n+        return true;\n+      } else {\n+        return false; \/\/ keep looking\n+      }\n+    };\n+    assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table->iterate(findblob_runtime_table);\n+  }\n@@ -3498,0 +3947,7 @@\n+bool AdapterHandlerLibrary::is_abstract_method_adapter(AdapterHandlerEntry* entry) {\n+  if (entry == _abstract_method_handler) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":680,"deletions":224,"binary":false,"changes":904,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/compactHashtable.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"memory\/metaspaceClosure.hpp\"\n@@ -120,0 +122,1 @@\n+  static void init_adapter_library();\n@@ -480,11 +483,11 @@\n-  static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                      int comp_args_on_stack,\n-                                                      const GrowableArray<SigEntry>* sig,\n-                                                      const VMRegPair* regs,\n-                                                      const GrowableArray<SigEntry>* sig_cc,\n-                                                      const VMRegPair* regs_cc,\n-                                                      const GrowableArray<SigEntry>* sig_cc_ro,\n-                                                      const VMRegPair* regs_cc_ro,\n-                                                      AdapterFingerPrint* fingerprint,\n-                                                      AdapterBlob*& new_adapter,\n-                                                      bool allocate_code_blob);\n+  static void generate_i2c2i_adapters(MacroAssembler* _masm,\n+                                      int total_args_passed,\n+                                      const GrowableArray<SigEntry>* sig,\n+                                      const VMRegPair* regs,\n+                                      const GrowableArray<SigEntry>* sig_cc,\n+                                      const VMRegPair* regs_cc,\n+                                      const GrowableArray<SigEntry>* sig_cc_ro,\n+                                      const VMRegPair* regs_cc_ro,\n+                                      AdapterHandlerEntry* handler,\n+                                      AdapterBlob*& new_adapter,\n+                                      bool allocate_code_blob);\n@@ -693,1 +696,1 @@\n-class AdapterHandlerEntry : public CHeapObj<mtCode> {\n+class AdapterHandlerEntry : public MetaspaceObj {\n@@ -696,0 +699,3 @@\n+ public:\n+  static const int ENTRIES_COUNT = 7;\n+\n@@ -705,0 +711,3 @@\n+  bool    _linked;\n+\n+  static const char *_entry_names[];\n@@ -716,4 +725,1 @@\n-  AdapterHandlerEntry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,\n-                      address c2i_inline_entry, address c2i_inline_ro_entry,\n-                      address c2i_unverified_entry, address c2i_unverified_inline_entry,\n-                      address c2i_no_clinit_check_entry) :\n+  AdapterHandlerEntry(AdapterFingerPrint* fingerprint) :\n@@ -721,7 +727,8 @@\n-    _i2c_entry(i2c_entry),\n-    _c2i_entry(c2i_entry),\n-    _c2i_inline_entry(c2i_inline_entry),\n-    _c2i_inline_ro_entry(c2i_inline_ro_entry),\n-    _c2i_unverified_entry(c2i_unverified_entry),\n-    _c2i_unverified_inline_entry(c2i_unverified_inline_entry),\n-    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry),\n+    _i2c_entry(nullptr),\n+    _c2i_entry(nullptr),\n+    _c2i_inline_entry(nullptr),\n+    _c2i_inline_ro_entry(nullptr),\n+    _c2i_unverified_entry(nullptr),\n+    _c2i_unverified_inline_entry(nullptr),\n+    _c2i_no_clinit_check_entry(nullptr),\n+    _linked(false),\n@@ -730,1 +737,2 @@\n-    , _saved_code_length(0)\n+    , _saved_code(nullptr),\n+    _saved_code_length(0)\n@@ -736,0 +744,9 @@\n+  \/\/ Allocate on CHeap instead of metaspace (see JDK-8331086).\n+  \/\/ Dummy argument is used to avoid C++ warning about using\n+  \/\/ deleted opearator MetaspaceObj::delete().\n+  void* operator new(size_t size, size_t dummy) throw() {\n+    void* p = AllocateHeap(size, mtCode);\n+    memset(p, 0, size);\n+    return p;\n+  }\n+\n@@ -737,0 +754,22 @@\n+  static AdapterHandlerEntry* allocate(AdapterFingerPrint* fingerprint) {\n+    return new(0) AdapterHandlerEntry(fingerprint);\n+  }\n+\n+  static void deallocate(AdapterHandlerEntry *handler) {\n+    handler->~AdapterHandlerEntry();\n+  }\n+\n+  void set_entry_points(address i2c_entry, address c2i_entry, address c2i_inline_entry, address c2i_inline_ro_entry,\n+                        address c2i_unverified_entry, address c2i_unverified_inline_entry,\n+                        address c2i_no_clinit_check_entry = nullptr,\n+                        bool linked = true) {\n+    _i2c_entry = i2c_entry;\n+    _c2i_entry = c2i_entry;\n+    _c2i_inline_entry = c2i_inline_entry;\n+    _c2i_inline_ro_entry = c2i_inline_ro_entry;\n+    _c2i_unverified_entry = c2i_unverified_entry;\n+    _c2i_unverified_inline_entry = c2i_unverified_inline_entry;\n+    _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;\n+    _linked = linked;\n+  }\n+\n@@ -745,0 +784,6 @@\n+  static const char* entry_name(int i) {\n+    assert(i >=0 && i < ENTRIES_COUNT, \"entry id out of range\");\n+    return _entry_names[i];\n+  }\n+\n+  bool is_linked() const { return _linked; }\n@@ -762,0 +807,7 @@\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  int size() const {return (int)heap_word_size(sizeof(AdapterHandlerEntry)); }\n+  MetaspaceObj::Type type() const { return AdapterHandlerEntryType; }\n+\n+  void remove_unshareable_info() NOT_CDS_RETURN;\n+  void link() NOT_CDS_RETURN;\n@@ -764,0 +816,4 @@\n+#if INCLUDE_CDS\n+class ArchivedAdapterTable;\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -776,0 +832,3 @@\n+#if INCLUDE_CDS\n+  static ArchivedAdapterTable _aot_adapter_handler_table;\n+#endif \/\/ INCLUDE_CDS\n@@ -779,0 +838,2 @@\n+  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n+  static AdapterBlob* lookup_aot_cache(AdapterHandlerEntry* handler);\n@@ -781,2 +842,7 @@\n-                                             bool allocate_code_blob);\n-  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n+                                             bool allocate_code_blob,\n+                                             bool is_transient = false);\n+  static void create_abstract_method_handler();\n+  static void lookup_simple_adapters() NOT_CDS_RETURN;\n+#ifndef PRODUCT\n+  static void print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler, AdapterBlob* adapter_blob);\n+#endif \/\/ PRODUCT\n@@ -785,3 +851,1 @@\n-  static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,\n-                                        address i2c_entry, address c2i_entry, address c2i_inline_entry, address c2i_inline_ro_entry,\n-                                        address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry = nullptr);\n+  static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint);\n@@ -790,0 +854,10 @@\n+  static AdapterHandlerEntry* lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false);\n+  static bool generate_adapter_code(AdapterBlob*& adapter_blob,\n+                                    AdapterHandlerEntry* handler,\n+                                    CompiledEntrySignature& ces,\n+                                    bool allocate_code_blob,\n+                                    bool is_transient);\n+\n+#ifdef ASSERT\n+  static void verify_adapter_sharing(CompiledEntrySignature& ces, AdapterHandlerEntry* cached_entry);\n+#endif \/\/ ASSERT\n@@ -794,0 +868,2 @@\n+  static const char* name(AdapterFingerPrint* fingerprint);\n+  static uint32_t id(AdapterFingerPrint* fingerprint);\n@@ -798,0 +874,6 @@\n+  static bool is_abstract_method_adapter(AdapterHandlerEntry* adapter);\n+\n+  static AdapterBlob* link_aot_adapter_handler(AdapterHandlerEntry* handler) NOT_CDS_RETURN_(nullptr);\n+  static void dump_aot_adapter_table() NOT_CDS_RETURN;\n+  static void serialize_shared_table_header(SerializeClosure* soc) NOT_CDS_RETURN;\n+  static void link_aot_adapters() NOT_CDS_RETURN;\n@@ -857,0 +939,1 @@\n+  void initialize_from_fingerprint(AdapterFingerPrint* fingerprint);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":112,"deletions":29,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -1464,1 +1464,1 @@\n-        return AccessFlag.maskToAccessFlags(accessFlags, location, cffv);\n+        return getReflectionFactory().parseAccessFlags(accessFlags, location, this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2036,0 +2036,3 @@\n+            public int classFileVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.Collections;\n@@ -43,1 +42,0 @@\n-import java.util.WeakHashMap;\n@@ -59,0 +57,1 @@\n+import jdk.internal.util.ReferencedKeySet;\n@@ -204,1 +203,1 @@\n-    private static final Set<Class<?>> WRAPPER_TYPES = Collections.newSetFromMap(new WeakHashMap<>());\n+    private static final Set<Class<?>> WRAPPER_TYPES = ReferencedKeySet.create(false, ReferencedKeySet.concurrentHashMapSupplier());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-     *     <td>{@code FT f;}<\/td><td>{@code (T) this.f;}<\/td>\n+     *     <td>{@code FT f;}<\/td><td>{@code (FT) this.f;}<\/td>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-     * appropriate for the location in question}\n+     * appropriate for the location in the current class file format version}\n@@ -412,1 +412,2 @@\n-     * positions not supported for the location in question\n+     * positions not defined for the location in the current class file format\n+     * @throws NullPointerException if {@code location} is {@code null}\n@@ -415,4 +416,2 @@\n-        var definition = findDefinition(location);\n-        int flagsMask = location.flagsMask();\n-        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n-        int unmatchedMask = mask & (~parsingMask);\n+        var definition = findDefinition(location);  \/\/ null checks location\n+        int unmatchedMask = mask & (~location.flagsMask());\n@@ -429,1 +428,1 @@\n-     * appropriate for the location in question}\n+     * appropriate for the location in the given class file format version}\n@@ -433,1 +432,1 @@\n-     * @param cffv the class file format version\n+     * @param cffv the class file format to interpret mask value\n@@ -435,3 +434,3 @@\n-     * positions not supported for the location in question\n-     *\n-     * @since Valhalla\n+     * positions not defined for the location in the given class file format\n+     * @throws NullPointerException if {@code location} or {@code cffv} is {@code null}\n+     * @since 25\n@@ -439,6 +438,3 @@\n-    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location,\n-                                                    ClassFileFormatVersion cffv) {\n-        var definition = findDefinition(location);\n-        int flagsMask = location.flagsMask(cffv);\n-        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n-        int unmatchedMask = mask & (~parsingMask);\n+    public static Set<AccessFlag> maskToAccessFlags(int mask, Location location, ClassFileFormatVersion cffv) {\n+        var definition = findDefinition(location);  \/\/ null checks location\n+        int unmatchedMask = mask & (~location.flagsMask(cffv));  \/\/ null checks cffv\n@@ -448,1 +444,2 @@\n-                    \" for location \" + location);\n+                    \" for location \" + location +\n+                    \" for class file format \" + cffv);\n@@ -535,1 +532,1 @@\n-        INNER_CLASS(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | (PreviewFeatures.isEnabled() ? ACC_IDENTITY : 0) |\n+        INNER_CLASS(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | (PreviewFeatures.isEnabled() ? ACC_IDENTITY : ACC_SUPER) |\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,5 +225,3 @@\n-        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n-        var cffv = ClassFileFormatVersion.fromMajor(major);\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                                            AccessFlag.Location.METHOD,\n-                                            cffv);\n+        return reflectionFactory.parseAccessFlags(getModifiers(),\n+                                                  AccessFlag.Location.METHOD,\n+                                                  getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,1 @@\n-        int major = SharedSecrets.getJavaLangAccess().classFileFormatVersion(getDeclaringClass()) & 0xffff;\n-        var cffv = ClassFileFormatVersion.fromMajor(major);\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.FIELD, cffv);\n+        return reflectionFactory.parseAccessFlags(getModifiers(), AccessFlag.Location.FIELD, getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,0 +123,6 @@\n+    \/**\n+     * Returns the big-endian packed minor-major version of the class file\n+     * of this class.\n+     *\/\n+    int classFileVersion(Class<?> clazz);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-                currentFrame.pushStack(cp.entryByIndex(index, ConstantDynamicEntry.class).asSymbol().constantType());\n+                currentFrame.pushStack(cp.entryByIndex(index, ConstantDynamicEntry.class).typeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-        @JEP(number=495, title=\"Simple Source Files and Instance Main Methods\", status=\"Fourth Preview\")\n-        IMPLICIT_CLASSES,\n+        IMPLICIT_CLASSES, \/\/to be removed when boot JDK is 25\n@@ -81,2 +80,1 @@\n-        @JEP(number=494, title=\"Module Import Declarations\", status=\"Second Preview\")\n-        MODULE_IMPORTS,\n+        MODULE_IMPORTS, \/\/remove when the boot JDK is JDK 25\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -37,7 +38,1 @@\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Executable;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Proxy;\n+import java.lang.reflect.*;\n@@ -531,0 +526,25 @@\n+    public final Set<AccessFlag> parseAccessFlags(int mask, AccessFlag.Location location, Class<?> classFile) {\n+        var cffv = classFileFormatVersion(classFile);\n+        return cffv == null ?\n+                AccessFlag.maskToAccessFlags(mask, location) :\n+                AccessFlag.maskToAccessFlags(mask, location, cffv);\n+    }\n+\n+    private final ClassFileFormatVersion classFileFormatVersion(Class<?> cl) {\n+        int raw = SharedSecrets.getJavaLangAccess().classFileVersion(cl);\n+\n+        int major = raw & 0xFFFF;\n+        int minor = raw >>> Character.SIZE;\n+\n+        assert VM.isSupportedClassFileVersion(major, minor) : major + \".\" + minor;\n+\n+        if (major >= ClassFile.JAVA_12_VERSION) {\n+            if (minor == 0)\n+                return ClassFileFormatVersion.fromMajor(raw);\n+            return null; \/\/ preview or old preview, fallback to default handling\n+        } else if (major == ClassFile.JAVA_1_VERSION) {\n+            return minor < 3 ? ClassFileFormatVersion.RELEASE_0 : ClassFileFormatVersion.RELEASE_1;\n+        }\n+        return ClassFileFormatVersion.fromMajor(major);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -156,3 +156,1 @@\n-                .anyMatch(ed -> ed.modules.contains(m)) ||\n-               \/\/the specification lists the java.se module as participating in preview:\n-               m.name == names.java_se;\n+                .anyMatch(ed -> ed.modules.contains(m));\n@@ -231,1 +229,0 @@\n-            case IMPLICIT_CLASSES -> true;\n@@ -235,2 +232,0 @@\n-            case MODULE_IMPORTS -> true;\n-            case JAVA_BASE_TRANSITIVE -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,1 +278,1 @@\n-        IMPLICIT_CLASSES(JDK21, Fragments.FeatureImplicitClasses, DiagKind.PLURAL),\n+        IMPLICIT_CLASSES(JDK25, Fragments.FeatureImplicitClasses, DiagKind.PLURAL),\n@@ -284,2 +284,2 @@\n-        MODULE_IMPORTS(JDK23, Fragments.FeatureModuleImports, DiagKind.PLURAL),\n-        JAVA_BASE_TRANSITIVE(JDK24, Fragments.FeatureJavaBaseTransitive, DiagKind.PLURAL),\n+        MODULE_IMPORTS(JDK25, Fragments.FeatureModuleImports, DiagKind.PLURAL),\n+        JAVA_BASE_TRANSITIVE(JDK25, Fragments.FeatureJavaBaseTransitive, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,1 +231,0 @@\n-    public final Type ioType;\n@@ -632,1 +631,0 @@\n-        ioType = enterClass(\"java.io.IO\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3368,0 +3368,4 @@\n+                        if (bound.tsym != syms.objectType.tsym && (!bound.isInterface() || (bound.tsym.flags() & ANNOTATION) != 0)) {\n+                            \/\/ bound must be j.l.Object or an interface, but not an annotation\n+                            reportIntersectionError(that, \"not.an.intf.component\", bound);\n+                        }\n@@ -3391,0 +3395,5 @@\n+        private void reportIntersectionError(DiagnosticPosition pos, String key, Object... args) {\n+             resultInfo.checkContext.report(pos,\n+                 diags.fragment(Fragments.BadIntersectionTargetForFunctionalExpr(diags.fragment(key, args))));\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -344,14 +344,0 @@\n-                if (peekTypeExists(syms.ioType.tsym)) {\n-                    doImport(make.Import(make.Select(make.QualIdent(syms.ioType.tsym),\n-                            names.asterisk), true), false);\n-                }\n-            }\n-        }\n-\n-        private boolean peekTypeExists(TypeSymbol type) {\n-            try {\n-                type.complete();\n-                return !type.type.isErroneous();\n-            } catch (CompletionFailure cf) {\n-                \/\/does not exist\n-                return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1216,5 +1216,0 @@\n-                                if (flags.contains(RequiresFlag.TRANSITIVE) &&\n-                                    (majorVersion != Version.MAX().major || !previewClassFile) &&\n-                                    !preview.participatesInPreview(syms, msym)) {\n-                                    throw badClassFile(\"bad.requires.flag\", RequiresFlag.TRANSITIVE);\n-                                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1843,5 +1843,1 @@\n-                Type result =\n-                    t==tother ? t :\n-                    types.isSubtype(t, tother) ? tother :\n-                    types.isSubtype(tother, t) ? t :\n-                    error();\n+                Type result = commonSuperClass(t, tother);\n@@ -1856,2 +1852,17 @@\n-        Type error() {\n-            throw new AssertionError(\"inconsistent stack types at join point\");\n+        private Type commonSuperClass(Type t1, Type t2) {\n+            if (t1 == t2) {\n+                return t1;\n+            } else if (types.isSubtype(t1, t2)) {\n+                return t2;\n+            } else if (types.isSubtype(t2, t1)) {\n+                return t1;\n+            } else {\n+                Type lub = types.lub(t1, t2);\n+\n+                if (lub.hasTag(BOT)) {\n+                    throw Assert.error(\"Cannot find a common super class of: \" +\n+                                       t1 + \" and \" + t2);\n+                }\n+\n+                return types.erasure(lub);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1272,5 +1272,1 @@\n-            Chain exit = loopEnv.info.exit;\n-            if (exit != null) {\n-                code.resolve(exit);\n-                exit.state.defined.excludeFrom(code.nextreg);\n-            }\n+            code.resolve(loopEnv.info.exit);\n@@ -1286,5 +1282,1 @@\n-        Chain exit = localEnv.info.exit;\n-        if (exit != null) {\n-            code.resolve(exit);\n-            exit.state.defined.excludeFrom(code.nextreg);\n-        }\n+        code.resolve(localEnv.info.exit);\n@@ -1505,5 +1497,1 @@\n-            Chain exit = switchEnv.info.exit;\n-            if  (exit != null) {\n-                code.resolve(exit);\n-                exit.state.defined.excludeFrom(limit);\n-            }\n+            code.resolve(switchEnv.info.exit);\n@@ -1963,1 +1951,0 @@\n-                code.state.forceStackTop(tree.target.type);\n@@ -2079,1 +2066,0 @@\n-            code.state.forceStackTop(tree.type);\n@@ -2089,1 +2075,0 @@\n-            code.state.forceStackTop(tree.type);\n@@ -2652,1 +2637,8 @@\n-    static class GenContext {\n+    final class GenContext {\n+\n+        \/**\n+         * The top defined local variables for exit or continue branches to merge into.\n+         * It may contain uninitialized variables to be initialized by branched code,\n+         * so we cannot use Code.State.defined bits.\n+         *\/\n+        final int limit;\n@@ -2678,0 +2670,5 @@\n+        GenContext() {\n+            var code = Gen.this.code;\n+            this.limit = code == null ? 0 : code.nextreg;\n+        }\n+\n@@ -2681,0 +2678,3 @@\n+            if (c != null) {\n+                c.state.defined.excludeFrom(limit);\n+            }\n@@ -2687,0 +2687,3 @@\n+            if (c != null) {\n+                c.state.defined.excludeFrom(limit);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+    private JCDiagnostic.Error unexpectedTopLevelDefinitionStartError;\n@@ -209,0 +210,1 @@\n+        updateUnexpectedTopLevelDefinitionStartError(false);\n@@ -235,0 +237,1 @@\n+        updateUnexpectedTopLevelDefinitionStartError(false);\n@@ -4053,0 +4056,1 @@\n+            updateUnexpectedTopLevelDefinitionStartError(true);\n@@ -4126,1 +4130,1 @@\n-                if (Feature.IMPLICIT_CLASSES.allowedInSource(source) && !isDeclaration()) {\n+                if (!isDeclaration(true)) {\n@@ -4380,12 +4384,1 @@\n-            JCDiagnostic.Error error;\n-            if (parseModuleInfo) {\n-                error = Errors.ExpectedModuleOrOpen;\n-            } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) &&\n-                       (!preview.isPreview(Feature.IMPLICIT_CLASSES) || preview.isEnabled())) {\n-                error = Errors.ClassMethodOrFieldExpected;\n-            } else if (allowRecords) {\n-                error = Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\");\n-            } else {\n-                error = Errors.Expected3(CLASS, INTERFACE, ENUM);\n-            }\n-            return toP(F.Exec(syntaxError(pos, errs, error)));\n+            return toP(F.Exec(syntaxError(pos, errs, unexpectedTopLevelDefinitionStartError)));\n@@ -4980,0 +4973,4 @@\n+        return isDeclaration(allowRecords);\n+    }\n+\n+    private boolean isDeclaration(boolean allowRecords) {\n@@ -5672,0 +5669,13 @@\n+    private void updateUnexpectedTopLevelDefinitionStartError(boolean hasPackageDecl) {\n+        \/\/TODO: proper tests for this logic (and updates):\n+        if (parseModuleInfo) {\n+            unexpectedTopLevelDefinitionStartError = Errors.ExpectedModuleOrOpen;\n+        } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) && !hasPackageDecl) {\n+            unexpectedTopLevelDefinitionStartError = Errors.ClassMethodOrFieldExpected;\n+        } else if (allowRecords) {\n+            unexpectedTopLevelDefinitionStartError = Errors.Expected4(CLASS, INTERFACE, ENUM, \"record\");\n+        } else {\n+            unexpectedTopLevelDefinitionStartError = Errors.Expected3(CLASS, INTERFACE, ENUM);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-    component type {0} is not an interface\n+    component type {0} is not an interface or java.lang.Object\n@@ -532,1 +532,1 @@\n-    implicitly declared class should not have package declaration\n+    compact source file should not have package declaration\n@@ -535,1 +535,1 @@\n-    implicitly declared class does not have main method in the form of void main() or void main(String[] args)\n+    compact source file does not have main method in the form of void main() or void main(String[] args)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    Generate no warnings\n+    Generate only mandatory warnings\n@@ -171,1 +171,1 @@\n-    Enable recommended warnings\n+    Enable recommended warning categories\n@@ -173,1 +173,1 @@\n-    Enable all warnings\n+    Enable all warning categories\n@@ -175,1 +175,1 @@\n-    Disable all warnings\n+    Disable all warning categories\n@@ -180,1 +180,1 @@\n-    Warnings to enable or disable, separated by comma.\\n\\\n+    Warning categories to enable or disable, separated by comma.\\n\\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-            return null;\n+            \/\/ something not representable by CFFV, let's fall back\n+            return ClassFileFormatVersion.latest();\n@@ -125,1 +126,2 @@\n-            return null;\n+            \/\/ preview versions aren't explicitly supported, but latest is good enough for now\n+            return ClassFileFormatVersion.latest();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-runtime\/handshake\/HandshakeSuspendExitTest.java 8294313 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+    vm.cds.supports.aot.code.caching \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -182,0 +182,2 @@\n+  compiler\/ccp\/ \\\n+  compiler\/ciTypeFlow\/ \\\n@@ -192,0 +194,1 @@\n+  compiler\/igvn\/ \\\n@@ -196,1 +199,0 @@\n-  compiler\/igvn\/ \\\n@@ -210,0 +212,1 @@\n+  compiler\/predicates\/ \\\n@@ -213,0 +216,2 @@\n+  compiler\/sharedstubs\/ \\\n+  compiler\/splitif\/ \\\n@@ -433,0 +438,1 @@\n+ -runtime\/cds\/appcds\/aotCode \\\n@@ -534,0 +540,1 @@\n+ -runtime\/cds\/appcds\/aotCode \\\n@@ -612,0 +619,1 @@\n+  runtime\/cds\/appcds\/aotCode \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2571,0 +2571,10 @@\n+    public static final String FMA_F = PREFIX + \"FMA_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_F, \"FmaF\");\n+    }\n+\n+    public static final String FMA_D = PREFIX + \"FMA_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_D, \"FmaD\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+                    \"UseFMA\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test of AOT Code Cache with compressed oops configurations\n+ * @requires vm.cds.supports.aot.code.caching\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @comment The test verifies AOT checks during VM startup and not code generation.\n+ *          No need to run it with -Xcomp. It takes a lot of time to complete all\n+ *          subtests with this flag.\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build AOTCodeCompressedOopsTest JavacBenchApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *             JavacBenchApp\n+ *             JavacBenchApp$ClassFile\n+ *             JavacBenchApp$FileManager\n+ *             JavacBenchApp$SourceFile\n+ * @run driver AOTCodeCompressedOopsTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTCodeCompressedOopsTest {\n+    public static void main(String... args) throws Exception {\n+        {\n+            Tester t = new Tester();\n+            t.setHeapConfig(Tester.RunMode.ASSEMBLY, true, true);\n+            t.runAOTAssemblyWorkflow();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, true);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, false);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, false, false);\n+            t.productionRun();\n+        }\n+        {\n+            Tester t = new Tester();\n+            t.setHeapConfig(Tester.RunMode.ASSEMBLY, true, false);\n+            t.runAOTAssemblyWorkflow();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, true);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, false);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, false, false);\n+            t.productionRun();\n+        }\n+        {\n+            Tester t = new Tester();\n+            t.setHeapConfig(Tester.RunMode.ASSEMBLY, false, false);\n+            t.runAOTAssemblyWorkflow();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, true);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, true, false);\n+            t.productionRun();\n+            t.setHeapConfig(Tester.RunMode.PRODUCTION, false, false);\n+            t.productionRun();\n+        }\n+    }\n+    static class Tester extends CDSAppTester {\n+        boolean zeroBaseInAsmPhase, zeroBaseInProdPhase;\n+        boolean zeroShiftInAsmPhase, zeroShiftInProdPhase;\n+\n+        public Tester() {\n+            super(\"AOTCodeCompressedOopsTest\");\n+        }\n+\n+        public void setHeapConfig(RunMode runMode, boolean isBaseZero, boolean isShiftZero) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                zeroBaseInAsmPhase = isBaseZero;\n+                zeroShiftInAsmPhase = isShiftZero;\n+            } else if (runMode == RunMode.PRODUCTION) {\n+                zeroBaseInProdPhase = isBaseZero;\n+                zeroShiftInProdPhase = isShiftZero;\n+            }\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return \"app.jar\";\n+        }\n+\n+        List<String> getVMArgsForHeapConfig(boolean isBaseZero, boolean isShiftZero) {\n+            List<String> list = new ArrayList<String>();\n+            \/\/ Note the VM options used are best-effort to get the desired base and shift,\n+            \/\/ but it is OS dependent, so we may not get the desired configuration.\n+            if (isBaseZero && isShiftZero) {\n+                list.add(\"-Xmx128m\"); \/\/ Set max heap < 4G;\n+            } else if (isBaseZero && !isShiftZero) {\n+                list.add(\"-Xmx6g\"); \/\/ Set max heap > 4G for shift to be non-zero\n+            } else if (!isBaseZero && !isShiftZero) {\n+                list.add(\"-Xmx6g\");\n+                list.add(\"-XX:HeapBaseMinAddress=32g\");\n+            }\n+            return list;\n+       }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            switch (runMode) {\n+            case RunMode.ASSEMBLY: {\n+                    List<String> args = getVMArgsForHeapConfig(zeroBaseInAsmPhase, zeroShiftInAsmPhase);\n+                    args.addAll(List.of(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                        \"-Xlog:cds=info\",\n+                                        \"-Xlog:aot+codecache+init=debug\",\n+                                        \"-Xlog:aot+codecache+exit=debug\"));\n+                    return args.toArray(new String[0]);\n+                }\n+            case RunMode.PRODUCTION: {\n+                    List<String> args = getVMArgsForHeapConfig(zeroBaseInProdPhase, zeroShiftInProdPhase);\n+                    args.addAll(List.of(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                        \"-Xlog:cds=info\", \/\/ we need this to parse CompressedOops settings\n+                                        \"-Xlog:aot+codecache+init=debug\",\n+                                        \"-Xlog:aot+codecache+exit=debug\"));\n+                    return args.toArray(new String[0]);\n+                }\n+            }\n+            return new String[] {};\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                \"JavacBenchApp\", \"10\"\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (runMode == RunMode.PRODUCTION) {\n+                 int aotCacheShift = -1, currentShift = -1;\n+                 long aotCacheBase = -1, currentBase = -1;\n+                 List<String> list = out.asLines();\n+                 \/* We tried to have CompressedOops settings as per the test requirement,\n+                  * but it ultimately depends on OS and is not guaranteed that we have got the desired settings.\n+                  * So we parse the log output from the production run to get the real settings.\n+                  *\n+                  * Parse the following Xlog:cds output to get the values of CompressedOops::base and CompressedOops::shift\n+                  * used during the AOTCache assembly and production run:\n+                  *\n+                  *    [0.022s][info][cds] CDS archive was created with max heap size = 1024M, and the following configuration:\n+                  *    [0.022s][info][cds]     narrow_klass_base at mapping start address, narrow_klass_pointer_bits = 32, narrow_klass_shift = 0\n+                  *    [0.022s][info][cds]     narrow_oop_mode = 1, narrow_oop_base = 0x0000000000000000, narrow_oop_shift = 3\n+                  *    [0.022s][info][cds] The current max heap size = 31744M, G1HeapRegion::GrainBytes = 16777216\n+                  *    [0.022s][info][cds]     narrow_klass_base = 0x000007fc00000000, arrow_klass_pointer_bits = 32, narrow_klass_shift = 0\n+                  *    [0.022s][info][cds]     narrow_oop_mode = 3, narrow_oop_base = 0x0000000300000000, narrow_oop_shift = 3\n+                  *    [0.022s][info][cds]     heap range = [0x0000000301000000 - 0x0000000ac1000000]\n+                  *\/\n+                 Pattern p = Pattern.compile(\"narrow_oop_base = 0x(\\\\d+), narrow_oop_shift = (\\\\d)\");\n+                 for (int i = 0; i < list.size(); i++) {\n+                     String line = list.get(i);\n+                     if (line.indexOf(\"CDS archive was created with max heap size\") != -1) {\n+                         \/\/ Parse AOT Cache CompressedOops settings\n+                         line = list.get(i+2);\n+                         Matcher m = p.matcher(line);\n+                         if (!m.find()) {\n+                             throw new RuntimeException(\"Pattern \\\"\" + p + \"\\\" not found in the output\");\n+                         }\n+                         aotCacheBase = Long.valueOf(m.group(1), 16);\n+                         aotCacheShift = Integer.valueOf(m.group(2));\n+                         \/\/ Parse current CompressedOops settings\n+                         line = list.get(i+5);\n+                         m = p.matcher(line);\n+                         if (!m.find()) {\n+                             throw new RuntimeException(\"Pattern \\\"\" + p + \"\\\" not found in the output\");\n+                         }\n+                         currentBase = Long.valueOf(m.group(1), 16);\n+                         currentShift = Integer.valueOf(m.group(2));\n+                         break;\n+                     }\n+                 }\n+                 if (aotCacheShift == -1 || currentShift == -1 || aotCacheBase == -1 || currentBase == -1) {\n+                     throw new RuntimeException(\"Failed to find CompressedOops settings\");\n+                 }\n+                 if (aotCacheShift != currentShift) {\n+                     out.shouldContain(\"AOT Code Cache disabled: it was created with different CompressedOops::shift()\");\n+                 } else if ((aotCacheBase == 0 || currentBase == 0) && (aotCacheBase != currentBase)) {\n+                     out.shouldContain(\"AOTStubCaching is disabled: incompatible CompressedOops::base()\");\n+                 } else {\n+                     out.shouldMatch(\"Read \\\\d+ entries table at offset \\\\d+ from AOT Code Cache\");\n+                 }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test of combinations of the AOT Code Caching diagnostic flags\n+ * @requires vm.cds.supports.aot.code.caching\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @comment Both C1 and C2 JIT compilers are required because the test verifies\n+ *          compiler's runtime blobs generation.\n+ * @requires vm.opt.VerifyOops == null | vm.opt.VerifyOops == false\n+ * @comment VerifyOops flag switch off AOT code generation. Skip it.\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build AOTCodeFlags JavacBenchApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 JavacBenchApp\n+ *                 JavacBenchApp$ClassFile\n+ *                 JavacBenchApp$FileManager\n+ *                 JavacBenchApp$SourceFile\n+ * @run driver AOTCodeFlags\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTCodeFlags {\n+    public static void main(String... args) throws Exception {\n+        Tester t = new Tester();\n+        for (int mode = 0; mode < 3; mode++) {\n+            t.setTestMode(mode);\n+            t.run(new String[] {\"AOT\"});\n+        }\n+    }\n+    static class Tester extends CDSAppTester {\n+        private int testMode;\n+\n+        public Tester() {\n+            super(\"AOTCodeFlags\");\n+            testMode = 0;\n+        }\n+\n+        boolean isAdapterCachingOn() {\n+            return (testMode & 0x1) != 0;\n+        }\n+\n+        boolean isStubCachingOn() {\n+            return (testMode & 0x2) != 0;\n+        }\n+\n+        public void setTestMode(int mode) {\n+            testMode = mode;\n+        }\n+\n+        public List<String> getVMArgsForTestMode() {\n+            List<String> list = new ArrayList<String>();\n+            list.add(isAdapterCachingOn() ? \"-XX:+AOTAdapterCaching\" : \"-XX:-AOTAdapterCaching\");\n+            list.add(isStubCachingOn() ? \"-XX:+AOTStubCaching\" : \"-XX:-AOTStubCaching\");\n+            return list;\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return \"app.jar\";\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            switch (runMode) {\n+            case RunMode.ASSEMBLY:\n+            case RunMode.PRODUCTION: {\n+                    List<String> args = getVMArgsForTestMode();\n+                    args.addAll(List.of(\"-XX:+UnlockDiagnosticVMOptions\",\n+                                        \"-Xlog:aot+codecache+init=debug\",\n+                                        \"-Xlog:aot+codecache+exit=debug\"));\n+                    return args.toArray(new String[0]);\n+                }\n+            }\n+            return new String[] {};\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                \"JavacBenchApp\", \"10\"\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (!isAdapterCachingOn() && !isStubCachingOn()) { \/\/ this is equivalent to completely disable AOT code cache\n+                switch (runMode) {\n+                case RunMode.ASSEMBLY:\n+                case RunMode.PRODUCTION:\n+                    out.shouldNotMatch(\"Adapters:\\\\s+total\");\n+                    out.shouldNotMatch(\"Shared Blobs:\\\\s+total\");\n+                    out.shouldNotMatch(\"C1 Blobs:\\\\s+total\");\n+                    out.shouldNotMatch(\"C2 Blobs:\\\\s+total\");\n+                    break;\n+                }\n+            } else {\n+                if (isAdapterCachingOn()) {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTAdapterCaching is on, non-zero adapters should be stored\/loaded\n+                        out.shouldMatch(\"Adapters:\\\\s+total=[1-9][0-9]+\");\n+                        break;\n+                    }\n+                } else {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTAdapterCaching is off, no adapters should be stored\/loaded\n+                        out.shouldMatch(\"Adapters:\\\\s+total=0\");\n+                        break;\n+                    }\n+                }\n+                if (isStubCachingOn()) {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTStubCaching is on, non-zero stubs should be stored\/loaded\n+                        out.shouldMatch(\"Shared Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        out.shouldMatch(\"C1 Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        out.shouldMatch(\"C2 Blobs:\\\\s+total=[1-9][0-9]+\");\n+                        break;\n+                    }\n+                } else {\n+                    switch (runMode) {\n+                    case RunMode.ASSEMBLY:\n+                    case RunMode.PRODUCTION:\n+                        \/\/ AOTStubCaching is off, no stubs should be stored\/loaded\n+                        out.shouldMatch(\"Shared Blobs:\\\\s+total=0\");\n+                        out.shouldMatch(\"C1 Blobs:\\\\s+total=0\");\n+                        out.shouldMatch(\"C2 Blobs:\\\\s+total=0\");\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+ * @requires (os.arch != \"riscv64\" | !(vm.cpu.features ~= \".*qemu.*\"))\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpclass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+java\/awt\/List\/KeyEventsTest\/KeyEventsTest.java 8201307 linux-all\n+java\/awt\/Paint\/ListRepaint.java 8201307 linux-all\n@@ -802,0 +804,2 @@\n+java\/foreign\/TestBufferStackStress.java                         8350455 macosx-all\n+\n@@ -851,1 +855,2 @@\n-jdk\/classfile\/AdvancedTransformationsTest.java 8364095 generic-all\n+java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java#BasicPreview 8364095 generic-all\n+java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java 8364095 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+            result.add(new Object[]{ 44 + i, 0, Set.of(TRANSITIVE)});\n@@ -112,1 +113,0 @@\n-            result.add(new Object[]{i + 44, 0, Set.of(TRANSITIVE)});\n","filename":"test\/jdk\/java\/lang\/module\/ClassFileVersionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1525,1 +1525,0 @@\n-    @Test(expectedExceptions = InvalidModuleDescriptorException.class)\n@@ -1538,1 +1537,0 @@\n-    @Test(expectedExceptions = InvalidModuleDescriptorException.class)\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * @test\n- * @bug 8266670 8281463 8293626\n+ * @test id=Basic\n+ * @bug 8266670 8281463 8293626 8297271\n@@ -29,2 +29,1 @@\n- * @run main\/othervm --enable-preview BasicAccessFlagTest\n- * @run main BasicAccessFlagTest\n+ * @run junit BasicAccessFlagTest\n@@ -33,0 +32,10 @@\n+\/*\n+ * @test id=BasicPreview\n+ * @bug 8266670 8281463 8293626 8297271\n+ * @summary Basic tests of AccessFlag\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n+ * @run junit BasicAccessFlagTest\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n@@ -34,0 +43,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -45,0 +55,5 @@\n+import org.junit.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -46,7 +61,0 @@\n-    public static void main(String... args) throws Exception {\n-        testSourceModifiers();\n-        testMaskOrdering();\n-        testDisjoint();\n-        testMaskToAccessFlagsPositive();\n-        testLocationsNullHandling();\n-    }\n@@ -58,1 +66,2 @@\n-    private static void testSourceModifiers() throws Exception {\n+    @Test\n+    public void testSourceModifiers() throws Exception {\n@@ -65,4 +74,1 @@\n-                if (accessFlag.mask() != f.getInt(null) ) {\n-                    throw new RuntimeException(\"Unexpected mask for \" +\n-                                               accessFlag);\n-                }\n+                assertEquals(f.getInt(null), accessFlag.mask(), accessFlag + \" mask\");\n@@ -76,1 +82,2 @@\n-    private static void testMaskOrdering() {\n+    @Test\n+    public void testMaskOrdering() {\n@@ -81,5 +88,3 @@\n-            if (left.mask() > right.mask()) {\n-                throw new RuntimeException(left\n-                                           + \"has a greater mask than \"\n-                                           + right);\n-            }\n+            assertTrue(left.mask() <= right.mask(), () -> left\n+                    + \"has a greater mask than \"\n+                    + right);\n@@ -91,1 +96,2 @@\n-    private static void testDisjoint() {\n+    @Test\n+    public void testDisjoint() {\n@@ -99,1 +105,1 @@\n-            if (flags == null ) {\n+            if (flags == null) {\n@@ -146,1 +152,2 @@\n-    private static void testMaskToAccessFlagsPositive() {\n+    @Test\n+    public void testMaskToAccessFlagsPositive() {\n@@ -159,0 +166,10 @@\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                for (var location : accessFlag.locations(cffv)) {\n+                    Set<AccessFlag> computedSet =\n+                            AccessFlag.maskToAccessFlags(accessFlag.mask(), location, cffv);\n+                    if (!expectedSet.equals(computedSet)) {\n+                        throw new RuntimeException(\"Bad set computation on \" +\n+                                accessFlag + \", \" + location);\n+                    }\n+                }\n+            }\n@@ -160,0 +177,1 @@\n+        assertEquals(Set.of(AccessFlag.STRICT), AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_8));\n@@ -162,8 +180,23 @@\n-    private static void testLocationsNullHandling() {\n-        for (var flag : AccessFlag.values() ) {\n-            try {\n-                flag.locations(null);\n-                throw new RuntimeException(\"Did not get NPE on \" + flag + \".location(null)\");\n-            } catch (NullPointerException npe ) {\n-                ; \/\/ Expected\n-            }\n+    @Test\n+    public void testMaskToAccessFlagsNegative() {\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_17));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.STRICT, AccessFlag.Location.METHOD, ClassFileFormatVersion.RELEASE_1));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(Modifier.PRIVATE, AccessFlag.Location.CLASS));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MODULE, AccessFlag.Location.CLASS, ClassFileFormatVersion.RELEASE_8));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_ANNOTATION, AccessFlag.Location.CLASS, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_ENUM, AccessFlag.Location.FIELD, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_SYNTHETIC, AccessFlag.Location.INNER_CLASS, ClassFileFormatVersion.RELEASE_4));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_PUBLIC, AccessFlag.Location.INNER_CLASS, ClassFileFormatVersion.RELEASE_0));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MANDATED, AccessFlag.Location.METHOD_PARAMETER, ClassFileFormatVersion.RELEASE_7));\n+        assertThrows(IllegalArgumentException.class, () -> AccessFlag.maskToAccessFlags(ClassFile.ACC_MANDATED, AccessFlag.Location.MODULE, ClassFileFormatVersion.RELEASE_7));\n+    }\n+\n+    @Test\n+    public void testLocationsNullHandling() {\n+        for (var flag : AccessFlag.values()) {\n+            assertThrows(NullPointerException.class, () -> flag.locations(null));\n+        }\n+\n+        for (var location : AccessFlag.Location.values()) {\n+            assertThrows(NullPointerException.class, () -> location.flags(null));\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":66,"deletions":33,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+        map.put(\"vm.cds.supports.aot.code.caching\", this::vmCDSSupportsAOTCodeCaching);\n@@ -476,0 +477,14 @@\n+    \/**\n+     * @return true if this VM can support the AOT Code Caching\n+     *\/\n+    protected String vmCDSSupportsAOTCodeCaching() {\n+      if (\"true\".equals(vmCDSSupportsAOTClassLinking()) &&\n+          !\"zero\".equals(vmFlavor()) &&\n+          \"false\".equals(vmJvmciEnabled()) &&\n+          (Platform.isX64() || Platform.isAArch64())) {\n+        return \"true\";\n+      } else {\n+        return \"false\";\n+      }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-tools\/javap\/T4975569.java                                                       8364095    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -74,2 +79,8 @@\n-    public void testCompilerTestFlagEnv() {\n-        test(new String[] {\"-C\", \"-XDforcePreview\"},\n+    public void testCompilerTestFlagEnv() throws IOException {\n+        Path startupFile = Paths.get(\"startup.repl\");\n+        try (Writer w = Files.newBufferedWriter(startupFile)) {\n+            w.write(\"\"\"\n+                    import java.util.function.*;\n+                    \"\"\");\n+        }\n+        test(new String[] {\"-C\", \"-XDforcePreview\", \"-startup\", startupFile.toString()},\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnablePreviewTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+compiler.warn.is.preview                                # difficult to produce reliably despite future changes to java.base\n@@ -148,2 +149,0 @@\n-compiler.misc.bad.intersection.target.for.functional.expr  # currently not generated, should be removed?\n-compiler.misc.not.an.intf.component\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339 8335896\n+ * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339 8335896 8344706\n@@ -287,0 +287,40 @@\n+\n+    @Test\n+    public void testMainNoParams(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+            \"package hello;\\n\" +\n+            \"import java.util.Arrays;\\n\" +\n+            \"class World {\\n\" +\n+            \"    public static void main(String... args) {\\n\" +\n+            \"        System.out.println(\\\"Hello World! \\\" + Arrays.toString(args));\\n\" +\n+            \"    }\\n\" +\n+            \"}\");\n+        testSuccess(base.resolve(\"hello\").resolve(\"World.java\"), \"Hello World! [1, 2, 3]\\n\");\n+    }\n+\n+    @Test\n+    public void testMainNotPublic(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+            \"package hello;\\n\" +\n+            \"import java.util.Arrays;\\n\" +\n+            \"class World {\\n\" +\n+            \"    static void main(String... args) {\\n\" +\n+            \"        System.out.println(\\\"Hello World! \\\" + Arrays.toString(args));\\n\" +\n+            \"    }\\n\" +\n+            \"}\");\n+        testSuccess(base.resolve(\"hello\").resolve(\"World.java\"), \"Hello World! [1, 2, 3]\\n\");\n+    }\n+\n+    @Test\n+    public void testMainNotStatic(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+            \"package hello;\\n\" +\n+            \"import java.util.Arrays;\\n\" +\n+            \"class World {\\n\" +\n+            \"    public void main(String... args) {\\n\" +\n+            \"        System.out.println(\\\"Hello World! \\\" + Arrays.toString(args));\\n\" +\n+            \"    }\\n\" +\n+            \"}\");\n+        testSuccess(base.resolve(\"hello\").resolve(\"World.java\"), \"Hello World! [1, 2, 3]\\n\");\n+    }\n+\n@@ -306,1 +346,1 @@\n-            file + \":1: error: class, interface, enum, or record expected\\n\" +\n+            file + \":1: error: class, interface, annotation type, enum, record, method or field expected\\n\" +\n@@ -520,1 +560,1 @@\n-            file + \":1: error: class, interface, enum, or record expected\\n\" +\n+            file + \":1: error: class, interface, annotation type, enum, record, method or field expected\\n\" +\n@@ -571,1 +611,1 @@\n-                \"class BadParams { public static void main() { } }\");\n+                \"class BadParams { public static void main(int n) { } }\");\n@@ -576,16 +616,0 @@\n-    @Test\n-    public void testMainNotPublic(Path base) throws IOException {\n-        tb.writeJavaFiles(base,\n-                \"class NotPublic { static void main(String... args) { } }\");\n-        testError(base.resolve(\"NotPublic.java\"), \"\",\n-                \"error: can't find main(String[]) method in class: NotPublic\");\n-    }\n-\n-    @Test\n-    public void testMainNotStatic(Path base) throws IOException {\n-        tb.writeJavaFiles(base,\n-                \"class NotStatic { public void main(String... args) { } }\");\n-        testError(base.resolve(\"NotStatic.java\"), \"\",\n-                \"error: can't find main(String[]) method in class: NotStatic\");\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":45,"deletions":21,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-    private OutputAnalyzer productionRun() throws Exception {\n+    public OutputAnalyzer productionRun() throws Exception {\n@@ -434,0 +434,7 @@\n+\n+    \/\/ See JEP 483; stop at the assembly run; do not execute production run\n+    public void runAOTAssemblyWorkflow() throws Exception {\n+        this.workflow = Workflow.AOT;\n+        recordAOTConfiguration();\n+        createAOTCache();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}