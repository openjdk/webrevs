{"files":[{"patch":"@@ -6297,8 +6297,1 @@\n-          if (klass != nullptr) {\n-            \/\/ Loads triggered by the LoadableDescriptors attribute are speculative, failures must not\n-            \/\/ impact loading of current class. We need to clear the exception before setting the klass\n-            \/\/ in the array of InlineLayoutInfo, since it might throw a new exception during Metaspace\n-            \/\/ allocation.\n-            if (HAS_PENDING_EXCEPTION) {\n-              CLEAR_PENDING_EXCEPTION;\n-            }\n+          assert((klass == nullptr) == HAS_PENDING_EXCEPTION, \"Must be the same\");\n@@ -6306,0 +6299,1 @@\n+          if (klass != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -97,0 +97,22 @@\n+static bool field_is_inlineable(FieldInfo fieldinfo, LayoutKind lk, Array<InlineLayoutInfo>* ili) {\n+  if (fieldinfo.field_flags().is_null_free_inline_type()) {\n+    \/\/ A null-free inline type is always inlineable\n+    return true;\n+  }\n+\n+  if (lk != LayoutKind::REFERENCE) {\n+    \/\/ We've chosen a layout that isn't a normal reference\n+    return true;\n+  }\n+\n+  if (!fieldinfo.field_flags().is_injected() &&\n+      ili != nullptr &&\n+      ili->adr_at((int)fieldinfo.index())->klass() != nullptr &&\n+      !ili->adr_at((int)fieldinfo.index())->klass()->is_identity_class()) {\n+    \/\/ The field's klass is not an identity class\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n@@ -843,1 +865,0 @@\n-      const int field_index = (int)fieldinfo.index();\n@@ -845,4 +866,1 @@\n-      if (fieldinfo.field_flags().is_null_free_inline_type() || lk != LayoutKind::REFERENCE\n-          || (!fieldinfo.field_flags().is_injected()\n-              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(field_index)->klass() != nullptr\n-              && !_inline_layout_info_array->adr_at(field_index)->klass()->is_identity_class())) {\n+      if (field_is_inlineable(fieldinfo, lk, _inline_layout_info_array)) {\n@@ -856,0 +874,1 @@\n+        const int field_index = (int)fieldinfo.index();\n@@ -931,1 +950,0 @@\n-      const int field_index = (int)fieldinfo.index();\n@@ -933,4 +951,1 @@\n-      if (fieldinfo.field_flags().is_null_free_inline_type() || lk != LayoutKind::REFERENCE\n-          || (!fieldinfo.field_flags().is_injected()\n-              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(field_index)->klass() != nullptr\n-              && !_inline_layout_info_array->adr_at(field_index)->klass()->is_identity_class())) {\n+      if (field_is_inlineable(fieldinfo, lk, _inline_layout_info_array)) {\n@@ -947,0 +962,1 @@\n+        const int field_index = (int)fieldinfo.index();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"}]}