{"files":[{"patch":"@@ -1088,1 +1088,7 @@\n-        if (!fd->is_null_free_inline_type()) {\n+        if (fd->is_null_free_inline_type() && fd->is_flat()) {\n+          InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n+          int field_offset = fd->offset() - vk->payload_offset();\n+          oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n+          InlineTypeFieldInitializer init_fields(obj, _replay);\n+          vk->do_nonstatic_fields(&init_fields);\n+        } else {\n@@ -1092,13 +1098,0 @@\n-          break;\n-        } else {\n-          InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n-          if (fd->is_flat()) {\n-            int field_offset = fd->offset() - vk->payload_offset();\n-            oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n-            InlineTypeFieldInitializer init_fields(obj, _replay);\n-            vk->do_nonstatic_fields(&init_fields);\n-          } else {\n-            oop value = vk->allocate_instance(JavaThread::current());\n-            _vt->obj_field_put(fd->offset(), value);\n-          }\n-          break;\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -5697,1 +5697,1 @@\n-  _has_inline_type_fields(false),\n+  _has_inlined_fields(false),\n@@ -6253,3 +6253,0 @@\n-    _inline_layout_info_array = MetadataFactory::new_array<InlineLayoutInfo>(_loader_data,\n-                                                   java_fields_count(),\n-                                                   CHECK);\n@@ -6283,2 +6280,1 @@\n-        InlineKlass* vk = InlineKlass::cast(klass);\n-        _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(vk);\n+        set_inline_layout_info_klass(fieldinfo.index(), klass, CHECK);\n@@ -6297,3 +6293,4 @@\n-          Klass* klass = SystemDictionary::resolve_super_or_fail(_class_name, name,\n-                                                                 Handle(THREAD, loader),\n-                                                                 false, THREAD);\n+          InstanceKlass* klass = SystemDictionary::resolve_super_or_fail(_class_name, name,\n+                                                                         Handle(THREAD, loader),\n+                                                                         false, THREAD);\n+\n@@ -6301,0 +6298,8 @@\n+            \/\/ Loads triggered by the LoadableDescriptors attribute are speculative, failures must not\n+            \/\/ impact loading of current class. We need to clear the exception before setting the klass\n+            \/\/ in the array of InlineLayoutInfo, since it might throw a new exception during Metaspace\n+            \/\/ allocation.\n+            if (HAS_PENDING_EXCEPTION) {\n+              CLEAR_PENDING_EXCEPTION;\n+            }\n+\n@@ -6302,1 +6307,1 @@\n-              _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+              set_inline_layout_info_klass(fieldinfo.index(), klass, CHECK);\n@@ -6309,2 +6314,2 @@\n-                                          \"(cause: field type in LoadableDescriptors attribute) but loaded class is not a value class\",\n-                                          name->as_C_string(), _class_name->as_C_string());\n+                                       \"(cause: field type in LoadableDescriptors attribute) but loaded class is not a value class\",\n+                                       name->as_C_string(), _class_name->as_C_string());\n@@ -6314,6 +6319,4 @@\n-                                        \"(cause: field type in LoadableDescriptors attribute) failed : %s\",\n-                                        name->as_C_string(), _class_name->as_C_string(),\n-                                        PENDING_EXCEPTION->klass()->name()->as_C_string());\n-          }\n-          \/\/ Loads triggered by the LoadableDescriptors attribute are speculative, failures must not impact loading of current class\n-          if (HAS_PENDING_EXCEPTION) {\n+                                     \"(cause: field type in LoadableDescriptors attribute) failed : %s\",\n+                                     name->as_C_string(), _class_name->as_C_string(),\n+                                     PENDING_EXCEPTION->klass()->name()->as_C_string());\n+\n@@ -6329,1 +6332,1 @@\n-            _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+            set_inline_layout_info_klass(fieldinfo.index(), klass, CHECK);\n@@ -6345,1 +6348,9 @@\n-  _has_inline_type_fields = _layout_info->_has_inline_fields;\n+  _has_inlined_fields = _layout_info->_has_inlined_fields;\n+\n+  \/\/ If it turned out that we didn't inline any of the fields, we deallocate\n+  \/\/ the array of InlineLayoutInfo since it isn't needed, and so it isn't\n+  \/\/ transferred to the allocated InstanceKlass.\n+  if (_inline_layout_info_array != nullptr && !_layout_info->_has_inlined_fields) {\n+    MetadataFactory::free_array<InlineLayoutInfo>(_loader_data, _inline_layout_info_array);\n+    _inline_layout_info_array = nullptr;\n+  }\n@@ -6389,0 +6400,16 @@\n+void ClassFileParser::set_inline_layout_info_klass(int field_index, InstanceKlass* klass, TRAPS) {\n+  assert(field_index >= 0 && field_index < java_fields_count(), \"IOOB: 0 <= %d < %d\", field_index, (int)java_fields_count());\n+\n+  \/\/ The array of InlineLayoutInfo is allocated on demand. This way the array is\n+  \/\/ never allocated for an InstanceKlass which has no need for this information.\n+  if (_inline_layout_info_array == nullptr) {\n+    _inline_layout_info_array = MetadataFactory::new_array<InlineLayoutInfo>(_loader_data,\n+                                                                             java_fields_count(),\n+                                                                             CHECK);\n+  }\n+\n+  \/\/ Set the Klass for the field's index\n+  InlineKlass* ik = InlineKlass::cast(klass);\n+  _inline_layout_info_array->adr_at(field_index)->set_klass(ik);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":47,"deletions":20,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  bool _has_inline_fields;\n+  bool _has_inlined_fields;\n@@ -104,1 +104,1 @@\n-                      _has_inline_fields(false), _is_empty_inline_klass(false) { }\n+                      _has_inlined_fields(false), _is_empty_inline_klass(false) { }\n@@ -229,1 +229,1 @@\n-  bool _has_inline_type_fields;\n+  bool _has_inlined_fields;\n@@ -252,0 +252,2 @@\n+  void set_inline_layout_info_klass(int field_index, InstanceKlass* klass, TRAPS);\n+\n@@ -574,1 +576,1 @@\n-  bool has_inline_fields() const { return _has_inline_type_fields; }\n+  bool has_inlined_fields() const { return _has_inlined_fields; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -766,1 +766,2 @@\n-  _has_inline_type_fields(false),\n+  _has_inlineable_fields(false),\n+  _has_inlined_fields(false),\n@@ -770,1 +771,0 @@\n-  _has_flattening_information(is_inline_type),\n@@ -843,0 +843,2 @@\n+      const int field_index = (int)fieldinfo.index();\n+\n@@ -845,4 +847,3 @@\n-              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(fieldinfo.index())->klass() != nullptr\n-              && !_inline_layout_info_array->adr_at(fieldinfo.index())->klass()->is_identity_class())) {\n-        _has_inline_type_fields = true;\n-        _has_flattening_information = true;\n+              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(field_index)->klass() != nullptr\n+              && !_inline_layout_info_array->adr_at(field_index)->klass()->is_identity_class())) {\n+        _has_inlineable_fields = true;\n@@ -850,0 +851,1 @@\n+\n@@ -854,2 +856,4 @@\n-        _has_flattening_information = true;\n-        InlineKlass* vk = _inline_layout_info_array->adr_at(fieldinfo.index())->klass();\n+        assert(_inline_layout_info_array != nullptr, \"Array must have been created\");\n+        assert(_inline_layout_info_array->adr_at(field_index)->klass() != nullptr, \"Klass must have been set\");\n+        _has_inlined_fields = true;\n+        InlineKlass* vk = _inline_layout_info_array->adr_at(field_index)->klass();\n@@ -859,1 +863,1 @@\n-        _inline_layout_info_array->adr_at(fieldinfo.index())->set_kind(lk);\n+        _inline_layout_info_array->adr_at(field_index)->set_kind(lk);\n@@ -920,1 +924,1 @@\n-      group->add_primitive_field(fieldinfo.index(), type);\n+      group->add_primitive_field(idx, type);\n@@ -927,0 +931,2 @@\n+      const int field_index = (int)fieldinfo.index();\n+\n@@ -929,4 +935,3 @@\n-              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(fieldinfo.index())->klass() != nullptr\n-              && !_inline_layout_info_array->adr_at(fieldinfo.index())->klass()->is_identity_class())) {\n-        _has_inline_type_fields = true;\n-        _has_flattening_information = true;\n+              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(field_index)->klass() != nullptr\n+              && !_inline_layout_info_array->adr_at(field_index)->klass()->is_identity_class())) {\n+        _has_inlineable_fields = true;\n@@ -934,0 +939,1 @@\n+\n@@ -941,2 +947,4 @@\n-        _has_flattening_information = true;\n-        InlineKlass* vk = _inline_layout_info_array->adr_at(fieldinfo.index())->klass();\n+        assert(_inline_layout_info_array != nullptr, \"Array must have been created\");\n+        assert(_inline_layout_info_array->adr_at(field_index)->klass() != nullptr, \"Klass must have been set\");\n+        _has_inlined_fields = true;\n+        InlineKlass* vk = _inline_layout_info_array->adr_at(field_index)->klass();\n@@ -947,1 +955,1 @@\n-        _inline_layout_info_array->adr_at(fieldinfo.index())->set_kind(lk);\n+        _inline_layout_info_array->adr_at(field_index)->set_kind(lk);\n@@ -1503,1 +1511,1 @@\n-  _info->_has_inline_fields = _has_inline_type_fields;\n+  _info->_has_inlined_fields = _has_inlined_fields;\n@@ -1560,1 +1568,1 @@\n-  if (PrintFieldLayout || (PrintInlineLayout && (_has_flattening_information || _is_abstract_value))) {\n+  if (PrintFieldLayout || (PrintInlineLayout && (_has_inlineable_fields || _is_inline_type || _is_abstract_value))) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -307,1 +307,2 @@\n-  bool _has_inline_type_fields;\n+  bool _has_inlineable_fields;\n+  bool _has_inlined_fields;\n@@ -312,1 +313,0 @@\n-  bool _has_flattening_information;\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1199,1 +1199,1 @@\n-  if (ik->has_inline_type_fields()) {\n+  if (ik->has_inlined_fields()) {\n@@ -1214,2 +1214,2 @@\n-          \/\/ Pending exceptions are cleared so we can fail silently\n-          try_preload_from_loadable_descriptors(ik, class_loader, sig, field_index, CHECK_NULL);\n+        \/\/ Pending exceptions are cleared so we can fail silently\n+        try_preload_from_loadable_descriptors(ik, class_loader, sig, field_index, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -606,2 +606,2 @@\n-  if (parser.has_inline_fields()) {\n-    set_has_inline_type_fields();\n+  if (parser.has_inlined_fields()) {\n+    set_has_inlined_fields();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -399,2 +399,2 @@\n-  bool has_inline_type_fields() const { return _misc_flags.has_inline_type_fields(); }\n-  void set_has_inline_type_fields()   { _misc_flags.set_has_inline_type_fields(true); }\n+  bool has_inlined_fields() const { return _misc_flags.has_inlined_fields(); }\n+  void set_has_inlined_fields()   { _misc_flags.set_has_inlined_fields(true); }\n@@ -1075,4 +1075,1 @@\n-  void set_inline_layout_info(int index, InlineLayoutInfo *info) {\n-    assert(_inline_layout_info_array != nullptr ,\"Array not created\");\n-    _inline_layout_info_array->at_put(index, *info);\n-  }\n+\n@@ -1080,1 +1077,1 @@\n-    assert(_inline_layout_info_array != nullptr ,\"Array not created\");\n+    assert(_inline_layout_info_array != nullptr, \"Array not created\");\n@@ -1083,0 +1080,1 @@\n+\n@@ -1084,1 +1082,1 @@\n-    assert(_inline_layout_info_array != nullptr ,\"Array not created\");\n+    assert(_inline_layout_info_array != nullptr, \"Array not created\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(has_inlined_fields(), \"Sanity checking\");\n@@ -80,1 +80,1 @@\n-  assert(has_inline_type_fields(), \"Sanity checking\");\n+  assert(has_inlined_fields(), \"Sanity checking\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    flag(has_inline_type_fields             , 1 << 14) \/* has inline fields and related embedded section is not empty *\/ \\\n+    flag(has_inlined_fields                 , 1 << 14) \/* has inlined fields and related embedded section is not empty *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1371,1 +1371,1 @@\n-    if (InstanceKlass::cast(obj.klass())->has_inline_type_fields()) {\n+    if (InstanceKlass::cast(obj.klass())->has_inlined_fields()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}