{"files":[{"patch":"@@ -586,1 +586,8 @@\n-        case atos: new_code = Bytecodes::_fast_agetfield; break;\n+        case atos: {\n+          if (rfe->is_flat()) {\n+            new_code = Bytecodes::_fast_vgetfield;\n+          } else {\n+            new_code = Bytecodes::_fast_agetfield;\n+          }\n+          break;\n+        }\n@@ -611,1 +618,8 @@\n-        case atos: new_code = Bytecodes::_fast_aputfield; break;\n+        case atos: {\n+          if (rfe->is_flat() || rfe->is_null_free_inline_type()) {\n+            new_code = Bytecodes::_fast_vputfield;\n+          } else {\n+            new_code = Bytecodes::_fast_aputfield;\n+          }\n+          break;\n+        }\n@@ -1394,5 +1408,0 @@\n-  if (CDSConfig::is_valhalla_preview()) {\n-    log_info(cds)(\"Archived java heap is not yet supported with Valhalla preview\");\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-  if (Arguments::is_incompatible_cds_internal_module_property(key) && !Arguments::patching_migrated_classes(key, value)) {\n+  if (Arguments::is_incompatible_cds_internal_module_property(key)) {\n@@ -978,4 +978,0 @@\n-  if (is_valhalla_preview()) {\n-    \/\/ Not working yet -- e.g., HeapShared::oop_hash() needs to be implemented for value oops\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2263,6 +2263,0 @@\n-    if (CDSConfig::is_valhalla_preview() && strcmp(klass_name, \"jdk\/internal\/module\/ArchivedModuleGraph\") == 0) {\n-      \/\/ FIXME -- ArchivedModuleGraph doesn't work when java.base is patched with valhalla classes.\n-      i++;\n-      continue;\n-    }\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -217,1 +217,9 @@\n-        add_migrated_value_classes(cld);\n+        if (CDSConfig::is_using_aot_linked_classes() && java_system_loader() == nullptr) {\n+          \/\/ We are inside AOTLinkedClassBulkLoader::preload_classes().\n+          \/\/\n+          \/\/ AOTLinkedClassBulkLoader will automatically initiate the loading of all archived\n+          \/\/ public classes from the boot loader into platform\/system loaders, so there's\n+          \/\/ no need to call add_migrated_value_classes().\n+        } else {\n+          add_migrated_value_classes(cld);\n+        }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -373,12 +373,0 @@\n-bool Arguments::patching_migrated_classes(const char* property, const char* value) {\n-  if (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n-    const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;\n-    if (matches_property_suffix(property_suffix, PATCH, PATCH_LEN)) {\n-      if (strcmp(value, \"java.base-valueclasses.jar\")) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -478,1 +478,0 @@\n-  static bool patching_migrated_classes(const char* property, const char* value);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2915,0 +2915,13 @@\n+            if (AOTCodeCache::is_using_adapter() && super_method->adapter()->get_sig_cc() == nullptr) {\n+              \/\/ Calling conventions have to be regenerated at runtime and are accessed through method adapters,\n+              \/\/ which are archived in the AOT code cache. If the adapters are not regenerated, the\n+              \/\/ calling conventions should be regenerated here.\n+              CompiledEntrySignature ces(super_method);\n+              ces.compute_calling_conventions();\n+              if (ces.has_scalarized_args()) {\n+                \/\/ Save a C heap allocated version of the scalarized signature and store it in the adapter\n+                GrowableArray<SigEntry>* heap_sig = new (mtInternal) GrowableArray<SigEntry>(ces.sig_cc()->length(), mtInternal);\n+                heap_sig->appendAll(ces.sig_cc());\n+                super_method->adapter()->set_sig_cc(heap_sig);\n+              }\n+            }\n@@ -3369,0 +3382,1 @@\n+   _sig_cc = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -586,0 +586,1 @@\n+ -runtime\/cds\/appcds\/RewriteBytecodesInlineTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}