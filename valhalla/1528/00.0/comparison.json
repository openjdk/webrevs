{"files":[{"patch":"@@ -257,1 +257,0 @@\n-            \"--disable-cds-archive-coh\",\n","filename":"make\/conf\/jib-profiles.js","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import java.lang.classfile.TypeAnnotation.TargetInfo;\n+import java.lang.classfile.TypeAnnotation.TypePathComponent;\n@@ -999,0 +1001,6 @@\n+        if (desc.classTypeAnnotations != null && !desc.classTypeAnnotations.isEmpty()) {\n+            builder.accept(RuntimeInvisibleTypeAnnotationsAttribute.of(createTypeAnnotations(desc.classTypeAnnotations)));\n+        }\n+        if (desc.runtimeTypeAnnotations != null && !desc.runtimeTypeAnnotations.isEmpty()) {\n+            builder.accept(RuntimeVisibleTypeAnnotationsAttribute.of(createTypeAnnotations(desc.runtimeTypeAnnotations)));\n+        }\n@@ -1080,0 +1088,38 @@\n+\n+    private List<TypeAnnotation> createTypeAnnotations(List<TypeAnnotationDescription> desc) {\n+        return desc.stream().map(this::createTypeAnnotation).collect(Collectors.toList());\n+    }\n+\n+    private TypeAnnotation createTypeAnnotation(TypeAnnotationDescription desc) {\n+        Annotation baseAnn = createAnnotation(desc.annotation);\n+        TargetInfo targetInfo = switch ((String) desc.targetInfo.get(\"targetType\")) {\n+            case \"CLASS_TYPE_PARAMETER\" -> \/\/TODO: test!\n+                TargetInfo.ofClassTypeParameter((int) desc.targetInfo.get(\"typeParameterIndex\"));\n+            case \"METHOD_TYPE_PARAMETER\" ->\n+                TargetInfo.ofMethodTypeParameter((int) desc.targetInfo.get(\"typeParameterIndex\"));\n+            case \"CLASS_EXTENDS\" ->\n+                TargetInfo.ofClassExtends((int) desc.targetInfo.get(\"supertypeIndex\"));\n+            case \"CLASS_TYPE_PARAMETER_BOUND\" ->\n+                TargetInfo.ofClassTypeParameterBound((int) desc.targetInfo.get(\"typeParameterIndex\"),\n+                                                     (int) desc.targetInfo.get(\"boundIndex\"));\n+            case \"METHOD_TYPE_PARAMETER_BOUND\" ->\n+                TargetInfo.ofMethodTypeParameterBound((int) desc.targetInfo.get(\"typeParameterIndex\"),\n+                                                      (int) desc.targetInfo.get(\"boundIndex\"));\n+            case \"METHOD_RETURN\" ->\n+                TargetInfo.ofMethodReturn();\n+            case \"METHOD_RECEIVER\" ->\n+                TargetInfo.ofMethodReceiver();\n+            case \"METHOD_FORMAL_PARAMETER\" ->\n+                TargetInfo.ofMethodFormalParameter((int) desc.targetInfo.get(\"formalParameterIndex\"));\n+            case \"THROWS\" ->\n+                TargetInfo.ofThrows((int) desc.targetInfo.get(\"throwsTargetIndex\"));\n+            case \"FIELD\" ->\n+                TargetInfo.ofField();\n+            case String targetType ->\n+                throw new IllegalStateException(\"Unsupported targetType: \" + targetType);\n+        };\n+\n+        List<TypePathComponent> typePath = desc.typePath.stream().map(d -> TypePathComponent.of(TypePathComponent.Kind.valueOf(d.tag()), d.index())).toList();\n+\n+        return TypeAnnotation.of(targetInfo, typePath, baseAnn);\n+    }\n@@ -2227,1 +2273,4 @@\n-            case RuntimeVisibleTypeAnnotationsAttribute a -> {\/* do nothing for now *\/}\n+            case RuntimeInvisibleTypeAnnotationsAttribute a ->\n+                feature.classTypeAnnotations = typeAnnotations2Descriptions(a.annotations());\n+            case RuntimeVisibleTypeAnnotationsAttribute a ->\n+                feature.runtimeTypeAnnotations = typeAnnotations2Descriptions(a.annotations());\n@@ -2284,0 +2333,25 @@\n+\n+    private List<TypeAnnotationDescription> typeAnnotations2Descriptions(List<TypeAnnotation> annos) {\n+        return annos.stream().map(ta -> {\n+            TypeAnnotationDescription desc = new TypeAnnotationDescription();\n+            desc.annotation = annotation2Description(ta.annotation());\n+            desc.targetInfo = new HashMap<>();\n+            desc.targetInfo.put(\"targetType\", ta.targetInfo().targetType().name());\n+            switch (ta.targetInfo()) {\n+                case TypeAnnotation.TypeParameterTarget tpt -> desc.targetInfo.put(\"typeParameterIndex\", tpt.typeParameterIndex());\n+                case TypeAnnotation.SupertypeTarget st -> desc.targetInfo.put(\"supertypeIndex\", st.supertypeIndex());\n+                case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                    desc.targetInfo.put(\"typeParameterIndex\", tpbt.typeParameterIndex());\n+                    desc.targetInfo.put(\"boundIndex\", tpbt.boundIndex());\n+                }\n+                case TypeAnnotation.EmptyTarget _ -> {\n+                    \/\/ nothing to write\n+                }\n+                case TypeAnnotation.FormalParameterTarget fpt -> desc.targetInfo.put(\"formalParameterIndex\", fpt.formalParameterIndex());\n+                case TypeAnnotation.ThrowsTarget tt -> desc.targetInfo.put(\"throwsTargetIndex\", tt.throwsTargetIndex());\n+                default -> throw new IllegalStateException(ta.targetInfo().targetType().name());\n+            }\n+            desc.typePath = ta.targetPath().stream().map(tpc -> new TypeAnnotationDescription.TypePathComponentDesc(tpc.typePathKind().name(), tpc.typeArgumentIndex())).toList();\n+            return desc;\n+        }).toList();\n+    }\n@@ -2405,0 +2479,2 @@\n+        List<TypeAnnotationDescription> classTypeAnnotations;\n+        List<TypeAnnotationDescription> runtimeTypeAnnotations;\n@@ -2427,0 +2503,12 @@\n+            if (classTypeAnnotations != null && !classTypeAnnotations.isEmpty()) {\n+                output.append(\" classTypeAnnotations \");\n+                for (TypeAnnotationDescription a : classTypeAnnotations) {\n+                    output.append(quote(a.toString(), false));\n+                }\n+            }\n+            if (runtimeTypeAnnotations != null && !runtimeTypeAnnotations.isEmpty()) {\n+                output.append(\" runtimeTypeAnnotations \");\n+                for (TypeAnnotationDescription a : runtimeTypeAnnotations) {\n+                    output.append(quote(a.toString(), false));\n+                }\n+            }\n@@ -2456,0 +2544,8 @@\n+            String inClassTypeAnnotations = reader.attributes.get(\"classTypeAnnotations\");\n+            if (inClassTypeAnnotations != null) {\n+                classTypeAnnotations = parseTypeAnnotations(inClassTypeAnnotations, new int[1]);\n+            }\n+            String inRuntimeTypeAnnotations = reader.attributes.get(\"runtimeTypeAnnotations\");\n+            if (inRuntimeTypeAnnotations != null) {\n+                runtimeTypeAnnotations = parseTypeAnnotations(inRuntimeTypeAnnotations, new int[1]);\n+            }\n@@ -2468,0 +2564,2 @@\n+            hash = 89 * hash + listHashCode(this.classTypeAnnotations);\n+            hash = 89 * hash + listHashCode(this.runtimeTypeAnnotations);\n@@ -2495,0 +2593,6 @@\n+            if (!listEquals(this.classTypeAnnotations, other.classTypeAnnotations)) {\n+                return false;\n+            }\n+            if (!listEquals(this.runtimeTypeAnnotations, other.runtimeTypeAnnotations)) {\n+                return false;\n+            }\n@@ -3299,0 +3403,2 @@\n+            hash = 59 * hash + Objects.hashCode(this.classParameterAnnotations);\n+            hash = 59 * hash + Objects.hashCode(this.runtimeParameterAnnotations);\n@@ -3323,0 +3429,6 @@\n+            if (!Objects.equals(this.classParameterAnnotations, other.classParameterAnnotations)) {\n+                return false;\n+            }\n+            if (!Objects.equals(this.runtimeParameterAnnotations, other.runtimeParameterAnnotations)) {\n+                return false;\n+            }\n@@ -3650,0 +3762,34 @@\n+    static final class TypeAnnotationDescription {\n+        AnnotationDescription annotation;\n+        Map<String, Object> targetInfo;\n+        List<TypePathComponentDesc> typePath;\n+\n+        public TypeAnnotationDescription() {\n+        }\n+\n+        public TypeAnnotationDescription(AnnotationDescription annotation, Map<String, Object> targetInfo, List<TypePathComponentDesc> typePath) {\n+            this.annotation = annotation;\n+            this.targetInfo = targetInfo;\n+            this.typePath = typePath;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return annotation.toString() + \"{\" + targetInfo.entrySet().stream().map(e -> e.getKey() + \"=\" + quote(printValue(e.getValue()), false)).collect(Collectors.joining(\",\")) + \"}\" +\n+                                           (!typePath.isEmpty() ? \"[\" + typePath.stream().map(desc -> desc.tag + \":\" + desc.index).collect(Collectors.joining(\",\")) + \"]\" : \"\");\n+        }\n+\n+        private String printValue(Object obj) {\n+            if (obj instanceof String s) {\n+                return \"\\\"\" + s + \"\\\"\";\n+            } else if (obj instanceof Integer i) {\n+                return \"I\" + String.valueOf(i);\n+            } else {\n+                throw new IllegalStateException(\"Unsupported value: \" + obj.getClass());\n+            }\n+        }\n+\n+        \/\/TODO: path\n+        record TypePathComponentDesc(String tag, int index) {}\n+    }\n+\n@@ -3989,1 +4135,1 @@\n-        Map<String, Object> attribute2Value = new HashMap<>();\n+        Map<String, Object> attribute2Value = Map.of();\n@@ -3992,1 +4138,47 @@\n-            while (value.charAt(valuePointer[0]) != ')') {\n+            attribute2Value = parseMap(value, valuePointer, ')');\n+        }\n+\n+        return new AnnotationDescription(className, attribute2Value);\n+    }\n+\n+    private static Map<String, Object> parseMap(String value, int[] valuePointer, char endBracket) {\n+        Map<String, Object> attribute2Value = new HashMap<>();\n+\n+        while (value.charAt(valuePointer[0]) != endBracket) {\n+            int nameStart = ++valuePointer[0];\n+\n+            while (value.charAt(valuePointer[0]++) != '=');\n+\n+            String name = value.substring(nameStart, valuePointer[0] - 1);\n+\n+            attribute2Value.put(name, parseAnnotationValue(value, valuePointer));\n+        }\n+\n+        valuePointer[0]++;\n+\n+        return attribute2Value;\n+    }\n+\n+    public static List<TypeAnnotationDescription> parseTypeAnnotations(String encoded, int[] pointer) {\n+        List<TypeAnnotationDescription> result = new ArrayList<>();\n+\n+        while (pointer[0] < encoded.length() && encoded.charAt(pointer[0]) == '@') {\n+            pointer[0]++;\n+            result.add(parseTypeAnnotation(encoded, pointer));\n+        }\n+\n+        return result;\n+    }\n+\n+    private static TypeAnnotationDescription parseTypeAnnotation(String value, int[] valuePointer) {\n+        AnnotationDescription ann = parseAnnotation(value, valuePointer);\n+        Map<String, Object> targetInfo = Map.of();\n+\n+        if (valuePointer[0] < value.length() && value.charAt(valuePointer[0]) == '{') {\n+            targetInfo = parseMap(value, valuePointer, '}');\n+        }\n+\n+        List<TypeAnnotationDescription.TypePathComponentDesc> typePath = new ArrayList<>();\n+\n+        if (valuePointer[0] < value.length() && value.charAt(valuePointer[0]) == '[') {\n+            while (value.charAt(valuePointer[0]) != ']') {\n@@ -3995,1 +4187,1 @@\n-                while (value.charAt(valuePointer[0]++) != '=');\n+                while (value.charAt(valuePointer[0]++) != ':');\n@@ -3999,1 +4191,1 @@\n-                attribute2Value.put(name, parseAnnotationValue(value, valuePointer));\n+                typePath.add(new TypeAnnotationDescription.TypePathComponentDesc(name, Integer.parseInt(readDigits(value, valuePointer))));\n@@ -4005,1 +4197,1 @@\n-        return new AnnotationDescription(className, attribute2Value);\n+        return new TypeAnnotationDescription(ann, targetInfo, typePath);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":198,"deletions":6,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -8294,0 +8294,10 @@\n+instruct castHH(vRegF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -850,1 +850,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,47 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::interpreter_frame_bcp_offset]);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::return_addr_offset]);\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::interpreter_frame_sender_sp_offset]);\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp + frame::interpreter_frame_initial_sp_offset;\n+}\n+\n+inline intptr_t* frame::sender_sp(intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return fp + frame::sender_sp_offset;\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::link_offset]);\n+}\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(sp[-1]);\n+}\n+\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(sp[-2]);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -518,1 +518,0 @@\n-\/\/ Apply stack watermark barrier.\n@@ -521,0 +520,2 @@\n+\/\/ Apply stack watermark barrier.\n+\/\/ Notify JVMTI.\n@@ -530,5 +531,4 @@\n-void InterpreterMacroAssembler::remove_activation(\n-        TosState state,\n-        bool throw_monitor_exception,\n-        bool install_monitor_exception,\n-        bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -539,15 +539,0 @@\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-  br(Assembler::AL, fast_path);\n-  bind(slow_path);\n-  push(state);\n-  set_last_Java_frame(esp, rfp, (address)pc(), rscratch1);\n-  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n-  reset_last_Java_frame(true);\n-  pop(state);\n-  bind(fast_path);\n-\n@@ -671,1 +656,18 @@\n-  \/\/ jvmti support\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  br(Assembler::AL, fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(esp, rfp, pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n+\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n@@ -699,0 +701,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -739,2 +743,0 @@\n-  \/\/ restore sender esp\n-  mov(esp, rscratch2);\n@@ -743,0 +745,6 @@\n+\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n+  \/\/ restore sender esp\n+  mov(esp, rscratch2);\n+\n@@ -750,0 +758,13 @@\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(rthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  mov(rscratch1, true);\n+  strb(rscratch1, sampling_critical_section);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(rthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  strb(zr, sampling_critical_section);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":45,"deletions":24,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -339,0 +339,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2267,0 +2267,17 @@\n+  #if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ tbz(rscratch1, log2i_exact(SafepointMechanism::poll_bit()), L_return);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+    \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ adr(rscratch1, InternalAddress(poll_test_pc));\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1602,0 +1602,24 @@\n+  #if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ br(Assembler::AL, fast_path);\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(esp, rfp, __ pc(), rscratch1);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1624,0 +1648,2 @@\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1948,0 +1948,2 @@\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1959,0 +1961,3 @@\n+\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -541,1 +541,7 @@\n-    case Bytecodes::_i2d:\n+    case Bytecodes::_i2d:{\n+      FloatRegister rdst = dst->as_double_reg();\n+      \/\/ move src to dst register\n+      __ mtfprwa(rdst, src->as_register());\n+      __ fcfid(rdst, rdst);\n+      break;\n+    }\n@@ -543,14 +549,10 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n-      } else {\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2d) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      __ fcfid(rdst, rsrc);\n+      \/\/ move src to dst register\n+      __ mtfprd(rdst, src->as_register_lo());\n+      __ fcfid(rdst, rdst);\n+      break;\n+    }\n+    case Bytecodes::_i2f:{\n+      FloatRegister rdst = dst->as_float_reg();\n+      \/\/ move src to dst register\n+      __ mtfprwa(rdst, src->as_register());\n+      __ fcfids(rdst, rdst);\n@@ -560,21 +562,3 @@\n-    case Bytecodes::_i2f:\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n-      } else {\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2f) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      if (VM_Version::has_fcfids()) {\n-        __ fcfids(rdst, rsrc);\n-      } else {\n-        assert(code == Bytecodes::_i2f, \"fcfid+frsp needs fixup code to avoid rounding incompatibility\");\n-        __ fcfid(rdst, rsrc);\n-        __ frsp(rdst, rdst);\n-      }\n+      \/\/ move src to dst register\n+      __ mtfprd(rdst, src->as_register_lo());\n+      __ fcfids(rdst, rdst);\n@@ -595,2 +579,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -601,6 +583,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register(), 0);\n-      }\n+      __ li(dst->as_register(), 0);\n@@ -609,5 +586,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register(), rsrc);\n-      }\n+      __ mffprd(dst->as_register(), rsrc);\n@@ -619,2 +592,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -625,6 +596,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register_lo(), 0);\n-      }\n+      __ li(dst->as_register_lo(), 0);\n@@ -633,5 +599,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register_lo(), rsrc);\n-      }\n+      __ mffprd(dst->as_register_lo(), rsrc);\n@@ -1584,2 +1546,1 @@\n-  \/\/ Try to use isel on >=Power7.\n-  if (VM_Version::has_isel() && result->is_cpu_register()) {\n+  if (result->is_cpu_register()) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":25,"deletions":64,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  product(bool, SuperwordUseVSX, false,                                     \\\n+  product(bool, SuperwordUseVSX, true,                                      \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,6 +311,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mtfprd(d, l);\n-  } else {\n-    std(l, 0, R15_esp);\n-    lfd(d, 0, R15_esp);\n-  }\n+  mtfprd(d, l);\n@@ -320,6 +315,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mffprd(l, d);\n-  } else {\n-    stfd(d, 0, R15_esp);\n-    ld(l, 0, R15_esp);\n-  }\n+  mffprd(l, d);\n@@ -796,8 +786,11 @@\n-void InterpreterMacroAssembler::merge_frames(Register Rsender_sp, Register return_pc,\n-                                             Register Rscratch1, Register Rscratch2) {\n-  \/\/ Pop interpreter frame.\n-  ld(Rscratch1, 0, R1_SP); \/\/ *SP\n-  ld(Rsender_sp, _ijava_state_neg(sender_sp), Rscratch1); \/\/ top_frame_sp\n-  ld(Rscratch2, 0, Rscratch1); \/\/ **SP\n-  if (return_pc!=noreg) {\n-    ld(return_pc, _abi0(lr), Rscratch1); \/\/ LR\n+void InterpreterMacroAssembler::load_fp(Register fp) {\n+  ld(fp, _abi0(callers_sp), R1_SP); \/\/ *SP\n+}\n+\n+void InterpreterMacroAssembler::remove_top_frame_given_fp(Register fp, Register sender_sp, Register sender_fp,\n+                                                          Register return_pc, Register temp) {\n+  assert_different_registers(sender_sp, sender_fp, return_pc, temp);\n+  ld(sender_sp, _ijava_state_neg(sender_sp), fp);\n+  ld(sender_fp, _abi0(callers_sp), fp); \/\/ **SP\n+  if (return_pc != noreg) {\n+    ld(return_pc, _abi0(lr), fp); \/\/ last usage of fp, register can be reused\n@@ -805,0 +798,3 @@\n+  subf(temp, R1_SP, sender_sp);   \/\/ sender_sp - SP\n+  stdux(sender_fp, R1_SP, temp);  \/\/ atomically set *(SP = sender_sp) = sender_fp\n+}\n@@ -806,3 +802,5 @@\n-  \/\/ Merge top frames.\n-  subf(Rscratch1, R1_SP, Rsender_sp); \/\/ top_frame_sp - SP\n-  stdux(Rscratch2, R1_SP, Rscratch1); \/\/ atomically set *(SP = top_frame_sp) = **SP\n+void InterpreterMacroAssembler::merge_frames(Register sender_sp, Register return_pc,\n+                                             Register temp1, Register temp2) {\n+  Register fp = temp1, sender_fp = temp2;\n+  load_fp(fp);\n+  remove_top_frame_given_fp(fp, sender_sp, sender_fp, return_pc, \/* temp *\/ fp);\n@@ -867,0 +865,2 @@\n+  unlock_if_synchronized_method(state, throw_monitor_exception, install_monitor_exception);\n+\n@@ -870,2 +870,5 @@\n-  Label slow_path;\n-  Label fast_path;\n+  Label slow_path, fast_path;\n+  Register fp = R22_tmp2;\n+  load_fp(fp);\n+\n+  JFR_ONLY(enter_jfr_critical_section();)\n@@ -883,2 +886,0 @@\n-  unlock_if_synchronized_method(state, throw_monitor_exception, install_monitor_exception);\n-\n@@ -904,2 +905,1 @@\n-    ld_ptr(R11_scratch1, _abi0(callers_sp), R1_SP); \/\/ Load frame pointer.\n-    cmpld(CR0, R11_scratch1, R0);\n+    cmpld(CR0, fp, R0);\n@@ -908,0 +908,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -919,1 +921,1 @@\n-  merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n+  remove_top_frame_given_fp(fp, R21_sender_SP, R23_tmp3, \/*return_pc*\/ R0, R11_scratch1);\n@@ -922,0 +924,2 @@\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -925,0 +929,12 @@\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  li(R0, 1);\n+  stb(R0, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR), R16_thread);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  li(R0, 0);\n+  stb(R0, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR), R16_thread);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":46,"deletions":30,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -722,1 +722,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,47 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::interpreter_frame_bcp_offset]);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::return_addr_offset]);\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::interpreter_frame_sender_sp_offset]);\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp + frame::interpreter_frame_initial_sp_offset;\n+}\n+\n+inline intptr_t* frame::sender_sp(intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return fp + frame::sender_sp_offset;\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::link_offset]);\n+}\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(sp[-1]);\n+}\n+\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(sp[-2]);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -786,1 +786,0 @@\n-\/\/ Apply stack watermark barrier.\n@@ -789,0 +788,2 @@\n+\/\/ Apply stack watermark barrier.\n+\/\/ Notify JVMTI.\n@@ -798,6 +799,5 @@\n-void InterpreterMacroAssembler::remove_activation(\n-        TosState state,\n-        Register ret_addr,\n-        bool throw_monitor_exception,\n-        bool install_monitor_exception,\n-        bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  Register ret_addr,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -812,15 +812,0 @@\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n-  jmp(fast_path);\n-  bind(slow_path);\n-  push(state);\n-  set_last_Java_frame(noreg, rbp, (address)pc(), rscratch1);\n-  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n-  reset_last_Java_frame(true);\n-  pop(state);\n-  bind(fast_path);\n-\n@@ -948,1 +933,18 @@\n-  \/\/ jvmti support\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  jmp(fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(noreg, rbp, (address)pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), r15_thread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n+\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n@@ -970,0 +972,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -1018,0 +1022,1 @@\n+\n@@ -1019,0 +1024,3 @@\n+\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -1022,0 +1030,12 @@\n+\n+}\n+\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(r15_thread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  movbool(sampling_critical_section, true);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(r15_thread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  movbool(sampling_critical_section, false);\n@@ -1023,0 +1043,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -281,0 +281,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2703,0 +2703,17 @@\n+#if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ testb(Address(r15_thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n+  __ jccb(Assembler::zero, L_return);\n+  __ lea(rscratch1, InternalAddress(poll_test_pc));\n+  __ movptr(Address(r15_thread, JavaThread::saved_exception_pc_offset()), rscratch1);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+    \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1155,0 +1155,24 @@\n+#if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  __ jmp(fast_path);\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(noreg, rbp, (address)__ pc(), rscratch1);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), r15_thread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1177,0 +1201,3 @@\n+\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n@@ -1179,0 +1206,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1888,0 +1888,2 @@\n+      JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1902,0 +1904,1 @@\n+      JFR_ONLY(__ leave_jfr_critical_section();)\n@@ -1903,1 +1906,1 @@\n-      __ mov(rsp, sender_sp);                   \/\/ set sp to sender sp\n+      __ mov(rsp, sender_sp);                    \/\/ set sp to sender sp\n@@ -1907,3 +1910,0 @@\n-      \/\/ unlike x86 we need no specialized return from compiled code\n-      \/\/ to the interpreter or the call stub.\n-\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -923,0 +923,4 @@\n+\n+bool CDSConfig::is_dumping_adapters() {\n+  return (AOTAdapterCaching && is_dumping_final_static_archive());\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,0 +203,1 @@\n+  static bool is_dumping_adapters()                          NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-  if (specified_supertype->is_shared_unregistered_class()) {\n+  if (specified_supertype->defined_by_other_loaders()) {\n@@ -589,1 +589,1 @@\n-  assert(k->is_shared_unregistered_class(), \"must be\");\n+  assert(k->defined_by_other_loaders(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -806,1 +806,1 @@\n-      assert(InstanceKlass::cast(abk)->is_shared_boot_class(),\n+      assert(InstanceKlass::cast(abk)->defined_by_boot_loader(),\n@@ -1100,1 +1100,1 @@\n-    assert(k != nullptr && k->is_shared_boot_class(), \"sanity\");\n+    assert(k != nullptr && k->defined_by_boot_loader(), \"sanity\");\n@@ -1287,1 +1287,1 @@\n-  assert(k->is_shared_boot_class(), \"sanity\");\n+  assert(k->defined_by_boot_loader(), \"sanity\");\n@@ -1647,1 +1647,1 @@\n-  assert(k->is_shared_boot_class(), \"must be boot class\");\n+  assert(k->defined_by_boot_loader(), \"must be boot class\");\n@@ -1698,1 +1698,1 @@\n-  assert(k->is_shared_boot_class(), \"must be boot class\");\n+  assert(k->defined_by_boot_loader(), \"must be boot class\");\n@@ -1872,1 +1872,1 @@\n-    assert(InstanceKlass::cast(ik)->is_shared_boot_class(),\n+    assert(InstanceKlass::cast(ik)->defined_by_boot_loader(),\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-  if (AOTCodeCache::is_dumping_adapter()) {\n+  if (CDSConfig::is_dumping_adapters()) {\n@@ -738,1 +738,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared_unregistered_class()) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && ik->defined_by_other_loaders()) {\n@@ -1051,1 +1051,1 @@\n-    if (ik->is_shared_unregistered_class() && ik->class_loader() == nullptr) {\n+    if (ik->defined_by_other_loaders() && ik->class_loader() == nullptr) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5271,0 +5271,1 @@\n+  ik->set_class_loader_type();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1133,3 +1133,0 @@\n-#if INCLUDE_CDS\n-    result->set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n-#endif\n@@ -1213,1 +1210,1 @@\n-  if (ik->shared_classpath_index() == 0 && ik->is_shared_boot_class()) {\n+  if (ik->shared_classpath_index() == 0 && ik->defined_by_boot_loader()) {\n@@ -1223,1 +1220,0 @@\n-      ik->set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n@@ -1318,17 +1314,3 @@\n-  s2 classloader_type;\n-  if (HeapShared::is_lambda_form_klass(ik)) {\n-    classloader_type = ClassLoader::BOOT_LOADER;\n-  } else {\n-    oop loader = ik->class_loader();\n-\n-    if (loader == nullptr) {\n-      classloader_type = ClassLoader::BOOT_LOADER;\n-    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-      classloader_type = ClassLoader::PLATFORM_LOADER;\n-    } else if (SystemDictionary::is_system_class_loader(loader)) {\n-      classloader_type = ClassLoader::APP_LOADER;\n-    } else {\n-      \/\/ This class won't be archived, so no need to update its\n-      \/\/ classloader_type\/classpath_index.\n-      return;\n-    }\n+  if (ik->defined_by_other_loaders()) {\n+    \/\/ We don't archive hidden classes for non-builtin loaders.\n+    return;\n@@ -1336,1 +1318,0 @@\n-  ik->set_shared_class_loader_type(classloader_type);\n@@ -1345,1 +1326,1 @@\n-    if (classloader_type == ClassLoader::APP_LOADER) {\n+    if (ik->defined_by_app_loader()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -950,1 +950,1 @@\n-  if (ik->is_shared_boot_class()) {\n+  if (ik->defined_by_boot_loader()) {\n@@ -954,1 +954,1 @@\n-  } else if (ik->is_shared_platform_class()) {\n+  } else if (ik->defined_by_platform_loader()) {\n@@ -958,1 +958,1 @@\n-  } else if (ik->is_shared_app_class()) {\n+  } else if (ik->defined_by_app_loader()) {\n@@ -988,1 +988,1 @@\n-  assert(!ik->is_shared_unregistered_class(), \"this function should be called for built-in classes only\");\n+  assert(!ik->defined_by_other_loaders(), \"this function should be called for built-in classes only\");\n@@ -1050,1 +1050,1 @@\n-  if (!super_type->is_shared_unregistered_class() && super_type->class_loader_data() != nullptr) {\n+  if (!super_type->defined_by_other_loaders() && super_type->class_loader_data() != nullptr) {\n@@ -1344,1 +1344,1 @@\n-      if (ik != nullptr && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+      if (ik != nullptr && ik->defined_by_boot_loader() && !ik->shared_loading_failed()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+  \/\/ Disable stubs caching until JDK-8357398 is fixed.\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+\n@@ -902,1 +905,2 @@\n-  log_debug(aot, codecache, stubs)(\"Read blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n+  log_debug(aot, codecache, stubs)(\"%sRead blob '%s' (id=%u, kind=%s) from AOT Code Cache\",\n+                                   (blob == nullptr? \"Failed to \" : \"\"), name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -917,2 +921,1 @@\n-    ((AOTCodeCache*)_cache)->set_failed();\n-    report_load_failure();\n+    set_lookup_failed(); \/\/ Skip this blob\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -396,1 +396,3 @@\n-    return (pc-1)->pc_offset() < pc_offset && pc_offset <= pc->pc_offset();\n+    \/\/ Do not look before the sentinel\n+    assert(pc_offset > PcDesc::lower_offset_limit, \"illegal pc_offset\");\n+    return pc_offset <= pc->pc_offset() && (pc-1)->pc_offset() < pc_offset;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers),\n+    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers, ParGCArrayScanChunk),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads),\n+  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads, ObjArrayMarkingStride),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -668,1 +668,1 @@\n-  heap->print_heap_before_gc();\n+  heap->print_before_gc();\n@@ -1171,1 +1171,1 @@\n-  heap->print_heap_after_gc();\n+  heap->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n+  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads, ParGCArrayScanChunk)\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+class GCMemoryManager;\n+class GCMetaspaceLog;\n@@ -53,1 +55,0 @@\n-class GCMemoryManager;\n@@ -97,1 +98,2 @@\n-  GCHeapLog* _gc_heap_log;\n+  GCHeapLog*      _heap_log;\n+  GCMetaspaceLog* _metaspace_log;\n@@ -424,0 +426,2 @@\n+  void print_relative_to_gc(GCWhen::Type when) const;\n+\n@@ -439,0 +443,2 @@\n+  void print_invocation_on(outputStream* st, const char* type, GCWhen::Type when) const;\n+\n@@ -458,2 +464,2 @@\n-  void print_heap_before_gc();\n-  void print_heap_after_gc();\n+  void print_before_gc() const;\n+  void print_after_gc() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-  bool                _tlab_end_reset_for_sample;\n@@ -77,2 +76,1 @@\n-      _allocated_tlab_size(0),\n-      _tlab_end_reset_for_sample(false)\n+      _allocated_tlab_size(0)\n@@ -177,5 +175,2 @@\n-  if (!_allocated_outside_tlab && _allocated_tlab_size == 0 && !_tlab_end_reset_for_sample) {\n-    \/\/ Sample if it's a non-TLAB allocation, or a TLAB allocation that either refills the TLAB\n-    \/\/ or expands it due to taking a sampler induced slow path.\n-    return;\n-  }\n+  ThreadHeapSampler& heap_sampler = _thread->heap_sampler();\n+  ThreadLocalAllocBuffer& tlab = _thread->tlab();\n@@ -183,4 +178,2 @@\n-  \/\/ If we want to be sampling, protect the allocated object with a Handle\n-  \/\/ before doing the callback. The callback is done in the destructor of\n-  \/\/ the JvmtiSampledObjectAllocEventCollector.\n-  size_t bytes_since_last = 0;\n+  \/\/ Log sample decision\n+  heap_sampler.log_sample_decision(tlab.top());\n@@ -188,1 +181,4 @@\n-  {\n+  if (heap_sampler.should_sample(tlab.top())) {\n+    \/\/ If we want to be sampling, protect the allocated object with a Handle\n+    \/\/ before doing the callback. The callback is done in the destructor of\n+    \/\/ the JvmtiSampledObjectAllocEventCollector.\n@@ -191,5 +187,2 @@\n-    size_t size_in_bytes = _allocator._word_size * HeapWordSize;\n-    ThreadLocalAllocBuffer& tlab = _thread->tlab();\n-    if (!_allocated_outside_tlab) {\n-      bytes_since_last = tlab.bytes_since_last_sample_point();\n-    }\n+    \/\/ Perform the sampling\n+    heap_sampler.sample(obj_h(), tlab.top());\n@@ -198,1 +191,3 @@\n-    _thread->heap_sampler().check_for_sampling(obj_h(), size_in_bytes, bytes_since_last);\n+    \/\/ Note that after this point all the TLAB can have been retired, and agent\n+    \/\/ code can run and allocate, don't rely on earlier calculations involving\n+    \/\/ the TLAB.\n@@ -201,3 +196,4 @@\n-  if (_tlab_end_reset_for_sample || _allocated_tlab_size != 0) {\n-    \/\/ Tell tlab to forget bytes_since_last if we passed it to the heap sampler.\n-    _thread->tlab().set_sample_end(bytes_since_last != 0);\n+  \/\/ Set a new sampling point in the TLAB if it fits in the current TLAB\n+  const size_t words_until_sample = heap_sampler.bytes_until_sample(tlab.top()) \/ HeapWordSize;\n+  if (words_until_sample <= tlab.free()) {\n+    tlab.set_sampling_point(tlab.top() + words_until_sample);\n@@ -252,0 +248,1 @@\n+  _thread->heap_sampler().inc_outside_tlab_bytes(size_in_bytes);\n@@ -265,0 +262,6 @@\n+    \/\/ When sampling we artificially set the TLAB end to the sample point.\n+    \/\/ When we hit that point it looks like the TLAB is full, but it's\n+    \/\/ not necessarily the case. Set the real end and retry the allocation.\n+\n+    \/\/ Undo previous adjustment of end.\n+    \/\/ Note that notify_allocation_jvmti_sampler will set a new sample point.\n@@ -266,4 +269,2 @@\n-    mem = tlab.allocate(_word_size);\n-    \/\/ We set back the allocation sample point to try to allocate this, reset it\n-    \/\/ when done.\n-    allocation._tlab_end_reset_for_sample = true;\n+    \/\/ Retry the TLAB allocation with the proper end\n+    mem = tlab.allocate(_word_size);\n@@ -285,0 +286,7 @@\n+\n+  \/\/ Record the amount wasted\n+  tlab.record_refill_waste();\n+\n+  \/\/ Retire the current TLAB\n+  _thread->retire_tlab();\n+\n@@ -288,2 +296,0 @@\n-  tlab.retire_before_allocation();\n-\n@@ -320,1 +326,2 @@\n-  tlab.fill(mem, mem + _word_size, allocation._allocated_tlab_size);\n+  _thread->fill_tlab(mem, _word_size, allocation._allocated_tlab_size);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":36,"deletions":29,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -83,0 +83,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.inline.hpp\"\n+#endif\n@@ -1303,0 +1306,1 @@\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-    if (src_holder->is_shared_unregistered_class()) {\n+    if (src_holder->defined_by_other_loaders()) {\n@@ -488,7 +488,6 @@\n-    oop loader = src_ik->class_loader();\n-    if (loader == nullptr) {\n-      type = \"boot\";\n-    } else if (loader == SystemDictionary::java_platform_loader()) {\n-      type = \"plat\";\n-    } else if (loader == SystemDictionary::java_system_loader()) {\n-      type = \"app\";\n+    if (src_ik->defined_by_boot_loader()) {\n+      return \"boot\";\n+    } else if (src_ik->defined_by_platform_loader()) {\n+      return \"plat\";\n+    } else if (src_ik->defined_by_app_loader()) {\n+      return \"app\";\n@@ -496,1 +495,1 @@\n-      type = \"unreg\";\n+      return \"unreg\";\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -542,2 +542,1 @@\n-  if (!(pool_holder->is_shared_boot_class() || pool_holder->is_shared_platform_class() ||\n-        pool_holder->is_shared_app_class())) {\n+  if (pool_holder->defined_by_other_loaders()) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3037,1 +3037,1 @@\n-    if (is_shared_unregistered_class()) {\n+    if (defined_by_other_loaders()) {\n@@ -3149,11 +3149,0 @@\n-int InstanceKlass::shared_class_loader_type() const {\n-  if (is_shared_boot_class()) {\n-    return ClassLoader::BOOT_LOADER;\n-  } else if (is_shared_platform_class()) {\n-    return ClassLoader::PLATFORM_LOADER;\n-  } else if (is_shared_app_class()) {\n-    return ClassLoader::APP_LOADER;\n-  } else {\n-    return ClassLoader::OTHER;\n-  }\n-}\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -378,6 +378,6 @@\n-  \/\/ The three BUILTIN class loader types\n-  bool is_shared_boot_class() const { return _misc_flags.is_shared_boot_class(); }\n-  bool is_shared_platform_class() const { return _misc_flags.is_shared_platform_class(); }\n-  bool is_shared_app_class() const {  return _misc_flags.is_shared_app_class(); }\n-  \/\/ The UNREGISTERED class loader type\n-  bool is_shared_unregistered_class() const { return _misc_flags.is_shared_unregistered_class(); }\n+  \/\/ Quick checks for the loader that defined this class (without switching on this->class_loader())\n+  bool defined_by_boot_loader() const      { return _misc_flags.defined_by_boot_loader(); }\n+  bool defined_by_platform_loader() const  { return _misc_flags.defined_by_platform_loader(); }\n+  bool defined_by_app_loader() const       { return _misc_flags.defined_by_app_loader(); }\n+  bool defined_by_other_loaders() const    { return _misc_flags.defined_by_other_loaders(); }\n+  void set_class_loader_type()             { _misc_flags.set_class_loader_type(_class_loader_data); }\n@@ -392,6 +392,0 @@\n-#if INCLUDE_CDS\n-  int  shared_class_loader_type() const;\n-  void set_shared_class_loader_type(s2 loader_type) { _misc_flags.set_shared_class_loader_type(loader_type); }\n-  void assign_class_loader_type() { _misc_flags.assign_class_loader_type(_class_loader_data); }\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,3 @@\n-    flag(is_shared_boot_class               , 1 << 7) \/* defining class loader is boot class loader *\/ \\\n-    flag(is_shared_platform_class           , 1 << 8) \/* defining class loader is platform class loader *\/ \\\n-    flag(is_shared_app_class                , 1 << 9) \/* defining class loader is app class loader *\/ \\\n+    flag(defined_by_boot_loader             , 1 << 7) \/* defining class loader is boot class loader *\/ \\\n+    flag(defined_by_platform_loader         , 1 << 8) \/* defining class loader is platform class loader *\/ \\\n+    flag(defined_by_app_loader              , 1 << 9) \/* defining class loader is app class loader *\/ \\\n@@ -90,2 +90,2 @@\n-  u2 shared_loader_type_bits() const {\n-    return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;\n+  u2 builtin_loader_type_bits() const {\n+    return _misc_defined_by_boot_loader|_misc_defined_by_platform_loader|_misc_defined_by_app_loader;\n@@ -114,2 +114,2 @@\n-  bool is_shared_unregistered_class() const {\n-    return (_flags & shared_loader_type_bits()) == 0;\n+  bool defined_by_other_loaders() const {\n+    return (_flags & builtin_loader_type_bits()) == 0;\n@@ -118,1 +118,1 @@\n-  void set_shared_class_loader_type(s2 loader_type);\n+  void set_class_loader_type(const ClassLoaderData* cld);\n@@ -120,1 +120,0 @@\n-  void assign_class_loader_type(const ClassLoaderData* cld);\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-        assert(InstanceKlass::cast(this)->is_shared_unregistered_class(), \"sanity\");\n+        assert(InstanceKlass::cast(this)->defined_by_other_loaders(), \"sanity\");\n@@ -822,1 +822,1 @@\n-        assert(InstanceKlass::cast(k)->is_shared_unregistered_class(), \"sanity\");\n+        assert(InstanceKlass::cast(k)->defined_by_other_loaders(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  set_adapter_entry(nullptr);\n@@ -420,1 +421,1 @@\n-  if (AOTCodeCache::is_dumping_adapter() && _adapter != nullptr) {\n+  if (CDSConfig::is_dumping_adapters() && _adapter != nullptr) {\n@@ -422,0 +423,1 @@\n+    _adapter = nullptr;\n@@ -1191,1 +1193,1 @@\n-  if (!AOTCodeCache::is_dumping_adapter() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+  if (!CDSConfig::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -378,0 +378,12 @@\n+  product(uint, AutoVectorizationOverrideProfitability, 1, DIAGNOSTIC,      \\\n+          \"Override the auto vectorization profitability heuristics.\"       \\\n+          \"0 = Run auto vectorizer, but abort just before applying\"         \\\n+          \"    vectorization, as though it was not profitable.\"             \\\n+          \"1 = Run auto vectorizer with the default profitability\"          \\\n+          \"    heuristics. This is the default, and hopefully\"              \\\n+          \"    delivers the best performance.\"                              \\\n+          \"2 = Run auto vectorizer, and vectorize even if the\"              \\\n+          \"    profitability heuristics predict that vectorization\"         \\\n+          \"    is not profitable.\")                                         \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2316,8 +2316,4 @@\n-            if (arg_ptn != src_ptn) {\n-              \/\/ Special arraycopy edge:\n-              \/\/ A destination object's field can't have the source object\n-              \/\/ as base since objects escape states are not related.\n-              \/\/ Only escape state of destination object's fields affects\n-              \/\/ escape state of fields in source object.\n-              add_arraycopy(call, es, src_ptn, arg_ptn);\n-            }\n+            \/\/ Special arraycopy edge:\n+            \/\/ Only escape state of destination object's fields affects\n+            \/\/ escape state of fields in source object.\n+            add_arraycopy(call, es, src_ptn, arg_ptn);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -990,2 +990,3 @@\n-      \/\/ A test which leads to an uncommon trap which should be safe.\n-      \/\/ Later this trap will be converted into a trap that restarts\n+      \/\/ A test which leads to an uncommon trap. It is safe to convert the trap\n+      \/\/ into a trap that restarts at the beginning as long as its test does not\n+      \/\/ depend on intermediate results of the candidate chain.\n@@ -996,0 +997,8 @@\n+          \/\/ First check for dependency on a toString that is going away during stacked concats.\n+          if (_multiple &&\n+              ((v1->is_Proj() && is_SB_toString(v1->in(0)) && ctrl_path.member(v1->in(0))) ||\n+               (v2->is_Proj() && is_SB_toString(v2->in(0)) && ctrl_path.member(v2->in(0))))) {\n+            \/\/ iftrue -> if -> bool -> cmpp -> resproj -> tostring\n+            fail = true;\n+            break;\n+          }\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-    size_t nr = g1h->max_regions();\n+    size_t nr = g1h->max_num_regions();\n@@ -2622,0 +2622,5 @@\n+\/\/ Available memory of the host machine (container-aware)\n+WB_ENTRY(jlong, WB_HostAvailableMemory(JNIEnv* env, jobject o))\n+  return os::available_memory();\n+WB_END\n+\n@@ -3097,0 +3102,1 @@\n+  {CC\"hostAvailableMemory\",       CC\"()J\",            (void*)&WB_HostAvailableMemory },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+#include \"jfr\/jfr.inline.hpp\"\n@@ -504,0 +505,1 @@\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+}\n@@ -237,0 +238,7 @@\n+\/\/ This is optimized for intra-blob pc adjustments only.\n+void frame::adjust_pc(address newpc) {\n+  assert(_cb != nullptr, \"invariant\");\n+  assert(_cb == CodeCache::find_blob(newpc), \"invariant\");\n+  \/\/ Unsafe to use the is_deoptimized tester after changing pc\n+  _deopt_state = unknown;\n+  _pc = newpc;\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,1 @@\n+  void adjust_pc(address newpc);\n@@ -509,0 +510,12 @@\n+#if INCLUDE_JFR\n+  \/\/ Static helper routines\n+  static address interpreter_bcp(const intptr_t* fp);\n+  static address interpreter_return_address(const intptr_t* fp);\n+  static intptr_t* interpreter_sender_sp(const intptr_t* fp);\n+  static bool is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp);\n+  static intptr_t* sender_sp(intptr_t* fp);\n+  static intptr_t* link(const intptr_t* fp);\n+  static address return_address(const intptr_t* sp);\n+  static intptr_t* fp(const intptr_t* sp);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+  product(bool, UseCompactObjectHeaders, false,                             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -972,1 +972,1 @@\n-    tlab().retire();\n+    retire_tlab();\n@@ -1046,1 +1046,1 @@\n-    tlab().retire();\n+    retire_tlab();\n@@ -1082,1 +1082,0 @@\n-  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,0 @@\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n@@ -231,2 +230,0 @@\n-  inline void set_trace_flag();\n-  inline void clear_trace_flag();\n@@ -235,1 +232,0 @@\n-  bool is_trace_suspend()      { return (_suspend_flags & _trace_flag) != 0; }\n@@ -755,1 +751,1 @@\n-    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+    return (_suspend_flags & _obj_deopt) != 0;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-#include \"jfr\/jfr.hpp\"\n+#include \"jfr\/jfr.inline.hpp\"\n@@ -449,1 +449,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n@@ -2528,1 +2528,1 @@\n-  if (!AOTCodeCache::is_dumping_adapter()) {\n+  if (AOTCodeCache::is_using_adapter()) {\n@@ -2637,1 +2637,1 @@\n-  if (!_aot_adapter_handler_table.empty()) {\n+  if (AOTCodeCache::is_using_adapter() && !_aot_adapter_handler_table.empty()) {\n@@ -3435,0 +3435,1 @@\n+  assert(AOTCodeCache::is_using_adapter(), \"AOT adapters code should be available\");\n@@ -3761,1 +3762,1 @@\n-\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n@@ -3856,4 +3857,6 @@\n-  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n-    return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n-  };\n-  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  if (AOTCodeCache::is_using_adapter()) {\n+    auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+      return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n+    };\n+    _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  }\n@@ -3883,12 +3886,13 @@\n-  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n-    if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n-      found = true;\n-      st->print(\"Adapter for signature: \");\n-      handler->print_adapter_on(st);\n-      return true;\n-    } else {\n-      return false; \/\/ keep looking\n-\n-    }\n-  };\n-  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  if (AOTCodeCache::is_using_adapter()) {\n+    auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+      if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n+        found = true;\n+        st->print(\"Adapter for signature: \");\n+        handler->print_adapter_on(st);\n+        return true;\n+      } else {\n+        return false; \/\/ keep looking\n+      }\n+    };\n+    _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -839,1 +839,1 @@\n-    JVMCI::initialize_compiler(CHECK_JNI_ERR);\n+    JVMCI::initialize_compiler_in_create_vm(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -417,1 +417,0 @@\n-  MetaspaceUtils::print_on(output());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -411,0 +411,3 @@\n+  GrowableArrayWithAllocator(E* data, int capacity, int initial_len) :\n+    GrowableArrayView<E>(data, capacity, initial_len) {}\n+\n@@ -792,0 +795,9 @@\n+  \/\/ This constructor performs no default initialization, so be careful.\n+  GrowableArray(int initial_capacity, int initial_len, MemTag mem_tag) :\n+    GrowableArrayWithAllocator<E, GrowableArray>(\n+      allocate(initial_capacity, mem_tag),\n+      initial_capacity, initial_len),\n+    _metadata(mem_tag) {\n+    init_checks();\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4062,1 +4062,1 @@\n-        return isArray() ? componentType : null;\n+        return getComponentType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-    static final char[] digits = {\n+    @Stable\n+    static final byte[] digits = {\n@@ -185,1 +186,1 @@\n-                buf[charPos--] = (byte)digits[-(i % radix)];\n+                buf[charPos--] = digits[-(i % radix)];\n@@ -188,1 +189,1 @@\n-            buf[charPos] = (byte)digits[-i];\n+            buf[charPos] = digits[-i];\n@@ -405,1 +406,1 @@\n-            buf[--charPos] = (byte)Integer.digits[val & mask];\n+            buf[--charPos] = Integer.digits[val & mask];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                buf[charPos--] = (byte)Integer.digits[(int)(-(i % radix))];\n+                buf[charPos--] = Integer.digits[(int)(-(i % radix))];\n@@ -174,1 +174,1 @@\n-            buf[charPos] = (byte)Integer.digits[(int)(-i)];\n+            buf[charPos] = Integer.digits[(int)(-i)];\n@@ -436,1 +436,1 @@\n-            buf[--charPos] = (byte)Integer.digits[((int) val) & mask];\n+            buf[--charPos] = Integer.digits[((int) val) & mask];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2829,1 +2829,1 @@\n-         *     {@linkplain Module#reads reads} {@code M0} and the type is\n+         *     {@linkplain Module#canRead(Module)}  reads} {@code M0} and the type is\n@@ -2832,1 +2832,1 @@\n-         *     {@linkplain Module#reads reads} {@code M1} and the type is\n+         *     {@linkplain Module#canRead(Module)}  reads} {@code M1} and the type is\n@@ -4897,1 +4897,1 @@\n-     * @see MethodHandles#primitiveZero\n+     * @see MethodHandles#zero(Class)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -549,1 +549,5 @@\n-                    if (unconditionalExactnessCheck(selectorType, classLabel)) {\n+                    if (isNotValidPair(selectorType, caseLabel)){\n+                        cb.goto_(next);\n+                        continue;\n+                    }\n+                    else if (unconditionalExactnessCheck(selectorType, classLabel)) {\n@@ -720,0 +724,5 @@\n+    private static boolean isNotValidPair(Class<?> selectorType, Object caseLabel) {\n+        return (selectorType == boolean.class && caseLabel != boolean.class && caseLabel != Boolean.class) ||\n+               (selectorType != boolean.class && selectorType.isPrimitive() && (caseLabel == boolean.class || caseLabel == Boolean.class));\n+    }\n+\n@@ -772,5 +781,5 @@\n-                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n-                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n-                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n-                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n-                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n+                (targetType.isPrimitive() && selectorType.isPrimitive() &&\n+                    (selectorWrapper.isStrictSubRangeOf(targetWrapper) &&\n+                            !((selectorType.equals(byte.class) && targetType.equals(char.class)) ||\n+                              (selectorType.equals(int.class)  && targetType.equals(float.class)) ||\n+                              (selectorType.equals(long.class) && (targetType.equals(double.class) || targetType.equals(float.class))))))) return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -418,0 +418,5 @@\n+    \/**\n+     * Flag to indicate parameters that require identity.\n+     *\/\n+    public static final long REQUIRES_IDENTITY = 1L<<62; \/\/ VarSymbols (parameters)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -991,1 +991,2 @@\n-                        anno.position.parameter_index == index;\n+                        anno.position.parameter_index == index &&\n+                        anno.type.tsym.flatName() != name.table.names.requiresIdentityInternal;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -395,0 +395,6 @@\n+        return enterSyntheticAnnotation(names.fromString(name));\n+    }\n+\n+    \/\/ Enter a synthetic class that is used to mark classes in ct.sym.\n+    \/\/ This class does not have a class file.\n+    private Type enterSyntheticAnnotation(Name name) {\n@@ -397,1 +403,1 @@\n-        ClassType type = (ClassType)enterClass(java_base, names.fromString(name)).type;\n+        ClassType type = (ClassType)enterClass(java_base, name).type;\n@@ -632,1 +638,1 @@\n-        requiresIdentityInternalType = enterSyntheticAnnotation(\"jdk.internal.RequiresIdentity+Annotation\");\n+        requiresIdentityInternalType = enterSyntheticAnnotation(names.requiresIdentityInternal);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5111,10 +5111,6 @@\n-        if (isSameType(selectorType, targetType)) {\n-            return true;\n-        }\n-\n-        return (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n-                ((selectorType.hasTag(BYTE) && !targetType.hasTag(CHAR)) ||\n-                 (selectorType.hasTag(SHORT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))) ||\n-                 (selectorType.hasTag(CHAR)  && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag())))  ||\n-                 (selectorType.hasTag(INT)   && (targetType.hasTag(DOUBLE) || targetType.hasTag(LONG))) ||\n-                 (selectorType.hasTag(FLOAT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))));\n+        return isSameType(selectorType, targetType) ||\n+                (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n+                ((selectorType.getTag().isStrictSubRangeOf(targetType.getTag())) &&\n+                        !((selectorType.hasTag(BYTE) && targetType.hasTag(CHAR)) ||\n+                          (selectorType.hasTag(INT)  && targetType.hasTag(FLOAT)) ||\n+                          (selectorType.hasTag(LONG) && (targetType.hasTag(DOUBLE) || targetType.hasTag(FLOAT)))));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -402,0 +402,6 @@\n+\n+            if (!c.type.isErroneous()\n+                    && toAnnotate.kind == VAR\n+                    && types.isSameType(c.type, syms.requiresIdentityType)) {\n+                toAnnotate.flags_field |= Flags.REQUIRES_IDENTITY;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5890,1 +5890,1 @@\n-                            if (param.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                            if ((param.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n@@ -5897,1 +5897,1 @@\n-                            if (lastParam.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                            if ((lastParam.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n@@ -5974,1 +5974,1 @@\n-                            .filter(ta -> ta.type.tsym == syms.requiresIdentityType.tsym &&\n+                            .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym) &&\n@@ -5999,1 +5999,1 @@\n-                        .filter(ta -> (ta.type.tsym == syms.requiresIdentityType.tsym) &&\n+                        .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym) &&\n@@ -6006,0 +6006,5 @@\n+\n+    private boolean isRequiresIdentityAnnotation(TypeSymbol annoType) {\n+        return annoType == syms.requiresIdentityType.tsym ||\n+               annoType.flatName() == syms.requiresIdentityInternalType.tsym.flatName();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1577,0 +1577,3 @@\n+            } else if (proxy.type.tsym.flatName() == syms.requiresIdentityInternalType.tsym.flatName()) {\n+                Assert.check(sym.kind == VAR);\n+                sym.flags_field |= REQUIRES_IDENTITY;\n@@ -1599,0 +1602,3 @@\n+                }  else if (proxy.type.tsym == syms.requiresIdentityType.tsym) {\n+                    Assert.check(sym.kind == VAR);\n+                    sym.flags_field |= REQUIRES_IDENTITY;\n@@ -2836,3 +2842,2 @@\n-                if (annotations != null && annotations.proxies != null\n-                        && !annotations.proxies.isEmpty()) {\n-                    annotate.normal(new AnnotationCompleter(param, annotations.proxies));\n+                if (annotations != null && annotations.proxies != null) {\n+                    attachAnnotations(param, annotations.proxies);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -237,0 +237,3 @@\n+    \/\/ special annotation names\n+    public final Name requiresIdentityInternal;\n+\n@@ -425,0 +428,3 @@\n+\n+        \/\/ special annotations:\n+        requiresIdentityInternal = fromString(\"jdk.internal.RequiresIdentity+Annotation\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,6 +94,0 @@\n-gc\/TestAlwaysPreTouchBehavior.java#ParallelCollector 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#SerialCollector 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Shenandoah 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#G1 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Z 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Epsilon 8334513 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-            args.add(\"-XX:+UnlockExperimentalVMOptions\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AccessZeroNKlassHitsProtectionZone.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java 8341370 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -408,1 +408,0 @@\n-    java\/foreign\/TestMatrix.java \\\n@@ -640,1 +639,0 @@\n-    jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java \\\n@@ -647,1 +645,2 @@\n-    javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataUtil.java \n+    javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataUtil.java \\\n+    java\/util\/zip\/ZipFile\/CenSizeMaximum.java\n@@ -671,1 +670,3 @@\n-    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java \\\n+    java\/foreign\/TestMatrix.java \\\n+    java\/nio\/channels\/FileChannel\/BlockDeviceSize.java\n","filename":"test\/jdk\/TEST.groups","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,13 @@\n+\/**\n+ * @test\n+ * @bug 8072480 8277106 8331027\n+ * @summary Unit test for CreateSymbols\n+ * @modules java.compiler\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @clean *\n+ * @run main\/othervm CreateSymbolsTest\n+ *\/\n+\n@@ -911,0 +924,103 @@\n+    @Test\n+    void testTypeAnnotations() throws Exception {\n+        doPrintElementTest(\"\"\"\n+                           package t;\n+                           public class T {\n+                           }\n+                           \"\"\",\n+                           \"\"\"\n+                           package t;\n+                           import java.lang.annotation.*;\n+                           import java.util.*;\n+                           public class T<@AnnInvisible @AnnVisible E extends @AnnInvisible @AnnVisible ArrayList<@AnnInvisible @AnnVisible ArrayList>> extends @AnnInvisible @AnnVisible ArrayList {\n+                               public @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible E> field;\n+                               public <@AnnInvisible @AnnVisible M extends @AnnInvisible @AnnVisible ArrayList<@AnnInvisible @AnnVisible ArrayList>> @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible M> convert(@AnnInvisible @AnnVisible T<E> this, @AnnInvisible @AnnVisible M e1, @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible E> e2) throws @AnnInvisible @AnnVisible IllegalStateException, @AnnInvisible @AnnVisible IllegalArgumentException {\n+                                   return null;\n+                               }\n+                           }\n+                           @Retention(RetentionPolicy.RUNTIME)\n+                           @Target(ElementType.TYPE_USE)\n+                           @interface AnnVisible {\n+                           }\n+                           @Retention(RetentionPolicy.CLASS)\n+                           @Target(ElementType.TYPE_USE)\n+                           @interface AnnInvisible {\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T<@t.AnnInvisible @t.AnnVisible E extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList<java.util.@t.AnnInvisible @t.AnnVisible ArrayList>> extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList {\n+                             public java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible E> field;\n+\n+                             public T();\n+\n+                             public <@t.AnnInvisible @t.AnnVisible M extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList<java.util.@t.AnnInvisible @t.AnnVisible ArrayList>> java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible M> convert(@t.AnnInvisible @t.AnnVisible M arg0,\n+                               java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible E> arg1) throws java.lang.@t.AnnInvisible @t.AnnVisible IllegalStateException,\\s\n+                               java.lang.@t.AnnInvisible @t.AnnVisible IllegalArgumentException;\n+                           }\n+                           \"\"\");\n+    }\n+\n+    @Test\n+    void testParameterAnnotations() throws Exception {\n+        doPrintElementTest(\"\"\"\n+                           package t;\n+                           public class T {\n+                               public void test(int p1, int p2) {\n+                               }\n+                           }\n+                           \"\"\",\n+                           \"\"\"\n+                           package t;\n+                           import java.lang.annotation.*;\n+                           import java.util.*;\n+                           public class T {\n+                               public void test(@AnnVisible int p1, @AnnInvisible int p2) {\n+                               }\n+                           }\n+                           @Retention(RetentionPolicy.RUNTIME)\n+                           @Target(ElementType.PARAMETER)\n+                           @interface AnnVisible {\n+                           }\n+                           @Retention(RetentionPolicy.CLASS)\n+                           @Target(ElementType.PARAMETER)\n+                           @interface AnnInvisible {\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+\n+                             public void test(int arg0,\n+                               int arg1);\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+\n+                             public void test(@t.AnnVisible int arg0,\n+                               @t.AnnInvisible int arg1);\n+                           }\n+                           \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":117,"deletions":1,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -833,0 +833,1 @@\n+  public native long hostAvailableMemory();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}