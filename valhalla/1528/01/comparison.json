{"files":[{"patch":"@@ -35,0 +35,3 @@\n+  static-suffix:\n+    description: 'Static bundle file name suffix'\n+    required: false\n@@ -39,0 +42,3 @@\n+  static-jdk-path:\n+    description: 'Path to the installed static JDK bundle'\n+    value: ${{ steps.path-name.outputs.static_jdk }}\n@@ -64,0 +70,9 @@\n+    - name: 'Download static bundles artifact'\n+      id: download-static-bundles\n+      uses: actions\/download-artifact@v4\n+      with:\n+        name: bundles-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}\n+        path: bundles\n+      continue-on-error: true\n+      if: ${{ inputs.static-suffix == '-static' }}\n+\n@@ -78,0 +93,14 @@\n+        if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+          if [[ -e bundles\/jdk-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}.zip ]]; then\n+            echo 'Unpacking static jdk bundle...'\n+            mkdir -p bundles\/static-jdk\n+            unzip -q bundles\/jdk-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}.zip -d bundles\/static-jdk\n+          fi\n+\n+          if [[ -e bundles\/jdk-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}.tar.gz ]]; then\n+            echo 'Unpacking static jdk bundle...'\n+            mkdir -p bundles\/static-jdk\n+            tar -xf bundles\/jdk-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}.tar.gz -C bundles\/static-jdk\n+          fi\n+        fi\n+\n@@ -109,0 +138,8 @@\n+\n+        if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+          static_jdk_dir=\"$GITHUB_WORKSPACE\/$(dirname $(find bundles\/static-jdk -name bin -type d))\"\n+          if [[ '${{ runner.os }}' == 'Windows' ]]; then\n+            static_jdk_dir=\"$(cygpath $static_jdk_dir)\"\n+          fi\n+          echo \"static_jdk=$static_jdk_dir\" >> $GITHUB_OUTPUT\n+        fi\n","filename":".github\/actions\/get-bundles\/action.yml","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+  static-suffix:\n+    description: 'Static JDK bundle name suffix, possibly empty'\n+    required: false\n@@ -49,0 +52,2 @@\n+        static_jdk_bundle_zip=\"$(ls build\/*\/bundles\/static-jdk-*_bin${{ inputs.debug-suffix }}.zip 2> \/dev\/null || true)\"\n+        static_jdk_bundle_tar_gz=\"$(ls build\/*\/bundles\/static-jdk-*_bin${{ inputs.debug-suffix }}.tar.gz 2> \/dev\/null || true)\"\n@@ -61,0 +66,6 @@\n+        if [[ \"$static_jdk_bundle_zip\" != \"\" ]]; then\n+          mv \"$static_jdk_bundle_zip\" \"bundles\/jdk-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}.zip\"\n+        fi\n+        if [[ \"$static_jdk_bundle_tar_gz\" != \"\" ]]; then\n+          mv \"$static_jdk_bundle_tar_gz\" \"bundles\/jdk-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}.tar.gz\"\n+        fi\n@@ -71,1 +82,1 @@\n-        if [[ \"$jdk_bundle_zip$jdk_bundle_tar_gz$symbols_bundle$tests_bundle$static_libs_bundle\" != \"\" ]]; then\n+        if [[ \"$jdk_bundle_zip$jdk_bundle_tar_gz$static_jdk_bundle_zip$static_jdk_bundle_tar_gz$symbols_bundle$tests_bundle$static_libs_bundle\" != \"\" ]]; then\n@@ -81,1 +92,1 @@\n-        name: bundles-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.bundle-suffix }}\n+        name: bundles-${{ inputs.platform }}${{ inputs.debug-suffix }}${{ inputs.static-suffix }}${{ inputs.bundle-suffix }}\n","filename":".github\/actions\/upload-bundles\/action.yml","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+      static-suffix:\n+        required: false\n+        type: string\n@@ -146,0 +149,1 @@\n+          static-suffix: ${{ inputs.static-suffix }}\n","filename":".github\/workflows\/build-linux.yml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-      make-target: 'static-jdk-image'\n+      make-target: 'static-jdk-bundles'\n@@ -241,3 +241,1 @@\n-      # It currently doesn't produce any bundles, but probably will do in\n-      # the future.\n-      bundle-suffix: \"-static\"\n+      static-suffix: \"-static\"\n@@ -364,0 +362,13 @@\n+      debug-suffix: -debug\n+\n+  test-linux-x64-static:\n+    name: linux-x64-static\n+    needs:\n+      - build-linux-x64\n+      - build-linux-x64-static\n+    uses: .\/.github\/workflows\/test.yml\n+    with:\n+      platform: linux-x64\n+      bootjdk-platform: linux-x64\n+      runs-on: ubuntu-22.04\n+      static-suffix: \"-static\"\n@@ -375,0 +386,1 @@\n+      debug-suffix: -debug\n@@ -385,0 +397,1 @@\n+      debug-suffix: -debug\n","filename":".github\/workflows\/main.yml","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+      debug-suffix:\n+        required: false\n+        type: string\n+      static-suffix:\n+        required: false\n+        type: string\n@@ -89,1 +95,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -93,1 +99,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -97,1 +103,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -101,1 +107,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -105,1 +111,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -109,1 +115,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -113,1 +119,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -117,1 +123,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -143,0 +149,1 @@\n+          static-suffix: ${{ inputs.static-suffix }}\n@@ -163,0 +170,15 @@\n+          if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+            echo \"static-hotspot-problemlist-path=`pwd`\/test\/hotspot\/jtreg\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-jdk-problemlist-path=`pwd`\/test\/jdk\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-langtools-problemlist-path=`pwd`\/test\/langtools\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-lib-test-problemlist-path=`pwd`\/test\/lib-test\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+          fi\n+\n+      - name: 'Set Extra Options'\n+        id: extra-options\n+        run: |\n+          if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+            echo \"test-jdk=JDK_UNDER_TEST=${{ steps.bundles.outputs.static-jdk-path }}\" >> $GITHUB_OUTPUT\n+            echo \"compile-jdk=JDK_FOR_COMPILE=${{ steps.bundles.outputs.jdk-path }}\" >> $GITHUB_OUTPUT\n+            echo \"extra-problem-lists=EXTRA_PROBLEM_LISTS=${{ steps.path.outputs.static-hotspot-problemlist-path }}%20${{ steps.path.outputs.static-jdk-problemlist-path }}%20${{ steps.path.outputs.static-langtools-problemlist-path }}%20${{ steps.path.outputs.static-lib-test-problemlist-path }}\" >> $GITHUB_OUTPUT\n+          fi\n@@ -174,1 +196,3 @@\n-          JTREG='JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash;VERBOSE=fail,error,time;KEYWORDS=!headful'\n+          ${{ steps.extra-options.outputs.test-jdk }}\n+          ${{ steps.extra-options.outputs.compile-jdk }}\n+          JTREG='JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash;VERBOSE=fail,error,time;KEYWORDS=!headful;${{ steps.extra-options.outputs.extra-problem-lists }}'\n@@ -207,1 +231,1 @@\n-          artifact_name=\"results-${{ inputs.platform }}-$(echo ${{ matrix.test-name }} | tr '\/ ' '__')\"\n+          artifact_name=\"results-${{ inputs.platform }}-$(echo ${{ matrix.test-name }}${{ inputs.static-suffix }} | tr '\/ ' '__')\"\n","filename":".github\/workflows\/test.yml","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -418,0 +418,10 @@\n+  if test \"x$OPENJDK_BUILD_OS\" = xwindows || test \"x$OPENJDK_BUILD_OS\" = \"xmacosx\"; then\n+    # These systems have case insensitive paths, so convert them to lower case.\n+    [ cmp_configure_start_dir=`$ECHO $CONFIGURE_START_DIR | $TR '[:upper:]' '[:lower:]'` ]\n+    [ cmp_topdir=`$ECHO $TOPDIR | $TR '[:upper:]' '[:lower:]'` ]\n+    [ cmp_custom_root=`$ECHO $CUSTOM_ROOT | $TR '[:upper:]' '[:lower:]'` ]\n+  else\n+    cmp_configure_start_dir=\"$CONFIGURE_START_DIR\"\n+    cmp_topdir=\"$TOPDIR\"\n+    cmp_custom_root=\"$CUSTOM_ROOT\"\n+  fi\n@@ -419,4 +429,4 @@\n-  if test \"x$CONFIGURE_START_DIR\" = \"x$TOPDIR\" \\\n-      || test \"x$CONFIGURE_START_DIR\" = \"x$CUSTOM_ROOT\" \\\n-      || test \"x$CONFIGURE_START_DIR\" = \"x$TOPDIR\/make\/autoconf\" \\\n-      || test \"x$CONFIGURE_START_DIR\" = \"x$TOPDIR\/make\" ; then\n+  if test \"x$cmp_configure_start_dir\" = \"x$cmp_topdir\" \\\n+      || test \"x$cmp_configure_start_dir\" = \"x$cmp_custom_root\" \\\n+      || test \"x$cmp_configure_start_dir\" = \"x$cmp_topdir\/make\/autoconf\" \\\n+      || test \"x$cmp_configure_start_dir\" = \"x$cmp_topdir\/make\" ; then\n@@ -443,1 +453,6 @@\n-      CONF_NAME=`$ECHO $CONFIGURE_START_DIR | $SED -e \"s!^${TOPDIR}\/build\/!!\"`\n+      [ if [[ \"$cmp_configure_start_dir\" =~ ^${cmp_topdir}\/build\/[^\/]+$ ||\n+          \"$cmp_configure_start_dir\" =~ ^${cmp_custom_root}\/build\/[^\/]+$ ]]; then ]\n+          CONF_NAME=\"${CONFIGURE_START_DIR##*\/}\"\n+      else\n+          CONF_NAME=\"$CONFIGURE_START_DIR\"\n+      fi\n","filename":"make\/autoconf\/basic.m4","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -735,2 +735,1 @@\n-        # Use ppc64 instructions, but schedule for power5\n-        $1_CFLAGS_CPU=\"-mcpu=powerpc64 -mtune=power5\"\n+        $1_CFLAGS_CPU=\"-mcpu=power8 -mtune=power8\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-            \"--disable-cds-archive-coh\",\n","filename":"make\/conf\/jib-profiles.js","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/pandocfilter\/PandocFilter.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import java.lang.classfile.TypeAnnotation.TargetInfo;\n+import java.lang.classfile.TypeAnnotation.TypePathComponent;\n@@ -999,0 +1001,6 @@\n+        if (desc.classTypeAnnotations != null && !desc.classTypeAnnotations.isEmpty()) {\n+            builder.accept(RuntimeInvisibleTypeAnnotationsAttribute.of(createTypeAnnotations(desc.classTypeAnnotations)));\n+        }\n+        if (desc.runtimeTypeAnnotations != null && !desc.runtimeTypeAnnotations.isEmpty()) {\n+            builder.accept(RuntimeVisibleTypeAnnotationsAttribute.of(createTypeAnnotations(desc.runtimeTypeAnnotations)));\n+        }\n@@ -1080,0 +1088,38 @@\n+\n+    private List<TypeAnnotation> createTypeAnnotations(List<TypeAnnotationDescription> desc) {\n+        return desc.stream().map(this::createTypeAnnotation).collect(Collectors.toList());\n+    }\n+\n+    private TypeAnnotation createTypeAnnotation(TypeAnnotationDescription desc) {\n+        Annotation baseAnn = createAnnotation(desc.annotation);\n+        TargetInfo targetInfo = switch ((String) desc.targetInfo.get(\"targetType\")) {\n+            case \"CLASS_TYPE_PARAMETER\" -> \/\/TODO: test!\n+                TargetInfo.ofClassTypeParameter((int) desc.targetInfo.get(\"typeParameterIndex\"));\n+            case \"METHOD_TYPE_PARAMETER\" ->\n+                TargetInfo.ofMethodTypeParameter((int) desc.targetInfo.get(\"typeParameterIndex\"));\n+            case \"CLASS_EXTENDS\" ->\n+                TargetInfo.ofClassExtends((int) desc.targetInfo.get(\"supertypeIndex\"));\n+            case \"CLASS_TYPE_PARAMETER_BOUND\" ->\n+                TargetInfo.ofClassTypeParameterBound((int) desc.targetInfo.get(\"typeParameterIndex\"),\n+                                                     (int) desc.targetInfo.get(\"boundIndex\"));\n+            case \"METHOD_TYPE_PARAMETER_BOUND\" ->\n+                TargetInfo.ofMethodTypeParameterBound((int) desc.targetInfo.get(\"typeParameterIndex\"),\n+                                                      (int) desc.targetInfo.get(\"boundIndex\"));\n+            case \"METHOD_RETURN\" ->\n+                TargetInfo.ofMethodReturn();\n+            case \"METHOD_RECEIVER\" ->\n+                TargetInfo.ofMethodReceiver();\n+            case \"METHOD_FORMAL_PARAMETER\" ->\n+                TargetInfo.ofMethodFormalParameter((int) desc.targetInfo.get(\"formalParameterIndex\"));\n+            case \"THROWS\" ->\n+                TargetInfo.ofThrows((int) desc.targetInfo.get(\"throwsTargetIndex\"));\n+            case \"FIELD\" ->\n+                TargetInfo.ofField();\n+            case String targetType ->\n+                throw new IllegalStateException(\"Unsupported targetType: \" + targetType);\n+        };\n+\n+        List<TypePathComponent> typePath = desc.typePath.stream().map(d -> TypePathComponent.of(TypePathComponent.Kind.valueOf(d.tag()), d.index())).toList();\n+\n+        return TypeAnnotation.of(targetInfo, typePath, baseAnn);\n+    }\n@@ -2227,1 +2273,4 @@\n-            case RuntimeVisibleTypeAnnotationsAttribute a -> {\/* do nothing for now *\/}\n+            case RuntimeInvisibleTypeAnnotationsAttribute a ->\n+                feature.classTypeAnnotations = typeAnnotations2Descriptions(a.annotations());\n+            case RuntimeVisibleTypeAnnotationsAttribute a ->\n+                feature.runtimeTypeAnnotations = typeAnnotations2Descriptions(a.annotations());\n@@ -2284,0 +2333,25 @@\n+\n+    private List<TypeAnnotationDescription> typeAnnotations2Descriptions(List<TypeAnnotation> annos) {\n+        return annos.stream().map(ta -> {\n+            TypeAnnotationDescription desc = new TypeAnnotationDescription();\n+            desc.annotation = annotation2Description(ta.annotation());\n+            desc.targetInfo = new HashMap<>();\n+            desc.targetInfo.put(\"targetType\", ta.targetInfo().targetType().name());\n+            switch (ta.targetInfo()) {\n+                case TypeAnnotation.TypeParameterTarget tpt -> desc.targetInfo.put(\"typeParameterIndex\", tpt.typeParameterIndex());\n+                case TypeAnnotation.SupertypeTarget st -> desc.targetInfo.put(\"supertypeIndex\", st.supertypeIndex());\n+                case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                    desc.targetInfo.put(\"typeParameterIndex\", tpbt.typeParameterIndex());\n+                    desc.targetInfo.put(\"boundIndex\", tpbt.boundIndex());\n+                }\n+                case TypeAnnotation.EmptyTarget _ -> {\n+                    \/\/ nothing to write\n+                }\n+                case TypeAnnotation.FormalParameterTarget fpt -> desc.targetInfo.put(\"formalParameterIndex\", fpt.formalParameterIndex());\n+                case TypeAnnotation.ThrowsTarget tt -> desc.targetInfo.put(\"throwsTargetIndex\", tt.throwsTargetIndex());\n+                default -> throw new IllegalStateException(ta.targetInfo().targetType().name());\n+            }\n+            desc.typePath = ta.targetPath().stream().map(tpc -> new TypeAnnotationDescription.TypePathComponentDesc(tpc.typePathKind().name(), tpc.typeArgumentIndex())).toList();\n+            return desc;\n+        }).toList();\n+    }\n@@ -2405,0 +2479,2 @@\n+        List<TypeAnnotationDescription> classTypeAnnotations;\n+        List<TypeAnnotationDescription> runtimeTypeAnnotations;\n@@ -2427,0 +2503,12 @@\n+            if (classTypeAnnotations != null && !classTypeAnnotations.isEmpty()) {\n+                output.append(\" classTypeAnnotations \");\n+                for (TypeAnnotationDescription a : classTypeAnnotations) {\n+                    output.append(quote(a.toString(), false));\n+                }\n+            }\n+            if (runtimeTypeAnnotations != null && !runtimeTypeAnnotations.isEmpty()) {\n+                output.append(\" runtimeTypeAnnotations \");\n+                for (TypeAnnotationDescription a : runtimeTypeAnnotations) {\n+                    output.append(quote(a.toString(), false));\n+                }\n+            }\n@@ -2456,0 +2544,8 @@\n+            String inClassTypeAnnotations = reader.attributes.get(\"classTypeAnnotations\");\n+            if (inClassTypeAnnotations != null) {\n+                classTypeAnnotations = parseTypeAnnotations(inClassTypeAnnotations, new int[1]);\n+            }\n+            String inRuntimeTypeAnnotations = reader.attributes.get(\"runtimeTypeAnnotations\");\n+            if (inRuntimeTypeAnnotations != null) {\n+                runtimeTypeAnnotations = parseTypeAnnotations(inRuntimeTypeAnnotations, new int[1]);\n+            }\n@@ -2468,0 +2564,2 @@\n+            hash = 89 * hash + listHashCode(this.classTypeAnnotations);\n+            hash = 89 * hash + listHashCode(this.runtimeTypeAnnotations);\n@@ -2495,0 +2593,6 @@\n+            if (!listEquals(this.classTypeAnnotations, other.classTypeAnnotations)) {\n+                return false;\n+            }\n+            if (!listEquals(this.runtimeTypeAnnotations, other.runtimeTypeAnnotations)) {\n+                return false;\n+            }\n@@ -3299,0 +3403,2 @@\n+            hash = 59 * hash + Objects.hashCode(this.classParameterAnnotations);\n+            hash = 59 * hash + Objects.hashCode(this.runtimeParameterAnnotations);\n@@ -3323,0 +3429,6 @@\n+            if (!Objects.equals(this.classParameterAnnotations, other.classParameterAnnotations)) {\n+                return false;\n+            }\n+            if (!Objects.equals(this.runtimeParameterAnnotations, other.runtimeParameterAnnotations)) {\n+                return false;\n+            }\n@@ -3650,0 +3762,34 @@\n+    static final class TypeAnnotationDescription {\n+        AnnotationDescription annotation;\n+        Map<String, Object> targetInfo;\n+        List<TypePathComponentDesc> typePath;\n+\n+        public TypeAnnotationDescription() {\n+        }\n+\n+        public TypeAnnotationDescription(AnnotationDescription annotation, Map<String, Object> targetInfo, List<TypePathComponentDesc> typePath) {\n+            this.annotation = annotation;\n+            this.targetInfo = targetInfo;\n+            this.typePath = typePath;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return annotation.toString() + \"{\" + targetInfo.entrySet().stream().map(e -> e.getKey() + \"=\" + quote(printValue(e.getValue()), false)).collect(Collectors.joining(\",\")) + \"}\" +\n+                                           (!typePath.isEmpty() ? \"[\" + typePath.stream().map(desc -> desc.tag + \":\" + desc.index).collect(Collectors.joining(\",\")) + \"]\" : \"\");\n+        }\n+\n+        private String printValue(Object obj) {\n+            if (obj instanceof String s) {\n+                return \"\\\"\" + s + \"\\\"\";\n+            } else if (obj instanceof Integer i) {\n+                return \"I\" + String.valueOf(i);\n+            } else {\n+                throw new IllegalStateException(\"Unsupported value: \" + obj.getClass());\n+            }\n+        }\n+\n+        \/\/TODO: path\n+        record TypePathComponentDesc(String tag, int index) {}\n+    }\n+\n@@ -3989,1 +4135,1 @@\n-        Map<String, Object> attribute2Value = new HashMap<>();\n+        Map<String, Object> attribute2Value = Map.of();\n@@ -3992,1 +4138,47 @@\n-            while (value.charAt(valuePointer[0]) != ')') {\n+            attribute2Value = parseMap(value, valuePointer, ')');\n+        }\n+\n+        return new AnnotationDescription(className, attribute2Value);\n+    }\n+\n+    private static Map<String, Object> parseMap(String value, int[] valuePointer, char endBracket) {\n+        Map<String, Object> attribute2Value = new HashMap<>();\n+\n+        while (value.charAt(valuePointer[0]) != endBracket) {\n+            int nameStart = ++valuePointer[0];\n+\n+            while (value.charAt(valuePointer[0]++) != '=');\n+\n+            String name = value.substring(nameStart, valuePointer[0] - 1);\n+\n+            attribute2Value.put(name, parseAnnotationValue(value, valuePointer));\n+        }\n+\n+        valuePointer[0]++;\n+\n+        return attribute2Value;\n+    }\n+\n+    public static List<TypeAnnotationDescription> parseTypeAnnotations(String encoded, int[] pointer) {\n+        List<TypeAnnotationDescription> result = new ArrayList<>();\n+\n+        while (pointer[0] < encoded.length() && encoded.charAt(pointer[0]) == '@') {\n+            pointer[0]++;\n+            result.add(parseTypeAnnotation(encoded, pointer));\n+        }\n+\n+        return result;\n+    }\n+\n+    private static TypeAnnotationDescription parseTypeAnnotation(String value, int[] valuePointer) {\n+        AnnotationDescription ann = parseAnnotation(value, valuePointer);\n+        Map<String, Object> targetInfo = Map.of();\n+\n+        if (valuePointer[0] < value.length() && value.charAt(valuePointer[0]) == '{') {\n+            targetInfo = parseMap(value, valuePointer, '}');\n+        }\n+\n+        List<TypeAnnotationDescription.TypePathComponentDesc> typePath = new ArrayList<>();\n+\n+        if (valuePointer[0] < value.length() && value.charAt(valuePointer[0]) == '[') {\n+            while (value.charAt(valuePointer[0]) != ']') {\n@@ -3995,1 +4187,1 @@\n-                while (value.charAt(valuePointer[0]++) != '=');\n+                while (value.charAt(valuePointer[0]++) != ':');\n@@ -3999,1 +4191,1 @@\n-                attribute2Value.put(name, parseAnnotationValue(value, valuePointer));\n+                typePath.add(new TypeAnnotationDescription.TypePathComponentDesc(name, Integer.parseInt(readDigits(value, valuePointer))));\n@@ -4005,1 +4197,1 @@\n-        return new AnnotationDescription(className, attribute2Value);\n+        return new TypeAnnotationDescription(ann, targetInfo, typePath);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":198,"deletions":6,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -281,1 +281,0 @@\n-      DISABLED_WARNINGS_gcc_XToolkit.c := unused-result, \\\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -8294,0 +8294,10 @@\n+instruct castHH(vRegF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2025, Arm Limited. All rights reserved.\n@@ -228,0 +228,20 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n+      case Op_SqrtVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports half-precision floats\n+        \/\/ by default.\n+        if (UseSVE == 0 && !is_feat_fp16_supported()) {\n+          return false;\n+        }\n+        break;\n+      case Op_FmaVHF:\n+        \/\/ UseFMA flag needs to be checked along with FEAT_FP16\n+        if (!UseFMA || (UseSVE == 0 && !is_feat_fp16_supported())) {\n+          return false;\n+        }\n+        break;\n@@ -273,0 +293,13 @@\n+      \/\/ Currently, the masked versions of the following 8 Float16 operations are disabled.\n+      \/\/ When the support for Float16 vector classes is added in VectorAPI and the masked\n+      \/\/ Float16 IR can be generated, these masked operations will be enabled and relevant\n+      \/\/ backend support added.\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MaxVHF:\n+      case Op_MinVHF:\n+      case Op_SqrtVHF:\n+      case Op_FmaVHF:\n+        return false;\n@@ -586,0 +619,16 @@\n+instruct vaddHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"vaddHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fadd($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fadd($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -810,0 +859,16 @@\n+instruct vsubHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (SubVHF src1 src2));\n+  format %{ \"vsubHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsub($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsub($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1007,0 +1072,16 @@\n+instruct vmulHF(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (MulVHF src1 src2));\n+  format %{ \"vmulHF $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fmul($dst$$FloatRegister, get_arrangement(this),\n+              $src1$$FloatRegister, $src2$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fmul($dst$$FloatRegister, __ H, $src1$$FloatRegister, $src2$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1105,0 +1186,22 @@\n+instruct vdivHF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (DivVHF src1 src2));\n+  format %{ \"vdivHF_neon $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdiv($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivHF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (DivVHF dst_src1 src2));\n+  format %{ \"vdivHF_sve $dst_src1, $dst_src1, $src2\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fdiv($dst_src1$$FloatRegister, __ H, ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1994,0 +2097,15 @@\n+instruct vsqrtHF(vReg dst, vReg src) %{\n+  match(Set dst (SqrtVHF src));\n+  format %{ \"vsqrtHF $dst, $src\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ fsqrt($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else {\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_fsqrt($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2072,1 +2190,1 @@\n-\/\/ vector min - B\/S\/I\/F\/D\n+\/\/ vector min - B\/S\/I\/HF\/F\/D\n@@ -2113,0 +2231,23 @@\n+instruct vmin_HF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MinVHF src1 src2));\n+  format %{ \"vmin_HF_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    __ fmin($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmin_HF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MinVHF dst_src1 src2));\n+  format %{ \"vmin_HF_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fmin($dst_src1$$FloatRegister, __ H,\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2229,1 +2370,1 @@\n-\/\/ vector max - B\/S\/I\/F\/D\n+\/\/ vector max - B\/S\/I\/HF\/F\/D\n@@ -2270,0 +2411,23 @@\n+instruct vmax_HF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst (MaxVHF src1 src2));\n+  format %{ \"vmax_HF_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    __ fmax($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmax_HF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 (MaxVHF dst_src1 src2));\n+  format %{ \"vmax_HF_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_fmax($dst_src1$$FloatRegister, __ H,\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2416,2 +2580,3 @@\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVHF dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVF  dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD  dst_src1 (Binary src2 src3)));\n@@ -4616,0 +4781,17 @@\n+\/\/ Replicate a half-precision float value held in a floating point register\n+instruct replicateHF(vReg dst, vRegF src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n+  format %{ \"replicateHF $dst, $src\\t# replicate half-precision float\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -4684,0 +4866,17 @@\n+\/\/ Replicate a 16-bit half precision float value\n+instruct replicateHF_imm(vReg dst, immH con) %{\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int imm = (int)($con$$constant) & 0xffff;\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ H, imm);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":204,"deletions":5,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2020, 2024, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2025, Arm Limited. All rights reserved.\n@@ -218,0 +218,20 @@\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MinVHF:\n+      case Op_MaxVHF:\n+      case Op_SqrtVHF:\n+        \/\/ FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\" features are supported.\n+        \/\/ Only the Neon instructions need this check. SVE supports half-precision floats\n+        \/\/ by default.\n+        if (UseSVE == 0 && !is_feat_fp16_supported()) {\n+          return false;\n+        }\n+        break;\n+      case Op_FmaVHF:\n+        \/\/ UseFMA flag needs to be checked along with FEAT_FP16\n+        if (!UseFMA || (UseSVE == 0 && !is_feat_fp16_supported())) {\n+          return false;\n+        }\n+        break;\n@@ -263,0 +283,13 @@\n+      \/\/ Currently, the masked versions of the following 8 Float16 operations are disabled.\n+      \/\/ When the support for Float16 vector classes is added in VectorAPI and the masked\n+      \/\/ Float16 IR can be generated, these masked operations will be enabled and relevant\n+      \/\/ backend support added.\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MaxVHF:\n+      case Op_MinVHF:\n+      case Op_SqrtVHF:\n+      case Op_FmaVHF:\n+        return false;\n@@ -511,6 +544,7 @@\n-BINARY_OP(vaddB, AddVB, addv, sve_add,  B)\n-BINARY_OP(vaddS, AddVS, addv, sve_add,  H)\n-BINARY_OP(vaddI, AddVI, addv, sve_add,  S)\n-BINARY_OP(vaddL, AddVL, addv, sve_add,  D)\n-BINARY_OP(vaddF, AddVF, fadd, sve_fadd, S)\n-BINARY_OP(vaddD, AddVD, fadd, sve_fadd, D)\n+BINARY_OP(vaddB,  AddVB,  addv, sve_add,  B)\n+BINARY_OP(vaddS,  AddVS,  addv, sve_add,  H)\n+BINARY_OP(vaddI,  AddVI,  addv, sve_add,  S)\n+BINARY_OP(vaddL,  AddVL,  addv, sve_add,  D)\n+BINARY_OP(vaddHF, AddVHF, fadd, sve_fadd, H)\n+BINARY_OP(vaddF,  AddVF,  fadd, sve_fadd, S)\n+BINARY_OP(vaddD,  AddVD,  fadd, sve_fadd, D)\n@@ -535,6 +569,7 @@\n-BINARY_OP(vsubB, SubVB, subv, sve_sub,  B)\n-BINARY_OP(vsubS, SubVS, subv, sve_sub,  H)\n-BINARY_OP(vsubI, SubVI, subv, sve_sub,  S)\n-BINARY_OP(vsubL, SubVL, subv, sve_sub,  D)\n-BINARY_OP(vsubF, SubVF, fsub, sve_fsub, S)\n-BINARY_OP(vsubD, SubVD, fsub, sve_fsub, D)\n+BINARY_OP(vsubB,  SubVB,  subv, sve_sub,  B)\n+BINARY_OP(vsubS,  SubVS,  subv, sve_sub,  H)\n+BINARY_OP(vsubI,  SubVI,  subv, sve_sub,  S)\n+BINARY_OP(vsubL,  SubVL,  subv, sve_sub,  D)\n+BINARY_OP(vsubHF, SubVHF, fsub, sve_fsub, H)\n+BINARY_OP(vsubF,  SubVF,  fsub, sve_fsub, S)\n+BINARY_OP(vsubD,  SubVD,  fsub, sve_fsub, D)\n@@ -615,2 +650,3 @@\n-BINARY_OP(vmulF, MulVF, fmul, sve_fmul, S)\n-BINARY_OP(vmulD, MulVD, fmul, sve_fmul, D)\n+BINARY_OP(vmulHF, MulVHF, fmul, sve_fmul, H)\n+BINARY_OP(vmulF,  MulVF,  fmul, sve_fmul, S)\n+BINARY_OP(vmulD,  MulVD,  fmul, sve_fmul, D)\n@@ -629,2 +665,3 @@\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivF, DivVF, fdiv, sve_fdiv, S)\n-BINARY_OP_NEON_SVE_PAIRWISE(vdivD, DivVD, fdiv, sve_fdiv, D)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivHF, DivVHF, fdiv, sve_fdiv, H)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivF,  DivVF,  fdiv, sve_fdiv, S)\n+BINARY_OP_NEON_SVE_PAIRWISE(vdivD,  DivVD,  fdiv, sve_fdiv, D)\n@@ -1019,2 +1056,3 @@\n-UNARY_OP(vsqrtF, SqrtVF, fsqrt, sve_fsqrt, S)\n-UNARY_OP(vsqrtD, SqrtVD, fsqrt, sve_fsqrt, D)\n+UNARY_OP(vsqrtHF, SqrtVHF, fsqrt, sve_fsqrt, H)\n+UNARY_OP(vsqrtF,  SqrtVF,  fsqrt, sve_fsqrt, S)\n+UNARY_OP(vsqrtD,  SqrtVD,  fsqrt, sve_fsqrt, D)\n@@ -1077,0 +1115,14 @@\n+dnl VMINMAX_HF_NEON($1,   $2,      $3     )\n+dnl VMINMAX_HF_NEON(type, op_name, insn_fp)\n+define(`VMINMAX_HF_NEON', `\n+instruct v$1_HF_neon(vReg dst, vReg src1, vReg src2) %{\n+  predicate(VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst ($2 src1 src2));\n+  format %{ \"v$1_HF_neon $dst, $src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    __ $3($dst$$FloatRegister, get_arrangement(this),\n+            $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1100,0 +1152,15 @@\n+dnl VMINMAX_HF_SVE($1,   $2,      $3     )\n+dnl VMINMAX_HF_SVE(type, op_name, insn_fp)\n+define(`VMINMAX_HF_SVE', `\n+instruct v$1_HF_sve(vReg dst_src1, vReg src2) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n)));\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  format %{ \"v$1_HF_sve $dst_src1, $dst_src1, $src2\\t# Half float\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ $3($dst_src1$$FloatRegister, __ H,\n+                ptrue, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n@@ -1178,1 +1245,1 @@\n-\/\/ vector min - B\/S\/I\/F\/D\n+\/\/ vector min - B\/S\/I\/HF\/F\/D\n@@ -1181,0 +1248,2 @@\n+VMINMAX_HF_NEON(min, MinVHF, fmin)\n+VMINMAX_HF_SVE(min, MinVHF, sve_fmin)\n@@ -1202,1 +1271,1 @@\n-\/\/ vector max - B\/S\/I\/F\/D\n+\/\/ vector max - B\/S\/I\/HF\/F\/D\n@@ -1205,0 +1274,2 @@\n+VMINMAX_HF_NEON(max, MaxVHF, fmax)\n+VMINMAX_HF_SVE(max, MaxVHF, sve_fmax)\n@@ -1276,2 +1347,3 @@\n-  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n-  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVHF dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVF  dst_src1 (Binary src2 src3)));\n+  match(Set dst_src1 (FmaVD  dst_src1 (Binary src2 src3)));\n@@ -2941,0 +3013,17 @@\n+\/\/ Replicate a half-precision float value held in a floating point register\n+instruct replicateHF(vReg dst, vRegF src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n+  format %{ \"replicateHF $dst, $src\\t# replicate half-precision float\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ dup($dst$$FloatRegister, get_arrangement(this), $src$$FloatRegister);\n+    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_cpy($dst$$FloatRegister, __ H, ptrue, $src$$FloatRegister);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3009,0 +3098,17 @@\n+\/\/ Replicate a 16-bit half precision float value\n+instruct replicateHF_imm(vReg dst, immH con) %{\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  ins_encode %{\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    int imm = (int)($con$$constant) & 0xffff;\n+    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n+      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n+      assert(UseSVE > 0, \"must be sve\");\n+      __ sve_dup($dst$$FloatRegister, __ H, imm);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":129,"deletions":23,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -243,0 +243,13 @@\n+\/\/ This method is used to generate Advanced SIMD data processing instructions\n+void Assembler::adv_simd_three_same(Instruction_aarch64 &current_insn, FloatRegister Vd,\n+                                    SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm,\n+                                    int op1, int op2, int op3) {\n+  assert(T == T4H || T == T8H || T == T2S || T == T4S || T == T2D, \"invalid arrangement\");\n+  int op22 = (T == T2S || T == T4S) ? 0b0 : 0b1;\n+  int op21 = (T == T4H || T == T8H) ? 0b0 : 0b1;\n+  int op14 = (T == T4H || T == T8H) ? 0b00 : 0b11;\n+  f(0, 31), f((int)T & 1, 30), f(op1, 29), f(0b01110, 28, 24), f(op2, 23);\n+  f(op22, 22); f(op21, 21), rf(Vm, 16), f(op14, 15, 14), f(op3, 13, 10),\n+  rf(Vn, 5), rf(Vd, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2746,20 +2746,20 @@\n-\/\/ Advanced SIMD three same\n-#define INSN(NAME, op1, op2, op3)                                                       \\\n-  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) { \\\n-    starti;                                                                             \\\n-    assert(T == T2S || T == T4S || T == T2D, \"invalid arrangement\");                    \\\n-    f(0, 31), f((int)T & 1, 30), f(op1, 29), f(0b01110, 28, 24), f(op2, 23);            \\\n-    f(T==T2D ? 1:0, 22); f(1, 21), rf(Vm, 16), f(op3, 15, 10), rf(Vn, 5), rf(Vd, 0);    \\\n-  }\n-\n-  INSN(fabd, 1, 1, 0b110101);\n-  INSN(fadd, 0, 0, 0b110101);\n-  INSN(fdiv, 1, 0, 0b111111);\n-  INSN(faddp, 1, 0, 0b110101);\n-  INSN(fmul, 1, 0, 0b110111);\n-  INSN(fsub, 0, 1, 0b110101);\n-  INSN(fmla, 0, 0, 0b110011);\n-  INSN(fmls, 0, 1, 0b110011);\n-  INSN(fmax, 0, 0, 0b111101);\n-  INSN(fmin, 0, 1, 0b111101);\n-  INSN(facgt, 1, 1, 0b111011);\n+  \/\/ Advanced SIMD three same\n+  void adv_simd_three_same(Instruction_aarch64 &current_insn, FloatRegister Vd,\n+                           SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm,\n+                           int op1, int op2, int op3);\n+#define INSN(NAME, op1, op2, op3)                                                             \\\n+  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm) {       \\\n+    starti;                                                                                   \\\n+    adv_simd_three_same(current_insn, Vd, T, Vn, Vm, op1, op2, op3);                          \\\n+  }\n+  INSN(fabd,  1, 1, 0b0101);\n+  INSN(fadd,  0, 0, 0b0101);\n+  INSN(fdiv,  1, 0, 0b1111);\n+  INSN(faddp, 1, 0, 0b0101);\n+  INSN(fmul,  1, 0, 0b0111);\n+  INSN(fsub,  0, 1, 0b0101);\n+  INSN(fmla,  0, 0, 0b0011);\n+  INSN(fmls,  0, 1, 0b0011);\n+  INSN(fmax,  0, 0, 0b1101);\n+  INSN(fmin,  0, 1, 0b1101);\n+  INSN(facgt, 1, 1, 0b1011);\n@@ -3265,7 +3265,13 @@\n-#define INSN(NAME, U, size, tmask, opcode)                                          \\\n-  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {               \\\n-       starti;                                                                      \\\n-       assert((ASSERTION), MSG);                                                    \\\n-       f(0, 31), f((int)T & 1, 30), f(U, 29), f(0b01110, 28, 24);                   \\\n-       f(size | ((int)(T >> 1) & tmask), 23, 22), f(0b10000, 21, 17);               \\\n-       f(opcode, 16, 12), f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                    \\\n+#define INSN(NAME, U, size, tmask, opcode)                                      \\\n+  void NAME(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn) {           \\\n+    starti;                                                                     \\\n+    assert((ASSERTION), MSG);                                                   \\\n+    int op22 = (int)(T >> 1) & tmask;                                           \\\n+    int op19 = 0b00;                                                            \\\n+    if (tmask == 0b01 && (T == T4H || T == T8H)) {                              \\\n+      op22 = 0b1;                                                               \\\n+      op19 = 0b11;                                                              \\\n+    }                                                                           \\\n+    f(0, 31), f((int)T & 1, 30), f(U, 29), f(0b01110, 28, 24);                  \\\n+    f(size | op22, 23, 22), f(1, 21), f(op19, 20, 19), f(0b00, 18, 17);         \\\n+    f(opcode, 16, 12), f(0b10, 11, 10), rf(Vn, 5), rf(Vd, 0);                   \\\n@@ -3276,1 +3282,1 @@\n-#define ASSERTION (T == T2S || T == T4S || T == T2D)\n+#define ASSERTION (T == T4H || T == T8H || T == T2S || T == T4S || T == T2D)\n@@ -3403,1 +3409,1 @@\n-    assert(T == S || T == D, \"invalid register variant\");                              \\\n+    assert(T == H || T == S || T == D, \"invalid register variant\");                    \\\n@@ -3488,1 +3494,1 @@\n-    assert(T == S || T == D, \"invalid register variant\");                                             \\\n+    assert(T == H || T == S || T == D, \"invalid register variant\");                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -850,1 +850,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,47 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::interpreter_frame_bcp_offset]);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::return_addr_offset]);\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::interpreter_frame_sender_sp_offset]);\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp + frame::interpreter_frame_initial_sp_offset;\n+}\n+\n+inline intptr_t* frame::sender_sp(intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return fp + frame::sender_sp_offset;\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::link_offset]);\n+}\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(sp[-1]);\n+}\n+\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(sp[-2]);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -518,1 +518,0 @@\n-\/\/ Apply stack watermark barrier.\n@@ -521,0 +520,2 @@\n+\/\/ Apply stack watermark barrier.\n+\/\/ Notify JVMTI.\n@@ -530,5 +531,4 @@\n-void InterpreterMacroAssembler::remove_activation(\n-        TosState state,\n-        bool throw_monitor_exception,\n-        bool install_monitor_exception,\n-        bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -539,15 +539,0 @@\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-  br(Assembler::AL, fast_path);\n-  bind(slow_path);\n-  push(state);\n-  set_last_Java_frame(esp, rfp, (address)pc(), rscratch1);\n-  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n-  reset_last_Java_frame(true);\n-  pop(state);\n-  bind(fast_path);\n-\n@@ -671,1 +656,18 @@\n-  \/\/ jvmti support\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  br(Assembler::AL, fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(esp, rfp, pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n+\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n@@ -699,0 +701,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -739,2 +743,0 @@\n-  \/\/ restore sender esp\n-  mov(esp, rscratch2);\n@@ -743,0 +745,6 @@\n+\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n+  \/\/ restore sender esp\n+  mov(esp, rscratch2);\n+\n@@ -750,0 +758,13 @@\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(rthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  mov(rscratch1, true);\n+  strb(rscratch1, sampling_critical_section);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(rthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  strb(zr, sampling_critical_section);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":45,"deletions":24,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -339,0 +339,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2267,0 +2267,17 @@\n+  #if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ tbz(rscratch1, log2i_exact(SafepointMechanism::poll_bit()), L_return);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+    \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ adr(rscratch1, InternalAddress(poll_test_pc));\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1602,0 +1602,24 @@\n+  #if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ br(Assembler::AL, fast_path);\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(esp, rfp, __ pc(), rscratch1);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1624,0 +1648,2 @@\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1948,0 +1948,2 @@\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1959,0 +1961,3 @@\n+\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,0 +111,3 @@\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null = false);\n+\n+  void setup(address pc);\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -33,0 +34,48 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::interpreter_frame_bcp_offset]);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::return_addr_offset]);\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::interpreter_frame_sender_sp_offset]);\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp + frame::interpreter_frame_initial_sp_offset;\n+}\n+\n+inline intptr_t* frame::sender_sp(intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return fp + frame::sender_sp_offset;\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::link_offset]);\n+}\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(sp[-1]);\n+}\n+\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(sp[-2]);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n+\n@@ -57,0 +106,2 @@\n+  _on_heap = false;\n+  _oop_map = nullptr;\n@@ -58,1 +109,0 @@\n-  adjust_unextended_sp();\n@@ -61,0 +111,6 @@\n+  setup(pc);\n+}\n+\n+inline void frame::setup(address pc) {\n+  adjust_unextended_sp();\n+\n@@ -64,2 +120,0 @@\n-    assert(_cb->as_nmethod()->insts_contains_inclusive(_pc),\n-           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n@@ -67,0 +121,2 @@\n+    assert(_cb == nullptr || _cb->as_nmethod()->insts_contains_inclusive(_pc),\n+           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n@@ -68,1 +124,5 @@\n-    _deopt_state = not_deoptimized;\n+    if (_cb == SharedRuntime::deopt_blob()) {\n+      _deopt_state = is_deoptimized;\n+    } else {\n+      _deopt_state = not_deoptimized;\n+    }\n@@ -70,2 +130,0 @@\n-  _on_heap = false;\n-  _oop_map = nullptr;\n@@ -88,0 +146,16 @@\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null) {\n+  intptr_t a = intptr_t(sp);\n+  intptr_t b = intptr_t(fp);\n+  _sp = sp;\n+  _unextended_sp = unextended_sp;\n+  _fp = fp;\n+  _pc = pc;\n+  assert(pc != nullptr, \"no pc?\");\n+  _cb = cb;\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr || allow_cb_null, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n+\n+  setup(pc);\n+}\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":80,"deletions":6,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2011,1 +2011,1 @@\n-  inline void waitrsv(); \/\/ >=Power7\n+  inline void waitrsv();\n@@ -2019,1 +2019,0 @@\n-  inline bool lxarx_hint_exclusive_access();\n@@ -2042,1 +2041,0 @@\n-  \/\/ >= Power7\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,2 +211,1 @@\n-inline void Assembler::isel(Register d, Register a, Register b, int c) { guarantee(VM_Version::has_isel(), \"opcode not supported on this hardware\");\n-                                                                         emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n+inline void Assembler::isel(Register d, Register a, Register b, int c) { emit_int32(ISEL_OPCODE    | rt(d)  | ra(a) | rb(b) | bc(c)); }\n@@ -704,6 +703,5 @@\n-inline bool Assembler::lxarx_hint_exclusive_access()                                          { return VM_Version::has_lxarxeh(); }\n-inline void Assembler::lbarx( Register d, Register a, Register b, bool hint_exclusive_access) { lbarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lharx( Register d, Register a, Register b, bool hint_exclusive_access) { lharx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lwarx( Register d, Register a, Register b, bool hint_exclusive_access) { lwarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::ldarx( Register d, Register a, Register b, bool hint_exclusive_access) { ldarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lqarx( Register d, Register a, Register b, bool hint_exclusive_access) { lqarx_unchecked(d, a, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lbarx( Register d, Register a, Register b, bool hint_exclusive_access) { lbarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lharx( Register d, Register a, Register b, bool hint_exclusive_access) { lharx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lwarx( Register d, Register a, Register b, bool hint_exclusive_access) { lwarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::ldarx( Register d, Register a, Register b, bool hint_exclusive_access) { ldarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lqarx( Register d, Register a, Register b, bool hint_exclusive_access) { lqarx_unchecked(d, a, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n@@ -778,6 +776,3 @@\n-inline void Assembler::cmpb(   Register a, Register s, Register b) { guarantee(VM_Version::has_cmpb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n-inline void Assembler::popcntb(Register a, Register s)             { guarantee(VM_Version::has_popcntb(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n-inline void Assembler::popcntw(Register a, Register s)             { guarantee(VM_Version::has_popcntw(), \"opcode not supported on this hardware\");\n-                                                                     emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::cmpb(   Register a, Register s, Register b) { emit_int32( CMPB_OPCODE    | rta(a) | rs(s) | rb(b) | rc(0)); }\n+inline void Assembler::popcntb(Register a, Register s)             { emit_int32( POPCNTB_OPCODE | rta(a) | rs(s)); };\n+inline void Assembler::popcntw(Register a, Register s)             { emit_int32( POPCNTW_OPCODE | rta(a) | rs(s)); };\n@@ -838,2 +833,1 @@\n-inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fcfids(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fcfids(FloatRegister d, FloatRegister b) { emit_int32( FCFIDS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -845,4 +839,2 @@\n-inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrt(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n-inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { guarantee(VM_Version::has_fsqrts(), \"opcode not supported on this hardware\");\n-                                                                  emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrt( FloatRegister d, FloatRegister b) { emit_int32( FSQRT_OPCODE  | frt(d) | frb(b) | rc(0)); }\n+inline void Assembler::fsqrts(FloatRegister d, FloatRegister b) { emit_int32( FSQRTS_OPCODE | frt(d) | frb(b) | rc(0)); }\n@@ -1060,2 +1052,1 @@\n-inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { guarantee(VM_Version::has_vand(), \"opcode not supported on this hardware\");\n-                                                                                        emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n+inline void Assembler::vand(    VectorRegister d, VectorRegister a, VectorRegister b) { emit_int32( VAND_OPCODE     | vrt(d) | vra(a) | vrb(b)); }\n@@ -1169,5 +1160,5 @@\n-inline void Assembler::lbarx( Register d, Register b, bool hint_exclusive_access){ lbarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lharx( Register d, Register b, bool hint_exclusive_access){ lharx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lwarx( Register d, Register b, bool hint_exclusive_access){ lwarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::ldarx( Register d, Register b, bool hint_exclusive_access){ ldarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n-inline void Assembler::lqarx( Register d, Register b, bool hint_exclusive_access){ lqarx_unchecked(d, b, (hint_exclusive_access && lxarx_hint_exclusive_access() && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lbarx( Register d, Register b, bool hint_exclusive_access){ lbarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lharx( Register d, Register b, bool hint_exclusive_access){ lharx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lwarx( Register d, Register b, bool hint_exclusive_access){ lwarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::ldarx( Register d, Register b, bool hint_exclusive_access){ ldarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n+inline void Assembler::lqarx( Register d, Register b, bool hint_exclusive_access){ lqarx_unchecked(d, b, (hint_exclusive_access && UseExtendedLoadAndReserveInstructionsPPC64) ? 1 : 0); }\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -44,4 +44,0 @@\n-    assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n-           \"polling page return stub not created yet\");\n-    address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n@@ -49,14 +45,1 @@\n-    \/\/ Using pc relative address computation.\n-    {\n-      Label next_pc;\n-      __ bl(next_pc);\n-      __ bind(next_pc);\n-    }\n-    int current_offset = __ offset();\n-    __ mflr(R12);\n-    __ add_const_optimized(R12, R12, safepoint_offset() - current_offset);\n-    __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n-\n-    __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n-    __ mtctr(R0);\n-    __ bctr();\n+    __ jump_to_polling_page_return_handler_blob(safepoint_offset());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -541,1 +541,7 @@\n-    case Bytecodes::_i2d:\n+    case Bytecodes::_i2d:{\n+      FloatRegister rdst = dst->as_double_reg();\n+      \/\/ move src to dst register\n+      __ mtfprwa(rdst, src->as_register());\n+      __ fcfid(rdst, rdst);\n+      break;\n+    }\n@@ -543,1 +549,0 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n@@ -545,13 +550,10 @@\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n-      } else {\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2d) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      __ fcfid(rdst, rsrc);\n+      \/\/ move src to dst register\n+      __ mtfprd(rdst, src->as_register_lo());\n+      __ fcfid(rdst, rdst);\n+      break;\n+    }\n+    case Bytecodes::_i2f:{\n+      FloatRegister rdst = dst->as_float_reg();\n+      \/\/ move src to dst register\n+      __ mtfprwa(rdst, src->as_register());\n+      __ fcfids(rdst, rdst);\n@@ -560,1 +562,0 @@\n-    case Bytecodes::_i2f:\n@@ -562,1 +563,0 @@\n-      bool src_in_memory = !VM_Version::has_mtfprd();\n@@ -564,19 +564,3 @@\n-      FloatRegister rsrc;\n-      if (src_in_memory) {\n-        rsrc = src->as_double_reg(); \/\/ via mem\n-      } else {\n-        \/\/ move src to dst register\n-        if (code == Bytecodes::_i2f) {\n-          __ mtfprwa(rdst, src->as_register());\n-        } else {\n-          __ mtfprd(rdst, src->as_register_lo());\n-        }\n-        rsrc = rdst;\n-      }\n-      if (VM_Version::has_fcfids()) {\n-        __ fcfids(rdst, rsrc);\n-      } else {\n-        assert(code == Bytecodes::_i2f, \"fcfid+frsp needs fixup code to avoid rounding incompatibility\");\n-        __ fcfid(rdst, rsrc);\n-        __ frsp(rdst, rdst);\n-      }\n+      \/\/ move src to dst register\n+      __ mtfprd(rdst, src->as_register_lo());\n+      __ fcfids(rdst, rdst);\n@@ -595,1 +579,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n@@ -597,1 +580,0 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -601,6 +583,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register(), 0);\n-      }\n+      __ li(dst->as_register(), 0);\n@@ -609,5 +586,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register(), rsrc);\n-      }\n+      __ mffprd(dst->as_register(), rsrc);\n@@ -619,1 +592,0 @@\n-      bool dst_in_memory = !VM_Version::has_mtfprd();\n@@ -621,1 +593,0 @@\n-      Address       addr = dst_in_memory ? frame_map()->address_for_slot(dst->double_stack_ix()) : Address();\n@@ -625,6 +596,1 @@\n-      if (dst_in_memory) {\n-        __ li(R0, 0); \/\/ 0 in case of NAN\n-        __ std(R0, addr);\n-      } else {\n-        __ li(dst->as_register_lo(), 0);\n-      }\n+      __ li(dst->as_register_lo(), 0);\n@@ -633,5 +599,1 @@\n-      if (dst_in_memory) {\n-        __ stfd(rsrc, addr.disp(), addr.base());\n-      } else {\n-        __ mffprd(dst->as_register_lo(), rsrc);\n-      }\n+      __ mffprd(dst->as_register_lo(), rsrc);\n@@ -1584,2 +1546,1 @@\n-  \/\/ Try to use isel on >=Power7.\n-  if (VM_Version::has_isel() && result->is_cpu_register()) {\n+  if (result->is_cpu_register()) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":25,"deletions":64,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -717,8 +717,6 @@\n-      if (VM_Version::has_fsqrt()) {\n-        assert(x->number_of_arguments() == 1, \"wrong type\");\n-        LIRItem value(x->argument_at(0), this);\n-        value.load_item();\n-        LIR_Opr dst = rlock_result(x);\n-        __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n-        break;\n-      } \/\/ else fallthru\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n+      break;\n@@ -736,4 +734,0 @@\n-        case vmIntrinsics::_dsqrt:\n-        case vmIntrinsics::_dsqrt_strict:\n-          runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);\n-          break;\n@@ -822,72 +816,0 @@\n-  if (!VM_Version::has_mtfprd()) {\n-    switch (x->op()) {\n-\n-      \/\/ int -> float: force spill\n-      case Bytecodes::_l2f: {\n-        if (!VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-          \/\/ fcfid+frsp needs fixup code to avoid rounding incompatibility.\n-          address entry = CAST_FROM_FN_PTR(address, SharedRuntime::l2f);\n-          LIR_Opr result = call_runtime(x->value(), entry, x->type(), nullptr);\n-          set_result(x, result);\n-          return;\n-        } \/\/ else fallthru\n-      }\n-      case Bytecodes::_l2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        LIR_Opr tmp = force_to_spill(value.result(), T_DOUBLE);\n-        __ convert(x->op(), tmp, reg);\n-        return;\n-      }\n-      case Bytecodes::_i2f:\n-      case Bytecodes::_i2d: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.load_item();\n-        \/\/ Convert i2l first.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        __ convert(Bytecodes::_i2l, value.result(), tmp1);\n-        LIR_Opr tmp2 = force_to_spill(tmp1, T_DOUBLE);\n-        __ convert(x->op(), tmp2, reg);\n-        return;\n-      }\n-\n-      \/\/ float -> int: result will be stored\n-      case Bytecodes::_f2l:\n-      case Bytecodes::_d2l: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        set_vreg_flag(reg, must_start_in_memory);\n-        __ convert(x->op(), value.result(), reg);\n-        return;\n-      }\n-      case Bytecodes::_f2i:\n-      case Bytecodes::_d2i: {\n-        LIRItem value(x->value(), this);\n-        LIR_Opr reg = rlock_result(x);\n-        value.set_destroys_register(); \/\/ USE_KILL\n-        value.load_item();\n-        \/\/ Convert l2i afterwards.\n-        LIR_Opr tmp1 = new_register(T_LONG);\n-        set_vreg_flag(tmp1, must_start_in_memory);\n-        __ convert(x->op(), value.result(), tmp1);\n-        __ convert(Bytecodes::_l2i, tmp1, reg);\n-        return;\n-      }\n-\n-      \/\/ Within same category: just register conversions.\n-      case Bytecodes::_i2b:\n-      case Bytecodes::_i2c:\n-      case Bytecodes::_i2s:\n-      case Bytecodes::_i2l:\n-      case Bytecodes::_l2i:\n-      case Bytecodes::_f2d:\n-      case Bytecodes::_d2f:\n-        break;\n-\n-      default: ShouldNotReachHere();\n-    }\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":6,"deletions":84,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2022, SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2025 SAP SE. All rights reserved.\n@@ -37,4 +37,0 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n@@ -42,7 +38,0 @@\n-  \/\/ Using pc relative address computation.\n-  {\n-    Label next_pc;\n-    __ bl(next_pc);\n-    __ bind(next_pc);\n-  }\n-  int current_offset = __ offset();\n@@ -50,8 +39,1 @@\n-  __ load_const32(R12, _safepoint_offset - current_offset);\n-  __ mflr(R0);\n-  __ add(R12, R12, R0);\n-  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n-\n-  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n-  __ mtctr(R0);\n-  __ bctr();\n+  __ jump_to_polling_page_return_handler_blob(_safepoint_offset, true);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_CodeStubs_ppc.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -237,8 +237,1 @@\n-  if (VM_Version::has_isel()) {\n-    isel(cnt1, CR0, Assembler::greater, \/*invert*\/ false, cnt2);\n-  } else {\n-    Label Lskip;\n-    blt(CR0, Lskip);\n-    mr(cnt1, cnt2);\n-    bind(Lskip);\n-  }\n+  isel(cnt1, CR0, Assembler::greater, \/*invert*\/ false, cnt2);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -115,6 +115,1 @@\n-        if (VM_Version::has_mtfprd()) {\n-          __ mtfprd(as_FloatRegister(to_reg), as_Register(from_reg));\n-        } else {\n-          __ std(as_Register(from_reg), -8, R1_SP);\n-          __ lfd(as_FloatRegister(to_reg), -8, R1_SP);\n-        }\n+        __ mtfprd(as_FloatRegister(to_reg), as_Register(from_reg));\n@@ -153,6 +148,1 @@\n-        if (VM_Version::has_mtfprd()) {\n-          __ mffprd(as_Register(to_reg), as_FloatRegister(from_reg));\n-        } else {\n-          __ stfd(as_FloatRegister(from_reg), -8, R1_SP);\n-          __ ld(as_Register(to_reg), -8, R1_SP);\n-        }\n+        __ mffprd(as_Register(to_reg), as_FloatRegister(from_reg));\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map);\n+  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -394,0 +394,39 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+inline intptr_t* frame::sender_sp(intptr_t* fp) { return fp; }\n+\n+\/\/ Extract common_abi parts.\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(((common_abi*)sp)->callers_sp);\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) { return frame::fp(fp); }\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(((common_abi*)sp)->lr);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) { return frame::return_address(fp); }\n+\n+\/\/ Extract java interpreter state parts.\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(*(fp + ijava_idx(bcp)));\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(*(fp + ijava_idx(sender_sp)));\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp - ((frame::ijava_state_size + frame::top_ijava_frame_abi_size) >> LogBytesPerWord);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -363,7 +363,2 @@\n-  if (VM_Version::has_isel()) {\n-    __ xori(tmp1, tmp1, markWord::lock_mask_in_place);\n-    __ isel(dst, CR0, Assembler::equal, false, tmp1);\n-  } else {\n-    __ bne(CR0, done);\n-    __ xori(dst, tmp1, markWord::lock_mask_in_place);\n-  }\n+  __ xori(tmp1, tmp1, markWord::lock_mask_in_place);\n+  __ isel(dst, CR0, Assembler::equal, false, tmp1);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  product(bool, SuperwordUseVSX, false,                                     \\\n+  product(bool, SuperwordUseVSX, true,                                      \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -173,1 +173,5 @@\n-  void merge_frames(Register Rtop_frame_sp, Register return_pc, Register Rscratch1, Register Rscratch2); \/\/ merge top frames\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+  void load_fp(Register fp);\n+  void remove_top_frame_given_fp(Register fp, Register sender_sp, Register sender_fp, Register return_pc, Register temp);\n+  void merge_frames(Register sender_sp, Register return_pc, Register temp1, Register temp2); \/\/ merge top frames\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -311,6 +311,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mtfprd(d, l);\n-  } else {\n-    std(l, 0, R15_esp);\n-    lfd(d, 0, R15_esp);\n-  }\n+  mtfprd(d, l);\n@@ -320,6 +315,1 @@\n-  if (VM_Version::has_mtfprd()) {\n-    mffprd(l, d);\n-  } else {\n-    stfd(d, 0, R15_esp);\n-    ld(l, 0, R15_esp);\n-  }\n+  mffprd(l, d);\n@@ -796,8 +786,11 @@\n-void InterpreterMacroAssembler::merge_frames(Register Rsender_sp, Register return_pc,\n-                                             Register Rscratch1, Register Rscratch2) {\n-  \/\/ Pop interpreter frame.\n-  ld(Rscratch1, 0, R1_SP); \/\/ *SP\n-  ld(Rsender_sp, _ijava_state_neg(sender_sp), Rscratch1); \/\/ top_frame_sp\n-  ld(Rscratch2, 0, Rscratch1); \/\/ **SP\n-  if (return_pc!=noreg) {\n-    ld(return_pc, _abi0(lr), Rscratch1); \/\/ LR\n+void InterpreterMacroAssembler::load_fp(Register fp) {\n+  ld(fp, _abi0(callers_sp), R1_SP); \/\/ *SP\n+}\n+\n+void InterpreterMacroAssembler::remove_top_frame_given_fp(Register fp, Register sender_sp, Register sender_fp,\n+                                                          Register return_pc, Register temp) {\n+  assert_different_registers(sender_sp, sender_fp, return_pc, temp);\n+  ld(sender_sp, _ijava_state_neg(sender_sp), fp);\n+  ld(sender_fp, _abi0(callers_sp), fp); \/\/ **SP\n+  if (return_pc != noreg) {\n+    ld(return_pc, _abi0(lr), fp); \/\/ last usage of fp, register can be reused\n@@ -805,0 +798,3 @@\n+  subf(temp, R1_SP, sender_sp);   \/\/ sender_sp - SP\n+  stdux(sender_fp, R1_SP, temp);  \/\/ atomically set *(SP = sender_sp) = sender_fp\n+}\n@@ -806,3 +802,5 @@\n-  \/\/ Merge top frames.\n-  subf(Rscratch1, R1_SP, Rsender_sp); \/\/ top_frame_sp - SP\n-  stdux(Rscratch2, R1_SP, Rscratch1); \/\/ atomically set *(SP = top_frame_sp) = **SP\n+void InterpreterMacroAssembler::merge_frames(Register sender_sp, Register return_pc,\n+                                             Register temp1, Register temp2) {\n+  Register fp = temp1, sender_fp = temp2;\n+  load_fp(fp);\n+  remove_top_frame_given_fp(fp, sender_sp, sender_fp, return_pc, \/* temp *\/ fp);\n@@ -867,0 +865,2 @@\n+  unlock_if_synchronized_method(state, throw_monitor_exception, install_monitor_exception);\n+\n@@ -870,2 +870,5 @@\n-  Label slow_path;\n-  Label fast_path;\n+  Label slow_path, fast_path;\n+  Register fp = R22_tmp2;\n+  load_fp(fp);\n+\n+  JFR_ONLY(enter_jfr_critical_section();)\n@@ -883,2 +886,0 @@\n-  unlock_if_synchronized_method(state, throw_monitor_exception, install_monitor_exception);\n-\n@@ -904,2 +905,1 @@\n-    ld_ptr(R11_scratch1, _abi0(callers_sp), R1_SP); \/\/ Load frame pointer.\n-    cmpld(CR0, R11_scratch1, R0);\n+    cmpld(CR0, fp, R0);\n@@ -908,0 +908,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -919,1 +921,1 @@\n-  merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n+  remove_top_frame_given_fp(fp, R21_sender_SP, R23_tmp3, \/*return_pc*\/ R0, R11_scratch1);\n@@ -922,0 +924,2 @@\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -925,0 +929,12 @@\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  li(R0, 1);\n+  stb(R0, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR), R16_thread);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  li(R0, 0);\n+  stb(R0, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR), R16_thread);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":46,"deletions":30,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2014 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -76,0 +76,2 @@\n+  intptr_t* last_Java_fp() const      { return *(intptr_t**)_last_Java_sp; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/javaFrameAnchor_ppc.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1555,4 +1555,0 @@\n-  \/\/ For older processors, instruction_type != size holds, and we\n-  \/\/ emulate the sub-word instructions by constructing a 4-byte value\n-  \/\/ that leaves the other bytes unchanged.\n-  const int instruction_type = VM_Version::has_lqarx() ? size : 4;\n@@ -1565,15 +1561,0 @@\n-  if (instruction_type != size) {\n-    assert_different_registers(tmp1, tmp2, tmp3, dest_current_value, exchange_value, addr_base);\n-    modval = tmp1;\n-    shift_amount = tmp2;\n-    val32 = tmp3;\n-    \/\/ Need some preparation: Compute shift amount, align address. Note: shorts must be 2 byte aligned.\n-#ifdef VM_LITTLE_ENDIAN\n-    rldic(shift_amount, addr_base, 3, 64-5); \/\/ (dest & 3) * 8;\n-    clrrdi(addr_base, addr_base, 2);\n-#else\n-    xori(shift_amount, addr_base, (size == 1) ? 3 : 2);\n-    clrrdi(addr_base, addr_base, 2);\n-    rldic(shift_amount, shift_amount, 3, 64-5); \/\/ byte: ((3-dest) & 3) * 8; short: ((1-dest\/2) & 1) * 16;\n-#endif\n-  }\n@@ -1584,1 +1565,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1591,4 +1572,0 @@\n-  if (instruction_type != size) {\n-    srw(dest_current_value, val32, shift_amount);\n-  }\n-\n@@ -1597,7 +1574,0 @@\n-  if (instruction_type != size) {\n-    \/\/ Transform exchange value such that the replacement can be done by one xor instruction.\n-    xorr(modval, dest_current_value, is_add ? modval : exchange_value);\n-    clrldi(modval, modval, (size == 1) ? 56 : 48);\n-    slw(modval, modval, shift_amount);\n-    xorr(modval, val32, modval);\n-  }\n@@ -1605,1 +1575,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1630,2 +1600,1 @@\n-                                       Register addr_base, Register tmp1, Register tmp2,\n-                                       Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n+                                       Register addr_base, Label &retry, Label &failed, bool cmpxchgx_hint, int size) {\n@@ -1633,5 +1602,0 @@\n-  \/\/ For older processors, instruction_type != size holds, and we\n-  \/\/ emulate the sub-word instructions by constructing a 4-byte value\n-  \/\/ that leaves the other bytes unchanged.\n-  const int instruction_type = VM_Version::has_lqarx() ? size : 4;\n-\n@@ -1642,20 +1606,0 @@\n-  if (instruction_type != size) {\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n-    shift_amount = tmp1;\n-    val32 = tmp2;\n-    modval = tmp2;\n-    \/\/ Need some preparation: Compute shift amount, align address. Note: shorts must be 2 byte aligned.\n-#ifdef VM_LITTLE_ENDIAN\n-    rldic(shift_amount, addr_base, 3, 64-5); \/\/ (dest & 3) * 8;\n-    clrrdi(addr_base, addr_base, 2);\n-#else\n-    xori(shift_amount, addr_base, (size == 1) ? 3 : 2);\n-    clrrdi(addr_base, addr_base, 2);\n-    rldic(shift_amount, shift_amount, 3, 64-5); \/\/ byte: ((3-dest) & 3) * 8; short: ((1-dest\/2) & 1) * 16;\n-#endif\n-    \/\/ Transform exchange value such that the replacement can be done by one xor instruction.\n-    xorr(exchange_value, compare_value, exchange_value);\n-    clrldi(exchange_value, exchange_value, (size == 1) ? 56 : 48);\n-    slw(exchange_value, exchange_value, shift_amount);\n-  }\n-\n@@ -1665,1 +1609,1 @@\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1672,3 +1616,0 @@\n-  if (instruction_type != size) {\n-    srw(dest_current_value, val32, shift_amount);\n-  }\n@@ -1690,5 +1631,1 @@\n-  if (instruction_type != size) {\n-    xorr(modval, val32, exchange_value);\n-  }\n-\n-  switch (instruction_type) {\n+  switch (size) {\n@@ -1705,2 +1642,1 @@\n-                                     Register addr_base, Register tmp1, Register tmp2,\n-                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Register addr_base, int semantics, bool cmpxchgx_hint, Register int_flag_success,\n@@ -1717,2 +1653,1 @@\n-                            int_flag_success != exchange_value && int_flag_success != addr_base &&\n-                            int_flag_success != tmp1 && int_flag_success != tmp2);\n+                            int_flag_success != exchange_value && int_flag_success != addr_base);\n@@ -1744,1 +1679,1 @@\n-  cmpxchg_loop_body(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n+  cmpxchg_loop_body(flag, dest_current_value, compare_value, exchange_value, addr_base,\n@@ -3345,0 +3280,29 @@\n+void MacroAssembler::jump_to_polling_page_return_handler_blob(int safepoint_offset, bool fixed_size) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  \/\/ Determine saved exception pc using pc relative address computation.\n+  {\n+    Label next_pc;\n+    bl(next_pc);\n+    bind(next_pc);\n+  }\n+  int current_offset = offset();\n+\n+  if (fixed_size) {\n+    \/\/ Code size must not depend on offsets.\n+    load_const32(R12, safepoint_offset - current_offset);\n+    mflr(R0);\n+    add(R12, R12, R0);\n+  } else {\n+    mflr(R12);\n+    add_const_optimized(R12, R12, safepoint_offset - current_offset);\n+  }\n+  std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+  add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+  mtctr(R0);\n+  bctr();\n+}\n+\n@@ -3720,1 +3684,0 @@\n-  assert(!VM_Version::has_vpmsumb(), \"Vector version should be used instead!\");\n@@ -3853,97 +3816,0 @@\n-\/**\n- * @param crc   register containing existing CRC (32-bit)\n- * @param buf   register pointing to input byte buffer (byte*)\n- * @param len   register containing number of bytes\n- * @param table register pointing to CRC table\n- *\n- * uses R9..R12 as work register. Must be saved\/restored by caller!\n- *\/\n-void MacroAssembler::kernel_crc32_1word(Register crc, Register buf, Register len, Register table,\n-                                        Register t0,  Register t1,  Register t2,  Register t3,\n-                                        Register tc0, Register tc1, Register tc2, Register tc3,\n-                                        bool invertCRC) {\n-  assert_different_registers(crc, buf, len, table);\n-\n-  Label L_mainLoop, L_tail;\n-  Register  tmp          = t0;\n-  Register  data         = t0;\n-  Register  tmp2         = t1;\n-  const int mainLoop_stepping  = 4;\n-  const int tailLoop_stepping  = 1;\n-  const int log_stepping       = exact_log2(mainLoop_stepping);\n-  const int mainLoop_alignment = 32; \/\/ InputForNewCode > 4 ? InputForNewCode : 32;\n-  const int complexThreshold   = 2*mainLoop_stepping;\n-\n-  \/\/ Don't test for len <= 0 here. This pathological case should not occur anyway.\n-  \/\/ Optimizing for it by adding a test and a branch seems to be a waste of CPU cycles\n-  \/\/ for all well-behaved cases. The situation itself is detected and handled correctly\n-  \/\/ within update_byteLoop_crc32.\n-  assert(tailLoop_stepping == 1, \"check tailLoop_stepping!\");\n-\n-  BLOCK_COMMENT(\"kernel_crc32_1word {\");\n-\n-  if (invertCRC) {\n-    nand(crc, crc, crc);                      \/\/ 1s complement of crc\n-  }\n-\n-  \/\/ Check for short (<mainLoop_stepping) buffer.\n-  cmpdi(CR0, len, complexThreshold);\n-  blt(CR0, L_tail);\n-\n-  \/\/ Pre-mainLoop alignment did show a slight (1%) positive effect on performance.\n-  \/\/ We leave the code in for reference. Maybe we need alignment when we exploit vector instructions.\n-  {\n-    \/\/ Align buf addr to mainLoop_stepping boundary.\n-    neg(tmp2, buf);                              \/\/ Calculate # preLoop iterations for alignment.\n-    rldicl(tmp2, tmp2, 0, 64-log_stepping);      \/\/ Rotate tmp2 0 bits, insert into tmp2, anding with mask with 1s from 62..63.\n-\n-    if (complexThreshold > mainLoop_stepping) {\n-      sub(len, len, tmp2);                       \/\/ Remaining bytes for main loop (>=mainLoop_stepping is guaranteed).\n-    } else {\n-      sub(tmp, len, tmp2);                       \/\/ Remaining bytes for main loop.\n-      cmpdi(CR0, tmp, mainLoop_stepping);\n-      blt(CR0, L_tail);                         \/\/ For less than one mainloop_stepping left, do only tail processing\n-      mr(len, tmp);                              \/\/ remaining bytes for main loop (>=mainLoop_stepping is guaranteed).\n-    }\n-    update_byteLoop_crc32(crc, buf, tmp2, table, data, false);\n-  }\n-\n-  srdi(tmp2, len, log_stepping);                 \/\/ #iterations for mainLoop\n-  andi(len, len, mainLoop_stepping-1);           \/\/ remaining bytes for tailLoop\n-  mtctr(tmp2);\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  Register crc_rv = crc;\n-#else\n-  Register crc_rv = tmp;                         \/\/ Load_reverse needs separate registers to work on.\n-                                                 \/\/ Occupies tmp, but frees up crc.\n-  load_reverse_32(crc_rv, crc);                  \/\/ Revert byte order because we are dealing with big-endian data.\n-  tmp = crc;\n-#endif\n-\n-  int reconstructTableOffset = crc32_table_columns(table, tc0, tc1, tc2, tc3);\n-\n-  align(mainLoop_alignment);                     \/\/ Octoword-aligned loop address. Shows 2% improvement.\n-  BIND(L_mainLoop);\n-    update_1word_crc32(crc_rv, buf, table, 0, mainLoop_stepping, crc_rv, t1, t2, t3, tc0, tc1, tc2, tc3);\n-    bdnz(L_mainLoop);\n-\n-#ifndef VM_LITTLE_ENDIAN\n-  load_reverse_32(crc, crc_rv);                  \/\/ Revert byte order because we are dealing with big-endian data.\n-  tmp = crc_rv;                                  \/\/ Tmp uses it's original register again.\n-#endif\n-\n-  \/\/ Restore original table address for tailLoop.\n-  if (reconstructTableOffset != 0) {\n-    addi(table, table, -reconstructTableOffset);\n-  }\n-\n-  \/\/ Process last few (<complexThreshold) bytes of buffer.\n-  BIND(L_tail);\n-  update_byteLoop_crc32(crc, buf, len, table, data, false);\n-\n-  if (invertCRC) {\n-    nand(crc, crc, crc);                      \/\/ 1s complement of crc\n-  }\n-  BLOCK_COMMENT(\"} kernel_crc32_1word\");\n-}\n@@ -4064,5 +3930,3 @@\n-  \/\/ If supported set DSCR pre-fetch to deepest.\n-  if (VM_Version::has_mfdscr()) {\n-    load_const_optimized(t0, VM_Version::_dscr_val | 7);\n-    mtdscr(t0);\n-  }\n+  \/\/ Set DSCR pre-fetch to deepest.\n+  load_const_optimized(t0, VM_Version::_dscr_val | 7);\n+  mtdscr(t0);\n@@ -4212,4 +4076,2 @@\n-  if (VM_Version::has_mfdscr()) {\n-    load_const_optimized(t0, VM_Version::_dscr_val);\n-    mtdscr(t0);\n-  }\n+  load_const_optimized(t0, VM_Version::_dscr_val);\n+  mtdscr(t0);\n@@ -4287,5 +4149,1 @@\n-  if (VM_Version::has_vpmsumb()) {\n-    kernel_crc32_vpmsum(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, !is_crc32c);\n-  } else {\n-    kernel_crc32_1word(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, t0, !is_crc32c);\n-  }\n+  kernel_crc32_vpmsum(crc, buf, len, t0, t1, t2, t3, t4, t5, t6, t7, !is_crc32c);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":43,"deletions":185,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -504,2 +504,1 @@\n-                         Register addr_base, Register tmp1, Register tmp2,\n-                         Label &retry, Label &failed, bool cmpxchgx_hint, int size);\n+                         Register addr_base,Label &retry, Label &failed, bool cmpxchgx_hint, int size);\n@@ -508,2 +507,1 @@\n-                       Register addr_base, Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Register addr_base, int semantics, bool cmpxchgx_hint, Register int_flag_success,\n@@ -552,5 +550,5 @@\n-                Register addr_base, Register tmp1, Register tmp2,\n-                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n-                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n-                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n+                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n+                Register int_flag_success = noreg, Label* failed = nullptr,\n+                bool contention_hint = false, bool weak = false) {\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, semantics,\n+                    cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -562,4 +560,4 @@\n-                Register addr_base, Register tmp1, Register tmp2,\n-                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n-                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, tmp1, tmp2,\n+                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n+                Register int_flag_success = noreg, Label* failed = nullptr,\n+                bool contention_hint = false, bool weak = false) {\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base,\n@@ -573,1 +571,1 @@\n-    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base, noreg, noreg,\n+    cmpxchg_generic(flag, dest_current_value, compare_value, exchange_value, addr_base,\n@@ -734,0 +732,1 @@\n+  void jump_to_polling_page_return_handler_blob(int safepoint_offset, bool fixed_size = false);\n@@ -900,4 +899,0 @@\n-  void kernel_crc32_1word(Register crc, Register buf, Register len, Register table,\n-                          Register t0,  Register t1,  Register t2,  Register t3,\n-                          Register tc0, Register tc1, Register tc2, Register tc3,\n-                          bool invertCRC);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -470,12 +470,4 @@\n-    if (VM_Version::has_isel()) {\n-      cmpdi(CR0, src, 0);\n-      Register co = encode_heap_oop_not_null(d, src);\n-      assert(co == d, \"sanity\");\n-      isel_0(d, CR0, Assembler::equal);\n-    } else {\n-      Label isNull;\n-      or_(d, src, src); \/\/ move and compare 0\n-      beq(CR0, isNull);\n-      encode_heap_oop_not_null(d, src);\n-      bind(isNull);\n-    }\n+    cmpdi(CR0, src, 0);\n+    Register co = encode_heap_oop_not_null(d, src);\n+    assert(co == d, \"sanity\");\n+    isel_0(d, CR0, Assembler::equal);\n@@ -513,5 +505,1 @@\n-    if (VM_Version::has_isel()) {\n-      use_isel = true;\n-    } else {\n-      beq(CR0, isNull);\n-    }\n+    use_isel = true;\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -161,2 +161,1 @@\n-  \/\/ false means that conversion is done by runtime call\n-  static bool convL2FSupported(void) {\n+  static constexpr bool convL2FSupported(void) {\n@@ -165,1 +164,1 @@\n-    return VM_Version::has_fcfids();\n+    return true;\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2365,4 +2365,0 @@\n-    case Op_SqrtD:\n-      return VM_Version::has_fsqrt();\n-    case Op_RoundDoubleMode:\n-      return VM_Version::has_vsx();\n@@ -2377,1 +2373,1 @@\n-      return (UsePopCountInstruction && VM_Version::has_popcntw());\n+      return UsePopCountInstruction;\n@@ -2381,1 +2377,0 @@\n-\n@@ -3188,0 +3183,10 @@\n+    \/\/ use isel instruction with Power 7\n+    cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n+    encodeP_subNode    *n_sub_base = new encodeP_subNode();\n+    encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n+    cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n+\n+    n_compare->add_req(n_region, n_src);\n+    n_compare->_opnds[0] = op_crx;\n+    n_compare->_opnds[1] = op_src;\n+    n_compare->_opnds[2] = new immL16Oper(0);\n@@ -3189,37 +3194,4 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_subNode    *n_sub_base = new encodeP_subNode();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      n_cond_set->add_req(n_region, n_compare, n_shift);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-      nodes->push(n_cond_set);\n+    n_sub_base->add_req(n_region, n_src);\n+    n_sub_base->_opnds[0] = op_dst;\n+    n_sub_base->_opnds[1] = op_src;\n+    n_sub_base->_bottom_type = _bottom_type;\n@@ -3227,40 +3199,20 @@\n-    } else {\n-      \/\/ before Power 7\n-      moveRegNode        *n_move     = new moveRegNode();\n-      cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();\n-      encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();\n-      cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();\n-\n-      n_move->add_req(n_region, n_src);\n-      n_move->_opnds[0] = op_dst;\n-      n_move->_opnds[1] = op_src;\n-      ra_->set_oop(n_move, true); \/\/ Until here, 'n_move' still produces an oop.\n-\n-      n_compare->add_req(n_region, n_src);\n-      n_compare->add_prec(n_move);\n-\n-      n_compare->_opnds[0] = op_crx;\n-      n_compare->_opnds[1] = op_src;\n-      n_compare->_opnds[2] = new immL16Oper(0);\n-\n-      n_sub_base->add_req(n_region, n_compare, n_src);\n-      n_sub_base->_opnds[0] = op_dst;\n-      n_sub_base->_opnds[1] = op_crx;\n-      n_sub_base->_opnds[2] = op_src;\n-      n_sub_base->_bottom_type = _bottom_type;\n-\n-      n_shift->add_req(n_region, n_sub_base);\n-      n_shift->_opnds[0] = op_dst;\n-      n_shift->_opnds[1] = op_dst;\n-      n_shift->_bottom_type = _bottom_type;\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_move->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-\n-      nodes->push(n_move);\n-      nodes->push(n_compare);\n-      nodes->push(n_sub_base);\n-      nodes->push(n_shift);\n-    }\n+    n_shift->add_req(n_region, n_sub_base);\n+    n_shift->_opnds[0] = op_dst;\n+    n_shift->_opnds[1] = op_dst;\n+    n_shift->_bottom_type = _bottom_type;\n+\n+    n_cond_set->add_req(n_region, n_compare, n_shift);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n+\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_sub_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+\n+    nodes->push(n_compare);\n+    nodes->push(n_sub_base);\n+    nodes->push(n_shift);\n+    nodes->push(n_cond_set);\n@@ -3306,23 +3258,6 @@\n-    if (VM_Version::has_isel()) {\n-      \/\/ use isel instruction with Power 7\n-\n-      decodeN_addNode *n_add_base = new decodeN_addNode();\n-      n_add_base->add_req(n_region, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n-\n-      cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n-      n_cond_set->add_req(n_region, n_compare, n_add_base);\n-      n_cond_set->_opnds[0] = op_dst;\n-      n_cond_set->_opnds[1] = op_crx;\n-      n_cond_set->_opnds[2] = op_dst;\n-      n_cond_set->_bottom_type = _bottom_type;\n-\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_cond_set, true);\n-\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    \/\/ use isel instruction with Power 7\n+    decodeN_addNode *n_add_base = new decodeN_addNode();\n+    n_add_base->add_req(n_region, n_shift);\n+    n_add_base->_opnds[0] = op_dst;\n+    n_add_base->_opnds[1] = op_dst;\n+    n_add_base->_bottom_type = _bottom_type;\n@@ -3330,8 +3265,6 @@\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-      nodes->push(n_cond_set);\n-\n-    } else {\n-      \/\/ before Power 7\n-      cond_add_baseNode *n_add_base = new cond_add_baseNode();\n+    cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();\n+    n_cond_set->add_req(n_region, n_compare, n_add_base);\n+    n_cond_set->_opnds[0] = op_dst;\n+    n_cond_set->_opnds[1] = op_crx;\n+    n_cond_set->_opnds[2] = op_dst;\n+    n_cond_set->_bottom_type = _bottom_type;\n@@ -3339,5 +3272,2 @@\n-      n_add_base->add_req(n_region, n_compare, n_shift);\n-      n_add_base->_opnds[0] = op_dst;\n-      n_add_base->_opnds[1] = op_crx;\n-      n_add_base->_opnds[2] = op_dst;\n-      n_add_base->_bottom_type = _bottom_type;\n+    assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n+    ra_->set_oop(n_cond_set, true);\n@@ -3345,2 +3275,4 @@\n-      assert(ra_->is_oop(this) == true, \"A decodeN node must produce an oop!\");\n-      ra_->set_oop(n_add_base, true);\n+    ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n+    ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    ra_->set_pair(n_cond_set->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n@@ -3348,3 +3280,4 @@\n-      ra_->set_pair(n_shift->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n-      ra_->set_pair(n_compare->_idx, ra_->get_reg_second(n_crx), ra_->get_reg_first(n_crx));\n-      ra_->set_pair(n_add_base->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this));\n+    nodes->push(n_compare);\n+    nodes->push(n_shift);\n+    nodes->push(n_add_base);\n+    nodes->push(n_cond_set);\n@@ -3352,4 +3285,0 @@\n-      nodes->push(n_compare);\n-      nodes->push(n_shift);\n-      nodes->push(n_add_base);\n-    }\n@@ -3380,19 +3309,0 @@\n-  enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{\n-    int cc        = $cmp$$cmpcode;\n-    int flags_reg = $crx$$reg;\n-    Label done;\n-    assert((Assembler::bcondCRbiIs1 & ~Assembler::bcondCRbiIs0) == 8, \"check encoding\");\n-    \/\/ Branch if not (cmp crx).\n-    __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);\n-    __ mr($dst$$Register, $src$$Register);\n-    __ bind(done);\n-  %}\n-\n-  enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{\n-    Label done;\n-    assert((Assembler::bcondCRbiIs1 & ~Assembler::bcondCRbiIs0) == 8, \"check encoding\");\n-    \/\/ Branch if not (cmp crx).\n-    __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);\n-    __ li($dst$$Register, $src$$constant);\n-    __ bind(done);\n-  %}\n@@ -7099,1 +7009,1 @@\n-            CompressedOops::base_disjoint() && VM_Version::has_isel());\n+            CompressedOops::base_disjoint());\n@@ -7479,1 +7389,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7494,27 +7403,0 @@\n-instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{\n-  match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{\n-  match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7524,1 +7406,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7539,27 +7420,0 @@\n-instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{\n-  match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{\n-  match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7569,1 +7423,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7584,28 +7437,0 @@\n-\/\/ Conditional move for RegN. Only cmov(reg, reg).\n-instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{\n-  match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{\n-  match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7615,1 +7440,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -7630,27 +7454,0 @@\n-instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{\n-  match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));\n-  predicate(!VM_Version::has_isel());\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_reg(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{\n-  match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));\n-  ins_cost(DEFAULT_COST+BRANCH_COST);\n-\n-  ins_variable_size_depending_on_alignment(true);\n-\n-  format %{ \"CMOVE   $cmp, $crx, $dst, $src\\n\\t\" %}\n-  \/\/ Worst case is branch + move + stop, no stop without scheduler.\n-  size(8);\n-  ins_encode( enc_cmove_imm(dst, crx, src, cmp) );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -7707,1 +7504,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7712,20 +7508,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7745,1 +7522,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -7750,20 +7526,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                $res$$Register, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7859,1 +7616,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7864,15 +7621,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7887,1 +7630,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) );\n@@ -7892,15 +7635,1 @@\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgb(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7915,1 +7644,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -7920,15 +7649,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -7943,1 +7658,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n@@ -7948,15 +7663,1 @@\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); \/\/ TEMP_DEF to avoid jump\n-  format %{ \"weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,\n+    __ cmpxchgh(CR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8094,1 +7795,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -8099,15 +7800,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8122,1 +7809,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n@@ -8127,1 +7814,1 @@\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8140,19 +7827,0 @@\n-instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgb(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8162,1 +7830,1 @@\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && VM_Version::has_lqarx());\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n@@ -8167,15 +7835,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8190,1 +7844,1 @@\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && VM_Version::has_lqarx());\n+  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst));\n@@ -8195,1 +7849,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,\n+    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8208,5 +7862,5 @@\n-instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));\n-  predicate((((CompareAndSwapNode*)n)->order() == MemNode::acquire || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst) && !VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);\n-  format %{ \"CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int\" %}\n+instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{\n+  match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n+  effect(TEMP_DEF res, TEMP cr0);\n+  format %{ \"CMPXCHGW $res, $mem_ptr, $src1, $src2; as int\" %}\n@@ -8215,21 +7869,1 @@\n-    __ cmpxchgh(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,\n-                MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),\n-                noreg, nullptr, true);\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      \/\/ isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don't optimize for that.\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{\n-  match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));\n-  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n-  effect(TEMP_DEF res, TEMP cr0);\n-  format %{ \"CMPXCHGW $res, $mem_ptr, $src1, $src2; as int\" %}\n-  ins_encode %{\n-    \/\/ CmpxchgX sets CR0 to cmpX(src1, src2) and Rres to 'true'\/'false'.\n-    __ cmpxchgw(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n+    __ cmpxchgw(CR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,\n@@ -8370,1 +8004,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8385,17 +8018,0 @@\n-instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -8404,1 +8020,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8419,16 +8034,0 @@\n-instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndAddS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndAddS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -8470,1 +8069,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8485,17 +8083,0 @@\n-instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetB mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetB $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n-\n@@ -8504,1 +8085,0 @@\n-  predicate(VM_Version::has_lqarx());\n@@ -8519,16 +8099,0 @@\n-instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{\n-  match(Set res (GetAndSetS mem_ptr src));\n-  predicate(!VM_Version::has_lqarx());\n-  effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);\n-  format %{ \"GetAndSetS $res, $mem_ptr, $src\" %}\n-  ins_encode %{\n-    __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,\n-                  R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());\n-    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n-      __ isync();\n-    } else {\n-      __ sync();\n-    }\n-  %}\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -9823,1 +9387,0 @@\n-\/\/ VM_Version::has_fsqrt() decides if this node will be used.\n@@ -9838,1 +9401,0 @@\n-  predicate(VM_Version::has_fsqrts());\n@@ -10340,1 +9902,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -10460,12 +10021,0 @@\n-\/\/----------Moves between long and float\n-\n-instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE src);\n-  predicate(false);\n-\n-  format %{ \"storeD  $src, $dst \\t\/\/ STACK\" %}\n-  size(4);\n-  ins_encode( enc_stfd(src, dst) );\n-  ins_pipe(pipe_class_default);\n-%}\n@@ -10497,21 +10046,0 @@\n-\/\/ Move long value from long stack-location to double register.\n-instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"LFD     $dst, $src \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_lfd(dst, src) );\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n-\/\/ Move long value from long register to double stack-location.\n-instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{\n-  match(Set dst (MoveL2D src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"STD     $src, $dst \\t\/\/ MoveL2D\" %}\n-  size(4);\n-  ins_encode( enc_std(src, dst) );\n-  ins_pipe(pipe_class_memory);\n-%}\n@@ -10917,53 +10445,0 @@\n-instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovI   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovI_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConI16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovI_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConI16Node();\n-    MachNode *m2 = new cmovI_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-\n-    \/\/ precedences for new nodes\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immI16Oper(0);\n-\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -11025,16 +10500,0 @@\n-\/\/ Double to Int conversion, NaN is mapped to 0.\n-instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{\n-  match(Set dst (ConvD2I src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2IRaw_regD(tmpD, src);                         \/\/ Convert float to int (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11045,1 +10504,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11070,16 +10528,0 @@\n-\/\/ Float to Int conversion, NaN is mapped to 0.\n-instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{\n-  match(Set dst (ConvF2I src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2IRaw_regF(tmpF, src);                         \/\/ Convert float to int (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11090,1 +10532,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11181,50 +10622,0 @@\n-instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx, USE mem);\n-  predicate(false);\n-\n-  format %{ \"CmovL   $dst, $crx, $mem \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  dst  crx  mem\n-    \/\/    \\       |    |   \/\n-    \/\/     dst=cmovL_bso_stackSlotL_conLvalue0\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region  dst\n-    \/\/    \\       \/\n-    \/\/     dst=loadConL16(0)\n-    \/\/      |\n-    \/\/      ^  region  dst  crx  mem\n-    \/\/      |   \\       |    |    \/\n-    \/\/      dst=cmovL_bso_stackSlotL\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConL16Node();\n-    MachNode *m2 = new cmovL_bso_stackSlotLNode();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx, n_mem);\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immL16Oper(0);\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-    m2->_opnds[2] = op_mem;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n@@ -11283,16 +10674,0 @@\n-\/\/ Float to Long conversion, NaN is mapped to 0.\n-instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{\n-  match(Set dst (ConvF2L src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regF tmpF;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpFUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convF2LRaw_regF(tmpF, src);                         \/\/ Convert float to long (speculated).\n-    moveF2L_reg_stack(tmpS, tmpF);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11303,1 +10678,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11328,16 +10702,0 @@\n-\/\/ Double to Long conversion, NaN is mapped to 0.\n-instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{\n-  match(Set dst (ConvD2L src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    stackSlotL tmpS;\n-    flagsReg crx;\n-    cmpDUnordered_reg_reg(crx, src, src);               \/\/ Check whether src is NaN.\n-    convD2LRaw_regD(tmpD, src);                         \/\/ Convert float to long (speculated).\n-    moveD2L_reg_stack(tmpS, tmpD);                      \/\/ Store float to stack (speculated).\n-    cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); \/\/ Cmove based on NaN check.\n-  %}\n-%}\n@@ -11348,1 +10706,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11387,19 +10744,0 @@\n-\/\/ Integer to Float conversion.\n-instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  predicate(!VM_Version::has_fcfids());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regD tmpD2;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(tmpD2, tmpD);        \/\/ Convert to double.\n-    convD2F_reg(dst, tmpD2);             \/\/ Convert double to float.\n-  %}\n-%}\n-\n@@ -11419,16 +10757,0 @@\n-\/\/ Integer to Float conversion. Special version for Power7.\n-instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2F src));\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -11439,1 +10761,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -11449,14 +10770,0 @@\n-\/\/ L2F to avoid runtime call.\n-instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{\n-  match(Set dst (ConvL2F src));\n-  predicate(VM_Version::has_fcfids() && !VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    regL_to_stkL(tmpS, src);             \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2FRaw_regF(dst, tmpD);          \/\/ Convert to float.\n-  %}\n-%}\n@@ -11467,1 +10774,0 @@\n-  predicate(VM_Version::has_fcfids() && VM_Version::has_mtfprd());\n@@ -11482,16 +10788,0 @@\n-\/\/ Integer to Double conversion.\n-instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{\n-  match(Set dst (ConvI2D src));\n-  predicate(!VM_Version::has_mtfprd());\n-  ins_cost(DEFAULT_COST);\n-\n-  expand %{\n-    iRegLdst tmpL;\n-    stackSlotL tmpS;\n-    regD tmpD;\n-    convI2L_reg(tmpL, src);              \/\/ Sign-extension int to long.\n-    regL_to_stkL(tmpS, tmpL);            \/\/ Store long to stack.\n-    moveL2D_stack_reg(tmpD, tmpS);       \/\/ Load long into double register.\n-    convL2DRaw_regD(dst, tmpD);          \/\/ Convert to double.\n-  %}\n-%}\n@@ -11502,1 +10792,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -11512,11 +10801,0 @@\n-\/\/ Long to Double conversion\n-instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{\n-  match(Set dst (ConvL2D src));\n-  ins_cost(DEFAULT_COST + MEMORY_REF_COST);\n-\n-  expand %{\n-    regD tmpD;\n-    moveL2D_stack_reg(tmpD, src);\n-    convL2DRaw_regD(dst, tmpD);\n-  %}\n-%}\n@@ -11527,1 +10805,0 @@\n-  predicate(VM_Version::has_mtfprd());\n@@ -13122,19 +12399,0 @@\n-instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MinI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andL_reg_reg(doz, diff, sm); \/\/ <=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n@@ -13145,1 +12403,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -13155,19 +12412,0 @@\n-instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{\n-  match(Set dst (MaxI src1 src2));\n-  ins_cost(DEFAULT_COST*6);\n-\n-  expand %{\n-    iRegLdst src1s;\n-    iRegLdst src2s;\n-    iRegLdst diff;\n-    iRegLdst sm;\n-    iRegLdst doz; \/\/ difference or zero\n-    convI2L_reg(src1s, src1); \/\/ Ensure proper sign extension.\n-    convI2L_reg(src2s, src2); \/\/ Ensure proper sign extension.\n-    subL_reg_reg(diff, src2s, src1s);\n-    \/\/ Need to consider >=33 bit result, therefore we need signmaskL.\n-    signmask64L_regL(sm, diff);\n-    andcL_reg_reg(doz, diff, sm); \/\/ >=0\n-    addI_regL_regL(dst, doz, src1s);\n-  %}\n-%}\n@@ -13178,1 +12416,0 @@\n-  predicate(VM_Version::has_isel());\n@@ -13193,1 +12430,1 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n@@ -13206,1 +12443,1 @@\n-  predicate(UsePopCountInstruction && VM_Version::has_popcntw());\n+  predicate(UsePopCountInstruction);\n@@ -13565,1 +12802,1 @@\n-  predicate(VM_Version::has_ldbrx() && (n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n+  predicate((n->in(1)->as_Load()->is_unordered() || followed_by_acquire(n->in(1))));\n@@ -13577,1 +12814,0 @@\n-  predicate(VM_Version::has_ldbrx());\n@@ -13658,1 +12894,0 @@\n-  predicate(VM_Version::has_stdbrx());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":85,"deletions":850,"binary":false,"changes":935,"status":"modified"},{"patch":"@@ -2743,0 +2743,15 @@\n+  \/\/ Prepare for return\n+  \/\/ --------------------------------------------------------------------------\n+  __ pop_frame();\n+  __ restore_LR(R11);\n+\n+#if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_stub;\n+  int safepoint_offset = __ offset();\n+  if (!UseSIGTRAP) {\n+    __ relocate(relocInfo::poll_return_type);\n+  }\n+  __ safepoint_poll(L_stub, r_temp_2, true \/* at_return *\/, true \/* in_nmethod: frame already popped *\/);\n+#endif \/\/ INCLUDE_JFR\n@@ -2750,5 +2765,1 @@\n-  \/\/ Return\n-  \/\/ --------------------------------------------------------------------------\n-\n-  __ pop_frame();\n-  __ restore_LR(R11);\n+  \/\/ Return.\n@@ -2757,0 +2768,7 @@\n+  \/\/ Handler for return safepoint (out-of-line).\n+#if INCLUDE_JFR\n+  if (!UseSIGTRAP) {\n+    __ bind(L_stub);\n+    __ jump_to_polling_page_return_handler_blob(safepoint_offset);\n+  }\n+#endif \/\/ INCLUDE_JFR\n@@ -2764,3 +2782,0 @@\n-\n-  __ pop_frame();\n-  __ restore_LR(R11);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -957,4 +957,2 @@\n-    if (VM_Version::has_mfdscr()) {\n-      __ load_const_optimized(tmp1, VM_Version::_dscr_val);\n-      __ mtdscr(tmp1);\n-    }\n+    __ load_const_optimized(tmp1, VM_Version::_dscr_val);\n+    __ mtdscr(tmp1);\n@@ -1072,19 +1070,0 @@\n-       if (!VM_Version::has_vsx()) {\n-\n-        __ bind(l_8);\n-        \/\/ Use unrolled version for mass copying (copy 32 elements a time)\n-        \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-        \/\/ Therefore, the following sequence is made for the good of both.\n-        __ ld(tmp1, 0, R3_ARG1);\n-        __ ld(tmp2, 8, R3_ARG1);\n-        __ ld(tmp3, 16, R3_ARG1);\n-        __ ld(tmp4, 24, R3_ARG1);\n-        __ std(tmp1, 0, R4_ARG2);\n-        __ std(tmp2, 8, R4_ARG2);\n-        __ std(tmp3, 16, R4_ARG2);\n-        __ std(tmp4, 24, R4_ARG2);\n-        __ addi(R3_ARG1, R3_ARG1, 32);\n-        __ addi(R4_ARG2, R4_ARG2, 32);\n-        __ bdnz(l_8);\n-\n-      } else { \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1096,4 +1075,2 @@\n-        if (VM_Version::has_mfdscr()) {\n-          __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-          __ mtdscr(tmp2);\n-        }\n+        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+        __ mtdscr(tmp2);\n@@ -1120,4 +1097,2 @@\n-        if (VM_Version::has_mfdscr()) {\n-          __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-          __ mtdscr(tmp2);\n-        }\n+        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+        __ mtdscr(tmp2);\n@@ -1125,1 +1100,0 @@\n-      } \/\/ VSX\n@@ -1368,19 +1342,2 @@\n-        if (!VM_Version::has_vsx()) {\n-\n-          __ bind(l_8);\n-          \/\/ Use unrolled version for mass copying (copy 16 elements a time).\n-          \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-          \/\/ Therefore, the following sequence is made for the good of both.\n-          __ ld(tmp1, 0, R3_ARG1);\n-          __ ld(tmp2, 8, R3_ARG1);\n-          __ ld(tmp3, 16, R3_ARG1);\n-          __ ld(tmp4, 24, R3_ARG1);\n-          __ std(tmp1, 0, R4_ARG2);\n-          __ std(tmp2, 8, R4_ARG2);\n-          __ std(tmp3, 16, R4_ARG2);\n-          __ std(tmp4, 24, R4_ARG2);\n-          __ addi(R3_ARG1, R3_ARG1, 32);\n-          __ addi(R4_ARG2, R4_ARG2, 32);\n-          __ bdnz(l_8);\n-\n-        } else { \/\/ Processor supports VSX, so use it to mass copy.\n+\n+        \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1392,4 +1349,2 @@\n-          if (VM_Version::has_mfdscr()) {\n-            __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-            __ mtdscr(tmp2);\n-          }\n+          __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+          __ mtdscr(tmp2);\n@@ -1415,6 +1370,2 @@\n-          if (VM_Version::has_mfdscr()) {\n-            __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-            __ mtdscr(tmp2);\n-          }\n-\n-        }\n+          __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+          __ mtdscr(tmp2);\n@@ -1575,1 +1526,1 @@\n-     if (!VM_Version::has_vsx()) {\n+    \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1577,17 +1528,2 @@\n-      __ bind(l_6);\n-      \/\/ Use unrolled version for mass copying (copy 8 elements a time).\n-      \/\/ Load feeding store gets zero latency on power6, however not on power 5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_6);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n+    \/\/ Prefetch the data into the L2 cache.\n+    __ dcbt(R3_ARG1, 0);\n@@ -1595,2 +1531,3 @@\n-      \/\/ Prefetch the data into the L2 cache.\n-      __ dcbt(R3_ARG1, 0);\n+    \/\/ Set DSCR pre-fetch to deepest.\n+    __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+    __ mtdscr(tmp2);\n@@ -1598,5 +1535,1 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+    __ li(tmp1, 16);\n@@ -1604,1 +1537,4 @@\n-      __ li(tmp1, 16);\n+    \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n+    \/\/ loop contains < 8 instructions that fit inside a single\n+    \/\/ i-cache sector.\n+    __ align(32);\n@@ -1606,4 +1542,10 @@\n-      \/\/ Backbranch target aligned to 32-byte. Not 16-byte align as\n-      \/\/ loop contains < 8 instructions that fit inside a single\n-      \/\/ i-cache sector.\n-      __ align(32);\n+    __ bind(l_7);\n+    \/\/ Use loop with VSX load\/store instructions to\n+    \/\/ copy 8 elements a time.\n+    __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n+    __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n+    __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n+    __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n+    __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n+    __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n+    __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n@@ -1611,10 +1553,3 @@\n-      __ bind(l_7);\n-      \/\/ Use loop with VSX load\/store instructions to\n-      \/\/ copy 8 elements a time.\n-      __ lxvd2x(tmp_vsr1, R3_ARG1);        \/\/ Load src\n-      __ stxvd2x(tmp_vsr1, R4_ARG2);       \/\/ Store to dst\n-      __ lxvd2x(tmp_vsr2, tmp1, R3_ARG1);  \/\/ Load src + 16\n-      __ stxvd2x(tmp_vsr2, tmp1, R4_ARG2); \/\/ Store to dst + 16\n-      __ addi(R3_ARG1, R3_ARG1, 32);       \/\/ Update src+=32\n-      __ addi(R4_ARG2, R4_ARG2, 32);       \/\/ Update dsc+=32\n-      __ bdnz(l_7);                        \/\/ Dec CTR and loop if not zero.\n+    \/\/ Restore DSCR pre-fetch value.\n+    __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+    __ mtdscr(tmp2);\n@@ -1622,5 +1557,0 @@\n-      \/\/ Restore DSCR pre-fetch value.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n@@ -1628,1 +1558,0 @@\n-    } \/\/ VSX\n@@ -1743,17 +1672,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else {  \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1763,5 +1676,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1788,5 +1699,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n-     }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n@@ -1879,18 +1787,1 @@\n-    if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ addi(R3_ARG1, R3_ARG1, 32);\n-      __ addi(R4_ARG2, R4_ARG2, 32);\n-      __ bdnz(l_4);\n-\n-    } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -1901,5 +1792,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -1926,4 +1815,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n@@ -1931,1 +1818,0 @@\n-    } \/\/ VSX\n@@ -2024,17 +1910,1 @@\n-     if (!VM_Version::has_vsx()) {\n-      __ bind(l_4);\n-      \/\/ Use unrolled version for mass copying (copy 4 elements a time).\n-      \/\/ Load feeding store gets zero latency on Power6, however not on Power5.\n-      \/\/ Therefore, the following sequence is made for the good of both.\n-      __ addi(R3_ARG1, R3_ARG1, -32);\n-      __ addi(R4_ARG2, R4_ARG2, -32);\n-      __ ld(tmp4, 24, R3_ARG1);\n-      __ ld(tmp3, 16, R3_ARG1);\n-      __ ld(tmp2, 8, R3_ARG1);\n-      __ ld(tmp1, 0, R3_ARG1);\n-      __ std(tmp4, 24, R4_ARG2);\n-      __ std(tmp3, 16, R4_ARG2);\n-      __ std(tmp2, 8, R4_ARG2);\n-      __ std(tmp1, 0, R4_ARG2);\n-      __ bdnz(l_4);\n-     } else { \/\/ Processor supports VSX, so use it to mass copy.\n+      \/\/ Processor supports VSX, so use it to mass copy.\n@@ -2044,5 +1914,3 @@\n-      \/\/ If supported set DSCR pre-fetch to deepest.\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n-        __ mtdscr(tmp2);\n-      }\n+      \/\/ Set DSCR pre-fetch to deepest.\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val | 7);\n+      __ mtdscr(tmp2);\n@@ -2069,5 +1937,2 @@\n-      if (VM_Version::has_mfdscr()) {\n-        __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n-        __ mtdscr(tmp2);\n-      }\n-     }\n+      __ load_const_optimized(tmp2, VM_Version::_dscr_val);\n+      __ mtdscr(tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":54,"deletions":189,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-  \/\/ <= Power7 Little Endian: 4 tables for byte folding\n-  \/\/ <= Power7 Big Endian: 1 table for single byte folding + 4 tables for multi-byte folding\n@@ -83,1 +81,0 @@\n-  const bool use_vector = VM_Version::has_vpmsumb();\n@@ -86,1 +83,1 @@\n-  const int size = use_vector ? CRC32_TABLE_SIZE + vector_size : (4 BIG_ENDIAN_ONLY(+1)) * CRC32_TABLE_SIZE;\n+  const int size = CRC32_TABLE_SIZE + vector_size;\n@@ -94,37 +91,2 @@\n-  LITTLE_ENDIAN_ONLY(if (use_vector)) {\n-    for (int i = 0; i < 256; ++i) {\n-      ptr[i] = fold_byte(i, reverse_poly);\n-    }\n-  }\n-\n-  if (!use_vector) {\n-    BIG_ENDIAN_ONLY(ptr = (juint*)(consts + CRC32_TABLE_SIZE);)\n-    \/\/ <= Power7: 4 tables\n-    for (int i = 0; i < 256; ++i) {\n-      juint a = fold_byte(i, reverse_poly),\n-            b = fold_byte(a, reverse_poly),\n-            c = fold_byte(b, reverse_poly),\n-            d = fold_byte(c, reverse_poly);\n-#ifndef VM_LITTLE_ENDIAN\n-      a = byteswap(a);\n-      b = byteswap(b);\n-      c = byteswap(c);\n-      d = byteswap(d);\n-#endif\n-      ptr[i         ] = a;\n-      ptr[i +    256] = b;\n-      ptr[i + 2* 256] = c;\n-      ptr[i + 3* 256] = d;\n-    }\n-#if 0\n-    for (int i = 0; i < 4; ++i) {\n-      tty->print_cr(\"table %d:\", i);\n-      for (int j = 0; j < 32; ++j) {\n-        for (int k = 0; k < 8; ++k) {\n-          tty->print(\"%08x \", ptr[i*256 + j*8 + k]);\n-        }\n-        tty->cr();\n-      }\n-    }\n-#endif\n-    return consts;\n+  for (int i = 0; i < 256; ++i) {\n+    ptr[i] = fold_byte(i, reverse_poly);\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1081,1 +1081,1 @@\n-    case Interpreter::java_lang_math_sqrt: use_instruction = VM_Version::has_fsqrt(); break;\n+    case Interpreter::java_lang_math_sqrt: use_instruction = true; break;\n@@ -1094,1 +1094,1 @@\n-    case Interpreter::java_lang_math_sqrt : runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsqrt);  break;\n+    case Interpreter::java_lang_math_sqrt : \/* run interpreted *\/  break;\n@@ -1587,0 +1587,18 @@\n+  #if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path, fast_path;\n+  __ safepoint_poll(slow_path, R11_scratch1, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  __ b(fast_path);\n+  __ bind(slow_path);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), R16_thread);\n+  __ align(32);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1628,1 +1646,2 @@\n-  __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n+  __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R12_scratch2, R11_scratch1, R0);\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n@@ -1632,1 +1651,1 @@\n-  __ mtlr(R0);\n+  __ mtlr(R12_scratch2);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -322,8 +322,1 @@\n-  if (VM_Version::has_isel()) {\n-    __ isel_0(R17_tos, CR0, Assembler::equal);\n-  } else {\n-    Label not_sentinel;\n-    __ bne(CR0, not_sentinel);\n-    __ li(R17_tos, 0);\n-    __ bind(not_sentinel);\n-  }\n+  __ isel_0(R17_tos, CR0, Assembler::equal);\n@@ -1537,7 +1530,1 @@\n-      if (VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-        \/\/ Comment: alternatively, load with sign extend could be done by lfiwax.\n-        __ fcfids(F15_ftos, F15_ftos);\n-      } else {\n-        __ fcfid(F15_ftos, F15_ftos);\n-        __ frsp(F15_ftos, F15_ftos);\n-      }\n+      __ fcfids(F15_ftos, F15_ftos);\n@@ -1547,9 +1534,2 @@\n-      if (VM_Version::has_fcfids()) { \/\/ fcfids is >= Power7 only\n-        __ move_l_to_d();\n-        __ fcfids(F15_ftos, F15_ftos);\n-      } else {\n-        \/\/ Avoid rounding problem when result should be 0x3f800001: need fixup code before fcfid+frsp.\n-        __ mr(R3_ARG1, R17_tos);\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::l2f));\n-        __ fmr(F15_ftos, F1_RET);\n-      }\n+      __ move_l_to_d();\n+      __ fcfids(F15_ftos, F15_ftos);\n@@ -1751,0 +1731,1 @@\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n@@ -1756,1 +1737,2 @@\n-    __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R0, R11_scratch1, R12_scratch2);\n+    __ merge_frames(\/*top_frame_sp*\/ R21_sender_SP, \/*return_pc*\/ R12_scratch2, R11_scratch1, R0);\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n@@ -1760,1 +1742,1 @@\n-    __ mtlr(R0);\n+    __ mtlr(R12_scratch2);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -67,8 +67,0 @@\n-    } else if (VM_Version::has_lqarx()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 8);\n-    } else if (VM_Version::has_popcntw()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 7);\n-    } else if (VM_Version::has_cmpb()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 6);\n-    } else if (VM_Version::has_popcntb()) {\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 5);\n@@ -76,1 +68,1 @@\n-      FLAG_SET_ERGO(PowerArchitecturePPC64, 0);\n+      FLAG_SET_ERGO(PowerArchitecturePPC64, 8);\n@@ -84,5 +76,1 @@\n-    case  8: if (!VM_Version::has_lqarx()  ) break;\n-    case  7: if (!VM_Version::has_popcntw()) break;\n-    case  6: if (!VM_Version::has_cmpb()   ) break;\n-    case  5: if (!VM_Version::has_popcntb()) break;\n-    case  0: PowerArchitecturePPC64_ok = true; break;\n+    case  8: PowerArchitecturePPC64_ok = true; break;\n@@ -95,3 +83,1 @@\n-  if (PowerArchitecturePPC64 >= 8 && has_mfdscr()) {\n-    config_dscr();\n-  }\n+  config_dscr();\n@@ -112,21 +98,0 @@\n-  \/\/ Power7 and later.\n-  if (PowerArchitecturePPC64 > 6) {\n-    if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n-      FLAG_SET_ERGO(UsePopCountInstruction, true);\n-    }\n-  }\n-\n-  if (!VM_Version::has_isel() && FLAG_IS_DEFAULT(ConditionalMoveLimit)) {\n-    FLAG_SET_ERGO(ConditionalMoveLimit, 0);\n-  }\n-\n-  if (PowerArchitecturePPC64 >= 8) {\n-    if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {\n-      FLAG_SET_ERGO(SuperwordUseVSX, true);\n-    }\n-  } else {\n-    if (SuperwordUseVSX) {\n-      warning(\"SuperwordUseVSX specified, but needs at least Power8.\");\n-      FLAG_SET_DEFAULT(SuperwordUseVSX, false);\n-    }\n-  }\n@@ -201,17 +166,1 @@\n-               \"ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n-               (has_fsqrt()   ? \" fsqrt\"   : \"\"),\n-               (has_isel()    ? \" isel\"    : \"\"),\n-               (has_lxarxeh() ? \" lxarxeh\" : \"\"),\n-               (has_cmpb()    ? \" cmpb\"    : \"\"),\n-               (has_popcntb() ? \" popcntb\" : \"\"),\n-               (has_popcntw() ? \" popcntw\" : \"\"),\n-               (has_fcfids()  ? \" fcfids\"  : \"\"),\n-               (has_vand()    ? \" vand\"    : \"\"),\n-               (has_lqarx()   ? \" lqarx\"   : \"\"),\n-               (has_vcipher() ? \" aes\"     : \"\"),\n-               (has_vpmsumb() ? \" vpmsumb\" : \"\"),\n-               (has_mfdscr()  ? \" mfdscr\"  : \"\"),\n-               (has_vsx()     ? \" vsx\"     : \"\"),\n-               (has_ldbrx()   ? \" ldbrx\"   : \"\"),\n-               (has_stdbrx()  ? \" stdbrx\"  : \"\"),\n-               (has_vshasig() ? \" sha\"     : \"\"),\n+               \"ppc64 sha aes%s%s\",\n@@ -286,8 +235,2 @@\n-  if (has_vcipher()) {\n-    if (FLAG_IS_DEFAULT(UseAES)) {\n-      UseAES = true;\n-    }\n-  } else if (UseAES) {\n-    if (!FLAG_IS_DEFAULT(UseAES))\n-      warning(\"AES instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAES, false);\n+  if (FLAG_IS_DEFAULT(UseAES)) {\n+    UseAES = true;\n@@ -296,8 +239,2 @@\n-  if (UseAES && has_vcipher()) {\n-    if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n-      UseAESIntrinsics = true;\n-    }\n-  } else if (UseAESIntrinsics) {\n-    if (!FLAG_IS_DEFAULT(UseAESIntrinsics))\n-      warning(\"AES intrinsics are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseAESIntrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n+    UseAESIntrinsics = true;\n@@ -311,9 +248,2 @@\n-  if (VM_Version::has_vsx()) {\n-    if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {\n-      UseGHASHIntrinsics = true;\n-    }\n-  } else if (UseGHASHIntrinsics) {\n-    if (!FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {\n-      warning(\"GHASH intrinsics are not available on this CPU\");\n-    }\n-    FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {\n+    UseGHASHIntrinsics = true;\n@@ -331,8 +261,2 @@\n-  if (has_vshasig()) {\n-    if (FLAG_IS_DEFAULT(UseSHA)) {\n-      UseSHA = true;\n-    }\n-  } else if (UseSHA) {\n-    if (!FLAG_IS_DEFAULT(UseSHA))\n-      warning(\"SHA instructions are not available on this CPU\");\n-    FLAG_SET_DEFAULT(UseSHA, false);\n+  if (FLAG_IS_DEFAULT(UseSHA)) {\n+    UseSHA = true;\n@@ -346,1 +270,1 @@\n-  if (UseSHA && has_vshasig()) {\n+  if (UseSHA) {\n@@ -355,1 +279,1 @@\n-  if (UseSHA && has_vshasig()) {\n+  if (UseSHA) {\n@@ -373,6 +297,0 @@\n-  if (UseSecondarySupersTable && PowerArchitecturePPC64 < 7) {\n-    if (!FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n-      warning(\"UseSecondarySupersTable requires Power7 or later.\");\n-    }\n-    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":14,"deletions":96,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -104,12 +104,0 @@\n-  static bool has_fsqrt()   { return (_features & fsqrt_m) != 0; }\n-  static bool has_fsqrts()  { return (_features & fsqrts_m) != 0; }\n-  static bool has_isel()    { return (_features & isel_m) != 0; }\n-  static bool has_lxarxeh() { return (_features & lxarxeh_m) !=0; }\n-  static bool has_cmpb()    { return (_features & cmpb_m) != 0; }\n-  static bool has_popcntb() { return (_features & popcntb_m) != 0; }\n-  static bool has_popcntw() { return (_features & popcntw_m) != 0; }\n-  static bool has_fcfids()  { return (_features & fcfids_m) != 0; }\n-  static bool has_vand()    { return (_features & vand_m) != 0; }\n-  static bool has_lqarx()   { return (_features & lqarx_m) != 0; }\n-  static bool has_vcipher() { return (_features & vcipher_m) != 0; }\n-  static bool has_vpmsumb() { return (_features & vpmsumb_m) != 0; }\n@@ -117,4 +105,0 @@\n-  static bool has_vsx()     { return (_features & vsx_m) != 0; }\n-  static bool has_ldbrx()   { return (_features & ldbrx_m) != 0; }\n-  static bool has_stdbrx()  { return (_features & stdbrx_m) != 0; }\n-  static bool has_vshasig() { return (_features & vshasig_m) != 0; }\n@@ -124,2 +108,0 @@\n-  static bool has_mtfprd()  { return has_vpmsumb(); } \/\/ alias for P8\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -674,21 +674,12 @@\n-\/\/ Load\/store register (all modes)\n-#define INSN(NAME, op, funct3)                                                                     \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                      \\\n-    guarantee(is_simm12(offset), \"offset is invalid.\");                                            \\\n-    unsigned insn = 0;                                                                             \\\n-    int32_t val = offset & 0xfff;                                                                  \\\n-    patch((address)&insn, 6, 0, op);                                                               \\\n-    patch((address)&insn, 14, 12, funct3);                                                         \\\n-    patch_reg((address)&insn, 15, Rs);                                                             \\\n-    patch_reg((address)&insn, 7, Rd);                                                              \\\n-    patch((address)&insn, 31, 20, val);                                                            \\\n-    emit(insn);                                                                                    \\\n-  }\n-\n-  INSN(lb,  0b0000011, 0b000);\n-  INSN(_lbu, 0b0000011, 0b100);\n-  INSN(_lh,  0b0000011, 0b001);\n-  INSN(_lhu, 0b0000011, 0b101);\n-  INSN(_lw, 0b0000011, 0b010);\n-  INSN(lwu, 0b0000011, 0b110);\n-  INSN(_ld, 0b0000011, 0b011);\n+ private:\n+  \/\/ Load\n+  enum LoadWidthFunct3 : uint8_t {\n+    LOAD_WIDTH_BYTE              = 0b000,\n+    LOAD_WIDTH_HALFWORD          = 0b001,\n+    LOAD_WIDTH_WORD              = 0b010,\n+    LOAD_WIDTH_DOUBLEWORD        = 0b011,\n+    LOAD_WIDTH_BYTE_UNSIGNED     = 0b100,\n+    LOAD_WIDTH_HALFWORD_UNSIGNED = 0b101,\n+    LOAD_WIDTH_WORD_UNSIGNED     = 0b110,\n+    \/\/ 0b111 is reserved\n+  };\n@@ -696,1 +687,67 @@\n-#undef INSN\n+  static constexpr uint8_t OP_LOAD_MAJOR    = 0b0000011;\n+  static constexpr uint8_t OP_FP_LOAD_MAJOR = 0b0000111;\n+\n+  template <uint8_t op_major, LoadWidthFunct3 width>\n+  void load_base(uint8_t Rd, Register Rs, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    int32_t val = offset & 0xfff;\n+    patch((address)&insn,  6,  0, op_major);\n+    patch((address)&insn, 11,  7, Rd);\n+    patch((address)&insn, 14, 12, width);\n+    patch_reg((address)&insn, 15, Rs);\n+    patch((address)&insn, 31, 20, val);\n+    emit(insn);\n+  }\n+\n+  template <LoadWidthFunct3 width>\n+  void load_base(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<OP_LOAD_MAJOR, width>(Rd->raw_encoding(), Rs, offset);\n+  }\n+\n+  template <LoadWidthFunct3 width>\n+  void load_base(FloatRegister Rd, Register Rs, const int32_t offset) {\n+    load_base<OP_FP_LOAD_MAJOR, width>(Rd->raw_encoding(), Rs, offset);\n+  }\n+\n+ public:\n+\n+  void lb(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_BYTE>(Rd, Rs, offset);\n+  }\n+\n+  void _lbu(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_BYTE_UNSIGNED>(Rd, Rs, offset);\n+  }\n+\n+  void _lh(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_HALFWORD>(Rd, Rs, offset);\n+  }\n+\n+  void _lhu(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_HALFWORD_UNSIGNED>(Rd, Rs, offset);\n+  }\n+\n+  void _lw(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_WORD>(Rd, Rs, offset);\n+  }\n+\n+  void lwu(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_WORD_UNSIGNED>(Rd, Rs, offset);\n+  }\n+\n+  void _ld(Register Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_DOUBLEWORD>(Rd, Rs, offset);\n+  }\n+\n+  void flh(FloatRegister Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_HALFWORD>(Rd, Rs, offset);\n+  }\n+\n+  void flw(FloatRegister Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_WORD>(Rd, Rs, offset);\n+  }\n+\n+  void _fld(FloatRegister Rd, Register Rs, const int32_t offset) {\n+    load_base<LOAD_WIDTH_DOUBLEWORD>(Rd, Rs, offset);\n+  }\n@@ -727,15 +784,1 @@\n-#define INSN(NAME, REGISTER, op, funct3)                                                                    \\\n-  void NAME(REGISTER Rs1, Register Rs2, const int32_t offset) {                                             \\\n-    guarantee(is_simm12(offset), \"offset is invalid.\");                                                     \\\n-    unsigned insn = 0;                                                                                      \\\n-    uint32_t val  = offset & 0xfff;                                                                         \\\n-    uint32_t low  = val & 0x1f;                                                                             \\\n-    uint32_t high = (val >> 5) & 0x7f;                                                                      \\\n-    patch((address)&insn, 6, 0, op);                                                                        \\\n-    patch((address)&insn, 14, 12, funct3);                                                                  \\\n-    patch_reg((address)&insn, 15, Rs2);                                                                     \\\n-    patch_reg((address)&insn, 20, Rs1);                                                                     \\\n-    patch((address)&insn, 11, 7, low);                                                                      \\\n-    patch((address)&insn, 31, 25, high);                                                                    \\\n-    emit(insn);                                                                                             \\\n-  }                                                                                                         \\\n+ private:\n@@ -743,6 +786,7 @@\n-  INSN(_sb,   Register,      0b0100011, 0b000);\n-  INSN(_sh,   Register,      0b0100011, 0b001);\n-  INSN(_sw,  Register,      0b0100011, 0b010);\n-  INSN(_sd,  Register,      0b0100011, 0b011);\n-  INSN(fsw,  FloatRegister, 0b0100111, 0b010);\n-  INSN(_fsd, FloatRegister, 0b0100111, 0b011);\n+  enum StoreWidthFunct3 : uint8_t {\n+    STORE_WIDTH_BYTE        = 0b000,\n+    STORE_WIDTH_HALFWORD    = 0b001,\n+    STORE_WIDTH_WORD        = 0b010,\n+    STORE_WIDTH_DOUBLEWORD  = 0b011,\n+    \/\/ 0b100 to 0b111 are reserved for this opcode\n+  };\n@@ -750,1 +794,54 @@\n-#undef INSN\n+  static constexpr uint8_t OP_STORE_MAJOR    = 0b0100011;\n+  static constexpr uint8_t OP_FP_STORE_MAJOR = 0b0100111;\n+\n+  template <uint8_t op_code, StoreWidthFunct3 width>\n+  void store_base(uint8_t Rs2, Register Rs1, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    uint32_t val  = offset & 0xfff;\n+    uint32_t low  = val & 0x1f;\n+    uint32_t high = (val >> 5) & 0x7f;\n+    patch((address)&insn,  6,  0, op_code);\n+    patch((address)&insn, 11,  7, low);\n+    patch((address)&insn, 14, 12, width);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch((address)&insn, 24, 20, Rs2);\n+    patch((address)&insn, 31, 25, high);\n+    emit(insn);\n+  }\n+\n+  template <StoreWidthFunct3 width>\n+  void store_base(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_STORE_MAJOR, width>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n+\n+  template <StoreWidthFunct3 width>\n+  void store_base(FloatRegister Rs2, Register Rs1, const int32_t offset) {\n+    store_base<OP_FP_STORE_MAJOR, width>(Rs2->raw_encoding(), Rs1, offset);\n+  }\n+\n+ public:\n+\n+  void _sb(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<STORE_WIDTH_BYTE>(Rs2, Rs1, offset);\n+  }\n+\n+  void _sh(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<STORE_WIDTH_HALFWORD>(Rs2, Rs1, offset);\n+  }\n+\n+  void _sw(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<STORE_WIDTH_WORD>(Rs2, Rs1, offset);\n+  }\n+\n+  void _sd(Register Rs2, Register Rs1, const int32_t offset) {\n+    store_base<STORE_WIDTH_DOUBLEWORD>(Rs2, Rs1, offset);\n+  }\n+\n+  void fsw(FloatRegister Rs2, Register Rs1, const int32_t offset) {\n+    store_base<STORE_WIDTH_WORD>(Rs2, Rs1, offset);\n+  }\n+\n+  void _fsd(FloatRegister Rs2, Register Rs1, const int32_t offset) {\n+    store_base<STORE_WIDTH_DOUBLEWORD>(Rs2, Rs1, offset);\n+  }\n@@ -1348,23 +1445,0 @@\n- private:\n-  static constexpr unsigned int OP_LOAD_FP = 0b0000111;\n-\n-  template <int8_t FpWidth>\n-  void fp_load(FloatRegister Rd, Register Rs, const int32_t offset) {\n-    guarantee(is_uimm3(FpWidth), \"Rounding mode is out of validity\");\n-    guarantee(is_simm12(offset), \"offset is invalid.\");\n-    unsigned insn = 0;\n-    uint32_t val = offset & 0xfff;\n-    patch((address)&insn,   6, 0, OP_LOAD_FP);\n-    patch_reg((address)&insn,  7, Rd);\n-    patch((address)&insn, 14, 12, FpWidth);\n-    patch_reg((address)&insn, 15, Rs);\n-    patch((address)&insn, 31, 20, val);\n-    emit(insn);\n-  }\n-\n- public:\n-\n-  void  flh(FloatRegister Rd, Register Rs, const int32_t offset) { fp_load<0b001>(Rd, Rs, offset); }\n-  void  flw(FloatRegister Rd, Register Rs, const int32_t offset) { fp_load<0b010>(Rd, Rs, offset); }\n-  void _fld(FloatRegister Rd, Register Rs, const int32_t offset) { fp_load<0b011>(Rd, Rs, offset); }\n-\n@@ -3188,13 +3262,12 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n-    \/* lw -> c.lwsp\/c.lw *\/                                                                  \\\n-    if (do_compress()) {                                                                     \\\n-      if (is_c_lwswsp(Rs, Rd, offset, true)) {                                               \\\n-        c_lwsp(Rd, offset);                                                                  \\\n-        return;                                                                              \\\n-      } else if (is_c_lwsw(Rs, Rd, offset)) {                                                \\\n-        c_lw(Rd, Rs, offset);                                                                \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _lw(Rd, Rs, offset);                                                                     \\\n+  void lw(Register Rd, Register Rs, const int32_t offset) {\n+    \/* lw -> c.lwsp\/c.lw *\/\n+    if (do_compress()) {\n+      if (is_c_lwswsp(Rs, Rd, offset, true)) {\n+        c_lwsp(Rd, offset);\n+        return;\n+      } else if (is_c_lwsw(Rs, Rd, offset)) {\n+        c_lw(Rd, Rs, offset);\n+        return;\n+      }\n+    }\n+    _lw(Rd, Rs, offset);\n@@ -3203,4 +3276,0 @@\n-  INSN(lw);\n-\n-#undef INSN\n-\n@@ -3208,13 +3277,12 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n-    \/* ld -> c.ldsp\/c.ld *\/                                                                  \\\n-    if (do_compress()) {                                                                     \\\n-      if (is_c_ldsdsp(Rs, Rd, offset, true)) {                                               \\\n-        c_ldsp(Rd, offset);                                                                  \\\n-        return;                                                                              \\\n-      } else if (is_c_ldsd(Rs, Rd, offset)) {                                                \\\n-        c_ld(Rd, Rs, offset);                                                                \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _ld(Rd, Rs, offset);                                                                     \\\n+  void ld(Register Rd, Register Rs, const int32_t offset) {\n+    \/* ld -> c.ldsp\/c.ld *\/\n+    if (do_compress()) {\n+      if (is_c_ldsdsp(Rs, Rd, offset, true)) {\n+        c_ldsp(Rd, offset);\n+        return;\n+      } else if (is_c_ldsd(Rs, Rd, offset)) {\n+        c_ld(Rd, Rs, offset);\n+        return;\n+      }\n+    }\n+    _ld(Rd, Rs, offset);\n@@ -3223,4 +3291,0 @@\n-  INSN(ld);\n-\n-#undef INSN\n-\n@@ -3228,13 +3292,12 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                           \\\n-    \/* fld -> c.fldsp\/c.fld *\/                                                               \\\n-    if (do_compress()) {                                                                     \\\n-      if (is_c_fldsdsp(Rs, offset)) {                                                        \\\n-        c_fldsp(Rd, offset);                                                                 \\\n-        return;                                                                              \\\n-      } else if (is_c_fldsd(Rs, Rd, offset)) {                                               \\\n-        c_fld(Rd, Rs, offset);                                                               \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _fld(Rd, Rs, offset);                                                                    \\\n+  void fld(FloatRegister Rd, Register Rs, const int32_t offset) {\n+    \/* fld -> c.fldsp\/c.fld *\/\n+    if (do_compress()) {\n+      if (is_c_fldsdsp(Rs, offset)) {\n+        c_fldsp(Rd, offset);\n+        return;\n+      } else if (is_c_fldsd(Rs, Rd, offset)) {\n+        c_fld(Rd, Rs, offset);\n+        return;\n+      }\n+    }\n+    _fld(Rd, Rs, offset);\n@@ -3243,4 +3306,0 @@\n-  INSN(fld);\n-\n-#undef INSN\n-\n@@ -3248,13 +3307,12 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n-    \/* sd -> c.sdsp\/c.sd *\/                                                                  \\\n-    if (do_compress()) {                                                                     \\\n-      if (is_c_ldsdsp(Rs, Rd, offset, false)) {                                              \\\n-        c_sdsp(Rd, offset);                                                                  \\\n-        return;                                                                              \\\n-      } else if (is_c_ldsd(Rs, Rd, offset)) {                                                \\\n-        c_sd(Rd, Rs, offset);                                                                \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _sd(Rd, Rs, offset);                                                                     \\\n+  void sd(Register Rs2, Register Rs1, const int32_t offset) {\n+    \/* sd -> c.sdsp\/c.sd *\/\n+    if (do_compress()) {\n+      if (is_c_ldsdsp(Rs1, Rs2, offset, false)) {\n+        c_sdsp(Rs2, offset);\n+        return;\n+      } else if (is_c_ldsd(Rs1, Rs2, offset)) {\n+        c_sd(Rs2, Rs1, offset);\n+        return;\n+      }\n+    }\n+    _sd(Rs2, Rs1, offset);\n@@ -3263,4 +3321,0 @@\n-  INSN(sd);\n-\n-#undef INSN\n-\n@@ -3268,13 +3322,12 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n-    \/* sw -> c.swsp\/c.sw *\/                                                                  \\\n-    if (do_compress()) {                                                                     \\\n-      if (is_c_lwswsp(Rs, Rd, offset, false)) {                                              \\\n-        c_swsp(Rd, offset);                                                                  \\\n-        return;                                                                              \\\n-      } else if (is_c_lwsw(Rs, Rd, offset)) {                                                \\\n-        c_sw(Rd, Rs, offset);                                                                \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _sw(Rd, Rs, offset);                                                                     \\\n+  void sw(Register Rs2, Register Rs1, const int32_t offset) {\n+    \/* sw -> c.swsp\/c.sw *\/\n+    if (do_compress()) {\n+      if (is_c_lwswsp(Rs1, Rs2, offset, false)) {\n+        c_swsp(Rs2, offset);\n+        return;\n+      } else if (is_c_lwsw(Rs1, Rs2, offset)) {\n+        c_sw(Rs2, Rs1, offset);\n+        return;\n+      }\n+    }\n+    _sw(Rs2, Rs1, offset);\n@@ -3283,4 +3336,0 @@\n-  INSN(sw);\n-\n-#undef INSN\n-\n@@ -3288,13 +3337,12 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                           \\\n-    \/* fsd -> c.fsdsp\/c.fsd *\/                                                               \\\n-    if (do_compress()) {                                                                     \\\n-      if (is_c_fldsdsp(Rs, offset)) {                                                        \\\n-        c_fsdsp(Rd, offset);                                                                 \\\n-        return;                                                                              \\\n-      } else if (is_c_fldsd(Rs, Rd, offset)) {                                               \\\n-        c_fsd(Rd, Rs, offset);                                                               \\\n-        return;                                                                              \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-    _fsd(Rd, Rs, offset);                                                                    \\\n+  void fsd(FloatRegister Rs2, Register Rs1, const int32_t offset) {\n+    \/* fsd -> c.fsdsp\/c.fsd *\/\n+    if (do_compress()) {\n+      if (is_c_fldsdsp(Rs1, offset)) {\n+        c_fsdsp(Rs2, offset);\n+        return;\n+      } else if (is_c_fldsd(Rs1, Rs2, offset)) {\n+        c_fsd(Rs2, Rs1, offset);\n+        return;\n+      }\n+    }\n+    _fsd(Rs2, Rs1, offset);\n@@ -3303,4 +3351,0 @@\n-  INSN(fsd);\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":213,"deletions":169,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -673,1 +673,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,47 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::interpreter_frame_bcp_offset]);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::return_addr_offset]);\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::interpreter_frame_sender_sp_offset]);\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp + frame::interpreter_frame_initial_sp_offset;\n+}\n+\n+inline intptr_t* frame::sender_sp(intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return fp + frame::sender_sp_offset;\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::link_offset]);\n+}\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(sp[-1]);\n+}\n+\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(sp[-2]);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -500,1 +500,0 @@\n-\/\/ Apply stack watermark barrier.\n@@ -503,0 +502,2 @@\n+\/\/ Apply stack watermark barrier.\n+\/\/ Notify JVMTI.\n@@ -512,5 +513,4 @@\n-void InterpreterMacroAssembler::remove_activation(\n-                                TosState state,\n-                                bool throw_monitor_exception,\n-                                bool install_monitor_exception,\n-                                bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -521,17 +521,0 @@\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-  j(fast_path);\n-\n-  bind(slow_path);\n-  push(state);\n-  set_last_Java_frame(esp, fp, (address)pc(), t0);\n-  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), xthread);\n-  reset_last_Java_frame(true);\n-  pop(state);\n-\n-  bind(fast_path);\n-\n@@ -658,3 +641,17 @@\n-  \/\/ jvmti support\n-  if (notify_jvmdi) {\n-    notify_method_exit(state, NotifyJVMTI);    \/\/ preserve TOSCA\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  j(fast_path);\n+\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(esp, fp, pc(), t0);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), xthread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n@@ -662,0 +659,3 @@\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n+  if (notify_jvmdi) {\n+    notify_method_exit(state, NotifyJVMTI); \/\/ preserve TOSCA\n@@ -680,0 +680,2 @@\n+    \/\/ look for an overflow into the stack reserved zone, i.e.\n+    \/\/ interpreter_frame_sender_sp <= JavaThread::reserved_stack_activation\n@@ -683,0 +685,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -692,0 +696,5 @@\n+  \/\/ remove frame anchor\n+  leave();\n+\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -695,2 +704,0 @@\n-  \/\/ remove frame anchor\n-  leave();\n@@ -704,0 +711,13 @@\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(xthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  mv(t0, true);\n+  sb(t0, sampling_critical_section);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(xthread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  sb(zr, sampling_critical_section);\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1518,1 +1538,1 @@\n-  \/\/ Note: No need to save\/restore rbcp & rlocals pointer since these\n+  \/\/ Note: No need to save\/restore xbcp & xlocals pointer since these\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":49,"deletions":29,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -293,0 +293,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3742,2 +3742,2 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod) {\n-  ld(t0, Address(xthread, JavaThread::polling_word_offset()));\n+void MacroAssembler::safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg) {\n+  ld(tmp_reg, Address(xthread, JavaThread::polling_word_offset()));\n@@ -3748,1 +3748,1 @@\n-    bgtu(in_nmethod ? sp : fp, t0, slow_path, \/* is_far *\/ true);\n+    bgtu(in_nmethod ? sp : fp, tmp_reg, slow_path, \/* is_far *\/ true);\n@@ -3750,2 +3750,2 @@\n-    test_bit(t0, t0, exact_log2(SafepointMechanism::poll_bit()));\n-    bnez(t0, slow_path, true \/* is_far *\/);\n+    test_bit(tmp_reg, tmp_reg, exact_log2(SafepointMechanism::poll_bit()));\n+    bnez(tmp_reg, slow_path, \/* is_far *\/ true);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod);\n+  void safepoint_poll(Label& slow_path, bool at_return, bool acquire, bool in_nmethod, Register tmp_reg = t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1897,0 +1897,18 @@\n+  #if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  __ ld(t0, Address(xthread, JavaThread::polling_word_offset()));\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ test_bit(t0, t0, log2i_exact(SafepointMechanism::poll_bit()));\n+  __ beqz(t0, L_return);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ la(t0, InternalAddress(poll_test_pc));\n+  __ sd(t0, Address(xthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2025, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -1636,0 +1636,120 @@\n+  address generate_unsafecopy_common_error_exit() {\n+    address start = __ pc();\n+    __ mv(x10, 0);\n+    __ leave();\n+    __ ret();\n+    return start;\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::unsafe_setmemory_id;\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+\n+    \/\/ bump this on entry, not on exit:\n+    \/\/ inc_counter_np(SharedRuntime::_unsafe_set_memory_ctr);\n+\n+    Label L_fill_elements;\n+\n+    const Register dest = c_rarg0;\n+    const Register count = c_rarg1;\n+    const Register value = c_rarg2;\n+    const Register cnt_words = x28; \/\/ temp register\n+    const Register tmp_reg   = x29; \/\/ temp register\n+\n+    \/\/ Mark remaining code as such which performs Unsafe accesses.\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    \/\/ if count < 8, jump to L_fill_elements\n+    __ mv(tmp_reg, 8); \/\/ 8 bytes fill by element\n+    __ bltu(count, tmp_reg, L_fill_elements);\n+\n+    \/\/ Propagate byte to 64-bit width\n+    \/\/ 8 bit -> 16 bit\n+    __ zext(value, value, 8);\n+    __ slli(tmp_reg, value, 8);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 16 bit -> 32 bit\n+    __ slli(tmp_reg, value, 16);\n+    __ orr(value, value, tmp_reg);\n+    \/\/ 32 bit -> 64 bit\n+    __ slli(tmp_reg, value, 32);\n+    __ orr(value, value, tmp_reg);\n+\n+    \/\/ Align source address at 8 bytes address boundary.\n+    Label L_skip_align1, L_skip_align2, L_skip_align4;\n+    \/\/ One byte misalignment happens.\n+    __ test_bit(tmp_reg, dest, 0);\n+    __ beqz(tmp_reg, L_skip_align1);\n+    __ sb(value, Address(dest, 0));\n+    __ addi(dest, dest, 1);\n+    __ subi(count, count, 1);\n+\n+    __ bind(L_skip_align1);\n+    \/\/ Two bytes misalignment happens.\n+    __ test_bit(tmp_reg, dest, 1);\n+    __ beqz(tmp_reg, L_skip_align2);\n+    __ sh(value, Address(dest, 0));\n+    __ addi(dest, dest, 2);\n+    __ subi(count, count, 2);\n+\n+    __ bind(L_skip_align2);\n+    \/\/ Four bytes misalignment happens.\n+    __ test_bit(tmp_reg, dest, 2);\n+    __ beqz(tmp_reg, L_skip_align4);\n+    __ sw(value, Address(dest, 0));\n+    __ addi(dest, dest, 4);\n+    __ subi(count, count, 4);\n+    __ bind(L_skip_align4);\n+\n+    \/\/  Fill large chunks\n+    __ srli(cnt_words, count, 3); \/\/ number of words\n+    __ slli(tmp_reg, cnt_words, 3);\n+    __ sub(count, count, tmp_reg);\n+    {\n+      __ fill_words(dest, cnt_words, value);\n+    }\n+\n+    \/\/ Handle copies less than 8 bytes\n+    __ bind(L_fill_elements);\n+    Label L_fill_2, L_fill_1, L_exit;\n+    __ test_bit(tmp_reg, count, 2);\n+    __ beqz(tmp_reg, L_fill_2);\n+    __ sb(value, Address(dest, 0));\n+    __ sb(value, Address(dest, 1));\n+    __ sb(value, Address(dest, 2));\n+    __ sb(value, Address(dest, 3));\n+    __ addi(dest, dest, 4);\n+\n+    __ bind(L_fill_2);\n+    __ test_bit(tmp_reg, count, 1);\n+    __ beqz(tmp_reg, L_fill_1);\n+    __ sb(value, Address(dest, 0));\n+    __ sb(value, Address(dest, 1));\n+    __ addi(dest, dest, 2);\n+\n+    __ bind(L_fill_1);\n+    __ test_bit(tmp_reg, count, 0);\n+    __ beqz(tmp_reg, L_exit);\n+    __ sb(value, Address(dest, 0));\n+\n+    __ bind(L_exit);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -2079,2 +2199,2 @@\n-          __ test_bit(t0, to, 0);\n-          __ beqz(t0, L_skip_align1);\n+          __ test_bit(tmp_reg, to, 0);\n+          __ beqz(tmp_reg, L_skip_align1);\n@@ -2088,2 +2208,2 @@\n-          __ test_bit(t0, to, 1);\n-          __ beqz(t0, L_skip_align2);\n+          __ test_bit(tmp_reg, to, 1);\n+          __ beqz(tmp_reg, L_skip_align2);\n@@ -2097,2 +2217,2 @@\n-          __ test_bit(t0, to, 2);\n-          __ beqz(t0, L_skip_align4);\n+          __ test_bit(tmp_reg, to, 2);\n+          __ beqz(tmp_reg, L_skip_align4);\n@@ -2124,2 +2244,4 @@\n-    \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    \/\/ Handle copies less than 8 bytes.\n+    \/\/ Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n@@ -2128,3 +2250,6 @@\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n@@ -2132,0 +2257,1 @@\n+\n@@ -2133,3 +2259,4 @@\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n@@ -2137,0 +2264,1 @@\n+\n@@ -2138,2 +2266,2 @@\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n@@ -2143,7 +2271,2 @@\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n@@ -2151,10 +2274,2 @@\n-        break;\n-      case T_INT:\n-        __ beqz(count, L_exit1);\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n@@ -2162,14 +2277,3 @@\n-    \/\/ Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n@@ -2177,3 +2281,0 @@\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n@@ -2182,0 +2283,1 @@\n+        __ beqz(count, L_exit);\n@@ -2186,1 +2288,1 @@\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n@@ -2205,0 +2307,3 @@\n+    address ucm_common_error_exit     = generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+\n@@ -2275,0 +2380,2 @@\n+\n+    StubRoutines::_unsafe_setmemory    = generate_unsafe_setmemory();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":159,"deletions":52,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -1375,0 +1375,25 @@\n+  #if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  __ j(fast_path);\n+\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(esp, fp, __ pc(), t0);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), xthread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1388,1 +1413,2 @@\n-  __ ld(esp, Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize)); \/\/ get sender sp\n+  \/\/ get sender sp\n+  __ ld(esp, Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n@@ -1392,0 +1418,2 @@\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1760,0 +1760,2 @@\n+    JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1768,1 +1770,1 @@\n-        Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+          Address(fp, frame::interpreter_frame_sender_sp_offset * wordSize));\n@@ -1771,0 +1773,3 @@\n+\n+    JFR_ONLY(__ leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -478,0 +478,1 @@\n+  inline frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map = nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,0 +90,5 @@\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map)\n+  :_sp(sp), _pc(pc), _cb(cb), _oop_map(oop_map), _on_heap(false), DEBUG_ONLY(_frame_index(-1) COMMA) _unextended_sp(unextended_sp), _fp(fp) {\n+  setup();\n+}\n+\n@@ -374,0 +379,38 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+inline intptr_t* frame::sender_sp(intptr_t* fp) { return fp; }\n+\n+\/\/ Extract common_abi parts.\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(((z_common_abi*)sp)->callers_sp);\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) { return frame::fp(fp); }\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(((z_common_abi*)sp)->return_pc);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) { return frame::return_address(fp); }\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(*(fp + _z_ijava_idx(bcp)));\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(*(fp + _z_ijava_idx(sender_sp)));\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp - ((frame::z_ijava_state_size + frame::z_top_ijava_frame_abi_size) >> LogBytesPerWord);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -4592,1 +4592,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -4656,0 +4656,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -4686,0 +4687,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -5395,1 +5397,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_QVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8194,0 +8196,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8367,1 +8370,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8386,1 +8389,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8405,1 +8408,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8425,1 +8428,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8445,1 +8448,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8464,1 +8467,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8483,1 +8486,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8502,1 +8505,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8870,1 +8873,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8893,1 +8896,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8916,1 +8919,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -8939,1 +8942,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9039,1 +9042,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9062,1 +9065,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9087,1 +9090,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -9110,1 +9113,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10555,1 +10558,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10582,1 +10585,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10725,1 +10728,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10752,1 +10755,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10895,1 +10898,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10922,1 +10925,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10949,1 +10952,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -10976,1 +10979,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11003,1 +11006,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11030,1 +11033,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11057,1 +11060,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11085,1 +11088,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11112,1 +11115,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11378,1 +11381,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11393,1 +11395,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11407,1 +11409,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11422,1 +11423,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11542,1 +11543,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11571,0 +11572,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11597,0 +11599,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11623,0 +11626,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -11649,0 +11653,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12017,0 +12022,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12042,0 +12048,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12071,0 +12078,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12099,0 +12107,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12126,0 +12135,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12152,0 +12162,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12180,0 +12191,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12207,0 +12219,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -12577,1 +12590,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12595,1 +12608,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12642,1 +12655,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -12670,1 +12683,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -14855,1 +14868,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -14864,1 +14877,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -16446,1 +16459,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16467,1 +16480,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16488,1 +16501,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16509,1 +16522,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16530,1 +16543,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n@@ -16551,1 +16564,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_NObit);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":61,"deletions":48,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -722,1 +722,0 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,47 @@\n+#if INCLUDE_JFR\n+\n+\/\/ Static helper routines\n+\n+inline address frame::interpreter_bcp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::interpreter_frame_bcp_offset]);\n+}\n+\n+inline address frame::interpreter_return_address(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(fp[frame::return_addr_offset]);\n+}\n+\n+inline intptr_t* frame::interpreter_sender_sp(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::interpreter_frame_sender_sp_offset]);\n+}\n+\n+inline bool frame::is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp) {\n+  assert(fp != nullptr, \"invariant\");\n+  assert(sp != nullptr, \"invariant\");\n+  return sp <= fp + frame::interpreter_frame_initial_sp_offset;\n+}\n+\n+inline intptr_t* frame::sender_sp(intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return fp + frame::sender_sp_offset;\n+}\n+\n+inline intptr_t* frame::link(const intptr_t* fp) {\n+  assert(fp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(fp[frame::link_offset]);\n+}\n+\n+inline address frame::return_address(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<address>(sp[-1]);\n+}\n+\n+inline intptr_t* frame::fp(const intptr_t* sp) {\n+  assert(sp != nullptr, \"invariant\");\n+  return reinterpret_cast<intptr_t*>(sp[-2]);\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -81,9 +81,42 @@\n-    __ push(rax);\n-    __ push(rcx);\n-    __ push(rdx);\n-    __ push(rdi);\n-    __ push(rsi);\n-    __ push(r8);\n-    __ push(r9);\n-    __ push(r10);\n-    __ push(r11);\n+    if (VM_Version::supports_apx_f()) {\n+      if (_result != rax) {\n+        __ pushp(rax);\n+      }\n+      __ pushp(rcx);\n+      \/\/ Save current stack pointer into rcx\n+      __ movptr(rcx, rsp);\n+      \/\/ Align stack pointer to 16 byte boundary. This is hard constraint\n+      \/\/ for push2\/pop2 with PPX hints.\n+      __ andptr(rsp, -StackAlignmentInBytes);\n+      \/\/ Push original stack pointer.\n+      __ push(rcx);\n+      \/\/ Restore the original contents of RCX register.\n+      __ movptr(rcx, Address(rcx));\n+      \/\/ Now push remaining caller save GPRs and EGPRs on 16B aligned stack.\n+      \/\/ Note: For PPX to work properly, a PPX-marked PUSH2 (respectively, POP2) should always\n+      \/\/ be matched with a PPX-marked POP2 (PUSH2), not with two PPX-marked POPs (PUSHs).\n+      __ pushp(rdx);\n+      __ push2p(rdi, rsi);\n+      __ push2p(r8, r9);\n+      __ push2p(r10, r11);\n+      __ push2p(r16, r17);\n+      __ push2p(r18, r19);\n+      __ push2p(r20, r21);\n+      __ push2p(r22, r23);\n+      __ push2p(r24, r25);\n+      __ push2p(r26, r27);\n+      __ push2p(r28, r29);\n+      __ push2p(r30, r31);\n+    } else {\n+      if (_result != rax) {\n+        __ push(rax);\n+      }\n+      __ push(rcx);\n+      __ push(rdx);\n+      __ push(rdi);\n+      __ push(rsi);\n+      __ push(r8);\n+      __ push(r9);\n+      __ push(r10);\n+      __ push(r11);\n+    }\n@@ -142,12 +175,22 @@\n-    __ pop(r11);\n-    __ pop(r10);\n-    __ pop(r9);\n-    __ pop(r8);\n-    __ pop(rsi);\n-    __ pop(rdi);\n-    __ pop(rdx);\n-    __ pop(rcx);\n-    if (_result == noreg) {\n-      __ pop(rax);\n-    } else if (_result == rax) {\n-      __ addptr(rsp, wordSize);\n+    if (VM_Version::supports_apx_f()) {\n+      __ pop2p(r31, r30);\n+      __ pop2p(r29, r28);\n+      __ pop2p(r27, r26);\n+      __ pop2p(r25, r24);\n+      __ pop2p(r23, r22);\n+      __ pop2p(r21, r20);\n+      __ pop2p(r19, r18);\n+      __ pop2p(r17, r16);\n+      __ pop2p(r11, r10);\n+      __ pop2p(r9, r8);\n+      __ pop2p(rsi, rdi);\n+      __ popp(rdx);\n+      \/\/ Re-instantiate original stack pointer.\n+      __ movptr(rsp, Address(rsp));\n+      __ popp(rcx);\n+      if (_result != rax) {\n+        if (_result != noreg) {\n+          __ movptr(_result, rax);\n+        }\n+        __ popp(rax);\n+      }\n@@ -155,2 +198,14 @@\n-      __ movptr(_result, rax);\n-      __ pop(rax);\n+      __ pop(r11);\n+      __ pop(r10);\n+      __ pop(r9);\n+      __ pop(r8);\n+      __ pop(rsi);\n+      __ pop(rdi);\n+      __ pop(rdx);\n+      __ pop(rcx);\n+      if (_result != rax) {\n+        if (_result != noreg) {\n+          __ movptr(_result, rax);\n+        }\n+        __ pop(rax);\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":78,"deletions":23,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -786,1 +786,0 @@\n-\/\/ Apply stack watermark barrier.\n@@ -789,0 +788,2 @@\n+\/\/ Apply stack watermark barrier.\n+\/\/ Notify JVMTI.\n@@ -798,6 +799,5 @@\n-void InterpreterMacroAssembler::remove_activation(\n-        TosState state,\n-        Register ret_addr,\n-        bool throw_monitor_exception,\n-        bool install_monitor_exception,\n-        bool notify_jvmdi) {\n+void InterpreterMacroAssembler::remove_activation(TosState state,\n+                                                  Register ret_addr,\n+                                                  bool throw_monitor_exception,\n+                                                  bool install_monitor_exception,\n+                                                  bool notify_jvmdi) {\n@@ -812,15 +812,0 @@\n-  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n-  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n-  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n-  Label slow_path;\n-  Label fast_path;\n-  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n-  jmp(fast_path);\n-  bind(slow_path);\n-  push(state);\n-  set_last_Java_frame(noreg, rbp, (address)pc(), rscratch1);\n-  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), rthread);\n-  reset_last_Java_frame(true);\n-  pop(state);\n-  bind(fast_path);\n-\n@@ -948,1 +933,18 @@\n-  \/\/ jvmti support\n+  JFR_ONLY(enter_jfr_critical_section();)\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  jmp(fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(noreg, rbp, (address)pc(), rscratch1);\n+  super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), r15_thread);\n+  reset_last_Java_frame(true);\n+  pop(state);\n+  bind(fast_path);\n+\n+  \/\/ JVMTI support. Make sure the safepoint poll test is issued prior.\n@@ -970,0 +972,2 @@\n+    JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -1018,0 +1022,1 @@\n+\n@@ -1019,0 +1024,3 @@\n+\n+  JFR_ONLY(leave_jfr_critical_section();)\n+\n@@ -1022,0 +1030,12 @@\n+\n+}\n+\n+#if INCLUDE_JFR\n+void InterpreterMacroAssembler::enter_jfr_critical_section() {\n+  const Address sampling_critical_section(r15_thread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  movbool(sampling_critical_section, true);\n+}\n+\n+void InterpreterMacroAssembler::leave_jfr_critical_section() {\n+  const Address sampling_critical_section(r15_thread, in_bytes(SAMPLING_CRITICAL_SECTION_OFFSET_JFR));\n+  movbool(sampling_critical_section, false);\n@@ -1023,0 +1043,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -281,0 +281,3 @@\n+  JFR_ONLY(void enter_jfr_critical_section();)\n+  JFR_ONLY(void leave_jfr_critical_section();)\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2703,0 +2703,17 @@\n+#if INCLUDE_JFR\n+  \/\/ We need to do a poll test after unwind in case the sampler\n+  \/\/ managed to sample the native frame after returning to Java.\n+  Label L_return;\n+  address poll_test_pc = __ pc();\n+  __ relocate(relocInfo::poll_return_type);\n+  __ testb(Address(r15_thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n+  __ jccb(Assembler::zero, L_return);\n+  __ lea(rscratch1, InternalAddress(poll_test_pc));\n+  __ movptr(Address(r15_thread, JavaThread::saved_exception_pc_offset()), rscratch1);\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n+    \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  __ jump(RuntimeAddress(stub));\n+  __ bind(L_return);\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1155,0 +1155,24 @@\n+#if INCLUDE_JFR\n+  __ enter_jfr_critical_section();\n+\n+  \/\/ This poll test is to uphold the invariant that a JFR sampled frame\n+  \/\/ must not return to its caller without a prior safepoint poll check.\n+  \/\/ The earlier poll check in this routine is insufficient for this purpose\n+  \/\/ because the thread has transitioned back to Java.\n+\n+  Label slow_path;\n+  Label fast_path;\n+  __ safepoint_poll(slow_path, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  __ jmp(fast_path);\n+  __ bind(slow_path);\n+  __ push(dtos);\n+  __ push(ltos);\n+  __ set_last_Java_frame(noreg, rbp, (address)__ pc(), rscratch1);\n+  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), r15_thread);\n+  __ reset_last_Java_frame(true);\n+  __ pop(ltos);\n+  __ pop(dtos);\n+  __ bind(fast_path);\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1177,0 +1201,3 @@\n+\n+  JFR_ONLY(__ leave_jfr_critical_section();)\n+\n@@ -1179,0 +1206,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1888,0 +1888,2 @@\n+      JFR_ONLY(__ enter_jfr_critical_section();)\n+\n@@ -1902,0 +1904,1 @@\n+      JFR_ONLY(__ leave_jfr_critical_section();)\n@@ -1903,1 +1906,1 @@\n-      __ mov(rsp, sender_sp);                   \/\/ set sp to sender sp\n+      __ mov(rsp, sender_sp);                    \/\/ set sp to sender sp\n@@ -1907,3 +1910,0 @@\n-      \/\/ unlike x86 we need no specialized return from compiled code\n-      \/\/ to the interpreter or the call stub.\n-\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,6 +141,0 @@\n-#ifndef PV_7\n-  #define PV_7 0x200000          \/* Power PC 7 *\/\n-#endif\n-#ifndef PV_7_Compat\n-  #define PV_7_Compat 0x208000   \/* Power PC 7 *\/\n-#endif\n@@ -1250,27 +1244,0 @@\n-  case PV_7:\n-    strncpy(buf, \"Power PC 7\", buflen);\n-    break;\n-  case PV_6_1:\n-    strncpy(buf, \"Power PC 6 DD1.x\", buflen);\n-    break;\n-  case PV_6:\n-    strncpy(buf, \"Power PC 6\", buflen);\n-    break;\n-  case PV_5:\n-    strncpy(buf, \"Power PC 5\", buflen);\n-    break;\n-  case PV_5_2:\n-    strncpy(buf, \"Power PC 5_2\", buflen);\n-    break;\n-  case PV_5_3:\n-    strncpy(buf, \"Power PC 5_3\", buflen);\n-    break;\n-  case PV_5_Compat:\n-    strncpy(buf, \"PV_5_Compat\", buflen);\n-    break;\n-  case PV_6_Compat:\n-    strncpy(buf, \"PV_6_Compat\", buflen);\n-    break;\n-  case PV_7_Compat:\n-    strncpy(buf, \"PV_7_Compat\", buflen);\n-    break;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -145,1 +145,3 @@\n-\/\/ available here means free\n+\/\/ Available here means free. Note that this number is of no much use. As an estimate\n+\/\/ for future memory pressure it is far too conservative, since MacOS will use a lot\n+\/\/ of unused memory for caches, and return it willingly in case of needs.\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"interpreter\/interpreter.hpp\"\n@@ -1333,0 +1334,9 @@\n+#ifdef ASSERT\n+bool os::Posix::ucontext_is_interpreter(const ucontext_t* uc) {\n+  assert(uc != nullptr, \"invariant\");\n+  address pc = os::Posix::ucontext_get_pc(uc);\n+  assert(pc != nullptr, \"invariant\");\n+  return Interpreter::contains(pc);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+  DEBUG_ONLY(static bool ucontext_is_interpreter(const ucontext_t* ctx);)\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4629,0 +4629,57 @@\n+\/\/ This method checks if a wide path is actually a symbolic link\n+static bool is_symbolic_link(const wchar_t* wide_path) {\n+  WIN32_FIND_DATAW fd;\n+  HANDLE f = ::FindFirstFileW(wide_path, &fd);\n+  if (f != INVALID_HANDLE_VALUE) {\n+    const bool result = fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && fd.dwReserved0 == IO_REPARSE_TAG_SYMLINK;\n+    if (::FindClose(f) == 0) {\n+      errno = ::GetLastError();\n+      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%ld.\", errno);\n+    }\n+    return result;\n+  } else {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%ld.\", errno);\n+    return false;\n+  }\n+}\n+\n+\/\/ This method dereferences a symbolic link\n+static WCHAR* get_path_to_target(const wchar_t* wide_path) {\n+  HANDLE hFile = CreateFileW(wide_path, GENERIC_READ, FILE_SHARE_READ, nullptr,\n+                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n+  if (hFile == INVALID_HANDLE_VALUE) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  \/\/ Returned value includes the terminating null character.\n+  const size_t target_path_size = ::GetFinalPathNameByHandleW(hFile, nullptr, 0,\n+                                                              FILE_NAME_NORMALIZED);\n+  if (target_path_size == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  WCHAR* path_to_target = NEW_C_HEAP_ARRAY(WCHAR, target_path_size, mtInternal);\n+\n+  \/\/ The returned size is the length excluding the terminating null character.\n+  const size_t res = ::GetFinalPathNameByHandleW(hFile, path_to_target, static_cast<DWORD>(target_path_size),\n+                                                 FILE_NAME_NORMALIZED);\n+  if (res != target_path_size - 1) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  if (::CloseHandle(hFile) == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  return path_to_target;\n+}\n+\n@@ -4697,0 +4754,14 @@\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n@@ -4698,2 +4769,1 @@\n-  BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &file_data);\n-  os::free(wide_path);\n+  BOOL bret = ::GetFileAttributesExW(is_symlink ? path_to_target : wide_path, GetFileExInfoStandard, &file_data);\n@@ -4701,0 +4771,1 @@\n+  \/\/ if getting attributes failed, GetLastError should be called immediately after that\n@@ -4703,0 +4774,3 @@\n+    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%ld.\", errno);\n+    os::free(wide_path);\n+    os::free(path_to_target);\n@@ -4706,0 +4780,3 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n+\n@@ -4890,2 +4967,0 @@\n-  int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n-  os::free(wide_path);\n@@ -4893,0 +4968,17 @@\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n+  int fd = ::_wopen(is_symlink ? path_to_target : wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n+\n+  \/\/ if opening files failed, GetLastError should be called immediately after that\n@@ -4895,0 +4987,1 @@\n+    log_debug(os)(\"os::open() failed to _wopen: GetLastError->%ld.\", errno);\n@@ -4896,0 +4989,2 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n@@ -5748,18 +5843,4 @@\n-\/\/ returns true if thread could be suspended,\n-\/\/ false otherwise\n-static bool do_suspend(HANDLE* h) {\n-  if (h != nullptr) {\n-    if (SuspendThread(*h) != ~0) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ resume the thread\n-\/\/ calling resume on an active thread is a no-op\n-static void do_resume(HANDLE* h) {\n-  if (h != nullptr) {\n-    ResumeThread(*h);\n-  }\n-}\n+\/\/ WINDOWS CONTEXT Flags for THREAD_SAMPLING\n+#if defined(AMD64) || defined(_M_ARM64)\n+  #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)\n+#endif\n@@ -5767,7 +5848,4 @@\n-\/\/ retrieve a suspend\/resume context capable handle\n-\/\/ from the tid. Caller validates handle return value.\n-void get_thread_handle_for_extended_context(HANDLE* h,\n-                                            DWORD tid) {\n-  if (h != nullptr) {\n-    *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);\n-  }\n+\/\/ Retrieve a suspend\/resume context capable handle for the tid.\n+\/\/ Caller validates handle return value.\n+static inline HANDLE get_thread_handle_for_extended_context(DWORD tid) {\n+  return OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);\n@@ -5779,8 +5857,2 @@\n-  CONTEXT    ctxt;\n-  HANDLE     h = nullptr;\n-\n-  \/\/ get context capable handle for thread\n-  get_thread_handle_for_extended_context(&h, _thread->osthread()->thread_id());\n-\n-  \/\/ sanity\n-  if (h == nullptr || h == INVALID_HANDLE_VALUE) {\n+  const HANDLE h = get_thread_handle_for_extended_context(_thread->osthread()->thread_id());\n+  if (h == nullptr) {\n@@ -5789,11 +5861,9 @@\n-\n-  \/\/ suspend the thread\n-  if (do_suspend(&h)) {\n-    ctxt.ContextFlags = (CONTEXT_FULL | CONTEXT_FLOATING_POINT);\n-    \/\/ get thread context\n-    GetThreadContext(h, &ctxt);\n-    SuspendedThreadTaskContext context(_thread, &ctxt);\n-    \/\/ pass context to Thread Sampling impl\n-    do_task(context);\n-    \/\/ resume thread\n-    do_resume(&h);\n+  CONTEXT ctxt;\n+  ctxt.ContextFlags = sampling_context_flags;\n+  if (SuspendThread(h) != OS_ERR) {\n+    if (GetThreadContext(h, &ctxt)) {\n+      const SuspendedThreadTaskContext context(_thread, &ctxt);\n+      \/\/ Pass context to Thread Sampling implementation.\n+      do_task(context);\n+    }\n+    ResumeThread(h);\n@@ -5801,2 +5871,0 @@\n-\n-  \/\/ close handle\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":118,"deletions":50,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -141,0 +141,7 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.jmp_context.gpr[14]); \/\/ R14_bcp\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+#define REG_BCP context_x[22]\n+\n@@ -182,0 +184,7 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->REG_BCP);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+#define REG_BCP context_r13\n@@ -352,0 +353,7 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->REG_BCP);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -112,0 +112,5 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#define REG_BCP 22\n@@ -151,0 +152,7 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.regs[REG_BCP]);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -211,0 +211,5 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -249,13 +249,1 @@\n-  volatile int *dest_base = (volatile int*)((uintptr_t)dest & ~3);\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  const unsigned int shift_amount        = ((uintptr_t)dest & 3) * 8;\n-#else\n-  const unsigned int shift_amount        = ((~(uintptr_t)dest) & 3) * 8;\n-#endif\n-  const unsigned int masked_compare_val  = ((unsigned int)(unsigned char)compare_value),\n-                     masked_exchange_val = ((unsigned int)(unsigned char)exchange_value),\n-                     xor_value           = (masked_compare_val ^ masked_exchange_val) << shift_amount;\n-\n-  unsigned int old_value, value32;\n-\n+  unsigned int old_value, loaded_value;\n@@ -265,4 +253,0 @@\n-    \/* simple guard *\/\n-    \"   lbz     %[old_value], 0(%[dest])                  \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n-    \"   bne-    2f                                        \\n\"\n@@ -271,1 +255,1 @@\n-    \"   lwarx   %[value32], 0, %[dest_base]               \\n\"\n+    \"   lbarx   %[old_value], 0, %[dest]                  \\n\"\n@@ -273,3 +257,1 @@\n-    \"   srd     %[old_value], %[value32], %[shift_amount] \\n\"\n-    \"   clrldi  %[old_value], %[old_value], 56            \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n+    \"   cmpw    %[compare_value], %[old_value]            \\n\"\n@@ -278,2 +260,1 @@\n-    \"   xor     %[value32], %[xor_value], %[value32]      \\n\"\n-    \"   stwcx.  %[value32], 0, %[dest_base]               \\n\"\n+    \"   stbcx.  %[exchange_value], 0, %[dest]             \\n\"\n@@ -285,3 +266,2 @@\n-      [value32]             \"=&r\"   (value32),\n-                            \"=m\"    (*dest),\n-                            \"=m\"    (*dest_base)\n+      [loaded_value]        \"=&r\"   (loaded_value),\n+                            \"=m\"    (*dest)\n@@ -289,7 +269,4 @@\n-    : [dest]                \"b\"     (dest),\n-      [dest_base]           \"b\"     (dest_base),\n-      [shift_amount]        \"r\"     (shift_amount),\n-      [masked_compare_val]  \"r\"     (masked_compare_val),\n-      [xor_value]           \"r\"     (xor_value),\n-                            \"m\"     (*dest),\n-                            \"m\"     (*dest_base)\n+    : [dest]            \"b\"     (dest),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/atomic_linux_ppc.hpp","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -173,0 +173,7 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.regs->gpr[14]); \/\/ R14_bcp\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#define REG_BCP      22\n@@ -160,0 +161,7 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.__gregs[REG_BCP]);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -158,0 +158,5 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+#define REG_BCP REG_R13\n@@ -160,0 +161,7 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->uc_mcontext.gregs[REG_BCP]);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -214,0 +214,5 @@\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+#define REG_BCP X22\n+\n@@ -100,0 +102,16 @@\n+#ifdef ASSERT\n+static bool is_interpreter(const CONTEXT* uc) {\n+  assert(uc != nullptr, \"invariant\");\n+  address pc = reinterpret_cast<address>(uc->Pc);\n+  assert(pc != nullptr, \"invariant\");\n+  return Interpreter::contains(pc);\n+}\n+#endif\n+\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  CONTEXT* uc = (CONTEXT*)ucVoid;\n+  assert(is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->REG_BCP);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#define REG_BCP R13\n@@ -323,0 +324,16 @@\n+#ifdef ASSERT\n+static bool is_interpreter(const CONTEXT* uc) {\n+  assert(uc != nullptr, \"invariant\");\n+  address pc = reinterpret_cast<address>(uc->REG_PC);\n+  assert(pc != nullptr, \"invariant\");\n+  return Interpreter::contains(pc);\n+}\n+#endif\n+\n+intptr_t* os::fetch_bcp_from_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const CONTEXT* const uc = (CONTEXT*)ucVoid;\n+  assert(is_interpreter(uc), \"invariant\");\n+  return reinterpret_cast<intptr_t*>(uc->REG_BCP);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -585,1 +585,1 @@\n-    \"SqrtVF\", \"SqrtVD\",\n+    \"SqrtVHF\", \"SqrtVF\", \"SqrtVD\",\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    if (CDSConfig::is_dumping_final_static_archive() && ik->is_shared_unregistered_class()) {\n+    if (CDSConfig::is_dumping_final_static_archive() && ik->defined_by_other_loaders()) {\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    assert(ik->shared_class_loader_type() != ClassLoader::OTHER, \"must have been set\");\n+    assert(!ik->defined_by_other_loaders(), \"hidden classes are archived only for builtin loaders\");\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -493,1 +493,0 @@\n-    os::free((void*)lcp);\n@@ -495,0 +494,1 @@\n+    os::free((void*)lcp);\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-  if (ik->is_shared_boot_class()) {\n+  if (ik->defined_by_boot_loader()) {\n@@ -385,1 +385,1 @@\n-  } else if (ik->is_shared_platform_class()) {\n+  } else if (ik->defined_by_platform_loader()) {\n@@ -389,1 +389,1 @@\n-  } else if (ik->is_shared_app_class()) {\n+  } else if (ik->defined_by_app_loader()) {\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-    if (AOTCodeCache::is_dumping_adapter()) {\n+    if (CDSConfig::is_dumping_adapters()) {\n@@ -837,4 +837,0 @@\n-      if (CDSConfig::is_dumping_dynamic_archive()) {\n-        \/\/ For static dump, class loader type are already set.\n-        ik->assign_class_loader_type();\n-      }\n@@ -864,1 +860,1 @@\n-      } else if (ik->is_shared_boot_class()) {\n+      } else if (ik->defined_by_boot_loader()) {\n@@ -867,1 +863,1 @@\n-      } else if (ik->is_shared_platform_class()) {\n+      } else if (ik->defined_by_platform_loader()) {\n@@ -870,1 +866,1 @@\n-      } else if (ik->is_shared_app_class()) {\n+      } else if (ik->defined_by_app_loader()) {\n@@ -874,1 +870,1 @@\n-        assert(ik->is_shared_unregistered_class(), \"must be\");\n+        assert(ik->defined_by_other_loaders(), \"must be\");\n@@ -886,1 +882,1 @@\n-        if (ik->is_shared_boot_class()) {\n+        if (ik->defined_by_boot_loader()) {\n@@ -888,1 +884,1 @@\n-        } else if (ik->is_shared_platform_class()) {\n+        } else if (ik->defined_by_platform_loader()) {\n@@ -890,1 +886,1 @@\n-        } else if (ik->is_shared_app_class()) {\n+        } else if (ik->defined_by_app_loader()) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -923,0 +923,4 @@\n+\n+bool CDSConfig::is_dumping_adapters() {\n+  return (AOTAdapterCaching && is_dumping_final_static_archive());\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,0 +203,1 @@\n+  static bool is_dumping_adapters()                          NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    assert(!ik->is_shared_unregistered_class(), \"unexpected archived package entry for an unregistered class\");\n+    assert(!ik->defined_by_other_loaders(), \"unexpected archived package entry for an unregistered class\");\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-  if (specified_supertype->is_shared_unregistered_class()) {\n+  if (specified_supertype->defined_by_other_loaders()) {\n@@ -589,1 +589,1 @@\n-  assert(k->is_shared_unregistered_class(), \"must be\");\n+  assert(k->defined_by_other_loaders(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-      assert(k->is_shared_unregistered_class(), \"must be\");\n+      assert(k->defined_by_other_loaders(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-      if (ik->is_shared_unregistered_class()) {\n+      if (ik->defined_by_other_loaders()) {\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -806,1 +806,1 @@\n-      assert(InstanceKlass::cast(abk)->is_shared_boot_class(),\n+      assert(InstanceKlass::cast(abk)->defined_by_boot_loader(),\n@@ -1100,1 +1100,1 @@\n-    assert(k != nullptr && k->is_shared_boot_class(), \"sanity\");\n+    assert(k != nullptr && k->defined_by_boot_loader(), \"sanity\");\n@@ -1287,1 +1287,1 @@\n-  assert(k->is_shared_boot_class(), \"sanity\");\n+  assert(k->defined_by_boot_loader(), \"sanity\");\n@@ -1647,1 +1647,1 @@\n-  assert(k->is_shared_boot_class(), \"must be boot class\");\n+  assert(k->defined_by_boot_loader(), \"must be boot class\");\n@@ -1698,1 +1698,1 @@\n-  assert(k->is_shared_boot_class(), \"must be boot class\");\n+  assert(k->defined_by_boot_loader(), \"must be boot class\");\n@@ -1872,1 +1872,1 @@\n-    assert(InstanceKlass::cast(ik)->is_shared_boot_class(),\n+    assert(InstanceKlass::cast(ik)->defined_by_boot_loader(),\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -173,1 +173,0 @@\n-  lambda_ik->assign_class_loader_type();\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-  if (AOTCodeCache::is_dumping_adapter()) {\n+  if (CDSConfig::is_dumping_adapters()) {\n@@ -738,1 +738,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared_unregistered_class()) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && ik->defined_by_other_loaders()) {\n@@ -1051,1 +1051,1 @@\n-    if (ik->is_shared_unregistered_class() && ik->class_loader() == nullptr) {\n+    if (ik->defined_by_other_loaders() && ik->class_loader() == nullptr) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5271,0 +5271,1 @@\n+  ik->set_class_loader_type();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1133,3 +1133,0 @@\n-#if INCLUDE_CDS\n-    result->set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n-#endif\n@@ -1213,1 +1210,1 @@\n-  if (ik->shared_classpath_index() == 0 && ik->is_shared_boot_class()) {\n+  if (ik->shared_classpath_index() == 0 && ik->defined_by_boot_loader()) {\n@@ -1223,1 +1220,0 @@\n-      ik->set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n@@ -1318,17 +1314,3 @@\n-  s2 classloader_type;\n-  if (HeapShared::is_lambda_form_klass(ik)) {\n-    classloader_type = ClassLoader::BOOT_LOADER;\n-  } else {\n-    oop loader = ik->class_loader();\n-\n-    if (loader == nullptr) {\n-      classloader_type = ClassLoader::BOOT_LOADER;\n-    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-      classloader_type = ClassLoader::PLATFORM_LOADER;\n-    } else if (SystemDictionary::is_system_class_loader(loader)) {\n-      classloader_type = ClassLoader::APP_LOADER;\n-    } else {\n-      \/\/ This class won't be archived, so no need to update its\n-      \/\/ classloader_type\/classpath_index.\n-      return;\n-    }\n+  if (ik->defined_by_other_loaders()) {\n+    \/\/ We don't archive hidden classes for non-builtin loaders.\n+    return;\n@@ -1336,1 +1318,0 @@\n-  ik->set_shared_class_loader_type(classloader_type);\n@@ -1345,1 +1326,1 @@\n-    if (classloader_type == ClassLoader::APP_LOADER) {\n+    if (ik->defined_by_app_loader()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  s2 classloader_type;\n@@ -76,1 +75,0 @@\n-    classloader_type = ClassLoader::APP_LOADER;\n@@ -79,1 +77,0 @@\n-    classloader_type = ClassLoader::PLATFORM_LOADER;\n@@ -83,1 +80,0 @@\n-    classloader_type = ClassLoader::BOOT_LOADER;\n@@ -94,1 +90,0 @@\n-  result->set_shared_class_loader_type(classloader_type);\n@@ -97,1 +92,1 @@\n-  if (CDSConfig::is_dumping_heap() && AllowArchivingWithJavaAgent && classloader_type == ClassLoader::BOOT_LOADER &&\n+  if (CDSConfig::is_dumping_heap() && AllowArchivingWithJavaAgent && result->defined_by_boot_loader() &&\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-        new_ik->assign_class_loader_type();\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -950,1 +950,1 @@\n-  if (ik->is_shared_boot_class()) {\n+  if (ik->defined_by_boot_loader()) {\n@@ -954,1 +954,1 @@\n-  } else if (ik->is_shared_platform_class()) {\n+  } else if (ik->defined_by_platform_loader()) {\n@@ -958,1 +958,1 @@\n-  } else if (ik->is_shared_app_class()) {\n+  } else if (ik->defined_by_app_loader()) {\n@@ -988,1 +988,1 @@\n-  assert(!ik->is_shared_unregistered_class(), \"this function should be called for built-in classes only\");\n+  assert(!ik->defined_by_other_loaders(), \"this function should be called for built-in classes only\");\n@@ -1050,1 +1050,1 @@\n-  if (!super_type->is_shared_unregistered_class() && super_type->class_loader_data() != nullptr) {\n+  if (!super_type->defined_by_other_loaders() && super_type->class_loader_data() != nullptr) {\n@@ -1344,1 +1344,1 @@\n-      if (ik != nullptr && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+      if (ik != nullptr && ik->defined_by_boot_loader() && !ik->shared_loading_failed()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,2 +106,2 @@\n-    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->is_shared_app_class())  ||\n-        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->is_shared_platform_class())) {\n+    if ((SystemDictionary::is_system_class_loader(class_loader()) && ik->defined_by_app_loader())  ||\n+        (SystemDictionary::is_platform_class_loader(class_loader()) && ik->defined_by_platform_loader())) {\n@@ -253,1 +253,1 @@\n-  if (CDSConfig::is_dumping_final_static_archive() && k->is_shared_unregistered_class()\n+  if (CDSConfig::is_dumping_final_static_archive() && k->defined_by_other_loaders()\n@@ -595,1 +595,1 @@\n-    guarantee(!k->is_shared_unregistered_class(),\n+    guarantee(!k->defined_by_other_loaders(),\n@@ -599,1 +599,1 @@\n-    guarantee(k->is_shared_unregistered_class(),\n+    guarantee(k->defined_by_other_loaders(),\n@@ -757,1 +757,1 @@\n-      assert(k->is_shared_unregistered_class(), \"must be\");\n+      assert(k->defined_by_other_loaders(), \"must be\");\n@@ -943,1 +943,1 @@\n-  if (klass->is_shared_boot_class()) {\n+  if (klass->defined_by_boot_loader()) {\n@@ -947,1 +947,1 @@\n-  if (klass->is_shared_platform_class() || klass->is_shared_app_class()) {\n+  if (klass->defined_by_platform_loader() || klass->defined_by_app_loader()) {\n@@ -990,1 +990,1 @@\n-  if (klass->is_shared_platform_class() || klass->is_shared_app_class()) {\n+  if (klass->defined_by_platform_loader() || klass->defined_by_app_loader()) {\n@@ -1158,1 +1158,1 @@\n-  if (ik->is_shared_boot_class()) {\n+  if (ik->defined_by_boot_loader()) {\n@@ -1160,1 +1160,1 @@\n-  } else if (ik->is_shared_platform_class()) {\n+  } else if (ik->defined_by_platform_loader()) {\n@@ -1162,1 +1162,1 @@\n-  } else if (ik->is_shared_app_class()) {\n+  } else if (ik->defined_by_app_loader()) {\n@@ -1164,1 +1164,1 @@\n-  } else if (ik->is_shared_unregistered_class()) {\n+  } else if (ik->defined_by_other_loaders()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    assert(k->is_shared_boot_class(), \"must be\");\n+    assert(k->defined_by_boot_loader(), \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+  \/\/ Disable stubs caching until JDK-8357398 is fixed.\n+  FLAG_SET_ERGO(AOTStubCaching, false);\n+\n@@ -902,1 +905,2 @@\n-  log_debug(aot, codecache, stubs)(\"Read blob '%s' (id=%u, kind=%s) from AOT Code Cache\", name, id, aot_code_entry_kind_name[entry_kind]);\n+  log_debug(aot, codecache, stubs)(\"%sRead blob '%s' (id=%u, kind=%s) from AOT Code Cache\",\n+                                   (blob == nullptr? \"Failed to \" : \"\"), name, id, aot_code_entry_kind_name[entry_kind]);\n@@ -917,2 +921,1 @@\n-    ((AOTCodeCache*)_cache)->set_failed();\n-    report_load_failure();\n+    set_lookup_failed(); \/\/ Skip this blob\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -396,1 +396,3 @@\n-    return (pc-1)->pc_offset() < pc_offset && pc_offset <= pc->pc_offset();\n+    \/\/ Do not look before the sentinel\n+    assert(pc_offset > PcDesc::lower_offset_limit, \"illegal pc_offset\");\n+    return pc_offset <= pc->pc_offset() && (pc-1)->pc_offset() < pc_offset;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-static void register_command(TypedMethodOptionMatcher* matcher,\n+static bool register_command(TypedMethodOptionMatcher* matcher,\n@@ -322,0 +322,2 @@\n+                             char* errorbuf,\n+                             const int buf_size,\n@@ -334,1 +336,11 @@\n-    return;\n+    return true;\n+  }\n+\n+  if (!UnlockDiagnosticVMOptions) {\n+    const char* name = option2name(option);\n+    JVMFlag* flag = JVMFlag::find_declared_flag(name);\n+    if (flag != nullptr && flag->is_diagnostic()) {\n+      jio_snprintf(errorbuf, buf_size, \"VM option '%s' is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\", name);\n+      delete matcher;\n+      return false;\n+    }\n@@ -349,1 +361,1 @@\n-  return;\n+  return true;\n@@ -717,1 +729,1 @@\n-static void scan_value(enum OptionType type, char* line, int& total_bytes_read,\n+static bool scan_value(enum OptionType type, char* line, int& total_bytes_read,\n@@ -736,3 +748,1 @@\n-      line += bytes_read;\n-      register_command(matcher, option, value);\n-      return;\n+      return register_command(matcher, option, errorbuf, buf_size, value);\n@@ -741,0 +751,1 @@\n+      return false;\n@@ -754,2 +765,1 @@\n-      line += bytes_read;\n-      register_command(matcher, option, value);\n+      return register_command(matcher, option, errorbuf, buf_size, value);\n@@ -758,0 +768,1 @@\n+      return false;\n@@ -764,3 +775,1 @@\n-      line += bytes_read;\n-      register_command(matcher, option, (ccstr) value);\n-      return;\n+      return register_command(matcher, option, errorbuf, buf_size, (ccstr) value);\n@@ -769,0 +778,1 @@\n+      return false;\n@@ -793,0 +803,1 @@\n+          return false;\n@@ -801,0 +812,1 @@\n+          return false;\n@@ -807,0 +819,1 @@\n+          return false;\n@@ -813,0 +826,1 @@\n+          return false;\n@@ -822,2 +836,1 @@\n-      register_command(matcher, option, (ccstr) value);\n-      return;\n+      return register_command(matcher, option, errorbuf, buf_size, (ccstr) value);\n@@ -826,0 +839,1 @@\n+      return false;\n@@ -832,2 +846,1 @@\n-      register_command(matcher, option, true);\n-      return;\n+      return register_command(matcher, option, errorbuf, buf_size,true);\n@@ -838,3 +851,1 @@\n-        line += bytes_read;\n-        register_command(matcher, option, true);\n-        return;\n+        return register_command(matcher, option, errorbuf, buf_size,true);\n@@ -843,3 +854,1 @@\n-        line += bytes_read;\n-        register_command(matcher, option, false);\n-        return;\n+        return register_command(matcher, option, errorbuf, buf_size,false);\n@@ -848,0 +857,1 @@\n+        return false;\n@@ -851,0 +861,1 @@\n+      return false;\n@@ -860,3 +871,1 @@\n-      line += bytes_read;\n-      register_command(matcher, option, atof(value));\n-      return;\n+      return register_command(matcher, option, errorbuf, buf_size, atof(value));\n@@ -865,0 +874,1 @@\n+      return false;\n@@ -868,0 +878,1 @@\n+    return false;\n@@ -874,1 +885,1 @@\n-static void scan_option_and_value(enum OptionType type, char* line, int& total_bytes_read,\n+static bool scan_option_and_value(enum OptionType type, char* line, int& total_bytes_read,\n@@ -890,1 +901,1 @@\n-      return;\n+      return false;\n@@ -897,1 +908,1 @@\n-      return;\n+      return false;\n@@ -899,1 +910,1 @@\n-    scan_value(type, line, total_bytes_read, matcher, option, errorbuf, buf_size);\n+    return scan_value(type, line, total_bytes_read, matcher, option, errorbuf, buf_size);\n@@ -903,0 +914,1 @@\n+    return false;\n@@ -904,1 +916,0 @@\n-  return;\n@@ -999,2 +1010,1 @@\n-        scan_option_and_value(type, line, bytes_read, typed_matcher, error_buf, sizeof(error_buf));\n-        if (*error_buf != '\\0') {\n+        if (!scan_option_and_value(type, line, bytes_read, typed_matcher, error_buf, sizeof(error_buf))) {\n@@ -1014,1 +1024,4 @@\n-          register_command(typed_matcher, option, true);\n+          if (!register_command(typed_matcher, option, error_buf, sizeof(error_buf), true)) {\n+            print_parse_error(error_buf, original.get());\n+            return false;\n+          }\n@@ -1044,1 +1057,4 @@\n-        register_command(matcher, option, true);\n+        if (!register_command(matcher, option, error_buf, sizeof(error_buf), true)) {\n+          print_parse_error(error_buf, original.get());\n+          return false;\n+        }\n@@ -1048,1 +1064,4 @@\n-        register_command(matcher, option, (uintx)MemStatAction::collect);\n+        if (!register_command(matcher, option, error_buf, sizeof(error_buf), (uintx)MemStatAction::collect)) {\n+          print_parse_error(error_buf, original.get());\n+          return false;\n+        }\n@@ -1056,2 +1075,1 @@\n-    scan_value(type, line, bytes_read, matcher, option, error_buf, sizeof(error_buf));\n-    if (*error_buf != '\\0') {\n+    if (!scan_value(type, line, bytes_read, matcher, option, error_buf, sizeof(error_buf))) {\n@@ -1164,2 +1182,3 @@\n-        register_command(matcher, CompileCommandEnum::CompileOnly, true);\n-        continue;\n+        if (register_command(matcher, CompileCommandEnum::CompileOnly, error_buf, sizeof(error_buf), true)) {\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":58,"deletions":39,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -59,8 +59,0 @@\n-\n-void G1BiasedMappedArrayBase::verify_biased_index_inclusive_end(idx_t biased_index) const {\n-  guarantee(_biased_base != nullptr, \"Array not initialized\");\n-  guarantee(biased_index >= bias() && biased_index <= (bias() + length()),\n-            \"Biased index out of inclusive bounds, index: %zu bias: %zu length: %zu\",\n-            biased_index, bias(), length());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,13 +41,0 @@\n-public:\n-  typedef size_t idx_t;\n-\n-protected:\n-  address _base;          \/\/ the real base address\n-  size_t _length;         \/\/ the length of the array\n-  address _biased_base;   \/\/ base address biased by \"bias\" elements\n-  size_t _bias;           \/\/ the bias, i.e. the offset biased_base is located to the right in elements\n-  uint _shift_by;         \/\/ the amount of bits to shift right when mapping to an index of the array.\n-\n-protected:\n-  G1BiasedMappedArrayBase();\n-\n@@ -70,0 +57,12 @@\n+public:\n+  typedef size_t idx_t;\n+\n+protected:\n+  address _base;          \/\/ the real base address\n+  size_t _length;         \/\/ the length of the array\n+  address _biased_base;   \/\/ base address biased by \"bias\" elements\n+  size_t _bias;           \/\/ the bias, i.e. the offset biased_base is located to the right in elements\n+  uint _shift_by;         \/\/ the amount of bits to shift right when mapping to an index of the array.\n+\n+  G1BiasedMappedArrayBase();\n+\n@@ -93,1 +92,0 @@\n-  void verify_biased_index_inclusive_end(idx_t biased_index) const PRODUCT_RETURN;\n@@ -106,0 +104,6 @@\n+protected:\n+  T* base() const { return (T*)G1BiasedMappedArrayBase::_base; }\n+\n+  \/\/ The raw biased base pointer.\n+  T* biased_base() const { return (T*)G1BiasedMappedArrayBase::_biased_base; }\n+\n@@ -109,1 +113,0 @@\n-  T* base() const { return (T*)G1BiasedMappedArrayBase::_base; }\n@@ -126,3 +129,0 @@\n-  \/\/ The raw biased base pointer.\n-  T* biased_base() const { return (T*)G1BiasedMappedArrayBase::_biased_base; }\n-\n@@ -157,20 +157,0 @@\n-  \/\/ Set the value of all array entries that correspond to addresses\n-  \/\/ in the specified MemRegion.\n-  void set_by_address(MemRegion range, T value) {\n-    idx_t biased_start = ((uintptr_t)range.start()) >> this->shift_by();\n-    idx_t biased_last = ((uintptr_t)range.last()) >> this->shift_by();\n-    this->verify_biased_index(biased_start);\n-    this->verify_biased_index(biased_last);\n-    for (idx_t i = biased_start; i <= biased_last; i++) {\n-      biased_base()[i] = value;\n-    }\n-  }\n-\n-protected:\n-  \/\/ Returns the address of the element the given address maps to\n-  T* address_mapped_to(HeapWord* address) {\n-    idx_t biased_index = ((uintptr_t)address) >> this->shift_by();\n-    this->verify_biased_index_inclusive_end(biased_index);\n-    return biased_base() + biased_index;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.hpp","additions":18,"deletions":38,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-      policy()->record_new_heap_size(num_regions());\n+      policy()->record_new_heap_size(num_committed_regions());\n@@ -843,1 +843,1 @@\n-bool G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n+void G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n@@ -858,3 +858,0 @@\n-\n-  \/\/ Full collection was successfully completed.\n-  return true;\n@@ -873,1 +870,1 @@\n-bool G1CollectedHeap::upgrade_to_full_collection() {\n+void G1CollectedHeap::upgrade_to_full_collection() {\n@@ -876,7 +873,3 @@\n-  bool success = do_full_collection(true  \/* clear_all_soft_refs *\/,\n-                                    false \/* do_maximal_compaction *\/,\n-                                    size_t(0) \/* allocation_word_size *\/);\n-  \/\/ do_full_collection only fails if blocked by GC locker and that can't\n-  \/\/ be the case here since we only call this when already completed one gc.\n-  assert(success, \"invariant\");\n-  return success;\n+  do_full_collection(true  \/* clear_all_soft_refs *\/,\n+                     false \/* do_maximal_compaction *\/,\n+                     size_t(0) \/* allocation_word_size *\/);\n@@ -903,3 +896,1 @@\n-                                                            bool expect_null_mutator_alloc_region,\n-                                                            bool* gc_succeeded) {\n-  *gc_succeeded = true;\n+                                                            bool expect_null_mutator_alloc_region) {\n@@ -933,3 +924,3 @@\n-    *gc_succeeded = do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n-                                       maximal_compaction \/* do_maximal_compaction *\/,\n-                                       word_size \/* allocation_word_size *\/);\n+    do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n+                       maximal_compaction \/* do_maximal_compaction *\/,\n+                       word_size \/* allocation_word_size *\/);\n@@ -941,2 +932,1 @@\n-HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size,\n-                                                     bool* succeeded) {\n+HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size) {\n@@ -950,2 +940,1 @@\n-                                     false, \/* expect_null_mutator_alloc_region *\/\n-                                     succeeded);\n+                                     false \/* expect_null_mutator_alloc_region *\/);\n@@ -953,1 +942,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -961,2 +950,1 @@\n-                                            true, \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true \/* expect_null_mutator_alloc_region *\/);\n@@ -964,1 +952,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -972,2 +960,1 @@\n-                                            true,  \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true  \/* expect_null_mutator_alloc_region *\/);\n@@ -1038,1 +1025,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1047,1 +1034,1 @@\n-    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm.available());\n+    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm.num_inactive_regions());\n@@ -1052,1 +1039,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1068,1 +1055,1 @@\n-    policy()->record_new_heap_size(num_regions());\n+    policy()->record_new_heap_size(num_committed_regions());\n@@ -1380,1 +1367,1 @@\n-  guarantee((max_reserved_regions() - 1) <= max_region_idx, \"too many regions\");\n+  guarantee((max_num_regions() - 1) <= max_region_idx, \"too many regions\");\n@@ -1385,1 +1372,1 @@\n-  G1FromCardCache::initialize(max_reserved_regions());\n+  G1FromCardCache::initialize(max_num_regions());\n@@ -1388,1 +1375,1 @@\n-  _rem_set->initialize(max_reserved_regions());\n+  _rem_set->initialize(max_num_regions());\n@@ -1397,1 +1384,1 @@\n-  G1FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n+  G1FreeRegionList::set_unrealistically_long_length(max_num_regions() + 1);\n@@ -1465,1 +1452,1 @@\n-  _collection_set.initialize(max_reserved_regions());\n+  _collection_set.initialize(max_num_regions());\n@@ -1564,1 +1551,1 @@\n-  return _hrm.length() * G1HeapRegion::GrainBytes;\n+  return _hrm.num_committed_regions() * G1HeapRegion::GrainBytes;\n@@ -2056,1 +2043,1 @@\n-  return max_regions() * G1HeapRegion::GrainBytes;\n+  return max_num_regions() * G1HeapRegion::GrainBytes;\n@@ -2204,1 +2191,1 @@\n-                       survivor_used_bytes, old_gen_used_bytes, num_regions());\n+                       survivor_used_bytes, old_gen_used_bytes, num_committed_regions());\n@@ -2288,2 +2275,2 @@\n-  bool ret_succeeded = op.prologue_succeeded() && op.gc_succeeded();\n-  assert(result == nullptr || ret_succeeded,\n+  *succeeded = op.gc_succeeded();\n+  assert(result == nullptr || *succeeded,\n@@ -2291,1 +2278,0 @@\n-  *succeeded = ret_succeeded;\n@@ -2418,1 +2404,1 @@\n-bool G1CollectedHeap::do_collection_pause_at_safepoint() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint() {\n@@ -2423,1 +2409,0 @@\n-  return true;\n@@ -2431,1 +2416,1 @@\n-  _g1h->print_heap_before_gc();\n+  _g1h->print_before_gc();\n@@ -2445,1 +2430,1 @@\n-  _g1h->print_heap_after_gc();\n+  _g1h->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":33,"deletions":48,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_reserved_regions() )\n+typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_num_regions() )\n@@ -484,1 +484,1 @@\n-  bool do_full_collection(bool clear_all_soft_refs,\n+  void do_full_collection(bool clear_all_soft_refs,\n@@ -492,1 +492,1 @@\n-  bool upgrade_to_full_collection();\n+  void upgrade_to_full_collection();\n@@ -497,2 +497,1 @@\n-  HeapWord* satisfy_failed_allocation(size_t word_size,\n-                                      bool* succeeded);\n+  HeapWord* satisfy_failed_allocation(size_t word_size);\n@@ -513,2 +512,1 @@\n-                                             bool expect_null_mutator_alloc_region,\n-                                             bool* gc_succeeded);\n+                                             bool expect_null_mutator_alloc_region);\n@@ -745,3 +743,1 @@\n-  \/\/ followed by a by-policy upgrade to a full collection.  Returns\n-  \/\/ false if unable to do the collection due to the GC locker being\n-  \/\/ active, true otherwise.\n+  \/\/ followed by a by-policy upgrade to a full collection.\n@@ -750,1 +746,1 @@\n-  bool do_collection_pause_at_safepoint();\n+  void do_collection_pause_at_safepoint();\n@@ -974,1 +970,1 @@\n-    return _hrm.available() == 0;\n+    return _hrm.num_inactive_regions() == 0;\n@@ -984,1 +980,1 @@\n-  uint num_regions() const { return _hrm.length(); }\n+  uint num_committed_regions() const { return _hrm.num_committed_regions(); }\n@@ -986,6 +982,2 @@\n-  \/\/ The max number of regions reserved for the heap. Except for static array\n-  \/\/ sizing purposes you probably want to use max_regions().\n-  uint max_reserved_regions() const { return _hrm.reserved_length(); }\n-\n-  \/\/ Max number of regions that can be committed.\n-  uint max_regions() const { return _hrm.max_length(); }\n+  \/\/ The max number of regions reserved for the heap.\n+  uint max_num_regions() const { return _hrm.max_num_regions(); }\n@@ -996,0 +988,3 @@\n+  \/\/ The number of regions that are not completely free.\n+  uint num_used_regions() const { return _hrm.num_used_regions(); }\n+\n@@ -997,1 +992,1 @@\n-  uint num_free_or_available_regions() const { return num_free_regions() + _hrm.available(); }\n+  uint num_available_regions() const { return _hrm.num_available_regions(); }\n@@ -1003,2 +998,0 @@\n-  \/\/ The number of regions that are not completely free.\n-  uint num_used_regions() const { return num_regions() - num_free_regions(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-  _root_regions(_g1h->max_regions()),\n+  _root_regions(_g1h->max_num_regions()),\n@@ -516,3 +516,3 @@\n-  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_reserved_regions(), mtGC)),\n-  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC)),\n-  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC)),\n+  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_num_regions(), mtGC)),\n+  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n+  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_num_regions(), mtGC)),\n@@ -573,2 +573,2 @@\n-  uint max_reserved_regions = _g1h->max_reserved_regions();\n-  for (uint i = 0; i < max_reserved_regions; i++) {\n+  uint max_num_regions = _g1h->max_num_regions();\n+  for (uint i = 0; i < max_num_regions; i++) {\n@@ -616,2 +616,2 @@\n-    uint max_reserved_regions = _g1h->max_reserved_regions();\n-    for (uint i = 0; i < max_reserved_regions; i++) {\n+    uint max_num_regions = _g1h->max_num_regions();\n+    for (uint i = 0; i < max_num_regions; i++) {\n@@ -785,1 +785,1 @@\n-  size_t const num_bytes_to_clear = (G1HeapRegion::GrainBytes * _g1h->num_regions()) \/ G1CMBitMap::heap_map_factor();\n+  size_t const num_bytes_to_clear = (G1HeapRegion::GrainBytes * _g1h->num_committed_regions()) \/ G1CMBitMap::heap_map_factor();\n@@ -1437,1 +1437,1 @@\n-      uint const num_workers = MIN2(G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(_g1h->num_regions()),\n+      uint const num_workers = MIN2(G1UpdateRegionLivenessAndSelectForRebuildTask::desired_num_workers(_g1h->num_committed_regions()),\n@@ -1439,1 +1439,1 @@\n-      log_debug(gc,ergo)(\"Running %s using %u workers for %u regions in heap\", cl.name(), num_workers, _g1h->num_regions());\n+      log_debug(gc,ergo)(\"Running %s using %u workers for %u regions in heap\", cl.name(), num_workers, _g1h->num_committed_regions());\n@@ -1443,1 +1443,1 @@\n-                                        _g1h->num_regions(), cl.total_selected_for_rebuild());\n+                                        _g1h->num_committed_regions(), cl.total_selected_for_rebuild());\n@@ -1450,1 +1450,1 @@\n-        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n+        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_committed_regions(), _g1h->policy()->candidates());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"Tried to access TAMS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_num_regions(), \"Tried to access TAMS for region %u out of bounds\", region);\n@@ -202,1 +202,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_num_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n@@ -208,1 +208,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"obj \" PTR_FORMAT \" outside heap %u\", p2i(obj), region);\n+  assert(region < _g1h->max_num_regions(), \"obj \" PTR_FORMAT \" outside heap %u\", p2i(obj), region);\n@@ -220,1 +220,1 @@\n-  assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_num_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  uint max_wasted_regions_allowed = ((heap->num_regions() * G1HeapWastePercent) \/ 100);\n+  uint max_wasted_regions_allowed = ((heap->num_committed_regions() * G1HeapWastePercent) \/ 100);\n@@ -136,3 +136,3 @@\n-  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_regions(), mtGC);\n-  _compaction_tops = NEW_C_HEAP_ARRAY(HeapWord*, _heap->max_regions(), mtGC);\n-  for (uint j = 0; j < heap->max_regions(); j++) {\n+  _live_stats = NEW_C_HEAP_ARRAY(G1RegionMarkStats, _heap->max_num_regions(), mtGC);\n+  _compaction_tops = NEW_C_HEAP_ARRAY(HeapWord*, _heap->max_num_regions(), mtGC);\n+  for (uint j = 0; j < heap->max_num_regions(); j++) {\n@@ -418,1 +418,1 @@\n-  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n+  assert(start_serial < _heap->max_num_regions(), \"Called on empty parallel compaction queues\");\n@@ -430,1 +430,1 @@\n-  for (uint i = start_serial + 1; i < _heap->max_reserved_regions(); i++) {\n+  for (uint i = start_serial + 1; i < _heap->max_num_regions(); i++) {\n@@ -448,1 +448,1 @@\n-  uint max_reserved_regions = _heap->max_reserved_regions();\n+  uint max_num_regions = _heap->max_num_regions();\n@@ -452,1 +452,1 @@\n-  while (region_index < max_reserved_regions) {\n+  while (region_index < max_num_regions) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    assert(region_index < _heap->max_regions(), \"sanity\");\n+    assert(region_index < _heap->max_num_regions(), \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  _committed_map.initialize(reserved_length());\n+  _committed_map.initialize(max_num_regions());\n@@ -180,1 +180,1 @@\n-  guarantee(num_regions <= available(),\n+  guarantee(num_regions <= num_inactive_regions(),\n@@ -245,1 +245,1 @@\n-  assert(length() >= num_regions, \"pre-condition\");\n+  assert(num_committed_regions() >= num_regions, \"pre-condition\");\n@@ -398,2 +398,2 @@\n-  if (available() >= 1) {\n-    for (uint i = 0; i < reserved_length(); i++) {\n+  if (num_inactive_regions() >= 1) {\n+    for (uint i = 0; i < max_num_regions(); i++) {\n@@ -474,1 +474,1 @@\n-  } while (candidate == G1_NO_HRM_INDEX && range.end() < reserved_length());\n+  } while (candidate == G1_NO_HRM_INDEX && range.end() < max_num_regions());\n@@ -481,1 +481,1 @@\n-  if (num_regions > (num_free_regions() + available())) {\n+  if (num_regions > num_available_regions()) {\n@@ -485,1 +485,1 @@\n-  return find_contiguous_in_range(0, reserved_length(), num_regions);\n+  return find_contiguous_in_range(0, max_num_regions(), num_regions);\n@@ -501,1 +501,1 @@\n-  uint len = reserved_length();\n+  uint len = max_num_regions();\n@@ -517,1 +517,1 @@\n-  uint len = reserved_length();\n+  uint len = max_num_regions();\n@@ -584,2 +584,2 @@\n-  assert(length() > 0, \"the region sequence should not be empty\");\n-  assert(length() <= _next_highest_used_hrm_index, \"invariant\");\n+  assert(num_committed_regions() > 0, \"the region sequence should not be empty\");\n+  assert(num_committed_regions() <= _next_highest_used_hrm_index, \"invariant\");\n@@ -587,1 +587,1 @@\n-  assert(num_regions_to_remove < length(), \"We should never remove all regions\");\n+  assert(num_regions_to_remove < num_committed_regions(), \"We should never remove all regions\");\n@@ -660,9 +660,9 @@\n-  guarantee(length() <= _next_highest_used_hrm_index,\n-            \"invariant: _length: %u _next_highest_used_hrm_index: %u\",\n-            length(), _next_highest_used_hrm_index);\n-  guarantee(_next_highest_used_hrm_index <= reserved_length(),\n-            \"invariant: _next_highest_used_hrm_index: %u _max_length: %u\",\n-            _next_highest_used_hrm_index, reserved_length());\n-  guarantee(length() <= max_length(),\n-            \"invariant: committed regions: %u max_regions: %u\",\n-            length(), max_length());\n+  guarantee(num_committed_regions() <= _next_highest_used_hrm_index,\n+            \"invariant: committed regions: %u _next_highest_used_hrm_index: %u\",\n+            num_committed_regions(), _next_highest_used_hrm_index);\n+  guarantee(_next_highest_used_hrm_index <= max_num_regions(),\n+            \"invariant: _next_highest_used_hrm_index: %u max_num_regions: %u\",\n+            _next_highest_used_hrm_index, max_num_regions());\n+  guarantee(num_committed_regions() <= max_num_regions(),\n+            \"invariant: committed regions: %u max_num_regions: %u\",\n+            num_committed_regions(), max_num_regions());\n@@ -695,1 +695,1 @@\n-  for (uint i = _next_highest_used_hrm_index; i < reserved_length(); i++) {\n+  for (uint i = _next_highest_used_hrm_index; i < max_num_regions(); i++) {\n@@ -699,1 +699,1 @@\n-  guarantee(num_committed == length(), \"Found %u committed regions, but should be %u\", num_committed, length());\n+  guarantee(num_committed == num_committed_regions(), \"Found %u committed regions, but should be %u\", num_committed, num_committed_regions());\n@@ -748,1 +748,1 @@\n-      _worker_chunk_size((_hrm->reserved_length() + num_workers - 1) \/ num_workers),\n+      _worker_chunk_size((_hrm->max_num_regions() + num_workers - 1) \/ num_workers),\n@@ -773,1 +773,1 @@\n-    uint end = MIN2(start + _worker_chunk_size, _hrm->reserved_length());\n+    uint end = MIN2(start + _worker_chunk_size, _hrm->max_num_regions());\n@@ -799,1 +799,1 @@\n-  uint const num_workers = clamp(max_length(), 1u, workers->active_workers());\n+  uint const num_workers = clamp(max_num_regions(), 1u, workers->active_workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,1 @@\n-\/\/ * max_length() returns the maximum number of regions the heap may commit.\n-\/\/ * reserved_length() returns the maximum number of regions the heap has reserved.\n+\/\/ * max_num_regions() returns the maximum number of regions the heap has reserved.\n@@ -224,0 +223,2 @@\n+  uint num_used_regions() const { return num_committed_regions() - num_free_regions(); }\n+\n@@ -232,2 +233,2 @@\n-  \/\/ Return the number of regions available (uncommitted) regions.\n-  uint available() const { return max_length() - length(); }\n+  \/\/ Return the number of regions uncommitted or ready to be uncommitted.\n+  uint num_inactive_regions() const { return max_num_regions() - num_committed_regions(); }\n@@ -236,1 +237,1 @@\n-  uint length() const { return _committed_map.num_active(); }\n+  uint num_committed_regions() const { return _committed_map.num_active(); }\n@@ -239,1 +240,1 @@\n-  uint reserved_length() const { return (uint)_regions.length(); }\n+  uint max_num_regions() const { return (uint)_regions.length(); }\n@@ -241,2 +242,1 @@\n-  \/\/ Return maximum number of regions that heap can expand to.\n-  uint max_length() const { return reserved_length(); }\n+  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  if (index < reserved_length() && is_available(index) && at(index)->is_continues_humongous()) {\n+  if (index < max_num_regions() && is_available(index) && at(index)->is_continues_humongous()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers),\n+    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers, ParGCArrayScanChunk),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  _young_gen_sizer.adjust_max_new_size(_g1h->max_regions());\n+  _young_gen_sizer.adjust_max_new_size(_g1h->max_num_regions());\n@@ -679,1 +679,1 @@\n-  assert(max_survivor_regions() + _g1h->num_used_regions() <= _g1h->max_regions(),\n+  assert(max_survivor_regions() + _g1h->num_used_regions() <= _g1h->max_num_regions(),\n@@ -681,1 +681,1 @@\n-         max_survivor_regions(), _g1h->num_used_regions(), _g1h->max_regions());\n+         max_survivor_regions(), _g1h->num_used_regions(), _g1h->max_num_regions());\n@@ -1203,1 +1203,1 @@\n-                               _g1h->num_free_or_available_regions());\n+                               _g1h->num_available_regions());\n@@ -1448,1 +1448,1 @@\n-  double result = (double)_g1h->num_regions() * G1OldCSetRegionThresholdPercent \/ 100;\n+  double result = (double)_g1h->num_committed_regions() * G1OldCSetRegionThresholdPercent \/ 100;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1435,1 +1435,1 @@\n-      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * G1HeapRegion::CardsPerRegion;\n+      (g1h->num_committed_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * G1HeapRegion::CardsPerRegion;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-  void initialize(uint max_reserved_regions);\n+  void initialize(uint max_num_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-    _gc_succeeded = g1h->do_collection_pause_at_safepoint();\n-    assert(_gc_succeeded, \"No reason to fail\");\n+    g1h->do_collection_pause_at_safepoint();\n+    _gc_succeeded = true;\n@@ -113,2 +113,1 @@\n-  VM_CollectForAllocation(word_size, gc_count_before, gc_cause),\n-  _gc_succeeded(false) {}\n+  VM_CollectForAllocation(word_size, gc_count_before, gc_cause) {}\n@@ -121,2 +120,1 @@\n-  _gc_succeeded = g1h->do_collection_pause_at_safepoint();\n-  assert(_gc_succeeded, \"no reason to fail\");\n+  g1h->do_collection_pause_at_safepoint();\n@@ -127,1 +125,1 @@\n-    _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n+    _result = g1h->satisfy_failed_allocation(_word_size);\n@@ -132,1 +130,1 @@\n-    _gc_succeeded = g1h->upgrade_to_full_collection();\n+    g1h->upgrade_to_full_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+  \/\/ The concurrent start pause may be cancelled for some reasons. Keep track of\n+  \/\/ this.\n@@ -68,1 +70,0 @@\n-  bool _gc_succeeded;\n@@ -76,1 +77,1 @@\n-  bool gc_succeeded() const { return _gc_succeeded; }\n+  bool gc_succeeded() const { return prologue_succeeded(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-  _evac_failure_regions.pre_collection(_g1h->max_reserved_regions());\n+  _evac_failure_regions.pre_collection(_g1h->max_num_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  _allocation_failure_regions.reinitialize(g1h->max_reserved_regions());\n+  _allocation_failure_regions.reinitialize(g1h->max_num_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        thread->tlab().retire(&_tlab_stats);\n+        thread->retire_tlab(&_tlab_stats);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-void ObjectStartArray::initialize(MemRegion reserved_region) {\n+ObjectStartArray::ObjectStartArray(MemRegion covered_region)\n+  : _virtual_space(nullptr) {\n@@ -41,1 +42,1 @@\n-  size_t bytes_to_reserve = num_bytes_required(reserved_region);\n+  size_t bytes_to_reserve = num_bytes_required(covered_region);\n@@ -55,1 +56,1 @@\n-  _virtual_space.initialize(backing_store);\n+  _virtual_space = new PSVirtualSpace(backing_store, os::vm_page_size());\n@@ -57,1 +58,1 @@\n-  assert(_virtual_space.low_boundary() != nullptr, \"set from the backing_store\");\n+  assert(_virtual_space->low_boundary() != nullptr, \"set from the backing_store\");\n@@ -59,1 +60,1 @@\n-  _offset_base = (uint8_t*)(_virtual_space.low_boundary() - (uintptr_t(reserved_region.start()) >> CardTable::card_shift()));\n+  _offset_base = (uint8_t*)(_virtual_space->low_boundary() - (uintptr_t(covered_region.start()) >> CardTable::card_shift()));\n@@ -66,1 +67,1 @@\n-  \/\/ Only commit memory in page sized chunks\n+  \/\/ Only commit memory in page-sized chunks\n@@ -69,1 +70,1 @@\n-  size_t current_size = _virtual_space.committed_size();\n+  size_t current_size = _virtual_space->committed_size();\n@@ -78,1 +79,1 @@\n-    if (!_virtual_space.expand_by(expand_by)) {\n+    if (!_virtual_space->expand_by(expand_by)) {\n@@ -84,1 +85,1 @@\n-    _virtual_space.shrink_by(shrink_by);\n+    _virtual_space->shrink_by(shrink_by);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  PSVirtualSpace  _virtual_space;\n+  PSVirtualSpace* _virtual_space;\n@@ -77,1 +77,1 @@\n-  void initialize(MemRegion reserved_region);\n+  ObjectStartArray(MemRegion covered_region);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads),\n+  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads, ObjArrayMarkingStride),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  \/\/ Object start stuff: for all reserved memory\n-  start_array()->initialize(reserved_mr);\n-\n@@ -111,0 +108,1 @@\n+  _start_array = new ObjectStartArray(reserved_mr);\n@@ -285,1 +283,1 @@\n-    _start_array.update_for_block(cur, cur + word_size);\n+    _start_array->update_for_block(cur, cur + word_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  ObjectStartArray         _start_array;       \/\/ Keeps track of where objects start in a 512b block\n+  ObjectStartArray*        _start_array;       \/\/ Keeps track of where objects start in a 512b block\n@@ -59,1 +59,1 @@\n-      _start_array.update_for_block(res, res + word_size);\n+      _start_array->update_for_block(res, res + word_size);\n@@ -106,1 +106,1 @@\n-  ObjectStartArray*     start_array()             { return &_start_array; }\n+  ObjectStartArray*     start_array()             { return _start_array;  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -668,1 +668,1 @@\n-  heap->print_heap_before_gc();\n+  heap->print_before_gc();\n@@ -1171,1 +1171,1 @@\n-  heap->print_heap_after_gc();\n+  heap->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n+  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads, ParGCArrayScanChunk)\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-  heap->print_heap_before_gc();\n+  heap->print_before_gc();\n@@ -590,1 +590,1 @@\n-  heap->print_heap_after_gc();\n+  heap->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-\/\/ PSVirtualSpace\n-\n@@ -40,17 +38,0 @@\n-\/\/ Deprecated.\n-PSVirtualSpace::PSVirtualSpace():\n-  _alignment(os::vm_page_size()),\n-  _reserved_low_addr(nullptr),\n-  _reserved_high_addr(nullptr),\n-  _committed_low_addr(nullptr),\n-  _committed_high_addr(nullptr),\n-  _special(false) {\n-}\n-\n-\/\/ Deprecated.\n-void PSVirtualSpace::initialize(ReservedSpace rs) {\n-  set_reserved(rs);\n-  set_committed(reserved_low_addr(), reserved_low_addr());\n-  DEBUG_ONLY(verify());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,3 +61,0 @@\n-  PSVirtualSpace();\n-  void initialize(ReservedSpace rs);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-  print_heap_before_gc();\n+  print_before_gc();\n@@ -443,1 +443,1 @@\n-  print_heap_after_gc();\n+  print_after_gc();\n@@ -626,1 +626,1 @@\n-  print_heap_before_gc();\n+  print_before_gc();\n@@ -686,1 +686,1 @@\n-  print_heap_after_gc();\n+  print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,4 +70,1 @@\n-class GCMessage : public FormatBuffer<1024> {\n- public:\n-  bool is_before;\n-};\n+class GCLogMessage : public FormatBuffer<512> {};\n@@ -76,2 +73,1 @@\n-void EventLogBase<GCMessage>::print(outputStream* st, GCMessage& m) {\n-  st->print_cr(\"GC heap %s\", m.is_before ? \"before\" : \"after\");\n+void EventLogBase<GCLogMessage>::print(outputStream* st, GCLogMessage& m) {\n@@ -81,3 +77,3 @@\n-class GCHeapLog : public EventLogBase<GCMessage> {\n- private:\n-  void log_heap(CollectedHeap* heap, bool before);\n+class GCLog : public EventLogBase<GCLogMessage> {\n+ protected:\n+  virtual void log_usage(const CollectedHeap* heap, outputStream* st) const = 0;\n@@ -86,1 +82,1 @@\n-  GCHeapLog() : EventLogBase<GCMessage>(\"GC Heap History\", \"gc\") {}\n+  GCLog(const char* name, const char* handle) : EventLogBase<GCLogMessage>(name, handle) {}\n@@ -88,6 +84,1 @@\n-  void log_heap_before(CollectedHeap* heap) {\n-    log_heap(heap, true);\n-  }\n-  void log_heap_after(CollectedHeap* heap) {\n-    log_heap(heap, false);\n-  }\n+  void log_gc(const CollectedHeap* heap, GCWhen::Type when);\n@@ -96,1 +87,1 @@\n-void GCHeapLog::log_heap(CollectedHeap* heap, bool before) {\n+void GCLog::log_gc(const CollectedHeap* heap, GCWhen::Type when) {\n@@ -104,1 +95,1 @@\n-  _records[index].thread = nullptr; \/\/ Its the GC thread so it's not that interesting.\n+  _records[index].thread = nullptr; \/\/ It's the GC thread so it's not that interesting.\n@@ -106,1 +97,0 @@\n-  _records[index].data.is_before = before;\n@@ -109,5 +99,1 @@\n-  st.print_cr(\"{Heap %s GC invocations=%u (full %u):\",\n-                 before ? \"before\" : \"after\",\n-                 heap->total_collections(),\n-                 heap->total_full_collections());\n-\n+  st.print(\"{\");\n@@ -115,0 +101,1 @@\n+    heap->print_invocation_on(&st, _handle, when);\n@@ -116,2 +103,1 @@\n-    heap->print_heap_on(&st);\n-    MetaspaceUtils::print_on(&st);\n+    log_usage(heap, &st);\n@@ -119,1 +105,0 @@\n-\n@@ -123,0 +108,20 @@\n+class GCHeapLog : public GCLog {\n+ private:\n+  void log_usage(const CollectedHeap* heap, outputStream* st) const override {\n+    heap->print_heap_on(st);\n+  }\n+\n+ public:\n+  GCHeapLog() : GCLog(\"GC Heap Usage History\", \"heap\") {}\n+};\n+\n+class GCMetaspaceLog : public GCLog {\n+ private:\n+  void log_usage(const CollectedHeap* heap, outputStream* st) const override {\n+    MetaspaceUtils::print_on(st);\n+  }\n+\n+ public:\n+  GCMetaspaceLog() : GCLog(\"Metaspace Usage History\", \"metaspace\") {}\n+};\n+\n@@ -166,5 +171,3 @@\n-void CollectedHeap::print_heap_before_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print_cr(\"Heap before GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n+void CollectedHeap::print_invocation_on(outputStream* st, const char* type, GCWhen::Type when) const {\n+  st->print_cr(\"%s %s invocations=%u (full %u):\", type, GCWhen::to_string(when), total_collections(), total_full_collections());\n+}\n@@ -172,0 +175,6 @@\n+void CollectedHeap::print_relative_to_gc(GCWhen::Type when) const {\n+  \/\/ Print heap information\n+  LogTarget(Debug, gc, heap) lt_heap;\n+  if (lt_heap.is_enabled()) {\n+    LogStream ls(lt_heap);\n+    print_invocation_on(&ls, \"Heap\", when);\n@@ -174,1 +183,0 @@\n-    MetaspaceUtils::print_on(&ls);\n@@ -177,2 +185,2 @@\n-  if (_gc_heap_log != nullptr) {\n-    _gc_heap_log->log_heap_before(this);\n+  if (_heap_log != nullptr) {\n+    _heap_log->log_gc(this, when);\n@@ -180,1 +188,0 @@\n-}\n@@ -182,8 +189,6 @@\n-void CollectedHeap::print_heap_after_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print_cr(\"Heap after GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n-\n-    StreamIndentor si(&ls, 1);\n-    print_heap_on(&ls);\n+  \/\/ Print metaspace information\n+  LogTarget(Debug, gc, metaspace) lt_metaspace;\n+  if (lt_metaspace.is_enabled()) {\n+    LogStream ls(lt_metaspace);\n+    print_invocation_on(&ls, \"Metaspace\", when);\n+    StreamIndentor indentor(&ls, 1);\n@@ -193,2 +198,2 @@\n-  if (_gc_heap_log != nullptr) {\n-    _gc_heap_log->log_heap_after(this);\n+  if (_metaspace_log != nullptr) {\n+    _metaspace_log->log_gc(this, when);\n@@ -198,0 +203,8 @@\n+void CollectedHeap::print_before_gc() const {\n+  print_relative_to_gc(GCWhen::BeforeGC);\n+}\n+\n+void CollectedHeap::print_after_gc() const {\n+  print_relative_to_gc(GCWhen::AfterGC);\n+}\n+\n@@ -304,1 +317,2 @@\n-    _gc_heap_log = new GCHeapLog();\n+    _metaspace_log = new GCMetaspaceLog();\n+    _heap_log = new GCHeapLog();\n@@ -306,1 +320,2 @@\n-    _gc_heap_log = nullptr;\n+    _metaspace_log = nullptr;\n+    _heap_log = nullptr;\n@@ -520,2 +535,2 @@\n-      if (retire_tlabs) {\n-        thread->tlab().retire(&stats);\n+      if (retire_tlabs || ZeroTLAB) {\n+        thread->retire_tlab(&stats);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":65,"deletions":50,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+class GCMemoryManager;\n+class GCMetaspaceLog;\n@@ -53,1 +55,0 @@\n-class GCMemoryManager;\n@@ -97,1 +98,2 @@\n-  GCHeapLog* _gc_heap_log;\n+  GCHeapLog*      _heap_log;\n+  GCMetaspaceLog* _metaspace_log;\n@@ -424,0 +426,2 @@\n+  void print_relative_to_gc(GCWhen::Type when) const;\n+\n@@ -439,0 +443,2 @@\n+  void print_invocation_on(outputStream* st, const char* type, GCWhen::Type when) const;\n+\n@@ -458,2 +464,2 @@\n-  void print_heap_before_gc();\n-  void print_heap_after_gc();\n+  void print_before_gc() const;\n+  void print_after_gc() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-  bool                _tlab_end_reset_for_sample;\n@@ -77,2 +76,1 @@\n-      _allocated_tlab_size(0),\n-      _tlab_end_reset_for_sample(false)\n+      _allocated_tlab_size(0)\n@@ -177,5 +175,2 @@\n-  if (!_allocated_outside_tlab && _allocated_tlab_size == 0 && !_tlab_end_reset_for_sample) {\n-    \/\/ Sample if it's a non-TLAB allocation, or a TLAB allocation that either refills the TLAB\n-    \/\/ or expands it due to taking a sampler induced slow path.\n-    return;\n-  }\n+  ThreadHeapSampler& heap_sampler = _thread->heap_sampler();\n+  ThreadLocalAllocBuffer& tlab = _thread->tlab();\n@@ -183,4 +178,2 @@\n-  \/\/ If we want to be sampling, protect the allocated object with a Handle\n-  \/\/ before doing the callback. The callback is done in the destructor of\n-  \/\/ the JvmtiSampledObjectAllocEventCollector.\n-  size_t bytes_since_last = 0;\n+  \/\/ Log sample decision\n+  heap_sampler.log_sample_decision(tlab.top());\n@@ -188,1 +181,4 @@\n-  {\n+  if (heap_sampler.should_sample(tlab.top())) {\n+    \/\/ If we want to be sampling, protect the allocated object with a Handle\n+    \/\/ before doing the callback. The callback is done in the destructor of\n+    \/\/ the JvmtiSampledObjectAllocEventCollector.\n@@ -191,2 +187,0 @@\n-    size_t size_in_bytes = _allocator._word_size * HeapWordSize;\n-    ThreadLocalAllocBuffer& tlab = _thread->tlab();\n@@ -194,3 +188,2 @@\n-    if (!_allocated_outside_tlab) {\n-      bytes_since_last = tlab.bytes_since_last_sample_point();\n-    }\n+    \/\/ Perform the sampling\n+    heap_sampler.sample(obj_h(), tlab.top());\n@@ -198,1 +191,3 @@\n-    _thread->heap_sampler().check_for_sampling(obj_h(), size_in_bytes, bytes_since_last);\n+    \/\/ Note that after this point all the TLAB can have been retired, and agent\n+    \/\/ code can run and allocate, don't rely on earlier calculations involving\n+    \/\/ the TLAB.\n@@ -201,3 +196,4 @@\n-  if (_tlab_end_reset_for_sample || _allocated_tlab_size != 0) {\n-    \/\/ Tell tlab to forget bytes_since_last if we passed it to the heap sampler.\n-    _thread->tlab().set_sample_end(bytes_since_last != 0);\n+  \/\/ Set a new sampling point in the TLAB if it fits in the current TLAB\n+  const size_t words_until_sample = heap_sampler.bytes_until_sample(tlab.top()) \/ HeapWordSize;\n+  if (words_until_sample <= tlab.free()) {\n+    tlab.set_sampling_point(tlab.top() + words_until_sample);\n@@ -252,0 +248,1 @@\n+  _thread->heap_sampler().inc_outside_tlab_bytes(size_in_bytes);\n@@ -265,0 +262,6 @@\n+    \/\/ When sampling we artificially set the TLAB end to the sample point.\n+    \/\/ When we hit that point it looks like the TLAB is full, but it's\n+    \/\/ not necessarily the case. Set the real end and retry the allocation.\n+\n+    \/\/ Undo previous adjustment of end.\n+    \/\/ Note that notify_allocation_jvmti_sampler will set a new sample point.\n@@ -266,1 +269,0 @@\n-    mem = tlab.allocate(_word_size);\n@@ -268,3 +270,2 @@\n-    \/\/ We set back the allocation sample point to try to allocate this, reset it\n-    \/\/ when done.\n-    allocation._tlab_end_reset_for_sample = true;\n+    \/\/ Retry the TLAB allocation with the proper end\n+    mem = tlab.allocate(_word_size);\n@@ -285,0 +286,7 @@\n+\n+  \/\/ Record the amount wasted\n+  tlab.record_refill_waste();\n+\n+  \/\/ Retire the current TLAB\n+  _thread->retire_tlab();\n+\n@@ -288,2 +296,0 @@\n-  tlab.retire_before_allocation();\n-\n@@ -320,1 +326,2 @@\n-  tlab.fill(mem, mem + _word_size, allocation._allocated_tlab_size);\n+  _thread->fill_tlab(mem, _word_size, allocation._allocated_tlab_size);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":36,"deletions":29,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n-                                           uint num_workers)\n+                                           uint num_workers,\n+                                           size_t chunk_size)\n@@ -33,1 +34,1 @@\n-    _stepper(num_workers, ParGCArrayScanChunk)\n+    _stepper(num_workers, chunk_size)\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-  PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers);\n+  PartialArraySplitter(PartialArrayStateManager* manager,\n+                       uint num_workers,\n+                       size_t chunk_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  _bytes_since_last_sample_point(0),\n@@ -128,5 +127,1 @@\n-    if (ZeroTLAB) {\n-      retire();\n-    } else {\n-      insert_filler();\n-    }\n+    insert_filler();\n@@ -143,1 +138,0 @@\n-    thread()->incr_allocated_bytes(used_bytes());\n@@ -149,1 +143,1 @@\n-void ThreadLocalAllocBuffer::retire_before_allocation() {\n+void ThreadLocalAllocBuffer::record_refill_waste() {\n@@ -151,1 +145,0 @@\n-  retire();\n@@ -315,18 +308,0 @@\n-void ThreadLocalAllocBuffer::set_sample_end(bool reset_byte_accumulation) {\n-  size_t heap_words_remaining = pointer_delta(_end, _top);\n-  size_t bytes_until_sample = thread()->heap_sampler().bytes_until_sample();\n-  size_t words_until_sample = bytes_until_sample \/ HeapWordSize;\n-\n-  if (reset_byte_accumulation) {\n-    _bytes_since_last_sample_point = 0;\n-  }\n-\n-  if (heap_words_remaining > words_until_sample) {\n-    HeapWord* new_end = _top + words_until_sample;\n-    set_end(new_end);\n-    _bytes_since_last_sample_point += bytes_until_sample;\n-  } else {\n-    _bytes_since_last_sample_point += heap_words_remaining * HeapWordSize;\n-  }\n-}\n-\n@@ -341,0 +316,8 @@\n+void ThreadLocalAllocBuffer::set_sampling_point(HeapWord* sampling_point) {\n+  precond(sampling_point >= _top);\n+  precond(sampling_point <= _allocation_end);\n+\n+  \/\/ This will trigger a slow-path, which in turn might take a sample.\n+  _end = sampling_point;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":10,"deletions":27,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  size_t    _bytes_since_last_sample_point;      \/\/ bytes since last sample point.\n@@ -127,1 +126,0 @@\n-  size_t bytes_since_last_sample_point() const   { return _bytes_since_last_sample_point; }\n@@ -161,2 +159,2 @@\n-  \/\/ Retire in-use tlab before allocation of a new tlab\n-  void retire_before_allocation();\n+  \/\/ Record refill waste before allocating (refilling) with a new TLAB.\n+  void record_refill_waste();\n@@ -170,0 +168,1 @@\n+  \/\/ Support for TLAB sampling\n@@ -171,1 +170,1 @@\n-  void set_sample_end(bool reset_byte_accumulation);\n+  void set_sampling_point(HeapWord* sampling_point);\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  virtual bool is_experimental() { return true; }\n+  virtual bool is_experimental() { return false; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,6 +42,0 @@\n-\/\/ We do not maintain counts, capacity, or used for regions that are not free.  Informally, if a region is NotFree, it is\n-\/\/ in no partition.  NumPartitions represents the size of an array that may be indexed by Mutator or Collector.\n-#define NumPartitions           (ShenandoahFreeSetPartitionId::NotFree)\n-#define IntNumPartitions     int(ShenandoahFreeSetPartitionId::NotFree)\n-#define UIntNumPartitions   uint(ShenandoahFreeSetPartitionId::NotFree)\n-\n@@ -55,0 +49,6 @@\n+  \/\/ We do not maintain counts, capacity, or used for regions that are not free.  Informally, if a region is NotFree, it is\n+  \/\/ in no partition.  NumPartitions represents the size of an array that may be indexed by Mutator or Collector.\n+  static constexpr ShenandoahFreeSetPartitionId NumPartitions     =      ShenandoahFreeSetPartitionId::NotFree;\n+  static constexpr int                          IntNumPartitions  =  int(ShenandoahFreeSetPartitionId::NotFree);\n+  static constexpr uint                         UIntNumPartitions = uint(ShenandoahFreeSetPartitionId::NotFree);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1502,0 +1502,3 @@\n+    if (ZeroTLAB) {\n+      t->retire_tlab();\n+    }\n@@ -1519,2 +1522,1 @@\n-    ThreadLocalAllocBuffer& tlab = t->tlab();\n-    tlab.retire(&stats);\n+    t->retire_tlab(&stats);\n@@ -1522,1 +1524,1 @@\n-      tlab.resize();\n+      t->tlab().resize();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    _jt->tlab().retire(&_stats);\n+    _jt->retire_tlab(&_stats);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStackWatermark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-  ZCollectedHeap::heap()->print_heap_before_gc();\n+  ZCollectedHeap::heap()->print_before_gc();\n@@ -719,1 +719,1 @@\n-  ZCollectedHeap::heap()->print_heap_after_gc();\n+  ZCollectedHeap::heap()->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    thread->tlab().retire(stats);\n+    thread->retire_tlab(stats);\n","filename":"src\/hotspot\/share\/gc\/z\/zThreadLocalAllocBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,0 +83,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.inline.hpp\"\n+#endif\n@@ -1303,0 +1306,1 @@\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -39,0 +38,1 @@\n+struct JavaVMOption;\n@@ -75,0 +75,2 @@\n+  static bool has_sample_request(JavaThread* jt);\n+  static void check_and_process_sample_request(JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_JFR_INLINE_HPP\n+#define SHARE_JFR_JFR_INLINE_HPP\n+\n+#include \"jfr\/jfr.hpp\"\n+\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+\n+inline bool Jfr::has_sample_request(JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return jt->jfr_thread_local()->has_sample_request();\n+}\n+\n+inline void Jfr::check_and_process_sample_request(JavaThread* jt) {\n+  if (has_sample_request(jt)) {\n+    JfrThreadSampling::process_sample_request(jt);\n+  }\n+}\n+\n+#endif \/\/ SHARE_JFR_JFR_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/jfr.inline.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -280,1 +280,1 @@\n-    JfrThreadSampling::set_java_sample_period(periodMillis);\n+    JfrThreadSampler::set_java_sample_period(periodMillis);\n@@ -282,1 +282,1 @@\n-    JfrThreadSampling::set_native_sample_period(periodMillis);\n+    JfrThreadSampler::set_native_sample_period(periodMillis);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,1 +337,2 @@\n-  writer.write(trace->_nr_of_frames);\n+  const int number_of_frames = trace->number_of_frames();\n+  writer.write<u4>(number_of_frames);\n@@ -339,2 +340,2 @@\n-  for (u4 i = 0; i < trace->_nr_of_frames; ++i) {\n-    const JfrStackFrame& frame = trace->_frames[i];\n+  for (int i = 0; i < number_of_frames; ++i) {\n+    const JfrStackFrame& frame = trace->_frames->at(i);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -713,0 +713,5 @@\n+  <Event name=\"SafepointLatency\" category=\"Java Virtual Machine, Runtime, Safepoint\" label=\"Safepoint Latency\"\n+    description=\"The delay for a thread to reach its next safepoint poll instruction after receiving an asynchronous sampling interrupt\" thread=\"true\" stackTrace=\"true\" throttle=\"true\">\n+    <Field type=\"VMThreadState\" name=\"threadState\" label=\"VM Thread State\" \/>\n+  <\/Event>\n+\n@@ -1298,0 +1303,4 @@\n+  <Type name=\"VMThreadState\" label=\"JVM Thread State\">\n+    <Field type=\"string\" name=\"state\" label=\"State\" \/>\n+  <\/Type>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"code\/debugInfoRec.hpp\"\n-#include \"code\/nmethod.hpp\"\n-#include \"code\/pcDesc.hpp\"\n-#include \"jfr\/periodic\/sampling\/jfrCallTrace.hpp\"\n-#include \"jfr\/utilities\/jfrTypes.hpp\"\n-#include \"oops\/method.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/javaThread.inline.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-\n-bool JfrGetCallTrace::find_top_frame(frame& top_frame, Method** method, frame& first_frame) {\n-  assert(top_frame.cb() != nullptr, \"invariant\");\n-  RegisterMap map(_thread,\n-                  RegisterMap::UpdateMap::skip,\n-                  RegisterMap::ProcessFrames::skip,\n-                  RegisterMap::WalkContinuation::skip);\n-  frame candidate = top_frame;\n-  for (u4 i = 0; i < MAX_STACK_DEPTH * 2; ++i) {\n-    if (candidate.is_entry_frame()) {\n-      JavaCallWrapper *jcw = candidate.entry_frame_call_wrapper_if_safe(_thread);\n-      if (jcw == nullptr || jcw->is_first_frame()) {\n-        return false;\n-      }\n-    }\n-\n-    if (candidate.is_interpreted_frame()) {\n-      JavaThreadState state = _thread->thread_state();\n-      const bool known_valid = (state == _thread_in_native || state == _thread_in_vm || state == _thread_blocked);\n-      if (known_valid || candidate.is_interpreted_frame_valid(_thread)) {\n-        Method* im = candidate.interpreter_frame_method();\n-        if (known_valid && !Method::is_valid_method(im)) {\n-          return false;\n-        }\n-        *method = im;\n-        first_frame = candidate;\n-        return true;\n-      }\n-    }\n-\n-    if (candidate.cb()->is_nmethod()) {\n-      \/\/ first check to make sure that we have a sane stack,\n-      \/\/ the PC is actually inside the code part of the codeBlob,\n-      \/\/ and we are past is_frame_complete_at (stack has been setup)\n-      if (!candidate.safe_for_sender(_thread)) {\n-        return false;\n-      }\n-      nmethod* nm = (nmethod*)candidate.cb();\n-      *method = nm->method();\n-\n-      if (_in_java) {\n-        PcDesc* pc_desc = nm->pc_desc_near(candidate.pc() + 1);\n-        if (pc_desc == nullptr || pc_desc->scope_decode_offset() == DebugInformationRecorder::serialized_null) {\n-          return false;\n-        }\n-        candidate.set_pc(pc_desc->real_pc(nm));\n-        assert(nm->pc_desc_at(candidate.pc()) != nullptr, \"invalid pc\");\n-      }\n-      first_frame = candidate;\n-      return true;\n-    }\n-\n-    if (!candidate.safe_for_sender(_thread) ||\n-      candidate.is_stub_frame() ||\n-      candidate.cb()->frame_size() <= 0) {\n-      return false;\n-    }\n-\n-    candidate = candidate.sender(&map);\n-    if (candidate.cb() == nullptr) {\n-      return false;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool JfrGetCallTrace::get_topframe(void* ucontext, frame& topframe) {\n-  if (!_thread->pd_get_top_frame_for_profiling(&topframe, ucontext, _in_java)) {\n-    return false;\n-  }\n-\n-  if (topframe.cb() == nullptr) {\n-    return false;\n-  }\n-\n-  frame first_java_frame;\n-  Method* method = nullptr;\n-  if (find_top_frame(topframe, &method, first_java_frame)) {\n-    if (method == nullptr) {\n-      return false;\n-    }\n-    topframe = first_java_frame;\n-    return true;\n-  }\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCallTrace.cpp","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_PERIODIC_SAMPLING_JFRCALLTRACE_HPP\n-#define SHARE_JFR_PERIODIC_SAMPLING_JFRCALLTRACE_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-\n-class frame;\n-class Method;\n-class JavaThread;\n-\n-class JfrGetCallTrace : public StackObj {\n- private:\n-  JavaThread* _thread;\n-  bool _in_java;\n-\n- public:\n-  JfrGetCallTrace(bool in_java, JavaThread* thread) : _thread(thread), _in_java(in_java) {}\n-  bool find_top_frame(frame& topframe, Method** method, frame& first_frame);\n-  bool get_topframe(void* ucontext, frame& top);\n-};\n-\n-#endif \/\/ SHARE_JFR_PERIODIC_SAMPLING_JFRCALLTRACE_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCallTrace.hpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"asm\/codeBuffer.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrSampleRequest.hpp\"\n+#include \"runtime\/continuationEntry.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+static inline bool is_entry_frame(address pc) {\n+  return StubRoutines::returns_to_call_stub(pc);\n+}\n+\n+static inline bool is_entry_frame(const JfrSampleRequest& request) {\n+  return is_entry_frame(static_cast<address>(request._sample_pc));\n+}\n+\n+static inline bool is_interpreter(address pc) {\n+  return Interpreter::contains(pc);\n+}\n+\n+static inline bool is_interpreter(const JfrSampleRequest& request) {\n+  return is_interpreter(static_cast<address>(request._sample_pc));\n+}\n+\n+static inline address interpreter_frame_bcp(const JfrSampleRequest& request) {\n+  assert(is_interpreter(request), \"invariant\");\n+  return frame::interpreter_bcp(static_cast<intptr_t*>(request._sample_bcp));\n+}\n+\n+static inline bool in_stack(intptr_t* ptr, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return jt->is_in_full_stack_checked(reinterpret_cast<address>(ptr));\n+}\n+\n+static inline bool sp_in_stack(const JfrSampleRequest& request, JavaThread* jt) {\n+  return in_stack(static_cast<intptr_t*>(request._sample_sp), jt);\n+}\n+\n+static inline bool fp_in_stack(const JfrSampleRequest& request, JavaThread* jt) {\n+  return in_stack(static_cast<intptr_t*>(request._sample_bcp), jt);\n+}\n+\n+static inline void update_interpreter_frame_sender_pc(JfrSampleRequest& request, intptr_t* fp) {\n+  request._sample_pc = frame::interpreter_return_address(fp);\n+}\n+\n+static inline void update_interpreter_frame_pc(JfrSampleRequest& request, JavaThread* jt) {\n+  assert(fp_in_stack(request, jt), \"invariant\");\n+  assert(is_interpreter(request), \"invariant\");\n+  request._sample_pc = frame::interpreter_return_address(static_cast<intptr_t*>(request._sample_bcp));\n+}\n+\n+static inline address interpreter_frame_return_address(const JfrSampleRequest& request) {\n+  assert(is_interpreter(request), \"invariant\");\n+  return frame::interpreter_return_address(static_cast<intptr_t*>(request._sample_bcp));\n+}\n+\n+static inline intptr_t* frame_sender_sp(const JfrSampleRequest& request, JavaThread* jt) {\n+  assert(fp_in_stack(request, jt), \"invariant\");\n+  return frame::sender_sp(static_cast<intptr_t*>(request._sample_bcp));\n+}\n+\n+static inline void update_frame_sender_sp(JfrSampleRequest& request, JavaThread* jt) {\n+  request._sample_sp = frame_sender_sp(request, jt);\n+}\n+\n+static inline void update_frame_sender_sp(JfrSampleRequest& request, intptr_t* fp) {\n+  request._sample_sp = frame::sender_sp(fp);\n+}\n+\n+static inline intptr_t* frame_link(const JfrSampleRequest& request) {\n+  return frame::link(static_cast<intptr_t*>(request._sample_bcp));\n+}\n+\n+static inline void update_sp(JfrSampleRequest& request, int frame_size) {\n+  assert(frame_size >= 0, \"invariant\");\n+  request._sample_sp = static_cast<intptr_t*>(request._sample_sp) + frame_size;\n+}\n+\n+static inline void update_pc(JfrSampleRequest& request) {\n+  assert(request._sample_sp != nullptr, \"invariant\");\n+  request._sample_pc = frame::return_address(static_cast<intptr_t*>(request._sample_sp));\n+}\n+\n+static inline void update_fp(JfrSampleRequest& request) {\n+  assert(request._sample_sp != nullptr, \"invariant\");\n+  request._sample_bcp = is_interpreter(request) ? frame::fp(static_cast<intptr_t*>(request._sample_sp)) : nullptr;\n+}\n+\n+\/\/ Less extensive sanity checks for an interpreter frame.\n+static bool is_valid_interpreter_frame(const JfrSampleRequest& request, JavaThread* jt) {\n+  assert(sp_in_stack(request, jt), \"invariant\");\n+  assert(fp_in_stack(request, jt), \"invariant\");\n+  return frame::is_interpreter_frame_setup_at(static_cast<intptr_t*>(request._sample_bcp), request._sample_sp);\n+}\n+\n+static inline bool is_continuation_frame(address pc) {\n+  return ContinuationEntry::return_pc() == pc;\n+}\n+\n+static inline bool is_continuation_frame(const JfrSampleRequest& request) {\n+  return is_continuation_frame(static_cast<address>(request._sample_pc));\n+}\n+\n+static intptr_t* sender_for_interpreter_frame(JfrSampleRequest& request, JavaThread* jt) {\n+  update_interpreter_frame_pc(request, jt); \/\/ pick up return address\n+  if (is_continuation_frame(request) || is_entry_frame(request)) {\n+    request._sample_pc = nullptr;\n+    return nullptr;\n+  }\n+  update_frame_sender_sp(request, jt);\n+  intptr_t* fp = nullptr;\n+  if (is_interpreter(request)) {\n+    fp = frame_link(request);\n+  }\n+  request._sample_bcp = nullptr;\n+  return fp;\n+}\n+\n+static bool build(JfrSampleRequest& request, intptr_t* fp, JavaThread* jt);\n+\n+static bool build_for_interpreter(JfrSampleRequest& request, JavaThread* jt) {\n+  assert(is_interpreter(request), \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  if (!fp_in_stack(request, jt)) {\n+    return false;\n+  }\n+  if (is_valid_interpreter_frame(request, jt)) {\n+    \/\/ Set fp as sp for interpreter frames.\n+    request._sample_sp = request._sample_bcp;\n+    \/\/ Get real bcp.\n+    void* const bcp = interpreter_frame_bcp(request);\n+    \/\/ Setting bcp = 1 marks the sample request to represent a native method.\n+    request._sample_bcp = bcp != nullptr ? bcp : reinterpret_cast<address>(1);\n+    return true;\n+  }\n+  intptr_t* fp = sender_for_interpreter_frame(request, jt);\n+  if (request._sample_pc == nullptr || request._sample_sp == nullptr) {\n+    return false;\n+  }\n+  return build(request, fp, jt);\n+}\n+\n+\/\/ Attempt to build a Jfr sample request.\n+static bool build(JfrSampleRequest& request, intptr_t* fp, JavaThread* jt) {\n+  assert(request._sample_sp != nullptr, \"invariant\");\n+  assert(request._sample_pc != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jt->thread_state() == _thread_in_Java, \"invariant\");\n+\n+  \/\/ 1. Interpreter frame?\n+  if (is_interpreter(request)) {\n+    request._sample_bcp = fp;\n+    return build_for_interpreter(request, jt);\n+  }\n+  const CodeBlob* const cb = CodeCache::find_blob(request._sample_pc);\n+  if (cb != nullptr) {\n+    \/\/ 2. Is nmethod?\n+    return cb->is_nmethod();\n+    \/\/ 3. What kind of CodeBlob or Stub?\n+    \/\/ Longer plan is to make stubs and blobs parsable,\n+    \/\/ and we will have a list of cases here for each blob type\n+    \/\/ describing how to locate the sender. We can't get to the\n+    \/\/ sender of a blob or stub until they have a standardized\n+    \/\/ layout and proper metadata descriptions.\n+  }\n+  return false;\n+}\n+\n+static bool build_from_ljf(JfrSampleRequest& request,\n+                           const JfrThreadLocal* tl,\n+                           JavaThread* jt) {\n+  assert(tl != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jt->jfr_thread_local() == tl, \"invariant\");\n+  assert(sp_in_stack(request, jt), \"invariant\");\n+  \/\/ Last Java frame is available, but might not be walkable, fix it.\n+  address last_pc = jt->last_Java_pc();\n+  if (last_pc == nullptr) {\n+    last_pc = frame::return_address(static_cast<intptr_t*>(request._sample_sp));\n+    if (last_pc == nullptr) {\n+      return false;\n+    }\n+  }\n+  assert(last_pc != nullptr, \"invariant\");\n+  if (is_interpreter(last_pc)) {\n+    if (tl->in_sampling_critical_section()) {\n+      return false;\n+    }\n+    request._sample_pc = last_pc;\n+    request._sample_bcp = jt->frame_anchor()->last_Java_fp();\n+    return build_for_interpreter(request, jt);\n+  }\n+  request._sample_pc = last_pc;\n+  return build(request, nullptr, jt);\n+}\n+\n+static bool build_from_context(JfrSampleRequest& request,\n+                               const void* ucontext,\n+                               const JfrThreadLocal* tl,\n+                               JavaThread* jt) {\n+  assert(ucontext != nullptr, \"invariant\");\n+  assert(tl != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jt->jfr_thread_local() == tl, \"invariant\");\n+  assert(!jt->has_last_Java_frame(), \"invariant\");\n+  intptr_t* fp;\n+  request._sample_pc = os::fetch_frame_from_context(ucontext, reinterpret_cast<intptr_t**>(&request._sample_sp), &fp);\n+  assert(sp_in_stack(request, jt), \"invariant\");\n+  if (is_interpreter(request)) {\n+    if (tl->in_sampling_critical_section() || !in_stack(fp, jt)) {\n+      return false;\n+    }\n+    if (frame::is_interpreter_frame_setup_at(fp, request._sample_sp)) {\n+      \/\/ Set fp as sp for interpreter frames.\n+      request._sample_sp = fp;\n+      void* bcp = os::fetch_bcp_from_context(ucontext);\n+      \/\/ Setting bcp = 1 marks the sample request to represent a native method.\n+      request._sample_bcp = bcp != nullptr ? bcp : reinterpret_cast<void*>(1);\n+      return true;\n+    }\n+    request._sample_bcp = fp;\n+    fp = sender_for_interpreter_frame(request, jt);\n+    if (request._sample_pc == nullptr || request._sample_sp == nullptr) {\n+      return false;\n+    }\n+  }\n+  return build(request, fp, jt);\n+}\n+\n+static inline JfrSampleResult set_request_and_arm_local_poll(JfrSampleRequest& request, JfrThreadLocal* tl, JavaThread* jt) {\n+  assert(tl != nullptr, \"invariant\");\n+  assert(jt->jfr_thread_local() == tl, \"invariant\");\n+  tl->set_sample_state(JAVA_SAMPLE);\n+  SafepointMechanism::arm_local_poll_release(jt);\n+  \/\/ For a Java sample, request._sample_ticks is also the start time for the SafepointLatency event.\n+  request._sample_ticks = JfrTicks::now();\n+  tl->set_sample_request(request);\n+  return SAMPLE_JAVA;\n+}\n+\n+\/\/ A biased sample request is denoted by an empty bcp and an empty pc.\n+static inline JfrSampleResult set_biased_java_sample(JfrSampleRequest& request, JfrThreadLocal* tl, JavaThread* jt) {\n+  if (request._sample_bcp != nullptr) {\n+    request._sample_bcp = nullptr;\n+  }\n+  assert(request._sample_bcp == nullptr, \"invariant\");\n+  request._sample_pc = nullptr;\n+  return set_request_and_arm_local_poll(request, tl, jt);\n+}\n+\n+static inline JfrSampleResult set_unbiased_java_sample(JfrSampleRequest& request, JfrThreadLocal* tl, JavaThread* jt) {\n+  assert(request._sample_sp != nullptr, \"invariant\");\n+  assert(sp_in_stack(request, jt), \"invariant\");\n+  assert(request._sample_bcp != nullptr || !is_interpreter(request), \"invariant\");\n+  return set_request_and_arm_local_poll(request, tl, jt);\n+}\n+\n+JfrSampleResult JfrSampleRequestBuilder::build_java_sample_request(const void* ucontext,\n+                                                                   JfrThreadLocal* tl,\n+                                                                   JavaThread* jt) {\n+  assert(ucontext != nullptr, \"invariant\");\n+  assert(tl != nullptr, \"invariant\");\n+  assert(tl->sample_state() == NO_SAMPLE, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jt->thread_state() == _thread_in_Java, \"invariant\");\n+\n+  JfrSampleRequest request;\n+\n+  \/\/ Prioritize the ljf, if one exists.\n+  request._sample_sp = jt->last_Java_sp();\n+  if (request._sample_sp != nullptr) {\n+    if (build_from_ljf(request, tl, jt)) {\n+      return set_unbiased_java_sample(request, tl, jt);\n+    }\n+  } else if (build_from_context(request, ucontext, tl, jt)) {\n+    return set_unbiased_java_sample(request, tl, jt);\n+  }\n+  return set_biased_java_sample(request, tl, jt);\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrSampleRequest.cpp","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_SAMPLING_JFRSAMPLEREQUEST_HPP\n+#define SHARE_JFR_PERIODIC_SAMPLING_JFRSAMPLEREQUEST_HPP\n+\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class JavaThread;\n+class JfrThreadLocal;\n+\n+enum JfrSampleResult {\n+  THREAD_SUSPENSION_ERROR,\n+  WRONG_THREAD_STATE,\n+  UNPARSABLE_TOP_FRAME,\n+  INVALID_STACK_TRACE,\n+  CRASH,\n+  NO_LAST_JAVA_FRAME,\n+  UNKNOWN,\n+  FAIL,\n+  SKIP,\n+  SAMPLE_NATIVE,\n+  SAMPLE_JAVA,\n+  NOF_SAMPLING_RESULTS\n+};\n+\n+enum JfrSampleRequestType {\n+  NO_SAMPLE = 0,\n+  NATIVE_SAMPLE = 1,\n+  JAVA_SAMPLE = 2,\n+  NOF_SAMPLE_TYPES\n+};\n+\n+struct JfrSampleRequest {\n+  void* _sample_sp;\n+  void* _sample_pc;\n+  void* _sample_bcp;\n+  JfrTicks _sample_ticks;\n+\n+  JfrSampleRequest() :\n+    _sample_sp(nullptr),\n+    _sample_pc(nullptr),\n+    _sample_bcp(nullptr),\n+    _sample_ticks() {}\n+\n+  JfrSampleRequest(const JfrTicks& ticks) :\n+    _sample_sp(nullptr),\n+    _sample_pc(nullptr),\n+    _sample_bcp(nullptr),\n+    _sample_ticks(ticks) {}\n+};\n+\n+typedef GrowableArrayCHeap<JfrSampleRequest, mtTracing> JfrSampleRequestQueue;\n+\n+class JfrSampleRequestBuilder : AllStatic {\n+ public:\n+  static JfrSampleResult build_java_sample_request(const void* ucontext,\n+                                                   JfrThreadLocal* tl,\n+                                                   JavaThread* jt);\n+};\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_SAMPLING_JFRSAMPLEREQUEST_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrSampleRequest.hpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -25,6 +25,1 @@\n-#include \"classfile\/javaThreadStatus.hpp\"\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n-#include \"jfr\/periodic\/sampling\/jfrCallTrace.hpp\"\n-#include \"jfr\/periodic\/sampling\/jfrThreadSampler.hpp\"\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n+#include \"jfr\/metadata\/jfrSerializer.hpp\"\n@@ -32,3 +27,3 @@\n-#include \"jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp\"\n-#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n-#include \"jfr\/support\/jfrThreadLocal.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrSampleRequest.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampler.hpp\"\n@@ -36,1 +31,2 @@\n-#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"jfr\/utilities\/jfrTryLock.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n@@ -39,1 +35,0 @@\n-#include \"runtime\/frame.inline.hpp\"\n@@ -42,0 +37,2 @@\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n@@ -43,0 +40,1 @@\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n@@ -44,1 +42,0 @@\n-#include \"runtime\/stackWatermark.hpp\"\n@@ -46,2 +43,1 @@\n-#include \"runtime\/threadCrashProtection.hpp\"\n-#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -50,289 +46,8 @@\n-enum JfrSampleType {\n-  NO_SAMPLE = 0,\n-  JAVA_SAMPLE = 1,\n-  NATIVE_SAMPLE = 2\n-};\n-\n-static bool thread_state_in_java(JavaThread* thread) {\n-  assert(thread != nullptr, \"invariant\");\n-  switch(thread->thread_state()) {\n-    case _thread_new:\n-    case _thread_uninitialized:\n-    case _thread_new_trans:\n-    case _thread_in_vm_trans:\n-    case _thread_blocked_trans:\n-    case _thread_in_native_trans:\n-    case _thread_blocked:\n-    case _thread_in_vm:\n-    case _thread_in_native:\n-    case _thread_in_Java_trans:\n-      break;\n-    case _thread_in_Java:\n-      return true;\n-    default:\n-      ShouldNotReachHere();\n-      break;\n-  }\n-  return false;\n-}\n-\n-static bool thread_state_in_native(JavaThread* thread) {\n-  assert(thread != nullptr, \"invariant\");\n-  switch(thread->thread_state()) {\n-    case _thread_new:\n-    case _thread_uninitialized:\n-    case _thread_new_trans:\n-    case _thread_blocked_trans:\n-    case _thread_blocked:\n-    case _thread_in_vm:\n-    case _thread_in_vm_trans:\n-    case _thread_in_Java_trans:\n-    case _thread_in_Java:\n-    case _thread_in_native_trans:\n-      break;\n-    case _thread_in_native:\n-      return true;\n-    default:\n-      ShouldNotReachHere();\n-      break;\n-  }\n-  return false;\n-}\n-\n-class JfrThreadSampleClosure {\n- public:\n-  JfrThreadSampleClosure(EventExecutionSample* events, EventNativeMethodSample* events_native);\n-  ~JfrThreadSampleClosure() {}\n-  EventExecutionSample* next_event() { return &_events[_added_java++]; }\n-  EventNativeMethodSample* next_event_native() { return &_events_native[_added_native++]; }\n-  void commit_events(JfrSampleType type);\n-  bool do_sample_thread(JavaThread* thread, JfrStackFrame* frames, u4 max_frames, JfrSampleType type);\n-  uint java_entries() { return _added_java; }\n-  uint native_entries() { return _added_native; }\n-\n- private:\n-  bool sample_thread_in_java(JavaThread* thread, JfrStackFrame* frames, u4 max_frames);\n-  bool sample_thread_in_native(JavaThread* thread, JfrStackFrame* frames, u4 max_frames);\n-  EventExecutionSample* _events;\n-  EventNativeMethodSample* _events_native;\n-  Thread* _self;\n-  uint _added_java;\n-  uint _added_native;\n-};\n-\n-class OSThreadSampler : public SuspendedThreadTask {\n- public:\n-  OSThreadSampler(JavaThread* thread,\n-                  JfrThreadSampleClosure& closure,\n-                  JfrStackFrame *frames,\n-                  u4 max_frames) : SuspendedThreadTask((Thread*)thread),\n-    _success(false),\n-    _thread_oop(thread->threadObj()),\n-    _stacktrace(frames, max_frames),\n-    _closure(closure),\n-    _suspend_time() {}\n-\n-  void take_sample();\n-  void do_task(const SuspendedThreadTaskContext& context);\n-  void protected_task(const SuspendedThreadTaskContext& context);\n-  bool success() const { return _success; }\n-  const JfrStackTrace& stacktrace() const { return _stacktrace; }\n-\n- private:\n-  bool _success;\n-  oop _thread_oop;\n-  JfrStackTrace _stacktrace;\n-  JfrThreadSampleClosure& _closure;\n-  JfrTicks _suspend_time;\n-};\n-\n-class OSThreadSamplerCallback : public CrashProtectionCallback {\n- public:\n-  OSThreadSamplerCallback(OSThreadSampler& sampler, const SuspendedThreadTaskContext &context) :\n-    _sampler(sampler), _context(context) {\n-  }\n-  virtual void call() {\n-    _sampler.protected_task(_context);\n-  }\n- private:\n-  OSThreadSampler& _sampler;\n-  const SuspendedThreadTaskContext& _context;\n-};\n-\n-void OSThreadSampler::do_task(const SuspendedThreadTaskContext& context) {\n-#ifndef ASSERT\n-  guarantee(JfrOptionSet::sample_protection(), \"Sample Protection should be on in product builds\");\n-#endif\n-  assert(_suspend_time.value() == 0, \"already timestamped!\");\n-  _suspend_time = JfrTicks::now();\n-\n-  if (JfrOptionSet::sample_protection()) {\n-    OSThreadSamplerCallback cb(*this, context);\n-    ThreadCrashProtection crash_protection;\n-    if (!crash_protection.call(cb)) {\n-      log_error(jfr)(\"Thread method sampler crashed\");\n-    }\n-  } else {\n-    protected_task(context);\n-  }\n-}\n-\n-\/*\n-* From this method and down the call tree we attempt to protect against crashes\n-* using a signal handler \/ __try block. Don't take locks, rely on destructors or\n-* leave memory (in case of signal \/ exception) in an inconsistent state. *\/\n-void OSThreadSampler::protected_task(const SuspendedThreadTaskContext& context) {\n-  JavaThread* const jt = JavaThread::cast(context.thread());\n-  \/\/ Skip sample if we signaled a thread that moved to other state\n-  if (!thread_state_in_java(jt)) {\n-    return;\n-  }\n-  JfrGetCallTrace trace(true, jt);\n-  frame topframe;\n-  if (trace.get_topframe(context.ucontext(), topframe)) {\n-    if (_stacktrace.record_async(jt, topframe)) {\n-      \/* If we managed to get a topframe and a stacktrace, create an event\n-      * and put it into our array. We can't call Jfr::_stacktraces.add()\n-      * here since it would allocate memory using malloc. Doing so while\n-      * the stopped thread is inside malloc would deadlock. *\/\n-      _success = true;\n-      EventExecutionSample *ev = _closure.next_event();\n-      ev->set_starttime(_suspend_time);\n-      ev->set_endtime(_suspend_time); \/\/ fake to not take an end time\n-      ev->set_sampledThread(JfrThreadLocal::thread_id(jt));\n-      ev->set_state(static_cast<u8>(JavaThreadStatus::RUNNABLE));\n-    }\n-  }\n-}\n-\n-void OSThreadSampler::take_sample() {\n-  run();\n-}\n-\n-class JfrNativeSamplerCallback : public CrashProtectionCallback {\n- public:\n-  JfrNativeSamplerCallback(JfrThreadSampleClosure& closure, JavaThread* jt, JfrStackFrame* frames, u4 max_frames) :\n-    _closure(closure), _jt(jt), _thread_oop(jt->threadObj()), _stacktrace(frames, max_frames), _success(false) {\n-  }\n-  virtual void call();\n-  bool success() { return _success; }\n-  JfrStackTrace& stacktrace() { return _stacktrace; }\n-\n- private:\n-  JfrThreadSampleClosure& _closure;\n-  JavaThread* _jt;\n-  oop _thread_oop;\n-  JfrStackTrace _stacktrace;\n-  bool _success;\n-};\n-\n-static void write_native_event(JfrThreadSampleClosure& closure, JavaThread* jt, oop thread_oop) {\n-  EventNativeMethodSample *ev = closure.next_event_native();\n-  ev->set_starttime(JfrTicks::now());\n-  ev->set_sampledThread(JfrThreadLocal::thread_id(jt));\n-  ev->set_state(static_cast<u8>(JavaThreadStatus::RUNNABLE));\n-}\n-\n-void JfrNativeSamplerCallback::call() {\n-  \/\/ When a thread is only attach it will be native without a last java frame\n-  if (!_jt->has_last_Java_frame()) {\n-    return;\n-  }\n-\n-  frame topframe = _jt->last_frame();\n-  frame first_java_frame;\n-  Method* method = nullptr;\n-  JfrGetCallTrace gct(false, _jt);\n-  if (!gct.find_top_frame(topframe, &method, first_java_frame)) {\n-    return;\n-  }\n-  if (method == nullptr) {\n-    return;\n-  }\n-  topframe = first_java_frame;\n-  _success = _stacktrace.record_async(_jt, topframe);\n-  if (_success) {\n-    write_native_event(_closure, _jt, _thread_oop);\n-  }\n-}\n-\n-bool JfrThreadSampleClosure::sample_thread_in_java(JavaThread* thread, JfrStackFrame* frames, u4 max_frames) {\n-  \/\/ Process the oops in the thread head before calling into code that wants to\n-  \/\/ stack walk over Loom continuations. The stack walking code will otherwise\n-  \/\/ skip frames in stack chunks on the Java heap.\n-  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n-\n-  OSThreadSampler sampler(thread, *this, frames, max_frames);\n-  sampler.take_sample();\n-  \/* We don't want to allocate any memory using malloc\/etc while the thread\n-  * is stopped, so everything is stored in stack allocated memory until this\n-  * point where the thread has been resumed again, if the sampling was a success\n-  * we need to store the stacktrace in the stacktrace repository and update\n-  * the event with the id that was returned. *\/\n-  if (!sampler.success()) {\n-    return false;\n-  }\n-  EventExecutionSample *event = &_events[_added_java - 1];\n-  traceid id = JfrStackTraceRepository::add(sampler.stacktrace());\n-  assert(id != 0, \"Stacktrace id should not be 0\");\n-  event->set_stackTrace(id);\n-  return true;\n-}\n-\n-bool JfrThreadSampleClosure::sample_thread_in_native(JavaThread* thread, JfrStackFrame* frames, u4 max_frames) {\n-  \/\/ Process the oops in the thread head before calling into code that wants to\n-  \/\/ stack walk over Loom continuations. The stack walking code will otherwise\n-  \/\/ skip frames in stack chunks on the Java heap.\n-  StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n-\n-  JfrNativeSamplerCallback cb(*this, thread, frames, max_frames);\n-  if (JfrOptionSet::sample_protection()) {\n-    ThreadCrashProtection crash_protection;\n-    if (!crash_protection.call(cb)) {\n-      log_error(jfr)(\"Thread method sampler crashed for native\");\n-    }\n-  } else {\n-    cb.call();\n-  }\n-  if (!cb.success()) {\n-    return false;\n-  }\n-  EventNativeMethodSample *event = &_events_native[_added_native - 1];\n-  traceid id = JfrStackTraceRepository::add(cb.stacktrace());\n-  assert(id != 0, \"Stacktrace id should not be 0\");\n-  event->set_stackTrace(id);\n-  return true;\n-}\n-\n-static const uint MAX_NR_OF_JAVA_SAMPLES = 5;\n-static const uint MAX_NR_OF_NATIVE_SAMPLES = 1;\n-\n-void JfrThreadSampleClosure::commit_events(JfrSampleType type) {\n-  if (JAVA_SAMPLE == type) {\n-    assert(_added_java > 0 && _added_java <= MAX_NR_OF_JAVA_SAMPLES, \"invariant\");\n-    if (EventExecutionSample::is_enabled()) {\n-      for (uint i = 0; i < _added_java; ++i) {\n-        _events[i].commit();\n-      }\n-    }\n-  } else {\n-    assert(NATIVE_SAMPLE == type, \"invariant\");\n-    assert(_added_native > 0 && _added_native <= MAX_NR_OF_NATIVE_SAMPLES, \"invariant\");\n-    if (EventNativeMethodSample::is_enabled()) {\n-      for (uint i = 0; i < _added_native; ++i) {\n-        _events_native[i].commit();\n-      }\n-    }\n-  }\n-}\n-\n-JfrThreadSampleClosure::JfrThreadSampleClosure(EventExecutionSample* events, EventNativeMethodSample* events_native) :\n-  _events(events),\n-  _events_native(events_native),\n-  _self(Thread::current()),\n-  _added_java(0),\n-  _added_native(0) {\n-}\n-\n-class JfrThreadSampler : public NonJavaThread {\n-  friend class JfrThreadSampling;\n+\/\/ The JfrSamplerThread suspends, if necessary, JavaThreads for sampling.\n+\/\/ It creates a sample description of the top Java frame, called a Jfr Sample Request.\n+\/\/ The request is installed into a thread-local queue associated with the sampled thread.\n+\/\/ Before resuming the sampled thread, its thread-local poll page is armed.\n+\/\/ This mechanism lets the sampled thread discover and process the installed\n+\/\/ sample request at its next safepoint poll instruction.\n+class JfrSamplerThread : public NonJavaThread {\n+  friend class JfrThreadSampler;\n@@ -341,2 +56,0 @@\n-  Thread* _sampler_thread;\n-  JfrStackFrame* const _frames;\n@@ -347,1 +60,0 @@\n-  const size_t _min_size; \/\/ for enqueue buffer monitoring\n@@ -352,3 +64,0 @@\n-  const JfrBuffer* get_enqueue_buffer();\n-  const JfrBuffer* renew_if_full(const JfrBuffer* enqueue_buffer);\n-\n@@ -356,3 +65,2 @@\n-  void task_stacktrace(JfrSampleType type, JavaThread** last_thread);\n-  JfrThreadSampler(int64_t java_period_millis, int64_t native_period_millis, u4 max_frames);\n-  ~JfrThreadSampler();\n+  void task_stacktrace(JfrSampleRequestType type, JavaThread** last_thread);\n+  JfrSamplerThread(int64_t java_period_millis, int64_t native_period_millis, u4 max_frames);\n@@ -366,0 +74,3 @@\n+  bool sample_java_thread(JavaThread* jt);\n+  bool sample_native_thread(JavaThread* jt);\n+\n@@ -367,0 +78,1 @@\n+  void run();\n@@ -368,0 +80,1 @@\n+\n@@ -369,2 +82,2 @@\n-  virtual const char* name() const { return \"JFR Thread Sampler\"; }\n-  virtual const char* type_name() const { return \"JfrThreadSampler\"; }\n+  virtual const char* name() const { return \"JFR Sampler Thread\"; }\n+  virtual const char* type_name() const { return \"JfrSamplerThread\"; }\n@@ -372,5 +85,2 @@\n-  void run();\n-  static Monitor* transition_block() { return JfrThreadSampler_lock; }\n-  static void on_javathread_suspend(JavaThread* thread);\n-  int64_t get_java_period() const { return Atomic::load(&_java_period_millis); };\n-  int64_t get_native_period() const { return Atomic::load(&_native_period_millis); };\n+  int64_t java_period() const { return Atomic::load(&_java_period_millis); };\n+  int64_t native_period() const { return Atomic::load(&_native_period_millis); };\n@@ -379,41 +89,1 @@\n-static void clear_transition_block(JavaThread* jt) {\n-  assert(Threads_lock->owned_by_self(), \"Holding the thread table lock.\");\n-  jt->clear_trace_flag();\n-  JfrThreadLocal* const tl = jt->jfr_thread_local();\n-  MutexLocker ml(JfrThreadSampler::transition_block(), Mutex::_no_safepoint_check_flag);\n-  if (tl->is_trace_block()) {\n-    JfrThreadSampler::transition_block()->notify();\n-  }\n-}\n-\n-static bool is_excluded(JavaThread* thread) {\n-  assert(thread != nullptr, \"invariant\");\n-  return thread->is_hidden_from_external_view() || thread->in_deopt_handler() || thread->jfr_thread_local()->is_excluded();\n-}\n-\n-bool JfrThreadSampleClosure::do_sample_thread(JavaThread* thread, JfrStackFrame* frames, u4 max_frames, JfrSampleType type) {\n-  assert(Threads_lock->owned_by_self(), \"Holding the thread table lock.\");\n-  if (is_excluded(thread)) {\n-    return false;\n-  }\n-\n-  bool ret = false;\n-  thread->set_trace_flag();  \/\/ Provides StoreLoad, needed to keep read of thread state from floating up.\n-  if (UseSystemMemoryBarrier) {\n-    SystemMemoryBarrier::emit();\n-  }\n-  if (JAVA_SAMPLE == type) {\n-    if (thread_state_in_java(thread)) {\n-      ret = sample_thread_in_java(thread, frames, max_frames);\n-    }\n-  } else {\n-    assert(NATIVE_SAMPLE == type, \"invariant\");\n-    if (thread_state_in_native(thread)) {\n-      ret = sample_thread_in_native(thread, frames, max_frames);\n-    }\n-  }\n-  clear_transition_block(thread);\n-  return ret;\n-}\n-\n-JfrThreadSampler::JfrThreadSampler(int64_t java_period_millis, int64_t native_period_millis, u4 max_frames) :\n+JfrSamplerThread::JfrSamplerThread(int64_t java_period_millis, int64_t native_period_millis, u4 max_frames) :\n@@ -421,2 +91,0 @@\n-  _sampler_thread(nullptr),\n-  _frames(JfrCHeapObj::new_array<JfrStackFrame>(max_frames)),\n@@ -427,1 +95,0 @@\n-  _min_size(max_frames * 2 * wordSize), \/\/ each frame tags at most 2 words, min size is a full stacktrace\n@@ -435,45 +102,3 @@\n-JfrThreadSampler::~JfrThreadSampler() {\n-  JfrCHeapObj::free(_frames, sizeof(JfrStackFrame) * _max_frames);\n-}\n-\n-void JfrThreadSampler::set_java_period(int64_t period_millis) {\n-  assert(period_millis >= 0, \"invariant\");\n-  Atomic::store(&_java_period_millis, period_millis);\n-}\n-\n-void JfrThreadSampler::set_native_period(int64_t period_millis) {\n-  assert(period_millis >= 0, \"invariant\");\n-  Atomic::store(&_native_period_millis, period_millis);\n-}\n-\n-static inline bool is_released(JavaThread* jt) {\n-  return !jt->is_trace_suspend();\n-}\n-\n-void JfrThreadSampler::on_javathread_suspend(JavaThread* thread) {\n-  if (is_released(thread)) {\n-    return;\n-  }\n-  JfrThreadLocal* const tl = thread->jfr_thread_local();\n-  MonitorLocker ml(transition_block(), Mutex::_no_safepoint_check_flag);\n-  tl->set_trace_block();\n-  while (!is_released(thread)) {\n-    ml.wait();\n-  }\n-  tl->clear_trace_block();\n-}\n-\n-JavaThread* JfrThreadSampler::next_thread(ThreadsList* t_list, JavaThread* first_sampled, JavaThread* current) {\n-  assert(t_list != nullptr, \"invariant\");\n-  assert(Threads_lock->owned_by_self(), \"Holding the thread table lock.\");\n-  assert(_cur_index >= -1 && (uint)_cur_index + 1 <= t_list->length(), \"invariant\");\n-  assert((current == nullptr && -1 == _cur_index) || (t_list->find_index_of_JavaThread(current) == _cur_index), \"invariant\");\n-  if ((uint)_cur_index + 1 == t_list->length()) {\n-    \/\/ wrap\n-    _cur_index = 0;\n-  } else {\n-    _cur_index++;\n-  }\n-  assert(_cur_index >= 0 && (uint)_cur_index < t_list->length(), \"invariant\");\n-  JavaThread* const next = t_list->thread_at(_cur_index);\n-  return next != first_sampled ? next : nullptr;\n+void JfrSamplerThread::post_run() {\n+  this->NonJavaThread::post_run();\n+  delete this;\n@@ -482,1 +107,1 @@\n-void JfrThreadSampler::start_thread() {\n+void JfrSamplerThread::start_thread() {\n@@ -490,1 +115,1 @@\n-void JfrThreadSampler::enroll() {\n+void JfrSamplerThread::enroll() {\n@@ -498,1 +123,1 @@\n-void JfrThreadSampler::disenroll() {\n+void JfrSamplerThread::disenroll() {\n@@ -506,1 +131,12 @@\n-static int64_t get_monotonic_ms() {\n+\/\/ Currently we only need to serialize a single thread state\n+\/\/ _thread_in_Java for the SafepointLatency event.\n+class VMThreadStateSerializer : public JfrSerializer {\n+ public:\n+  void serialize(JfrCheckpointWriter& writer) {\n+    writer.write_count(1);\n+    writer.write_key(_thread_in_Java);\n+    writer.write(\"_thread_in_Java\");\n+  }\n+};\n+\n+static inline int64_t get_monotonic_ms() {\n@@ -510,4 +146,2 @@\n-void JfrThreadSampler::run() {\n-  assert(_sampler_thread == nullptr, \"invariant\");\n-\n-  _sampler_thread = this;\n+void JfrSamplerThread::run() {\n+  JfrSerializer::register_serializer(TYPE_VMTHREADSTATE, true, new VMThreadStateSerializer());\n@@ -526,1 +160,1 @@\n-    int64_t java_period_millis = get_java_period();\n+    int64_t java_period_millis = java_period();\n@@ -528,1 +162,1 @@\n-    int64_t native_period_millis = get_native_period();\n+    int64_t native_period_millis = native_period();\n@@ -570,8 +204,13 @@\n-void JfrThreadSampler::post_run() {\n-  this->NonJavaThread::post_run();\n-  delete this;\n-}\n-\n-const JfrBuffer* JfrThreadSampler::get_enqueue_buffer() {\n-  const JfrBuffer* buffer = JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(this);\n-  return buffer != nullptr ? renew_if_full(buffer) : JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this);\n+JavaThread* JfrSamplerThread::next_thread(ThreadsList* t_list, JavaThread* first_sampled, JavaThread* current) {\n+  assert(t_list != nullptr, \"invariant\");\n+  assert(_cur_index >= -1 && (uint)_cur_index + 1 <= t_list->length(), \"invariant\");\n+  assert((current == nullptr && -1 == _cur_index) || (t_list->find_index_of_JavaThread(current) == _cur_index), \"invariant\");\n+  if ((uint)_cur_index + 1 == t_list->length()) {\n+    \/\/ wrap\n+    _cur_index = 0;\n+  } else {\n+    _cur_index++;\n+  }\n+  assert(_cur_index >= 0 && (uint)_cur_index < t_list->length(), \"invariant\");\n+  JavaThread* const next = t_list->thread_at(_cur_index);\n+  return next != first_sampled ? next : nullptr;\n@@ -580,3 +219,3 @@\n-const JfrBuffer* JfrThreadSampler::renew_if_full(const JfrBuffer* enqueue_buffer) {\n-  assert(enqueue_buffer != nullptr, \"invariant\");\n-  return enqueue_buffer->free_size() < _min_size ? JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this) : enqueue_buffer;\n+static inline bool is_excluded(JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return jt->is_Compiler_thread() || jt->is_hidden_from_external_view() || jt->is_JfrRecorder_thread() || jt->jfr_thread_local()->is_excluded();\n@@ -585,7 +224,2 @@\n-void JfrThreadSampler::task_stacktrace(JfrSampleType type, JavaThread** last_thread) {\n-  ResourceMark rm;\n-  EventExecutionSample samples[MAX_NR_OF_JAVA_SAMPLES];\n-  EventNativeMethodSample samples_native[MAX_NR_OF_NATIVE_SAMPLES];\n-  JfrThreadSampleClosure sample_task(samples, samples_native);\n-\n-  const uint sample_limit = JAVA_SAMPLE == type ? MAX_NR_OF_JAVA_SAMPLES : MAX_NR_OF_NATIVE_SAMPLES;\n+void JfrSamplerThread::task_stacktrace(JfrSampleRequestType type, JavaThread** last_thread) {\n+  const uint sample_limit = JAVA_SAMPLE == type ? 5 : 1;\n@@ -594,0 +228,2 @@\n+  elapsedTimer sample_time;\n+  sample_time.start();\n@@ -595,35 +231,28 @@\n-    elapsedTimer sample_time;\n-    sample_time.start();\n-    {\n-      MutexLocker tlock(Threads_lock);\n-      ThreadsListHandle tlh;\n-      \/\/ Resolve a sample session relative start position index into the thread list array.\n-      \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n-      _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n-      JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n-\n-      \/\/ Explicitly monitor the available space of the thread-local buffer used by the load barrier\n-      \/\/ for enqueuing klasses as part of tagging methods. We do this because if space becomes sparse,\n-      \/\/ we cannot rely on the implicit allocation of a new buffer as part of the regular tag mechanism.\n-      \/\/ If the free list is empty, a malloc could result, and the problem with that is that the thread\n-      \/\/ we have suspended could be the holder of the malloc lock. Instead, the buffer is pre-emptively\n-      \/\/ renewed before thread suspension.\n-      const JfrBuffer* enqueue_buffer = get_enqueue_buffer();\n-      assert(enqueue_buffer != nullptr, \"invariant\");\n-\n-      while (num_samples < sample_limit) {\n-        current = next_thread(tlh.list(), start, current);\n-        if (current == nullptr) {\n-          break;\n-        }\n-        if (start == nullptr) {\n-          start = current;  \/\/ remember the thread where we started to attempt sampling\n-        }\n-        if (current->is_Compiler_thread()) {\n-          continue;\n-        }\n-        assert(enqueue_buffer->free_size() >= _min_size, \"invariant\");\n-        if (sample_task.do_sample_thread(current, _frames, _max_frames, type)) {\n-          num_samples++;\n-        }\n-        enqueue_buffer = renew_if_full(enqueue_buffer);\n+    MutexLocker tlock(Threads_lock);\n+    ThreadsListHandle tlh;\n+    \/\/ Resolve a sample session relative start position index into the thread list array.\n+    \/\/ In cases where the last sampled thread is null or not-null but stale, find_index() returns -1.\n+    _cur_index = tlh.list()->find_index_of_JavaThread(*last_thread);\n+    JavaThread* current = _cur_index != -1 ? *last_thread : nullptr;\n+\n+    \/\/ while (num_samples < sample_limit) {\n+    while (true) {\n+      current = next_thread(tlh.list(), start, current);\n+      if (current == nullptr) {\n+        break;\n+      }\n+      if (is_excluded(current)) {\n+        continue;\n+      }\n+      if (start == nullptr) {\n+        start = current; \/\/ remember the thread where we started to attempt sampling\n+      }\n+      bool success;\n+      if (JAVA_SAMPLE == type) {\n+        success = sample_java_thread(current);\n+      } else {\n+        assert(type == NATIVE_SAMPLE, \"invariant\");\n+        success = sample_native_thread(current);\n+      }\n+      if (success) {\n+        num_samples++;\n@@ -631,1 +260,0 @@\n-      *last_thread = current;  \/\/ remember the thread we last attempted to sample\n@@ -633,3 +261,1 @@\n-    sample_time.stop();\n-    log_trace(jfr)(\"JFR thread sampling done in %3.7f secs with %d java %d native samples\",\n-                   sample_time.seconds(), sample_task.java_entries(), sample_task.native_entries());\n+    *last_thread = current; \/\/ remember the thread we last attempted to sample\n@@ -637,2 +263,88 @@\n-  if (num_samples > 0) {\n-    sample_task.commit_events(type);\n+  sample_time.stop();\n+  log_trace(jfr)(\"JFR thread sampling done in %3.7f secs with %d java %d native samples\",\n+    sample_time.seconds(), type == JAVA_SAMPLE ? num_samples : 0, type == NATIVE_SAMPLE ? num_samples : 0);\n+}\n+\n+\/\/ Platform-specific thread suspension and CPU context retrieval.\n+class OSThreadSampler : public SuspendedThreadTask {\n+ private:\n+  JfrSampleResult _result;\n+ public:\n+  OSThreadSampler(JavaThread* jt) : SuspendedThreadTask(jt),\n+                                    _result(THREAD_SUSPENSION_ERROR) {}\n+  void request_sample() { run(); }\n+  JfrSampleResult result() const { return _result; }\n+\n+  void do_task(const SuspendedThreadTaskContext& context) {\n+    JavaThread* const jt = JavaThread::cast(context.thread());\n+    assert(jt != nullptr, \"invariant\");\n+    if (jt->thread_state() == _thread_in_Java) {\n+      JfrThreadLocal* const tl = jt->jfr_thread_local();\n+      if (tl->sample_state() == NO_SAMPLE) {\n+        _result = JfrSampleRequestBuilder::build_java_sample_request(context.ucontext(), tl, jt);\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Sampling a thread in state _thread_in_Java\n+\/\/ involves a platform-specific thread suspend and CPU context retrieval.\n+bool JfrSamplerThread::sample_java_thread(JavaThread* jt) {\n+  if (jt->thread_state() != _thread_in_Java) {\n+    return false;\n+  }\n+\n+  OSThreadSampler sampler(jt);\n+  sampler.request_sample();\n+\n+  if (sampler.result() != SAMPLE_JAVA) {\n+    \/\/ Wrong thread state or suspension error.\n+    return false;\n+  }\n+\n+  \/\/ If we get to do it before the sampled thread, we install\n+  \/\/ the new Jfr Sample Request into the thread-local queue\n+  \/\/ associated with the sampled thread. This makes the just\n+  \/\/ sampled thread eligible for yet another sample.\n+  JfrThreadLocal* const tl = jt->jfr_thread_local();\n+  JfrMutexTryLock lock(tl->sample_monitor());\n+  if (lock.acquired() && tl->sample_state() == JAVA_SAMPLE) {\n+    tl->enqueue_request();\n+    assert(tl->sample_state() == NO_SAMPLE, \"invariant\");\n+  }\n+  return true;\n+}\n+\n+static JfrSamplerThread* _sampler_thread = nullptr;\n+\n+\/\/ We can sample a JavaThread running in state _thread_in_native\n+\/\/ without thread suspension and CPU context retrieval,\n+\/\/ if we carefully order the loads of the thread state.\n+bool JfrSamplerThread::sample_native_thread(JavaThread* jt) {\n+  if (jt->thread_state() != _thread_in_native) {\n+    return false;\n+  }\n+\n+  JfrThreadLocal* const tl = jt->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+\n+  if (tl->sample_state() != NO_SAMPLE) {\n+    return false;\n+  }\n+\n+  tl->set_sample_state(NATIVE_SAMPLE);\n+\n+  SafepointMechanism::arm_local_poll_release(jt);\n+\n+  \/\/ Barriers needed to keep the next read of thread state from floating up.\n+  if (UseSystemMemoryBarrier) {\n+    SystemMemoryBarrier::emit();\n+  } else {\n+    OrderAccess::storeload();\n+  }\n+\n+  if (jt->thread_state() != _thread_in_native || !jt->has_last_Java_frame()) {\n+    MonitorLocker lock(tl->sample_monitor(), Monitor::_no_safepoint_check_flag);\n+    tl->set_sample_state(NO_SAMPLE);\n+    lock.notify_all();\n+    return false;\n@@ -640,0 +352,12 @@\n+\n+  return JfrThreadSampling::process_native_sample_request(tl, jt, _sampler_thread);\n+}\n+\n+void JfrSamplerThread::set_java_period(int64_t period_millis) {\n+  assert(period_millis >= 0, \"invariant\");\n+  Atomic::store(&_java_period_millis, period_millis);\n+}\n+\n+void JfrSamplerThread::set_native_period(int64_t period_millis) {\n+  assert(period_millis >= 0, \"invariant\");\n+  Atomic::store(&_native_period_millis, period_millis);\n@@ -642,1 +366,2 @@\n-static JfrThreadSampling* _instance = nullptr;\n+\/\/ JfrThreadSampler;\n+static JfrThreadSampler* _instance = nullptr;\n@@ -644,1 +369,1 @@\n-JfrThreadSampling& JfrThreadSampling::instance() {\n+JfrThreadSampler& JfrThreadSampler::instance() {\n@@ -648,1 +373,9 @@\n-JfrThreadSampling* JfrThreadSampling::create() {\n+JfrThreadSampler::JfrThreadSampler() {}\n+\n+JfrThreadSampler::~JfrThreadSampler() {\n+  if (_sampler_thread != nullptr) {\n+    _sampler_thread->disenroll();\n+  }\n+}\n+\n+JfrThreadSampler* JfrThreadSampler::create() {\n@@ -650,1 +383,1 @@\n-  _instance = new JfrThreadSampling();\n+  _instance = new JfrThreadSampler();\n@@ -654,1 +387,1 @@\n-void JfrThreadSampling::destroy() {\n+void JfrThreadSampler::destroy() {\n@@ -661,8 +394,0 @@\n-JfrThreadSampling::JfrThreadSampling() : _sampler(nullptr) {}\n-\n-JfrThreadSampling::~JfrThreadSampling() {\n-  if (_sampler != nullptr) {\n-    _sampler->disenroll();\n-  }\n-}\n-\n@@ -670,4 +395,4 @@\n-static void assert_periods(const JfrThreadSampler* sampler, int64_t java_period_millis, int64_t native_period_millis) {\n-  assert(sampler != nullptr, \"invariant\");\n-  assert(sampler->get_java_period() == java_period_millis, \"invariant\");\n-  assert(sampler->get_native_period() == native_period_millis, \"invariant\");\n+static void assert_periods(const JfrSamplerThread* sampler_thread, int64_t java_period_millis, int64_t native_period_millis) {\n+  assert(sampler_thread != nullptr, \"invariant\");\n+  assert(sampler_thread->java_period() == java_period_millis, \"invariant\");\n+  assert(sampler_thread->native_period() == native_period_millis, \"invariant\");\n@@ -681,2 +406,2 @@\n-void JfrThreadSampling::create_sampler(int64_t java_period_millis, int64_t native_period_millis) {\n-  assert(_sampler == nullptr, \"invariant\");\n+void JfrThreadSampler::create_sampler(int64_t java_period_millis, int64_t native_period_millis) {\n+  assert(_sampler_thread == nullptr, \"invariant\");\n@@ -684,3 +409,3 @@\n-  _sampler = new JfrThreadSampler(java_period_millis, native_period_millis, JfrOptionSet::stackdepth());\n-  _sampler->start_thread();\n-  _sampler->enroll();\n+  _sampler_thread = new JfrSamplerThread(java_period_millis, native_period_millis, JfrOptionSet::stackdepth());\n+  _sampler_thread->start_thread();\n+  _sampler_thread->enroll();\n@@ -689,1 +414,1 @@\n-void JfrThreadSampling::update_run_state(int64_t java_period_millis, int64_t native_period_millis) {\n+void JfrThreadSampler::update_run_state(int64_t java_period_millis, int64_t native_period_millis) {\n@@ -691,1 +416,1 @@\n-    if (_sampler == nullptr) {\n+    if (_sampler_thread == nullptr) {\n@@ -694,1 +419,1 @@\n-      _sampler->enroll();\n+      _sampler_thread->enroll();\n@@ -696,1 +421,1 @@\n-    DEBUG_ONLY(assert_periods(_sampler, java_period_millis, native_period_millis);)\n+    DEBUG_ONLY(assert_periods(_sampler_thread, java_period_millis, native_period_millis);)\n@@ -700,3 +425,3 @@\n-  if (_sampler != nullptr) {\n-    DEBUG_ONLY(assert_periods(_sampler, java_period_millis, native_period_millis);)\n-    _sampler->disenroll();\n+  if (_sampler_thread != nullptr) {\n+    DEBUG_ONLY(assert_periods(_sampler_thread, java_period_millis, native_period_millis);)\n+    _sampler_thread->disenroll();\n@@ -706,1 +431,1 @@\n-void JfrThreadSampling::set_sampling_period(bool is_java_period, int64_t period_millis) {\n+void JfrThreadSampler::set_period(bool is_java_period, int64_t period_millis) {\n@@ -711,3 +436,3 @@\n-    if (_sampler != nullptr) {\n-      _sampler->set_java_period(java_period_millis);\n-      native_period_millis = _sampler->get_native_period();\n+    if (_sampler_thread != nullptr) {\n+      _sampler_thread->set_java_period(java_period_millis);\n+      native_period_millis = _sampler_thread->native_period();\n@@ -717,3 +442,3 @@\n-    if (_sampler != nullptr) {\n-      _sampler->set_native_period(native_period_millis);\n-      java_period_millis = _sampler->get_java_period();\n+    if (_sampler_thread != nullptr) {\n+      _sampler_thread->set_native_period(native_period_millis);\n+      java_period_millis = _sampler_thread->java_period();\n@@ -725,1 +450,1 @@\n-void JfrThreadSampling::set_java_sample_period(int64_t period_millis) {\n+void JfrThreadSampler::set_java_sample_period(int64_t period_millis) {\n@@ -730,1 +455,1 @@\n-  instance().set_sampling_period(true, period_millis);\n+  instance().set_period(true, period_millis);\n@@ -733,1 +458,1 @@\n-void JfrThreadSampling::set_native_sample_period(int64_t period_millis) {\n+void JfrThreadSampler::set_native_sample_period(int64_t period_millis) {\n@@ -738,5 +463,1 @@\n-  instance().set_sampling_period(false, period_millis);\n-}\n-\n-void JfrThreadSampling::on_javathread_suspend(JavaThread* thread) {\n-  JfrThreadSampler::on_javathread_suspend(thread);\n+  instance().set_period(false, period_millis);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":242,"deletions":521,"binary":false,"changes":763,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,4 +30,1 @@\n-class JavaThread;\n-class JfrThreadSampler;\n-\n-class JfrThreadSampling : public JfrCHeapObj {\n+class JfrThreadSampler : public JfrCHeapObj {\n@@ -36,1 +33,0 @@\n-  JfrThreadSampler* _sampler;\n@@ -39,1 +35,1 @@\n-  void set_sampling_period(bool is_java_period, int64_t period_millis);\n+  void set_period(bool is_java_period, int64_t period_millis);\n@@ -41,2 +37,2 @@\n-  JfrThreadSampling();\n-  ~JfrThreadSampling();\n+  JfrThreadSampler();\n+  ~JfrThreadSampler();\n@@ -44,2 +40,2 @@\n-  static JfrThreadSampling& instance();\n-  static JfrThreadSampling* create();\n+  static JfrThreadSampler& instance();\n+  static JfrThreadSampler* create();\n@@ -51,1 +47,0 @@\n-  static void on_javathread_suspend(JavaThread* thread);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.hpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,397 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/javaThreadStatus.hpp\"\n+#include \"code\/codeCache.inline.hpp\"\n+#include \"code\/debugInfoRec.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrSampleRequest.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackTrace.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n+\n+template <typename EventType>\n+static inline void send_sample_event(const JfrTicks& start_time, const JfrTicks& end_time, traceid sid, traceid tid) {\n+  EventType event(UNTIMED);\n+  event.set_starttime(start_time);\n+  event.set_endtime(end_time);\n+  event.set_sampledThread(tid);\n+  event.set_state(static_cast<u8>(JavaThreadStatus::RUNNABLE));\n+  event.set_stackTrace(sid);\n+  event.commit();\n+}\n+\n+static inline void send_safepoint_latency_event(const JfrSampleRequest& request, const JfrTicks& end_time, traceid sid, const JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(!jt->jfr_thread_local()->has_cached_stack_trace(), \"invariant\");\n+  EventSafepointLatency event(UNTIMED);\n+  event.set_starttime(request._sample_ticks);\n+  event.set_endtime(end_time);\n+  if (event.should_commit()) {\n+    event.set_threadState(_thread_in_Java);\n+    jt->jfr_thread_local()->set_cached_stack_trace_id(sid);\n+    event.commit();\n+    jt->jfr_thread_local()->clear_cached_stack_trace();\n+  }\n+}\n+\n+static inline bool is_interpreter(address pc) {\n+  return Interpreter::contains(pc);\n+}\n+\n+static inline bool is_interpreter(const JfrSampleRequest& request) {\n+  return request._sample_bcp != nullptr;\n+}\n+\n+static inline bool is_in_continuation(const frame& frame, JavaThread* jt) {\n+  return JfrThreadLocal::is_vthread(jt) &&\n+         (Continuation::is_frame_in_continuation(jt, frame) || Continuation::is_continuation_enterSpecial(frame));\n+}\n+\n+\/\/ A sampled interpreter frame is handled differently from a sampled compiler frame.\n+\/\/\n+\/\/ The JfrSampleRequest description partially describes a _potential_ interpreter Java frame.\n+\/\/ It's partial because the sampler thread only sets the fp and bcp fields.\n+\/\/\n+\/\/ We want to ensure that what we discovered inside interpreter code _really_ is what we assume, a valid interpreter frame.\n+\/\/\n+\/\/ Therefore, instead of letting the sampler thread read what it believes to be a Method*, we delay until we are at a safepoint to ensure the Method* is valid.\n+\/\/\n+\/\/ If the JfrSampleRequest represents a valid interpreter frame, the Method* is retrieved and the sender frame is returned per the sender_frame.\n+\/\/\n+\/\/ If it is not a valid interpreter frame, then the JfrSampleRequest is invalidated, and the current frame is returned per the sender frame.\n+\/\/\n+static bool compute_sender_frame(JfrSampleRequest& request, frame& sender_frame, bool& in_continuation, JavaThread* jt) {\n+  assert(is_interpreter(request), \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jt->has_last_Java_frame(), \"invariant\");\n+\n+  \/\/ For a request representing an interpreter frame, request._sample_sp is actually the frame pointer, fp.\n+  const void* const sampled_fp = request._sample_sp;\n+\n+  StackFrameStream stream(jt, false, false);\n+\n+  \/\/ Search for the sampled interpreter frame and get its Method*.\n+\n+  while (!stream.is_done()) {\n+    const frame* const frame = stream.current();\n+    assert(frame != nullptr, \"invariant\");\n+    const intptr_t* const real_fp = frame->real_fp();\n+    assert(real_fp != nullptr, \"invariant\");\n+    if (real_fp == sampled_fp && frame->is_interpreted_frame()) {\n+      Method* const method = frame->interpreter_frame_method();\n+      assert(method != nullptr, \"invariant\");\n+      request._sample_pc = method;\n+      \/\/ Got the Method*. Validate bcp.\n+      if (!method->is_native() &&  !method->contains(static_cast<address>(request._sample_bcp))) {\n+        request._sample_bcp = frame->interpreter_frame_bcp();\n+      }\n+      in_continuation = is_in_continuation(*frame, jt);\n+      break;\n+    }\n+    if (real_fp >= sampled_fp) {\n+      \/\/ What we sampled is not an official interpreter frame.\n+      \/\/ Invalidate the sample request and use current.\n+      request._sample_bcp = nullptr;\n+      sender_frame = *stream.current();\n+      in_continuation = is_in_continuation(sender_frame, jt);\n+      return true;\n+    }\n+    stream.next();\n+  }\n+\n+  assert(!stream.is_done(), \"invariant\");\n+\n+  \/\/ Step to sender.\n+  stream.next();\n+\n+  \/\/ If the top frame is in a continuation, check that the sender frame is too.\n+  if (in_continuation && !is_in_continuation(*stream.current(), jt)) {\n+    \/\/ Leave sender frame empty.\n+    return true;\n+  }\n+\n+  sender_frame = *stream.current();\n+\n+  assert(request._sample_pc != nullptr, \"invariant\");\n+  assert(request._sample_bcp != nullptr, \"invariant\");\n+  assert(Method::is_valid_method(static_cast<const Method*>(request._sample_pc)), \"invariant\");\n+  assert(static_cast<const Method*>(request._sample_pc)->is_native() ||\n+         static_cast<const Method*>(request._sample_pc)->contains(static_cast<address>(request._sample_bcp)), \"invariant\");\n+  return true;\n+}\n+\n+static inline const PcDesc* get_pc_desc(nmethod* nm, void* pc) {\n+  assert(nm != nullptr, \"invariant\");\n+  assert(pc != nullptr, \"invariant\");\n+  return nm->pc_desc_near(static_cast<address>(pc));\n+}\n+\n+static inline bool is_valid(const PcDesc* pc_desc) {\n+  return pc_desc != nullptr && pc_desc->scope_decode_offset() != DebugInformationRecorder::serialized_null;\n+}\n+\n+static bool compute_top_frame(const JfrSampleRequest& request, frame& top_frame, bool& in_continuation, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+\n+  if (!jt->has_last_Java_frame()) {\n+    return false;\n+  }\n+\n+  if (is_interpreter(request)) {\n+    return compute_sender_frame(const_cast<JfrSampleRequest&>(request), top_frame, in_continuation, jt);\n+  }\n+\n+  void* const sampled_pc = request._sample_pc;\n+  CodeBlob* sampled_cb;\n+  if (sampled_pc == nullptr || (sampled_cb = CodeCache::find_blob(sampled_pc)) == nullptr) {\n+    \/\/ A biased sample is requested or no code blob.\n+    top_frame = jt->last_frame();\n+    in_continuation = is_in_continuation(top_frame, jt);\n+    return true;\n+  }\n+\n+  \/\/ We will never describe a sample request that represents an unparsable stub or blob.\n+  assert(sampled_cb->frame_complete_offset() != CodeOffsets::frame_never_safe, \"invariant\");\n+\n+  const void* const sampled_sp = request._sample_sp;\n+  assert(sampled_sp != nullptr, \"invariant\");\n+\n+  nmethod* const sampled_nm = sampled_cb->as_nmethod_or_null();\n+\n+  StackFrameStream stream(jt, false \/* update registers *\/, false \/* process frames *\/);\n+\n+  if (stream.current()->is_safepoint_blob_frame()) {\n+    if (sampled_nm != nullptr) {\n+      \/\/ Move to the physical sender frame of the SafepointBlob stub frame using the frame size, not the logical iterator.\n+      const int safepoint_blob_stub_frame_size = stream.current()->cb()->frame_size();\n+      intptr_t* const sender_sp = stream.current()->unextended_sp() + safepoint_blob_stub_frame_size;\n+      if (sender_sp > sampled_sp) {\n+        const address saved_exception_pc = jt->saved_exception_pc();\n+        assert(saved_exception_pc != nullptr, \"invariant\");\n+        const nmethod* const exception_nm = CodeCache::find_blob(saved_exception_pc)->as_nmethod();\n+        assert(exception_nm != nullptr, \"invariant\");\n+        if (exception_nm == sampled_nm && sampled_nm->is_at_poll_return(saved_exception_pc)) {\n+          \/\/ We sit at the poll return site in the sampled compiled nmethod with only the return address on the stack.\n+          \/\/ The sampled_nm compiled frame is no longer extant, but we might be able to reconstruct a synthetic\n+          \/\/ compiled frame at this location. We do this by overlaying a reconstructed frame on top of\n+          \/\/ the huge SafepointBlob stub frame. Of course, the synthetic frame only contains random stack memory,\n+          \/\/ but it is safe because stack walking cares only about the form of the frame (i.e., an sp and a pc).\n+          \/\/ We also do not have to worry about stackbanging because we currently have a huge SafepointBlob stub frame\n+          \/\/ on the stack. For extra assurance, we know that we can create this frame size at this\n+          \/\/ very location because we just popped such a frame before we hit the return poll site.\n+          \/\/\n+          \/\/ Let's attempt to correct for the safepoint bias.\n+          const PcDesc* const pc_desc = get_pc_desc(sampled_nm, sampled_pc);\n+          if (is_valid(pc_desc)) {\n+            intptr_t* const synthetic_sp = sender_sp - sampled_nm->frame_size();\n+            top_frame = frame(synthetic_sp, synthetic_sp, sender_sp, pc_desc->real_pc(sampled_nm), sampled_nm);\n+            in_continuation = is_in_continuation(top_frame, jt);\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+    stream.next(); \/\/ skip the SafepointBlob stub frame\n+  }\n+\n+  assert(!stream.current()->is_safepoint_blob_frame(), \"invariant\");\n+\n+  \/\/ Search the first frame that is above the sampled sp.\n+  for (; !stream.is_done(); stream.next()) {\n+    frame* const current = stream.current();\n+\n+    if (current->real_fp() <= sampled_sp) {\n+      \/\/ Continue searching for a matching frame.\n+      continue;\n+    }\n+\n+    if (sampled_nm == nullptr) {\n+      \/\/ The sample didn't have an nmethod; we decide to trace from its sender.\n+      \/\/ Another instance of safepoint bias.\n+      top_frame = *current;\n+      break;\n+    }\n+\n+    \/\/ Check for a matching compiled method.\n+    if (current->cb()->as_nmethod_or_null() == sampled_nm) {\n+      if (current->pc() != sampled_pc) {\n+        \/\/ Let's adjust for the safepoint bias if we can.\n+        const PcDesc* const pc_desc = get_pc_desc(sampled_nm, sampled_pc);\n+        if (is_valid(pc_desc)) {\n+          current->adjust_pc(pc_desc->real_pc(sampled_nm));\n+        }\n+      }\n+    }\n+    \/\/ Either a hit or a mismatched sample in which case we trace from the sender.\n+    \/\/ Yet another instance of safepoint bias,to be addressed with\n+    \/\/ more exact and stricter versions when parsable blobs become available.\n+    top_frame = *current;\n+    break;\n+  }\n+\n+  in_continuation = is_in_continuation(top_frame, jt);\n+  return true;\n+}\n+\n+static void record_thread_in_java(const JfrSampleRequest& request, const JfrTicks& now, const JfrThreadLocal* tl, JavaThread* jt, Thread* current) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(tl != nullptr, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+\n+  frame top_frame;\n+  bool in_continuation;\n+  if (!compute_top_frame(request, top_frame, in_continuation, jt)) {\n+    return;\n+  }\n+\n+  traceid sid;\n+  {\n+    ResourceMark rm(current);\n+    JfrStackTrace stacktrace;\n+    if (!stacktrace.record(jt, top_frame, in_continuation, request)) {\n+      \/\/ Unable to record stacktrace. Fail.\n+      return;\n+    }\n+    sid = JfrStackTraceRepository::add(stacktrace);\n+  }\n+  assert(sid != 0, \"invariant\");\n+  const traceid tid = in_continuation ? tl->vthread_id_with_epoch_update(jt) : JfrThreadLocal::jvm_thread_id(jt);\n+  send_sample_event<EventExecutionSample>(request._sample_ticks, now, sid, tid);\n+  if (current == jt) {\n+    send_safepoint_latency_event(request, now, sid, jt);\n+  }\n+}\n+\n+static void drain_enqueued_requests(const JfrTicks& now, JfrThreadLocal* tl, JavaThread* jt, Thread* current) {\n+  assert(tl != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+  assert(jt->jfr_thread_local() == tl, \"invariant\");\n+  assert_lock_strong(tl->sample_monitor());\n+  if (tl->has_enqueued_requests()) {\n+    for (const JfrSampleRequest& request : *tl->sample_requests()) {\n+      record_thread_in_java(request, now, tl, jt, current);\n+    }\n+    tl->clear_enqueued_requests();\n+  }\n+  assert(!tl->has_enqueued_requests(), \"invariant\");\n+}\n+\n+class SampleMonitor : public StackObj {\n+ private:\n+  JfrThreadLocal* const _tl;\n+  Monitor* const _sample_monitor;\n+ public:\n+  SampleMonitor(JfrThreadLocal* tl) : _tl(tl), _sample_monitor(tl->sample_monitor()) {\n+    assert(tl != nullptr, \"invariant\");\n+    assert(_sample_monitor != nullptr, \"invariant\");\n+    _sample_monitor->lock_without_safepoint_check();\n+  }\n+  ~SampleMonitor() {\n+    assert_lock_strong(_sample_monitor);\n+    _tl->set_sample_state(NO_SAMPLE);\n+    _sample_monitor->notify_all();\n+    _sample_monitor->unlock();\n+  }\n+};\n+\n+\/\/ Only entered by the JfrSampler thread.\n+bool JfrThreadSampling::process_native_sample_request(JfrThreadLocal* tl, JavaThread* jt, Thread* sampler_thread) {\n+  assert(tl != nullptr, \"invairant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(sampler_thread != nullptr, \"invariant\");\n+  assert(sampler_thread->is_JfrSampler_thread(), \"invariant\");\n+  assert(tl == jt->jfr_thread_local(), \"invariant\");\n+  assert(jt != sampler_thread, \"only asynchronous processing of native samples\");\n+  assert(jt->has_last_Java_frame(), \"invariant\");\n+  assert(tl->sample_state() == NATIVE_SAMPLE, \"invariant\");\n+\n+  const JfrTicks start_time = JfrTicks::now();\n+\n+  traceid tid;\n+  traceid sid;\n+\n+  {\n+    SampleMonitor sm(tl);\n+\n+    \/\/ Because the thread was in native, it is in a walkable state, because\n+    \/\/ it will hit a safepoint poll on the way back from native. To ensure timely\n+    \/\/ progress, any requests in the queue can be safely processed now.\n+    drain_enqueued_requests(start_time, tl, jt, sampler_thread);\n+    \/\/ Process the current stacktrace using the ljf.\n+    {\n+      ResourceMark rm(sampler_thread);\n+      JfrStackTrace stacktrace;\n+      const frame top_frame = jt->last_frame();\n+      if (!stacktrace.record_inner(jt, top_frame, is_in_continuation(top_frame, jt), 0 \/* skip level *\/)) {\n+        \/\/ Unable to record stacktrace. Fail.\n+        return false;\n+      }\n+      sid = JfrStackTraceRepository::add(stacktrace);\n+    }\n+    \/\/ Read the tid under the monitor to ensure that if its a virtual thread,\n+    \/\/ it is not unmounted until we are done with it.\n+    tid = JfrThreadLocal::thread_id(jt);\n+  }\n+\n+  assert(tl->sample_state() == NO_SAMPLE, \"invariant\");\n+  send_sample_event<EventNativeMethodSample>(start_time, start_time, sid, tid);\n+  return true;\n+}\n+\n+\/\/ Entry point for a sampled thread that discovered pending Jfr Sample Requests as part of a safepoint poll.\n+void JfrThreadSampling::process_sample_request(JavaThread* jt) {\n+  assert(JavaThread::current() == jt, \"should be current thread\");\n+  assert(jt->thread_state() == _thread_in_vm || jt->thread_state() == _thread_in_Java, \"invariant\");\n+\n+  const JfrTicks now = JfrTicks::now();\n+\n+  JfrThreadLocal* const tl = jt->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+\n+  MonitorLocker ml(tl->sample_monitor(), Monitor::_no_safepoint_check_flag);\n+\n+  for (;;) {\n+    const int sample_state = tl->sample_state();\n+    if (sample_state == NATIVE_SAMPLE) {\n+      \/\/ Wait until stack trace is processed.\n+      ml.wait();\n+    } else if (sample_state == JAVA_SAMPLE) {\n+      tl->enqueue_request();\n+    } else {\n+      \/\/ State has been processed.\n+      break;\n+    }\n+  }\n+  drain_enqueued_requests(now, tl, jt, jt);\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":397,"deletions":0,"binary":false,"changes":397,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_SAMPLING_JFRTHREADSAMPLING_HPP\n+#define SHARE_JFR_PERIODIC_SAMPLING_JFRTHREADSAMPLING_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class JavaThread;\n+class JfrThreadLocal;\n+class Thread;\n+\n+class JfrThreadSampling : AllStatic {\n+  friend class JfrSamplerThread;\n+ private:\n+  static bool process_native_sample_request(JfrThreadLocal* tl, JavaThread* jt, Thread* sampler_thread);\n+ public:\n+  static void process_sample_request(JavaThread* jt);\n+};\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_SAMPLING_JFRTHREADSAMPLING_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -304,1 +304,1 @@\n-  if (!create_thread_sampling()) {\n+  if (!create_thread_sampler()) {\n@@ -320,1 +320,1 @@\n-static JfrThreadSampling* _thread_sampling = nullptr;\n+static JfrThreadSampler* _thread_sampler = nullptr;\n@@ -387,4 +387,4 @@\n-bool JfrRecorder::create_thread_sampling() {\n-  assert(_thread_sampling == nullptr, \"invariant\");\n-  _thread_sampling = JfrThreadSampling::create();\n-  return _thread_sampling != nullptr;\n+bool JfrRecorder::create_thread_sampler() {\n+  assert(_thread_sampler == nullptr, \"invariant\");\n+  _thread_sampler = JfrThreadSampler::create();\n+  return _thread_sampler != nullptr;\n@@ -427,3 +427,3 @@\n-  if (_thread_sampling != nullptr) {\n-    JfrThreadSampling::destroy();\n-    _thread_sampling = nullptr;\n+  if (_thread_sampler != nullptr) {\n+    JfrThreadSampler::destroy();\n+    _thread_sampler = nullptr;\n@@ -435,1 +435,1 @@\n-  return JfrRecorderThread::start(_checkpoint_manager, _post_box, JavaThread::current());\n+  return JfrRecorderThreadEntry::start(_checkpoint_manager, _post_box, JavaThread::current());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  static bool create_thread_sampling();\n+  static bool create_thread_sampler();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-static JfrEventThrottler* _throttler = nullptr;\n+static JfrEventThrottler* _object_allocation_throttler = nullptr;\n+static JfrEventThrottler* _safepoint_latency_throttler = nullptr;\n@@ -50,3 +51,8 @@\n-  assert(_throttler == nullptr, \"invariant\");\n-  _throttler = new JfrEventThrottler(JfrObjectAllocationSampleEvent);\n-  return _throttler != nullptr && _throttler->initialize();\n+  assert(_object_allocation_throttler == nullptr, \"invariant\");\n+  _object_allocation_throttler = new JfrEventThrottler(JfrObjectAllocationSampleEvent);\n+  if (_object_allocation_throttler == nullptr || !_object_allocation_throttler->initialize()) {\n+    return false;\n+  }\n+  assert(_safepoint_latency_throttler == nullptr, \"invariant\");\n+  _safepoint_latency_throttler = new JfrEventThrottler(JfrSafepointLatencyEvent);\n+  return _safepoint_latency_throttler != nullptr && _safepoint_latency_throttler->initialize();\n@@ -56,2 +62,4 @@\n-  delete _throttler;\n-  _throttler = nullptr;\n+  delete _object_allocation_throttler;\n+  _object_allocation_throttler = nullptr;\n+  delete _safepoint_latency_throttler;\n+  _safepoint_latency_throttler = nullptr;\n@@ -60,2 +68,3 @@\n-\/\/ There is currently only one throttler instance, for the jdk.ObjectAllocationSample event.\n-\/\/ When introducing additional throttlers, also add a lookup map keyed by event id.\n+\/\/ There is currently only two throttler instances, one for the jdk.ObjectAllocationSample event\n+\/\/ and another for the SamplingLatency event.\n+\/\/ When introducing many more throttlers, consider adding a lookup map keyed by event id.\n@@ -63,3 +72,10 @@\n-  assert(_throttler != nullptr, \"JfrEventThrottler has not been properly initialized\");\n-  assert(event_id == JfrObjectAllocationSampleEvent, \"Event type has an unconfigured throttler\");\n-  return event_id == JfrObjectAllocationSampleEvent ? _throttler : nullptr;\n+  assert(_object_allocation_throttler != nullptr, \"ObjectAllocation throttler has not been properly initialized\");\n+  assert(_safepoint_latency_throttler != nullptr, \"SafepointLatency throttler has not been properly initialized\");\n+  assert(event_id == JfrObjectAllocationSampleEvent || event_id == JfrSafepointLatencyEvent, \"Event type has an unconfigured throttler\");\n+  if (event_id == JfrObjectAllocationSampleEvent) {\n+    return _object_allocation_throttler;\n+  }\n+  if (event_id == JfrSafepointLatencyEvent) {\n+    return _safepoint_latency_throttler;\n+  }\n+  return nullptr;\n@@ -69,1 +85,3 @@\n-  if (event_id != JfrObjectAllocationSampleEvent) {\n+  if (event_id == JfrObjectAllocationSampleEvent) {\n+    assert(_object_allocation_throttler != nullptr, \"ObjectAllocation throttler has not been properly initialized\");\n+    _object_allocation_throttler->configure(sample_size, period_ms);\n@@ -72,2 +90,4 @@\n-  assert(_throttler != nullptr, \"JfrEventThrottler has not been properly initialized\");\n-  _throttler->configure(sample_size, period_ms);\n+  if (event_id == JfrSafepointLatencyEvent) {\n+    assert(_safepoint_latency_throttler != nullptr, \"SafepointLatency throttler has not been properly initialized\");\n+    _safepoint_latency_throttler->configure(sample_size, period_ms);\n+  }\n@@ -95,2 +115,2 @@\n-  if (throttler == nullptr) return true;\n-  return _throttler->_disabled ? true : _throttler->sample(timestamp);\n+  assert(throttler != nullptr, \"invariant\");\n+  return throttler->_disabled ? true : throttler->sample(timestamp);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":36,"deletions":16,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+class JfrRecorderThread : public JavaThread {\n+ public:\n+  JfrRecorderThread(ThreadFunction entry_point) : JavaThread(entry_point) {}\n+  virtual ~JfrRecorderThread() {}\n+\n+  virtual bool is_JfrRecorder_thread() const { return true; }\n+};\n+\n@@ -43,1 +51,1 @@\n-  JavaThread* new_thread = new JavaThread(proc);\n+  JfrRecorderThread* new_thread = new JfrRecorderThread(proc);\n@@ -57,1 +65,1 @@\n-JfrPostBox* JfrRecorderThread::_post_box = nullptr;\n+JfrPostBox* JfrRecorderThreadEntry::_post_box = nullptr;\n@@ -59,1 +67,1 @@\n-JfrPostBox& JfrRecorderThread::post_box() {\n+JfrPostBox& JfrRecorderThreadEntry::post_box() {\n@@ -66,1 +74,1 @@\n-bool JfrRecorderThread::start(JfrCheckpointManager* cp_manager, JfrPostBox* post_box, TRAPS) {\n+bool JfrRecorderThreadEntry::start(JfrCheckpointManager* cp_manager, JfrPostBox* post_box, TRAPS) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-class JfrRecorderThread : AllStatic {\n+class JfrRecorderThreadEntry : AllStatic {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  JfrPostBox& post_box = JfrRecorderThread::post_box();\n+  JfrPostBox& post_box = JfrRecorderThreadEntry::post_box();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThreadLoop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,3 +80,1 @@\n-  if (id < 0) {\n-    return nullptr;\n-  }\n+  assert(id >= 0, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFrame.hpp\"\n+#include \"jfr\/support\/jfrMethodLookup.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+\n+JfrStackFrame::JfrStackFrame() : _klass(nullptr), _methodid(0), _line(0), _bci(0), _type(0) {}\n+\n+JfrStackFrame::JfrStackFrame(const traceid& id, int bci, u1 type, const InstanceKlass* ik) :\n+  _klass(ik), _methodid(id), _line(0), _bci(bci), _type(type) {}\n+\n+JfrStackFrame::JfrStackFrame(const traceid& id, int bci, u1 type, int lineno, const InstanceKlass* ik) :\n+  _klass(ik), _methodid(id), _line(lineno), _bci(bci), _type(type) {}\n+\n+template <typename Writer>\n+static void write_frame(Writer& w, traceid methodid, int line, int bci, u1 type) {\n+  w.write(methodid);\n+  w.write(static_cast<u4>(line));\n+  w.write(static_cast<u4>(bci));\n+  w.write(static_cast<u8>(type));\n+}\n+\n+void JfrStackFrame::write(JfrChunkWriter& cw) const {\n+  write_frame(cw, _methodid, _line, _bci, _type);\n+}\n+\n+void JfrStackFrame::write(JfrCheckpointWriter& cpw) const {\n+  write_frame(cpw, _methodid, _line, _bci, _type);\n+}\n+\n+bool JfrStackFrame::equals(const JfrStackFrame& rhs) const {\n+  return _methodid == rhs._methodid && _bci == rhs._bci && _type == rhs._type;\n+}\n+\n+void JfrStackFrame::resolve_lineno() const {\n+  assert(_klass, \"no klass pointer\");\n+  assert(_line == 0, \"already have linenumber\");\n+  const Method* const method = JfrMethodLookup::lookup(_klass, _methodid);\n+  assert(method != nullptr, \"invariant\");\n+  assert(method->method_holder() == _klass, \"invariant\");\n+  _line = method->line_number_from_bci(_bci);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFrame.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFRAME_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFRAME_HPP\n+\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+class JfrCheckpointWriter;\n+class JfrChunkWriter;\n+class InstanceKlass;\n+\n+class JfrStackFrame {\n+  friend class ObjectSampleCheckpoint;\n+ private:\n+  const InstanceKlass* _klass;\n+  traceid _methodid;\n+  mutable int _line;\n+  int _bci;\n+  u1 _type;\n+\n+ public:\n+  JfrStackFrame();\n+  JfrStackFrame(const traceid& id, int bci, u1 type, const InstanceKlass* klass);\n+  JfrStackFrame(const traceid& id, int bci, u1 type, int lineno, const InstanceKlass* klass);\n+\n+  bool equals(const JfrStackFrame& rhs) const;\n+  void write(JfrChunkWriter& cw) const;\n+  void write(JfrCheckpointWriter& cpw) const;\n+  void resolve_lineno() const;\n+\n+  enum : u1 {\n+    FRAME_INTERPRETER = 0,\n+    FRAME_JIT,\n+    FRAME_INLINE,\n+    FRAME_NATIVE,\n+    NUM_FRAME_TYPES\n+  };\n+};\n+\n+template <typename>\n+class GrowableArray;\n+\n+typedef GrowableArray<JfrStackFrame> JfrStackFrames;\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFRAME_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFrame.hpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/recorder\/stacktrace\/jfrVframeStream.inline.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"jfr\/support\/jfrMethodLookup.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -41,1 +43,1 @@\n-static void copy_frames(JfrStackFrame** lhs_frames, u4 length, const JfrStackFrame* rhs_frames) {\n+static inline void copy_frames(JfrStackFrames* lhs_frames, const JfrStackFrames* rhs_frames) {\n@@ -44,4 +46,5 @@\n-  if (length > 0) {\n-    *lhs_frames = NEW_C_HEAP_ARRAY(JfrStackFrame, length, mtTracing);\n-    memcpy(*lhs_frames, rhs_frames, length * sizeof(JfrStackFrame));\n-  }\n+  assert(rhs_frames->length() > 0, \"invariant\");\n+  assert(lhs_frames->capacity() == rhs_frames->length(), \"invariant\");\n+  assert(lhs_frames->length() == rhs_frames->length(), \"invariant\");\n+  assert(lhs_frames->capacity() == lhs_frames->length(), \"invariant\");\n+  memcpy(lhs_frames->adr_at(0), rhs_frames->adr_at(0), rhs_frames->length() * sizeof(JfrStackFrame));\n@@ -50,7 +53,1 @@\n-JfrStackFrame::JfrStackFrame(const traceid& id, int bci, u1 type, const InstanceKlass* ik) :\n-  _klass(ik), _methodid(id), _line(0), _bci(bci), _type(type) {}\n-\n-JfrStackFrame::JfrStackFrame(const traceid& id, int bci, u1 type, int lineno, const InstanceKlass* ik) :\n-  _klass(ik), _methodid(id), _line(lineno), _bci(bci), _type(type) {}\n-\n-JfrStackTrace::JfrStackTrace(JfrStackFrame* frames, u4 max_frames) :\n+JfrStackTrace::JfrStackTrace() :\n@@ -58,1 +55,1 @@\n-  _frames(frames),\n+  _frames(new JfrStackFrames(JfrOptionSet::stackdepth())), \/\/ ResourceArea\n@@ -61,2 +58,2 @@\n-  _nr_of_frames(0),\n-  _max_frames(max_frames),\n+  _count(0),\n+  _max_frames(JfrOptionSet::stackdepth()),\n@@ -70,1 +67,1 @@\n-  _frames(nullptr),\n+  _frames(new (mtTracing) JfrStackFrames(trace.number_of_frames(), trace.number_of_frames(), mtTracing)), \/\/ CHeap\n@@ -73,1 +70,1 @@\n-  _nr_of_frames(trace._nr_of_frames),\n+  _count(trace._count),\n@@ -79,1 +76,1 @@\n-  copy_frames(&_frames, trace._nr_of_frames, trace._frames);\n+  copy_frames(_frames, trace._frames);\n@@ -84,1 +81,1 @@\n-    FREE_C_HEAP_ARRAY(JfrStackFrame, _frames);\n+    delete _frames;\n@@ -88,0 +85,5 @@\n+int JfrStackTrace::number_of_frames() const {\n+  assert(_frames != nullptr, \"invariant\");\n+  return _frames->length();\n+}\n+\n@@ -89,6 +91,7 @@\n-static void write_stacktrace(Writer& w, traceid id, bool reached_root, u4 nr_of_frames, const JfrStackFrame* frames) {\n-  w.write((u8)id);\n-  w.write((u1)!reached_root);\n-  w.write(nr_of_frames);\n-  for (u4 i = 0; i < nr_of_frames; ++i) {\n-    frames[i].write(w);\n+static void write_stacktrace(Writer& w, traceid id, bool reached_root, const JfrStackFrames* frames) {\n+  w.write(static_cast<u8>(id));\n+  w.write(static_cast<u1>(!reached_root));\n+  const int nr_of_frames = frames->length();\n+  w.write(static_cast<u4>(nr_of_frames));\n+  for (int i = 0; i < nr_of_frames; ++i) {\n+    frames->at(i).write(w);\n@@ -100,1 +103,1 @@\n-  write_stacktrace(sw, _id, _reached_root, _nr_of_frames, _frames);\n+  write_stacktrace(sw, _id, _reached_root, _frames);\n@@ -106,1 +109,1 @@\n-  write_stacktrace(cpw, _id, _reached_root, _nr_of_frames, _frames);\n+  write_stacktrace(cpw, _id, _reached_root, _frames);\n@@ -110,4 +113,0 @@\n-bool JfrStackFrame::equals(const JfrStackFrame& rhs) const {\n-  return _methodid == rhs._methodid && _bci == rhs._bci && _type == rhs._type;\n-}\n-\n@@ -115,1 +114,1 @@\n-  if (_reached_root != rhs._reached_root || _nr_of_frames != rhs._nr_of_frames || _hash != rhs._hash) {\n+  if (_reached_root != rhs._reached_root || _frames->length() != rhs.number_of_frames() || _hash != rhs._hash) {\n@@ -118,2 +117,2 @@\n-  for (u4 i = 0; i < _nr_of_frames; ++i) {\n-    if (!_frames[i].equals(rhs._frames[i])) {\n+  for (int i = 0; i < _frames->length(); ++i) {\n+    if (!_frames->at(i).equals(rhs._frames->at(i))) {\n@@ -126,10 +125,3 @@\n-template <typename Writer>\n-static void write_frame(Writer& w, traceid methodid, int line, int bci, u1 type) {\n-  w.write((u8)methodid);\n-  w.write((u4)line);\n-  w.write((u4)bci);\n-  w.write((u8)type);\n-}\n-\n-void JfrStackFrame::write(JfrChunkWriter& cw) const {\n-  write_frame(cw, _methodid, _line, _bci, _type);\n+static inline bool is_in_continuation(const frame& frame, JavaThread* jt) {\n+  return JfrThreadLocal::is_vthread(jt) &&\n+    (Continuation::is_frame_in_continuation(jt, frame) || Continuation::is_continuation_enterSpecial(frame));\n@@ -138,2 +130,2 @@\n-void JfrStackFrame::write(JfrCheckpointWriter& cpw) const {\n-  write_frame(cpw, _methodid, _line, _bci, _type);\n+static inline bool is_interpreter(const JfrSampleRequest& request) {\n+  return request._sample_bcp != nullptr;\n@@ -142,38 +134,25 @@\n-class JfrVframeStream : public vframeStreamCommon {\n- private:\n-  bool _vthread;\n-  const ContinuationEntry* _cont_entry;\n-  bool _async_mode;\n-  bool step_to_sender();\n-  void next_frame();\n- public:\n-  JfrVframeStream(JavaThread* jt, const frame& fr, bool stop_at_java_call_stub, bool async_mode);\n-  void next_vframe();\n-};\n-\n-static RegisterMap::WalkContinuation walk_continuation(JavaThread* jt) {\n-  \/\/ NOTE: WalkContinuation::skip, because of interactions with ZGC relocation\n-  \/\/       and load barriers. This code is run while generating stack traces for\n-  \/\/       the ZPage allocation event, even when ZGC is relocating  objects.\n-  \/\/       When ZGC is relocating, it is forbidden to run code that performs\n-  \/\/       load barriers. With WalkContinuation::include, we visit heap stack\n-  \/\/       chunks and could be using load barriers.\n-  return (UseZGC && !StackWatermarkSet::processing_started(jt))\n-      ? RegisterMap::WalkContinuation::skip\n-      : RegisterMap::WalkContinuation::include;\n-}\n-\n-JfrVframeStream::JfrVframeStream(JavaThread* jt, const frame& fr, bool stop_at_java_call_stub, bool async_mode) :\n-  vframeStreamCommon(jt,\n-                     RegisterMap::UpdateMap::skip,\n-                     RegisterMap::ProcessFrames::skip,\n-                     walk_continuation(jt)),\n-    _vthread(JfrThreadLocal::is_vthread(jt)),\n-    _cont_entry(_vthread ? jt->last_continuation() : nullptr),\n-    _async_mode(async_mode) {\n-  assert(!_vthread || _cont_entry != nullptr, \"invariant\");\n-  _reg_map.set_async(async_mode);\n-  _frame = fr;\n-  _stop_at_java_call_stub = stop_at_java_call_stub;\n-  while (!fill_from_frame()) {\n-    step_to_sender();\n+void JfrStackTrace::record_interpreter_top_frame(const JfrSampleRequest& request) {\n+  assert(_hash == 0, \"invariant\");\n+  assert(_count == 0, \"invariant\");\n+  assert(_frames != nullptr, \"invariant\");\n+  assert(_frames->length() == 0, \"invariant\");\n+  _hash = 1;\n+  const Method* method = reinterpret_cast<Method*>(request._sample_pc);\n+  assert(method != nullptr, \"invariant\");\n+  const traceid mid = JfrTraceId::load(method);\n+  const int bci = method->is_native() ? 0 : method->bci_from(reinterpret_cast<address>(request._sample_bcp));\n+  const u1 type = method->is_native() ? JfrStackFrame::FRAME_NATIVE : JfrStackFrame::FRAME_INTERPRETER;\n+  _hash = (_hash * 31) + mid;\n+  _hash = (_hash * 31) + bci;\n+  _hash = (_hash * 31) + type;\n+  _frames->append(JfrStackFrame(mid, bci, type, method->method_holder()));\n+  _count++;\n+}\n+\n+bool JfrStackTrace::record(JavaThread* jt, const frame& frame, bool in_continuation, const JfrSampleRequest& request) {\n+  if (is_interpreter(request)) {\n+    record_interpreter_top_frame(request);\n+    if (frame.pc() == nullptr) {\n+      \/\/ No sender frame. Done.\n+      return true;\n+    }\n@@ -181,0 +160,1 @@\n+  return record(jt, frame, in_continuation, 0);\n@@ -183,3 +163,4 @@\n-inline bool JfrVframeStream::step_to_sender() {\n-  if (_async_mode && !_frame.safe_for_sender(_thread)) {\n-    _mode = at_end_mode;\n+bool JfrStackTrace::record(JavaThread* jt, int skip, int64_t stack_filter_id) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jt == JavaThread::current(), \"invariant\");\n+  if (!jt->has_last_Java_frame()) {\n@@ -188,40 +169,2 @@\n-  _frame = _frame.sender(&_reg_map);\n-  return true;\n-}\n-\n-inline void JfrVframeStream::next_frame() {\n-  static constexpr const u4 loop_max = MAX_STACK_DEPTH * 2;\n-  u4 loop_count = 0;\n-  do {\n-    if (_vthread && Continuation::is_continuation_enterSpecial(_frame)) {\n-      if (_cont_entry->is_virtual_thread()) {\n-        \/\/ An entry of a vthread continuation is a termination point.\n-        _mode = at_end_mode;\n-        break;\n-      }\n-      _cont_entry = _cont_entry->parent();\n-    }\n-    if (_async_mode) {\n-      ++loop_count;\n-      if (loop_count > loop_max) {\n-        _mode = at_end_mode;\n-        break;\n-      }\n-    }\n-  } while (step_to_sender() && !fill_from_frame());\n-}\n-\n-\/\/ Solaris SPARC Compiler1 needs an additional check on the grandparent\n-\/\/ of the top_frame when the parent of the top_frame is interpreted and\n-\/\/ the grandparent is compiled. However, in this method we do not know\n-\/\/ the relationship of the current _frame relative to the top_frame so\n-\/\/ we implement a more broad sanity check. When the previous callee is\n-\/\/ interpreted and the current sender is compiled, we verify that the\n-\/\/ current sender is also walkable. If it is not walkable, then we mark\n-\/\/ the current vframeStream as at the end.\n-void JfrVframeStream::next_vframe() {\n-  \/\/ handle frames with inlining\n-  if (_mode == compiled_mode && fill_in_compiled_inlined_sender()) {\n-    return;\n-  }\n-  next_frame();\n+  const frame last_frame = jt->last_frame();\n+  return record(jt, last_frame, is_in_continuation(last_frame, jt), skip, stack_filter_id);\n@@ -230,4 +173,5 @@\n-static const size_t min_valid_free_size_bytes = 16;\n-\n-static inline bool is_full(const JfrBuffer* enqueue_buffer) {\n-  return enqueue_buffer->free_size() < min_valid_free_size_bytes;\n+bool JfrStackTrace::record(JavaThread* jt, const frame& frame, bool in_continuation, int skip, int64_t stack_filter_id \/* -1 *\/) {\n+  \/\/ Must use ResetNoHandleMark here to bypass if any NoHandleMark exist on stack.\n+  \/\/ This is because RegisterMap uses Handles to support continuations.\n+  ResetNoHandleMark rnhm;\n+  return record_inner(jt, frame, in_continuation, skip, stack_filter_id);\n@@ -236,1 +180,1 @@\n-bool JfrStackTrace::record_async(JavaThread* jt, const frame& frame) {\n+bool JfrStackTrace::record_inner(JavaThread* jt, const frame& frame, bool in_continuation, int skip, int64_t stack_filter_id \/* -1 *\/) {\n@@ -239,8 +183,4 @@\n-  Thread* current_thread = Thread::current();\n-  assert(current_thread->is_JfrSampler_thread(), \"invariant\");\n-  assert(jt != current_thread, \"invariant\");\n-  \/\/ Explicitly monitor the available space of the thread-local buffer used for enqueuing klasses as part of tagging methods.\n-  \/\/ We do this because if space becomes sparse, we cannot rely on the implicit allocation of a new buffer as part of the\n-  \/\/ regular tag mechanism. If the free list is empty, a malloc could result, and the problem with that is that the thread\n-  \/\/ we have suspended could be the holder of the malloc lock. If there is no more available space, the attempt is aborted.\n-  const JfrBuffer* const enqueue_buffer = JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(current_thread);\n+  assert(_frames != nullptr, \"invariant\");\n+  assert(_frames->length() == 0 || _frames->length() == 1, \"invariant\");\n+  assert(!in_continuation || is_in_continuation(frame, jt), \"invariant\");\n+  Thread* const current_thread = Thread::current();\n@@ -248,53 +188,1 @@\n-  JfrVframeStream vfs(jt, frame, false, true);\n-  u4 count = 0;\n-  _reached_root = true;\n-  _hash = 1;\n-  while (!vfs.at_end()) {\n-    if (count >= _max_frames) {\n-      _reached_root = false;\n-      break;\n-    }\n-    const Method* method = vfs.method();\n-    if (!Method::is_valid_method(method) || is_full(enqueue_buffer)) {\n-      \/\/ we throw away everything we've gathered in this sample since\n-      \/\/ none of it is safe\n-      return false;\n-    }\n-    const traceid mid = JfrTraceId::load(method);\n-    u1 type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;\n-    int bci = 0;\n-    if (method->is_native()) {\n-      type = JfrStackFrame::FRAME_NATIVE;\n-    } else {\n-      bci = vfs.bci();\n-    }\n-\n-    intptr_t* frame_id = vfs.frame_id();\n-    vfs.next_vframe();\n-    if (type == JfrStackFrame::FRAME_JIT && !vfs.at_end() && frame_id == vfs.frame_id()) {\n-      \/\/ This frame and the caller frame are both the same physical\n-      \/\/ frame, so this frame is inlined into the caller.\n-      type = JfrStackFrame::FRAME_INLINE;\n-    }\n-    _hash = (_hash * 31) + mid;\n-    _hash = (_hash * 31) + bci;\n-    _hash = (_hash * 31) + type;\n-    _frames[count] = JfrStackFrame(mid, bci, type, method->line_number_from_bci(bci), method->method_holder());\n-    count++;\n-  }\n-  _lineno = true;\n-  _nr_of_frames = count;\n-  return count > 0;\n-}\n-\n-bool JfrStackTrace::record(JavaThread* jt, const frame& frame, int skip, int64_t stack_filter_id) {\n-  assert(jt != nullptr, \"invariant\");\n-  assert(jt == Thread::current(), \"invariant\");\n-  assert(jt->thread_state() != _thread_in_native, \"invariant\");\n-  assert(!_lineno, \"invariant\");\n-  \/\/ Must use ResetNoHandleMark here to bypass if any NoHandleMark exist on stack.\n-  \/\/ This is because RegisterMap uses Handles to support continuations.\n-  ResetNoHandleMark rnhm;\n-  HandleMark hm(jt);\n-  JfrVframeStream vfs(jt, frame, false, false);\n-  u4 count = 0;\n+  JfrVframeStream vfs(jt, frame, in_continuation, false);\n@@ -308,2 +196,4 @@\n-  const JfrStackFilter* stack_filter = JfrStackFilterRegistry::lookup(stack_filter_id);\n-  _hash = 1;\n+  const JfrStackFilter* stack_filter = stack_filter_id < 0 ? nullptr : JfrStackFilterRegistry::lookup(stack_filter_id);\n+  if (_hash == 0) {\n+    _hash = 1;\n+  }\n@@ -311,1 +201,1 @@\n-    if (count >= _max_frames) {\n+    if (_count >= _max_frames) {\n@@ -331,1 +221,1 @@\n-    intptr_t* frame_id = vfs.frame_id();\n+    const intptr_t* const frame_id = vfs.frame_id();\n@@ -341,2 +231,2 @@\n-    _frames[count] = JfrStackFrame(mid, bci, type, method->method_holder());\n-    count++;\n+    _frames->append(JfrStackFrame(mid, bci, type, method->method_holder()));\n+    _count++;\n@@ -344,20 +234,1 @@\n-  _nr_of_frames = count;\n-  return count > 0;\n-}\n-\n-bool JfrStackTrace::record(JavaThread* current_thread, int skip, int64_t stack_filter_id) {\n-  assert(current_thread != nullptr, \"invariant\");\n-  assert(current_thread == Thread::current(), \"invariant\");\n-  if (!current_thread->has_last_Java_frame()) {\n-    return false;\n-  }\n-  return record(current_thread, current_thread->last_frame(), skip, stack_filter_id);\n-}\n-\n-void JfrStackFrame::resolve_lineno() const {\n-  assert(_klass, \"no klass pointer\");\n-  assert(_line == 0, \"already have linenumber\");\n-  const Method* const method = JfrMethodLookup::lookup(_klass, _methodid);\n-  assert(method != nullptr, \"invariant\");\n-  assert(method->method_holder() == _klass, \"invariant\");\n-  _line = method->line_number_from_bci(_bci);\n+  return _count > 0;\n@@ -368,2 +239,2 @@\n-  for (unsigned int i = 0; i < _nr_of_frames; i++) {\n-    _frames[i].resolve_lineno();\n+  for (int i = 0; i < _frames->length(); i++) {\n+    _frames->at(i).resolve_lineno();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":93,"deletions":222,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFrame.hpp\"\n@@ -36,27 +37,1 @@\n-\n-class JfrStackFrame {\n-  friend class ObjectSampleCheckpoint;\n- private:\n-  const InstanceKlass* _klass;\n-  traceid _methodid;\n-  mutable int _line;\n-  int _bci;\n-  u1 _type;\n-\n- public:\n-  JfrStackFrame(const traceid& id, int bci, u1 type, const InstanceKlass* klass);\n-  JfrStackFrame(const traceid& id, int bci, u1 type, int lineno, const InstanceKlass* klass);\n-\n-  bool equals(const JfrStackFrame& rhs) const;\n-  void write(JfrChunkWriter& cw) const;\n-  void write(JfrCheckpointWriter& cpw) const;\n-  void resolve_lineno() const;\n-\n-  enum : u1 {\n-    FRAME_INTERPRETER = 0,\n-    FRAME_JIT,\n-    FRAME_INLINE,\n-    FRAME_NATIVE,\n-    NUM_FRAME_TYPES\n-  };\n-};\n+struct JfrSampleRequest;\n@@ -68,0 +43,1 @@\n+  friend class JfrThreadSampling;\n@@ -70,1 +46,0 @@\n-  friend class OSThreadSampler;\n@@ -74,1 +49,1 @@\n-  JfrStackFrame* _frames;\n+  JfrStackFrames* _frames;\n@@ -77,1 +52,1 @@\n-  u4 _nr_of_frames;\n+  u4 _count;\n@@ -91,1 +66,0 @@\n-  void set_nr_of_frames(u4 nr_of_frames) { _nr_of_frames = nr_of_frames; }\n@@ -96,4 +70,1 @@\n-  bool record(JavaThread* current_thread, int skip, int64_t stack_frame_id);\n-  bool record(JavaThread* current_thread, const frame& frame, int skip, int64_t stack_frame_id);\n-  bool record_async(JavaThread* other_thread, const frame& frame);\n-\n+  int number_of_frames() const;\n@@ -102,0 +73,3 @@\n+  bool record_inner(JavaThread* jt, const frame& frame, bool in_continuation, int skip, int64_t stack_filter_id = -1);\n+  bool record(JavaThread* jt, const frame& frame, bool in_continuation, int skip, int64_t stack_filter_id = -1);\n+  void record_interpreter_top_frame(const JfrSampleRequest& request);\n@@ -104,2 +78,0 @@\n-  JfrStackTrace(JfrStackFrame* frames, u4 max_frames);\n-  ~JfrStackTrace();\n@@ -108,0 +80,4 @@\n+  \/\/ ResourceArea allocation, remember ResourceMark.\n+  JfrStackTrace();\n+  ~JfrStackTrace();\n+\n@@ -110,0 +86,3 @@\n+\n+  bool record(JavaThread* current_thread, int skip, int64_t stack_filter_id);\n+  bool record(JavaThread* jt, const frame& frame, bool in_continuation, const JfrSampleRequest& request);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":16,"deletions":37,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -68,1 +69,1 @@\n-class JfrFrameType : public JfrSerializer {\n+class JfrFrameTypeSerializer : public JfrSerializer {\n@@ -84,1 +85,1 @@\n-  return JfrSerializer::register_serializer(TYPE_FRAMETYPE, true, new JfrFrameType());\n+  return JfrSerializer::register_serializer(TYPE_FRAMETYPE, true, new JfrFrameTypeSerializer());\n@@ -153,13 +154,3 @@\n-  JfrStackFrame* frames = tl->stackframes();\n-  if (frames == nullptr) {\n-    \/\/ pending oom\n-    return 0;\n-  }\n-  assert(frames != nullptr, \"invariant\");\n-  assert(tl->stackframes() == frames, \"invariant\");\n-  return instance().record(JavaThread::cast(current_thread), skip, stack_filter_id, frames, tl->stackdepth());\n-}\n-\n-traceid JfrStackTraceRepository::record(JavaThread* current_thread, int skip, int64_t stack_filter_id, JfrStackFrame *frames, u4 max_frames) {\n-  JfrStackTrace stacktrace(frames, max_frames);\n-  return stacktrace.record(current_thread, skip, stack_filter_id) ? add(instance(), stacktrace) : 0;\n+  ResourceMark rm(current_thread);\n+  JfrStackTrace stacktrace;\n+  return stacktrace.record(JavaThread::cast(current_thread), skip, stack_filter_id) ? add(instance(), stacktrace) : 0;\n@@ -188,1 +179,2 @@\n-  JfrStackTrace stacktrace(tl->stackframes(), tl->stackdepth());\n+  ResourceMark rm(current_thread);\n+  JfrStackTrace stacktrace;\n@@ -198,1 +190,1 @@\n-  assert(stacktrace._nr_of_frames > 0, \"invariant\");\n+  assert(stacktrace.number_of_frames() > 0, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class JfrStackTrace;\n@@ -40,0 +41,1 @@\n+  friend class JfrThreadSampler;\n@@ -71,2 +73,0 @@\n-\n-  traceid add_trace(const JfrStackTrace& stacktrace);\n@@ -74,2 +74,1 @@\n-  static traceid add(const JfrStackTrace& stacktrace);\n-  traceid record(JavaThread* current_thread, int skip, int64_t stack_filter_id, JfrStackFrame* frames, u4 max_frames);\n+  traceid add_trace(const JfrStackTrace& stacktrace);\n@@ -78,0 +77,1 @@\n+  static traceid add(const JfrStackTrace& stacktrace);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/recorder\/stacktrace\/jfrVframeStream.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n+\n+static inline RegisterMap::WalkContinuation walk_continuation(JavaThread* jt) {\n+  \/\/ NOTE: WalkContinuation::skip, because of interactions with ZGC relocation\n+  \/\/       and load barriers. This code is run while generating stack traces for\n+  \/\/       the ZPage allocation event, even when ZGC is relocating  objects.\n+  \/\/       When ZGC is relocating, it is forbidden to run code that performs\n+  \/\/       load barriers. With WalkContinuation::include, we visit heap stack\n+  \/\/       chunks and could be using load barriers.\n+  \/\/\n+  \/\/ NOTE: Shenandoah GC also seems to require this check - actual details as to why\n+  \/\/       is unknown but to be filled in by others.\n+  return ((UseZGC || UseShenandoahGC) && !StackWatermarkSet::processing_started(jt))\n+    ? RegisterMap::WalkContinuation::skip\n+    : RegisterMap::WalkContinuation::include;\n+}\n+\n+JfrVframeStream::JfrVframeStream(JavaThread* jt, const frame& fr, bool in_continuation, bool stop_at_java_call_stub) :\n+  vframeStreamCommon(jt, RegisterMap::UpdateMap::skip, RegisterMap::ProcessFrames::skip, walk_continuation(jt)),\n+  _vthread(in_continuation), _cont_entry(_vthread ? jt->last_continuation() : nullptr) {\n+  assert(!_vthread || JfrThreadLocal::is_vthread(jt), \"invariant\");\n+  assert(!_vthread || _cont_entry != nullptr, \"invariant\");\n+  _frame = fr;\n+  _stop_at_java_call_stub = stop_at_java_call_stub;\n+  while (!fill_from_frame()) {\n+    _frame = _frame.sender(&_reg_map);\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrVframeStream.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRVFRAMESTREAM_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRVFRAMESTREAM_HPP\n+\n+#include \"runtime\/vframe.hpp\"\n+\n+class JfrVframeStream : public vframeStreamCommon {\n+ private:\n+  bool _vthread;\n+  const ContinuationEntry* _cont_entry;\n+  void step_to_sender();\n+  void next_frame();\n+ public:\n+  JfrVframeStream(JavaThread* jt, const frame& fr, bool in_continuation, bool stop_at_java_call_stub);\n+  void next_vframe();\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRVFRAMESTREAM_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrVframeStream.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRVFRAMESTREAM_INLINE_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRVFRAMESTREAM_INLINE_HPP\n+\n+#include \"jfr\/recorder\/stacktrace\/jfrVframeStream.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+\n+inline void JfrVframeStream::next_frame() {\n+  do {\n+    if (_vthread && Continuation::is_continuation_enterSpecial(_frame)) {\n+      if (_cont_entry->is_virtual_thread()) {\n+        \/\/ An entry of a vthread continuation is a termination point.\n+        _mode = at_end_mode;\n+        break;\n+      }\n+      _cont_entry = _cont_entry->parent();\n+    }\n+\n+    _frame = _frame.sender(&_reg_map);\n+\n+  } while (!fill_from_frame());\n+}\n+\n+inline void JfrVframeStream::next_vframe() {\n+  \/\/ handle frames with inlining\n+  if (_mode == compiled_mode && fill_in_compiled_inlined_sender()) {\n+    return;\n+  }\n+  next_frame();\n+}\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRVFRAMESTREAM_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrVframeStream.inline.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"jfr\/periodic\/sampling\/jfrThreadSampler.hpp\"\n@@ -68,1 +67,5 @@\n-#define SUSPEND_THREAD_CONDITIONAL(thread) if ((thread)->is_trace_suspend()) JfrThreadSampling::on_javathread_suspend(thread)\n+#define SAMPLE_STATE_OFFSET_JFR \\\n+  JfrThreadLocal::sample_state_offset() + THREAD_LOCAL_OFFSET_JFR\n+\n+#define SAMPLING_CRITICAL_SECTION_OFFSET_JFR \\\n+  JfrThreadLocal::sampling_critical_section_offset() + THREAD_LOCAL_OFFSET_JFR\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadExtension.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+  _sample_request(),\n+  _sample_request_queue(8),\n+  _sample_monitor(Monitor::nosafepoint, \"jfr thread sample monitor\"),\n@@ -57,1 +60,1 @@\n-  _stackframes(nullptr),\n+  _sample_state(0),\n@@ -71,2 +74,0 @@\n-  _stackdepth(0),\n-  _entering_suspend_flag(0),\n@@ -77,0 +78,1 @@\n+  _enqueued_requests(false),\n@@ -168,4 +170,0 @@\n-  if (_stackframes != nullptr) {\n-    FREE_C_HEAP_ARRAY(JfrStackFrame, _stackframes);\n-    _stackframes = nullptr;\n-  }\n@@ -248,6 +246,0 @@\n-JfrStackFrame* JfrThreadLocal::install_stackframes() const {\n-  assert(_stackframes == nullptr, \"invariant\");\n-  _stackframes = NEW_C_HEAP_ARRAY(JfrStackFrame, stackdepth(), mtTracing);\n-  return _stackframes;\n-}\n-\n@@ -282,0 +274,8 @@\n+ByteSize JfrThreadLocal::sample_state_offset() {\n+  return byte_offset_of(JfrThreadLocal, _sample_state);\n+}\n+\n+ByteSize JfrThreadLocal::sampling_critical_section_offset() {\n+  return byte_offset_of(JfrThreadLocal, _sampling_critical_section);\n+}\n+\n@@ -340,4 +340,0 @@\n-u4 JfrThreadLocal::stackdepth() const {\n-  return _stackdepth != 0 ? _stackdepth : (u4)JfrOptionSet::stackdepth();\n-}\n-\n@@ -400,0 +396,13 @@\n+traceid JfrThreadLocal::vthread_id_with_epoch_update(const JavaThread* jt) const {\n+  assert(is_vthread(jt), \"invariant\");\n+  const traceid tid = vthread_id(jt);\n+  assert(tid != 0, \"invariant\");\n+  if (!is_vthread_excluded()) {\n+    const u2 current_epoch = AccessThreadTraceId::current_epoch();\n+    if (vthread_epoch(jt) != current_epoch) {\n+      set_vthread_epoch_checked(jt, tid, current_epoch);\n+    }\n+  }\n+  return tid;\n+}\n+\n@@ -415,13 +424,1 @@\n-  if (!is_vthread(jt)) {\n-    return jvm_thread_id(tl);\n-  }\n-  \/\/ virtual thread\n-  const traceid tid = vthread_id(jt);\n-  assert(tid != 0, \"invariant\");\n-  if (!tl->is_vthread_excluded()) {\n-    const u2 current_epoch = AccessThreadTraceId::current_epoch();\n-    if (vthread_epoch(jt) != current_epoch) {\n-      set_vthread_epoch_checked(jt, tid, current_epoch);\n-    }\n-  }\n-  return tid;\n+  return is_vthread(jt) ? tl->vthread_id_with_epoch_update(jt) : jvm_thread_id(tl);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"jfr\/periodic\/sampling\/jfrSampleRequest.hpp\"\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n@@ -29,0 +31,1 @@\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n@@ -30,0 +33,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -34,1 +39,0 @@\n-class JfrStackFrame;\n@@ -43,0 +47,3 @@\n+  mutable JfrSampleRequest _sample_request;\n+  JfrSampleRequestQueue _sample_request_queue;\n+  Monitor _sample_monitor;\n@@ -51,1 +58,1 @@\n-  mutable JfrStackFrame* _stackframes;\n+  volatile int _sample_state;\n@@ -65,2 +72,0 @@\n-  mutable u4 _stackdepth;\n-  volatile jint _entering_suspend_flag;\n@@ -71,0 +76,1 @@\n+  volatile bool _enqueued_requests;\n@@ -74,0 +80,1 @@\n+  bool _sampling_critical_section;\n@@ -77,1 +84,0 @@\n-  JfrStackFrame* install_stackframes() const;\n@@ -143,2 +149,35 @@\n-  JfrStackFrame* stackframes() const {\n-    return _stackframes != nullptr ? _stackframes : install_stackframes();\n+\n+  int sample_state() const {\n+    return Atomic::load_acquire(&_sample_state);\n+  }\n+\n+  void set_sample_state(int state) {\n+    Atomic::release_store(&_sample_state, state);\n+  }\n+\n+  Monitor* sample_monitor() {\n+    return &_sample_monitor;\n+  }\n+\n+  JfrSampleRequestQueue* sample_requests() {\n+    return &_sample_request_queue;\n+  }\n+\n+  JfrSampleRequest sample_request() const {\n+    return _sample_request;\n+  }\n+\n+  void set_sample_request(JfrSampleRequest request) {\n+    _sample_request = request;\n+  }\n+\n+  void set_sample_ticks() {\n+    _sample_request._sample_ticks = JfrTicks::now();\n+  }\n+\n+  void set_sample_ticks(const JfrTicks& ticks) {\n+    _sample_request._sample_ticks = ticks;\n+  }\n+\n+  bool has_sample_ticks() const {\n+    return _sample_request._sample_ticks.value() != 0;\n@@ -147,2 +186,2 @@\n-  void set_stackframes(JfrStackFrame* frames) {\n-    _stackframes = frames;\n+  const JfrTicks& sample_ticks() const {\n+    return _sample_request._sample_ticks;\n@@ -151,1 +190,28 @@\n-  u4 stackdepth() const;\n+  bool has_enqueued_requests() const {\n+    return Atomic::load_acquire(&_enqueued_requests);\n+  }\n+\n+  void enqueue_request() {\n+    assert_lock_strong(sample_monitor());\n+    assert(sample_state() == JAVA_SAMPLE, \"invariant\");\n+    if (_sample_request_queue.append(_sample_request) == 0) {\n+      Atomic::release_store(&_enqueued_requests, true);\n+    }\n+    set_sample_state(NO_SAMPLE);\n+  }\n+\n+  void clear_enqueued_requests() {\n+    assert_lock_strong(sample_monitor());\n+    assert(has_enqueued_requests(), \"invariant\");\n+    assert(_sample_request_queue.is_nonempty(), \"invariant\");\n+    _sample_request_queue.clear();\n+    Atomic::release_store(&_enqueued_requests, false);\n+  }\n+\n+  bool has_native_sample_request() const {\n+    return sample_state() == NATIVE_SAMPLE;\n+  }\n+\n+  bool has_java_sample_request() const {\n+    return sample_state() == JAVA_SAMPLE || has_enqueued_requests();\n+  }\n@@ -153,2 +219,2 @@\n-  void set_stackdepth(u4 depth) {\n-    _stackdepth = depth;\n+  bool has_sample_request() const {\n+    return sample_state() != NO_SAMPLE || has_enqueued_requests();\n@@ -174,0 +240,1 @@\n+  traceid vthread_id_with_epoch_update(const JavaThread* jt) const;\n@@ -214,12 +281,0 @@\n-  void set_trace_block() {\n-    _entering_suspend_flag = 1;\n-  }\n-\n-  void clear_trace_block() {\n-    _entering_suspend_flag = 0;\n-  }\n-\n-  bool is_trace_block() const {\n-    return _entering_suspend_flag != 0;\n-  }\n-\n@@ -272,0 +327,4 @@\n+  bool in_sampling_critical_section() const {\n+    return _sampling_critical_section;\n+  }\n+\n@@ -300,0 +359,2 @@\n+  static ByteSize sample_state_offset();\n+  static ByteSize sampling_critical_section_offset();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":85,"deletions":24,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+  JFR_LOG_TAG(jfr, system, sampling) \\\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLogTagSets.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-void JVMCI::initialize_compiler(TRAPS) {\n+void JVMCI::initialize_compiler_in_create_vm(TRAPS) {\n@@ -165,1 +165,6 @@\n-  runtime->call_getCompiler(CHECK);\n+\n+  JVMCIENV_FROM_THREAD(THREAD);\n+  JVMCIENV->check_init(CHECK);\n+  JVMCIObject jvmciRuntime = runtime->get_HotSpotJVMCIRuntime(JVMCI_CHECK);\n+  runtime->initialize(JVMCI_CHECK);\n+  JVMCIENV->call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -194,3 +194,2 @@\n-  \/\/ Called to force initialization of the JVMCI compiler\n-  \/\/ early in VM startup.\n-  static void initialize_compiler(TRAPS);\n+  \/\/ Initializes the JVMCI compiler during VM startup.\n+  static void initialize_compiler_in_create_vm(TRAPS);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -254,3 +254,0 @@\n-  if (_init_error == JNI_ENOMEM) {\n-    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), \"JNI_ENOMEM creating or attaching to libjvmci\");\n-  }\n@@ -259,1 +256,1 @@\n-           _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg);\n+            _init_error, _init_error_msg != nullptr ? _init_error_msg : (_init_error == JNI_ENOMEM ? \"JNI_ENOMEM\" : \"none\"));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -746,8 +746,0 @@\n-void JVMCIRuntime::call_getCompiler(TRAPS) {\n-  JVMCIENV_FROM_THREAD(THREAD);\n-  JVMCIENV->check_init(CHECK);\n-  JVMCIObject jvmciRuntime = JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_CHECK);\n-  initialize(JVMCI_CHECK);\n-  JVMCIENV->call_HotSpotJVMCIRuntime_getCompiler(jvmciRuntime, JVMCI_CHECK);\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -378,2 +378,0 @@\n-  void call_getCompiler(TRAPS);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+  MetaspaceUtils::print_on(output());\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceDCmd.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,1 +450,1 @@\n-    if (src_holder->is_shared_unregistered_class()) {\n+    if (src_holder->defined_by_other_loaders()) {\n@@ -488,7 +488,6 @@\n-    oop loader = src_ik->class_loader();\n-    if (loader == nullptr) {\n-      type = \"boot\";\n-    } else if (loader == SystemDictionary::java_platform_loader()) {\n-      type = \"plat\";\n-    } else if (loader == SystemDictionary::java_system_loader()) {\n-      type = \"app\";\n+    if (src_ik->defined_by_boot_loader()) {\n+      return \"boot\";\n+    } else if (src_ik->defined_by_platform_loader()) {\n+      return \"plat\";\n+    } else if (src_ik->defined_by_app_loader()) {\n+      return \"app\";\n@@ -496,1 +495,1 @@\n-      type = \"unreg\";\n+      return \"unreg\";\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -542,2 +542,1 @@\n-  if (!(pool_holder->is_shared_boot_class() || pool_holder->is_shared_platform_class() ||\n-        pool_holder->is_shared_app_class())) {\n+  if (pool_holder->defined_by_other_loaders()) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3037,1 +3037,1 @@\n-    if (is_shared_unregistered_class()) {\n+    if (defined_by_other_loaders()) {\n@@ -3149,11 +3149,0 @@\n-int InstanceKlass::shared_class_loader_type() const {\n-  if (is_shared_boot_class()) {\n-    return ClassLoader::BOOT_LOADER;\n-  } else if (is_shared_platform_class()) {\n-    return ClassLoader::PLATFORM_LOADER;\n-  } else if (is_shared_app_class()) {\n-    return ClassLoader::APP_LOADER;\n-  } else {\n-    return ClassLoader::OTHER;\n-  }\n-}\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -378,6 +378,6 @@\n-  \/\/ The three BUILTIN class loader types\n-  bool is_shared_boot_class() const { return _misc_flags.is_shared_boot_class(); }\n-  bool is_shared_platform_class() const { return _misc_flags.is_shared_platform_class(); }\n-  bool is_shared_app_class() const {  return _misc_flags.is_shared_app_class(); }\n-  \/\/ The UNREGISTERED class loader type\n-  bool is_shared_unregistered_class() const { return _misc_flags.is_shared_unregistered_class(); }\n+  \/\/ Quick checks for the loader that defined this class (without switching on this->class_loader())\n+  bool defined_by_boot_loader() const      { return _misc_flags.defined_by_boot_loader(); }\n+  bool defined_by_platform_loader() const  { return _misc_flags.defined_by_platform_loader(); }\n+  bool defined_by_app_loader() const       { return _misc_flags.defined_by_app_loader(); }\n+  bool defined_by_other_loaders() const    { return _misc_flags.defined_by_other_loaders(); }\n+  void set_class_loader_type()             { _misc_flags.set_class_loader_type(_class_loader_data); }\n@@ -392,6 +392,0 @@\n-#if INCLUDE_CDS\n-  int  shared_class_loader_type() const;\n-  void set_shared_class_loader_type(s2 loader_type) { _misc_flags.set_shared_class_loader_type(loader_type); }\n-  void assign_class_loader_type() { _misc_flags.assign_class_loader_type(_class_loader_data); }\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,17 +40,2 @@\n-#if INCLUDE_CDS\n-void InstanceKlassFlags::set_shared_class_loader_type(s2 loader_type) {\n-  switch (loader_type) {\n-  case ClassLoader::BOOT_LOADER:\n-    _flags |= _misc_is_shared_boot_class;\n-    break;\n-  case ClassLoader::PLATFORM_LOADER:\n-    _flags |= _misc_is_shared_platform_class;\n-    break;\n-  case ClassLoader::APP_LOADER:\n-    _flags |= _misc_is_shared_app_class;\n-    break;\n-  default:\n-    ShouldNotReachHere();\n-    break;\n-  }\n-}\n+void InstanceKlassFlags::set_class_loader_type(const ClassLoaderData* cld) {\n+  assert((_flags & builtin_loader_type_bits()) == 0, \"set only once\");\n@@ -58,1 +43,0 @@\n-void InstanceKlassFlags::assign_class_loader_type(const ClassLoaderData* cld) {\n@@ -60,1 +44,1 @@\n-    set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n+    _flags |= _misc_defined_by_boot_loader;\n@@ -63,1 +47,1 @@\n-    set_shared_class_loader_type(ClassLoader::PLATFORM_LOADER);\n+    _flags |= _misc_defined_by_platform_loader;\n@@ -66,1 +50,1 @@\n-    set_shared_class_loader_type(ClassLoader::APP_LOADER);\n+    _flags |= _misc_defined_by_app_loader;\n@@ -69,1 +53,0 @@\n-#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,3 @@\n-    flag(is_shared_boot_class               , 1 << 7) \/* defining class loader is boot class loader *\/ \\\n-    flag(is_shared_platform_class           , 1 << 8) \/* defining class loader is platform class loader *\/ \\\n-    flag(is_shared_app_class                , 1 << 9) \/* defining class loader is app class loader *\/ \\\n+    flag(defined_by_boot_loader             , 1 << 7) \/* defining class loader is boot class loader *\/ \\\n+    flag(defined_by_platform_loader         , 1 << 8) \/* defining class loader is platform class loader *\/ \\\n+    flag(defined_by_app_loader              , 1 << 9) \/* defining class loader is app class loader *\/ \\\n@@ -90,2 +90,2 @@\n-  u2 shared_loader_type_bits() const {\n-    return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;\n+  u2 builtin_loader_type_bits() const {\n+    return _misc_defined_by_boot_loader|_misc_defined_by_platform_loader|_misc_defined_by_app_loader;\n@@ -114,2 +114,2 @@\n-  bool is_shared_unregistered_class() const {\n-    return (_flags & shared_loader_type_bits()) == 0;\n+  bool defined_by_other_loaders() const {\n+    return (_flags & builtin_loader_type_bits()) == 0;\n@@ -118,1 +118,1 @@\n-  void set_shared_class_loader_type(s2 loader_type);\n+  void set_class_loader_type(const ClassLoaderData* cld);\n@@ -120,1 +120,0 @@\n-  void assign_class_loader_type(const ClassLoaderData* cld);\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-        assert(InstanceKlass::cast(this)->is_shared_unregistered_class(), \"sanity\");\n+        assert(InstanceKlass::cast(this)->defined_by_other_loaders(), \"sanity\");\n@@ -822,1 +822,1 @@\n-        assert(InstanceKlass::cast(k)->is_shared_unregistered_class(), \"sanity\");\n+        assert(InstanceKlass::cast(k)->defined_by_other_loaders(), \"sanity\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  set_adapter_entry(nullptr);\n@@ -420,1 +421,1 @@\n-  if (AOTCodeCache::is_dumping_adapter() && _adapter != nullptr) {\n+  if (CDSConfig::is_dumping_adapters() && _adapter != nullptr) {\n@@ -422,0 +423,1 @@\n+    _adapter = nullptr;\n@@ -1191,1 +1193,1 @@\n-  if (!AOTCodeCache::is_dumping_adapter() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+  if (!CDSConfig::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -378,0 +378,12 @@\n+  product(uint, AutoVectorizationOverrideProfitability, 1, DIAGNOSTIC,      \\\n+          \"Override the auto vectorization profitability heuristics.\"       \\\n+          \"0 = Run auto vectorizer, but abort just before applying\"         \\\n+          \"    vectorization, as though it was not profitable.\"             \\\n+          \"1 = Run auto vectorizer with the default profitability\"          \\\n+          \"    heuristics. This is the default, and hopefully\"              \\\n+          \"    delivers the best performance.\"                              \\\n+          \"2 = Run auto vectorizer, and vectorize even if the\"              \\\n+          \"    profitability heuristics predict that vectorization\"         \\\n+          \"    is not profitable.\")                                         \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2316,8 +2316,4 @@\n-            if (arg_ptn != src_ptn) {\n-              \/\/ Special arraycopy edge:\n-              \/\/ A destination object's field can't have the source object\n-              \/\/ as base since objects escape states are not related.\n-              \/\/ Only escape state of destination object's fields affects\n-              \/\/ escape state of fields in source object.\n-              add_arraycopy(call, es, src_ptn, arg_ptn);\n-            }\n+            \/\/ Special arraycopy edge:\n+            \/\/ Only escape state of destination object's fields affects\n+            \/\/ escape state of fields in source object.\n+            add_arraycopy(call, es, src_ptn, arg_ptn);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -477,0 +477,4 @@\n+        \/\/ Print block index for nodes that are placed in blocks and scheduled locally.\n+        if (block->contains(node)) {\n+          print_prop(\"block_index\", block->find_node(node));\n+        }\n@@ -629,6 +633,2 @@\n-      if (index >= 10) {\n-        print_prop(short_name, \"PA\");\n-      } else {\n-        os::snprintf_checked(buffer, sizeof(buffer), \"P%d\", index);\n-        print_prop(short_name, buffer);\n-      }\n+      os::snprintf_checked(buffer, sizeof(buffer), \"P%d\", index);\n+      print_prop(short_name, buffer);\n@@ -646,3 +646,3 @@\n-        \/\/ max. 2 chars allowed\n-        if (value >= -9 && value <= 99) {\n-          os::snprintf_checked(buffer, sizeof(buffer), \"%d\", value);\n+        \/\/ Only use up to 4 chars and fall back to a generic \"I\" to keep it short.\n+        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), \"%d\", value);\n+        if (written_chars <= 4) {\n@@ -660,3 +660,3 @@\n-        \/\/ max. 2 chars allowed\n-        if (value >= -9 && value <= 99) {\n-          os::snprintf_checked(buffer, sizeof(buffer), JLONG_FORMAT, value);\n+        \/\/ Only use up to 4 chars and fall back to a generic \"L\" to keep it short.\n+        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), JLONG_FORMAT, value);\n+        if (written_chars <= 4) {\n@@ -679,1 +679,5 @@\n-        print_prop(short_name, \"P\");\n+        if (t->is_ptr()->ptr() == TypePtr::Null) {\n+          print_prop(short_name, \"Null\");\n+        } else {\n+          print_prop(short_name, \"P\");\n+        }\n@@ -684,0 +688,2 @@\n+      } else if (t->base() == Type::NarrowOop && t->is_narrowoop() == TypeNarrowOop::NULL_PTR) {\n+        print_prop(short_name, \"Null\");\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -990,2 +990,3 @@\n-      \/\/ A test which leads to an uncommon trap which should be safe.\n-      \/\/ Later this trap will be converted into a trap that restarts\n+      \/\/ A test which leads to an uncommon trap. It is safe to convert the trap\n+      \/\/ into a trap that restarts at the beginning as long as its test does not\n+      \/\/ depend on intermediate results of the candidate chain.\n@@ -996,0 +997,8 @@\n+          \/\/ First check for dependency on a toString that is going away during stacked concats.\n+          if (_multiple &&\n+              ((v1->is_Proj() && is_SB_toString(v1->in(0)) && ctrl_path.member(v1->in(0))) ||\n+               (v2->is_Proj() && is_SB_toString(v2->in(0)) && ctrl_path.member(v2->in(0))))) {\n+            \/\/ iftrue -> if -> bool -> cmpp -> resproj -> tostring\n+            fail = true;\n+            break;\n+          }\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1608,5 +1608,23 @@\n-      \/\/ Length 2 reductions of INT\/LONG do not offer performance benefits\n-      if (((arith_type->basic_type() == T_INT) || (arith_type->basic_type() == T_LONG)) && (size == 2)) {\n-        retValue = false;\n-      } else {\n-        retValue = ReductionNode::implemented(opc, size, arith_type->basic_type());\n+      \/\/ This heuristic predicts that 2-element reductions for INT\/LONG are not\n+      \/\/ profitable. This heuristic was added in JDK-8078563. The argument\n+      \/\/ was that reductions are not just a single instruction, but multiple, and\n+      \/\/ hence it is not directly clear that they are profitable. If we only have\n+      \/\/ two elements per vector, then the performance gains from non-reduction\n+      \/\/ vectors are at most going from 2 scalar instructions to 1 vector instruction.\n+      \/\/ But a 2-element reduction vector goes from 2 scalar instructions to\n+      \/\/ 3 instructions (1 shuffle and two reduction ops).\n+      \/\/ However, this optimization assumes that these reductions stay in the loop\n+      \/\/ which may not be true any more in most cases after the introduction of:\n+      \/\/ PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+      \/\/ Hence, this heuristic has room for improvement.\n+      bool is_two_element_int_or_long_reduction = (size == 2) &&\n+                                                  (arith_type->basic_type() == T_INT ||\n+                                                   arith_type->basic_type() == T_LONG);\n+      if (is_two_element_int_or_long_reduction && AutoVectorizationOverrideProfitability != 2) {\n+#ifndef PRODUCT\n+        if (is_trace_superword_rejections()) {\n+          tty->print_cr(\"\\nPerformance heuristic: 2-element INT\/LONG reduction not profitable.\");\n+          tty->print_cr(\"  Can override with AutoVectorizationOverrideProfitability=2\");\n+        }\n+#endif\n+        return false;\n@@ -1614,0 +1632,1 @@\n+      retValue = ReductionNode::implemented(opc, size, arith_type->basic_type());\n@@ -1759,3 +1778,23 @@\n-    if ((second_pk == nullptr) || (_num_work_vecs == _num_reductions)) {\n-      \/\/ No parent pack or not enough work\n-      \/\/ to cover reduction expansion overhead\n+    if (second_pk == nullptr) {\n+      \/\/ The second input has to be the vector we wanted to reduce,\n+      \/\/ but it was not packed.\n+      return false;\n+    } else if (_num_work_vecs == _num_reductions && AutoVectorizationOverrideProfitability != 2) {\n+      \/\/ This heuristic predicts that the reduction is not profitable.\n+      \/\/ Reduction vectors can be expensive, because they require multiple\n+      \/\/ operations to fold all the lanes together. Hence, vectorizing the\n+      \/\/ reduction is not profitable on its own. Hence, we need a lot of\n+      \/\/ other \"work vectors\" that deliver performance improvements to\n+      \/\/ balance out the performance loss due to reductions.\n+      \/\/ This heuristic is a bit simplistic, and assumes that the reduction\n+      \/\/ vector stays in the loop. But in some cases, we can move the\n+      \/\/ reduction out of the loop, replacing it with a single vector op.\n+      \/\/ See: PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+      \/\/ Hence, this heuristic has room for improvement.\n+#ifndef PRODUCT\n+        if (is_trace_superword_rejections()) {\n+          tty->print_cr(\"\\nPerformance heuristic: not enough vectors in the loop to make\");\n+          tty->print_cr(\"  reduction profitable.\");\n+          tty->print_cr(\"  Can override with AutoVectorizationOverrideProfitability=2\");\n+        }\n+#endif\n@@ -1917,0 +1956,10 @@\n+\n+  if (AutoVectorizationOverrideProfitability == 0) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_any()) {\n+      tty->print_cr(\"\\nForced bailout of vectorization (AutoVectorizationOverrideProfitability=0).\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":57,"deletions":8,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  _saved_interp_only_mode = 0;\n+  _saved_interp_only_mode = false;\n@@ -803,1 +803,1 @@\n-    _saved_interp_only_mode = 0;\n+    _saved_interp_only_mode = false;\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-    size_t nr = g1h->max_regions();\n+    size_t nr = g1h->max_num_regions();\n@@ -2622,0 +2622,5 @@\n+\/\/ Available memory of the host machine (container-aware)\n+WB_ENTRY(jlong, WB_HostAvailableMemory(JNIEnv* env, jobject o))\n+  return os::available_memory();\n+WB_END\n+\n@@ -3097,0 +3102,1 @@\n+  {CC\"hostAvailableMemory\",       CC\"()J\",            (void*)&WB_HostAvailableMemory },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-private:\n+ private:\n@@ -49,1 +49,1 @@\n-public:\n+ public:\n@@ -58,1 +58,1 @@\n-public:\n+ public:\n@@ -66,1 +66,1 @@\n-private:\n+ private:\n@@ -73,1 +73,1 @@\n-private:\n+ private:\n@@ -89,1 +89,1 @@\n-public:\n+ public:\n@@ -99,1 +99,4 @@\n-public:\n+  static address return_pc() { return _return_pc; }\n+  static address return_pc_address() { return (address)&_return_pc; }\n+\n+ public:\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.inline.hpp\"\n+#endif\n@@ -611,0 +614,1 @@\n+  JFR_ONLY(Jfr::check_and_process_sample_request(_thread);)\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+#include \"jfr\/jfr.inline.hpp\"\n@@ -504,0 +505,1 @@\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+}\n@@ -237,0 +238,7 @@\n+\/\/ This is optimized for intra-blob pc adjustments only.\n+void frame::adjust_pc(address newpc) {\n+  assert(_cb != nullptr, \"invariant\");\n+  assert(_cb == CodeCache::find_blob(newpc), \"invariant\");\n+  \/\/ Unsafe to use the is_deoptimized tester after changing pc\n+  _deopt_state = unknown;\n+  _pc = newpc;\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,1 @@\n+  void adjust_pc(address newpc);\n@@ -509,0 +510,12 @@\n+#if INCLUDE_JFR\n+  \/\/ Static helper routines\n+  static address interpreter_bcp(const intptr_t* fp);\n+  static address interpreter_return_address(const intptr_t* fp);\n+  static intptr_t* interpreter_sender_sp(const intptr_t* fp);\n+  static bool is_interpreter_frame_setup_at(const intptr_t* fp, const void* sp);\n+  static intptr_t* sender_sp(intptr_t* fp);\n+  static intptr_t* link(const intptr_t* fp);\n+  static address return_address(const intptr_t* sp);\n+  static intptr_t* fp(const intptr_t* sp);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+  product(bool, UseCompactObjectHeaders, false,                             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-  Log(gc, heap, exit) log;\n+  Log(gc, exit) log;\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -972,1 +972,1 @@\n-    tlab().retire();\n+    retire_tlab();\n@@ -1046,1 +1046,1 @@\n-    tlab().retire();\n+    retire_tlab();\n@@ -1082,1 +1082,0 @@\n-  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,0 @@\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n@@ -231,2 +230,0 @@\n-  inline void set_trace_flag();\n-  inline void clear_trace_flag();\n@@ -235,1 +232,0 @@\n-  bool is_trace_suspend()      { return (_suspend_flags & _trace_flag) != 0; }\n@@ -755,1 +751,1 @@\n-    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+    return (_suspend_flags & _obj_deopt) != 0;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,6 +60,0 @@\n-inline void JavaThread::set_trace_flag() {\n-  set_suspend_flag(_trace_flag);\n-}\n-inline void JavaThread::clear_trace_flag() {\n-  clear_suspend_flag(_trace_flag);\n-}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-Monitor* JfrThreadSampler_lock        = nullptr;\n@@ -285,1 +284,0 @@\n-  MUTEX_DEFN(JfrThreadSampler_lock           , PaddedMonitor, nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-extern Monitor* JfrThreadSampler_lock;           \/\/ used to suspend\/resume JFR thread sampler\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -626,0 +626,1 @@\n+  static intptr_t*  fetch_bcp_from_context(const void* ucVoid);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.inline.hpp\"\n+#endif\n@@ -97,1 +100,1 @@\n-    bool armed = global_poll() || thread->handshake_state()->has_operation();\n+    bool armed = has_pending_safepoint(thread);\n@@ -123,1 +126,1 @@\n-    if (!armed && (global_poll() || thread->handshake_state()->has_operation())) {\n+    if (!armed && has_pending_safepoint(thread)) {\n@@ -142,0 +145,1 @@\n+    JFR_ONLY(Jfr::check_and_process_sample_request(thread);)\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,2 @@\n+  static inline bool has_pending_safepoint(JavaThread* thread);\n+\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.inline.hpp\"\n+#endif\n@@ -59,0 +62,4 @@\n+inline bool SafepointMechanism::has_pending_safepoint(JavaThread* thread) {\n+  return global_poll() || thread->handshake_state()->has_operation() JFR_ONLY(|| Jfr::has_sample_request(thread));\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-#include \"jfr\/jfr.hpp\"\n+#include \"jfr\/jfr.inline.hpp\"\n@@ -449,1 +449,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n@@ -2528,1 +2528,1 @@\n-  if (!AOTCodeCache::is_dumping_adapter()) {\n+  if (AOTCodeCache::is_using_adapter()) {\n@@ -2637,1 +2637,1 @@\n-  if (!_aot_adapter_handler_table.empty()) {\n+  if (AOTCodeCache::is_using_adapter() && !_aot_adapter_handler_table.empty()) {\n@@ -3435,0 +3435,1 @@\n+  assert(AOTCodeCache::is_using_adapter(), \"AOT adapters code should be available\");\n@@ -3761,1 +3762,1 @@\n-\n+  JFR_ONLY(Jfr::check_and_process_sample_request(current);)\n@@ -3856,4 +3857,6 @@\n-  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n-    return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n-  };\n-  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  if (AOTCodeCache::is_using_adapter()) {\n+    auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+      return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n+    };\n+    _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  }\n@@ -3883,12 +3886,13 @@\n-  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n-    if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n-      found = true;\n-      st->print(\"Adapter for signature: \");\n-      handler->print_adapter_on(st);\n-      return true;\n-    } else {\n-      return false; \/\/ keep looking\n-\n-    }\n-  };\n-  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  if (AOTCodeCache::is_using_adapter()) {\n+    auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+      if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n+        found = true;\n+        st->print(\"Adapter for signature: \");\n+        handler->print_adapter_on(st);\n+        return true;\n+      } else {\n+        return false; \/\/ keep looking\n+      }\n+    };\n+    _aot_adapter_handler_table.iterate(findblob_archived_table);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-#if defined(__SOFTFP__) || defined(PPC)\n+#if defined(__SOFTFP__)\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/suspendedThreadTask.hpp\"\n-\n-void SuspendedThreadTask::run() {\n-  internal_do_task();\n-  _done = true;\n-}\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,5 +31,1 @@\n-public:\n-  SuspendedThreadTaskContext(Thread* thread, void *ucontext) : _thread(thread), _ucontext(ucontext) {}\n-  Thread* thread() const { return _thread; }\n-  void* ucontext() const { return _ucontext; }\n-private:\n+ private:\n@@ -38,0 +34,4 @@\n+ public:\n+  SuspendedThreadTaskContext(Thread* thread, void* ucontext) : _thread(thread), _ucontext(ucontext) {}\n+  Thread* thread() const { return _thread; }\n+  void* ucontext() const { return _ucontext; }\n@@ -41,8 +41,1 @@\n-public:\n-  SuspendedThreadTask(Thread* thread) : _thread(thread), _done(false) {}\n-  void run();\n-  virtual void do_task(const SuspendedThreadTaskContext& context) = 0;\n-protected:\n-  ~SuspendedThreadTask() {}\n-private:\n-  void internal_do_task();\n+ private:\n@@ -50,1 +43,7 @@\n-  bool _done;\n+  void internal_do_task();\n+ protected:\n+  ~SuspendedThreadTask() {}\n+ public:\n+  SuspendedThreadTask(Thread* thread) : _thread(thread) {}\n+  void run() { internal_do_task(); }\n+  virtual void do_task(const SuspendedThreadTaskContext& context) = 0;\n","filename":"src\/hotspot\/share\/runtime\/suspendedThreadTask.hpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -157,0 +157,19 @@\n+void Thread::retire_tlab(ThreadLocalAllocStats* stats) {\n+  \/\/ Sampling and serviceability support\n+  if (tlab().end() != nullptr) {\n+    incr_allocated_bytes(tlab().used_bytes());\n+    heap_sampler().retire_tlab(tlab().top());\n+  }\n+\n+  \/\/ Retire the TLAB\n+  tlab().retire(stats);\n+}\n+\n+void Thread::fill_tlab(HeapWord* start, size_t pre_reserved, size_t new_size) {\n+  \/\/ Thread allocation sampling support\n+  heap_sampler().set_tlab_top_at_sample_start(start);\n+\n+  \/\/ Fill the TLAB\n+  tlab().fill(start, start + pre_reserved, new_size);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -312,0 +312,1 @@\n+  virtual bool is_JfrRecorder_thread() const         { return false; }\n@@ -405,0 +406,2 @@\n+  void retire_tlab(ThreadLocalAllocStats* stats = nullptr);\n+  void fill_tlab(HeapWord* start, size_t pre_reserved, size_t new_size);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-  _bytes_until_sample = interval;\n+  _sample_threshold = interval;\n@@ -402,1 +402,1 @@\n-void ThreadHeapSampler::pick_next_sample(size_t overflowed_bytes) {\n+void ThreadHeapSampler::pick_next_sample() {\n@@ -411,1 +411,1 @@\n-    _bytes_until_sample = 0;\n+    _sample_threshold = 0;\n@@ -418,7 +418,12 @@\n-void ThreadHeapSampler::check_for_sampling(oop obj, size_t allocation_size, size_t bytes_since_allocation) {\n-  size_t total_allocated_bytes = bytes_since_allocation + allocation_size;\n-\n-  \/\/ If not yet time for a sample, skip it.\n-  if (total_allocated_bytes < _bytes_until_sample) {\n-    _bytes_until_sample -= total_allocated_bytes;\n-    return;\n+#ifndef PRODUCT\n+void ThreadHeapSampler::log_sample_decision(HeapWord* tlab_top) {\n+  LogTarget(Debug, gc, tlab) log;\n+  if (log.is_enabled()) {\n+    const bool should_sample = bytes_since_last_sample(tlab_top) >= _sample_threshold;\n+    log_debug(gc, tlab)(\"Should sample: %s sample threshold: %zu total: %zu tlab: %zu current tlab: %zu outside tlab: %zu\",\n+                        should_sample ? \"yes\" : \"no \",\n+                        _sample_threshold,\n+                        bytes_since_last_sample(tlab_top),\n+                        tlab_bytes_since_last_sample(tlab_top),\n+                        current_tlab_bytes_since_last_sample(tlab_top),\n+                        outside_tlab_bytes_since_last_sample());\n@@ -426,0 +431,2 @@\n+}\n+#endif\n@@ -427,0 +434,1 @@\n+void ThreadHeapSampler::sample(oop obj, HeapWord* tlab_top) {\n@@ -429,2 +437,3 @@\n-  size_t overflow_bytes = total_allocated_bytes - _bytes_until_sample;\n-  pick_next_sample(overflow_bytes);\n+  pick_next_sample();\n+\n+  reset_after_sample(tlab_top);\n","filename":"src\/hotspot\/share\/runtime\/threadHeapSampler.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -33,1 +34,14 @@\n-  size_t _bytes_until_sample;\n+  \/\/ Amount of bytes to allocate before taking the next sample\n+  size_t _sample_threshold;\n+\n+  \/\/ The TLAB top address when the last sampling happened, or\n+  \/\/ TLAB start if a new TLAB is allocated\n+  HeapWord* _tlab_top_at_sample_start;\n+\n+  \/\/ The accumulated amount of allocated bytes in a TLAB since the last sampling\n+  \/\/ excluding the amount between _tlab_sample_start and top\n+  size_t _accumulated_tlab_bytes_since_sample;\n+\n+  \/\/ The accumulated amount of allocated bytes outside TLABs since last sample point\n+  size_t _accumulated_outside_tlab_bytes_since_sample;\n+\n@@ -40,1 +54,1 @@\n-  void pick_next_sample(size_t overflowed_bytes = 0);\n+  void pick_next_sample();\n@@ -45,0 +59,19 @@\n+  size_t current_tlab_bytes_since_last_sample(HeapWord* tlab_top)  const {\n+    \/\/ Both can be nullptr if there's not active TLAB, but otherwise\n+    \/\/ they both should be non-null.\n+    assert((tlab_top != nullptr) == (_tlab_top_at_sample_start != nullptr),\n+           \"Both should either be uninitialized or initialized \"\n+           \"tlab_top: \" PTR_FORMAT \" _tlab_top_at_sample_start: \" PTR_FORMAT,\n+           p2i(tlab_top), p2i(_tlab_top_at_sample_start));\n+\n+    return pointer_delta(tlab_top, _tlab_top_at_sample_start, 1);\n+  }\n+\n+  size_t tlab_bytes_since_last_sample(HeapWord* tlab_top) const {\n+    return _accumulated_tlab_bytes_since_sample + current_tlab_bytes_since_last_sample(tlab_top);\n+  }\n+\n+  size_t outside_tlab_bytes_since_last_sample() const {\n+    return _accumulated_outside_tlab_bytes_since_sample;\n+  }\n+\n@@ -46,1 +79,5 @@\n-  ThreadHeapSampler() {\n+  ThreadHeapSampler() :\n+      _sample_threshold(0),\n+      _tlab_top_at_sample_start(nullptr),\n+      _accumulated_tlab_bytes_since_sample(0),\n+      _accumulated_outside_tlab_bytes_since_sample(0) {\n@@ -52,1 +89,1 @@\n-    \/\/ Call this after _rnd is initialized to initialize _bytes_until_sample.\n+    \/\/ Call this after _rnd is initialized to initialize _sample_threshold.\n@@ -56,1 +93,34 @@\n-  size_t bytes_until_sample()                    { return _bytes_until_sample;   }\n+  size_t bytes_since_last_sample(HeapWord* tlab_top) const {\n+    return tlab_bytes_since_last_sample(tlab_top) +\n+           outside_tlab_bytes_since_last_sample();\n+  }\n+\n+  size_t bytes_until_sample(HeapWord* tlab_top) const {\n+    const size_t since_last_sample = bytes_since_last_sample(tlab_top);\n+    return _sample_threshold - MIN2(since_last_sample, _sample_threshold);\n+  }\n+\n+  bool should_sample(HeapWord* tlab_top) const {\n+    return bytes_until_sample(tlab_top) == 0;\n+  }\n+\n+  void set_tlab_top_at_sample_start(HeapWord* tlab_top) {\n+    _tlab_top_at_sample_start = tlab_top;\n+  }\n+\n+  void reset_after_sample(HeapWord* tlab_top) {\n+    _tlab_top_at_sample_start = tlab_top;\n+    _accumulated_tlab_bytes_since_sample = 0;\n+    _accumulated_outside_tlab_bytes_since_sample = 0;\n+  }\n+\n+  void retire_tlab(HeapWord* tlab_top) {\n+    _accumulated_tlab_bytes_since_sample += current_tlab_bytes_since_last_sample(tlab_top);\n+    _tlab_top_at_sample_start = nullptr;\n+  }\n+\n+  void inc_outside_tlab_bytes(size_t size) {\n+    _accumulated_outside_tlab_bytes_since_sample += size;\n+  }\n+\n+  void log_sample_decision(HeapWord* tlab_top) PRODUCT_RETURN;\n@@ -58,1 +128,1 @@\n-  void check_for_sampling(oop obj, size_t size_in_bytes, size_t bytes_allocated_before);\n+  void sample(oop obj, HeapWord* tlab_top);\n","filename":"src\/hotspot\/share\/runtime\/threadHeapSampler.hpp","additions":77,"deletions":7,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -839,1 +839,1 @@\n-    JVMCI::initialize_compiler(CHECK_JNI_ERR);\n+    JVMCI::initialize_compiler_in_create_vm(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -417,1 +417,0 @@\n-  MetaspaceUtils::print_on(output());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -411,0 +411,3 @@\n+  GrowableArrayWithAllocator(E* data, int capacity, int initial_len) :\n+    GrowableArrayView<E>(data, capacity, initial_len) {}\n+\n@@ -792,0 +795,9 @@\n+  \/\/ This constructor performs no default initialization, so be careful.\n+  GrowableArray(int initial_capacity, int initial_len, MemTag mem_tag) :\n+    GrowableArrayWithAllocator<E, GrowableArray>(\n+      allocate(initial_capacity, mem_tag),\n+      initial_capacity, initial_len),\n+    _metadata(mem_tag) {\n+    init_checks();\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1206,1 +1206,0 @@\n-      MetaspaceUtils::print_on(st);\n@@ -1223,0 +1222,1 @@\n+    MetaspaceUtils::print_on(st);\n@@ -1394,3 +1394,3 @@\n-  \/\/ Take heap lock over both heap and GC printing so that information is\n-  \/\/ consistent.\n-  {\n+  \/\/ Take heap lock over heap, GC and metaspace printing so that information\n+  \/\/ is consistent.\n+  if (Universe::is_fully_initialized()) {\n@@ -1401,2 +1401,1 @@\n-    if (Universe::is_fully_initialized()) {\n-      GCLogPrecious::print_on_error(st);\n+    GCLogPrecious::print_on_error(st);\n@@ -1404,0 +1403,1 @@\n+    {\n@@ -1407,1 +1407,0 @@\n-      MetaspaceUtils::print_on(st);\n@@ -1413,3 +1412,2 @@\n-    if (Universe::is_fully_initialized()) {\n-      Universe::heap()->print_gc_on(st);\n-      st->cr();\n+    Universe::heap()->print_gc_on(st);\n+    st->cr();\n@@ -1417,4 +1415,2 @@\n-      st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n-      st->cr();\n-    }\n-  }\n+    st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n+    st->cr();\n@@ -1422,1 +1418,1 @@\n-  \/\/ STEP(\"printing metaspace information\")\n+    \/\/ STEP(\"printing metaspace information\")\n@@ -1424,1 +1420,0 @@\n-  if (Universe::is_fully_initialized()) {\n@@ -1426,0 +1421,1 @@\n+    MetaspaceUtils::print_on(st);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.Buffer;\n@@ -913,1 +914,1 @@\n-                \/\/ The use of DirectBuffer::address below need not be guarded as\n+                \/\/ The use of addresses below need not be guarded as\n@@ -919,2 +920,2 @@\n-                long srcaddr = dsrc.address();\n-                long dstaddr = ddst.address();\n+                long srcaddr = NIO_ACCESS.getBufferAddress(src);\n+                long dstaddr = NIO_ACCESS.getBufferAddress(dst);\n@@ -925,1 +926,1 @@\n-                    srcaddr = ((DirectBuffer) dsrc.attachment()).address();\n+                    srcaddr = NIO_ACCESS.getBufferAddress((Buffer) dsrc.attachment());\n@@ -932,1 +933,1 @@\n-                    dstaddr = ((DirectBuffer) ddst.attachment()).address();\n+                    dstaddr = NIO_ACCESS.getBufferAddress((Buffer) ddst.attachment());\n@@ -950,2 +951,2 @@\n-                if (((DirectBuffer) src).address() - srcaddr + src.position() >=\n-                    ((DirectBuffer) dst).address() - dstaddr + dst.position()) {\n+                if (NIO_ACCESS.getBufferAddress(src) - srcaddr + src.position() >=\n+                    NIO_ACCESS.getBufferAddress(dst) - dstaddr + dst.position()) {\n@@ -1605,1 +1606,1 @@\n-                                ((DirectBuffer)dst).address(),\n+                                NIO_ACCESS.getBufferAddress(dst),\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4062,1 +4062,1 @@\n-        return isArray() ? componentType : null;\n+        return getComponentType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-    static final char[] digits = {\n+    @Stable\n+    static final byte[] digits = {\n@@ -185,1 +186,1 @@\n-                buf[charPos--] = (byte)digits[-(i % radix)];\n+                buf[charPos--] = digits[-(i % radix)];\n@@ -188,1 +189,1 @@\n-            buf[charPos] = (byte)digits[-i];\n+            buf[charPos] = digits[-i];\n@@ -405,1 +406,1 @@\n-            buf[--charPos] = (byte)Integer.digits[val & mask];\n+            buf[--charPos] = Integer.digits[val & mask];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                buf[charPos--] = (byte)Integer.digits[(int)(-(i % radix))];\n+                buf[charPos--] = Integer.digits[(int)(-(i % radix))];\n@@ -174,1 +174,1 @@\n-            buf[charPos] = (byte)Integer.digits[(int)(-i)];\n+            buf[charPos] = Integer.digits[(int)(-i)];\n@@ -436,1 +436,1 @@\n-            buf[--charPos] = (byte)Integer.digits[((int) val) & mask];\n+            buf[--charPos] = Integer.digits[((int) val) & mask];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2829,1 +2829,1 @@\n-         *     {@linkplain Module#reads reads} {@code M0} and the type is\n+         *     {@linkplain Module#canRead(Module)}  reads} {@code M0} and the type is\n@@ -2832,1 +2832,1 @@\n-         *     {@linkplain Module#reads reads} {@code M1} and the type is\n+         *     {@linkplain Module#canRead(Module)}  reads} {@code M1} and the type is\n@@ -4897,1 +4897,1 @@\n-     * @see MethodHandles#primitiveZero\n+     * @see MethodHandles#zero(Class)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2023,1 +2023,1 @@\n-         * each {@link Provides#providers provider} (or provider factory) is\n+         * each {@link Provides#providers() provider} (or provider factory) is\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -549,1 +549,5 @@\n-                    if (unconditionalExactnessCheck(selectorType, classLabel)) {\n+                    if (isNotValidPair(selectorType, caseLabel)){\n+                        cb.goto_(next);\n+                        continue;\n+                    }\n+                    else if (unconditionalExactnessCheck(selectorType, classLabel)) {\n@@ -720,0 +724,5 @@\n+    private static boolean isNotValidPair(Class<?> selectorType, Object caseLabel) {\n+        return (selectorType == boolean.class && caseLabel != boolean.class && caseLabel != Boolean.class) ||\n+               (selectorType != boolean.class && selectorType.isPrimitive() && (caseLabel == boolean.class || caseLabel == Boolean.class));\n+    }\n+\n@@ -772,5 +781,5 @@\n-                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n-                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n-                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n-                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n-                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n+                (targetType.isPrimitive() && selectorType.isPrimitive() &&\n+                    (selectorWrapper.isStrictSubRangeOf(targetWrapper) &&\n+                            !((selectorType.equals(byte.class) && targetType.equals(char.class)) ||\n+                              (selectorType.equals(int.class)  && targetType.equals(float.class)) ||\n+                              (selectorType.equals(long.class) && (targetType.equals(double.class) || targetType.equals(float.class))))))) return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -483,10 +483,0 @@\n-    \/**\n-     * The value 0.1, with a scale of 1.\n-     *\/\n-    private static final BigDecimal ONE_TENTH = valueOf(1L, 1);\n-\n-    \/**\n-     * The value 0.5, with a scale of 1.\n-     *\/\n-    private static final BigDecimal ONE_HALF = valueOf(5L, 1);\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -429,2 +429,2 @@\n-     * Returns the URL that resulted in this\n-     * request for authentication.\n+     * Returns the URL that resulted in this request for authentication.\n+     * If the corresponding request does not specify a URL, this method returns null.\n@@ -434,1 +434,1 @@\n-     * @return the requesting URL\n+     * @return the requesting URL, or null if not available.\n","filename":"src\/java.base\/share\/classes\/java\/net\/Authenticator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-     * @see #isBound\n+     * @see #isBound()\n@@ -1615,1 +1615,1 @@\n-     * @see #isClosed\n+     * @see #isClosed()\n@@ -1645,1 +1645,1 @@\n-     * @see #isInputShutdown\n+     * @see #isInputShutdown()\n@@ -1675,1 +1675,1 @@\n-     * @see #isOutputShutdown\n+     * @see #isOutputShutdown()\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,2 +260,3 @@\n-     *          or the {@code env} parameter does not contain properties required\n-     *          by the provider, or a property value is invalid\n+     *          or if the {@code env} parameter does not contain properties\n+     *          required by the provider, contains an invalid combination of\n+     *          properties and values, or contains an invalid property value\n@@ -299,2 +300,3 @@\n-     *          or the {@code env} parameter does not contain properties required\n-     *          by the provider, or a property value is invalid\n+     *          or if the {@code env} parameter does not contain properties\n+     *          required by the provider, contains an invalid combination of\n+     *          properties and values, or contains an invalid property value\n@@ -403,0 +405,4 @@\n+     * @throws  IllegalArgumentException\n+     *          if the {@code env} parameter does not contain properties\n+     *          required by the provider, contains an invalid combination of\n+     *          properties and values, or contains an invalid property value\n@@ -479,0 +485,4 @@\n+     * @throws  IllegalArgumentException\n+     *          if the {@code env} parameter does not contain properties\n+     *          required by the provider, contains an invalid combination of\n+     *          properties and values, or contains an invalid property value\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/FileSystems.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1694,1 +1694,1 @@\n-        String subtag = tag.getLanguage();\n+        String subtag = tag.language();\n@@ -1699,1 +1699,1 @@\n-        subtag = tag.getScript();\n+        subtag = tag.script();\n@@ -1705,1 +1705,1 @@\n-        subtag = tag.getRegion();\n+        subtag = tag.region();\n@@ -1711,1 +1711,1 @@\n-        List<String>subtags = tag.getVariants();\n+        List<String>subtags = tag.variants();\n@@ -1718,1 +1718,1 @@\n-        subtags = tag.getExtensions();\n+        subtags = tag.extensions();\n@@ -1724,1 +1724,1 @@\n-        subtag = tag.getPrivateuse();\n+        subtag = tag.privateuse();\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.internal.util.HexDigits;\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -79,1 +79,0 @@\n-\n@@ -465,5 +464,0 @@\n-        int i0 = (int) (mostSigBits >> 32);\n-        int i1 = (int) mostSigBits;\n-        int i2 = (int) (leastSigBits >> 32);\n-        int i3 = (int) leastSigBits;\n-\n@@ -471,2 +465,0 @@\n-        HexDigits.put4(buf, 0, i0 >> 16);\n-        HexDigits.put4(buf, 4, i0);\n@@ -474,1 +466,0 @@\n-        HexDigits.put4(buf, 9, i1 >> 16);\n@@ -476,1 +467,0 @@\n-        HexDigits.put4(buf, 14, i1);\n@@ -478,1 +468,0 @@\n-        HexDigits.put4(buf, 19, i2 >> 16);\n@@ -480,3 +469,13 @@\n-        HexDigits.put4(buf, 24, i2);\n-        HexDigits.put4(buf, 28, i3 >> 16);\n-        HexDigits.put4(buf, 32, i3);\n+\n+        \/\/ Although the UUID byte ordering is defined to be big-endian, ByteArrayLittleEndian is used here to optimize\n+        \/\/ for the most common architectures. hex8 reverses the order internally.\n+        ByteArrayLittleEndian.setLong(buf, 0, hex8(mostSigBits >>> 32));\n+        long x0 = hex8(mostSigBits);\n+        ByteArrayLittleEndian.setInt(buf, 9, (int) x0);\n+        ByteArrayLittleEndian.setInt(buf, 14, (int) (x0 >>> 32));\n+\n+        long x1 = hex8(leastSigBits >>> 32);\n+        ByteArrayLittleEndian.setInt(buf, 19, (int) (x1));\n+        ByteArrayLittleEndian.setInt(buf, 24, (int) (x1 >>> 32));\n+        ByteArrayLittleEndian.setLong(buf, 28, hex8(leastSigBits));\n+\n@@ -490,0 +489,77 @@\n+    \/**\n+     * Efficiently converts 8 hexadecimal digits to their ASCII representation using SIMD-style vector operations.\n+     * This method processes multiple digits in parallel by treating a long value as eight 8-bit lanes,\n+     * achieving significantly better performance compared to traditional loop-based conversion.\n+     *\n+     * <p>The conversion algorithm works as follows:\n+     * <pre>\n+     * 1. Input expansion: Each 4-bit hex digit is expanded to 8 bits\n+     * 2. Vector processing:\n+     *    - Add 6 to each digit: triggers carry flag for a-f digits\n+     *    - Mask with 0x10 pattern to isolate carry flags\n+     *    - Calculate ASCII adjustment: (carry << 1) + (carry >> 1) - (carry >> 4)\n+     *    - Add ASCII '0' base (0x30) and original value\n+     * 3. Byte order adjustment for final output\n+     * <\/pre>\n+     *\n+     * <p>Performance characteristics:\n+     * <ul>\n+     *   <li>Processes 8 digits in parallel using vector operations\n+     *   <li>Avoids branching and loops completely\n+     *   <li>Uses only integer arithmetic and bit operations\n+     *   <li>Constant time execution regardless of input values\n+     * <\/ul>\n+     *\n+     * <p>ASCII conversion mapping:\n+     * <ul>\n+     *   <li>Digits 0-9 → ASCII '0'-'9' (0x30-0x39)\n+     *   <li>Digits a-f → ASCII 'a'-'f' (0x61-0x66)\n+     * <\/ul>\n+     *\n+     * @param input A long containing 8 hex digits (each digit must be 0-15)\n+     * @return A long containing 8 ASCII bytes representing the hex digits\n+     *\n+     * @implNote The implementation leverages CPU vector processing capabilities through\n+     *           long integer operations. The algorithm is based on the observation that\n+     *           ASCII hex digits have a specific pattern that can be computed efficiently\n+     *           using carry flag manipulation.\n+     *\n+     * @example\n+     * <pre>\n+     * Input:  0xABCDEF01\n+     * Output: 3130666564636261 ('1','0','f','e','d','c','b','a' in ASCII)\n+     * <\/pre>\n+     *\n+     * @see Long#reverseBytes(long)\n+     *\/\n+    private static long hex8(long i) {\n+        \/\/ Expand each 4-bit group into 8 bits, spreading them out in the long value: 0xAABBCCDD -> 0xA0A0B0B0C0C0D0D\n+        i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+\n+        \/*\n+         * This method efficiently converts 8 hexadecimal digits simultaneously using vector operations\n+         * The algorithm works as follows:\n+         *\n+         * For input values 0-15:\n+         * - For digits 0-9: converts to ASCII '0'-'9' (0x30-0x39)\n+         * - For digits 10-15: converts to ASCII 'a'-'f' (0x61-0x66)\n+         *\n+         * The conversion process:\n+         * 1. Add 6 to each 4-bit group: i + 0x0606_0606_0606_0606L\n+         * 2. Mask to get the adjustment flags: & 0x1010_1010_1010_1010L\n+         * 3. Calculate the offset: (m << 1) + (m >> 1) - (m >> 4)\n+         *    - For 0-9: offset = 0\n+         *    - For a-f: offset = 39 (to bridge the gap between '9' and 'a' in ASCII)\n+         * 4. Add ASCII '0' base (0x30) and the original value\n+         * 5. Reverse byte order for correct positioning\n+         *\/\n+        long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+\n+        \/\/ Calculate final ASCII values and reverse bytes for proper ordering\n+        return Long.reverseBytes(\n+                ((m << 1) + (m >> 1) - (m >> 4))\n+                + 0x3030_3030_3030_3030L \/\/ Add ASCII '0' base to all digits\n+                + i                      \/\/ Add original values\n+        );\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":91,"deletions":15,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3455,1 +3455,1 @@\n-            lockRunState();\n+            long isShutdown = lockRunState() & SHUTDOWN;\n@@ -3457,1 +3457,1 @@\n-                if ((ds = delayScheduler) == null) {\n+                if (isShutdown == 0L && (ds = delayScheduler) == null) {\n@@ -3465,1 +3465,0 @@\n-                \/\/ exceptions on start passed to (external) callers\n@@ -3467,4 +3466,13 @@\n-                if ((ctr = container) != null)\n-                    ctr.start(ds);\n-                else\n-                    ds.start();\n+                try {\n+                    if ((ctr = container) != null)\n+                        ctr.start(ds);\n+                    else\n+                        ds.start();\n+                } catch (RuntimeException | Error ex) { \/\/ back out\n+                    lockRunState();\n+                    ds = delayScheduler = null;\n+                    unlockRunState();\n+                    tryTerminate(false, false);\n+                    if (ex instanceof Error)\n+                        throw ex;\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n- * true if the task was cancelled (in which case {@link #getException}\n+ * true if the task was cancelled (in which case {@link #getException()}\n@@ -138,1 +138,1 @@\n- * #getException} will return either the encountered exception or\n+ * #getException()} will return either the encountered exception or\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+        this.state = ST_NEW;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScopeImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-            sink.begin(size);\n+            sink.begin(-1); \/\/ GathererOp does not know the size of the output\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/GathererOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -103,1 +102,1 @@\n-                adler = updateByteBuffer(adler, ((DirectBuffer)buffer).address(), pos, rem);\n+                adler = updateByteBuffer(adler, NIO_ACCESS.getBufferAddress(buffer), pos, rem);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -102,1 +101,1 @@\n-                crc = updateByteBuffer(crc, ((DirectBuffer)buffer).address(), pos, rem);\n+                crc = updateByteBuffer(crc, NIO_ACCESS.getBufferAddress(buffer), pos, rem);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -33,1 +34,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -179,1 +179,1 @@\n-                crc = updateDirectByteBuffer(crc, ((DirectBuffer)buffer).address(),\n+                crc = updateDirectByteBuffer(crc, NIO_ACCESS.getBufferAddress(buffer),\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -325,1 +324,1 @@\n-                    long address = ((DirectBuffer) dictionary).address();\n+                    long address = NIO_ACCESS.getBufferAddress(dictionary);\n@@ -580,1 +579,1 @@\n-                        long inputAddress = ((DirectBuffer) input).address();\n+                        long inputAddress = NIO_ACCESS.getBufferAddress(input);\n@@ -704,1 +703,1 @@\n-                        long outputAddress = ((DirectBuffer) output).address();\n+                        long outputAddress = NIO_ACCESS.getBufferAddress(output);\n@@ -726,1 +725,1 @@\n-                        long inputAddress = ((DirectBuffer) input).address();\n+                        long inputAddress = NIO_ACCESS.getBufferAddress(input);\n@@ -730,1 +729,1 @@\n-                                long outputAddress = outputPos + ((DirectBuffer) output).address();\n+                                long outputAddress = outputPos + NIO_ACCESS.getBufferAddress(output);\n@@ -755,1 +754,1 @@\n-                            long outputAddress = ((DirectBuffer) output).address();\n+                            long outputAddress = NIO_ACCESS.getBufferAddress(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -246,1 +245,1 @@\n-                    long address = ((DirectBuffer) dictionary).address();\n+                    long address = NIO_ACCESS.getBufferAddress(dictionary);\n@@ -369,1 +368,1 @@\n-                                long inputAddress = ((DirectBuffer) input).address();\n+                                long inputAddress = NIO_ACCESS.getBufferAddress(input);\n@@ -506,1 +505,1 @@\n-                                long outputAddress = ((DirectBuffer) output).address();\n+                                long outputAddress = NIO_ACCESS.getBufferAddress(output);\n@@ -531,1 +530,1 @@\n-                                long inputAddress = ((DirectBuffer) input).address();\n+                                long inputAddress = NIO_ACCESS.getBufferAddress(input);\n@@ -535,1 +534,1 @@\n-                                        long outputAddress = ((DirectBuffer) output).address();\n+                                        long outputAddress = NIO_ACCESS.getBufferAddress(output);\n@@ -558,1 +557,1 @@\n-                                    long outputAddress = ((DirectBuffer) output).address();\n+                                    long outputAddress = NIO_ACCESS.getBufferAddress(output);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -710,2 +710,2 @@\n-     * a matching decapsulator, it will be included as a byte array in the\n-     * {@link Encapsulated#params} field inside the encapsulation output.\n+     * a matching decapsulator, it will be included as a byte array returned by the\n+     * {@link Encapsulated#params()} method within the encapsulation output.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.access.JavaLangAccess;\n@@ -39,2 +38,0 @@\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n@@ -115,82 +112,0 @@\n-\n-    \/**\n-     * Insert the unsigned 2-byte integer into the buffer as 4 hexadecimal digit ASCII bytes,\n-     * only least significant 16 bits of {@code value} are used.\n-     * @param buffer byte buffer to copy into\n-     * @param index insert point\n-     * @param value to convert\n-     *\/\n-    public static void put4(byte[] buffer, int index, int value) {\n-        \/\/ Prepare an int value so C2 generates a 4-byte write instead of two 2-byte writes\n-        int v = (DIGITS[value & 0xff] << 16) | DIGITS[(value >> 8) & 0xff];\n-        buffer[index]     = (byte)  v;\n-        buffer[index + 1] = (byte) (v >> 8);\n-        buffer[index + 2] = (byte) (v >> 16);\n-        buffer[index + 3] = (byte) (v >> 24);\n-    }\n-\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param index      insert point + 1\n-     * @param buffer     byte buffer to copy into\n-     *\n-     * @return the last index used\n-     *\/\n-    public static int getCharsLatin1(long value, int index, byte[] buffer) {\n-        while ((value & ~0xFF) != 0) {\n-            short pair = DIGITS[((int) value) & 0xFF];\n-            buffer[--index] = (byte)(pair >> 8);\n-            buffer[--index] = (byte)(pair);\n-            value >>>= 8;\n-        }\n-\n-        int digits = DIGITS[(int) (value & 0xFF)];\n-        buffer[--index] = (byte) (digits >> 8);\n-\n-        if (0xF < value) {\n-            buffer[--index] = (byte) (digits & 0xFF);\n-        }\n-\n-        return index;\n-    }\n-\n-    \/**\n-     * Insert digits for long value in buffer from high index to low index.\n-     *\n-     * @param value      value to convert\n-     * @param index      insert point + 1\n-     * @param buffer     byte buffer to copy into\n-     *\n-     * @return the last index used\n-     *\/\n-    public static int getCharsUTF16(long value, int index, byte[] buffer) {\n-        while ((value & ~0xFF) != 0) {\n-            int pair = (int) DIGITS[((int) value) & 0xFF];\n-            JLA.uncheckedPutCharUTF16(buffer, --index, pair >> 8);\n-            JLA.uncheckedPutCharUTF16(buffer, --index, pair & 0xFF);\n-            value >>>= 8;\n-        }\n-\n-        int digits = DIGITS[(int) (value & 0xFF)];\n-        JLA.uncheckedPutCharUTF16(buffer, --index, (byte) (digits >> 8));\n-\n-        if (0xF < value) {\n-            JLA.uncheckedPutCharUTF16(buffer, --index, (byte) (digits & 0xFF));\n-        }\n-\n-        return index;\n-    }\n-\n-    \/**\n-     * Calculate the number of digits required to represent the long.\n-     *\n-     * @param value value to convert\n-     *\n-     * @return number of digits\n-     *\/\n-    public static int stringSize(long value) {\n-        return value == 0 ? 1 :\n-                67 - Long.numberOfLeadingZeros(value) >> 2;\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-    private static void releaseScope(ByteBuffer bb) {\n+    static void releaseScope(ByteBuffer bb) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,2 +350,2 @@\n-        if (!langtag.getExtlangs().isEmpty()) {\n-            language = langtag.getExtlangs().get(0);\n+        if (!langtag.extlangs().isEmpty()) {\n+            language = langtag.extlangs().get(0);\n@@ -353,1 +353,1 @@\n-            String lang = langtag.getLanguage();\n+            String lang = langtag.language();\n@@ -358,2 +358,2 @@\n-        script = langtag.getScript();\n-        region = langtag.getRegion();\n+        script = langtag.script();\n+        region = langtag.region();\n@@ -361,1 +361,1 @@\n-        List<String> bcpVariants = langtag.getVariants();\n+        List<String> bcpVariants = langtag.variants();\n@@ -371,1 +371,1 @@\n-        setExtensions(langtag.getExtensions(), langtag.getPrivateuse());\n+        setExtensions(langtag.extensions(), langtag.privateuse());\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/InternalLocaleBuilder.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,4 +45,4 @@\n-public class LanguageTag {\n-    \/\/\n-    \/\/ static fields\n-    \/\/\n+\/\/ List fields are unmodifiable\n+public record LanguageTag(String language, String script, String region, String privateuse,\n+                          List<String> extlangs, List<String> variants, List<String> extensions) {\n+\n@@ -53,0 +53,2 @@\n+    private static final String EMPTY_SUBTAG = \"\";\n+    private static final List<String> EMPTY_SUBTAGS = Collections.emptyList();\n@@ -54,11 +56,0 @@\n-    \/\/\n-    \/\/ Language subtag fields\n-    \/\/\n-    private String language = \"\";      \/\/ language subtag\n-    private String script = \"\";        \/\/ script subtag\n-    private String region = \"\";        \/\/ region subtag\n-    private String privateuse = \"\";    \/\/ privateuse\n-\n-    private List<String> extlangs = Collections.emptyList();   \/\/ extlang subtags\n-    private List<String> variants = Collections.emptyList();   \/\/ variant subtags\n-    private List<String> extensions = Collections.emptyList(); \/\/ extensions\n@@ -68,1 +59,1 @@\n-    private static final Map<String, String[]> LEGACY = new HashMap<>();\n+    private static final Map<String, String[]> LEGACY;\n@@ -131,0 +122,1 @@\n+        LEGACY = HashMap.newHashMap(entries.length);\n@@ -136,3 +128,0 @@\n-    private LanguageTag() {\n-    }\n-\n@@ -198,2 +187,6 @@\n-        LanguageTag tag = new LanguageTag();\n-\n+        String language = parseLanguage(itr, pp);\n+        List<String> extlangs;\n+        String script;\n+        String region;\n+        List<String> variants;\n+        List<String> extensions;\n@@ -201,6 +194,12 @@\n-        if (tag.parseLanguage(itr, pp)) {\n-            tag.parseExtlangs(itr, pp);\n-            tag.parseScript(itr, pp);\n-            tag.parseRegion(itr, pp);\n-            tag.parseVariants(itr, pp);\n-            tag.parseExtensions(itr, pp, errorMsg);\n+        if (!language.isEmpty()) {\n+            extlangs = parseExtlangs(itr, pp);\n+            script = parseScript(itr, pp);\n+            region = parseRegion(itr, pp);\n+            variants = parseVariants(itr, pp);\n+            extensions = parseExtensions(itr, pp, errorMsg);\n+        } else {\n+            extlangs = EMPTY_SUBTAGS;\n+            script = EMPTY_SUBTAG;\n+            region = EMPTY_SUBTAG;\n+            variants = EMPTY_SUBTAGS;\n+            extensions = EMPTY_SUBTAGS;\n@@ -208,1 +207,1 @@\n-        tag.parsePrivateuse(itr, pp, errorMsg);\n+        String privateuse = parsePrivateuse(itr, pp, errorMsg);\n@@ -224,1 +223,1 @@\n-        return tag;\n+        return new LanguageTag(language, script, region, privateuse, extlangs, variants, extensions);\n@@ -231,1 +230,1 @@\n-    private boolean parseLanguage(StringTokenIterator itr, ParsePosition pp) {\n+    private static String parseLanguage(StringTokenIterator itr, ParsePosition pp) {\n@@ -233,1 +232,1 @@\n-            return false;\n+            return EMPTY_SUBTAG;\n@@ -236,2 +235,0 @@\n-        boolean found = false;\n-\n@@ -240,2 +237,0 @@\n-            found = true;\n-            language = s;\n@@ -244,0 +239,1 @@\n+            return s;\n@@ -246,1 +242,1 @@\n-        return found;\n+        return EMPTY_SUBTAG;\n@@ -249,1 +245,1 @@\n-    private boolean parseExtlangs(StringTokenIterator itr, ParsePosition pp) {\n+    private static List<String> parseExtlangs(StringTokenIterator itr, ParsePosition pp) {\n@@ -251,1 +247,1 @@\n-            return false;\n+            return EMPTY_SUBTAGS;\n@@ -253,3 +249,1 @@\n-\n-        boolean found = false;\n-\n+        List<String> extlangs = null;\n@@ -261,2 +255,1 @@\n-            found = true;\n-            if (extlangs.isEmpty()) {\n+            if (extlangs == null) {\n@@ -268,1 +261,0 @@\n-\n@@ -274,2 +266,2 @@\n-\n-        return found;\n+        return extlangs == null ? EMPTY_SUBTAGS :\n+                Collections.unmodifiableList(extlangs);\n@@ -278,1 +270,1 @@\n-    private boolean parseScript(StringTokenIterator itr, ParsePosition pp) {\n+    private static String parseScript(StringTokenIterator itr, ParsePosition pp) {\n@@ -280,1 +272,1 @@\n-            return false;\n+            return EMPTY_SUBTAG;\n@@ -283,2 +275,0 @@\n-        boolean found = false;\n-\n@@ -287,2 +277,0 @@\n-            found = true;\n-            script = s;\n@@ -291,0 +279,1 @@\n+            return s;\n@@ -293,1 +282,1 @@\n-        return found;\n+        return EMPTY_SUBTAG;\n@@ -296,1 +285,1 @@\n-    private boolean parseRegion(StringTokenIterator itr, ParsePosition pp) {\n+    private static String parseRegion(StringTokenIterator itr, ParsePosition pp) {\n@@ -298,1 +287,1 @@\n-            return false;\n+            return EMPTY_SUBTAG;\n@@ -300,3 +289,0 @@\n-\n-        boolean found = false;\n-\n@@ -305,2 +291,0 @@\n-            found = true;\n-            region = s;\n@@ -309,0 +293,1 @@\n+            return s;\n@@ -311,1 +296,1 @@\n-        return found;\n+        return EMPTY_SUBTAG;\n@@ -314,1 +299,1 @@\n-    private boolean parseVariants(StringTokenIterator itr, ParsePosition pp) {\n+    private static List<String> parseVariants(StringTokenIterator itr, ParsePosition pp) {\n@@ -316,1 +301,1 @@\n-            return false;\n+            return EMPTY_SUBTAGS;\n@@ -318,2 +303,1 @@\n-\n-        boolean found = false;\n+        List<String> variants = null;\n@@ -326,2 +310,1 @@\n-            found = true;\n-            if (variants.isEmpty()) {\n+            if (variants == null) {\n@@ -335,1 +318,2 @@\n-        return found;\n+        return variants == null ? EMPTY_SUBTAGS :\n+                Collections.unmodifiableList(variants);\n@@ -338,1 +322,1 @@\n-    private boolean parseExtensions(StringTokenIterator itr, ParsePosition pp,\n+    private static List<String> parseExtensions(StringTokenIterator itr, ParsePosition pp,\n@@ -341,1 +325,1 @@\n-            return false;\n+            return EMPTY_SUBTAGS;\n@@ -343,2 +327,1 @@\n-\n-        boolean found = false;\n+        List<String> extensions = null;\n@@ -371,1 +354,1 @@\n-                if (extensions.isEmpty()) {\n+                if (extensions == null) {\n@@ -375,1 +358,0 @@\n-                found = true;\n@@ -380,1 +362,2 @@\n-        return found;\n+        return extensions == null ? EMPTY_SUBTAGS :\n+                Collections.unmodifiableList(extensions);\n@@ -383,1 +366,1 @@\n-    private boolean parsePrivateuse(StringTokenIterator itr, ParsePosition pp,\n+    private static String parsePrivateuse(StringTokenIterator itr, ParsePosition pp,\n@@ -386,1 +369,1 @@\n-            return false;\n+            return EMPTY_SUBTAG;\n@@ -389,2 +372,0 @@\n-        boolean found = false;\n-\n@@ -413,2 +394,1 @@\n-                privateuse = sb.toString();\n-                found = true;\n+                return sb.toString();\n@@ -418,1 +398,1 @@\n-        return found;\n+        return EMPTY_SUBTAG;\n@@ -465,1 +445,0 @@\n-        LanguageTag tag = new LanguageTag();\n@@ -467,4 +446,8 @@\n-        String language = baseLocale.getLanguage();\n-        String script = baseLocale.getScript();\n-        String region = baseLocale.getRegion();\n-        String variant = baseLocale.getVariant();\n+        String language = EMPTY_SUBTAG;\n+        String script = EMPTY_SUBTAG;\n+        String region = EMPTY_SUBTAG;\n+\n+        String baseLanguage = baseLocale.getLanguage();\n+        String baseScript = baseLocale.getScript();\n+        String baseRegion = baseLocale.getRegion();\n+        String baseVariant = baseLocale.getVariant();\n@@ -476,1 +459,1 @@\n-        if (isLanguage(language)) {\n+        if (isLanguage(baseLanguage)) {\n@@ -478,8 +461,7 @@\n-            if (language.equals(\"iw\")) {\n-                language = \"he\";\n-            } else if (language.equals(\"ji\")) {\n-                language = \"yi\";\n-            } else if (language.equals(\"in\")) {\n-                language = \"id\";\n-            }\n-            tag.language = language;\n+            baseLanguage = switch (baseLanguage) {\n+                case \"iw\" -> \"he\";\n+                case \"ji\" -> \"yi\";\n+                case \"in\" -> \"id\";\n+                default -> baseLanguage;\n+            };\n+            language = baseLanguage;\n@@ -488,2 +470,2 @@\n-        if (isScript(script)) {\n-            tag.script = canonicalizeScript(script);\n+        if (isScript(baseScript)) {\n+            script = canonicalizeScript(baseScript);\n@@ -493,2 +475,2 @@\n-        if (isRegion(region)) {\n-            tag.region = canonicalizeRegion(region);\n+        if (isRegion(baseRegion)) {\n+            region = canonicalizeRegion(baseRegion);\n@@ -499,3 +481,3 @@\n-        if (tag.language.equals(\"no\") && tag.region.equals(\"NO\") && variant.equals(\"NY\")) {\n-            tag.language = \"nn\";\n-            variant = \"\";\n+        if (language.equals(\"no\") && region.equals(\"NO\") && baseVariant.equals(\"NY\")) {\n+            language = \"nn\";\n+            baseVariant = EMPTY_SUBTAG;\n@@ -504,3 +486,3 @@\n-        if (!variant.isEmpty()) {\n-            List<String> variants = null;\n-            StringTokenIterator varitr = new StringTokenIterator(variant, BaseLocale.SEP);\n+        List<String> variants = null;\n+        if (!baseVariant.isEmpty()) {\n+            StringTokenIterator varitr = new StringTokenIterator(baseVariant, BaseLocale.SEP);\n@@ -519,1 +501,0 @@\n-                tag.variants = variants;\n@@ -559,1 +540,0 @@\n-            tag.extensions = extensions;\n@@ -573,5 +553,1 @@\n-        if (privateuse != null) {\n-            tag.privateuse = privateuse;\n-        }\n-\n-        if (tag.language.isEmpty() && (hasSubtag || privateuse == null)) {\n+        if (language.isEmpty() && (hasSubtag || privateuse == null)) {\n@@ -581,17 +557,1 @@\n-            tag.language = UNDETERMINED;\n-        }\n-\n-        return tag;\n-    }\n-\n-    \/\/\n-    \/\/ Getter methods for language subtag fields\n-    \/\/\n-\n-    public String getLanguage() {\n-        return language;\n-    }\n-\n-    public List<String> getExtlangs() {\n-        if (extlangs.isEmpty()) {\n-            return Collections.emptyList();\n+            language = UNDETERMINED;\n@@ -599,10 +559,0 @@\n-        return Collections.unmodifiableList(extlangs);\n-    }\n-\n-    public String getScript() {\n-        return script;\n-    }\n-\n-    public String getRegion() {\n-        return region;\n-    }\n@@ -610,13 +560,5 @@\n-    public List<String> getVariants() {\n-        if (variants.isEmpty()) {\n-            return Collections.emptyList();\n-        }\n-        return Collections.unmodifiableList(variants);\n-    }\n-\n-    public List<String> getExtensions() {\n-        if (extensions.isEmpty()) {\n-            return Collections.emptyList();\n-        }\n-        return Collections.unmodifiableList(extensions);\n-    }\n+        privateuse = privateuse == null ? EMPTY_SUBTAG : privateuse;\n+        extensions = extensions == null ? EMPTY_SUBTAGS :\n+                Collections.unmodifiableList(extensions);\n+        variants = variants == null ? EMPTY_SUBTAGS :\n+                Collections.unmodifiableList(variants);\n@@ -624,2 +566,2 @@\n-    public String getPrivateuse() {\n-        return privateuse;\n+        \/\/ extlangs always empty for locale parse\n+        return new LanguageTag(language, script, region, privateuse, EMPTY_SUBTAGS, variants, extensions);\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/LanguageTag.java","additions":97,"deletions":155,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-    private void implDelete(Path obj, boolean haveFlags, int flags)\n+    private void implDelete(Path obj, int flags)\n@@ -171,14 +171,0 @@\n-            if (!haveFlags) {\n-                \/\/ need file attribute to know if file is directory. This creates\n-                \/\/ a race in that the file may be replaced by a directory or a\n-                \/\/ directory replaced by a file between the time we query the\n-                \/\/ file type and unlink it.\n-                UnixFileAttributes attrs = null;\n-                try {\n-                    attrs = UnixFileAttributes.get(dfd, file, false);\n-                } catch (UnixException x) {\n-                    x.rethrowAsIOException(file);\n-                }\n-                flags = (attrs.isDirectory()) ? AT_REMOVEDIR : 0;\n-            }\n-\n@@ -202,1 +188,1 @@\n-        implDelete(file, true, 0);\n+        implDelete(file, 0);\n@@ -207,1 +193,1 @@\n-        implDelete(dir, true, AT_REMOVEDIR);\n+        implDelete(dir, AT_REMOVEDIR);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixSecureDirectoryStream.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-        if (dst instanceof sun.nio.ch.DirectBuffer ddst) {\n+        if (dst.isDirect()) {\n@@ -172,1 +172,1 @@\n-                long address = ddst.address() + pos;\n+                long address = NIO_ACCESS.getBufferAddress(dst) + pos;\n@@ -228,1 +228,1 @@\n-        if (src instanceof sun.nio.ch.DirectBuffer buf) {\n+        if (src.isDirect()) {\n@@ -231,1 +231,1 @@\n-                long address = buf.address() + pos;\n+                long address = NIO_ACCESS.getBufferAddress(src) + pos;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1195,0 +1195,3 @@\n+\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n@@ -1259,0 +1262,3 @@\n+\n+                putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileChooserUI.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+@property (readwrite, atomic) int displayLinkFailCount;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLLayer.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+#define CV_DISPLAYLINK_FAIL_DELAY 1.0\n+#define MAX_DISPLAYLINK_FAIL_COUNT 5\n@@ -47,0 +49,1 @@\n+@synthesize displayLinkFailCount;\n@@ -49,3 +52,18 @@\n-    CVDisplayLinkCreateWithActiveCGDisplays(&displayLink);\n-    CVDisplayLinkSetOutputCallback(displayLink, &displayLinkCallback, (__bridge void*)self);\n-    self.displayLinkCount = 0;\n+    CVReturn r = CVDisplayLinkCreateWithActiveCGDisplays(&displayLink);\n+    if (r != kCVReturnSuccess) {\n+        if (self.displayLinkFailCount >= MAX_DISPLAYLINK_FAIL_COUNT) {\n+            J2dTraceLn(J2D_TRACE_ERROR,\n+                \"MTLLayer.createDisplayLink --- unable to create CVDisplayLink.\");\n+            self.displayLinkFailCount = 0;\n+            return;\n+        }\n+        self.displayLinkFailCount++;\n+        [self performSelector:@selector(createDisplayLink)\n+                   withObject:nil\n+                   afterDelay:CV_DISPLAYLINK_FAIL_DELAY];\n+        return;\n+    } else {\n+        CVDisplayLinkSetOutputCallback(displayLink, &displayLinkCallback, (__bridge void*)self);\n+        self.displayLinkCount = 0;\n+        self.displayLinkFailCount = 0;\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLLayer.m","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -659,0 +659,3 @@\n+\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n@@ -671,0 +674,3 @@\n+\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifFileChooserUI.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n- * Here is an example of five buttons in an applet laid out using\n+ * Here is an example of five buttons in a window laid out using\n@@ -95,1 +95,1 @@\n- * <img src=\"doc-files\/BorderLayout-1.gif\" alt=\"Diagram of an applet\n+ * <img src=\"doc-files\/BorderLayout-1.png\" alt=\"Diagram of a window\n@@ -98,1 +98,1 @@\n- * Center, East, or South.\" style=\"margin: 7px 10px;\">\n+ * Center, East, or South.\">\n@@ -100,1 +100,1 @@\n- * The code for this applet is as follows:\n+ * The code for this program is as follows:\n@@ -102,3 +102,5 @@\n- * <hr><blockquote><pre>\n- * import java.awt.*;\n- * import java.applet.Applet;\n+ * {@snippet lang='java':\n+ * import java.awt.BorderLayout;\n+ * import java.awt.Button;\n+ * import java.awt.EventQueue;\n+ * import java.awt.Frame;\n@@ -106,9 +108,16 @@\n- * public class buttonDir extends Applet {\n- *   public void init() {\n- *     setLayout(new BorderLayout());\n- *     add(new Button(\"North\"), BorderLayout.NORTH);\n- *     add(new Button(\"South\"), BorderLayout.SOUTH);\n- *     add(new Button(\"East\"), BorderLayout.EAST);\n- *     add(new Button(\"West\"), BorderLayout.WEST);\n- *     add(new Button(\"Center\"), BorderLayout.CENTER);\n- *   }\n+ * public class BorderLayoutExample {\n+ *\n+ *     public static void main(String[] args) throws Exception {\n+ *         EventQueue.invokeAndWait(() -> {\n+ *             Frame frame = new Frame(\"BorderLayout\");\n+ *             frame.setLayout(new BorderLayout());\n+ *             frame.add(new Button(\"North\"), BorderLayout.NORTH);\n+ *             frame.add(new Button(\"South\"), BorderLayout.SOUTH);\n+ *             frame.add(new Button(\"East\"), BorderLayout.EAST);\n+ *             frame.add(new Button(\"West\"), BorderLayout.WEST);\n+ *             frame.add(new Button(\"Center\"), BorderLayout.CENTER);\n+ *             frame.setSize(300, 300);\n+ *             frame.setVisible(true);\n+ *         });\n+ *     }\n+ * }\n@@ -116,1 +125,0 @@\n- * <\/pre><\/blockquote><hr>\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/BorderLayout.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * For example, the following picture shows an applet using the flow\n+ * For example, the following picture shows a window using the flow\n@@ -57,1 +57,1 @@\n- * <img src=\"doc-files\/FlowLayout-1.gif\"\n+ * <img src=\"doc-files\/FlowLayout-1.png\"\n@@ -59,1 +59,1 @@\n- * style=\"margin: 7px 10px;\">\n+ * >\n@@ -61,1 +61,1 @@\n- * Here is the code for this applet:\n+ * Here is the code for this program:\n@@ -63,3 +63,5 @@\n- * <hr><blockquote><pre>\n- * import java.awt.*;\n- * import java.applet.Applet;\n+ * {@snippet lang='java':\n+ * import java.awt.Button;\n+ * import java.awt.EventQueue;\n+ * import java.awt.FlowLayout;\n+ * import java.awt.Frame;\n@@ -67,9 +69,12 @@\n- * public class myButtons extends Applet {\n- *     Button button1, button2, button3;\n- *     public void init() {\n- *         button1 = new Button(\"Ok\");\n- *         button2 = new Button(\"Open\");\n- *         button3 = new Button(\"Close\");\n- *         add(button1);\n- *         add(button2);\n- *         add(button3);\n+ * public class FlowLayoutExample {\n+ *\n+ *     public static void main(String[] args) throws Exception {\n+ *         EventQueue.invokeAndWait(() -> {\n+ *             Frame frame = new Frame(\"FlowLayout\");\n+ *             frame.setLayout(new FlowLayout());\n+ *             frame.add(new Button(\"OK\"));\n+ *             frame.add(new Button(\"Open\"));\n+ *             frame.add(new Button(\"Close\"));\n+ *             frame.pack();\n+ *             frame.setVisible(true);\n+ *         });\n@@ -78,1 +83,1 @@\n- * <\/pre><\/blockquote><hr>\n+ * }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/FlowLayout.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n- * <div style=\"margin:0 auto;width:680px;text-align:center;font-weight:bold\">\n+ * <div style=\"margin:0 auto;width:850px;text-align:center;font-weight:bold\">\n@@ -245,1 +245,1 @@\n- *     <p><img src=\"doc-files\/GridBagLayout-1.gif\"\n+ *     <p><img src=\"doc-files\/GridBagLayout-1.png\"\n@@ -251,1 +251,1 @@\n- *     <p><img src=\"doc-files\/GridBagLayout-2.gif\"\n+ *     <p><img src=\"doc-files\/GridBagLayout-2.png\"\n@@ -279,4 +279,6 @@\n- * <hr><blockquote><pre>\n- * import java.awt.*;\n- * import java.util.*;\n- * import java.applet.Applet;\n+ * {@snippet lang='java':\n+ * import java.awt.Button;\n+ * import java.awt.EventQueue;\n+ * import java.awt.Frame;\n+ * import java.awt.GridBagConstraints;\n+ * import java.awt.GridBagLayout;\n@@ -284,1 +286,1 @@\n- * public class GridBagEx1 extends Applet {\n+ * public class GridBagLayoutExample {\n@@ -286,3 +288,4 @@\n- *     protected void makebutton(String name,\n- *                               GridBagLayout gridbag,\n- *                               GridBagConstraints c) {\n+ *     private static void addButton(String name,\n+ *                                   GridBagLayout gridbag,\n+ *                                   GridBagConstraints c,\n+ *                                   Frame frame) {\n@@ -291,1 +294,1 @@\n- *         add(button);\n+ *         frame.add(button);\n@@ -294,3 +297,6 @@\n- *     public void init() {\n- *         GridBagLayout gridbag = new GridBagLayout();\n- *         GridBagConstraints c = new GridBagConstraints();\n+ *     public static void main(String[] args) throws Exception {\n+ *         EventQueue.invokeAndWait(() -> {\n+ *             Frame frame = new Frame(\"GridBagLayout\");\n+ *             GridBagLayout gridbag = new GridBagLayout();\n+ *             GridBagConstraints c = new GridBagConstraints();\n+ *             frame.setLayout(gridbag);\n@@ -298,2 +304,5 @@\n- *         setFont(new Font(\"SansSerif\", Font.PLAIN, 14));\n- *         setLayout(gridbag);\n+ *             c.fill = GridBagConstraints.BOTH;\n+ *             c.weightx = 1.0;\n+ *             addButton(\"Button1\", gridbag, c, frame);\n+ *             addButton(\"Button2\", gridbag, c, frame);\n+ *             addButton(\"Button3\", gridbag, c, frame);\n@@ -301,5 +310,2 @@\n- *         c.fill = GridBagConstraints.BOTH;\n- *         c.weightx = 1.0;\n- *         makebutton(\"Button1\", gridbag, c);\n- *         makebutton(\"Button2\", gridbag, c);\n- *         makebutton(\"Button3\", gridbag, c);\n+ *             c.gridwidth = GridBagConstraints.REMAINDER; \/\/end row\n+ *             addButton(\"Button4\", gridbag, c, frame);\n@@ -307,2 +313,2 @@\n- *         c.gridwidth = GridBagConstraints.REMAINDER; \/\/end row\n- *         makebutton(\"Button4\", gridbag, c);\n+ *             c.weightx = 0.0;                \/\/reset to the default\n+ *             addButton(\"Button5\", gridbag, c, frame); \/\/another row\n@@ -310,2 +316,2 @@\n- *         c.weightx = 0.0;                \/\/reset to the default\n- *         makebutton(\"Button5\", gridbag, c); \/\/another row\n+ *             c.gridwidth = GridBagConstraints.RELATIVE; \/\/next-to-last in row\n+ *             addButton(\"Button6\", gridbag, c, frame);\n@@ -313,2 +319,2 @@\n- *         c.gridwidth = GridBagConstraints.RELATIVE; \/\/next-to-last in row\n- *         makebutton(\"Button6\", gridbag, c);\n+ *             c.gridwidth = GridBagConstraints.REMAINDER; \/\/end row\n+ *             addButton(\"Button7\", gridbag, c, frame);\n@@ -316,2 +322,4 @@\n- *         c.gridwidth = GridBagConstraints.REMAINDER; \/\/end row\n- *         makebutton(\"Button7\", gridbag, c);\n+ *             c.gridwidth = 1;                \/\/reset to the default\n+ *             c.gridheight = 2;\n+ *             c.weighty = 1.0;\n+ *             addButton(\"Button8\", gridbag, c, frame);\n@@ -319,4 +327,5 @@\n- *         c.gridwidth = 1;                \/\/reset to the default\n- *         c.gridheight = 2;\n- *         c.weighty = 1.0;\n- *         makebutton(\"Button8\", gridbag, c);\n+ *             c.weighty = 0.0;                \/\/reset to the default\n+ *             c.gridwidth = GridBagConstraints.REMAINDER; \/\/end row\n+ *             c.gridheight = 1;               \/\/reset to the default\n+ *             addButton(\"Button9\", gridbag, c, frame);\n+ *             addButton(\"Button10\", gridbag, c, frame);\n@@ -324,19 +333,3 @@\n- *         c.weighty = 0.0;                \/\/reset to the default\n- *         c.gridwidth = GridBagConstraints.REMAINDER; \/\/end row\n- *         c.gridheight = 1;               \/\/reset to the default\n- *         makebutton(\"Button9\", gridbag, c);\n- *         makebutton(\"Button10\", gridbag, c);\n- *\n- *         setSize(300, 100);\n- *     }\n- *\n- *     public static void main(String args[]) {\n- *         Frame f = new Frame(\"GridBag Layout Example\");\n- *         GridBagEx1 ex1 = new GridBagEx1();\n- *\n- *         ex1.init();\n- *\n- *         f.add(\"Center\", ex1);\n- *         f.pack();\n- *         f.setSize(f.getPreferredSize());\n- *         f.show();\n+ *             frame.pack();\n+ *             frame.setVisible(true);\n+ *         });\n@@ -345,1 +338,1 @@\n- * <\/pre><\/blockquote><hr>\n+ * }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GridBagLayout.java","additions":47,"deletions":54,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * For example, the following is an applet that lays out six buttons\n+ * For example, the following is a window that lays out six buttons\n@@ -38,13 +38,21 @@\n- * <hr><blockquote>\n- * <pre>\n- * import java.awt.*;\n- * import java.applet.Applet;\n- * public class ButtonGrid extends Applet {\n- *     public void init() {\n- *         setLayout(new GridLayout(3,2));\n- *         add(new Button(\"1\"));\n- *         add(new Button(\"2\"));\n- *         add(new Button(\"3\"));\n- *         add(new Button(\"4\"));\n- *         add(new Button(\"5\"));\n- *         add(new Button(\"6\"));\n+ * {@snippet lang='java':\n+ * import java.awt.Button;\n+ * import java.awt.EventQueue;\n+ * import java.awt.Frame;\n+ * import java.awt.GridLayout;\n+ *\n+ * public class GridLayoutExample {\n+ *\n+ *     public static void main(String[] args) throws Exception {\n+ *         EventQueue.invokeAndWait(() -> {\n+ *             Frame frame = new Frame(\"GridLayout\");\n+ *             frame.setLayout(new GridLayout(3, 2));\n+ *             frame.add(new Button(\"1\"));\n+ *             frame.add(new Button(\"2\"));\n+ *             frame.add(new Button(\"3\"));\n+ *             frame.add(new Button(\"4\"));\n+ *             frame.add(new Button(\"5\"));\n+ *             frame.add(new Button(\"6\"));\n+ *             frame.setSize(200, 200);\n+ *             frame.setVisible(true);\n+ *         });\n@@ -53,1 +61,1 @@\n- * <\/pre><\/blockquote><hr>\n+ * }\n@@ -62,1 +70,1 @@\n- *     <p><img SRC=\"doc-files\/GridLayout-1.gif\"\n+ *     <p><img SRC=\"doc-files\/GridLayout-1.png\"\n@@ -68,1 +76,1 @@\n- *     <p><img SRC=\"doc-files\/GridLayout-2.gif\"\n+ *     <p><img SRC=\"doc-files\/GridLayout-2.png\"\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GridLayout.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,1 @@\n- * <hr><blockquote><pre>{@code\n- * import java.applet.Applet;\n+ * {@snippet lang='java':\n@@ -73,0 +72,2 @@\n+ * import java.awt.EventQueue;\n+ * import java.awt.Frame;\n@@ -76,0 +77,2 @@\n+ * import java.awt.Panel;\n+ * import java.awt.Toolkit;\n@@ -77,1 +80,1 @@\n- * public class ImageBlaster extends Applet implements Runnable {\n+ * public class MediaTrackerExample extends Panel implements Runnable {\n@@ -87,1 +90,13 @@\n- *      public void init() {\n+ *      public static void main(String[] args) throws Exception {\n+ *          MediaTrackerExample mte = new MediaTrackerExample();\n+ *          EventQueue.invokeAndWait(() -> {\n+ *              Frame frame = new Frame(\"MediaTrackerExample\");\n+ *              frame.setSize(400, 400);\n+ *              frame.add(mte);\n+ *              frame.setVisible(true);\n+ *          });\n+ *          mte.startAnimation();\n+ *      }\n+ *\n+ *      public MediaTrackerExample() {\n+ *          Toolkit tk = Toolkit.getDefaultToolkit();\n@@ -89,2 +104,2 @@\n- *          bg = getImage(getDocumentBase(),\n- *                  \"images\/background.gif\");\n+ *          \/\/ Note : actual images not provided as part of this code example\n+ *          bg = tk.getImage(\"background.gif\");\n@@ -93,2 +108,1 @@\n- *              anim[i] = getImage(getDocumentBase(),\n- *                      \"images\/anim\"+i+\".gif\");\n+ *              anim[i] = tk.getImage(\"anim\" + i + \".gif\");\n@@ -99,2 +113,1 @@\n- *      \/\/ Start the animation thread.\n- *      public void start() {\n+ *      public void startAnimation() {\n@@ -105,5 +118,0 @@\n- *      \/\/ Stop the animation thread.\n- *      public void stop() {\n- *          animator = null;\n- *      }\n- *\n@@ -140,1 +148,1 @@\n- *      \/\/ don't need to clear the applet on repaints.\n+ *      \/\/ don't need to clear the component background on repaints.\n@@ -155,1 +163,1 @@\n- *              g.fillRect(0, 0, size().width, size().height);\n+ *              g.fillRect(0, 0, getSize().width, getSize().height);\n@@ -164,1 +172,1 @@\n- * } <\/pre><\/blockquote><hr>\n+ * }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MediaTracker.java","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+import static sun.java2d.cmm.ProfileDataVerifier.HEADER_SIZE;\n+\n@@ -767,2 +769,0 @@\n-    private static final int HEADER_SIZE = 128;\n-\n@@ -916,1 +916,1 @@\n-        bis.mark(128); \/\/ 128 is the length of the ICC profile header\n+        bis.mark(HEADER_SIZE);\n@@ -918,3 +918,3 @@\n-        byte[] header = bis.readNBytes(128);\n-        if (header.length < 128 || header[36] != 0x61 || header[37] != 0x63 ||\n-            header[38] != 0x73 || header[39] != 0x70) {\n+        byte[] header = bis.readNBytes(HEADER_SIZE);\n+        if (header.length < HEADER_SIZE || header[36] != 0x61 ||\n+            header[37] != 0x63 || header[38] != 0x73 || header[39] != 0x70) {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/BorderLayout-1.gif","binary":true,"status":"deleted"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/BorderLayout-1.png","binary":true,"status":"added"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/FlowLayout-1.gif","binary":true,"status":"deleted"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/FlowLayout-1.png","binary":true,"status":"added"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridBagLayout-1.gif","binary":true,"status":"deleted"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridBagLayout-1.png","binary":true,"status":"added"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridBagLayout-2.gif","binary":true,"status":"deleted"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridBagLayout-2.png","binary":true,"status":"added"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridLayout-1.gif","binary":true,"status":"deleted"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridLayout-1.png","binary":true,"status":"added"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridLayout-2.gif","binary":true,"status":"deleted"},{"filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/GridLayout-2.png","binary":true,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.Set;\n@@ -61,4 +60,1 @@\n-    private Map<E, DigraphNode<E>> poNodes = new HashMap<>();\n-\n-    \/\/ The set of Objects\n-    private Set<E> nodes = poNodes.keySet();\n+    private final Map<E, DigraphNode<E>> poNodes = new HashMap<>();\n@@ -72,1 +68,1 @@\n-        return nodes.size();\n+        return poNodes.size();\n@@ -76,1 +72,1 @@\n-        return nodes.contains(o);\n+        return poNodes.containsKey(o);\n@@ -93,1 +89,1 @@\n-        if (nodes.contains(o)) {\n+        if (poNodes.containsKey(o)) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/PartiallyOrderedSet.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -402,0 +402,1 @@\n+        putClientProperty(\"html.disable\", true);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JFileChooser.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -952,0 +952,2 @@\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalFileChooserUI.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -878,1 +878,8 @@\n-    return new ExtendedTextSourceLabel(source.getSubSource(start, limit-start, dir), decorator);\n+    if (start == 0 &&\n+        limit == source.getLength() &&\n+        (dir == source.getBidiLevel() || dir == TextLineComponent.UNCHANGED)) {\n+      return this; \/\/ avoid unnecessary object creation and text shaping\n+    } else {\n+      TextSource subSource = source.getSubSource(start, limit-start, dir);\n+      return new ExtendedTextSourceLabel(subSource, decorator);\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/ExtendedTextSourceLabel.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    private static final int HEADER_SIZE = 128;\n+    public static final int HEADER_SIZE = 128;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/ProfileDataVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1238,0 +1238,2 @@\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n@@ -1634,0 +1636,2 @@\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/FilePane.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -692,0 +692,2 @@\n+            label.putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/synth\/SynthFileChooserUIImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,4 +1621,0 @@\n-#if defined(_LP64) && !defined(_LITTLE_ENDIAN)\n-        \/\/ The Window value which is used for XGetICValues must be 32bit on BigEndian XOrg's xlib\n-        unsigned int w = 0;\n-#else\n@@ -1626,1 +1622,0 @@\n-#endif\n@@ -1629,0 +1624,5 @@\n+#if defined(_LP64) && !defined(_LITTLE_ENDIAN)\n+        \/\/ On 64bit BigEndian,\n+        \/\/ Window value may be stored on high 32bit by XGetICValues via XIM\n+        if (w > 0xffffffffUL) w = w >> 32;\n+#endif\n@@ -1677,4 +1677,0 @@\n-#if defined(__linux__) && defined(_LP64) && !defined(_LITTLE_ENDIAN)\n-    \/\/ XIMPreeditState value which is used for XGetICValues must be 32bit on BigEndian XOrg's xlib\n-    unsigned int state = XIMPreeditUnKnown;\n-#else\n@@ -1682,1 +1678,0 @@\n-#endif\n@@ -1698,0 +1693,5 @@\n+#if defined(__linux__) && defined(_LP64) && !defined(_LITTLE_ENDIAN)\n+    \/\/ On 64bit BigEndian,\n+    \/\/ XIMPreeditState value may be stored on high 32bit by XGetICValues via XIM\n+    if (state > 0xffffffffUL) state = state >> 32;\n+#endif\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_InputMethod.c","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -695,1 +695,3 @@\n-        write ( AWT_WRITEPIPE, &wakeUp_char, 1 );\n+        if (write(AWT_WRITEPIPE, &wakeUp_char, 1) < 0) {\n+            DTRACE_PRINTLN(\"wakeUp(): write to AWT pipe failed\");\n+        }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XToolkit.c","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1081,0 +1081,2 @@\n+            putClientProperty(\"html.disable\", getFileChooser().getClientProperty(\"html.disable\"));\n+\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsFileChooserUI.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,2 @@\n+            assert firstNanos + delay == nanos :\n+                    \"%d + %d != %d\".formatted(firstNanos, delay, nanos);\n@@ -88,1 +90,1 @@\n-            return delay >= 0 && delay <= TIME_WINDOW;\n+            return delay >= -TIME_WINDOW && delay <= TIME_WINDOW;\n@@ -95,2 +97,0 @@\n-        long nanos = System.nanoTime();\n-        long delay = localSource.delay(nanos);\n@@ -98,2 +98,5 @@\n-        if (localSource.isInWindow(delay)) {\n-            return localSource.instant(nanos, delay);\n+        NanoSource source = localSource;\n+        long nanos = System.nanoTime();\n+        long delay = source.delay(nanos);\n+        if (source.isInWindow(delay)) {\n+            return source.instant(nanos, delay);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/TimeSource.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3592,1 +3592,1 @@\n-     *  value returned will correspond to the enum name returned by {@link PseudoColumnUsage#name PseudoColumnUsage.name()}\n+     *  value returned will correspond to the enum name returned by {@link PseudoColumnUsage#name() PseudoColumnUsage.name()}\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/DatabaseMetaData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * via the {@linkplain ServiceLoader#load service-provider loading} mechanism.\n+ * via the {@linkplain ServiceLoader#load(Class) service-provider loading} mechanism.\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/DriverManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -418,0 +418,5 @@\n+    \/**\n+     * Flag to indicate parameters that require identity.\n+     *\/\n+    public static final long REQUIRES_IDENTITY = 1L<<62; \/\/ VarSymbols (parameters)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -991,1 +991,2 @@\n-                        anno.position.parameter_index == index;\n+                        anno.position.parameter_index == index &&\n+                        anno.type.tsym.flatName() != name.table.names.requiresIdentityInternal;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -395,0 +395,6 @@\n+        return enterSyntheticAnnotation(names.fromString(name));\n+    }\n+\n+    \/\/ Enter a synthetic class that is used to mark classes in ct.sym.\n+    \/\/ This class does not have a class file.\n+    private Type enterSyntheticAnnotation(Name name) {\n@@ -397,1 +403,1 @@\n-        ClassType type = (ClassType)enterClass(java_base, names.fromString(name)).type;\n+        ClassType type = (ClassType)enterClass(java_base, name).type;\n@@ -632,1 +638,1 @@\n-        requiresIdentityInternalType = enterSyntheticAnnotation(\"jdk.internal.RequiresIdentity+Annotation\");\n+        requiresIdentityInternalType = enterSyntheticAnnotation(names.requiresIdentityInternal);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5111,10 +5111,6 @@\n-        if (isSameType(selectorType, targetType)) {\n-            return true;\n-        }\n-\n-        return (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n-                ((selectorType.hasTag(BYTE) && !targetType.hasTag(CHAR)) ||\n-                 (selectorType.hasTag(SHORT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))) ||\n-                 (selectorType.hasTag(CHAR)  && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag())))  ||\n-                 (selectorType.hasTag(INT)   && (targetType.hasTag(DOUBLE) || targetType.hasTag(LONG))) ||\n-                 (selectorType.hasTag(FLOAT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))));\n+        return isSameType(selectorType, targetType) ||\n+                (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n+                ((selectorType.getTag().isStrictSubRangeOf(targetType.getTag())) &&\n+                        !((selectorType.hasTag(BYTE) && targetType.hasTag(CHAR)) ||\n+                          (selectorType.hasTag(INT)  && targetType.hasTag(FLOAT)) ||\n+                          (selectorType.hasTag(LONG) && (targetType.hasTag(DOUBLE) || targetType.hasTag(FLOAT)))));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -402,0 +402,6 @@\n+\n+            if (!c.type.isErroneous()\n+                    && toAnnotate.kind == VAR\n+                    && types.isSameType(c.type, syms.requiresIdentityType)) {\n+                toAnnotate.flags_field |= Flags.REQUIRES_IDENTITY;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5890,1 +5890,1 @@\n-                            if (param.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                            if ((param.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n@@ -5897,1 +5897,1 @@\n-                            if (lastParam.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                            if ((lastParam.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n@@ -5974,1 +5974,1 @@\n-                            .filter(ta -> ta.type.tsym == syms.requiresIdentityType.tsym &&\n+                            .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym) &&\n@@ -5999,1 +5999,1 @@\n-                        .filter(ta -> (ta.type.tsym == syms.requiresIdentityType.tsym) &&\n+                        .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym) &&\n@@ -6006,0 +6006,5 @@\n+\n+    private boolean isRequiresIdentityAnnotation(TypeSymbol annoType) {\n+        return annoType == syms.requiresIdentityType.tsym ||\n+               annoType.flatName() == syms.requiresIdentityInternalType.tsym.flatName();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -813,3 +813,0 @@\n-        Type selsuper = types.supertype(tree.selector.type);\n-        boolean enumSwitch = selsuper != null &&\n-            selsuper.tsym == syms.enumSym;\n@@ -851,3 +848,0 @@\n-        Type selsuper = types.supertype(tree.selector.type);\n-        boolean enumSwitch = selsuper != null &&\n-            selsuper.tsym == syms.enumSym;\n@@ -855,1 +849,1 @@\n-        tree.cases = translate(tree.cases, tree.type);\n+        tree.cases = translate(tree.cases, erasure(tree.type));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -564,0 +564,5 @@\n+            Map<String,String> env = new HashMap<>();\n+            \/\/ ignores timestamps not stored in ZIP central directory, reducing I\/O\n+            \/\/ This key is handled by ZipFileSystem only.\n+            env.put(\"zipinfo-time\", \"false\");\n+\n@@ -565,1 +570,1 @@\n-                Map<String,String> env = Collections.singletonMap(\"multi-release\", multiReleaseValue);\n+                env.put(\"multi-release\", multiReleaseValue);\n@@ -574,1 +579,3 @@\n-                this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);\n+                \/\/ Less common case is possible if the file manager was not initialized in JavacTask,\n+                \/\/ or if non \"*.jar\" files are on the classpath.\n+                this.fileSystem = FileSystems.newFileSystem(archivePath, env, (ClassLoader)null);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1577,0 +1577,3 @@\n+            } else if (proxy.type.tsym.flatName() == syms.requiresIdentityInternalType.tsym.flatName()) {\n+                Assert.check(sym.kind == VAR);\n+                sym.flags_field |= REQUIRES_IDENTITY;\n@@ -1599,0 +1602,3 @@\n+                }  else if (proxy.type.tsym == syms.requiresIdentityType.tsym) {\n+                    Assert.check(sym.kind == VAR);\n+                    sym.flags_field |= REQUIRES_IDENTITY;\n@@ -2836,3 +2842,2 @@\n-                if (annotations != null && annotations.proxies != null\n-                        && !annotations.proxies.isEmpty()) {\n-                    annotate.normal(new AnnotationCompleter(param, annotations.proxies));\n+                if (annotations != null && annotations.proxies != null) {\n+                    attachAnnotations(param, annotations.proxies);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -237,0 +237,3 @@\n+    \/\/ special annotation names\n+    public final Name requiresIdentityInternal;\n+\n@@ -425,0 +428,3 @@\n+\n+        \/\/ special annotations:\n+        requiresIdentityInternal = fromString(\"jdk.internal.RequiresIdentity+Annotation\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -746,2 +747,2 @@\n-                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n-                            inAddr = dInBuffer.address();\n+                        if (inBuffer instanceof DirectBuffer) {\n+                            inAddr = NIO_ACCESS.getBufferAddress(inBuffer);\n@@ -762,2 +763,2 @@\n-                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                        outAddr = dOutBuffer.address();\n+                    if (outBuffer instanceof DirectBuffer) {\n+                        outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -745,2 +746,2 @@\n-                if (inBuffer instanceof DirectBuffer dInBuffer) {\n-                    inAddr = dInBuffer.address();\n+                if (inBuffer instanceof DirectBuffer) {\n+                    inAddr = NIO_ACCESS.getBufferAddress(inBuffer);\n@@ -756,2 +757,2 @@\n-                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                    outAddr = dOutBuffer.address();\n+                if (outBuffer instanceof DirectBuffer) {\n+                    outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n@@ -1015,2 +1016,2 @@\n-                if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                    outAddr = dOutBuffer.address();\n+                if (outBuffer instanceof DirectBuffer) {\n+                    outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-        if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+        if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -292,1 +292,2 @@\n-                token.p11.C_DigestUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+                final long address = NIO_ACCESS.getBufferAddress(byteBuffer);\n+                token.p11.C_DigestUpdate(session.id(), address + ofs, null, 0, len);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -580,2 +581,2 @@\n-                        if (inBuffer instanceof DirectBuffer dInBuffer) {\n-                            inAddr = dInBuffer.address();\n+                        if (inBuffer instanceof DirectBuffer) {\n+                            inAddr = NIO_ACCESS.getBufferAddress(inBuffer);\n@@ -596,2 +597,2 @@\n-                    if (outBuffer instanceof DirectBuffer dOutBuffer) {\n-                        outAddr = dOutBuffer.address();\n+                    if (outBuffer instanceof DirectBuffer) {\n+                        outAddr = NIO_ACCESS.getBufferAddress(outBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-            if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+            if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -289,1 +289,2 @@\n-                token.p11.C_SignUpdate(session.id(), dByteBuffer.address() + ofs, null, 0, len);\n+                final long address = NIO_ACCESS.getBufferAddress(byteBuffer);\n+                token.p11.C_SignUpdate(session.id(), address + ofs, null, 0, len);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -617,1 +617,1 @@\n-                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+                if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -625,1 +625,1 @@\n-                    long addr = dByteBuffer.address();\n+                    long addr = NIO_ACCESS.getBufferAddress(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -582,1 +582,1 @@\n-                if (!(byteBuffer instanceof DirectBuffer dByteBuffer)) {\n+                if (!(byteBuffer instanceof DirectBuffer)) {\n@@ -590,1 +590,1 @@\n-                    long addr = dByteBuffer.address();\n+                    long addr = NIO_ACCESS.getBufferAddress(byteBuffer);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -276,1 +276,4 @@\n-                        jline = LineReaderBuilder.builder().terminal(terminal).build();\n+                        jline = LineReaderBuilder.builder()\n+                                                 .option(LineReader.Option.DISABLE_EVENT_EXPANSION, true)\n+                                                 .terminal(terminal)\n+                                                 .build();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,5 +25,0 @@\n-import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n-\n-import jdk.vm.ci.meta.DeoptimizationReason;\n-import jdk.vm.ci.meta.JavaMethodProfile;\n-import jdk.vm.ci.meta.JavaTypeProfile;\n@@ -31,101 +26,0 @@\n-import jdk.vm.ci.meta.TriState;\n-\n-final class HotSpotProfilingInfo implements ProfilingInfo {\n-\n-    private final HotSpotMethodData methodData;\n-    private final HotSpotResolvedJavaMethod method;\n-\n-    private boolean isMature;\n-    private int position;\n-    private int hintPosition;\n-    private int hintBCI;\n-    private HotSpotMethodDataAccessor dataAccessor;\n-\n-    private boolean includeNormal;\n-    private boolean includeOSR;\n-\n-    HotSpotProfilingInfo(HotSpotMethodData methodData, HotSpotResolvedJavaMethod method, boolean includeNormal, boolean includeOSR) {\n-        this.methodData = methodData;\n-        this.method = method;\n-        if (!method.getDeclaringClass().isLinked()) {\n-            throw new IllegalArgumentException(method.format(\"%H.%n(%p) must be linked\"));\n-        }\n-        this.includeNormal = includeNormal;\n-        this.includeOSR = includeOSR;\n-        this.isMature = methodData.isProfileMature();\n-        hintPosition = 0;\n-        hintBCI = -1;\n-    }\n-\n-    @Override\n-    public int getCodeSize() {\n-        return method.getCodeSize();\n-    }\n-\n-    public int getDecompileCount() {\n-        return methodData.getDecompileCount();\n-    }\n-\n-    public int getOverflowRecompileCount() {\n-        return methodData.getOverflowRecompileCount();\n-    }\n-\n-    public int getOverflowTrapCount() {\n-        return methodData.getOverflowTrapCount();\n-    }\n-\n-    @Override\n-    public JavaTypeProfile getTypeProfile(int bci) {\n-        if (!isMature) {\n-            return null;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getTypeProfile(methodData, position);\n-    }\n-\n-    @Override\n-    public JavaMethodProfile getMethodProfile(int bci) {\n-        if (!isMature) {\n-            return null;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getMethodProfile(methodData, position);\n-    }\n-\n-    @Override\n-    public double getBranchTakenProbability(int bci) {\n-        if (!isMature) {\n-            return -1;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getBranchTakenProbability(methodData, position);\n-    }\n-\n-    @Override\n-    public double[] getSwitchProbabilities(int bci) {\n-        if (!isMature) {\n-            return null;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getSwitchProbabilities(methodData, position);\n-    }\n-\n-    @Override\n-    public TriState getExceptionSeen(int bci) {\n-        if (!findBCI(bci)) {\n-            \/\/ There might data in the extra data section but all accesses to that memory must be\n-            \/\/ under a lock so go into VM to get the data.\n-            int exceptionSeen = compilerToVM().methodDataExceptionSeen(methodData.methodDataPointer, bci);\n-            if (exceptionSeen == -1) {\n-                return TriState.UNKNOWN;\n-            }\n-            return TriState.get(exceptionSeen != 0);\n-        }\n-        return dataAccessor.getExceptionSeen(methodData, position);\n-    }\n-\n-    @Override\n-    public TriState getNullSeen(int bci) {\n-        findBCI(bci);\n-        return dataAccessor.getNullSeen(methodData, position);\n-    }\n@@ -133,76 +27,4 @@\n-    @Override\n-    public int getExecutionCount(int bci) {\n-        if (!isMature) {\n-            return -1;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getExecutionCount(methodData, position);\n-    }\n-\n-    @Override\n-    public int getDeoptimizationCount(DeoptimizationReason reason) {\n-        int count = 0;\n-        if (includeNormal) {\n-            count += methodData.getDeoptimizationCount(reason);\n-        }\n-        if (includeOSR) {\n-            count += methodData.getOSRDeoptimizationCount(reason);\n-        }\n-        return count;\n-    }\n-\n-    private boolean findBCI(int targetBCI) {\n-        assert targetBCI >= 0 : \"invalid BCI\";\n-\n-        if (methodData.hasNormalData()) {\n-            int currentPosition = targetBCI < hintBCI ? 0 : hintPosition;\n-            HotSpotMethodDataAccessor currentAccessor;\n-            while ((currentAccessor = methodData.getNormalData(currentPosition)) != null) {\n-                int currentBCI = currentAccessor.getBCI(methodData, currentPosition);\n-                if (currentBCI == targetBCI) {\n-                    normalDataFound(currentAccessor, currentPosition, currentBCI);\n-                    return true;\n-                } else if (currentBCI > targetBCI) {\n-                    break;\n-                }\n-                currentPosition = currentPosition + currentAccessor.getSize(methodData, currentPosition);\n-            }\n-        }\n-        noDataFound(false);\n-        return false;\n-    }\n-\n-    private void normalDataFound(HotSpotMethodDataAccessor data, int pos, int bci) {\n-        setCurrentData(data, pos);\n-        this.hintPosition = position;\n-        this.hintBCI = bci;\n-    }\n-\n-    private void noDataFound(boolean exceptionPossiblyNotRecorded) {\n-        HotSpotMethodDataAccessor accessor = HotSpotMethodData.getNoDataAccessor(exceptionPossiblyNotRecorded);\n-        setCurrentData(accessor, -1);\n-    }\n-\n-    private void setCurrentData(HotSpotMethodDataAccessor dataAccessor, int position) {\n-        this.dataAccessor = dataAccessor;\n-        this.position = position;\n-    }\n-\n-    @Override\n-    public boolean isMature() {\n-        return isMature;\n-    }\n-\n-    public void ignoreMature() {\n-        isMature = true;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"HotSpotProfilingInfo<\" + this.toString(null, \"; \") + \">\";\n-    }\n-\n-    @Override\n-    public void setMature() {\n-        isMature = true;\n-    }\n+\/**\n+ * Extends {@link ProfilingInfo} with HotSpot specific profiling info.\n+ *\/\n+public interface HotSpotProfilingInfo extends ProfilingInfo {\n@@ -211,3 +33,1 @@\n-     * {@code MethodData::_jvmci_ir_size} (currently) supports at most one JVMCI compiler IR type\n-     * which will be determined by the first JVMCI compiler that calls\n-     * {@link #setCompilerIRSize(Class, int)}.\n+     * Returns {@code MethodData::_compiler_counters._nof_decompiles}.\n@@ -215,1 +35,1 @@\n-    private static volatile Class<?> supportedCompilerIRType;\n+    int getDecompileCount();\n@@ -217,15 +37,4 @@\n-    @Override\n-    public boolean setCompilerIRSize(Class<?> irType, int size) {\n-        if (supportedCompilerIRType == null) {\n-            synchronized (HotSpotProfilingInfo.class) {\n-                if (supportedCompilerIRType == null) {\n-                    supportedCompilerIRType = irType;\n-                }\n-            }\n-        }\n-        if (supportedCompilerIRType != irType) {\n-            return false;\n-        }\n-        methodData.setCompiledIRSize(size);\n-        return true;\n-    }\n+    \/**\n+     * Returns {@code MethodData::_compiler_counters._nof_overflow_recompiles}.\n+     *\/\n+    int getOverflowRecompileCount();\n@@ -233,7 +42,4 @@\n-    @Override\n-    public int getCompilerIRSize(Class<?> irType) {\n-        if (irType == supportedCompilerIRType) {\n-            return methodData.getCompiledIRSize();\n-        }\n-        return -1;\n-    }\n+    \/**\n+     * Returns {@code MethodData::_compiler_counters._nof_overflow_traps}.\n+     *\/\n+    int getOverflowTrapCount();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfo.java","additions":15,"deletions":209,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final class HotSpotProfilingInfo implements ProfilingInfo {\n+final class HotSpotProfilingInfoImpl implements HotSpotProfilingInfo {\n@@ -47,1 +47,1 @@\n-    HotSpotProfilingInfo(HotSpotMethodData methodData, HotSpotResolvedJavaMethod method, boolean includeNormal, boolean includeOSR) {\n+    HotSpotProfilingInfoImpl(HotSpotMethodData methodData, HotSpotResolvedJavaMethod method, boolean includeNormal, boolean includeOSR) {\n@@ -65,0 +65,1 @@\n+    @Override\n@@ -69,0 +70,1 @@\n+    @Override\n@@ -73,0 +75,1 @@\n+    @Override\n@@ -220,1 +223,1 @@\n-            synchronized (HotSpotProfilingInfo.class) {\n+            synchronized (HotSpotProfilingInfoImpl.class) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfoImpl.java","additions":7,"deletions":4,"binary":false,"changes":11,"previous_filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfo.java","status":"copied"},{"patch":"@@ -492,1 +492,1 @@\n-            info = new HotSpotProfilingInfo(methodData, this, includeNormal, includeOSR);\n+            info = new HotSpotProfilingInfoImpl(methodData, this, includeNormal, includeOSR);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,5 @@\n-    private static final ProfilingInfo[] NO_PROFILING_INFO = new ProfilingInfo[]{new DefaultProfilingInfo(TriState.TRUE), new DefaultProfilingInfo(TriState.FALSE),\n-                    new DefaultProfilingInfo(TriState.UNKNOWN)};\n+    private static final ProfilingInfo[] NO_PROFILING_INFO = {\n+        new DefaultProfilingInfo(TriState.TRUE),\n+        new DefaultProfilingInfo(TriState.FALSE),\n+        new DefaultProfilingInfo(TriState.UNKNOWN)\n+    };\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/DefaultProfilingInfo.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,4 @@\n+    \/**\n+     *  Covers sampling work (for Hotspot developer)\n+     *\/\n+    JFR_SYSTEM_SAMPLING(10),\n@@ -80,1 +84,1 @@\n-    JFR_PERIODIC(10),\n+    JFR_PERIODIC(11),\n@@ -84,1 +88,1 @@\n-    JFR_METADATA(11),\n+    JFR_METADATA(12),\n@@ -88,1 +92,1 @@\n-    JFR_EVENT(12),\n+    JFR_EVENT(13),\n@@ -92,1 +96,1 @@\n-    JFR_SETTING(13),\n+    JFR_SETTING(14),\n@@ -96,1 +100,1 @@\n-    JFR_DCMD(14),\n+    JFR_DCMD(15),\n@@ -100,1 +104,1 @@\n-    JFR_START(15);\n+    JFR_START(16);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LogTag.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -209,0 +209,7 @@\n+    <event name=\"jdk.SafepointLatency\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"throttle\">off<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -209,0 +209,7 @@\n+    <event name=\"jdk.SafepointLatency\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"stackTrace\">false<\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"throttle\">off<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7,1 +7,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CollectionUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7,1 +7,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CompositeProxy.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -162,4 +163,9 @@\n-            terminal = TerminalBuilder.builder().exec(allowExecTerminal).inputStreamWrapper(in -> {\n-                input.setInputStream(in);\n-                return nonBlockingInput;\n-            }).nativeSignals(false).build();\n+            terminal = TerminalBuilder.builder()\n+                                      .exec(allowExecTerminal)\n+                                      .inputStreamWrapper(in -> {\n+                                          input.setInputStream(in);\n+                                          return nonBlockingInput;\n+                                      })\n+                                      .nativeSignals(false)\n+                                      .encoding(System.getProperty(\"stdin.encoding\"))\n+                                      .build();\n@@ -971,0 +977,3 @@\n+    private static final Charset stdinCharset =\n+            Charset.forName(System.getProperty(\"stdin.encoding\"),\n+                            Charset.defaultCharset());\n@@ -993,1 +1002,1 @@\n-            pendingBytes = dataToConvert.toString().getBytes();\n+            pendingBytes = dataToConvert.toString().getBytes(stdinCharset);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,1 @@\n+import javax.lang.model.element.ModuleElement;\n@@ -253,0 +254,4 @@\n+        return guessKind(code, null);\n+    }\n+\n+    private Tree.Kind guessKind(String code, boolean[] moduleImport) {\n@@ -260,0 +265,3 @@\n+            if (moduleImport != null && unitTree.getKind() == Kind.IMPORT) {\n+                moduleImport[0] = ((ImportTree) unitTree).isModule();\n+            }\n@@ -295,2 +303,4 @@\n-        OuterWrap codeWrap = switch (guessKind(code)) {\n-            case IMPORT -> proc.outerMap.wrapImport(Wrap.simpleWrap(code + \"any.any\"), null);\n+        boolean[] moduleImport = new boolean[1];\n+        OuterWrap codeWrap = switch (guessKind(code, moduleImport)) {\n+            case IMPORT -> moduleImport[0] ? proc.outerMap.wrapImport(Wrap.simpleWrap(code), null)\n+                                           : proc.outerMap.wrapImport(Wrap.simpleWrap(code + \"any.any\"), null);\n@@ -300,3 +310,3 @@\n-        String requiredPrefix = identifier;\n-        return computeSuggestions(codeWrap, cursor, anchor).stream()\n-                .filter(s -> s.continuation().startsWith(requiredPrefix) && !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))\n+        String[] requiredPrefix = new String[] {identifier};\n+        return computeSuggestions(codeWrap, cursor, requiredPrefix, anchor).stream()\n+                .filter(s -> s.continuation().startsWith(requiredPrefix[0]) && !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))\n@@ -307,1 +317,1 @@\n-    private List<Suggestion> computeSuggestions(OuterWrap code, int cursor, int[] anchor) {\n+    private List<Suggestion> computeSuggestions(OuterWrap code, int cursor, String[] requiredPrefix, int[] anchor) {\n@@ -398,0 +408,15 @@\n+\n+                        if (it != null && it.isModule()) {\n+                            int selectStart = (int) sp.getStartPosition(topLevel, tp.getLeaf());\n+                            String qualifiedPrefix = it.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT\n+                                ? ((MemberSelectTree) it.getQualifiedIdentifier()).getExpression().toString() + \".\"\n+                                : \"\";\n+\n+                            addModuleElements(at, qualifiedPrefix, result);\n+\n+                            requiredPrefix[0] = qualifiedPrefix + requiredPrefix[0];\n+                            anchor[0] = selectStart;\n+\n+                            return result;\n+                        }\n+\n@@ -457,12 +482,18 @@\n-                            \/\/ the context of the identifier is an import, look for\n-                            \/\/ package names that start with the identifier.\n-                            \/\/ If and when Java allows imports from the default\n-                            \/\/ package to the default package which would allow\n-                            \/\/ JShell to change to use the default package, and that\n-                            \/\/ change is done, then this should use some variation\n-                            \/\/ of membersOf(at, at.getElements().getPackageElement(\"\").asType(), false)\n-                            addElements(listPackages(at, \"\"),\n-                                    it.isStatic()\n-                                            ? STATIC_ONLY.and(accessibility)\n-                                            : accessibility,\n-                                    smartFilter, result);\n+                            if (it.isModule()) {\n+                                addModuleElements(at, \"\", result);\n+                            } else {\n+                                \/\/ the context of the identifier is an import, look for\n+                                \/\/ package names that start with the identifier.\n+                                \/\/ If and when Java allows imports from the default\n+                                \/\/ package to the default package which would allow\n+                                \/\/ JShell to change to use the default package, and that\n+                                \/\/ change is done, then this should use some variation\n+                                \/\/ of membersOf(at, at.getElements().getPackageElement(\"\").asType(), false)\n+                                addElements(listPackages(at, \"\"),\n+                                        it.isStatic()\n+                                                ? STATIC_ONLY.and(accessibility)\n+                                                : accessibility,\n+                                        smartFilter, result);\n+\n+                                result.add(new SuggestionImpl(\"module \", false));\n+                            }\n@@ -1017,0 +1048,12 @@\n+    private void addModuleElements(AnalyzeTask at,\n+                                   String prefix,\n+                                   List<Suggestion> result) {\n+        for (ModuleElement me : at.getElements().getAllModuleElements()) {\n+            if (!me.getQualifiedName().toString().startsWith(prefix)) {\n+                continue;\n+            }\n+            result.add(new SuggestionImpl(me.getQualifiedName().toString(),\n+                                          false));\n+        }\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":62,"deletions":19,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.time.Duration;\n@@ -52,2 +53,0 @@\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Stream;\n@@ -74,1 +73,6 @@\n-    private static final int SHUTDOWN_TIMEOUT = 1; \/\/1 second\n+    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(1);\n+    private static final List<String> FORWARD_SYSTEM_PROPERTIES = List.of(\n+        \"stderr.encoding\",\n+        \"stdin.encoding\",\n+        \"stdout.encoding\"\n+    );\n@@ -108,5 +112,9 @@\n-            List<String> augmentedremoteVMOptions =\n-                    Stream.concat(env.extraRemoteVMOptions().stream(),\n-                                  \/\/disable System.console():\n-                                  List.of(\"-Djdk.console=\" + consoleModule).stream())\n-                          .toList();\n+            List<String> augmentedremoteVMOptions = new ArrayList<>();\n+\n+            \/\/the stdin\/out\/err.encoding properties are always defined, and can be copied:\n+            FORWARD_SYSTEM_PROPERTIES.forEach(\n+                    prop -> augmentedremoteVMOptions.add(\"-D\" + prop + \"=\" +\n+                                                         System.getProperty(prop)));\n+            augmentedremoteVMOptions.addAll(env.extraRemoteVMOptions());\n+            augmentedremoteVMOptions.add(\"-Djdk.console=\" + consoleModule);\n+\n@@ -282,1 +290,1 @@\n-                remoteProcess.waitFor(SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);\n+                remoteProcess.waitFor(SHUTDOWN_TIMEOUT);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n@@ -93,0 +95,1 @@\n+    private static final String STOP_CHECK = \"stopCheck\";\n@@ -99,12 +102,1 @@\n-                            CodeTransform.ofStateful(() -> {\n-                                Set<Label> priorLabels = new HashSet<>();\n-                                return (builder, element) -> {\n-                                    switch (element) {\n-                                        case LabelTarget target -> priorLabels.add(target.label());\n-                                        case BranchInstruction branch when priorLabels.contains(branch.target())\n-                                            -> builder.invokestatic(CD_Cancel, \"stopCheck\", ConstantDescs.MTD_void);\n-                                        default -> { }\n-                                    }\n-                                    builder.with(element);\n-                                };\n-                            })));\n+                            CodeTransform.ofStateful(StopCheckWeaver::new)));\n@@ -117,1 +109,1 @@\n-                .withMethodBody(\"stopCheck\", ConstantDescs.MTD_void, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob ->\n+                .withMethodBody(STOP_CHECK, ConstantDescs.MTD_void, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob ->\n@@ -126,0 +118,25 @@\n+    \/\/ This inserts calls to REPL.$Cancel$.stopCheck() at method start and prior to any backward branch\n+    private static class StopCheckWeaver implements CodeTransform {\n+\n+        private final Set<Label> priorLabels = new HashSet<>();\n+\n+        @Override\n+        public void atStart(CodeBuilder builder) {\n+            stopCheck(builder);\n+        }\n+\n+        @Override\n+        public void accept(CodeBuilder builder, CodeElement element) {\n+            switch (element) {\n+                case LabelTarget target -> priorLabels.add(target.label());\n+                case BranchInstruction branch when priorLabels.contains(branch.target()) -> stopCheck(builder);\n+                default -> { }\n+            }\n+            builder.with(element);\n+        };\n+\n+        private void stopCheck(CodeBuilder builder) {\n+            builder.invokestatic(CD_Cancel, STOP_CHECK, ConstantDescs.MTD_void);\n+        }\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -832,1 +833,1 @@\n-            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n+            int n = receive0(fd, resultContainer, NIO_ACCESS.getBufferAddress(bb) + pos, rem, peek);\n@@ -1015,1 +1016,1 @@\n-            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+            int written = send0(fd, NIO_ACCESS.getBufferAddress(bb) + pos, rem, addr,\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -564,1 +565,1 @@\n-            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n+            int n = receive0(fd, resultContainer, NIO_ACCESS.getBufferAddress(bb) + pos, rem);\n@@ -873,1 +874,1 @@\n-            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+            int written = send0(fd, NIO_ACCESS.getBufferAddress(bb) + pos, rem, addr,\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1783,1 +1783,2 @@\n-          [\"fabs\", \"fabs\", \"2D\"],\n+          [\"fabs\", \"fabs\", \"2D\"], [\"fabs\", \"fabs\", \"4H\"],\n+          [\"fabs\", \"fabs\", \"8H\"],\n@@ -1785,1 +1786,2 @@\n-          [\"fneg\", \"fneg\", \"2D\"],\n+          [\"fneg\", \"fneg\", \"2D\"], [\"fneg\", \"fneg\", \"4H\"],\n+          [\"fneg\", \"fneg\", \"8H\"],\n@@ -1787,1 +1789,2 @@\n-          [\"fsqrt\", \"fsqrt\", \"2D\"],\n+          [\"fsqrt\", \"fsqrt\", \"2D\"], [\"fsqrt\", \"fsqrt\", \"4H\"],\n+          [\"fsqrt\", \"fsqrt\", \"8H\"],\n@@ -1808,1 +1811,2 @@\n-          [\"fadd\", \"fadd\", \"2D\"],\n+          [\"fadd\", \"fadd\", \"2D\"], [\"fadd\", \"fadd\", \"4H\"],\n+          [\"fadd\", \"fadd\", \"8H\"],\n@@ -1822,1 +1826,2 @@\n-          [\"fsub\", \"fsub\", \"2D\"],\n+          [\"fsub\", \"fsub\", \"2D\"], [\"fsub\", \"fsub\", \"4H\"],\n+          [\"fsub\", \"fsub\", \"8H\"],\n@@ -1827,1 +1832,2 @@\n-          [\"fabd\", \"fabd\", \"2D\"],\n+          [\"fabd\", \"fabd\", \"2D\"], [\"fabd\", \"fabd\", \"4H\"],\n+          [\"fabd\", \"fabd\", \"8H\"],\n@@ -1829,1 +1835,2 @@\n-          [\"faddp\", \"faddp\", \"2D\"],\n+          [\"faddp\", \"faddp\", \"2D\"], [\"faddp\", \"faddp\", \"4H\"],\n+          [\"faddp\", \"faddp\", \"8H\"],\n@@ -1831,1 +1838,2 @@\n-          [\"fmul\", \"fmul\", \"2D\"],\n+          [\"fmul\", \"fmul\", \"2D\"], [\"fmul\", \"fmul\", \"4H\"],\n+          [\"fmul\", \"fmul\", \"8H\"],\n@@ -1835,1 +1843,2 @@\n-          [\"fmla\", \"fmla\", \"2D\"],\n+          [\"fmla\", \"fmla\", \"2D\"], [\"fmla\", \"fmla\", \"4H\"],\n+          [\"fmla\", \"fmla\", \"8H\"],\n@@ -1839,1 +1848,2 @@\n-          [\"fmls\", \"fmls\", \"2D\"],\n+          [\"fmls\", \"fmls\", \"2D\"], [\"fmls\", \"fmls\", \"4H\"],\n+          [\"fmls\", \"fmls\", \"8H\"],\n@@ -1841,1 +1851,2 @@\n-          [\"fdiv\", \"fdiv\", \"2D\"],\n+          [\"fdiv\", \"fdiv\", \"2D\"], [\"fdiv\", \"fdiv\", \"4H\"],\n+          [\"fdiv\", \"fdiv\", \"8H\"],\n@@ -1852,1 +1863,2 @@\n-          [\"fmax\", \"fmax\", \"2D\"],\n+          [\"fmax\", \"fmax\", \"2D\"], [\"fmax\", \"fmax\", \"4H\"],\n+          [\"fmax\", \"fmax\", \"8H\"],\n@@ -1868,1 +1880,2 @@\n-          [\"fmin\", \"fmin\", \"2D\"],\n+          [\"fmin\", \"fmin\", \"2D\"], [\"fmin\", \"fmin\", \"4H\"],\n+          [\"fmin\", \"fmin\", \"8H\"],\n@@ -1870,1 +1883,2 @@\n-          [\"facgt\", \"facgt\", \"2D\"],\n+          [\"facgt\", \"facgt\", \"2D\"], [\"facgt\", \"facgt\", \"4H\"],\n+          [\"facgt\", \"facgt\", \"8H\"],\n@@ -1931,0 +1945,2 @@\n+                        [\"fcvtzs\", \"__ fcvtzs(v0, __ T4H, v1);\",                         \"fcvtzs\\tv0.4h, v1.4h\"],\n+                        [\"fcvtzs\", \"__ fcvtzs(v0, __ T8H, v1);\",                         \"fcvtzs\\tv0.8h, v1.8h\"],\n@@ -1932,0 +1948,2 @@\n+                        [\"fcvtas\", \"__ fcvtas(v2, __ T4H, v3);\",                         \"fcvtas\\tv2.4h, v3.4h\"],\n+                        [\"fcvtas\", \"__ fcvtas(v2, __ T8H, v3);\",                         \"fcvtas\\tv2.8h, v3.8h\"],\n@@ -1933,0 +1951,2 @@\n+                        [\"fcvtms\", \"__ fcvtms(v4, __ T4H, v5);\",                         \"fcvtms\\tv4.4h, v5.4h\"],\n+                        [\"fcvtms\", \"__ fcvtms(v4, __ T8H, v5);\",                         \"fcvtms\\tv4.8h, v5.8h\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -669,8 +669,14 @@\n-    __ fneg(v1, __ T2S, v2);                           \/\/       fneg    v1.2S, v2.2S\n-    __ fneg(v0, __ T4S, v1);                           \/\/       fneg    v0.4S, v1.4S\n-    __ fneg(v24, __ T2D, v25);                         \/\/       fneg    v24.2D, v25.2D\n-    __ fsqrt(v4, __ T2S, v5);                          \/\/       fsqrt   v4.2S, v5.2S\n-    __ fsqrt(v3, __ T4S, v4);                          \/\/       fsqrt   v3.4S, v4.4S\n-    __ fsqrt(v12, __ T2D, v13);                        \/\/       fsqrt   v12.2D, v13.2D\n-    __ notr(v31, __ T8B, v0);                          \/\/       not     v31.8B, v0.8B\n-    __ notr(v28, __ T16B, v29);                        \/\/       not     v28.16B, v29.16B\n+    __ fabs(v1, __ T4H, v2);                           \/\/       fabs    v1.4H, v2.4H\n+    __ fabs(v0, __ T8H, v1);                           \/\/       fabs    v0.8H, v1.8H\n+    __ fneg(v24, __ T2S, v25);                         \/\/       fneg    v24.2S, v25.2S\n+    __ fneg(v4, __ T4S, v5);                           \/\/       fneg    v4.4S, v5.4S\n+    __ fneg(v3, __ T2D, v4);                           \/\/       fneg    v3.2D, v4.2D\n+    __ fneg(v12, __ T4H, v13);                         \/\/       fneg    v12.4H, v13.4H\n+    __ fneg(v31, __ T8H, v0);                          \/\/       fneg    v31.8H, v0.8H\n+    __ fsqrt(v28, __ T2S, v29);                        \/\/       fsqrt   v28.2S, v29.2S\n+    __ fsqrt(v10, __ T4S, v11);                        \/\/       fsqrt   v10.4S, v11.4S\n+    __ fsqrt(v26, __ T2D, v27);                        \/\/       fsqrt   v26.2D, v27.2D\n+    __ fsqrt(v2, __ T4H, v3);                          \/\/       fsqrt   v2.4H, v3.4H\n+    __ fsqrt(v12, __ T8H, v13);                        \/\/       fsqrt   v12.8H, v13.8H\n+    __ notr(v18, __ T8B, v19);                         \/\/       not     v18.8B, v19.8B\n+    __ notr(v31, __ T16B, v0);                         \/\/       not     v31.16B, v0.16B\n@@ -679,16 +685,16 @@\n-    __ andr(v10, __ T8B, v11, v12);                    \/\/       and     v10.8B, v11.8B, v12.8B\n-    __ andr(v26, __ T16B, v27, v28);                   \/\/       and     v26.16B, v27.16B, v28.16B\n-    __ orr(v2, __ T8B, v3, v4);                        \/\/       orr     v2.8B, v3.8B, v4.8B\n-    __ orr(v12, __ T16B, v13, v14);                    \/\/       orr     v12.16B, v13.16B, v14.16B\n-    __ eor(v18, __ T8B, v19, v20);                     \/\/       eor     v18.8B, v19.8B, v20.8B\n-    __ eor(v31, __ T16B, v0, v1);                      \/\/       eor     v31.16B, v0.16B, v1.16B\n-    __ addv(v1, __ T8B, v2, v3);                       \/\/       add     v1.8B, v2.8B, v3.8B\n-    __ addv(v13, __ T16B, v14, v15);                   \/\/       add     v13.16B, v14.16B, v15.16B\n-    __ addv(v29, __ T4H, v30, v31);                    \/\/       add     v29.4H, v30.4H, v31.4H\n-    __ addv(v0, __ T8H, v1, v2);                       \/\/       add     v0.8H, v1.8H, v2.8H\n-    __ addv(v19, __ T2S, v20, v21);                    \/\/       add     v19.2S, v20.2S, v21.2S\n-    __ addv(v12, __ T4S, v13, v14);                    \/\/       add     v12.4S, v13.4S, v14.4S\n-    __ addv(v17, __ T2D, v18, v19);                    \/\/       add     v17.2D, v18.2D, v19.2D\n-    __ sqaddv(v22, __ T8B, v23, v24);                  \/\/       sqadd   v22.8B, v23.8B, v24.8B\n-    __ sqaddv(v13, __ T16B, v14, v15);                 \/\/       sqadd   v13.16B, v14.16B, v15.16B\n-    __ sqaddv(v28, __ T4H, v29, v30);                  \/\/       sqadd   v28.4H, v29.4H, v30.4H\n+    __ andr(v1, __ T8B, v2, v3);                       \/\/       and     v1.8B, v2.8B, v3.8B\n+    __ andr(v13, __ T16B, v14, v15);                   \/\/       and     v13.16B, v14.16B, v15.16B\n+    __ orr(v29, __ T8B, v30, v31);                     \/\/       orr     v29.8B, v30.8B, v31.8B\n+    __ orr(v0, __ T16B, v1, v2);                       \/\/       orr     v0.16B, v1.16B, v2.16B\n+    __ eor(v19, __ T8B, v20, v21);                     \/\/       eor     v19.8B, v20.8B, v21.8B\n+    __ eor(v12, __ T16B, v13, v14);                    \/\/       eor     v12.16B, v13.16B, v14.16B\n+    __ addv(v17, __ T8B, v18, v19);                    \/\/       add     v17.8B, v18.8B, v19.8B\n+    __ addv(v22, __ T16B, v23, v24);                   \/\/       add     v22.16B, v23.16B, v24.16B\n+    __ addv(v13, __ T4H, v14, v15);                    \/\/       add     v13.4H, v14.4H, v15.4H\n+    __ addv(v28, __ T8H, v29, v30);                    \/\/       add     v28.8H, v29.8H, v30.8H\n+    __ addv(v30, __ T2S, v31, v0);                     \/\/       add     v30.2S, v31.2S, v0.2S\n+    __ addv(v31, __ T4S, v0, v1);                      \/\/       add     v31.4S, v0.4S, v1.4S\n+    __ addv(v1, __ T2D, v2, v3);                       \/\/       add     v1.2D, v2.2D, v3.2D\n+    __ sqaddv(v26, __ T8B, v27, v28);                  \/\/       sqadd   v26.8B, v27.8B, v28.8B\n+    __ sqaddv(v28, __ T16B, v29, v30);                 \/\/       sqadd   v28.16B, v29.16B, v30.16B\n+    __ sqaddv(v4, __ T4H, v5, v6);                     \/\/       sqadd   v4.4H, v5.4H, v6.4H\n@@ -696,26 +702,28 @@\n-    __ sqaddv(v31, __ T2S, v0, v1);                    \/\/       sqadd   v31.2S, v0.2S, v1.2S\n-    __ sqaddv(v1, __ T4S, v2, v3);                     \/\/       sqadd   v1.4S, v2.4S, v3.4S\n-    __ sqaddv(v26, __ T2D, v27, v28);                  \/\/       sqadd   v26.2D, v27.2D, v28.2D\n-    __ uqaddv(v28, __ T8B, v29, v30);                  \/\/       uqadd   v28.8B, v29.8B, v30.8B\n-    __ uqaddv(v4, __ T16B, v5, v6);                    \/\/       uqadd   v4.16B, v5.16B, v6.16B\n-    __ uqaddv(v30, __ T4H, v31, v0);                   \/\/       uqadd   v30.4H, v31.4H, v0.4H\n-    __ uqaddv(v4, __ T8H, v5, v6);                     \/\/       uqadd   v4.8H, v5.8H, v6.8H\n-    __ uqaddv(v6, __ T2S, v7, v8);                     \/\/       uqadd   v6.2S, v7.2S, v8.2S\n-    __ uqaddv(v30, __ T4S, v31, v0);                   \/\/       uqadd   v30.4S, v31.4S, v0.4S\n-    __ uqaddv(v26, __ T2D, v27, v28);                  \/\/       uqadd   v26.2D, v27.2D, v28.2D\n-    __ fadd(v18, __ T2S, v19, v20);                    \/\/       fadd    v18.2S, v19.2S, v20.2S\n-    __ fadd(v9, __ T4S, v10, v11);                     \/\/       fadd    v9.4S, v10.4S, v11.4S\n-    __ fadd(v8, __ T2D, v9, v10);                      \/\/       fadd    v8.2D, v9.2D, v10.2D\n-    __ subv(v12, __ T8B, v13, v14);                    \/\/       sub     v12.8B, v13.8B, v14.8B\n-    __ subv(v0, __ T16B, v1, v2);                      \/\/       sub     v0.16B, v1.16B, v2.16B\n-    __ subv(v20, __ T4H, v21, v22);                    \/\/       sub     v20.4H, v21.4H, v22.4H\n-    __ subv(v1, __ T8H, v2, v3);                       \/\/       sub     v1.8H, v2.8H, v3.8H\n-    __ subv(v24, __ T2S, v25, v26);                    \/\/       sub     v24.2S, v25.2S, v26.2S\n-    __ subv(v2, __ T4S, v3, v4);                       \/\/       sub     v2.4S, v3.4S, v4.4S\n-    __ subv(v0, __ T2D, v1, v2);                       \/\/       sub     v0.2D, v1.2D, v2.2D\n-    __ sqsubv(v9, __ T8B, v10, v11);                   \/\/       sqsub   v9.8B, v10.8B, v11.8B\n-    __ sqsubv(v24, __ T16B, v25, v26);                 \/\/       sqsub   v24.16B, v25.16B, v26.16B\n-    __ sqsubv(v26, __ T4H, v27, v28);                  \/\/       sqsub   v26.4H, v27.4H, v28.4H\n-    __ sqsubv(v16, __ T8H, v17, v18);                  \/\/       sqsub   v16.8H, v17.8H, v18.8H\n-    __ sqsubv(v30, __ T2S, v31, v0);                   \/\/       sqsub   v30.2S, v31.2S, v0.2S\n-    __ sqsubv(v3, __ T4S, v4, v5);                     \/\/       sqsub   v3.4S, v4.4S, v5.4S\n+    __ sqaddv(v4, __ T2S, v5, v6);                     \/\/       sqadd   v4.2S, v5.2S, v6.2S\n+    __ sqaddv(v6, __ T4S, v7, v8);                     \/\/       sqadd   v6.4S, v7.4S, v8.4S\n+    __ sqaddv(v30, __ T2D, v31, v0);                   \/\/       sqadd   v30.2D, v31.2D, v0.2D\n+    __ uqaddv(v26, __ T8B, v27, v28);                  \/\/       uqadd   v26.8B, v27.8B, v28.8B\n+    __ uqaddv(v18, __ T16B, v19, v20);                 \/\/       uqadd   v18.16B, v19.16B, v20.16B\n+    __ uqaddv(v9, __ T4H, v10, v11);                   \/\/       uqadd   v9.4H, v10.4H, v11.4H\n+    __ uqaddv(v8, __ T8H, v9, v10);                    \/\/       uqadd   v8.8H, v9.8H, v10.8H\n+    __ uqaddv(v12, __ T2S, v13, v14);                  \/\/       uqadd   v12.2S, v13.2S, v14.2S\n+    __ uqaddv(v0, __ T4S, v1, v2);                     \/\/       uqadd   v0.4S, v1.4S, v2.4S\n+    __ uqaddv(v20, __ T2D, v21, v22);                  \/\/       uqadd   v20.2D, v21.2D, v22.2D\n+    __ fadd(v1, __ T2S, v2, v3);                       \/\/       fadd    v1.2S, v2.2S, v3.2S\n+    __ fadd(v24, __ T4S, v25, v26);                    \/\/       fadd    v24.4S, v25.4S, v26.4S\n+    __ fadd(v2, __ T2D, v3, v4);                       \/\/       fadd    v2.2D, v3.2D, v4.2D\n+    __ fadd(v0, __ T4H, v1, v2);                       \/\/       fadd    v0.4H, v1.4H, v2.4H\n+    __ fadd(v9, __ T8H, v10, v11);                     \/\/       fadd    v9.8H, v10.8H, v11.8H\n+    __ subv(v24, __ T8B, v25, v26);                    \/\/       sub     v24.8B, v25.8B, v26.8B\n+    __ subv(v26, __ T16B, v27, v28);                   \/\/       sub     v26.16B, v27.16B, v28.16B\n+    __ subv(v16, __ T4H, v17, v18);                    \/\/       sub     v16.4H, v17.4H, v18.4H\n+    __ subv(v30, __ T8H, v31, v0);                     \/\/       sub     v30.8H, v31.8H, v0.8H\n+    __ subv(v3, __ T2S, v4, v5);                       \/\/       sub     v3.2S, v4.2S, v5.2S\n+    __ subv(v10, __ T4S, v11, v12);                    \/\/       sub     v10.4S, v11.4S, v12.4S\n+    __ subv(v23, __ T2D, v24, v25);                    \/\/       sub     v23.2D, v24.2D, v25.2D\n+    __ sqsubv(v10, __ T8B, v11, v12);                  \/\/       sqsub   v10.8B, v11.8B, v12.8B\n+    __ sqsubv(v4, __ T16B, v5, v6);                    \/\/       sqsub   v4.16B, v5.16B, v6.16B\n+    __ sqsubv(v18, __ T4H, v19, v20);                  \/\/       sqsub   v18.4H, v19.4H, v20.4H\n+    __ sqsubv(v2, __ T8H, v3, v4);                     \/\/       sqsub   v2.8H, v3.8H, v4.8H\n+    __ sqsubv(v11, __ T2S, v12, v13);                  \/\/       sqsub   v11.2S, v12.2S, v13.2S\n+    __ sqsubv(v8, __ T4S, v9, v10);                    \/\/       sqsub   v8.4S, v9.4S, v10.4S\n@@ -723,27 +731,35 @@\n-    __ uqsubv(v23, __ T8B, v24, v25);                  \/\/       uqsub   v23.8B, v24.8B, v25.8B\n-    __ uqsubv(v10, __ T16B, v11, v12);                 \/\/       uqsub   v10.16B, v11.16B, v12.16B\n-    __ uqsubv(v4, __ T4H, v5, v6);                     \/\/       uqsub   v4.4H, v5.4H, v6.4H\n-    __ uqsubv(v18, __ T8H, v19, v20);                  \/\/       uqsub   v18.8H, v19.8H, v20.8H\n-    __ uqsubv(v2, __ T2S, v3, v4);                     \/\/       uqsub   v2.2S, v3.2S, v4.2S\n-    __ uqsubv(v11, __ T4S, v12, v13);                  \/\/       uqsub   v11.4S, v12.4S, v13.4S\n-    __ uqsubv(v8, __ T2D, v9, v10);                    \/\/       uqsub   v8.2D, v9.2D, v10.2D\n-    __ fsub(v10, __ T2S, v11, v12);                    \/\/       fsub    v10.2S, v11.2S, v12.2S\n-    __ fsub(v15, __ T4S, v16, v17);                    \/\/       fsub    v15.4S, v16.4S, v17.4S\n-    __ fsub(v17, __ T2D, v18, v19);                    \/\/       fsub    v17.2D, v18.2D, v19.2D\n-    __ mulv(v2, __ T8B, v3, v4);                       \/\/       mul     v2.8B, v3.8B, v4.8B\n-    __ mulv(v10, __ T16B, v11, v12);                   \/\/       mul     v10.16B, v11.16B, v12.16B\n-    __ mulv(v12, __ T4H, v13, v14);                    \/\/       mul     v12.4H, v13.4H, v14.4H\n-    __ mulv(v12, __ T8H, v13, v14);                    \/\/       mul     v12.8H, v13.8H, v14.8H\n-    __ mulv(v15, __ T2S, v16, v17);                    \/\/       mul     v15.2S, v16.2S, v17.2S\n-    __ mulv(v13, __ T4S, v14, v15);                    \/\/       mul     v13.4S, v14.4S, v15.4S\n-    __ fabd(v2, __ T2S, v3, v4);                       \/\/       fabd    v2.2S, v3.2S, v4.2S\n-    __ fabd(v7, __ T4S, v8, v9);                       \/\/       fabd    v7.4S, v8.4S, v9.4S\n-    __ fabd(v20, __ T2D, v21, v22);                    \/\/       fabd    v20.2D, v21.2D, v22.2D\n-    __ faddp(v26, __ T2S, v27, v28);                   \/\/       faddp   v26.2S, v27.2S, v28.2S\n-    __ faddp(v16, __ T4S, v17, v18);                   \/\/       faddp   v16.4S, v17.4S, v18.4S\n-    __ faddp(v4, __ T2D, v5, v6);                      \/\/       faddp   v4.2D, v5.2D, v6.2D\n-    __ fmul(v2, __ T2S, v3, v4);                       \/\/       fmul    v2.2S, v3.2S, v4.2S\n-    __ fmul(v4, __ T4S, v5, v6);                       \/\/       fmul    v4.4S, v5.4S, v6.4S\n-    __ fmul(v12, __ T2D, v13, v14);                    \/\/       fmul    v12.2D, v13.2D, v14.2D\n-    __ mlav(v18, __ T4H, v19, v20);                    \/\/       mla     v18.4H, v19.4H, v20.4H\n-    __ mlav(v21, __ T8H, v22, v23);                    \/\/       mla     v21.8H, v22.8H, v23.8H\n+    __ uqsubv(v15, __ T8B, v16, v17);                  \/\/       uqsub   v15.8B, v16.8B, v17.8B\n+    __ uqsubv(v17, __ T16B, v18, v19);                 \/\/       uqsub   v17.16B, v18.16B, v19.16B\n+    __ uqsubv(v2, __ T4H, v3, v4);                     \/\/       uqsub   v2.4H, v3.4H, v4.4H\n+    __ uqsubv(v10, __ T8H, v11, v12);                  \/\/       uqsub   v10.8H, v11.8H, v12.8H\n+    __ uqsubv(v12, __ T2S, v13, v14);                  \/\/       uqsub   v12.2S, v13.2S, v14.2S\n+    __ uqsubv(v12, __ T4S, v13, v14);                  \/\/       uqsub   v12.4S, v13.4S, v14.4S\n+    __ uqsubv(v15, __ T2D, v16, v17);                  \/\/       uqsub   v15.2D, v16.2D, v17.2D\n+    __ fsub(v13, __ T2S, v14, v15);                    \/\/       fsub    v13.2S, v14.2S, v15.2S\n+    __ fsub(v2, __ T4S, v3, v4);                       \/\/       fsub    v2.4S, v3.4S, v4.4S\n+    __ fsub(v7, __ T2D, v8, v9);                       \/\/       fsub    v7.2D, v8.2D, v9.2D\n+    __ fsub(v20, __ T4H, v21, v22);                    \/\/       fsub    v20.4H, v21.4H, v22.4H\n+    __ fsub(v26, __ T8H, v27, v28);                    \/\/       fsub    v26.8H, v27.8H, v28.8H\n+    __ mulv(v16, __ T8B, v17, v18);                    \/\/       mul     v16.8B, v17.8B, v18.8B\n+    __ mulv(v4, __ T16B, v5, v6);                      \/\/       mul     v4.16B, v5.16B, v6.16B\n+    __ mulv(v2, __ T4H, v3, v4);                       \/\/       mul     v2.4H, v3.4H, v4.4H\n+    __ mulv(v4, __ T8H, v5, v6);                       \/\/       mul     v4.8H, v5.8H, v6.8H\n+    __ mulv(v12, __ T2S, v13, v14);                    \/\/       mul     v12.2S, v13.2S, v14.2S\n+    __ mulv(v18, __ T4S, v19, v20);                    \/\/       mul     v18.4S, v19.4S, v20.4S\n+    __ fabd(v21, __ T2S, v22, v23);                    \/\/       fabd    v21.2S, v22.2S, v23.2S\n+    __ fabd(v16, __ T4S, v17, v18);                    \/\/       fabd    v16.4S, v17.4S, v18.4S\n+    __ fabd(v18, __ T2D, v19, v20);                    \/\/       fabd    v18.2D, v19.2D, v20.2D\n+    __ fabd(v11, __ T4H, v12, v13);                    \/\/       fabd    v11.4H, v12.4H, v13.4H\n+    __ fabd(v21, __ T8H, v22, v23);                    \/\/       fabd    v21.8H, v22.8H, v23.8H\n+    __ faddp(v23, __ T2S, v24, v25);                   \/\/       faddp   v23.2S, v24.2S, v25.2S\n+    __ faddp(v12, __ T4S, v13, v14);                   \/\/       faddp   v12.4S, v13.4S, v14.4S\n+    __ faddp(v26, __ T2D, v27, v28);                   \/\/       faddp   v26.2D, v27.2D, v28.2D\n+    __ faddp(v23, __ T4H, v24, v25);                   \/\/       faddp   v23.4H, v24.4H, v25.4H\n+    __ faddp(v28, __ T8H, v29, v30);                   \/\/       faddp   v28.8H, v29.8H, v30.8H\n+    __ fmul(v14, __ T2S, v15, v16);                    \/\/       fmul    v14.2S, v15.2S, v16.2S\n+    __ fmul(v11, __ T4S, v12, v13);                    \/\/       fmul    v11.4S, v12.4S, v13.4S\n+    __ fmul(v24, __ T2D, v25, v26);                    \/\/       fmul    v24.2D, v25.2D, v26.2D\n+    __ fmul(v1, __ T4H, v2, v3);                       \/\/       fmul    v1.4H, v2.4H, v3.4H\n+    __ fmul(v12, __ T8H, v13, v14);                    \/\/       fmul    v12.8H, v13.8H, v14.8H\n+    __ mlav(v31, __ T4H, v0, v1);                      \/\/       mla     v31.4H, v0.4H, v1.4H\n+    __ mlav(v10, __ T8H, v11, v12);                    \/\/       mla     v10.8H, v11.8H, v12.8H\n@@ -751,22 +767,28 @@\n-    __ mlav(v18, __ T4S, v19, v20);                    \/\/       mla     v18.4S, v19.4S, v20.4S\n-    __ fmla(v11, __ T2S, v12, v13);                    \/\/       fmla    v11.2S, v12.2S, v13.2S\n-    __ fmla(v21, __ T4S, v22, v23);                    \/\/       fmla    v21.4S, v22.4S, v23.4S\n-    __ fmla(v23, __ T2D, v24, v25);                    \/\/       fmla    v23.2D, v24.2D, v25.2D\n-    __ mlsv(v12, __ T4H, v13, v14);                    \/\/       mls     v12.4H, v13.4H, v14.4H\n-    __ mlsv(v26, __ T8H, v27, v28);                    \/\/       mls     v26.8H, v27.8H, v28.8H\n-    __ mlsv(v23, __ T2S, v24, v25);                    \/\/       mls     v23.2S, v24.2S, v25.2S\n-    __ mlsv(v28, __ T4S, v29, v30);                    \/\/       mls     v28.4S, v29.4S, v30.4S\n-    __ fmls(v14, __ T2S, v15, v16);                    \/\/       fmls    v14.2S, v15.2S, v16.2S\n-    __ fmls(v11, __ T4S, v12, v13);                    \/\/       fmls    v11.4S, v12.4S, v13.4S\n-    __ fmls(v24, __ T2D, v25, v26);                    \/\/       fmls    v24.2D, v25.2D, v26.2D\n-    __ fdiv(v1, __ T2S, v2, v3);                       \/\/       fdiv    v1.2S, v2.2S, v3.2S\n-    __ fdiv(v12, __ T4S, v13, v14);                    \/\/       fdiv    v12.4S, v13.4S, v14.4S\n-    __ fdiv(v31, __ T2D, v0, v1);                      \/\/       fdiv    v31.2D, v0.2D, v1.2D\n-    __ maxv(v10, __ T8B, v11, v12);                    \/\/       smax    v10.8B, v11.8B, v12.8B\n-    __ maxv(v16, __ T16B, v17, v18);                   \/\/       smax    v16.16B, v17.16B, v18.16B\n-    __ maxv(v7, __ T4H, v8, v9);                       \/\/       smax    v7.4H, v8.4H, v9.4H\n-    __ maxv(v2, __ T8H, v3, v4);                       \/\/       smax    v2.8H, v3.8H, v4.8H\n-    __ maxv(v3, __ T2S, v4, v5);                       \/\/       smax    v3.2S, v4.2S, v5.2S\n-    __ maxv(v13, __ T4S, v14, v15);                    \/\/       smax    v13.4S, v14.4S, v15.4S\n-    __ umaxv(v19, __ T8B, v20, v21);                   \/\/       umax    v19.8B, v20.8B, v21.8B\n-    __ umaxv(v17, __ T16B, v18, v19);                  \/\/       umax    v17.16B, v18.16B, v19.16B\n+    __ mlav(v7, __ T4S, v8, v9);                       \/\/       mla     v7.4S, v8.4S, v9.4S\n+    __ fmla(v2, __ T2S, v3, v4);                       \/\/       fmla    v2.2S, v3.2S, v4.2S\n+    __ fmla(v3, __ T4S, v4, v5);                       \/\/       fmla    v3.4S, v4.4S, v5.4S\n+    __ fmla(v13, __ T2D, v14, v15);                    \/\/       fmla    v13.2D, v14.2D, v15.2D\n+    __ fmla(v19, __ T4H, v20, v21);                    \/\/       fmla    v19.4H, v20.4H, v21.4H\n+    __ fmla(v17, __ T8H, v18, v19);                    \/\/       fmla    v17.8H, v18.8H, v19.8H\n+    __ mlsv(v16, __ T4H, v17, v18);                    \/\/       mls     v16.4H, v17.4H, v18.4H\n+    __ mlsv(v3, __ T8H, v4, v5);                       \/\/       mls     v3.8H, v4.8H, v5.8H\n+    __ mlsv(v1, __ T2S, v2, v3);                       \/\/       mls     v1.2S, v2.2S, v3.2S\n+    __ mlsv(v11, __ T4S, v12, v13);                    \/\/       mls     v11.4S, v12.4S, v13.4S\n+    __ fmls(v30, __ T2S, v31, v0);                     \/\/       fmls    v30.2S, v31.2S, v0.2S\n+    __ fmls(v5, __ T4S, v6, v7);                       \/\/       fmls    v5.4S, v6.4S, v7.4S\n+    __ fmls(v8, __ T2D, v9, v10);                      \/\/       fmls    v8.2D, v9.2D, v10.2D\n+    __ fmls(v15, __ T4H, v16, v17);                    \/\/       fmls    v15.4H, v16.4H, v17.4H\n+    __ fmls(v29, __ T8H, v30, v31);                    \/\/       fmls    v29.8H, v30.8H, v31.8H\n+    __ fdiv(v30, __ T2S, v31, v0);                     \/\/       fdiv    v30.2S, v31.2S, v0.2S\n+    __ fdiv(v0, __ T4S, v1, v2);                       \/\/       fdiv    v0.4S, v1.4S, v2.4S\n+    __ fdiv(v20, __ T2D, v21, v22);                    \/\/       fdiv    v20.2D, v21.2D, v22.2D\n+    __ fdiv(v7, __ T4H, v8, v9);                       \/\/       fdiv    v7.4H, v8.4H, v9.4H\n+    __ fdiv(v20, __ T8H, v21, v22);                    \/\/       fdiv    v20.8H, v21.8H, v22.8H\n+    __ maxv(v23, __ T8B, v24, v25);                    \/\/       smax    v23.8B, v24.8B, v25.8B\n+    __ maxv(v28, __ T16B, v29, v30);                   \/\/       smax    v28.16B, v29.16B, v30.16B\n+    __ maxv(v21, __ T4H, v22, v23);                    \/\/       smax    v21.4H, v22.4H, v23.4H\n+    __ maxv(v27, __ T8H, v28, v29);                    \/\/       smax    v27.8H, v28.8H, v29.8H\n+    __ maxv(v25, __ T2S, v26, v27);                    \/\/       smax    v25.2S, v26.2S, v27.2S\n+    __ maxv(v5, __ T4S, v6, v7);                       \/\/       smax    v5.4S, v6.4S, v7.4S\n+    __ umaxv(v1, __ T8B, v2, v3);                      \/\/       umax    v1.8B, v2.8B, v3.8B\n+    __ umaxv(v23, __ T16B, v24, v25);                  \/\/       umax    v23.16B, v24.16B, v25.16B\n@@ -774,46 +796,52 @@\n-    __ umaxv(v3, __ T8H, v4, v5);                      \/\/       umax    v3.8H, v4.8H, v5.8H\n-    __ umaxv(v1, __ T2S, v2, v3);                      \/\/       umax    v1.2S, v2.2S, v3.2S\n-    __ umaxv(v11, __ T4S, v12, v13);                   \/\/       umax    v11.4S, v12.4S, v13.4S\n-    __ smaxp(v30, __ T8B, v31, v0);                    \/\/       smaxp   v30.8B, v31.8B, v0.8B\n-    __ smaxp(v5, __ T16B, v6, v7);                     \/\/       smaxp   v5.16B, v6.16B, v7.16B\n-    __ smaxp(v8, __ T4H, v9, v10);                     \/\/       smaxp   v8.4H, v9.4H, v10.4H\n-    __ smaxp(v15, __ T8H, v16, v17);                   \/\/       smaxp   v15.8H, v16.8H, v17.8H\n-    __ smaxp(v29, __ T2S, v30, v31);                   \/\/       smaxp   v29.2S, v30.2S, v31.2S\n-    __ smaxp(v30, __ T4S, v31, v0);                    \/\/       smaxp   v30.4S, v31.4S, v0.4S\n-    __ fmax(v0, __ T2S, v1, v2);                       \/\/       fmax    v0.2S, v1.2S, v2.2S\n-    __ fmax(v20, __ T4S, v21, v22);                    \/\/       fmax    v20.4S, v21.4S, v22.4S\n-    __ fmax(v7, __ T2D, v8, v9);                       \/\/       fmax    v7.2D, v8.2D, v9.2D\n-    __ minv(v20, __ T8B, v21, v22);                    \/\/       smin    v20.8B, v21.8B, v22.8B\n-    __ minv(v23, __ T16B, v24, v25);                   \/\/       smin    v23.16B, v24.16B, v25.16B\n-    __ minv(v28, __ T4H, v29, v30);                    \/\/       smin    v28.4H, v29.4H, v30.4H\n-    __ minv(v21, __ T8H, v22, v23);                    \/\/       smin    v21.8H, v22.8H, v23.8H\n-    __ minv(v27, __ T2S, v28, v29);                    \/\/       smin    v27.2S, v28.2S, v29.2S\n-    __ minv(v25, __ T4S, v26, v27);                    \/\/       smin    v25.4S, v26.4S, v27.4S\n-    __ uminv(v5, __ T8B, v6, v7);                      \/\/       umin    v5.8B, v6.8B, v7.8B\n-    __ uminv(v1, __ T16B, v2, v3);                     \/\/       umin    v1.16B, v2.16B, v3.16B\n-    __ uminv(v23, __ T4H, v24, v25);                   \/\/       umin    v23.4H, v24.4H, v25.4H\n-    __ uminv(v16, __ T8H, v17, v18);                   \/\/       umin    v16.8H, v17.8H, v18.8H\n-    __ uminv(v31, __ T2S, v0, v1);                     \/\/       umin    v31.2S, v0.2S, v1.2S\n-    __ uminv(v5, __ T4S, v6, v7);                      \/\/       umin    v5.4S, v6.4S, v7.4S\n-    __ sminp(v12, __ T8B, v13, v14);                   \/\/       sminp   v12.8B, v13.8B, v14.8B\n-    __ sminp(v9, __ T16B, v10, v11);                   \/\/       sminp   v9.16B, v10.16B, v11.16B\n-    __ sminp(v28, __ T4H, v29, v30);                   \/\/       sminp   v28.4H, v29.4H, v30.4H\n-    __ sminp(v15, __ T8H, v16, v17);                   \/\/       sminp   v15.8H, v16.8H, v17.8H\n-    __ sminp(v29, __ T2S, v30, v31);                   \/\/       sminp   v29.2S, v30.2S, v31.2S\n-    __ sminp(v22, __ T4S, v23, v24);                   \/\/       sminp   v22.4S, v23.4S, v24.4S\n-    __ sqdmulh(v31, __ T4H, v0, v1);                   \/\/       sqdmulh v31.4H, v0.4H, v1.4H\n-    __ sqdmulh(v19, __ T8H, v20, v21);                 \/\/       sqdmulh v19.8H, v20.8H, v21.8H\n-    __ sqdmulh(v31, __ T2S, v0, v1);                   \/\/       sqdmulh v31.2S, v0.2S, v1.2S\n-    __ sqdmulh(v5, __ T4S, v6, v7);                    \/\/       sqdmulh v5.4S, v6.4S, v7.4S\n-    __ shsubv(v14, __ T8B, v15, v16);                  \/\/       shsub   v14.8B, v15.8B, v16.8B\n-    __ shsubv(v18, __ T16B, v19, v20);                 \/\/       shsub   v18.16B, v19.16B, v20.16B\n-    __ shsubv(v31, __ T4H, v0, v1);                    \/\/       shsub   v31.4H, v0.4H, v1.4H\n-    __ shsubv(v18, __ T8H, v19, v20);                  \/\/       shsub   v18.8H, v19.8H, v20.8H\n-    __ shsubv(v27, __ T2S, v28, v29);                  \/\/       shsub   v27.2S, v28.2S, v29.2S\n-    __ shsubv(v20, __ T4S, v21, v22);                  \/\/       shsub   v20.4S, v21.4S, v22.4S\n-    __ fmin(v16, __ T2S, v17, v18);                    \/\/       fmin    v16.2S, v17.2S, v18.2S\n-    __ fmin(v12, __ T4S, v13, v14);                    \/\/       fmin    v12.4S, v13.4S, v14.4S\n-    __ fmin(v11, __ T2D, v12, v13);                    \/\/       fmin    v11.2D, v12.2D, v13.2D\n-    __ facgt(v9, __ T2S, v10, v11);                    \/\/       facgt   v9.2S, v10.2S, v11.2S\n-    __ facgt(v6, __ T4S, v7, v8);                      \/\/       facgt   v6.4S, v7.4S, v8.4S\n-    __ facgt(v30, __ T2D, v31, v0);                    \/\/       facgt   v30.2D, v31.2D, v0.2D\n+    __ umaxv(v31, __ T8H, v0, v1);                     \/\/       umax    v31.8H, v0.8H, v1.8H\n+    __ umaxv(v5, __ T2S, v6, v7);                      \/\/       umax    v5.2S, v6.2S, v7.2S\n+    __ umaxv(v12, __ T4S, v13, v14);                   \/\/       umax    v12.4S, v13.4S, v14.4S\n+    __ smaxp(v9, __ T8B, v10, v11);                    \/\/       smaxp   v9.8B, v10.8B, v11.8B\n+    __ smaxp(v28, __ T16B, v29, v30);                  \/\/       smaxp   v28.16B, v29.16B, v30.16B\n+    __ smaxp(v15, __ T4H, v16, v17);                   \/\/       smaxp   v15.4H, v16.4H, v17.4H\n+    __ smaxp(v29, __ T8H, v30, v31);                   \/\/       smaxp   v29.8H, v30.8H, v31.8H\n+    __ smaxp(v22, __ T2S, v23, v24);                   \/\/       smaxp   v22.2S, v23.2S, v24.2S\n+    __ smaxp(v31, __ T4S, v0, v1);                     \/\/       smaxp   v31.4S, v0.4S, v1.4S\n+    __ fmax(v19, __ T2S, v20, v21);                    \/\/       fmax    v19.2S, v20.2S, v21.2S\n+    __ fmax(v31, __ T4S, v0, v1);                      \/\/       fmax    v31.4S, v0.4S, v1.4S\n+    __ fmax(v5, __ T2D, v6, v7);                       \/\/       fmax    v5.2D, v6.2D, v7.2D\n+    __ fmax(v14, __ T4H, v15, v16);                    \/\/       fmax    v14.4H, v15.4H, v16.4H\n+    __ fmax(v18, __ T8H, v19, v20);                    \/\/       fmax    v18.8H, v19.8H, v20.8H\n+    __ minv(v31, __ T8B, v0, v1);                      \/\/       smin    v31.8B, v0.8B, v1.8B\n+    __ minv(v18, __ T16B, v19, v20);                   \/\/       smin    v18.16B, v19.16B, v20.16B\n+    __ minv(v27, __ T4H, v28, v29);                    \/\/       smin    v27.4H, v28.4H, v29.4H\n+    __ minv(v20, __ T8H, v21, v22);                    \/\/       smin    v20.8H, v21.8H, v22.8H\n+    __ minv(v16, __ T2S, v17, v18);                    \/\/       smin    v16.2S, v17.2S, v18.2S\n+    __ minv(v12, __ T4S, v13, v14);                    \/\/       smin    v12.4S, v13.4S, v14.4S\n+    __ uminv(v11, __ T8B, v12, v13);                   \/\/       umin    v11.8B, v12.8B, v13.8B\n+    __ uminv(v9, __ T16B, v10, v11);                   \/\/       umin    v9.16B, v10.16B, v11.16B\n+    __ uminv(v6, __ T4H, v7, v8);                      \/\/       umin    v6.4H, v7.4H, v8.4H\n+    __ uminv(v30, __ T8H, v31, v0);                    \/\/       umin    v30.8H, v31.8H, v0.8H\n+    __ uminv(v17, __ T2S, v18, v19);                   \/\/       umin    v17.2S, v18.2S, v19.2S\n+    __ uminv(v27, __ T4S, v28, v29);                   \/\/       umin    v27.4S, v28.4S, v29.4S\n+    __ sminp(v28, __ T8B, v29, v30);                   \/\/       sminp   v28.8B, v29.8B, v30.8B\n+    __ sminp(v30, __ T16B, v31, v0);                   \/\/       sminp   v30.16B, v31.16B, v0.16B\n+    __ sminp(v7, __ T4H, v8, v9);                      \/\/       sminp   v7.4H, v8.4H, v9.4H\n+    __ sminp(v10, __ T8H, v11, v12);                   \/\/       sminp   v10.8H, v11.8H, v12.8H\n+    __ sminp(v20, __ T2S, v21, v22);                   \/\/       sminp   v20.2S, v21.2S, v22.2S\n+    __ sminp(v10, __ T4S, v11, v12);                   \/\/       sminp   v10.4S, v11.4S, v12.4S\n+    __ sqdmulh(v4, __ T4H, v5, v6);                    \/\/       sqdmulh v4.4H, v5.4H, v6.4H\n+    __ sqdmulh(v24, __ T8H, v25, v26);                 \/\/       sqdmulh v24.8H, v25.8H, v26.8H\n+    __ sqdmulh(v17, __ T2S, v18, v19);                 \/\/       sqdmulh v17.2S, v18.2S, v19.2S\n+    __ sqdmulh(v17, __ T4S, v18, v19);                 \/\/       sqdmulh v17.4S, v18.4S, v19.4S\n+    __ shsubv(v22, __ T8B, v23, v24);                  \/\/       shsub   v22.8B, v23.8B, v24.8B\n+    __ shsubv(v3, __ T16B, v4, v5);                    \/\/       shsub   v3.16B, v4.16B, v5.16B\n+    __ shsubv(v29, __ T4H, v30, v31);                  \/\/       shsub   v29.4H, v30.4H, v31.4H\n+    __ shsubv(v15, __ T8H, v16, v17);                  \/\/       shsub   v15.8H, v16.8H, v17.8H\n+    __ shsubv(v22, __ T2S, v23, v24);                  \/\/       shsub   v22.2S, v23.2S, v24.2S\n+    __ shsubv(v19, __ T4S, v20, v21);                  \/\/       shsub   v19.4S, v20.4S, v21.4S\n+    __ fmin(v19, __ T2S, v20, v21);                    \/\/       fmin    v19.2S, v20.2S, v21.2S\n+    __ fmin(v22, __ T4S, v23, v24);                    \/\/       fmin    v22.4S, v23.4S, v24.4S\n+    __ fmin(v2, __ T2D, v3, v4);                       \/\/       fmin    v2.2D, v3.2D, v4.2D\n+    __ fmin(v15, __ T4H, v16, v17);                    \/\/       fmin    v15.4H, v16.4H, v17.4H\n+    __ fmin(v6, __ T8H, v7, v8);                       \/\/       fmin    v6.8H, v7.8H, v8.8H\n+    __ facgt(v12, __ T2S, v13, v14);                   \/\/       facgt   v12.2S, v13.2S, v14.2S\n+    __ facgt(v16, __ T4S, v17, v18);                   \/\/       facgt   v16.4S, v17.4S, v18.4S\n+    __ facgt(v11, __ T2D, v12, v13);                   \/\/       facgt   v11.2D, v12.2D, v13.2D\n+    __ facgt(v13, __ T4H, v14, v15);                   \/\/       facgt   v13.4H, v14.4H, v15.4H\n+    __ facgt(v23, __ T8H, v24, v25);                   \/\/       facgt   v23.8H, v24.8H, v25.8H\n@@ -822,13 +850,13 @@\n-    __ fmlavs(v13, __ T2S, v14, v15, 1);               \/\/       fmla    v13.2S, v14.2S, v15.S[1]\n-    __ mulvs(v15, __ T4S, v0, v1, 3);                  \/\/       mul     v15.4S, v0.4S, v1.S[3]\n-    __ fmlavs(v5, __ T2D, v6, v7, 0);                  \/\/       fmla    v5.2D, v6.2D, v7.D[0]\n-    __ fmlsvs(v5, __ T2S, v6, v7, 1);                  \/\/       fmls    v5.2S, v6.2S, v7.S[1]\n-    __ mulvs(v12, __ T4S, v13, v14, 0);                \/\/       mul     v12.4S, v13.4S, v14.S[0]\n-    __ fmlsvs(v8, __ T2D, v9, v10, 1);                 \/\/       fmls    v8.2D, v9.2D, v10.D[1]\n-    __ fmulxvs(v1, __ T2S, v2, v3, 1);                 \/\/       fmulx   v1.2S, v2.2S, v3.S[1]\n-    __ mulvs(v7, __ T4S, v8, v9, 3);                   \/\/       mul     v7.4S, v8.4S, v9.S[3]\n-    __ fmulxvs(v9, __ T2D, v10, v11, 1);               \/\/       fmulx   v9.2D, v10.2D, v11.D[1]\n-    __ mulvs(v11, __ T4H, v12, v13, 2);                \/\/       mul     v11.4H, v12.4H, v13.H[2]\n-    __ mulvs(v7, __ T8H, v8, v9, 0);                   \/\/       mul     v7.8H, v8.8H, v9.H[0]\n-    __ mulvs(v6, __ T2S, v7, v8, 0);                   \/\/       mul     v6.2S, v7.2S, v8.S[0]\n-    __ mulvs(v5, __ T4S, v6, v7, 2);                   \/\/       mul     v5.4S, v6.4S, v7.S[2]\n+    __ fmlavs(v15, __ T2S, v0, v1, 0);                 \/\/       fmla    v15.2S, v0.2S, v1.S[0]\n+    __ mulvs(v2, __ T4S, v3, v4, 2);                   \/\/       mul     v2.4S, v3.4S, v4.S[2]\n+    __ fmlavs(v1, __ T2D, v2, v3, 1);                  \/\/       fmla    v1.2D, v2.2D, v3.D[1]\n+    __ fmlsvs(v11, __ T2S, v12, v13, 1);               \/\/       fmls    v11.2S, v12.2S, v13.S[1]\n+    __ mulvs(v5, __ T4S, v6, v7, 1);                   \/\/       mul     v5.4S, v6.4S, v7.S[1]\n+    __ fmlsvs(v14, __ T2D, v15, v16, 1);               \/\/       fmls    v14.2D, v15.2D, v16.D[1]\n+    __ fmulxvs(v6, __ T2S, v7, v8, 1);                 \/\/       fmulx   v6.2S, v7.2S, v8.S[1]\n+    __ mulvs(v1, __ T4S, v2, v3, 3);                   \/\/       mul     v1.4S, v2.4S, v3.S[3]\n+    __ fmulxvs(v15, __ T2D, v0, v1, 0);                \/\/       fmulx   v15.2D, v0.2D, v1.D[0]\n+    __ mulvs(v9, __ T4H, v10, v11, 3);                 \/\/       mul     v9.4H, v10.4H, v11.H[3]\n+    __ mulvs(v4, __ T8H, v5, v6, 4);                   \/\/       mul     v4.8H, v5.8H, v6.H[4]\n+    __ mulvs(v13, __ T2S, v14, v15, 1);                \/\/       mul     v13.2S, v14.2S, v15.S[1]\n+    __ mulvs(v3, __ T4S, v4, v5, 1);                   \/\/       mul     v3.4S, v4.4S, v5.S[1]\n@@ -837,1 +865,1 @@\n-    __ cm(Assembler::GT, v13, __ T8B, v14, v15);       \/\/       cmgt    v13.8B, v14.8B, v15.8B\n+    __ cm(Assembler::GT, v21, __ T8B, v22, v23);       \/\/       cmgt    v21.8B, v22.8B, v23.8B\n@@ -839,23 +867,23 @@\n-    __ cm(Assembler::GT, v1, __ T4H, v2, v3);          \/\/       cmgt    v1.4H, v2.4H, v3.4H\n-    __ cm(Assembler::GT, v30, __ T8H, v31, v0);        \/\/       cmgt    v30.8H, v31.8H, v0.8H\n-    __ cm(Assembler::GT, v19, __ T2S, v20, v21);       \/\/       cmgt    v19.2S, v20.2S, v21.2S\n-    __ cm(Assembler::GT, v5, __ T4S, v6, v7);          \/\/       cmgt    v5.4S, v6.4S, v7.4S\n-    __ cm(Assembler::GT, v17, __ T2D, v18, v19);       \/\/       cmgt    v17.2D, v18.2D, v19.2D\n-    __ cm(Assembler::GE, v2, __ T8B, v3, v4);          \/\/       cmge    v2.8B, v3.8B, v4.8B\n-    __ cm(Assembler::GE, v16, __ T16B, v17, v18);      \/\/       cmge    v16.16B, v17.16B, v18.16B\n-    __ cm(Assembler::GE, v22, __ T4H, v23, v24);       \/\/       cmge    v22.4H, v23.4H, v24.4H\n-    __ cm(Assembler::GE, v13, __ T8H, v14, v15);       \/\/       cmge    v13.8H, v14.8H, v15.8H\n-    __ cm(Assembler::GE, v10, __ T2S, v11, v12);       \/\/       cmge    v10.2S, v11.2S, v12.2S\n-    __ cm(Assembler::GE, v21, __ T4S, v22, v23);       \/\/       cmge    v21.4S, v22.4S, v23.4S\n-    __ cm(Assembler::GE, v29, __ T2D, v30, v31);       \/\/       cmge    v29.2D, v30.2D, v31.2D\n-    __ cm(Assembler::EQ, v27, __ T8B, v28, v29);       \/\/       cmeq    v27.8B, v28.8B, v29.8B\n-    __ cm(Assembler::EQ, v12, __ T16B, v13, v14);      \/\/       cmeq    v12.16B, v13.16B, v14.16B\n-    __ cm(Assembler::EQ, v27, __ T4H, v28, v29);       \/\/       cmeq    v27.4H, v28.4H, v29.4H\n-    __ cm(Assembler::EQ, v3, __ T8H, v4, v5);          \/\/       cmeq    v3.8H, v4.8H, v5.8H\n-    __ cm(Assembler::EQ, v1, __ T2S, v2, v3);          \/\/       cmeq    v1.2S, v2.2S, v3.2S\n-    __ cm(Assembler::EQ, v31, __ T4S, v0, v1);         \/\/       cmeq    v31.4S, v0.4S, v1.4S\n-    __ cm(Assembler::EQ, v24, __ T2D, v25, v26);       \/\/       cmeq    v24.2D, v25.2D, v26.2D\n-    __ cm(Assembler::HI, v19, __ T8B, v20, v21);       \/\/       cmhi    v19.8B, v20.8B, v21.8B\n-    __ cm(Assembler::HI, v17, __ T16B, v18, v19);      \/\/       cmhi    v17.16B, v18.16B, v19.16B\n-    __ cm(Assembler::HI, v9, __ T4H, v10, v11);        \/\/       cmhi    v9.4H, v10.4H, v11.4H\n-    __ cm(Assembler::HI, v28, __ T8H, v29, v30);       \/\/       cmhi    v28.8H, v29.8H, v30.8H\n+    __ cm(Assembler::GT, v31, __ T4H, v0, v1);         \/\/       cmgt    v31.4H, v0.4H, v1.4H\n+    __ cm(Assembler::GT, v25, __ T8H, v26, v27);       \/\/       cmgt    v25.8H, v26.8H, v27.8H\n+    __ cm(Assembler::GT, v2, __ T2S, v3, v4);          \/\/       cmgt    v2.2S, v3.2S, v4.2S\n+    __ cm(Assembler::GT, v31, __ T4S, v0, v1);         \/\/       cmgt    v31.4S, v0.4S, v1.4S\n+    __ cm(Assembler::GT, v27, __ T2D, v28, v29);       \/\/       cmgt    v27.2D, v28.2D, v29.2D\n+    __ cm(Assembler::GE, v18, __ T8B, v19, v20);       \/\/       cmge    v18.8B, v19.8B, v20.8B\n+    __ cm(Assembler::GE, v10, __ T16B, v11, v12);      \/\/       cmge    v10.16B, v11.16B, v12.16B\n+    __ cm(Assembler::GE, v23, __ T4H, v24, v25);       \/\/       cmge    v23.4H, v24.4H, v25.4H\n+    __ cm(Assembler::GE, v19, __ T8H, v20, v21);       \/\/       cmge    v19.8H, v20.8H, v21.8H\n+    __ cm(Assembler::GE, v3, __ T2S, v4, v5);          \/\/       cmge    v3.2S, v4.2S, v5.2S\n+    __ cm(Assembler::GE, v18, __ T4S, v19, v20);       \/\/       cmge    v18.4S, v19.4S, v20.4S\n+    __ cm(Assembler::GE, v0, __ T2D, v1, v2);          \/\/       cmge    v0.2D, v1.2D, v2.2D\n+    __ cm(Assembler::EQ, v25, __ T8B, v26, v27);       \/\/       cmeq    v25.8B, v26.8B, v27.8B\n+    __ cm(Assembler::EQ, v26, __ T16B, v27, v28);      \/\/       cmeq    v26.16B, v27.16B, v28.16B\n+    __ cm(Assembler::EQ, v23, __ T4H, v24, v25);       \/\/       cmeq    v23.4H, v24.4H, v25.4H\n+    __ cm(Assembler::EQ, v2, __ T8H, v3, v4);          \/\/       cmeq    v2.8H, v3.8H, v4.8H\n+    __ cm(Assembler::EQ, v18, __ T2S, v19, v20);       \/\/       cmeq    v18.2S, v19.2S, v20.2S\n+    __ cm(Assembler::EQ, v12, __ T4S, v13, v14);       \/\/       cmeq    v12.4S, v13.4S, v14.4S\n+    __ cm(Assembler::EQ, v4, __ T2D, v5, v6);          \/\/       cmeq    v4.2D, v5.2D, v6.2D\n+    __ cm(Assembler::HI, v28, __ T8B, v29, v30);       \/\/       cmhi    v28.8B, v29.8B, v30.8B\n+    __ cm(Assembler::HI, v30, __ T16B, v31, v0);       \/\/       cmhi    v30.16B, v31.16B, v0.16B\n+    __ cm(Assembler::HI, v29, __ T4H, v30, v31);       \/\/       cmhi    v29.4H, v30.4H, v31.4H\n+    __ cm(Assembler::HI, v16, __ T8H, v17, v18);       \/\/       cmhi    v16.8H, v17.8H, v18.8H\n@@ -863,18 +891,18 @@\n-    __ cm(Assembler::HI, v15, __ T4S, v16, v17);       \/\/       cmhi    v15.4S, v16.4S, v17.4S\n-    __ cm(Assembler::HI, v7, __ T2D, v8, v9);          \/\/       cmhi    v7.2D, v8.2D, v9.2D\n-    __ cm(Assembler::HS, v21, __ T8B, v22, v23);       \/\/       cmhs    v21.8B, v22.8B, v23.8B\n-    __ cm(Assembler::HS, v23, __ T16B, v24, v25);      \/\/       cmhs    v23.16B, v24.16B, v25.16B\n-    __ cm(Assembler::HS, v31, __ T4H, v0, v1);         \/\/       cmhs    v31.4H, v0.4H, v1.4H\n-    __ cm(Assembler::HS, v25, __ T8H, v26, v27);       \/\/       cmhs    v25.8H, v26.8H, v27.8H\n-    __ cm(Assembler::HS, v2, __ T2S, v3, v4);          \/\/       cmhs    v2.2S, v3.2S, v4.2S\n-    __ cm(Assembler::HS, v31, __ T4S, v0, v1);         \/\/       cmhs    v31.4S, v0.4S, v1.4S\n-    __ cm(Assembler::HS, v27, __ T2D, v28, v29);       \/\/       cmhs    v27.2D, v28.2D, v29.2D\n-    __ fcm(Assembler::EQ, v18, __ T2S, v19, v20);      \/\/       fcmeq   v18.2S, v19.2S, v20.2S\n-    __ fcm(Assembler::EQ, v10, __ T4S, v11, v12);      \/\/       fcmeq   v10.4S, v11.4S, v12.4S\n-    __ fcm(Assembler::EQ, v23, __ T2D, v24, v25);      \/\/       fcmeq   v23.2D, v24.2D, v25.2D\n-    __ fcm(Assembler::GT, v19, __ T2S, v20, v21);      \/\/       fcmgt   v19.2S, v20.2S, v21.2S\n-    __ fcm(Assembler::GT, v3, __ T4S, v4, v5);         \/\/       fcmgt   v3.4S, v4.4S, v5.4S\n-    __ fcm(Assembler::GT, v18, __ T2D, v19, v20);      \/\/       fcmgt   v18.2D, v19.2D, v20.2D\n-    __ fcm(Assembler::GE, v0, __ T2S, v1, v2);         \/\/       fcmge   v0.2S, v1.2S, v2.2S\n-    __ fcm(Assembler::GE, v25, __ T4S, v26, v27);      \/\/       fcmge   v25.4S, v26.4S, v27.4S\n-    __ fcm(Assembler::GE, v26, __ T2D, v27, v28);      \/\/       fcmge   v26.2D, v27.2D, v28.2D\n+    __ cm(Assembler::HI, v6, __ T4S, v7, v8);          \/\/       cmhi    v6.4S, v7.4S, v8.4S\n+    __ cm(Assembler::HI, v9, __ T2D, v10, v11);        \/\/       cmhi    v9.2D, v10.2D, v11.2D\n+    __ cm(Assembler::HS, v29, __ T8B, v30, v31);       \/\/       cmhs    v29.8B, v30.8B, v31.8B\n+    __ cm(Assembler::HS, v18, __ T16B, v19, v20);      \/\/       cmhs    v18.16B, v19.16B, v20.16B\n+    __ cm(Assembler::HS, v7, __ T4H, v8, v9);          \/\/       cmhs    v7.4H, v8.4H, v9.4H\n+    __ cm(Assembler::HS, v4, __ T8H, v5, v6);          \/\/       cmhs    v4.8H, v5.8H, v6.8H\n+    __ cm(Assembler::HS, v7, __ T2S, v8, v9);          \/\/       cmhs    v7.2S, v8.2S, v9.2S\n+    __ cm(Assembler::HS, v15, __ T4S, v16, v17);       \/\/       cmhs    v15.4S, v16.4S, v17.4S\n+    __ cm(Assembler::HS, v9, __ T2D, v10, v11);        \/\/       cmhs    v9.2D, v10.2D, v11.2D\n+    __ fcm(Assembler::EQ, v23, __ T2S, v24, v25);      \/\/       fcmeq   v23.2S, v24.2S, v25.2S\n+    __ fcm(Assembler::EQ, v8, __ T4S, v9, v10);        \/\/       fcmeq   v8.4S, v9.4S, v10.4S\n+    __ fcm(Assembler::EQ, v2, __ T2D, v3, v4);         \/\/       fcmeq   v2.2D, v3.2D, v4.2D\n+    __ fcm(Assembler::GT, v28, __ T2S, v29, v30);      \/\/       fcmgt   v28.2S, v29.2S, v30.2S\n+    __ fcm(Assembler::GT, v21, __ T4S, v22, v23);      \/\/       fcmgt   v21.4S, v22.4S, v23.4S\n+    __ fcm(Assembler::GT, v31, __ T2D, v0, v1);        \/\/       fcmgt   v31.2D, v0.2D, v1.2D\n+    __ fcm(Assembler::GE, v5, __ T2S, v6, v7);         \/\/       fcmge   v5.2S, v6.2S, v7.2S\n+    __ fcm(Assembler::GE, v27, __ T4S, v28, v29);      \/\/       fcmge   v27.4S, v28.4S, v29.4S\n+    __ fcm(Assembler::GE, v0, __ T2D, v1, v2);         \/\/       fcmge   v0.2D, v1.2D, v2.2D\n@@ -883,6 +911,6 @@\n-    __ sve_fcm(Assembler::EQ, p11, __ D, p3, z2, 0.0); \/\/       fcmeq   p11.d, p3\/z, z2.d, #0.0\n-    __ sve_fcm(Assembler::GT, p2, __ D, p7, z28, 0.0); \/\/       fcmgt   p2.d, p7\/z, z28.d, #0.0\n-    __ sve_fcm(Assembler::GE, p8, __ S, p2, z27, 0.0); \/\/       fcmge   p8.s, p2\/z, z27.s, #0.0\n-    __ sve_fcm(Assembler::LT, p14, __ S, p1, z18, 0.0); \/\/      fcmlt   p14.s, p1\/z, z18.s, #0.0\n-    __ sve_fcm(Assembler::LE, p3, __ S, p5, z15, 0.0); \/\/       fcmle   p3.s, p5\/z, z15.s, #0.0\n-    __ sve_fcm(Assembler::NE, p4, __ D, p5, z2, 0.0);  \/\/       fcmne   p4.d, p5\/z, z2.d, #0.0\n+    __ sve_fcm(Assembler::EQ, p8, __ S, p6, z15, 0.0); \/\/       fcmeq   p8.s, p6\/z, z15.s, #0.0\n+    __ sve_fcm(Assembler::GT, p4, __ D, p6, z28, 0.0); \/\/       fcmgt   p4.d, p6\/z, z28.d, #0.0\n+    __ sve_fcm(Assembler::GE, p13, __ D, p0, z25, 0.0); \/\/      fcmge   p13.d, p0\/z, z25.d, #0.0\n+    __ sve_fcm(Assembler::LT, p2, __ D, p0, z6, 0.0);  \/\/       fcmlt   p2.d, p0\/z, z6.d, #0.0\n+    __ sve_fcm(Assembler::LE, p2, __ S, p2, z15, 0.0); \/\/       fcmle   p2.s, p2\/z, z15.s, #0.0\n+    __ sve_fcm(Assembler::NE, p3, __ S, p7, z5, 0.0);  \/\/       fcmne   p3.s, p7\/z, z5.s, #0.0\n@@ -891,10 +919,10 @@\n-    __ sve_cmp(Assembler::EQ, p15, __ D, p0, z5, 1);   \/\/       cmpeq   p15.d, p0\/z, z5.d, #1\n-    __ sve_cmp(Assembler::GT, p7, __ D, p2, z4, 12);   \/\/       cmpgt   p7.d, p2\/z, z4.d, #12\n-    __ sve_cmp(Assembler::GE, p11, __ D, p6, z27, 7);  \/\/       cmpge   p11.d, p6\/z, z27.d, #7\n-    __ sve_cmp(Assembler::LT, p0, __ B, p4, z4, -16);  \/\/       cmplt   p0.b, p4\/z, z4.b, #-16\n-    __ sve_cmp(Assembler::LE, p2, __ B, p2, z15, -9);  \/\/       cmple   p2.b, p2\/z, z15.b, #-9\n-    __ sve_cmp(Assembler::NE, p2, __ D, p1, z10, 4);   \/\/       cmpne   p2.d, p1\/z, z10.d, #4\n-    __ sve_cmp(Assembler::HS, p11, __ B, p2, z21, 34); \/\/       cmphs   p11.b, p2\/z, z21.b, #34\n-    __ sve_cmp(Assembler::HI, p8, __ B, p4, z31, 8);   \/\/       cmphi   p8.b, p4\/z, z31.b, #8\n-    __ sve_cmp(Assembler::LS, p6, __ D, p0, z30, 109); \/\/       cmpls   p6.d, p0\/z, z30.d, #109\n-    __ sve_cmp(Assembler::LO, p11, __ H, p3, z29, 114); \/\/      cmplo   p11.h, p3\/z, z29.h, #114\n+    __ sve_cmp(Assembler::EQ, p3, __ S, p5, z20, -10); \/\/       cmpeq   p3.s, p5\/z, z20.s, #-10\n+    __ sve_cmp(Assembler::GT, p5, __ S, p7, z8, -10);  \/\/       cmpgt   p5.s, p7\/z, z8.s, #-10\n+    __ sve_cmp(Assembler::GE, p8, __ H, p7, z2, 13);   \/\/       cmpge   p8.h, p7\/z, z2.h, #13\n+    __ sve_cmp(Assembler::LT, p1, __ S, p7, z27, -2);  \/\/       cmplt   p1.s, p7\/z, z27.s, #-2\n+    __ sve_cmp(Assembler::LE, p6, __ S, p6, z28, -11); \/\/       cmple   p6.s, p6\/z, z28.s, #-11\n+    __ sve_cmp(Assembler::NE, p1, __ H, p4, z14, -5);  \/\/       cmpne   p1.h, p4\/z, z14.h, #-5\n+    __ sve_cmp(Assembler::HS, p13, __ H, p1, z23, 90); \/\/       cmphs   p13.h, p1\/z, z23.h, #90\n+    __ sve_cmp(Assembler::HI, p8, __ B, p4, z4, 66);   \/\/       cmphi   p8.b, p4\/z, z4.b, #66\n+    __ sve_cmp(Assembler::LS, p9, __ H, p3, z13, 11);  \/\/       cmpls   p9.h, p3\/z, z13.h, #11\n+    __ sve_cmp(Assembler::LO, p8, __ S, p5, z3, 21);   \/\/       cmplo   p8.s, p5\/z, z3.s, #21\n@@ -930,0 +958,2 @@\n+    __ fcvtzs(v0, __ T4H, v1);                         \/\/       fcvtzs  v0.4h, v1.4h\n+    __ fcvtzs(v0, __ T8H, v1);                         \/\/       fcvtzs  v0.8h, v1.8h\n@@ -931,0 +961,2 @@\n+    __ fcvtas(v2, __ T4H, v3);                         \/\/       fcvtas  v2.4h, v3.4h\n+    __ fcvtas(v2, __ T8H, v3);                         \/\/       fcvtas  v2.8h, v3.8h\n@@ -932,0 +964,2 @@\n+    __ fcvtms(v4, __ T4H, v5);                         \/\/       fcvtms  v4.4h, v5.4h\n+    __ fcvtms(v4, __ T8H, v5);                         \/\/       fcvtms  v4.8h, v5.8h\n@@ -1155,9 +1189,9 @@\n-    __ swp(Assembler::xword, r17, r24, r5);            \/\/       swp     x17, x24, [x5]\n-    __ ldadd(Assembler::xword, r2, r14, r10);          \/\/       ldadd   x2, x14, [x10]\n-    __ ldbic(Assembler::xword, r16, r11, r27);         \/\/       ldclr   x16, x11, [x27]\n-    __ ldeor(Assembler::xword, r23, r12, r4);          \/\/       ldeor   x23, x12, [x4]\n-    __ ldorr(Assembler::xword, r22, r17, r4);          \/\/       ldset   x22, x17, [x4]\n-    __ ldsmin(Assembler::xword, r1, r19, r16);         \/\/       ldsmin  x1, x19, [x16]\n-    __ ldsmax(Assembler::xword, r16, r13, r14);        \/\/       ldsmax  x16, x13, [x14]\n-    __ ldumin(Assembler::xword, r12, r2, r17);         \/\/       ldumin  x12, x2, [x17]\n-    __ ldumax(Assembler::xword, r3, r21, r23);         \/\/       ldumax  x3, x21, [x23]\n+    __ swp(Assembler::xword, r6, r7, r19);             \/\/       swp     x6, x7, [x19]\n+    __ ldadd(Assembler::xword, r13, r28, r17);         \/\/       ldadd   x13, x28, [x17]\n+    __ ldbic(Assembler::xword, r16, r6, r2);           \/\/       ldclr   x16, x6, [x2]\n+    __ ldeor(Assembler::xword, r29, r3, r4);           \/\/       ldeor   x29, x3, [x4]\n+    __ ldorr(Assembler::xword, r6, r16, r20);          \/\/       ldset   x6, x16, [x20]\n+    __ ldsmin(Assembler::xword, r13, r12, r20);        \/\/       ldsmin  x13, x12, [x20]\n+    __ ldsmax(Assembler::xword, r8, r25, r20);         \/\/       ldsmax  x8, x25, [x20]\n+    __ ldumin(Assembler::xword, r19, r0, r11);         \/\/       ldumin  x19, x0, [x11]\n+    __ ldumax(Assembler::xword, r24, r6, r20);         \/\/       ldumax  x24, x6, [x20]\n@@ -1166,9 +1200,9 @@\n-    __ swpa(Assembler::xword, r5, r6, r7);             \/\/       swpa    x5, x6, [x7]\n-    __ ldadda(Assembler::xword, r19, r13, r28);        \/\/       ldadda  x19, x13, [x28]\n-    __ ldbica(Assembler::xword, r17, r16, r6);         \/\/       ldclra  x17, x16, [x6]\n-    __ ldeora(Assembler::xword, r2, r29, r3);          \/\/       ldeora  x2, x29, [x3]\n-    __ ldorra(Assembler::xword, r4, r6, r15);          \/\/       ldseta  x4, x6, [x15]\n-    __ ldsmina(Assembler::xword, r20, r13, r12);       \/\/       ldsmina x20, x13, [x12]\n-    __ ldsmaxa(Assembler::xword, r20, r8, r25);        \/\/       ldsmaxa x20, x8, [x25]\n-    __ ldumina(Assembler::xword, r20, r19, r0);        \/\/       ldumina x20, x19, [x0]\n-    __ ldumaxa(Assembler::xword, r11, r24, r6);        \/\/       ldumaxa x11, x24, [x6]\n+    __ swpa(Assembler::xword, zr, r14, r16);           \/\/       swpa    xzr, x14, [x16]\n+    __ ldadda(Assembler::xword, r6, r0, r7);           \/\/       ldadda  x6, x0, [x7]\n+    __ ldbica(Assembler::xword, r15, r19, r26);        \/\/       ldclra  x15, x19, [x26]\n+    __ ldeora(Assembler::xword, r9, r10, r23);         \/\/       ldeora  x9, x10, [x23]\n+    __ ldorra(Assembler::xword, r21, r22, r28);        \/\/       ldseta  x21, x22, [x28]\n+    __ ldsmina(Assembler::xword, r2, r3, r15);         \/\/       ldsmina x2, x3, [x15]\n+    __ ldsmaxa(Assembler::xword, r19, r20, r7);        \/\/       ldsmaxa x19, x20, [x7]\n+    __ ldumina(Assembler::xword, r4, r29, r7);         \/\/       ldumina x4, x29, [x7]\n+    __ ldumaxa(Assembler::xword, r0, r9, r16);         \/\/       ldumaxa x0, x9, [x16]\n@@ -1177,9 +1211,9 @@\n-    __ swpal(Assembler::xword, r20, zr, r14);          \/\/       swpal   x20, xzr, [x14]\n-    __ ldaddal(Assembler::xword, r16, r6, r0);         \/\/       ldaddal x16, x6, [x0]\n-    __ ldbical(Assembler::xword, r7, r15, r19);        \/\/       ldclral x7, x15, [x19]\n-    __ ldeoral(Assembler::xword, r26, r9, r10);        \/\/       ldeoral x26, x9, [x10]\n-    __ ldorral(Assembler::xword, r23, r21, r22);       \/\/       ldsetal x23, x21, [x22]\n-    __ ldsminal(Assembler::xword, r28, r2, r3);        \/\/       ldsminal        x28, x2, [x3]\n-    __ ldsmaxal(Assembler::xword, r15, r19, r20);      \/\/       ldsmaxal        x15, x19, [x20]\n-    __ lduminal(Assembler::xword, r7, r4, r29);        \/\/       lduminal        x7, x4, [x29]\n-    __ ldumaxal(Assembler::xword, r7, r0, r9);         \/\/       ldumaxal        x7, x0, [x9]\n+    __ swpal(Assembler::xword, r20, r23, r4);          \/\/       swpal   x20, x23, [x4]\n+    __ ldaddal(Assembler::xword, r16, r10, r23);       \/\/       ldaddal x16, x10, [x23]\n+    __ ldbical(Assembler::xword, r11, r25, r6);        \/\/       ldclral x11, x25, [x6]\n+    __ ldeoral(Assembler::xword, zr, r16, r13);        \/\/       ldeoral xzr, x16, [x13]\n+    __ ldorral(Assembler::xword, r23, r12, r1);        \/\/       ldsetal x23, x12, [x1]\n+    __ ldsminal(Assembler::xword, r14, r9, r21);       \/\/       ldsminal        x14, x9, [x21]\n+    __ ldsmaxal(Assembler::xword, r16, r26, r15);      \/\/       ldsmaxal        x16, x26, [x15]\n+    __ lduminal(Assembler::xword, r4, r4, r15);        \/\/       lduminal        x4, x4, [x15]\n+    __ ldumaxal(Assembler::xword, r8, r6, r30);        \/\/       ldumaxal        x8, x6, [x30]\n@@ -1188,9 +1222,9 @@\n-    __ swpl(Assembler::xword, r16, r20, r23);          \/\/       swpl    x16, x20, [x23]\n-    __ ldaddl(Assembler::xword, r4, r16, r10);         \/\/       ldaddl  x4, x16, [x10]\n-    __ ldbicl(Assembler::xword, r23, r11, r25);        \/\/       ldclrl  x23, x11, [x25]\n-    __ ldeorl(Assembler::xword, r6, zr, r16);          \/\/       ldeorl  x6, xzr, [x16]\n-    __ ldorrl(Assembler::xword, r13, r23, r12);        \/\/       ldsetl  x13, x23, [x12]\n-    __ ldsminl(Assembler::xword, r1, r14, r9);         \/\/       ldsminl x1, x14, [x9]\n-    __ ldsmaxl(Assembler::xword, r21, r16, r26);       \/\/       ldsmaxl x21, x16, [x26]\n-    __ lduminl(Assembler::xword, r15, r4, r4);         \/\/       lduminl x15, x4, [x4]\n-    __ ldumaxl(Assembler::xword, r16, r8, r6);         \/\/       ldumaxl x16, x8, [x6]\n+    __ swpl(Assembler::xword, r4, r29, r17);           \/\/       swpl    x4, x29, [x17]\n+    __ ldaddl(Assembler::xword, r29, r26, r9);         \/\/       ldaddl  x29, x26, [x9]\n+    __ ldbicl(Assembler::xword, r15, r2, r11);         \/\/       ldclrl  x15, x2, [x11]\n+    __ ldeorl(Assembler::xword, r29, r3, r7);          \/\/       ldeorl  x29, x3, [x7]\n+    __ ldorrl(Assembler::xword, r1, r27, r21);         \/\/       ldsetl  x1, x27, [x21]\n+    __ ldsminl(Assembler::xword, r16, r14, r8);        \/\/       ldsminl x16, x14, [x8]\n+    __ ldsmaxl(Assembler::xword, r16, r22, r25);       \/\/       ldsmaxl x16, x22, [x25]\n+    __ lduminl(Assembler::xword, r5, r20, r21);        \/\/       lduminl x5, x20, [x21]\n+    __ ldumaxl(Assembler::xword, r16, r23, r16);       \/\/       ldumaxl x16, x23, [x16]\n@@ -1199,9 +1233,9 @@\n-    __ swp(Assembler::word, r30, r4, r29);             \/\/       swp     w30, w4, [x29]\n-    __ ldadd(Assembler::word, r17, r29, r26);          \/\/       ldadd   w17, w29, [x26]\n-    __ ldbic(Assembler::word, r9, r15, r2);            \/\/       ldclr   w9, w15, [x2]\n-    __ ldeor(Assembler::word, r11, r29, r3);           \/\/       ldeor   w11, w29, [x3]\n-    __ ldorr(Assembler::word, r7, r1, r27);            \/\/       ldset   w7, w1, [x27]\n-    __ ldsmin(Assembler::word, r21, r16, r14);         \/\/       ldsmin  w21, w16, [x14]\n-    __ ldsmax(Assembler::word, r8, r16, r22);          \/\/       ldsmax  w8, w16, [x22]\n-    __ ldumin(Assembler::word, r25, r5, r20);          \/\/       ldumin  w25, w5, [x20]\n-    __ ldumax(Assembler::word, r21, r16, r23);         \/\/       ldumax  w21, w16, [x23]\n+    __ swp(Assembler::word, r30, r20, r20);            \/\/       swp     w30, w20, [x20]\n+    __ ldadd(Assembler::word, r0, r4, r19);            \/\/       ldadd   w0, w4, [x19]\n+    __ ldbic(Assembler::word, r24, r4, r20);           \/\/       ldclr   w24, w4, [x20]\n+    __ ldeor(Assembler::word, r4, r24, r26);           \/\/       ldeor   w4, w24, [x26]\n+    __ ldorr(Assembler::word, r19, r2, r8);            \/\/       ldset   w19, w2, [x8]\n+    __ ldsmin(Assembler::word, r8, r14, r24);          \/\/       ldsmin  w8, w14, [x24]\n+    __ ldsmax(Assembler::word, r16, zr, r22);          \/\/       ldsmax  w16, wzr, [x22]\n+    __ ldumin(Assembler::word, r4, zr, r1);            \/\/       ldumin  w4, wzr, [x1]\n+    __ ldumax(Assembler::word, r10, r20, r12);         \/\/       ldumax  w10, w20, [x12]\n@@ -1210,9 +1244,9 @@\n-    __ swpa(Assembler::word, r16, r30, r20);           \/\/       swpa    w16, w30, [x20]\n-    __ ldadda(Assembler::word, r20, r0, r4);           \/\/       ldadda  w20, w0, [x4]\n-    __ ldbica(Assembler::word, r19, r24, r4);          \/\/       ldclra  w19, w24, [x4]\n-    __ ldeora(Assembler::word, r20, r4, r24);          \/\/       ldeora  w20, w4, [x24]\n-    __ ldorra(Assembler::word, r26, r19, r2);          \/\/       ldseta  w26, w19, [x2]\n-    __ ldsmina(Assembler::word, r8, r8, r14);          \/\/       ldsmina w8, w8, [x14]\n-    __ ldsmaxa(Assembler::word, r24, r16, sp);         \/\/       ldsmaxa w24, w16, [sp]\n-    __ ldumina(Assembler::word, r22, r4, sp);          \/\/       ldumina w22, w4, [sp]\n-    __ ldumaxa(Assembler::word, r1, r10, r20);         \/\/       ldumaxa w1, w10, [x20]\n+    __ swpa(Assembler::word, r0, r9, r7);              \/\/       swpa    w0, w9, [x7]\n+    __ ldadda(Assembler::word, r24, r16, r4);          \/\/       ldadda  w24, w16, [x4]\n+    __ ldbica(Assembler::word, r27, r6, r10);          \/\/       ldclra  w27, w6, [x10]\n+    __ ldeora(Assembler::word, r27, r24, r13);         \/\/       ldeora  w27, w24, [x13]\n+    __ ldorra(Assembler::word, r16, zr, r22);          \/\/       ldseta  w16, wzr, [x22]\n+    __ ldsmina(Assembler::word, r22, r20, sp);         \/\/       ldsmina w22, w20, [sp]\n+    __ ldsmaxa(Assembler::word, r29, r9, r14);         \/\/       ldsmaxa w29, w9, [x14]\n+    __ ldumina(Assembler::word, r20, r7, r20);         \/\/       ldumina w20, w7, [x20]\n+    __ ldumaxa(Assembler::word, r28, r9, r11);         \/\/       ldumaxa w28, w9, [x11]\n@@ -1221,9 +1255,9 @@\n-    __ swpal(Assembler::word, r12, r0, r9);            \/\/       swpal   w12, w0, [x9]\n-    __ ldaddal(Assembler::word, r7, r24, r15);         \/\/       ldaddal w7, w24, [x15]\n-    __ ldbical(Assembler::word, r4, r27, r6);          \/\/       ldclral w4, w27, [x6]\n-    __ ldeoral(Assembler::word, r10, r27, r24);        \/\/       ldeoral w10, w27, [x24]\n-    __ ldorral(Assembler::word, r13, r16, sp);         \/\/       ldsetal w13, w16, [sp]\n-    __ ldsminal(Assembler::word, r22, r22, r20);       \/\/       ldsminal        w22, w22, [x20]\n-    __ ldsmaxal(Assembler::word, zr, r29, r9);         \/\/       ldsmaxal        wzr, w29, [x9]\n-    __ lduminal(Assembler::word, r14, r20, r7);        \/\/       lduminal        w14, w20, [x7]\n-    __ ldumaxal(Assembler::word, r20, r28, r9);        \/\/       ldumaxal        w20, w28, [x9]\n+    __ swpal(Assembler::word, r14, r12, r20);          \/\/       swpal   w14, w12, [x20]\n+    __ ldaddal(Assembler::word, r1, r24, r9);          \/\/       ldaddal w1, w24, [x9]\n+    __ ldbical(Assembler::word, r19, r13, r19);        \/\/       ldclral w19, w13, [x19]\n+    __ ldeoral(Assembler::word, r16, r16, r5);         \/\/       ldeoral w16, w16, [x5]\n+    __ ldorral(Assembler::word, r0, r3, r12);          \/\/       ldsetal w0, w3, [x12]\n+    __ ldsminal(Assembler::word, r8, r15, r15);        \/\/       ldsminal        w8, w15, [x15]\n+    __ ldsmaxal(Assembler::word, r16, r4, r15);        \/\/       ldsmaxal        w16, w4, [x15]\n+    __ lduminal(Assembler::word, r30, r5, r0);         \/\/       lduminal        w30, w5, [x0]\n+    __ ldumaxal(Assembler::word, r10, r22, r27);       \/\/       ldumaxal        w10, w22, [x27]\n@@ -1232,9 +1266,9 @@\n-    __ swpl(Assembler::word, r11, r14, r12);           \/\/       swpl    w11, w14, [x12]\n-    __ ldaddl(Assembler::word, r20, r1, r24);          \/\/       ldaddl  w20, w1, [x24]\n-    __ ldbicl(Assembler::word, r9, r19, r13);          \/\/       ldclrl  w9, w19, [x13]\n-    __ ldeorl(Assembler::word, r19, r16, r16);         \/\/       ldeorl  w19, w16, [x16]\n-    __ ldorrl(Assembler::word, r5, r0, r3);            \/\/       ldsetl  w5, w0, [x3]\n-    __ ldsminl(Assembler::word, r12, r8, r15);         \/\/       ldsminl w12, w8, [x15]\n-    __ ldsmaxl(Assembler::word, r15, r16, r4);         \/\/       ldsmaxl w15, w16, [x4]\n-    __ lduminl(Assembler::word, r15, r30, r5);         \/\/       lduminl w15, w30, [x5]\n-    __ ldumaxl(Assembler::word, r0, r10, r22);         \/\/       ldumaxl w0, w10, [x22]\n+    __ swpl(Assembler::word, r3, r0, r9);              \/\/       swpl    w3, w0, [x9]\n+    __ ldaddl(Assembler::word, r19, r29, r10);         \/\/       ldaddl  w19, w29, [x10]\n+    __ ldbicl(Assembler::word, r24, r4, r20);          \/\/       ldclrl  w24, w4, [x20]\n+    __ ldeorl(Assembler::word, r7, r24, r29);          \/\/       ldeorl  w7, w24, [x29]\n+    __ ldorrl(Assembler::word, r14, r21, r11);         \/\/       ldsetl  w14, w21, [x11]\n+    __ ldsminl(Assembler::word, r27, r13, r15);        \/\/       ldsminl w27, w13, [x15]\n+    __ ldsmaxl(Assembler::word, zr, r17, r14);         \/\/       ldsmaxl wzr, w17, [x14]\n+    __ lduminl(Assembler::word, r3, r30, r16);         \/\/       lduminl w3, w30, [x16]\n+    __ ldumaxl(Assembler::word, r22, r20, r7);         \/\/       ldumaxl w22, w20, [x7]\n@@ -1243,4 +1277,4 @@\n-    __ bcax(v27, __ T16B, v3, v0, v9);                 \/\/       bcax            v27.16B, v3.16B, v0.16B, v9.16B\n-    __ eor3(v19, __ T16B, v29, v10, v24);              \/\/       eor3            v19.16B, v29.16B, v10.16B, v24.16B\n-    __ rax1(v4, __ T2D, v20, v7);                      \/\/       rax1            v4.2D, v20.2D, v7.2D\n-    __ xar(v24, __ T2D, v29, v14, 43);                 \/\/       xar             v24.2D, v29.2D, v14.2D, #43\n+    __ bcax(v20, __ T16B, v3, v1, v26);                \/\/       bcax            v20.16B, v3.16B, v1.16B, v26.16B\n+    __ eor3(v19, __ T16B, v9, v16, v17);               \/\/       eor3            v19.16B, v9.16B, v16.16B, v17.16B\n+    __ rax1(v21, __ T2D, v0, v4);                      \/\/       rax1            v21.2D, v0.2D, v4.2D\n+    __ xar(v2, __ T2D, v24, v14, 12);                  \/\/       xar             v2.2D, v24.2D, v14.2D, #12\n@@ -1249,4 +1283,4 @@\n-    __ sha512h(v11, __ T2D, v27, v13);                 \/\/       sha512h         q11, q27, v13.2D\n-    __ sha512h2(v18, __ T2D, v31, v17);                \/\/       sha512h2                q18, q31, v17.2D\n-    __ sha512su0(v14, __ T2D, v3);                     \/\/       sha512su0               v14.2D, v3.2D\n-    __ sha512su1(v30, __ T2D, v16, v22);               \/\/       sha512su1               v30.2D, v16.2D, v22.2D\n+    __ sha512h(v11, __ T2D, v21, v14);                 \/\/       sha512h         q11, q21, v14.2D\n+    __ sha512h2(v17, __ T2D, v30, v12);                \/\/       sha512h2                q17, q30, v12.2D\n+    __ sha512su0(v3, __ T2D, v3);                      \/\/       sha512su0               v3.2D, v3.2D\n+    __ sha512su1(v23, __ T2D, v9, v3);                 \/\/       sha512su1               v23.2D, v9.2D, v3.2D\n@@ -1255,5 +1289,5 @@\n-    __ sve_add(z20, __ B, 163u);                       \/\/       add     z20.b, z20.b, #0xa3\n-    __ sve_sub(z3, __ B, 215u);                        \/\/       sub     z3.b, z3.b, #0xd7\n-    __ sve_and(z19, __ H, 33279u);                     \/\/       and     z19.h, z19.h, #0x81ff\n-    __ sve_eor(z21, __ B, 12u);                        \/\/       eor     z21.b, z21.b, #0xc\n-    __ sve_orr(z24, __ H, 8064u);                      \/\/       orr     z24.h, z24.h, #0x1f80\n+    __ sve_add(z24, __ D, 26u);                        \/\/       add     z24.d, z24.d, #0x1a\n+    __ sve_sub(z19, __ S, 62u);                        \/\/       sub     z19.s, z19.s, #0x3e\n+    __ sve_and(z26, __ S, 917504u);                    \/\/       and     z26.s, z26.s, #0xe0000\n+    __ sve_eor(z8, __ D, 18442240474082197503u);       \/\/       eor     z8.d, z8.d, #0xfff0000000003fff\n+    __ sve_orr(z18, __ S, 253952u);                    \/\/       orr     z18.s, z18.s, #0x3e000\n@@ -1262,5 +1296,5 @@\n-    __ sve_add(z21, __ H, 139u);                       \/\/       add     z21.h, z21.h, #0x8b\n-    __ sve_sub(z30, __ H, 26u);                        \/\/       sub     z30.h, z30.h, #0x1a\n-    __ sve_and(z3, __ S, 122880u);                     \/\/       and     z3.s, z3.s, #0x1e000\n-    __ sve_eor(z24, __ D, 18158513714670600195u);      \/\/       eor     z24.d, z24.d, #0xfc000003fc000003\n-    __ sve_orr(z23, __ B, 191u);                       \/\/       orr     z23.b, z23.b, #0xbf\n+    __ sve_add(z9, __ S, 97u);                         \/\/       add     z9.s, z9.s, #0x61\n+    __ sve_sub(z8, __ H, 118u);                        \/\/       sub     z8.h, z8.h, #0x76\n+    __ sve_and(z19, __ S, 1056980736u);                \/\/       and     z19.s, z19.s, #0x3f003f00\n+    __ sve_eor(z25, __ S, 3758350339u);                \/\/       eor     z25.s, z25.s, #0xe003e003\n+    __ sve_orr(z9, __ S, 4294459391u);                 \/\/       orr     z9.s, z9.s, #0xfff83fff\n@@ -1269,5 +1303,5 @@\n-    __ sve_add(z14, __ B, 66u);                        \/\/       add     z14.b, z14.b, #0x42\n-    __ sve_sub(z26, __ B, 180u);                       \/\/       sub     z26.b, z26.b, #0xb4\n-    __ sve_and(z18, __ S, 253952u);                    \/\/       and     z18.s, z18.s, #0x3e000\n-    __ sve_eor(z9, __ S, 16744448u);                   \/\/       eor     z9.s, z9.s, #0xff8000\n-    __ sve_orr(z12, __ H, 33279u);                     \/\/       orr     z12.h, z12.h, #0x81ff\n+    __ sve_add(z23, __ D, 183u);                       \/\/       add     z23.d, z23.d, #0xb7\n+    __ sve_sub(z8, __ H, 41u);                         \/\/       sub     z8.h, z8.h, #0x29\n+    __ sve_and(z28, __ D, 8064u);                      \/\/       and     z28.d, z28.d, #0x1f80\n+    __ sve_eor(z15, __ D, 18428729675200069887u);      \/\/       eor     z15.d, z15.d, #0xffc00000000000ff\n+    __ sve_orr(z0, __ B, 239u);                        \/\/       orr     z0.b, z0.b, #0xef\n@@ -1276,5 +1310,5 @@\n-    __ sve_add(z11, __ H, 206u);                       \/\/       add     z11.h, z11.h, #0xce\n-    __ sve_sub(z18, __ D, 154u);                       \/\/       sub     z18.d, z18.d, #0x9a\n-    __ sve_and(z9, __ S, 4294459391u);                 \/\/       and     z9.s, z9.s, #0xfff83fff\n-    __ sve_eor(z23, __ D, 562675075514368u);           \/\/       eor     z23.d, z23.d, #0x1ffc000000000\n-    __ sve_orr(z8, __ B, 243u);                        \/\/       orr     z8.b, z8.b, #0xf3\n+    __ sve_add(z5, __ D, 243u);                        \/\/       add     z5.d, z5.d, #0xf3\n+    __ sve_sub(z19, __ S, 8u);                         \/\/       sub     z19.s, z19.s, #0x8\n+    __ sve_and(z13, __ H, 32256u);                     \/\/       and     z13.h, z13.h, #0x7e00\n+    __ sve_eor(z0, __ S, 4294967293u);                 \/\/       eor     z0.s, z0.s, #0xfffffffd\n+    __ sve_orr(z21, __ S, 4294965263u);                \/\/       orr     z21.s, z21.s, #0xfffff80f\n@@ -1283,5 +1317,5 @@\n-    __ sve_add(z10, __ B, 121u);                       \/\/       add     z10.b, z10.b, #0x79\n-    __ sve_sub(z25, __ S, 172u);                       \/\/       sub     z25.s, z25.s, #0xac\n-    __ sve_and(z0, __ B, 239u);                        \/\/       and     z0.b, z0.b, #0xef\n-    __ sve_eor(z5, __ D, 17870287719452639231u);       \/\/       eor     z5.d, z5.d, #0xf80003ffffffffff\n-    __ sve_orr(z17, __ B, 128u);                       \/\/       orr     z17.b, z17.b, #0x80\n+    __ sve_add(z12, __ H, 20u);                        \/\/       add     z12.h, z12.h, #0x14\n+    __ sve_sub(z0, __ H, 190u);                        \/\/       sub     z0.h, z0.h, #0xbe\n+    __ sve_and(z23, __ B, 239u);                       \/\/       and     z23.b, z23.b, #0xef\n+    __ sve_eor(z27, __ D, 18442240474082197503u);      \/\/       eor     z27.d, z27.d, #0xfff0000000003fff\n+    __ sve_orr(z22, __ B, 124u);                       \/\/       orr     z22.b, z22.b, #0x7c\n@@ -1290,5 +1324,5 @@\n-    __ sve_add(z30, __ H, 3u);                         \/\/       add     z30.h, z30.h, #0x3\n-    __ sve_sub(z18, __ B, 253u);                       \/\/       sub     z18.b, z18.b, #0xfd\n-    __ sve_and(z21, __ S, 4294965263u);                \/\/       and     z21.s, z21.s, #0xfffff80f\n-    __ sve_eor(z12, __ H, 1u);                         \/\/       eor     z12.h, z12.h, #0x1\n-    __ sve_orr(z15, __ S, 1u);                         \/\/       orr     z15.s, z15.s, #0x1\n+    __ sve_add(z20, __ H, 165u);                       \/\/       add     z20.h, z20.h, #0xa5\n+    __ sve_sub(z24, __ D, 72u);                        \/\/       sub     z24.d, z24.d, #0x48\n+    __ sve_and(z31, __ S, 4026535935u);                \/\/       and     z31.s, z31.s, #0xf0000fff\n+    __ sve_eor(z21, __ B, 128u);                       \/\/       eor     z21.b, z21.b, #0x80\n+    __ sve_orr(z30, __ S, 4294967293u);                \/\/       orr     z30.s, z30.s, #0xfffffffd\n@@ -1297,66 +1331,66 @@\n-    __ sve_add(z19, __ D, z26, z27);                   \/\/       add     z19.d, z26.d, z27.d\n-    __ sve_sub(z13, __ B, z22, z22);                   \/\/       sub     z13.b, z22.b, z22.b\n-    __ sve_fadd(z1, __ S, z11, z20);                   \/\/       fadd    z1.s, z11.s, z20.s\n-    __ sve_fmul(z20, __ S, z24, z24);                  \/\/       fmul    z20.s, z24.s, z24.s\n-    __ sve_fsub(z31, __ D, z17, z20);                  \/\/       fsub    z31.d, z17.d, z20.d\n-    __ sve_sqadd(z21, __ H, z4, z21);                  \/\/       sqadd   z21.h, z4.h, z21.h\n-    __ sve_sqsub(z30, __ D, z22, z31);                 \/\/       sqsub   z30.d, z22.d, z31.d\n-    __ sve_uqadd(z26, __ H, z18, z19);                 \/\/       uqadd   z26.h, z18.h, z19.h\n-    __ sve_uqsub(z11, __ S, z13, z29);                 \/\/       uqsub   z11.s, z13.s, z29.s\n-    __ sve_abs(z5, __ H, p0, z14);                     \/\/       abs     z5.h, p0\/m, z14.h\n-    __ sve_add(z2, __ H, p1, z10);                     \/\/       add     z2.h, p1\/m, z2.h, z10.h\n-    __ sve_and(z19, __ H, p1, z26);                    \/\/       and     z19.h, p1\/m, z19.h, z26.h\n-    __ sve_asr(z2, __ B, p0, z30);                     \/\/       asr     z2.b, p0\/m, z2.b, z30.b\n-    __ sve_bic(z20, __ D, p1, z20);                    \/\/       bic     z20.d, p1\/m, z20.d, z20.d\n-    __ sve_clz(z29, __ H, p3, z13);                    \/\/       clz     z29.h, p3\/m, z13.h\n-    __ sve_cnt(z14, __ H, p7, z1);                     \/\/       cnt     z14.h, p7\/m, z1.h\n-    __ sve_eor(z28, __ D, p0, z3);                     \/\/       eor     z28.d, p0\/m, z28.d, z3.d\n-    __ sve_lsl(z9, __ B, p6, z9);                      \/\/       lsl     z9.b, p6\/m, z9.b, z9.b\n-    __ sve_lsr(z26, __ B, p2, z14);                    \/\/       lsr     z26.b, p2\/m, z26.b, z14.b\n-    __ sve_mul(z20, __ D, p6, z7);                     \/\/       mul     z20.d, p6\/m, z20.d, z7.d\n-    __ sve_neg(z20, __ D, p4, z6);                     \/\/       neg     z20.d, p4\/m, z6.d\n-    __ sve_not(z13, __ H, p0, z29);                    \/\/       not     z13.h, p0\/m, z29.h\n-    __ sve_orr(z9, __ B, p0, z1);                      \/\/       orr     z9.b, p0\/m, z9.b, z1.b\n-    __ sve_rbit(z27, __ B, p6, z15);                   \/\/       rbit    z27.b, p6\/m, z15.b\n-    __ sve_revb(z4, __ D, p7, z17);                    \/\/       revb    z4.d, p7\/m, z17.d\n-    __ sve_smax(z2, __ B, p0, z24);                    \/\/       smax    z2.b, p0\/m, z2.b, z24.b\n-    __ sve_smin(z26, __ B, p7, z13);                   \/\/       smin    z26.b, p7\/m, z26.b, z13.b\n-    __ sve_umax(z22, __ D, p3, z16);                   \/\/       umax    z22.d, p3\/m, z22.d, z16.d\n-    __ sve_umin(z17, __ D, p1, z11);                   \/\/       umin    z17.d, p1\/m, z17.d, z11.d\n-    __ sve_sub(z16, __ B, p0, z16);                    \/\/       sub     z16.b, p0\/m, z16.b, z16.b\n-    __ sve_fabs(z28, __ D, p1, z23);                   \/\/       fabs    z28.d, p1\/m, z23.d\n-    __ sve_fadd(z28, __ D, p4, z10);                   \/\/       fadd    z28.d, p4\/m, z28.d, z10.d\n-    __ sve_fdiv(z17, __ D, p7, z7);                    \/\/       fdiv    z17.d, p7\/m, z17.d, z7.d\n-    __ sve_fmax(z4, __ S, p3, z24);                    \/\/       fmax    z4.s, p3\/m, z4.s, z24.s\n-    __ sve_fmin(z9, __ S, p2, z11);                    \/\/       fmin    z9.s, p2\/m, z9.s, z11.s\n-    __ sve_fmul(z4, __ D, p5, z22);                    \/\/       fmul    z4.d, p5\/m, z4.d, z22.d\n-    __ sve_fneg(z4, __ S, p0, z15);                    \/\/       fneg    z4.s, p0\/m, z15.s\n-    __ sve_frintm(z4, __ D, p7, z26);                  \/\/       frintm  z4.d, p7\/m, z26.d\n-    __ sve_frintn(z5, __ S, p5, z26);                  \/\/       frintn  z5.s, p5\/m, z26.s\n-    __ sve_frintp(z31, __ S, p0, z25);                 \/\/       frintp  z31.s, p0\/m, z25.s\n-    __ sve_fsqrt(z8, __ D, p1, z3);                    \/\/       fsqrt   z8.d, p1\/m, z3.d\n-    __ sve_fsub(z7, __ D, p6, z24);                    \/\/       fsub    z7.d, p6\/m, z7.d, z24.d\n-    __ sve_fmad(z24, __ S, p7, z17, z1);               \/\/       fmad    z24.s, p7\/m, z17.s, z1.s\n-    __ sve_fmla(z12, __ D, p7, z13, z8);               \/\/       fmla    z12.d, p7\/m, z13.d, z8.d\n-    __ sve_fmls(z29, __ D, p0, z31, z23);              \/\/       fmls    z29.d, p0\/m, z31.d, z23.d\n-    __ sve_fmsb(z20, __ D, p0, z21, z7);               \/\/       fmsb    z20.d, p0\/m, z21.d, z7.d\n-    __ sve_fnmad(z29, __ D, p6, z22, z8);              \/\/       fnmad   z29.d, p6\/m, z22.d, z8.d\n-    __ sve_fnmsb(z26, __ D, p5, z5, z6);               \/\/       fnmsb   z26.d, p5\/m, z5.d, z6.d\n-    __ sve_fnmla(z18, __ S, p3, z26, z21);             \/\/       fnmla   z18.s, p3\/m, z26.s, z21.s\n-    __ sve_fnmls(z0, __ S, p4, z10, z28);              \/\/       fnmls   z0.s, p4\/m, z10.s, z28.s\n-    __ sve_mla(z17, __ D, p1, z30, z20);               \/\/       mla     z17.d, p1\/m, z30.d, z20.d\n-    __ sve_mls(z28, __ S, p3, z17, z14);               \/\/       mls     z28.s, p3\/m, z17.s, z14.s\n-    __ sve_and(z10, z26, z11);                         \/\/       and     z10.d, z26.d, z11.d\n-    __ sve_eor(z0, z11, z15);                          \/\/       eor     z0.d, z11.d, z15.d\n-    __ sve_orr(z23, z23, z20);                         \/\/       orr     z23.d, z23.d, z20.d\n-    __ sve_bic(z23, z20, z29);                         \/\/       bic     z23.d, z20.d, z29.d\n-    __ sve_uzp1(z0, __ S, z27, z6);                    \/\/       uzp1    z0.s, z27.s, z6.s\n-    __ sve_uzp2(z13, __ H, z12, z4);                   \/\/       uzp2    z13.h, z12.h, z4.h\n-    __ sve_fabd(z31, __ D, p6, z23);                   \/\/       fabd    z31.d, p6\/m, z31.d, z23.d\n-    __ sve_bext(z6, __ D, z2, z29);                    \/\/       bext    z6.d, z2.d, z29.d\n-    __ sve_bdep(z0, __ B, z29, z23);                   \/\/       bdep    z0.b, z29.b, z23.b\n-    __ sve_eor3(z4, z5, z8);                           \/\/       eor3    z4.d, z4.d, z5.d, z8.d\n-    __ sve_sqadd(z13, __ H, p4, z13);                  \/\/       sqadd   z13.h, p4\/m, z13.h, z13.h\n-    __ sve_sqsub(z8, __ H, p2, z8);                    \/\/       sqsub   z8.h, p2\/m, z8.h, z8.h\n-    __ sve_uqadd(z19, __ S, p0, z29);                  \/\/       uqadd   z19.s, p0\/m, z19.s, z29.s\n-    __ sve_uqsub(z16, __ D, p3, z23);                  \/\/       uqsub   z16.d, p3\/m, z16.d, z23.d\n+    __ sve_add(z26, __ H, z18, z19);                   \/\/       add     z26.h, z18.h, z19.h\n+    __ sve_sub(z11, __ S, z13, z29);                   \/\/       sub     z11.s, z13.s, z29.s\n+    __ sve_fadd(z5, __ S, z1, z14);                    \/\/       fadd    z5.s, z1.s, z14.s\n+    __ sve_fmul(z2, __ S, z7, z10);                    \/\/       fmul    z2.s, z7.s, z10.s\n+    __ sve_fsub(z19, __ S, z4, z26);                   \/\/       fsub    z19.s, z4.s, z26.s\n+    __ sve_sqadd(z2, __ B, z3, z30);                   \/\/       sqadd   z2.b, z3.b, z30.b\n+    __ sve_sqsub(z20, __ D, z5, z20);                  \/\/       sqsub   z20.d, z5.d, z20.d\n+    __ sve_uqadd(z29, __ H, z13, z13);                 \/\/       uqadd   z29.h, z13.h, z13.h\n+    __ sve_uqsub(z14, __ H, z30, z1);                  \/\/       uqsub   z14.h, z30.h, z1.h\n+    __ sve_abs(z28, __ D, p0, z3);                     \/\/       abs     z28.d, p0\/m, z3.d\n+    __ sve_add(z9, __ B, p6, z9);                      \/\/       add     z9.b, p6\/m, z9.b, z9.b\n+    __ sve_and(z26, __ B, p2, z14);                    \/\/       and     z26.b, p2\/m, z26.b, z14.b\n+    __ sve_asr(z20, __ D, p6, z7);                     \/\/       asr     z20.d, p6\/m, z20.d, z7.d\n+    __ sve_bic(z20, __ D, p4, z6);                     \/\/       bic     z20.d, p4\/m, z20.d, z6.d\n+    __ sve_clz(z13, __ H, p0, z29);                    \/\/       clz     z13.h, p0\/m, z29.h\n+    __ sve_cnt(z9, __ B, p0, z1);                      \/\/       cnt     z9.b, p0\/m, z1.b\n+    __ sve_eor(z27, __ B, p6, z15);                    \/\/       eor     z27.b, p6\/m, z27.b, z15.b\n+    __ sve_lsl(z4, __ D, p7, z17);                     \/\/       lsl     z4.d, p7\/m, z4.d, z17.d\n+    __ sve_lsr(z2, __ B, p0, z24);                     \/\/       lsr     z2.b, p0\/m, z2.b, z24.b\n+    __ sve_mul(z26, __ B, p7, z13);                    \/\/       mul     z26.b, p7\/m, z26.b, z13.b\n+    __ sve_neg(z22, __ D, p3, z16);                    \/\/       neg     z22.d, p3\/m, z16.d\n+    __ sve_not(z17, __ D, p1, z11);                    \/\/       not     z17.d, p1\/m, z11.d\n+    __ sve_orr(z16, __ B, p0, z16);                    \/\/       orr     z16.b, p0\/m, z16.b, z16.b\n+    __ sve_rbit(z28, __ D, p1, z23);                   \/\/       rbit    z28.d, p1\/m, z23.d\n+    __ sve_revb(z28, __ D, p4, z10);                   \/\/       revb    z28.d, p4\/m, z10.d\n+    __ sve_smax(z17, __ S, p7, z7);                    \/\/       smax    z17.s, p7\/m, z17.s, z7.s\n+    __ sve_smin(z4, __ H, p3, z24);                    \/\/       smin    z4.h, p3\/m, z4.h, z24.h\n+    __ sve_umax(z9, __ B, p2, z11);                    \/\/       umax    z9.b, p2\/m, z9.b, z11.b\n+    __ sve_umin(z4, __ S, p5, z22);                    \/\/       umin    z4.s, p5\/m, z4.s, z22.s\n+    __ sve_sub(z4, __ H, p0, z15);                     \/\/       sub     z4.h, p0\/m, z4.h, z15.h\n+    __ sve_fabs(z4, __ D, p7, z26);                    \/\/       fabs    z4.d, p7\/m, z26.d\n+    __ sve_fadd(z5, __ S, p5, z26);                    \/\/       fadd    z5.s, p5\/m, z5.s, z26.s\n+    __ sve_fdiv(z31, __ S, p0, z25);                   \/\/       fdiv    z31.s, p0\/m, z31.s, z25.s\n+    __ sve_fmax(z8, __ D, p1, z3);                     \/\/       fmax    z8.d, p1\/m, z8.d, z3.d\n+    __ sve_fmin(z7, __ D, p6, z24);                    \/\/       fmin    z7.d, p6\/m, z7.d, z24.d\n+    __ sve_fmul(z24, __ S, p7, z17);                   \/\/       fmul    z24.s, p7\/m, z24.s, z17.s\n+    __ sve_fneg(z10, __ S, p3, z30);                   \/\/       fneg    z10.s, p3\/m, z30.s\n+    __ sve_frintm(z8, __ S, p6, z29);                  \/\/       frintm  z8.s, p6\/m, z29.s\n+    __ sve_frintn(z31, __ D, p5, z31);                 \/\/       frintn  z31.d, p5\/m, z31.d\n+    __ sve_frintp(z0, __ D, p5, z7);                   \/\/       frintp  z0.d, p5\/m, z7.d\n+    __ sve_fsqrt(z29, __ S, p6, z22);                  \/\/       fsqrt   z29.s, p6\/m, z22.s\n+    __ sve_fsub(z29, __ S, p6, z20);                   \/\/       fsub    z29.s, p6\/m, z29.s, z20.s\n+    __ sve_fmad(z6, __ D, p4, z18, z13);               \/\/       fmad    z6.d, p4\/m, z18.d, z13.d\n+    __ sve_fmla(z21, __ S, p2, z0, z19);               \/\/       fmla    z21.s, p2\/m, z0.s, z19.s\n+    __ sve_fmls(z28, __ D, p1, z17, z6);               \/\/       fmls    z28.d, p1\/m, z17.d, z6.d\n+    __ sve_fmsb(z20, __ D, p6, z28, z14);              \/\/       fmsb    z20.d, p6\/m, z28.d, z14.d\n+    __ sve_fnmad(z14, __ S, p4, z10, z26);             \/\/       fnmad   z14.s, p4\/m, z10.s, z26.s\n+    __ sve_fnmsb(z24, __ D, p0, z11, z15);             \/\/       fnmsb   z24.d, p0\/m, z11.d, z15.d\n+    __ sve_fnmla(z23, __ D, p5, z20, z28);             \/\/       fnmla   z23.d, p5\/m, z20.d, z28.d\n+    __ sve_fnmls(z20, __ D, p7, z24, z0);              \/\/       fnmls   z20.d, p7\/m, z24.d, z0.d\n+    __ sve_mla(z6, __ B, p5, z13, z12);                \/\/       mla     z6.b, p5\/m, z13.b, z12.b\n+    __ sve_mls(z13, __ S, p7, z26, z23);               \/\/       mls     z13.s, p7\/m, z26.s, z23.s\n+    __ sve_and(z6, z2, z29);                           \/\/       and     z6.d, z2.d, z29.d\n+    __ sve_eor(z0, z29, z23);                          \/\/       eor     z0.d, z29.d, z23.d\n+    __ sve_orr(z4, z5, z8);                            \/\/       orr     z4.d, z5.d, z8.d\n+    __ sve_bic(z13, z17, z13);                         \/\/       bic     z13.d, z17.d, z13.d\n+    __ sve_uzp1(z8, __ H, z10, z8);                    \/\/       uzp1    z8.h, z10.h, z8.h\n+    __ sve_uzp2(z19, __ S, z0, z29);                   \/\/       uzp2    z19.s, z0.s, z29.s\n+    __ sve_fabd(z16, __ D, p3, z23);                   \/\/       fabd    z16.d, p3\/m, z16.d, z23.d\n+    __ sve_bext(z23, __ B, z30, z13);                  \/\/       bext    z23.b, z30.b, z13.b\n+    __ sve_bdep(z25, __ H, z22, z0);                   \/\/       bdep    z25.h, z22.h, z0.h\n+    __ sve_eor3(z25, z30, z11);                        \/\/       eor3    z25.d, z25.d, z30.d, z11.d\n+    __ sve_sqadd(z14, __ H, p5, z22);                  \/\/       sqadd   z14.h, p5\/m, z14.h, z22.h\n+    __ sve_sqsub(z5, __ H, p4, z0);                    \/\/       sqsub   z5.h, p4\/m, z5.h, z0.h\n+    __ sve_uqadd(z9, __ D, p0, z3);                    \/\/       uqadd   z9.d, p0\/m, z9.d, z3.d\n+    __ sve_uqsub(z14, __ H, p1, z29);                  \/\/       uqsub   z14.h, p1\/m, z14.h, z29.h\n@@ -1365,9 +1399,9 @@\n-    __ sve_andv(v23, __ B, p7, z13);                   \/\/       andv b23, p7, z13.b\n-    __ sve_orv(v25, __ H, p5, z0);                     \/\/       orv h25, p5, z0.h\n-    __ sve_eorv(v25, __ H, p7, z11);                   \/\/       eorv h25, p7, z11.h\n-    __ sve_smaxv(v14, __ H, p5, z22);                  \/\/       smaxv h14, p5, z22.h\n-    __ sve_sminv(v5, __ H, p4, z0);                    \/\/       sminv h5, p4, z0.h\n-    __ sve_fminv(v9, __ D, p0, z3);                    \/\/       fminv d9, p0, z3.d\n-    __ sve_fmaxv(v14, __ S, p1, z29);                  \/\/       fmaxv s14, p1, z29.s\n-    __ sve_fadda(v14, __ D, p5, z4);                   \/\/       fadda d14, p5, d14, z4.d\n-    __ sve_uaddv(v27, __ S, p3, z22);                  \/\/       uaddv d27, p3, z22.s\n+    __ sve_andv(v14, __ D, p5, z4);                    \/\/       andv d14, p5, z4.d\n+    __ sve_orv(v27, __ S, p3, z22);                    \/\/       orv s27, p3, z22.s\n+    __ sve_eorv(v31, __ S, p6, z11);                   \/\/       eorv s31, p6, z11.s\n+    __ sve_smaxv(v12, __ B, p4, z28);                  \/\/       smaxv b12, p4, z28.b\n+    __ sve_sminv(v28, __ D, p4, z4);                   \/\/       sminv d28, p4, z4.d\n+    __ sve_fminv(v6, __ D, p0, z15);                   \/\/       fminv d6, p0, z15.d\n+    __ sve_fmaxv(v1, __ D, p5, z18);                   \/\/       fmaxv d1, p5, z18.d\n+    __ sve_fadda(v2, __ S, p2, z4);                    \/\/       fadda s2, p2, s2, z4.s\n+    __ sve_uaddv(v11, __ S, p2, z28);                  \/\/       uaddv d11, p2, z28.s\n@@ -1376,12 +1410,12 @@\n-    __ saddwv(v31, v0, __ T8H, v1, __ T8B);            \/\/       saddw   v31.8H, v0.8H, v1.8B\n-    __ saddwv2(v24, v25, __ T8H, v26, __ T16B);        \/\/       saddw2  v24.8H, v25.8H, v26.16B\n-    __ saddwv(v11, v12, __ T4S, v13, __ T4H);          \/\/       saddw   v11.4S, v12.4S, v13.4H\n-    __ saddwv2(v16, v17, __ T4S, v18, __ T8H);         \/\/       saddw2  v16.4S, v17.4S, v18.8H\n-    __ saddwv(v12, v13, __ T2D, v14, __ T2S);          \/\/       saddw   v12.2D, v13.2D, v14.2S\n-    __ saddwv2(v17, v18, __ T2D, v19, __ T4S);         \/\/       saddw2  v17.2D, v18.2D, v19.4S\n-    __ uaddwv(v28, v29, __ T8H, v30, __ T8B);          \/\/       uaddw   v28.8H, v29.8H, v30.8B\n-    __ uaddwv2(v3, v4, __ T8H, v5, __ T16B);           \/\/       uaddw2  v3.8H, v4.8H, v5.16B\n-    __ uaddwv(v28, v29, __ T4S, v30, __ T4H);          \/\/       uaddw   v28.4S, v29.4S, v30.4H\n-    __ uaddwv2(v16, v17, __ T4S, v18, __ T8H);         \/\/       uaddw2  v16.4S, v17.4S, v18.8H\n-    __ uaddwv(v4, v5, __ T2D, v6, __ T2S);             \/\/       uaddw   v4.2D, v5.2D, v6.2S\n-    __ uaddwv2(v29, v30, __ T2D, v31, __ T4S);         \/\/       uaddw2  v29.2D, v30.2D, v31.4S\n+    __ saddwv(v3, v4, __ T8H, v5, __ T8B);             \/\/       saddw   v3.8H, v4.8H, v5.8B\n+    __ saddwv2(v21, v22, __ T8H, v23, __ T16B);        \/\/       saddw2  v21.8H, v22.8H, v23.16B\n+    __ saddwv(v31, v0, __ T4S, v1, __ T4H);            \/\/       saddw   v31.4S, v0.4S, v1.4H\n+    __ saddwv2(v11, v12, __ T4S, v13, __ T8H);         \/\/       saddw2  v11.4S, v12.4S, v13.8H\n+    __ saddwv(v24, v25, __ T2D, v26, __ T2S);          \/\/       saddw   v24.2D, v25.2D, v26.2S\n+    __ saddwv2(v21, v22, __ T2D, v23, __ T4S);         \/\/       saddw2  v21.2D, v22.2D, v23.4S\n+    __ uaddwv(v15, v16, __ T8H, v17, __ T8B);          \/\/       uaddw   v15.8H, v16.8H, v17.8B\n+    __ uaddwv2(v12, v13, __ T8H, v14, __ T16B);        \/\/       uaddw2  v12.8H, v13.8H, v14.16B\n+    __ uaddwv(v6, v7, __ T4S, v8, __ T4H);             \/\/       uaddw   v6.4S, v7.4S, v8.4H\n+    __ uaddwv2(v13, v14, __ T4S, v15, __ T8H);         \/\/       uaddw2  v13.4S, v14.4S, v15.8H\n+    __ uaddwv(v8, v9, __ T2D, v10, __ T2S);            \/\/       uaddw   v8.2D, v9.2D, v10.2S\n+    __ uaddwv2(v15, v16, __ T2D, v17, __ T4S);         \/\/       uaddw2  v15.2D, v16.2D, v17.4S\n@@ -1406,7 +1440,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400048d,     0x94000000,\n-    0x97ffffd4,     0x9400048a,     0x3400000a,     0x34fffa2a,\n-    0x340090ea,     0x35000008,     0x35fff9c8,     0x35009088,\n-    0xb400000b,     0xb4fff96b,     0xb400902b,     0xb500001d,\n-    0xb5fff91d,     0xb5008fdd,     0x10000013,     0x10fff8b3,\n-    0x10008f73,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36308ef6,     0x3758000c,     0x375ff7cc,     0x37588e8c,\n+    0x14000000,     0x17ffffd7,     0x140004af,     0x94000000,\n+    0x97ffffd4,     0x940004ac,     0x3400000a,     0x34fffa2a,\n+    0x3400952a,     0x35000008,     0x35fff9c8,     0x350094c8,\n+    0xb400000b,     0xb4fff96b,     0xb400946b,     0xb500001d,\n+    0xb5fff91d,     0xb500941d,     0x10000013,     0x10fff8b3,\n+    0x100093b3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36309336,     0x3758000c,     0x375ff7cc,     0x375892cc,\n@@ -1417,13 +1451,13 @@\n-    0x54008c60,     0x54000001,     0x54fff541,     0x54008c01,\n-    0x54000002,     0x54fff4e2,     0x54008ba2,     0x54000002,\n-    0x54fff482,     0x54008b42,     0x54000003,     0x54fff423,\n-    0x54008ae3,     0x54000003,     0x54fff3c3,     0x54008a83,\n-    0x54000004,     0x54fff364,     0x54008a24,     0x54000005,\n-    0x54fff305,     0x540089c5,     0x54000006,     0x54fff2a6,\n-    0x54008966,     0x54000007,     0x54fff247,     0x54008907,\n-    0x54000008,     0x54fff1e8,     0x540088a8,     0x54000009,\n-    0x54fff189,     0x54008849,     0x5400000a,     0x54fff12a,\n-    0x540087ea,     0x5400000b,     0x54fff0cb,     0x5400878b,\n-    0x5400000c,     0x54fff06c,     0x5400872c,     0x5400000d,\n-    0x54fff00d,     0x540086cd,     0x5400000e,     0x54ffefae,\n-    0x5400866e,     0x5400000f,     0x54ffef4f,     0x5400860f,\n+    0x540090a0,     0x54000001,     0x54fff541,     0x54009041,\n+    0x54000002,     0x54fff4e2,     0x54008fe2,     0x54000002,\n+    0x54fff482,     0x54008f82,     0x54000003,     0x54fff423,\n+    0x54008f23,     0x54000003,     0x54fff3c3,     0x54008ec3,\n+    0x54000004,     0x54fff364,     0x54008e64,     0x54000005,\n+    0x54fff305,     0x54008e05,     0x54000006,     0x54fff2a6,\n+    0x54008da6,     0x54000007,     0x54fff247,     0x54008d47,\n+    0x54000008,     0x54fff1e8,     0x54008ce8,     0x54000009,\n+    0x54fff189,     0x54008c89,     0x5400000a,     0x54fff12a,\n+    0x54008c2a,     0x5400000b,     0x54fff0cb,     0x54008bcb,\n+    0x5400000c,     0x54fff06c,     0x54008b6c,     0x5400000d,\n+    0x54fff00d,     0x54008b0d,     0x5400000e,     0x54ffefae,\n+    0x54008aae,     0x5400000f,     0x54ffef4f,     0x54008a4f,\n@@ -1531,56 +1565,63 @@\n-    0x2ea0f841,     0x6ea0f820,     0x6ee0fb38,     0x2ea1f8a4,\n-    0x6ea1f883,     0x6ee1f9ac,     0x2e20581f,     0x6e205bbc,\n-    0x0e2c1d6a,     0x4e3c1f7a,     0x0ea41c62,     0x4eae1dac,\n-    0x2e341e72,     0x6e211c1f,     0x0e238441,     0x4e2f85cd,\n-    0x0e7f87dd,     0x4e628420,     0x0eb58693,     0x4eae85ac,\n-    0x4ef38651,     0x0e380ef6,     0x4e2f0dcd,     0x0e7e0fbc,\n-    0x4e600ffe,     0x0ea10c1f,     0x4ea30c41,     0x4efc0f7a,\n-    0x2e3e0fbc,     0x6e260ca4,     0x2e600ffe,     0x6e660ca4,\n-    0x2ea80ce6,     0x6ea00ffe,     0x6efc0f7a,     0x0e34d672,\n-    0x4e2bd549,     0x4e6ad528,     0x2e2e85ac,     0x6e228420,\n-    0x2e7686b4,     0x6e638441,     0x2eba8738,     0x6ea48462,\n-    0x6ee28420,     0x0e2b2d49,     0x4e3a2f38,     0x0e7c2f7a,\n-    0x4e722e30,     0x0ea02ffe,     0x4ea52c83,     0x4eec2d6a,\n-    0x2e392f17,     0x6e2c2d6a,     0x2e662ca4,     0x6e742e72,\n-    0x2ea42c62,     0x6ead2d8b,     0x6eea2d28,     0x0eacd56a,\n-    0x4eb1d60f,     0x4ef3d651,     0x0e249c62,     0x4e2c9d6a,\n-    0x0e6e9dac,     0x4e6e9dac,     0x0eb19e0f,     0x4eaf9dcd,\n-    0x2ea4d462,     0x6ea9d507,     0x6ef6d6b4,     0x2e3cd77a,\n-    0x6e32d630,     0x6e66d4a4,     0x2e24dc62,     0x6e26dca4,\n-    0x6e6eddac,     0x0e749672,     0x4e7796d5,     0x0eb29630,\n-    0x4eb49672,     0x0e2dcd8b,     0x4e37ced5,     0x4e79cf17,\n-    0x2e6e95ac,     0x6e7c977a,     0x2eb99717,     0x6ebe97bc,\n-    0x0eb0cdee,     0x4eadcd8b,     0x4efacf38,     0x2e23fc41,\n-    0x6e2efdac,     0x6e61fc1f,     0x0e2c656a,     0x4e326630,\n-    0x0e696507,     0x4e646462,     0x0ea56483,     0x4eaf65cd,\n-    0x2e356693,     0x6e336651,     0x2e726630,     0x6e656483,\n-    0x2ea36441,     0x6ead658b,     0x0e20a7fe,     0x4e27a4c5,\n-    0x0e6aa528,     0x4e71a60f,     0x0ebfa7dd,     0x4ea0a7fe,\n-    0x0e22f420,     0x4e36f6b4,     0x4e69f507,     0x0e366eb4,\n-    0x4e396f17,     0x0e7e6fbc,     0x4e776ed5,     0x0ebd6f9b,\n-    0x4ebb6f59,     0x2e276cc5,     0x6e236c41,     0x2e796f17,\n-    0x6e726e30,     0x2ea16c1f,     0x6ea76cc5,     0x0e2eadac,\n-    0x4e2bad49,     0x0e7eafbc,     0x4e71ae0f,     0x0ebfafdd,\n-    0x4eb8aef6,     0x0e61b41f,     0x4e75b693,     0x0ea1b41f,\n-    0x4ea7b4c5,     0x0e3025ee,     0x4e342672,     0x0e61241f,\n-    0x4e742672,     0x0ebd279b,     0x4eb626b4,     0x0eb2f630,\n-    0x4eaef5ac,     0x4eedf58b,     0x2eabed49,     0x6ea8ece6,\n-    0x6ee0effe,     0x0faf11cd,     0x4fa1880f,     0x4fc710c5,\n-    0x0fa750c5,     0x4f8e81ac,     0x4fca5928,     0x2fa39041,\n-    0x4fa98907,     0x6fcb9949,     0x0f6d818b,     0x4f498107,\n-    0x0f8880e6,     0x4f8788c5,     0x0e2f35cd,     0x4e393717,\n-    0x0e633441,     0x4e6037fe,     0x0eb53693,     0x4ea734c5,\n-    0x4ef33651,     0x0e243c62,     0x4e323e30,     0x0e783ef6,\n-    0x4e6f3dcd,     0x0eac3d6a,     0x4eb73ed5,     0x4eff3fdd,\n-    0x2e3d8f9b,     0x6e2e8dac,     0x2e7d8f9b,     0x6e658c83,\n-    0x2ea38c41,     0x6ea18c1f,     0x6efa8f38,     0x2e353693,\n-    0x6e333651,     0x2e6b3549,     0x6e7e37bc,     0x2ebd379b,\n-    0x6eb1360f,     0x6ee93507,     0x2e373ed5,     0x6e393f17,\n-    0x2e613c1f,     0x6e7b3f59,     0x2ea43c62,     0x6ea13c1f,\n-    0x6efd3f9b,     0x0e34e672,     0x4e2ce56a,     0x4e79e717,\n-    0x2eb5e693,     0x6ea5e483,     0x6ef4e672,     0x2e22e420,\n-    0x6e3be759,     0x6e7ce77a,     0x65d22c4b,     0x65d03f92,\n-    0x65902b68,     0x6591264e,     0x659135f3,     0x65d33444,\n-    0x25c180af,     0x25cc0897,     0x25c71b6b,     0x25103080,\n-    0x251729f2,     0x25c48552,     0x24288aab,     0x242213f8,\n-    0x24fb63d6,     0x247cafab,     0xba5fd3e3,     0x3a5f03e5,\n+    0x0ef8f841,     0x4ef8f820,     0x2ea0fb38,     0x6ea0f8a4,\n+    0x6ee0f883,     0x2ef8f9ac,     0x6ef8f81f,     0x2ea1fbbc,\n+    0x6ea1f96a,     0x6ee1fb7a,     0x2ef9f862,     0x6ef9f9ac,\n+    0x2e205a72,     0x6e20581f,     0x0e231c41,     0x4e2f1dcd,\n+    0x0ebf1fdd,     0x4ea21c20,     0x2e351e93,     0x6e2e1dac,\n+    0x0e338651,     0x4e3886f6,     0x0e6f85cd,     0x4e7e87bc,\n+    0x0ea087fe,     0x4ea1841f,     0x4ee38441,     0x0e3c0f7a,\n+    0x4e3e0fbc,     0x0e660ca4,     0x4e600ffe,     0x0ea60ca4,\n+    0x4ea80ce6,     0x4ee00ffe,     0x2e3c0f7a,     0x6e340e72,\n+    0x2e6b0d49,     0x6e6a0d28,     0x2eae0dac,     0x6ea20c20,\n+    0x6ef60eb4,     0x0e23d441,     0x4e3ad738,     0x4e64d462,\n+    0x0e421420,     0x4e4b1549,     0x2e3a8738,     0x6e3c877a,\n+    0x2e728630,     0x6e6087fe,     0x2ea58483,     0x6eac856a,\n+    0x6ef98717,     0x0e2c2d6a,     0x4e262ca4,     0x0e742e72,\n+    0x4e642c62,     0x0ead2d8b,     0x4eaa2d28,     0x4eec2d6a,\n+    0x2e312e0f,     0x6e332e51,     0x2e642c62,     0x6e6c2d6a,\n+    0x2eae2dac,     0x6eae2dac,     0x6ef12e0f,     0x0eafd5cd,\n+    0x4ea4d462,     0x4ee9d507,     0x0ed616b4,     0x4edc177a,\n+    0x0e329e30,     0x4e269ca4,     0x0e649c62,     0x4e669ca4,\n+    0x0eae9dac,     0x4eb49e72,     0x2eb7d6d5,     0x6eb2d630,\n+    0x6ef4d672,     0x2ecd158b,     0x6ed716d5,     0x2e39d717,\n+    0x6e2ed5ac,     0x6e7cd77a,     0x2e591717,     0x6e5e17bc,\n+    0x2e30ddee,     0x6e2ddd8b,     0x6e7adf38,     0x2e431c41,\n+    0x6e4e1dac,     0x0e61941f,     0x4e6c956a,     0x0eb29630,\n+    0x4ea99507,     0x0e24cc62,     0x4e25cc83,     0x4e6fcdcd,\n+    0x0e550e93,     0x4e530e51,     0x2e729630,     0x6e659483,\n+    0x2ea39441,     0x6ead958b,     0x0ea0cffe,     0x4ea7ccc5,\n+    0x4eeacd28,     0x0ed10e0f,     0x4edf0fdd,     0x2e20fffe,\n+    0x6e22fc20,     0x6e76feb4,     0x2e493d07,     0x6e563eb4,\n+    0x0e396717,     0x4e3e67bc,     0x0e7766d5,     0x4e7d679b,\n+    0x0ebb6759,     0x4ea764c5,     0x2e236441,     0x6e396717,\n+    0x2e726630,     0x6e61641f,     0x2ea764c5,     0x6eae65ac,\n+    0x0e2ba549,     0x4e3ea7bc,     0x0e71a60f,     0x4e7fa7dd,\n+    0x0eb8a6f6,     0x4ea1a41f,     0x0e35f693,     0x4e21f41f,\n+    0x4e67f4c5,     0x0e5035ee,     0x4e543672,     0x0e216c1f,\n+    0x4e346e72,     0x0e7d6f9b,     0x4e766eb4,     0x0eb26e30,\n+    0x4eae6dac,     0x2e2d6d8b,     0x6e2b6d49,     0x2e686ce6,\n+    0x6e606ffe,     0x2eb36e51,     0x6ebd6f9b,     0x0e3eafbc,\n+    0x4e20affe,     0x0e69ad07,     0x4e6cad6a,     0x0eb6aeb4,\n+    0x4eacad6a,     0x0e66b4a4,     0x4e7ab738,     0x0eb3b651,\n+    0x4eb3b651,     0x0e3826f6,     0x4e252483,     0x0e7f27dd,\n+    0x4e71260f,     0x0eb826f6,     0x4eb52693,     0x0eb5f693,\n+    0x4eb8f6f6,     0x4ee4f462,     0x0ed1360f,     0x4ec834e6,\n+    0x2eaeedac,     0x6eb2ee30,     0x6eeded8b,     0x2ecf2dcd,\n+    0x6ed92f17,     0x0f81100f,     0x4f848862,     0x4fc31841,\n+    0x0fad518b,     0x4fa780c5,     0x4fd059ee,     0x2fa890e6,\n+    0x4fa38841,     0x6fc1900f,     0x0f7b8149,     0x4f4688a4,\n+    0x0faf81cd,     0x4fa58083,     0x0e3736d5,     0x4e393717,\n+    0x0e61341f,     0x4e7b3759,     0x0ea43462,     0x4ea1341f,\n+    0x4efd379b,     0x0e343e72,     0x4e2c3d6a,     0x0e793f17,\n+    0x4e753e93,     0x0ea53c83,     0x4eb43e72,     0x4ee23c20,\n+    0x2e3b8f59,     0x6e3c8f7a,     0x2e798f17,     0x6e648c62,\n+    0x2eb48e72,     0x6eae8dac,     0x6ee68ca4,     0x2e3e37bc,\n+    0x6e2037fe,     0x2e7f37dd,     0x6e723630,     0x2ebd379b,\n+    0x6ea834e6,     0x6eeb3549,     0x2e3f3fdd,     0x6e343e72,\n+    0x2e693d07,     0x6e663ca4,     0x2ea93d07,     0x6eb13e0f,\n+    0x6eeb3d49,     0x0e39e717,     0x4e2ae528,     0x4e64e462,\n+    0x2ebee7bc,     0x6eb7e6d5,     0x6ee1e41f,     0x2e27e4c5,\n+    0x6e3de79b,     0x6e62e420,     0x659239e8,     0x65d03b94,\n+    0x65d0232d,     0x65d120c2,     0x659129f2,     0x65933ca3,\n+    0x25969683,     0x25961d15,     0x254d1c48,     0x259e3f61,\n+    0x25953b96,     0x255b91d1,     0x247686ed,     0x24309098,\n+    0x2462edb9,     0x24a57468,     0xba5fd3e3,     0x3a5f03e5,\n@@ -1593,105 +1634,107 @@\n-    0x0ea1b820,     0x4e21c862,     0x4e61b8a4,     0x05a08020,\n-    0x05104fe0,     0x05505001,     0x05906fe2,     0x05d03005,\n-    0x05101fea,     0x05901feb,     0x04b0e3e0,     0x0470e7e1,\n-    0x042f9c20,     0x043f9c35,     0x047f9c20,     0x04ff9c20,\n-    0x04299420,     0x04319160,     0x0461943e,     0x04a19020,\n-    0x04038100,     0x040381a0,     0x040387e1,     0x04438be2,\n-    0x04c38fe3,     0x040181e0,     0x04018100,     0x04018621,\n-    0x04418b22,     0x04418822,     0x04818c23,     0x040081e0,\n-    0x04008120,     0x04008761,     0x04008621,     0x04408822,\n-    0x04808c23,     0x042053ff,     0x047f5401,     0x25208028,\n-    0x2538cfe0,     0x2578d001,     0x25b8efe2,     0x25f8f007,\n-    0x2538dfea,     0x25b8dfeb,     0xa400a3e0,     0xa420a7e0,\n-    0xa4484be0,     0xa467afe0,     0xa4a8a7ea,     0xa547a814,\n-    0xa4084ffe,     0xa55c53e0,     0xa5e1540b,     0xe400fbf6,\n-    0xe408ffff,     0xe420e7e0,     0xe4484be0,     0xe460efe0,\n-    0xe547e400,     0xe4014be0,     0xe4a84fe0,     0xe5f15000,\n-    0x858043e0,     0x85a043ff,     0xe59f5d08,     0x0420e3e9,\n-    0x0460e3ea,     0x04a0e3eb,     0x04e0e3ec,     0x25104042,\n-    0x25104871,     0x25904861,     0x25904c92,     0x05344020,\n-    0x05744041,     0x05b44062,     0x05f44083,     0x252c8840,\n-    0x253c1420,     0x25681572,     0x25a21ce3,     0x25ea1e34,\n-    0x253c0421,     0x25680572,     0x25a20ce3,     0x25ea0e34,\n-    0x0522c020,     0x05e6c0a4,     0x2401a001,     0x2443a051,\n-    0x24858881,     0x24c78cd1,     0x24850891,     0x24c70cc1,\n-    0x250f9001,     0x25508051,     0x25802491,     0x25df28c1,\n-    0x25850c81,     0x251e10d1,     0x65816001,     0x65c36051,\n-    0x65854891,     0x65c74cc1,     0x05733820,     0x05b238a4,\n-    0x05f138e6,     0x0570396a,     0x65d0a001,     0x65d6a443,\n-    0x65d4a826,     0x6594ac26,     0x6554ac26,     0x6556ac26,\n-    0x6552ac26,     0x65cbac85,     0x65caac01,     0x6589ac85,\n-    0x6588ac01,     0x65c9ac85,     0x65c8ac01,     0x65dea833,\n-    0x659ca509,     0x65d8a801,     0x65dcac01,     0x655cb241,\n-    0x0520a1e0,     0x0521a601,     0x052281e0,     0x05238601,\n-    0x04a14026,     0x042244a6,     0x046344a6,     0x04a444a6,\n-    0x04e544a7,     0x0568aca7,     0x05b23230,     0x853040af,\n-    0xc5b040af,     0xe57080af,     0xe5b080af,     0x25034440,\n-    0x254054c4,     0x25034640,     0x25415a05,     0x25834440,\n-    0x25c54489,     0x250b5d3a,     0x2550dc20,     0x2518e3e1,\n-    0x2518e021,     0x2518e0a1,     0x2518e121,     0x2518e1a1,\n-    0x2558e3e2,     0x2558e042,     0x2558e0c2,     0x2558e142,\n-    0x2598e3e3,     0x2598e063,     0x2598e0e3,     0x2598e163,\n-    0x25d8e3e4,     0x25d8e084,     0x25d8e104,     0x25d8e184,\n-    0x2518e407,     0x05214800,     0x05614800,     0x05a14800,\n-    0x05e14800,     0x05214c00,     0x05614c00,     0x05a14c00,\n-    0x05e14c00,     0x05304001,     0x05314001,     0x05a18610,\n-    0x05e18610,     0x05271e11,     0x6545e891,     0x6585e891,\n-    0x65c5e891,     0x6545c891,     0x6585c891,     0x65c5c891,\n-    0x45b0c210,     0x45f1c231,     0x1e601000,     0x1e603000,\n-    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n-    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n-    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n-    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n-    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n-    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n-    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n-    0x1e7e1000,     0x1e7e3000,     0xf83180b8,     0xf822014e,\n-    0xf830136b,     0xf837208c,     0xf8363091,     0xf8215213,\n-    0xf83041cd,     0xf82c7222,     0xf82362f5,     0xf8a580e6,\n-    0xf8b3038d,     0xf8b110d0,     0xf8a2207d,     0xf8a431e6,\n-    0xf8b4518d,     0xf8b44328,     0xf8b47013,     0xf8ab60d8,\n-    0xf8f481df,     0xf8f00006,     0xf8e7126f,     0xf8fa2149,\n-    0xf8f732d5,     0xf8fc5062,     0xf8ef4293,     0xf8e773a4,\n-    0xf8e76120,     0xf87082f4,     0xf8640150,     0xf877132b,\n-    0xf866221f,     0xf86d3197,     0xf861512e,     0xf8754350,\n-    0xf86f7084,     0xf87060c8,     0xb83e83a4,     0xb831035d,\n-    0xb829104f,     0xb82b207d,     0xb8273361,     0xb83551d0,\n-    0xb82842d0,     0xb8397285,     0xb83562f0,     0xb8b0829e,\n-    0xb8b40080,     0xb8b31098,     0xb8b42304,     0xb8ba3053,\n-    0xb8a851c8,     0xb8b843f0,     0xb8b673e4,     0xb8a1628a,\n-    0xb8ec8120,     0xb8e701f8,     0xb8e410db,     0xb8ea231b,\n-    0xb8ed33f0,     0xb8f65296,     0xb8ff413d,     0xb8ee70f4,\n-    0xb8f4613c,     0xb86b818e,     0xb8740301,     0xb86911b3,\n-    0xb8732210,     0xb8653060,     0xb86c51e8,     0xb86f4090,\n-    0xb86f70be,     0xb86062ca,     0xce20247b,     0xce0a63b3,\n-    0xce678e84,     0xce8eafb8,     0xce6d836b,     0xce7187f2,\n-    0xcec0806e,     0xce768a1e,     0x2520d474,     0x2521dae3,\n-    0x05800d33,     0x05403635,     0x05004cb8,     0x2560d175,\n-    0x2561c35e,     0x05809863,     0x054030f8,     0x05000ed7,\n-    0x2520c84e,     0x2521d69a,     0x05809892,     0x05408909,\n-    0x05000d2c,     0x2560d9cb,     0x25e1d352,     0x05806b49,\n-    0x0542d157,     0x050026a8,     0x2520cf2a,     0x25a1d599,\n-    0x05801ec0,     0x05422dc5,     0x05000e11,     0x2560c07e,\n-    0x2521dfb2,     0x0580ab15,     0x0540040c,     0x0500000f,\n-    0x04fb0353,     0x043606cd,     0x65940161,     0x65980b14,\n-    0x65d4063f,     0x04751095,     0x04ff1ade,     0x0473165a,\n-    0x04bd1dab,     0x0456a1c5,     0x04400542,     0x045a0753,\n-    0x041083c2,     0x04db0694,     0x0459adbd,     0x045abc2e,\n-    0x04d9007c,     0x04139929,     0x041189da,     0x04d018f4,\n-    0x04d7b0d4,     0x045ea3ad,     0x04180029,     0x052799fb,\n-    0x05e49e24,     0x04080302,     0x040a1dba,     0x04c90e16,\n-    0x04cb0571,     0x04010210,     0x04dca6fc,     0x65c0915c,\n-    0x65cd9cf1,     0x65868f04,     0x65878969,     0x65c296c4,\n-    0x049da1e4,     0x65c2bf44,     0x6580b745,     0x6581a33f,\n-    0x65cda468,     0x65c19b07,     0x65a19e38,     0x65e81dac,\n-    0x65f723fd,     0x65e7a2b4,     0x65e8dadd,     0x65e6f4ba,\n-    0x65b54f52,     0x65bc7140,     0x04d447d1,     0x048e6e3c,\n-    0x042b334a,     0x04af3160,     0x047432f7,     0x04fd3297,\n-    0x05a66b60,     0x05646d8d,     0x65c89aff,     0x45ddb046,\n-    0x4517b7a0,     0x04253904,     0x445891ad,     0x445a8908,\n-    0x449983b3,     0x44db8ef0,     0x041a3db7,     0x04583419,\n-    0x04593d79,     0x044836ce,     0x044a3005,     0x65c72069,\n-    0x658627ae,     0x65d8348e,     0x04812edb,     0x0e21101f,\n-    0x4e3a1338,     0x0e6d118b,     0x4e721230,     0x0eae11ac,\n-    0x4eb31251,     0x2e3e13bc,     0x6e251083,     0x2e7e13bc,\n-    0x6e721230,     0x2ea610a4,     0x6ebf13dd,\n+    0x0ea1b820,     0x0ef9b820,     0x4ef9b820,     0x4e21c862,\n+    0x0e79c862,     0x4e79c862,     0x4e61b8a4,     0x0e79b8a4,\n+    0x4e79b8a4,     0x05a08020,     0x05104fe0,     0x05505001,\n+    0x05906fe2,     0x05d03005,     0x05101fea,     0x05901feb,\n+    0x04b0e3e0,     0x0470e7e1,     0x042f9c20,     0x043f9c35,\n+    0x047f9c20,     0x04ff9c20,     0x04299420,     0x04319160,\n+    0x0461943e,     0x04a19020,     0x04038100,     0x040381a0,\n+    0x040387e1,     0x04438be2,     0x04c38fe3,     0x040181e0,\n+    0x04018100,     0x04018621,     0x04418b22,     0x04418822,\n+    0x04818c23,     0x040081e0,     0x04008120,     0x04008761,\n+    0x04008621,     0x04408822,     0x04808c23,     0x042053ff,\n+    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,\n+    0x25b8efe2,     0x25f8f007,     0x2538dfea,     0x25b8dfeb,\n+    0xa400a3e0,     0xa420a7e0,     0xa4484be0,     0xa467afe0,\n+    0xa4a8a7ea,     0xa547a814,     0xa4084ffe,     0xa55c53e0,\n+    0xa5e1540b,     0xe400fbf6,     0xe408ffff,     0xe420e7e0,\n+    0xe4484be0,     0xe460efe0,     0xe547e400,     0xe4014be0,\n+    0xe4a84fe0,     0xe5f15000,     0x858043e0,     0x85a043ff,\n+    0xe59f5d08,     0x0420e3e9,     0x0460e3ea,     0x04a0e3eb,\n+    0x04e0e3ec,     0x25104042,     0x25104871,     0x25904861,\n+    0x25904c92,     0x05344020,     0x05744041,     0x05b44062,\n+    0x05f44083,     0x252c8840,     0x253c1420,     0x25681572,\n+    0x25a21ce3,     0x25ea1e34,     0x253c0421,     0x25680572,\n+    0x25a20ce3,     0x25ea0e34,     0x0522c020,     0x05e6c0a4,\n+    0x2401a001,     0x2443a051,     0x24858881,     0x24c78cd1,\n+    0x24850891,     0x24c70cc1,     0x250f9001,     0x25508051,\n+    0x25802491,     0x25df28c1,     0x25850c81,     0x251e10d1,\n+    0x65816001,     0x65c36051,     0x65854891,     0x65c74cc1,\n+    0x05733820,     0x05b238a4,     0x05f138e6,     0x0570396a,\n+    0x65d0a001,     0x65d6a443,     0x65d4a826,     0x6594ac26,\n+    0x6554ac26,     0x6556ac26,     0x6552ac26,     0x65cbac85,\n+    0x65caac01,     0x6589ac85,     0x6588ac01,     0x65c9ac85,\n+    0x65c8ac01,     0x65dea833,     0x659ca509,     0x65d8a801,\n+    0x65dcac01,     0x655cb241,     0x0520a1e0,     0x0521a601,\n+    0x052281e0,     0x05238601,     0x04a14026,     0x042244a6,\n+    0x046344a6,     0x04a444a6,     0x04e544a7,     0x0568aca7,\n+    0x05b23230,     0x853040af,     0xc5b040af,     0xe57080af,\n+    0xe5b080af,     0x25034440,     0x254054c4,     0x25034640,\n+    0x25415a05,     0x25834440,     0x25c54489,     0x250b5d3a,\n+    0x2550dc20,     0x2518e3e1,     0x2518e021,     0x2518e0a1,\n+    0x2518e121,     0x2518e1a1,     0x2558e3e2,     0x2558e042,\n+    0x2558e0c2,     0x2558e142,     0x2598e3e3,     0x2598e063,\n+    0x2598e0e3,     0x2598e163,     0x25d8e3e4,     0x25d8e084,\n+    0x25d8e104,     0x25d8e184,     0x2518e407,     0x05214800,\n+    0x05614800,     0x05a14800,     0x05e14800,     0x05214c00,\n+    0x05614c00,     0x05a14c00,     0x05e14c00,     0x05304001,\n+    0x05314001,     0x05a18610,     0x05e18610,     0x05271e11,\n+    0x6545e891,     0x6585e891,     0x65c5e891,     0x6545c891,\n+    0x6585c891,     0x65c5c891,     0x45b0c210,     0x45f1c231,\n+    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n+    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n+    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n+    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n+    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n+    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n+    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n+    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n+    0xf8268267,     0xf82d023c,     0xf8301046,     0xf83d2083,\n+    0xf8263290,     0xf82d528c,     0xf8284299,     0xf8337160,\n+    0xf8386286,     0xf8bf820e,     0xf8a600e0,     0xf8af1353,\n+    0xf8a922ea,     0xf8b53396,     0xf8a251e3,     0xf8b340f4,\n+    0xf8a470fd,     0xf8a06209,     0xf8f48097,     0xf8f002ea,\n+    0xf8eb10d9,     0xf8ff21b0,     0xf8f7302c,     0xf8ee52a9,\n+    0xf8f041fa,     0xf8e471e4,     0xf8e863c6,     0xf864823d,\n+    0xf87d013a,     0xf86f1162,     0xf87d20e3,     0xf86132bb,\n+    0xf870510e,     0xf8704336,     0xf86572b4,     0xf8706217,\n+    0xb83e8294,     0xb8200264,     0xb8381284,     0xb8242358,\n+    0xb8333102,     0xb828530e,     0xb83042df,     0xb824703f,\n+    0xb82a6194,     0xb8a080e9,     0xb8b80090,     0xb8bb1146,\n+    0xb8bb21b8,     0xb8b032df,     0xb8b653f4,     0xb8bd41c9,\n+    0xb8b47287,     0xb8bc6169,     0xb8ee828c,     0xb8e10138,\n+    0xb8f3126d,     0xb8f020b0,     0xb8e03183,     0xb8e851ef,\n+    0xb8f041e4,     0xb8fe7005,     0xb8ea6376,     0xb8638120,\n+    0xb873015d,     0xb8781284,     0xb86723b8,     0xb86e3175,\n+    0xb87b51ed,     0xb87f41d1,     0xb863721e,     0xb87660f4,\n+    0xce216874,     0xce104533,     0xce648c15,     0xce8e3302,\n+    0xce6e82ab,     0xce6c87d1,     0xcec08063,     0xce638937,\n+    0x25e0c358,     0x25a1c7d3,     0x0580785a,     0x05426328,\n+    0x05009892,     0x25a0cc29,     0x2561cec8,     0x058044b3,\n+    0x05401c99,     0x05006b49,     0x25e0d6f7,     0x2561c528,\n+    0x0583c8bc,     0x0542522f,     0x05001ec0,     0x25e0de65,\n+    0x25a1c113,     0x05803cad,     0x0540f3c0,     0x0500ab15,\n+    0x2560c28c,     0x2561d7c0,     0x05801ed7,     0x0542633b,\n+    0x05003696,     0x2560d4b4,     0x25e1c918,     0x058021ff,\n+    0x05400e15,     0x0500f3de,     0x0473025a,     0x04bd05ab,\n+    0x658e0025,     0x658a08e2,     0x659a0493,     0x043e1062,\n+    0x04f418b4,     0x046d15bd,     0x04611fce,     0x04d6a07c,\n+    0x04001929,     0x041a09da,     0x04d098f4,     0x04db10d4,\n+    0x0459a3ad,     0x041aa029,     0x041919fb,     0x04d39e24,\n+    0x04118302,     0x04101dba,     0x04d7ae16,     0x04dea571,\n+    0x04180210,     0x05e786fc,     0x05e4915c,     0x04881cf1,\n+    0x044a0f04,     0x04090969,     0x048b16c4,     0x044101e4,\n+    0x04dcbf44,     0x65809745,     0x658d833f,     0x65c68468,\n+    0x65c79b07,     0x65829e38,     0x049dafca,     0x6582bba8,\n+    0x65c0b7ff,     0x65c1b4e0,     0x658dbadd,     0x65819a9d,\n+    0x65ed9246,     0x65b30815,     0x65e6263c,     0x65eebb94,\n+    0x65bad14e,     0x65efe178,     0x65fc5697,     0x65e07f14,\n+    0x040c55a6,     0x04977f4d,     0x043d3046,     0x04b733a0,\n+    0x046830a4,     0x04ed322d,     0x05686948,     0x05bd6c13,\n+    0x65c88ef0,     0x450db3d7,     0x4540b6d9,     0x043e3979,\n+    0x445896ce,     0x445a9005,     0x44d98069,     0x445b87ae,\n+    0x04da348e,     0x04982edb,     0x0499397f,     0x0408338c,\n+    0x04ca309c,     0x65c721e6,     0x65c63641,     0x65982882,\n+    0x04812b8b,     0x0e251083,     0x4e3712d5,     0x0e61101f,\n+    0x4e6d118b,     0x0eba1338,     0x4eb712d5,     0x2e31120f,\n+    0x6e2e11ac,     0x2e6810e6,     0x6e6f11cd,     0x2eaa1128,\n+    0x6eb1120f,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":637,"deletions":594,"binary":false,"changes":1231,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+  void verify_biased_index_inclusive_end(idx_t biased_index) const {\n+    guarantee(_biased_base != nullptr, \"Array not initialized\");\n+    guarantee(biased_index >= bias() && biased_index <= (bias() + length()),\n+              \"Biased index out of inclusive bounds, index: %zu bias: %zu length: %zu\",\n+              biased_index, bias(), length());\n+  }\n+\n@@ -32,0 +39,2 @@\n+\n+  \/\/ Returns the address of the element the given address maps to\n@@ -33,1 +42,3 @@\n-    return address_mapped_to(address);\n+    idx_t biased_index = ((uintptr_t)address) >> shift_by();\n+    verify_biased_index_inclusive_end(biased_index);\n+    return biased_base() + biased_index;\n@@ -35,0 +46,5 @@\n+\n+  int* base() const { return G1BiasedMappedArray<int>::base(); }\n+\n+  \/\/ The raw biased base pointer.\n+  int* biased_base() const { return G1BiasedMappedArray<int>::biased_base(); }\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1BiasedArray.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -45,1 +44,1 @@\n-#include <vector>\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n@@ -47,1 +46,3 @@\n-#include <map>\n+#include <string>\n+#include <vector>\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n@@ -71,1 +72,0 @@\n-    std::map<traceid, std::string> ids;\n","filename":"test\/hotspot\/gtest\/jfr\/test_networkUtilization.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,8 @@\n+# Need CDS archive\n+runtime\/cds\/NonJVMVariantLocation.java                        8357632 generic-all\n+runtime\/cds\/TestCDSVMCrash.java                               8357632 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_coh          8357632 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_nocoh        8357632 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_coh        8357632 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_nocoh      8357632 generic-all\n+serviceability\/jvmti\/RedefineClasses\/RedefineSharedClass.java 8357632 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-StaticJdk.txt","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -119,3 +119,0 @@\n-serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterObjectTest.java                8356372 generic-all\n-serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatObjectCorrectnessTest.java\t          8356372 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,0 +82,6 @@\n+# Valhalla\n+compiler\/regalloc\/TestVerifyRegisterAllocator.java 8365895 windows-x64\n+compiler\/startup\/StartupOutput.java 8365895 windows-x64\n+compiler\/types\/TestArrayManyDimensions.java 8365895 windows-x64\n+compiler\/types\/correctness\/OffTest.java 8365895 windows-x64\n+\n@@ -94,6 +100,0 @@\n-gc\/TestAlwaysPreTouchBehavior.java#ParallelCollector 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#SerialCollector 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Shenandoah 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#G1 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Z 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Epsilon 8334513 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *                   -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders -XX:-UseTLAB\n+ *                   -XX:+UseCompactObjectHeaders -XX:-UseTLAB\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyNoInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -51,1 +51,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -54,1 +54,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n@@ -57,1 +57,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2NotProcessedIGVN.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n@@ -50,1 +50,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+                                   \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n@@ -52,1 +52,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n@@ -54,1 +54,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+                                   \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -58,1 +58,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -61,1 +61,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n@@ -64,1 +64,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -49,1 +49,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-UseCompactObjectHeaders\",\n@@ -52,1 +52,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n@@ -55,1 +55,1 @@\n-                                   \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:+UseCompactObjectHeaders\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationNotRun.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -46,1 +46,1 @@\n-        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:CompileCommand=option,*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -54,1 +54,1 @@\n-        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,*.ccstrlist,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:CompileCommand=option,*.ccstrlist,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -60,1 +60,1 @@\n-        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,*.*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:CompileCommand=option,*.*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -65,1 +65,1 @@\n-        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,class,PrintIntrinsics\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:CompileCommand=option,class,PrintIntrinsics\", \"-version\")\n@@ -71,1 +71,1 @@\n-        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,class.PrintIntrinsics,PrintIntrinsics\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:CompileCommand=option,class.PrintIntrinsics,PrintIntrinsics\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/commands\/OptionTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8356989\n+ * @summary Unexpected null in C2 compiled code\n+ * @run main\/othervm -XX:-BackgroundCompilation TestArrayCopySameSrcDstInitializesNonEscapingArray\n+ * @run main TestArrayCopySameSrcDstInitializesNonEscapingArray\n+ *\/\n+\n+ public class TestArrayCopySameSrcDstInitializesNonEscapingArray {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        Object obj = new Object();\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(obj);\n+        }\n+    }\n+\n+    private static void test1(Object obj) {\n+        A a = new A();\n+        Object[] array = new Object[2];\n+        array[0] = obj;\n+        a.field = array;\n+        System.arraycopy(array, 0, array, 1, 1);\n+        if (a.field[1] == null) {\n+            throw new RuntimeException(\"Can't be null\");\n+        }\n+    }\n+\n+    private static class A {\n+        Object[] field;\n+\n+        public A() {\n+            field = null;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestArrayCopySameSrcDstInitializesNonEscapingArray.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+ *      -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bigInteger\/TestMultiplyToLen.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ *      -XX:+UnlockDiagnosticVMOptions\n@@ -41,0 +42,1 @@\n+ *      -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bigInteger\/TestShift.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ *      -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bigInteger\/TestSquareToLen.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n@@ -50,0 +51,1 @@\n+import jdk.vm.ci.hotspot.HotSpotProfilingInfo;\n@@ -206,0 +208,9 @@\n+\n+        \/\/ Basic test that the counters are non-negative\n+        HotSpotProfilingInfo hsInfo = (HotSpotProfilingInfo) info;\n+        int count = hsInfo.getDecompileCount();\n+        Assert.assertTrue(\"count = \" + count, count >= 0);\n+        count = hsInfo.getOverflowRecompileCount();\n+        Assert.assertTrue(\"count = \" + count, count >= 0);\n+        count = hsInfo.getOverflowTrapCount();\n+        Assert.assertTrue(\"count = \" + count, count >= 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/meta\/ProfilingInfoTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -117,5 +117,5 @@\n-            case \"NoAlignVector\"         -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"AlignVector\"           -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"VerifyAlignVector\"     -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n-            case \"NoAlignVector-COH\"     -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"VerifyAlignVector-COH\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            case \"NoAlignVector\"         -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"AlignVector\"           -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"VerifyAlignVector\"     -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n+            case \"NoAlignVector-COH\"     -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"VerifyAlignVector-COH\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyAlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8357530\n+ * @summary Test the effect of AutoVectorizationOverrideProfitability.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestAutoVectorizationOverrideProfitability\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import compiler.lib.generators.Generator;\n+import static compiler.lib.generators.Generators.G;\n+\n+public class TestAutoVectorizationOverrideProfitability {\n+    public static final Generator<Integer> GEN_I = G.ints();\n+    public static final Generator<Float>   GEN_F = G.floats();\n+\n+    public static int[] aI = new int[10_000];\n+    public static int[] rI = new int[10_000];\n+    public static float[] aF = new float[10_000];\n+    public static float[] rF = new float[10_000];\n+\n+    static {\n+        G.fill(GEN_I, aI);\n+        G.fill(GEN_F, aF);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Do not vectorize, even if profitable.\n+        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AutoVectorizationOverrideProfitability=0\");\n+\n+        \/\/ Normal run, i.e. with normal heuristic. In some cases this vectorizes, in some not.\n+        \/\/ By default, we have AutoVectorizationOverrideProfitability=1\n+        TestFramework.run();\n+\n+        \/\/ Vectorize even if not profitable.\n+        TestFramework.runWithFlags(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AutoVectorizationOverrideProfitability=2\");\n+    }\n+\n+    public static final float GOLD_SIMPLE_FLOAT_REDUCTION = simpleFloatReduction();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VF, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"< 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VF, \"= 0\"})\n+    \/\/ The simple float reduction is not profitable. We need to sequentially\n+    \/\/ add up the values, and so we cannot move the reduction out of the loop.\n+    private static float simpleFloatReduction() {\n+        float sum = 0;\n+        for (int i = 0; i < aF.length; i++) {\n+            sum += aF[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Check(test=\"simpleFloatReduction\")\n+    public static void checkSimpleFloatReduction(float result) {\n+        Verify.checkEQ(GOLD_SIMPLE_FLOAT_REDUCTION, result);\n+    }\n+\n+    static { simpleFloatCopy(); }\n+    public static final float[] GOLD_SIMPLE_FLOAT_COPY = rF.clone();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"},\n+        counts = {IRNode.LOAD_VECTOR_F, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"},\n+        counts = {IRNode.LOAD_VECTOR_F, \"= 0\"})\n+    \/\/ The simple float copy is always profitable.\n+    private static void simpleFloatCopy() {\n+        for (int i = 0; i < aF.length; i++) {\n+            rF[i] = aF[i];\n+        }\n+    }\n+\n+    @Check(test=\"simpleFloatCopy\")\n+    public static void checkSimpleFloatCopy() {\n+        Verify.checkEQ(GOLD_SIMPLE_FLOAT_COPY, rF);\n+    }\n+\n+    public static final int GOLD_SIMPLE_INT_REDUCTION = simpleIntReduction();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \"> 0\", IRNode.ADD_VI, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"< 2\"},\n+        counts = {IRNode.ADD_REDUCTION_VI, \"= 0\", IRNode.ADD_VI, \"= 0\"})\n+    \/\/ Current heuristics say that this simple int reduction is not profitable.\n+    \/\/ But it would actually be profitable, since we are able to move the\n+    \/\/ reduction out of the loop (we can reorder the reduction). When moving\n+    \/\/ the reduction out of the loop, we instead accumulate with a simple\n+    \/\/ ADD_VI inside the loop.\n+    \/\/ See: JDK-8307516 JDK-8345044\n+    private static int simpleIntReduction() {\n+        int sum = 0;\n+        for (int i = 0; i < aI.length; i++) {\n+            sum += aI[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Check(test=\"simpleIntReduction\")\n+    public static void checkSimpleIntReduction(int result) {\n+        Verify.checkEQ(GOLD_SIMPLE_INT_REDUCTION, result);\n+    }\n+\n+    static { simpleIntCopy(); }\n+    public static final int[] GOLD_SIMPLE_INT_COPY = rI.clone();\n+\n+    @Test\n+    @Warmup(10)\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"> 0\"},\n+        counts = {IRNode.LOAD_VECTOR_I, \"> 0\"})\n+    @IR(applyIfCPUFeatureOr = {\"avx\", \"true\"},\n+        applyIf = {\"AutoVectorizationOverrideProfitability\", \"= 0\"},\n+        counts = {IRNode.LOAD_VECTOR_I, \"= 0\"})\n+    \/\/ The simple int copy is always profitable.\n+    private static void simpleIntCopy() {\n+        for (int i = 0; i < aI.length; i++) {\n+            rI[i] = aI[i];\n+        }\n+    }\n+\n+    @Check(test=\"simpleIntCopy\")\n+    public static void checkSimpleIntCopy() {\n+        Verify.checkEQ(GOLD_SIMPLE_INT_COPY, rI);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAutoVectorizationOverrideProfitability.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -85,4 +85,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,4 +80,4 @@\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaers\");\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaers\");\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaers\");\n-        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:-UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:-UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:+UseCompactObjectHeaers\");\n+        TestFramework.runWithFlags(\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+UseCompactObjectHeaers\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,4 +64,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,4 +79,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,4 +42,4 @@\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\");\n+        TestFramework.runWithFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357105\n+ * @summary Test stacked string concatenations where the toString result\n+ *          of the first StringBuilder chain is wired into an uncommon trap\n+ *          located in the second one.\n+ * @run main\/othervm compiler.stringopts.TestStackedConcatsAppendUncommonTrap\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch\n+ *                   -XX:CompileOnly=compiler.stringopts.TestStackedConcatsAppendUncommonTrap::*\n+ *                   compiler.stringopts.TestStackedConcatsAppendUncommonTrap\n+ *\/\n+\n+package compiler.stringopts;\n+\n+public class TestStackedConcatsAppendUncommonTrap {\n+\n+    public static void main (String... args) {\n+        for (int i = 0; i < 10000; i++) {\n+            String s = f(\" \");\n+            if (!s.equals(\"    \")) {\n+                throw new RuntimeException(\"wrong result.\");\n+            }\n+        }\n+    }\n+\n+    static String f(String c) {\n+        String s = \" \";\n+        s = new StringBuilder().append(s).append(s).toString();\n+        s = new StringBuilder().append(s).append(s == c ? s : \"  \").toString();\n+        return s;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/stringopts\/TestStackedConcatsAppendUncommonTrap.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+        \/\/ Test with default MaxVectorSize\n@@ -54,0 +55,6 @@\n+\n+        \/\/ Test with different values of MaxVectorSize\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=8\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=16\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=32\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:MaxVectorSize=64\");\n@@ -79,1 +86,3 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n@@ -81,1 +90,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -100,1 +109,3 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n@@ -102,1 +113,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -121,1 +132,1 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n@@ -123,1 +134,3 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -142,1 +155,3 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n@@ -144,1 +159,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -163,1 +178,3 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n@@ -165,1 +182,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -184,1 +201,1 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n@@ -186,1 +203,3 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -205,1 +224,3 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n+    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n@@ -207,1 +228,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -226,1 +247,3 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n+    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n@@ -228,1 +251,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -249,1 +272,1 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n@@ -251,1 +274,3 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -273,1 +298,1 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n@@ -275,1 +300,3 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -296,1 +323,3 @@\n-    @Warmup(10000)\n+    @Warmup(50)\n+    @IR(counts = {IRNode.FMA_VHF, \" 0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n@@ -298,1 +327,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\"})\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":51,"deletions":22,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -53,4 +53,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,4 +56,4 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorZeroCount.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,4 +72,4 @@\n-            case \"nCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"nCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n-            case \"yCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"yCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"nCOH_nAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"nCOH_yAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"yCOH_nAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"yCOH_yAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,4 +70,4 @@\n-            case \"nCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"nCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n-            case \"yCOH_nAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n-            case \"yCOH_yAV\" -> new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"nCOH_nAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"nCOH_yAV\" -> new String[]{\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n+            case \"yCOH_nAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"};\n+            case \"yCOH_yAV\" -> new String[]{\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"};\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.test.lib.containers.docker.ContainerRuntimeVersionTestUtils;\n@@ -28,2 +29,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n@@ -47,1 +46,0 @@\n-\n@@ -73,0 +71,3 @@\n+\n+        ContainerRuntimeVersionTestUtils.checkContainerVersionSupported();\n+\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryWithSubgroups.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n- * Copyright (c) 2024, Red Hat Inc.\n+ * Copyright (c) 2024, 2025, Red Hat Inc.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +33,2 @@\n- * @requires os.family != \"aix\"\n+ * @requires !vm.debug\n+ * @requires os.family == \"linux\"\n@@ -36,1 +38,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx512m -Xms512m -XX:+UseParallelGC -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx256m -Xms256m -XX:+UseParallelGC -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n@@ -39,1 +41,1 @@\n- \/**\n+\/**\n@@ -44,1 +46,2 @@\n- * @requires os.family != \"aix\"\n+ * @requires !vm.debug\n+ * @requires os.family == \"linux\"\n@@ -48,1 +51,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx512m -Xms512m -XX:+UseSerialGC -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx256m -Xms256m -XX:+UseSerialGC -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n@@ -56,1 +59,2 @@\n- * @requires os.family != \"aix\"\n+ * @requires !vm.debug\n+ * @requires os.family == \"linux\"\n@@ -60,1 +64,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx512m -Xms512m -XX:+UseShenandoahGC  -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx256m -Xms256m -XX:+UseShenandoahGC  -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n@@ -68,1 +72,2 @@\n- * @requires os.family != \"aix\"\n+ * @requires !vm.debug\n+ * @requires os.family == \"linux\"\n@@ -72,1 +77,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx512m -Xms512m -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx256m -Xms256m -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n@@ -80,1 +85,2 @@\n- * @requires os.family != \"aix\"\n+ * @requires !vm.debug\n+ * @requires os.family == \"linux\"\n@@ -84,1 +90,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -Xmx512m -Xms512m -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -Xmx256m -Xms256m -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n@@ -92,1 +98,2 @@\n- * @requires os.family != \"aix\"\n+ * @requires !vm.debug\n+ * @requires os.family == \"linux\"\n@@ -96,1 +103,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xmx512m -Xms512m -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xmx256m -Xms256m -XX:+AlwaysPreTouch gc.TestAlwaysPreTouchBehavior\n@@ -99,1 +106,0 @@\n-\n@@ -103,0 +109,1 @@\n+import jtreg.SkippedException;\n@@ -105,0 +112,22 @@\n+    \/\/\n+    \/\/    This test tests the ability of the JVM to pretouch its java heap for test purposes (AlwaysPreTouch). We start a\n+    \/\/    JVM with -XX:+AlwaysPreTouch, then observe RSS and expect to see RSS covering the entirety of the java heap,\n+    \/\/    since it should all be pre-touched now.\n+    \/\/\n+    \/\/    This test is important (we had pretouching break before) but very shaky since RSS of the JVM process is subject to\n+    \/\/    host machine conditions. If there is memory pressure, we may swap parts of the heap out after pretouching and\n+    \/\/    before measuring RSS, thus tainting the result.\n+    \/\/\n+    \/\/    This test attempts to minimize the risk of false positives stemming from memory pressure by:\n+    \/\/    - specifying @requires os.maxMemory > 2G\n+    \/\/    - checking  if the memory still available on the host machine after starting the process is lower than a\n+    \/\/      certain required threshold; if it is, we take this as a sign of memory pressure and disregard test errors.\n+    \/\/    - we only run this test with release JVMs - debug JVMs have a higher and more unpredictable RSS footprint\n+    \/\/      and therefore would require a larger heap for a clear difference between non-pretouch and pretouch; also,\n+    \/\/      there should not be much difference between debug and release code.\n+    \/\/\n+    \/\/    Obviously, all of this is not bulletproof and only useful on Linux:\n+    \/\/    - On MacOS, os::available_memory() drastically underreports available memory, so this technique would almost\n+    \/\/      always fail to function\n+    \/\/    - On AIX, we dont have a way to measure rss yet.\n+    \/\/\n@@ -107,5 +136,24 @@\n-    long rss = WhiteBox.getWhiteBox().rss();\n-    System.out.println(\"RSS: \" + rss);\n-    if (rss == 0) {\n-        System.out.println(\"cannot get RSS, just skip\");\n-        return; \/\/ Did not get available RSS, just ignore this test.\n+        long rss = WhiteBox.getWhiteBox().rss();\n+        System.out.println(\"RSS: \" + rss);\n+        long available = WhiteBox.getWhiteBox().hostAvailableMemory();\n+        System.out.println(\"Host available memory: \" + available);\n+\n+        long heapSize = 256 * 1024 * 1024;\n+\n+        \/\/ On Linux, a JVM that runs with 256M pre-committed heap will use about 60MB (release JVM) RSS. Barring\n+        \/\/ memory pressure that causes us to lose RSS, pretouching should increase RSS to >256MB. So there should be a\n+        \/\/ clear distinction between non-pretouched and pretouched.\n+        long minRequiredRss = heapSize;\n+\n+        \/\/ The minimum required available memory size to count test errors as errors (to somewhat safely disregard\n+        \/\/ outside memory pressure as the culprit). We are over-cautious and require at least 1G free. We rather err\n+        \/\/ on the side of disregarding true errors than to produce false positives (if pretouching is broken, at least\n+        \/\/ some of the runs of this test will run on beefy enough machines and show the test as failed).\n+        long requiredAvailable = 1024 * 1024 * 1024;\n+        if (rss == 0) {\n+            throw new SkippedException(\"cannot get RSS?\");\n+        }\n+        if (available > requiredAvailable) {\n+            Asserts.assertGreaterThan(rss, minRequiredRss, \"RSS of this process(\" + rss + \"b) should be bigger \" +\n+                                      \"than or equal to heap size(\" + heapSize + \"b) (available memory: \" + available + \")\");\n+        }\n@@ -113,4 +161,0 @@\n-    Runtime runtime = Runtime.getRuntime();\n-    long committedMemory = runtime.totalMemory();\n-    Asserts.assertGreaterThan(rss, committedMemory, \"RSS of this process(\" + rss + \"b) should be bigger than or equal to committed heap mem(\" + committedMemory + \"b)\");\n-   }\n@@ -118,1 +162,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/TestAlwaysPreTouchBehavior.java","additions":68,"deletions":25,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -57,0 +57,5 @@\n+\n+    \/\/ Avoid issues with libjvmci failing to reserve\n+    \/\/ a large virtual address space for its heap\n+    args.add(\"-Xint\");\n+\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsFlagsWithUlimit.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.EXPERIMENTAL);\n+        testWith(\"-XX:ShenandoahGCMode=generational\", Mode.PRODUCT);\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestModeUnlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run main\/native GTestWrapper --gtest_filter=CompressedKlass* -XX:+UnlockExperimentalVMOptions -XX:-UseCompactObjectHeaders -Xlog:metaspace* -Xmx6g -Xms128m -Xshare:off -XX:CompressedClassSpaceSize=128m\n+ * @run main\/native GTestWrapper --gtest_filter=CompressedKlass* -XX:-UseCompactObjectHeaders -Xlog:metaspace* -Xmx6g -Xms128m -Xshare:off -XX:CompressedClassSpaceSize=128m\n@@ -52,1 +52,1 @@\n- * @run main\/native GTestWrapper --gtest_filter=CompressedKlass* -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders -Xlog:metaspace* -Xmx6g -Xms128m -Xshare:off -XX:CompressedClassSpaceSize=128m\n+ * @run main\/native GTestWrapper --gtest_filter=CompressedKlass* -XX:+UseCompactObjectHeaders -Xlog:metaspace* -Xmx6g -Xms128m -Xshare:off -XX:CompressedClassSpaceSize=128m\n@@ -59,1 +59,1 @@\n- * @run main\/native GTestWrapper --gtest_filter=CompressedKlass* -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders -Xlog:metaspace* -Xmx6g -Xms128m -Xshare:off -XX:CompressedClassSpaceSize=4g\n+ * @run main\/native GTestWrapper --gtest_filter=CompressedKlass* -XX:+UseCompactObjectHeaders -Xlog:metaspace* -Xmx6g -Xms128m -Xshare:off -XX:CompressedClassSpaceSize=4g\n","filename":"test\/hotspot\/jtreg\/gtest\/CompressedKlassGtest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n- * @run main\/native GTestWrapper --gtest_filter=metaspace* -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders\n+ * @run main\/native GTestWrapper --gtest_filter=metaspace* -XX:+UseCompactObjectHeaders\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceGtests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @requires ! vm.opt.final.UnlockExperimentalVMOptions\n+ * @requires !vm.opt.final.UnlockExperimentalVMOptions\n@@ -40,1 +40,1 @@\n- * @requires ! vm.debug\n+ * @requires !vm.debug\n@@ -47,0 +47,11 @@\n+\/* @test VMCompileCommandWarningDiagnostic\n+ * @bug 8351958\n+ * @summary Warn if compile command that is an alias for a diagnostic vm option is used and -XX:+UnlockDiagnosticVMOptions isn't specified.\n+ * @requires vm.flagless\n+ * @requires !vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver VMOptionWarning DiagnosticCompileCommand\n+ *\/\n+\n@@ -51,1 +62,1 @@\n- * @requires ! vm.debug\n+ * @requires !vm.debug\n@@ -85,0 +96,7 @@\n+            case \"DiagnosticCompileCommand\": {\n+                pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:CompileCommand=PrintAssembly,MyClass::myMethod\", \"-version\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldNotHaveExitValue(0);\n+                output.shouldContain(\"Error: VM option 'PrintAssembly' is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\");\n+                break;\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMOptionWarning.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\",\n+                \"-XX:-UseCompactObjectHeaders\",\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-            args.add(\"-XX:+UnlockExperimentalVMOptions\");\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AccessZeroNKlassHitsProtectionZone.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-            Pattern.compile(\"GC Heap History \\\\([0-9]* events\\\\):\"),\n+            Pattern.compile(\"GC Heap Usage History \\\\([0-9]* events\\\\):\"),\n+            Pattern.compile(\"Metaspace Usage History \\\\([0-9]* events\\\\):\"),\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ShowEventsOnCrashTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:-UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:+UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -52,1 +52,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -62,1 +62,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:-UseCompressedClassPointers -XX:-UseCompactObjectHeaders BaseOffsets\n@@ -72,1 +72,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:+UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n@@ -82,1 +82,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UnlockExperimentalVMOptions -XX:-UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops -XX:+UseCompactObjectHeaders BaseOffsets\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/BaseOffsets.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary JVM should be able to handle loading class via symlink on windows\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run testng\/othervm TestSymlinkLoad\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.SkipException;\n+import org.testng.annotations.Test;\n+\n+public class TestSymlinkLoad {\n+\n+    @Test\n+    public void testSymlinkClassLoading() throws Exception {\n+        Path sourceDir = Paths.get(System.getProperty(\"test.src\"), \"test-classes\");\n+\n+        String subPath = \"compiled\";\n+        Path destDir = Paths.get(System.getProperty(\"test.classes\"), subPath);\n+\n+        CompilerUtils.compile(sourceDir, destDir);\n+\n+        String bootCP = \"-Xbootclasspath\/a:\" + destDir.toString();\n+\n+        String className = \"Hello\";\n+\n+        \/\/ try to load a class itself directly, i.e. not via a symlink\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                bootCP, className);\n+\n+        \/\/ make sure it runs as expected\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Hello World\")\n+              .shouldHaveExitValue(0);\n+\n+        \/\/ create a symlink to the classfile in a subdir with a given name\n+        Path classFile = Path.of(destDir + File.separator + className + \".class\");\n+        final String subdir = \"remote\";\n+        final String pathToFolderForSymlink = destDir + File.separator + subdir + File.separator;\n+        createLinkInSeparateFolder(pathToFolderForSymlink, classFile, className);\n+\n+        \/\/ try to load class via its symlink, which is in a different directory\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                bootCP + File.separator + subdir, className);\n+        output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"Hello World\")\n+              .shouldHaveExitValue(0);\n+\n+        \/\/ remove the subdir\n+        FileUtils.deleteFileTreeWithRetry(Path.of(pathToFolderForSymlink));\n+    }\n+\n+    public static void createLinkInSeparateFolder(final String pathToFolderForSymlink, final Path target, final String className) throws IOException {\n+        File theDir = new File(pathToFolderForSymlink);\n+        if (!theDir.exists()) {\n+            theDir.mkdirs();\n+        }\n+        Path link = Paths.get(pathToFolderForSymlink, className + \".class\");\n+        if (Files.exists(link)) {\n+            Files.delete(link);\n+        }\n+        try {\n+            Files.createSymbolicLink(link, target);\n+        } catch (UnsupportedOperationException uoe) {\n+            throw new SkipException(\"Symbolic link creation not supported.\", uoe);\n+        } catch (IOException ioe) {\n+            throw new SkipException(\"Probably insufficient privileges to create symbolic links (Windows)\", ioe);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/TestSymlinkLoad.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -135,1 +135,0 @@\n-                \"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestDefaultArchiveLoading.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-                                        \"-XX:+UnlockExperimentalVMOptions\",\n@@ -62,1 +61,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n@@ -75,1 +73,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n@@ -89,1 +86,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n@@ -103,1 +99,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n@@ -116,1 +111,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n@@ -130,1 +124,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n@@ -145,1 +138,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n@@ -155,1 +147,0 @@\n-                         \"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestZGCWithCDS.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test how various AOT optimizations handle classes that are excluded from the AOT cache.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/test-classes\n+ * @build ExcludedClasses CustyWithLoop\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 TestApp\n+ *                 TestApp$Foo\n+ *                 TestApp$Foo$Bar\n+ *                 TestApp$Foo$ShouldBeExcluded\n+ *                 TestApp$MyInvocationHandler\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar\n+ *                 CustyWithLoop\n+ * @run driver ExcludedClasses\n+ *\/\n+\n+import java.io.File;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.security.ProtectionDomain;\n+import java.util.Map;\n+\n+import jdk.jfr.Event;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ExcludedClasses {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"TestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.runAOTWorkflow();\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:cds+resolve=trace\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass, runMode.name()\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            if (isDumping(runMode)) {\n+                out.shouldNotMatch(\"cds,resolve.*archived field.*TestApp.Foo => TestApp.Foo.ShouldBeExcluded.f:I\");\n+            }\n+        }\n+    }\n+}\n+\n+class TestApp {\n+    static volatile Object custInstance;\n+    static volatile Object custArrayInstance;\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ In new workflow, classes from custom loaders are passed from the preimage\n+        \/\/ to the final image. See ClassPrelinker::record_unregistered_klasses().\n+        custInstance = initFromCustomLoader();\n+        custArrayInstance = Array.newInstance(custInstance.getClass(), 0);\n+        System.out.println(custArrayInstance);\n+        System.out.println(\"Counter = \" + Foo.hotSpot());\n+    }\n+\n+    static Object initFromCustomLoader() throws Exception {\n+        String path = \"cust.jar\";\n+        URL url = new File(path).toURI().toURL();\n+        URL[] urls = new URL[] {url};\n+        URLClassLoader urlClassLoader =\n+            new URLClassLoader(\"MyLoader\", urls, null);\n+        Class c = Class.forName(\"CustyWithLoop\", true, urlClassLoader);\n+        return c.newInstance();\n+    }\n+\n+    static class MyInvocationHandler implements InvocationHandler {\n+        volatile static int cnt;\n+\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            long start = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - start < 20) {\n+                cnt += 2;\n+                for (int i = 0; i < 1000; i++) {\n+                    int n = cnt - 2;\n+                    if (n < 2) {\n+                        n = 2;\n+                    }\n+                    cnt += (i + cnt) % n + cnt % 2;\n+                }\n+            }\n+            return Integer.valueOf(cnt);\n+        }\n+    }\n+\n+    static class Foo {\n+        volatile static int counter;\n+        static Class c = ShouldBeExcluded.class;\n+\n+        static Map mapProxy = (Map) Proxy.newProxyInstance(\n+            Foo.class.getClassLoader(),\n+            new Class[] { Map.class },\n+            new MyInvocationHandler());\n+\n+        static int hotSpot() {\n+            ShouldBeExcluded s = new ShouldBeExcluded();\n+            Bar b = new Bar();\n+\n+            long start = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - start < 1000) {\n+                lambdaHotSpot();\n+                s.hotSpot2();\n+                b.hotSpot3();\n+\n+                \/\/ In JDK mainline, generated proxy classes are excluded from the AOT cache.\n+                \/\/ In Leyden\/premain, generated proxy classes included. The following code should\n+                \/\/ work with either repos.\n+                Integer i = (Integer)mapProxy.get(null);\n+                counter += i.intValue();\n+\n+                if (custInstance != null) {\n+                    \/\/ Classes loaded by custom loaders are included included in the AOT cache\n+                    \/\/ but their array classes are excluded.\n+                    counter += custInstance.equals(null) ? 1 : 2;\n+                }\n+\n+                if (custArrayInstance != null) {\n+                    if ((counter % 3) == 0) {\n+                        counter += (custArrayInstance instanceof String) ? 0 : 1;\n+                    } else {\n+                        counter += (custArrayInstance instanceof Object) ? 0 : 1;\n+                    }\n+                }\n+            }\n+\n+            return counter + s.m() + s.f + b.m() + b.f;\n+        }\n+\n+        static void f() {\n+            if (counter % 2 == 1) {\n+                counter ++;\n+            }\n+        }\n+\n+        \/\/ Generated Lambda classes should be excluded from CDS preimage.\n+        static void lambdaHotSpot() {\n+            long start = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - start < 20) {\n+                doit(() -> counter ++ );\n+            }\n+        }\n+\n+        static void doit(Runnable r) {\n+            r.run();\n+        }\n+\n+        \/\/ All subclasses of jdk.jfr.Event are excluded from the CDS archive.\n+        static class ShouldBeExcluded extends jdk.jfr.Event {\n+            int f = (int)(System.currentTimeMillis()) + 123;\n+            int m() {\n+                return f + 456;\n+            }\n+\n+            void hotSpot2() {\n+                long start = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - start < 20) {\n+                    for (int i = 0; i < 50000; i++) {\n+                        counter += i;\n+                    }\n+                    f();\n+                }\n+            }\n+        }\n+\n+        static class Bar {\n+            int f = (int)(System.currentTimeMillis()) + 123;\n+            int m() {\n+                return f + 456;\n+            }\n+\n+            void hotSpot3() {\n+                long start = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - start < 20) {\n+                    for (int i = 0; i < 50000; i++) {\n+                        counter += i;\n+                    }\n+                    f();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/ExcludedClasses.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ A class to be loaded by a custom class loader. It has a loop. AOT\n+\/\/ optimizations may be applied to this loop.\n+public class CustyWithLoop {\n+    volatile static int cnt;\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        long start = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - start < 20) {\n+            cnt += 2;\n+            for (int i = 0; i < 1000; i++) {\n+                int n = cnt - 2;\n+                if (n < 2) {\n+                    n = 2;\n+                }\n+                cnt += (i + cnt) % n + cnt % 2;\n+            }\n+        }\n+        return (cnt % 17) == 8;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/test-classes\/CustyWithLoop.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -53,1 +53,2 @@\n-        for (int mode = 0; mode < 3; mode++) {\n+        \/\/ Run only 2 modes (0 - no AOT code, 1 - AOT adapters) until JDK-8357398 is fixed\n+        for (int mode = 0; mode < 2; mode++) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-            \"-XX:+UnlockExperimentalVMOptions\",\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/JNIMonitor\/JNIMonitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,9 @@\n-        output.shouldContain(\"Metaspace\");\n+\n+        \/\/ All GCs have different strategies for printing similar information,\n+        \/\/ which makes it hard to grep for anything substantial. However, all\n+        \/\/ GCs print the string \"used\", so lets check for that to see if the\n+        \/\/ jcmd printed something at all.\n+        output.shouldContain(\"used\");\n+\n+        output.shouldNotContain(\"Unknown diagnostic command\");\n+        output.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/gc\/HeapInfoTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-        output.stdoutShouldMatch(buildHeaderPattern(\"GC Heap History\"));\n+        output.stdoutShouldMatch(buildHeaderPattern(\"GC Heap Usage History\"));\n+        output.stdoutShouldMatch(buildHeaderPattern(\"Metaspace Usage History\"));\n@@ -67,1 +68,2 @@\n-        output.stdoutShouldNotMatch(buildHeaderPattern(\"GC Heap History\"));\n+        output.stdoutShouldNotMatch(buildHeaderPattern(\"GC Heap Usage History\"));\n+        output.stdoutShouldNotMatch(buildHeaderPattern(\"Metaspace Usage History\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/EventsTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -280,0 +280,3 @@\n+    } else {\n+      System.out.println(\"OK difference percentage: \" + diffPercentage\n+          + \" due to the count being \" + actual + \" instead of \" + expected);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitor.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+                \"-Xint\", \/\/ Avoids issues with libjvmci failing to reserve\n+                         \/\/ a large virtual address space for its heap\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Allocate\/alloc001\/alloc001.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java 8341370 macosx-all\n@@ -587,0 +586,2 @@\n+java\/net\/CookieHandler\/B6644726.java                            8365811 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -408,1 +408,0 @@\n-    java\/foreign\/TestMatrix.java \\\n@@ -640,1 +639,0 @@\n-    jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java \\\n@@ -647,1 +645,2 @@\n-    javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataUtil.java \n+    javax\/xml\/jaxp\/datatype\/8033980\/GregorianCalAndDurSerDataUtil.java \\\n+    java\/util\/zip\/ZipFile\/CenSizeMaximum.java\n@@ -671,1 +670,3 @@\n-    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java \\\n+    java\/foreign\/TestMatrix.java \\\n+    java\/nio\/channels\/FileChannel\/BlockDeviceSize.java\n","filename":"test\/jdk\/TEST.groups","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.awt.image.BufferedImage;\n+import java.lang.reflect.InvocationTargetException;\n@@ -48,1 +50,1 @@\n-public class RootPaneDefaultButtonTest extends JDialog {\n+public class RootPaneDefaultButtonTest {\n@@ -50,2 +52,1 @@\n-    record ButtonRenderingExpectation(JButton button,\n-                                      boolean appearAsDefault) {}\n+    static class TestDialog extends JDialog {\n@@ -53,4 +54,8 @@\n-    public static void main(String[] args) throws Exception {\n-        if (!System.getProperty(\"os.name\").contains(\"OS X\")) {\n-            System.out.println(\"This test is for MacOS only.\");\n-            return;\n+        JButton button1 = new JButton(\"Button 1\");\n+        JButton button2 = new JButton(\"Button 2\");\n+\n+        TestDialog() {\n+            getContentPane().setLayout(new BorderLayout());\n+            getContentPane().add(createPushButtonRow(), BorderLayout.SOUTH);\n+            setUndecorated(true);\n+            pack();\n@@ -59,2 +64,8 @@\n-        RootPaneDefaultButtonTest window1 = new RootPaneDefaultButtonTest();\n-        RootPaneDefaultButtonTest window2 = new RootPaneDefaultButtonTest();\n+        private JPanel createPushButtonRow() {\n+            JPanel p = new JPanel(new GridLayout(1, 2));\n+            p.add(button1);\n+            p.add(button2);\n+            p.setBorder(new EmptyBorder(5,5,5,5));\n+            return p;\n+        }\n+    }\n@@ -62,4 +73,27 @@\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            @Override\n-            public void run() {\n-                Rectangle r1 = new Rectangle(0, 20,\n+    \/**\n+     * We want 2 dialogs: one in the foreground and one not in the foreground\n+     *\/\n+    static class TestScene {\n+        boolean isButton1Default, isButton2Default;\n+\n+        TestScene(boolean isButton1Default, boolean isButton2Default) {\n+            this.isButton1Default = isButton1Default;\n+            this.isButton2Default = isButton2Default;\n+        }\n+\n+        void run() throws Exception {\n+            SwingUtilities.invokeAndWait(() -> {\n+                System.out.println(\n+                        \"Testing isButton1Default = \" + isButton1Default +\n+                                \" isButton2Default = \" + isButton2Default);\n+                TestDialog window1 = new TestDialog();\n+                TestDialog window2 = new TestDialog();\n+\n+                if (isButton1Default) {\n+                    window1.getRootPane().setDefaultButton(window1.button1);\n+                }\n+                if (isButton2Default) {\n+                    window1.getRootPane().setDefaultButton(window1.button2);\n+                }\n+\n+                Rectangle r1 = new Rectangle(0, 100,\n@@ -69,1 +103,1 @@\n-                Rectangle r2 = new Rectangle((int) (r1.getMaxX() + 10), 20,\n+                Rectangle r2 = new Rectangle((int) (r1.getMaxX() + 10), 100,\n@@ -75,43 +109,0 @@\n-            }\n-        });\n-\n-        Robot robot = new Robot();\n-\n-        test(robot, window1.radioButton1,\n-                new ButtonRenderingExpectation(window1.button1, true),\n-                new ButtonRenderingExpectation(window1.button2, false),\n-                new ButtonRenderingExpectation(window2.button1, false),\n-                new ButtonRenderingExpectation(window2.button2, false));\n-\n-        test(robot, window1.radioButton2,\n-                new ButtonRenderingExpectation(window1.button1, false),\n-                new ButtonRenderingExpectation(window1.button2, true),\n-                new ButtonRenderingExpectation(window2.button1, false),\n-                new ButtonRenderingExpectation(window2.button2, false));\n-\n-        test(robot, window1.radioButton3,\n-                new ButtonRenderingExpectation(window1.button1, false),\n-                new ButtonRenderingExpectation(window1.button2, false),\n-                new ButtonRenderingExpectation(window2.button1, false),\n-                new ButtonRenderingExpectation(window2.button2, false));\n-\n-        test(robot, window2.radioButton1,\n-                new ButtonRenderingExpectation(window1.button1, false),\n-                new ButtonRenderingExpectation(window1.button2, false),\n-                new ButtonRenderingExpectation(window2.button1, true),\n-                new ButtonRenderingExpectation(window2.button2, false));\n-\n-        test(robot, window2.radioButton2,\n-                new ButtonRenderingExpectation(window1.button1, false),\n-                new ButtonRenderingExpectation(window1.button2, false),\n-                new ButtonRenderingExpectation(window2.button1, false),\n-                new ButtonRenderingExpectation(window2.button2, true));\n-\n-        test(robot, window2.radioButton3,\n-                new ButtonRenderingExpectation(window1.button1, false),\n-                new ButtonRenderingExpectation(window1.button2, false),\n-                new ButtonRenderingExpectation(window2.button1, false),\n-                new ButtonRenderingExpectation(window2.button2, false));\n-\n-        System.out.println(\"Test passed successfully\");\n-    }\n@@ -119,46 +110,69 @@\n-    private static void test(Robot robot, AbstractButton buttonToClick,\n-                             ButtonRenderingExpectation... expectations)\n-            throws Exception {\n-        robot.delay(100);\n-\n-        Point mouseLoc = buttonToClick.getLocationOnScreen();\n-        robot.mouseMove(mouseLoc.x + buttonToClick.getSize().width \/ 2,\n-                mouseLoc.y + buttonToClick.getSize().height \/ 2);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.delay(20);\n-        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-        robot.delay(100);\n-\n-        \/\/ the colors may change depending on your system's appearance.\n-        \/\/ Depending on how you've configured \"Appearance\" in the\n-        \/\/ System Settings app: the default button may be blue (the default),\n-        \/\/ red, purple, etc. So instead of checking for a specific color: we'll\n-        \/\/ make sure 3-4 are the same color, and one is significantly\n-        \/\/ different.\n-        Color defaultColor = null;\n-        Color nonDefaultColor = null;\n-\n-        for (ButtonRenderingExpectation expectation : expectations) {\n-            int x = expectation.button.getLocationOnScreen().x + 20;\n-            int y = expectation.button.getLocationOnScreen().y + 10;\n-\n-            \/\/ this mouseMove is optional, but it helps debug this test to see\n-            \/\/ where we're sampling the pixel color from:\n-            robot.mouseMove(x, y);\n-\n-            Color c = robot.getPixelColor(x, y);\n-            if (expectation.appearAsDefault) {\n-                if (defaultColor == null) {\n-                    defaultColor = c;\n-                } else {\n-                    throw new IllegalStateException(\n-                            \"there should only be at most 1 default button\");\n-                }\n-            } else {\n-                if (nonDefaultColor == null) {\n-                    nonDefaultColor = c;\n-                } else if (!isSimilar(nonDefaultColor, c)) {\n-                    throw new IllegalStateException(\n-                            \"these two colors should match: \" + c + \", \" +\n-                                    nonDefaultColor);\n+                Rectangle sum = new Rectangle();\n+                sum.add(r1);\n+                sum.add(r2);\n+                BufferedImage bi = new BufferedImage(sum.width, sum.height,\n+                        BufferedImage.TYPE_INT_ARGB);\n+                Graphics2D g = bi.createGraphics();\n+                window1.paint(g.create(r1.x, r1.y, r1.width, r1.height));\n+                window2.paint(g.create(r2.x, r2.y, r2.width, r2.height));\n+                g.dispose();\n+\n+                \/\/ the exact colors may change depending on your system's\n+                \/\/ appearance. Depending on how you've configured \"Appearance\"\n+                \/\/ in the System Settings app: the default button may be blue\n+                \/\/ (the default), red, purple, etc. So instead of checking for\n+                \/\/ a specific color: we'll make sure 3-4 are the same color,\n+                \/\/ and one is significantly different.\n+                Color defaultColor = null;\n+                Color nonDefaultColor = null;\n+\n+                JButton[] buttons = new JButton[] {window1.button1,\n+                        window1.button2, window2.button1, window2.button2};\n+\n+                try {\n+                    for (int a = 0; a < buttons.length; a++) {\n+                        try {\n+                            JButton b = buttons[a];\n+\n+                            Point p = b.getLocationOnScreen();\n+                            int x = p.x + 20;\n+                            int y = p.y + 10;\n+\n+                            Color c = new Color(bi.getRGB(x - sum.x, y - sum.y));\n+                            if (b.isDefaultButton()) {\n+                                if (defaultColor == null) {\n+                                    defaultColor = c;\n+                                } else {\n+                                    throw new IllegalStateException(\n+                                            \"there should only be at most 1 \" +\n+                                                    \"default button\");\n+                                }\n+                            } else {\n+                                if (nonDefaultColor == null) {\n+                                    nonDefaultColor = c;\n+                                } else if (!isSimilar(nonDefaultColor, c)) {\n+                                    throw new IllegalStateException(\n+                                            \"these two colors should match: \" + c +\n+                                                    \", \" + nonDefaultColor);\n+                                }\n+                            }\n+\n+                            if (defaultColor != null && nonDefaultColor != null &&\n+                                    isSimilar(defaultColor, nonDefaultColor)) {\n+                                throw new IllegalStateException(\n+                                        \"The default button and non-default \" +\n+                                                \"buttons should look \" +\n+                                                \"different: \" + defaultColor +\n+                                                \" matches \" + nonDefaultColor);\n+                            }\n+                        } catch(Exception e) {\n+                            System.err.println(\"a = \" + a);\n+                            throw e;\n+                        }\n+                    }\n+                } finally {\n+                    System.out.println(\"defaultColor = \" + defaultColor +\n+                            \" nonDefaultColor = \" + nonDefaultColor);\n+\n+                    window1.dispose();\n+                    window2.dispose();\n@@ -166,2 +180,0 @@\n-            }\n-        }\n@@ -169,5 +181,2 @@\n-        if (defaultColor != null && isSimilar(defaultColor, nonDefaultColor)) {\n-            throw new IllegalStateException(\n-                    \"The default button and non-default buttons should \" +\n-                            \"look different: \" + defaultColor + \" matches \" +\n-                            nonDefaultColor);\n+                System.out.println(\"Test passed successfully\\n\");\n+            });\n@@ -190,50 +199,5 @@\n-    JRadioButton radioButton1 = new JRadioButton(\n-            \"\\\"Button 1\\\" is the default button\");\n-    JRadioButton radioButton2 = new JRadioButton(\n-            \"\\\"Button 2\\\" is the default button\");\n-    JRadioButton radioButton3 = new JRadioButton(\"No default button\");\n-\n-    JButton button1 = new JButton(\"Button 1\");\n-    JButton button2 = new JButton(\"Button 2\");\n-\n-    public RootPaneDefaultButtonTest() {\n-        getContentPane().setLayout(new BorderLayout());\n-        getContentPane().add(createRadioButtonPanel(), BorderLayout.NORTH);\n-        getContentPane().add(createPushButtonRow(), BorderLayout.SOUTH);\n-        pack();\n-\n-        radioButton1.addActionListener(new ActionListener() {\n-            @Override\n-            public void actionPerformed(ActionEvent e) {\n-                getRootPane().setDefaultButton(button1);\n-            }\n-        });\n-\n-        radioButton2.addActionListener(new ActionListener() {\n-            @Override\n-            public void actionPerformed(ActionEvent e) {\n-                getRootPane().setDefaultButton(button2);\n-            }\n-        });\n-\n-        radioButton3.addActionListener(new ActionListener() {\n-            @Override\n-            public void actionPerformed(ActionEvent e) {\n-                getRootPane().setDefaultButton(null);\n-            }\n-        });\n-\n-        ButtonGroup g = new ButtonGroup();\n-        g.add(radioButton1);\n-        g.add(radioButton2);\n-        g.add(radioButton3);\n-        radioButton1.doClick();\n-    }\n-\n-    private JPanel createPushButtonRow() {\n-        JPanel p = new JPanel(new GridLayout(1, 2));\n-        p.add(button1);\n-        p.add(button2);\n-        p.setBorder(new EmptyBorder(5,5,5,5));\n-        return p;\n-    }\n+    public static void main(String[] args) throws Exception {\n+        if (!System.getProperty(\"os.name\").contains(\"OS X\")) {\n+            System.out.println(\"This test is for MacOS only.\");\n+            return;\n+        }\n@@ -241,7 +205,3 @@\n-    private JPanel createRadioButtonPanel() {\n-        JPanel p = new JPanel(new GridLayout(3, 1));\n-        p.add(radioButton1);\n-        p.add(radioButton2);\n-        p.add(radioButton3);\n-        p.setBorder(new EmptyBorder(5,5,5,5));\n-        return p;\n+        new TestScene(true, false).run();\n+        new TestScene(false, true).run();\n+        new TestScene(false, false).run();\n","filename":"test\/jdk\/com\/apple\/laf\/RootPane\/RootPaneDefaultButtonTest.java","additions":127,"deletions":167,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.awt.image.BufferedImage;\n@@ -45,1 +46,1 @@\n- * @run main\/othervm -Dsun.java2d.uiScale=1 ShapeNotSetSometimes\n+ * @run main\/othervm\/timeout=300 -Dsun.java2d.uiScale=1 ShapeNotSetSometimes\n@@ -150,0 +151,2 @@\n+        Rectangle screenBounds = window.getGraphicsConfiguration().getBounds();\n+        BufferedImage screenCapture = robot.createScreenCapture(screenBounds);\n@@ -151,1 +154,2 @@\n-            colorCheck(innerPoint.x, innerPoint.y, SHAPE_COLOR, true);\n+            colorCheck(innerPoint.x, innerPoint.y, SHAPE_COLOR,\n+                    true, screenCapture);\n@@ -154,1 +158,2 @@\n-                colorCheck(point.x, point.y, BACKGROUND_COLOR, true);\n+                colorCheck(point.x, point.y, BACKGROUND_COLOR,\n+                        true, screenCapture);\n@@ -158,1 +163,2 @@\n-                colorCheck(point.x, point.y, SHAPE_COLOR, false);\n+                colorCheck(point.x, point.y, SHAPE_COLOR,\n+                        false, screenCapture);\n@@ -172,1 +178,2 @@\n-    private void colorCheck(int x, int y, Color expectedColor, boolean mustBeExpectedColor) {\n+    private void colorCheck(int x, int y, Color expectedColor,\n+                            boolean mustBeExpectedColor, BufferedImage screenCapture) {\n@@ -176,5 +183,1 @@\n-        robot.mouseMove(screenX, screenY);\n-        robot.waitForIdle();\n-        robot.delay(50);\n-\n-        Color actualColor = robot.getPixelColor(screenX, screenY);\n+        Color actualColor = new Color(screenCapture.getRGB(screenX, screenY));\n","filename":"test\/jdk\/java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.awt.event.InputEvent;\n@@ -43,0 +42,3 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n@@ -45,1 +47,0 @@\n-    final MouseEnterExitListener mouseEnterExitListener = new MouseEnterExitListener();\n@@ -49,0 +50,7 @@\n+    private static final int X_OFFSET = 30;\n+    private static final int Y_OFFSET = 40;\n+    private static final int LATCH_TIMEOUT = 3;\n+\n+    private final CountDownLatch mouseEnterLatch = new CountDownLatch(1);\n+    private final CountDownLatch mouseExitLatch = new CountDownLatch(1);\n+\n@@ -60,1 +68,5 @@\n-                list.addMouseListener(mouseEnterExitListener);\n+                list.add(\"Item 3\");\n+                list.add(\"Item 4\");\n+                list.add(\"Item 5\");\n+                list.add(\"Item 6\");\n+                list.addMouseListener(new MouseEnterExitListener());\n@@ -69,1 +81,1 @@\n-            robot.delay(1000);\n+            robot.setAutoDelay(100);\n@@ -71,0 +83,1 @@\n+            robot.delay(1000);\n@@ -75,2 +88,1 @@\n-            robot.mouseMove(p.x + 10, p.y + 10);\n-            robot.delay(100);\n+            robot.mouseMove(p.x + X_OFFSET, p.y + Y_OFFSET);\n@@ -78,2 +90,2 @@\n-            robot.mouseMove(p.x - 10, p.y - 10);\n-            robot.delay(100);\n+\n+            robot.mouseMove(p.x - X_OFFSET, p.y + Y_OFFSET);\n@@ -81,1 +93,0 @@\n-            robot.mouseMove(p.x + 10, p.y + 10);\n@@ -83,2 +94,6 @@\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            robot.mouseMove(p.x + X_OFFSET, p.y + Y_OFFSET);\n+            robot.waitForIdle();\n+\n+            if (!mouseEnterLatch.await(LATCH_TIMEOUT, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Mouse enter event timeout\");\n+            }\n@@ -86,2 +101,2 @@\n-            synchronized (mouseEnterExitListener) {\n-                mouseEnterExitListener.wait(2000);\n+            if (!mouseExitLatch.await(LATCH_TIMEOUT, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Mouse exit event timeout\");\n@@ -96,5 +111,0 @@\n-        System.out.println(\"mouseEnterExitListener.isPassed() : \" + mouseEnterExitListener.isPassed());\n-        if (!mouseEnterExitListener.isPassed()) {\n-            throw new RuntimeException(\"Haven't receive mouse enter\/exit events\");\n-        }\n-\n@@ -103,21 +113,5 @@\n-}\n-\n-class MouseEnterExitListener extends MouseAdapter {\n-\n-    volatile boolean passed_1 = false;\n-    volatile boolean passed_2 = false;\n-\n-    public void mouseEntered(MouseEvent e) {\n-        passed_1 = true;\n-        System.out.println(\"passed_1 is: \" + passed_1);\n-    }\n-\n-    public void mouseExited(MouseEvent e) {\n-        passed_2 = true;\n-        System.out.println(\"passed_2 is: \" + passed_2);\n-    }\n-\n-    public void mousePressed(MouseEvent e) {\n-        synchronized (this) {\n-            System.out.println(\"mouse pressed\");\n-            this.notifyAll();\n+    private class MouseEnterExitListener extends MouseAdapter {\n+        @Override\n+        public void mouseEntered(MouseEvent e) {\n+            System.out.println(\"Mouse Entered Event\");\n+            mouseEnterLatch.countDown();\n@@ -125,1 +119,0 @@\n-    }\n@@ -127,2 +120,5 @@\n-    public boolean isPassed() {\n-        return passed_1 & passed_2;\n+        @Override\n+        public void mouseExited(MouseEvent e) {\n+            System.out.println(\"Mouse Exited Event\");\n+            mouseExitLatch.countDown();\n+        }\n","filename":"test\/jdk\/java\/awt\/List\/ListEnterExitTest.java","additions":38,"deletions":42,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,0 @@\n-import java.awt.Button;\n-import java.awt.Dimension;\n-import java.awt.Frame;\n@@ -29,1 +26,0 @@\n-import java.awt.Panel;\n@@ -34,0 +30,1 @@\n+import java.io.File;\n@@ -37,1 +34,3 @@\n-import javax.swing.JOptionPane;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+import javax.print.attribute.standard.Destination;\n@@ -42,1 +41,1 @@\n- * @summary Printer graphics must behave the same as screen graphics\n+ * @summary Printer graphics must throw expected exceptions\n@@ -44,3 +43,1 @@\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @run main\/manual PrintNullString\n+ * @run main PrintNullString\n@@ -48,10 +45,6 @@\n-public class PrintNullString extends Frame {\n-    private static final String INSTRUCTIONS =\n-            \"This test should print a page which contains the same\\n\" +\n-            \"text messages as in the test window on the screen.\\n\" +\n-            \"\\n\" +\n-            \"The messages should contain only 'OK' and 'expected' messages.\\n\" +\n-            \"Press Pass if it's the case; otherwise press Fail.\\n\" +\n-            \"\\n\" +\n-            \"If the page fails to print, but there were no exceptions\\n\" +\n-            \"then the problem is likely elsewhere (i.e. your printer)\";\n+public class PrintNullString implements Printable {\n+    private final String nullStr = null;\n+    private final String emptyStr = \"\";\n+    private final AttributedString emptyAttStr = new AttributedString(emptyStr);\n+    private final AttributedCharacterIterator nullIterator = null;\n+    private final AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n@@ -64,7 +57,1 @@\n-        PassFailJFrame.builder()\n-                .instructions(INSTRUCTIONS)\n-                .testUI(PrintNullString::new)\n-                .rows((int) INSTRUCTIONS.lines().count() + 1)\n-                .columns(45)\n-                .build()\n-                .awaitAndCheck();\n+        new PrintNullString();\n@@ -73,24 +60,8 @@\n-    public PrintNullString() {\n-        super(\"PrintNullString\");\n-\n-        TextCanvas c = new TextCanvas();\n-        add(\"Center\", c);\n-\n-        Button b = new Button(\"Print\");\n-        add(\"South\", b);\n-        b.addActionListener(e -> {\n-            PrinterJob pj = PrinterJob.getPrinterJob();\n-            if (pj.printDialog()) {\n-                pj.setPrintable(c);\n-                try {\n-                    pj.print();\n-                } catch (PrinterException ex) {\n-                    ex.printStackTrace();\n-                    String msg = \"PrinterException: \" + ex.getMessage();\n-                    JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n-                            JOptionPane.ERROR_MESSAGE);\n-                    PassFailJFrame.forceFail(msg);\n-                }\n-            }\n-        });\n-        pack();\n+    public PrintNullString() throws PrinterException {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n+        pj.setPrintable(this, new PageFormat());\n+        PrintRequestAttributeSet pSet = new HashPrintRequestAttributeSet();\n+        File file = new File(\"out.prn\");\n+        file.deleteOnExit();\n+        pSet.add(new Destination(file.toURI()));\n+        pj.print(pSet);\n@@ -99,11 +70,4 @@\n-    private static class TextCanvas extends Panel implements Printable {\n-        private final String nullStr = null;\n-        private final String emptyStr = \"\";\n-        private final AttributedString emptyAttStr = new AttributedString(emptyStr);\n-        private final AttributedCharacterIterator nullIterator = null;\n-        private final AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-        @Override\n-        public void paint(Graphics g) {\n-            Graphics2D g2d = (Graphics2D) g;\n-            paint(g2d);\n+    @Override\n+    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+        if (pgIndex > 0) {\n+            return NO_SUCH_PAGE;\n@@ -112,5 +76,2 @@\n-        @Override\n-        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-            if (pgIndex > 0) {\n-                return NO_SUCH_PAGE;\n-            }\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n@@ -118,3 +79,18 @@\n-            Graphics2D g2d = (Graphics2D) g;\n-            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-            paint(g2d);\n+        \/\/ API 1: null & empty drawString(String, int, int);\n+        try {\n+            g2d.drawString(nullStr, 20, 40);\n+            throw new RuntimeException(\"FAILURE: No NPE for null String, int\");\n+        } catch (NullPointerException e) {\n+            g2d.drawString(\"caught expected NPE for null String, int\", 20, 40);\n+        }\n+\n+        g2d.drawString(emptyStr, 20, 60);\n+        g2d.drawString(\"OK for empty String, int\", 20, 60);\n+\n+        \/\/ API 2: null & empty drawString(String, float, float);\n+        try {\n+            g2d.drawString(nullStr, 20.0f, 80.0f);\n+            throw new RuntimeException(\"FAILURE: No NPE for null String, float\");\n+        } catch (NullPointerException e) {\n+            g2d.drawString(\"caught expected NPE for null String, float\", 20, 80);\n+        }\n@@ -122,1 +98,16 @@\n-            return PAGE_EXISTS;\n+        g2d.drawString(emptyStr, 20.0f, 100.0f);\n+        g2d.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n+\n+        \/\/ API 3: null & empty drawString(Iterator, int, int);\n+        try {\n+            g2d.drawString(nullIterator, 20, 120);\n+            throw new RuntimeException(\"FAILURE: No NPE for null iterator, int\");\n+        } catch (NullPointerException e) {\n+            g2d.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n+        }\n+\n+        try {\n+            g2d.drawString(emptyIterator, 20, 140);\n+            throw new RuntimeException(\"FAILURE: No IAE for empty iterator, int\");\n+        } catch (IllegalArgumentException e) {\n+            g2d.drawString(\"caught expected IAE for empty iterator, int\", 20, 140);\n@@ -125,52 +116,6 @@\n-        private void paint(Graphics2D g2d) {\n-            \/\/ API 1: null & empty drawString(String, int, int);\n-            try {\n-                g2d.drawString(nullStr, 20, 40);\n-                g2d.drawString(\"FAILURE: No NPE for null String, int\", 20, 40);\n-            } catch (NullPointerException e) {\n-                g2d.drawString(\"caught expected NPE for null String, int\", 20, 40);\n-            }\n-\n-            g2d.drawString(emptyStr, 20, 60);\n-            g2d.drawString(\"OK for empty String, int\", 20, 60);\n-\n-            \/\/ API 2: null & empty drawString(String, float, float);\n-            try {\n-                g2d.drawString(nullStr, 20.0f, 80.0f);\n-                g2d.drawString(\"FAILURE: No NPE for null String, float\", 20, 80);\n-            } catch (NullPointerException e) {\n-                g2d.drawString(\"caught expected NPE for null String, float\", 20, 80);\n-            }\n-\n-            g2d.drawString(emptyStr, 20.0f, 100.0f);\n-            g2d.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n-\n-            \/\/ API 3: null & empty drawString(Iterator, int, int);\n-            try {\n-                g2d.drawString(nullIterator, 20, 120);\n-                g2d.drawString(\"FAILURE: No NPE for null iterator, int\", 20, 120);\n-            } catch (NullPointerException e) {\n-                g2d.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n-            }\n-\n-            try {\n-                g2d.drawString(emptyIterator, 20, 140);\n-                g2d.drawString(\"FAILURE: No IAE for empty iterator, int\", 20, 140);\n-            } catch (IllegalArgumentException e) {\n-                g2d.drawString(\"caught expected IAE for empty iterator, int\", 20, 140);\n-            }\n-\n-            \/\/ API 4: null & empty drawString(Iterator, float, int);\n-            try {\n-                g2d.drawString(nullIterator, 20.0f, 160.0f);\n-                g2d.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 160);\n-            } catch (NullPointerException e) {\n-                g2d.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n-            }\n-\n-            try {\n-                g2d.drawString(emptyIterator, 20.0f, 180.0f);\n-                g2d.drawString(\"FAILURE: No IAE for empty iterator, float\", 20, 180);\n-            } catch (IllegalArgumentException e) {\n-                g2d.drawString(\"caught expected IAE for empty iterator, float\", 20, 180);\n-            }\n+        \/\/ API 4: null & empty drawString(Iterator, float, int);\n+        try {\n+            g2d.drawString(nullIterator, 20.0f, 160.0f);\n+            throw new RuntimeException(\"FAILURE: No NPE for null iterator, float\");\n+        } catch (NullPointerException e) {\n+            g2d.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n@@ -179,3 +124,5 @@\n-        @Override\n-        public Dimension getPreferredSize() {\n-            return new Dimension(450, 250);\n+        try {\n+            g2d.drawString(emptyIterator, 20.0f, 180.0f);\n+            throw new RuntimeException(\"FAILURE: No IAE for empty iterator, float\");\n+        } catch (IllegalArgumentException e) {\n+            g2d.drawString(\"caught expected IAE for empty iterator, float\", 20, 180);\n@@ -183,0 +130,2 @@\n+\n+        return PAGE_EXISTS;\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintNullString.java","additions":75,"deletions":126,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm\/native\n+ * @run testng\/othervm\/native\/manual\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1500m Skynet\n+ * @run main\/othervm\/timeout=400 -Xmx1500m Skynet\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=400 -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -179,1 +179,4 @@\n-    private static final Duration TIMEOUT = Duration.of(2, ChronoUnit.SECONDS);\n+    \/\/ Adjust this timeout to fail faster for test stalls\n+    private static final Duration TIMEOUT = Duration.ofNanos((long) (\n+            Duration.of(1, ChronoUnit.MINUTES).toNanos()\n+                    * Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\"))));\n@@ -183,1 +186,1 @@\n-            if (!latch.await(2L, TimeUnit.SECONDS)) {\n+            if (!latch.await(TIMEOUT.toNanos(), TimeUnit.NANOSECONDS)) {\n@@ -212,1 +215,0 @@\n-    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n@@ -244,1 +246,0 @@\n-    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n@@ -266,1 +267,0 @@\n-    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n@@ -318,1 +318,4 @@\n-        if (!ForceGC.wait(() -> ref.refersTo(null))) {\n+        if (!ForceGC.wait(() -> {\n+            CV1.get(int.class); \/\/ flush the weak maps\n+            return ref.refersTo(null);\n+        })) {\n@@ -355,1 +358,0 @@\n-    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n@@ -401,1 +403,0 @@\n-    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n@@ -446,1 +447,0 @@\n-    @Timeout(value = 4, unit = TimeUnit.SECONDS)\n","filename":"test\/jdk\/java\/lang\/invoke\/ClassValueTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -77,0 +77,6 @@\n+    private void testPrimitiveType(Object target, Class<?> targetType, int start, int result, Object... labels) throws Throwable {\n+        MethodType switchType = MethodType.methodType(int.class, targetType, int.class);\n+        MethodHandle indy = ((CallSite) BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels)).dynamicInvoker();\n+        assertEquals((int) indy.invoke(target, start), result);\n+    }\n+\n@@ -135,0 +141,12 @@\n+    public void testPrimitiveTypes() throws Throwable {\n+        testPrimitiveType((short) 1, short.class, 0, 1, String.class);\n+        testPrimitiveType((byte) 1, byte.class,0, 1, String.class, byte.class);\n+        testPrimitiveType(true, boolean.class,0, 1, false, boolean.class);\n+        testPrimitiveType(1, int.class,0, 1, String.class);\n+        testPrimitiveType(1, int.class,0, 1, true);\n+        testPrimitiveType(true, boolean.class,0, 1, false);\n+        testPrimitiveType((byte) 1, byte.class,0, 1, boolean.class, byte.class);\n+        testPrimitiveType((byte) 1, byte.class,0, 1, Boolean.class, byte.class);\n+        testPrimitiveType(true, boolean.class,0, 1, String.class, boolean.class);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-\/**\n+\/*\n@@ -57,1 +57,0 @@\n- * -Djdk.tracePinnedThreads=full\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilterCacheTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- *      -Djdk.tracePinnedThreads=full\n","filename":"test\/jdk\/java\/net\/httpclient\/ConcurrentResponses.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,0 @@\n- *      -Djdk.tracePinnedThreads=full\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientLocalAddrTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,1 @@\n- * @run junit\/othervm -Djdk.tracePinnedThreads=full\n- *                   -DuseReferenceTracker=false\n+ * @run junit\/othervm -DuseReferenceTracker=false\n@@ -67,2 +66,1 @@\n- * @run junit\/othervm -Djdk.tracePinnedThreads=full\n- *                   -DuseReferenceTracker=true\n+ * @run junit\/othervm -DuseReferenceTracker=true\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpGetInCancelledFuture.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,8 +35,4 @@\n- * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n- *                              -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n- *                              -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n- *                              -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.tracePinnedThreads=full\n- *                              -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n- *                              -Djdk.tracePinnedThreads=full\n@@ -40,1 +39,0 @@\n- *                              -Djdk.tracePinnedThreads=full\n@@ -43,1 +41,0 @@\n- *                              -Djdk.tracePinnedThreads=full\n@@ -46,1 +43,0 @@\n- *                              -Djdk.tracePinnedThreads=full\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests2.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-\/**\n+\/*\n@@ -63,2 +63,1 @@\n- * @run main\/othervm -Djdk.tracePinnedThreads=full\n- *      -Djdk.httpclient.HttpClient.log=headers,requests,trace\n+ * @run main\/othervm -Djdk.httpclient.HttpClient.log=headers,requests,trace\n","filename":"test\/jdk\/java\/net\/httpclient\/PlainProxyConnectionTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -61,0 +62,1 @@\n+    \/\/ Must be indeterministic\n@@ -566,9 +568,10 @@\n-        boolean useDirect = rand.nextBoolean();\n-        if (useDirect) {\n-            ByteBuffer bb = ByteBuffer.allocateDirect(buf.length);\n-            bb.put(buf);\n-            bb.flip();\n-            return bb;\n-        } else {\n-            return ByteBuffer.wrap(buf);\n-        }\n+        return switch (rand.nextInt(3)) {\n+            case 0 -> ByteBuffer.allocateDirect(buf.length)\n+                    .put(buf)\n+                    .flip();\n+            case 1 -> ByteBuffer.wrap(buf);\n+            case 2 -> Arena.ofAuto().allocate(buf.length).asByteBuffer()\n+                    .put(buf)\n+                    .flip();\n+            default -> throw new InternalError(\"Should not reach here\");\n+        };\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousFileChannel\/Basic.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -49,1 +50,2 @@\n-    private static Random rand = new Random();\n+    \/\/ Must be indeterministic\n+    private static final Random rand = new Random();\n@@ -91,2 +93,6 @@\n-        ByteBuffer buf = rand.nextBoolean() ?\n-            ByteBuffer.allocate(100) : ByteBuffer.allocateDirect(100);\n+        final ByteBuffer buf = switch (rand.nextInt(3)) {\n+            case 0 -> ByteBuffer.allocate(100);\n+            case 1 -> ByteBuffer.allocateDirect(100);\n+            case 2 -> Arena.ofAuto().allocate(100).asByteBuffer();\n+            default -> throw new InternalError(\"Should not reach here\");\n+        };\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/UserDefinedFileAttributeView\/Basic.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -647,0 +647,18 @@\n+    \/**\n+     * schedule throws RejectedExecutionException if shutdown before\n+     * first delayed task is submitted\n+     *\/\n+    public void testInitialScheduleAfterShutdown() throws InterruptedException {\n+        Runnable r = new NoOpRunnable();\n+        boolean rje = false;\n+        try (final ForkJoinPool p = new ForkJoinPool(1)) {\n+            p.shutdown();\n+            assertTrue(p.awaitTermination(LONG_DELAY_MS, MILLISECONDS));\n+            try {\n+                p.schedule(r, 1, MILLISECONDS);\n+            } catch (RejectedExecutionException ok) {\n+                rje = true;\n+            }\n+        }\n+        assertTrue(rje);\n+    }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool20Test.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -703,0 +703,2 @@\n+        final int DELAY = 100;\n+\n@@ -705,3 +707,3 @@\n-            tasks.add(p.schedule(r, 9, SECONDS));\n-            tasks.add(p.scheduleAtFixedRate(r, 9, 9, SECONDS));\n-            tasks.add(p.scheduleWithFixedDelay(r, 9, 9, SECONDS));\n+            tasks.add(p.schedule(r, DELAY, SECONDS));\n+            tasks.add(p.scheduleAtFixedRate(r, DELAY, DELAY, SECONDS));\n+            tasks.add(p.scheduleWithFixedDelay(r, DELAY, DELAY, SECONDS));\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ScheduledExecutorTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-import java.util.ArrayList;\n@@ -25,1 +24,2 @@\n-import java.util.function.Predicate;\n+import java.util.Spliterator;\n+import java.util.function.Consumer;\n@@ -34,0 +34,1 @@\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -468,0 +469,35 @@\n+    @ParameterizedTest\n+    @ValueSource(booleans = { false, true })\n+    public void mustNotPropagateSizeInformation(boolean parallel) {\n+        \/\/ Constructs a spliterator of unbounded length but which\n+        \/\/ reports SIZED and SUBSIZED characteristics so if its size\n+        \/\/ of Long.MAX_VALUE gets propagated by gather() then the\n+        \/\/ resulting toList() call would allocate a huge array and as\n+        \/\/ such would yield an OutOfMemoryError\n+        var s = new Spliterator<Integer>() {\n+            @Override\n+            public boolean tryAdvance(Consumer<? super Integer> action) {\n+                action.accept(0);\n+                return true;\n+            }\n+\n+            @Override public Spliterator<Integer> trySplit() { return null; }\n+\n+            @Override public long estimateSize() { return Long.MAX_VALUE; }\n+\n+            @Override\n+            public int characteristics() {\n+                return Spliterator.SIZED | Spliterator.IMMUTABLE | Spliterator.SUBSIZED;\n+            }\n+        };\n+\n+        var result = StreamSupport.stream(s, parallel)\n+                                  .gather(\n+                                      Gatherer.of(\n+                                          (_, i, d)\n+                                              -> d.push(i) && false\n+                                      )\n+                                  ).toList();\n+        assertEquals(result, List.of(0));\n+    }\n+\n","filename":"test\/jdk\/java\/util\/stream\/GathererTest.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,1 @@\n-\/**\n- * Base class for Checksum tests\n- *\/\n+import java.lang.foreign.MemorySegment;\n@@ -32,0 +30,3 @@\n+\/**\n+ * Base class for Checksum tests\n+ *\/\n@@ -39,0 +40,1 @@\n+        testWrappedMemorySegment(checksum, expected);\n@@ -72,0 +74,7 @@\n+    private static void testWrappedMemorySegment(Checksum checksum, long expected) {\n+        checksum.reset();\n+        ByteBuffer bb = MemorySegment.ofArray(BYTES_123456789).asByteBuffer();\n+        checksum.update(bb);\n+        checkChecksum(checksum, expected);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/zip\/ChecksumBase.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -26,1 +26,1 @@\n- * @bug 7110149 8184306 6341887\n+ * @bug 7110149 8184306 6341887 8357145\n@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -206,0 +207,10 @@\n+\n+        \/\/ segment\n+        try (var arena = Arena.ofConfined()) {\n+            bbIn = arena.allocate(in.length).asByteBuffer();\n+            bbIn.put(in, 0, n).flip();\n+            bbOut1 = arena.allocate(out1.length).asByteBuffer();\n+            bbOut2 = arena.allocate(out2.length).asByteBuffer();\n+            checkByteBuffer(def, inf, bbIn, bbOut1, bbOut2, in, len, out2, false);\n+            checkByteBufferReadonly(def, inf, bbIn, bbOut1, bbOut2);\n+        }\n","filename":"test\/jdk\/java\/util\/zip\/DeInflate.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.util.List;\n+import javax.swing.Icon;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.filechooser.FileSystemView;\n+\n+\/*\n+ * @test id=metal\n+ * @bug 8139228\n+ * @summary JFileChooser should not render Directory names in HTML format\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual HTMLFileName metal\n+ *\/\n+\n+\/*\n+ * @test id=system\n+ * @bug 8139228\n+ * @summary JFileChooser should not render Directory names in HTML format\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual HTMLFileName system\n+ *\/\n+\n+public class HTMLFileName {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            <html>\n+            <ol>\n+            <li>FileChooser shows up a virtual directory and file with name\n+               <html><h1 color=#ff00ff><font face=\"Comic Sans MS\">Swing Rocks!.\n+            <li>On \"HTML disabled\" frame :\n+                <ol>\n+                  <li>Verify that the folder and file name must be plain text.\n+                  <li>If the name in file pane window and also in directory\n+                     ComboBox remains in plain text, then press <b>Pass<\/b>.\n+                     If it appears to be in HTML format with Pink color as\n+                     shown, then press <b>Fail<\/b>.\n+                <\/ol>\n+\n+            <li>On \"HTML enabled\" frame :\n+                <ol>\n+                  <li>Verify that the folder and file name remains in HTML\n+                     format with name \"Swing Rocks!\" pink in color as shown.\n+                  <li>If the name in file pane window and also in directory\n+                     ComboBox remains in HTML format string, then press <b>Pass<\/b>.\n+                     If it appears to be in plain text, then press <b>Fail<\/b>.\n+                <\/ol>\n+            <\/ol>\n+            <\/html>\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Look-and-Feel keyword is required\");\n+        }\n+\n+        final String lafClassName;\n+        switch (args[0]) {\n+            case \"metal\" -> lafClassName = UIManager.getCrossPlatformLookAndFeelClassName();\n+            case \"system\" -> lafClassName = UIManager.getSystemLookAndFeelClassName();\n+            default -> throw new IllegalArgumentException(\"Unsupported Look-and-Feel keyword: \" + args[0]);\n+        }\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                UIManager.setLookAndFeel(lafClassName);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        System.out.println(\"Test for LookAndFeel \" + lafClassName);\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .columns(45)\n+                .testUI(HTMLFileName::initialize)\n+                .positionTestUIBottomRowCentered()\n+                .build()\n+                .awaitAndCheck();\n+        System.out.println(\"Test passed for LookAndFeel \" + lafClassName);\n+    }\n+\n+    private static List<JFrame> initialize() {\n+        return List.of(createFileChooser(true), createFileChooser(false));\n+    }\n+\n+    private static JFrame createFileChooser(boolean htmlEnabled) {\n+        JFileChooser jfc = new JFileChooser(new VirtualFileSystemView());\n+        jfc.putClientProperty(\"html.disable\", htmlEnabled);\n+        jfc.setControlButtonsAreShown(false);\n+\n+        JFrame frame = new JFrame((htmlEnabled) ? \"HTML enabled\" : \"HTML disabled\");\n+        frame.add(jfc);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    private static class VirtualFileSystemView extends FileSystemView {\n+        @Override\n+        public File createNewFolder(File containingDir) {\n+            return null;\n+        }\n+\n+        @Override\n+        public File[] getRoots() {\n+            return new File[]{\n+                    new File(\"\/\", \"<html><h1 color=#ff00ff><font \" +\n+                            \"face=\\\"Comic Sans MS\\\">Swing Rocks!\"),\n+                    new File(\"\/\", \"virtualFile2.txt\"),\n+                    new File(\"\/\", \"virtualFolder\")\n+            };\n+        }\n+\n+        @Override\n+        public File getHomeDirectory() {\n+            return new File(\"\/\");\n+        }\n+\n+        @Override\n+        public File getDefaultDirectory() {\n+            return new File(\"\/\");\n+        }\n+\n+        @Override\n+        public File[] getFiles(File dir, boolean useFileHiding) {\n+            \/\/ Simulate a virtual folder structure\n+            return new File[]{\n+                    new File(\"\/\", \"<html><h1 color=#ff00ff><font \" +\n+                            \"face=\\\"Comic Sans MS\\\">Swing Rocks!\"),\n+                    new File(dir, \"virtualFile2.txt\"),\n+                    new File(dir, \"virtualFolder\")\n+            };\n+        }\n+\n+        @Override\n+        public Icon getSystemIcon(File f) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/HTMLFileName.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.ComponentOrientation;\n+import java.awt.Graphics;\n+import java.awt.event.KeyEvent;\n+import javax.swing.Icon;\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JRadioButtonMenuItem;\n+import javax.swing.KeyStroke;\n+import javax.swing.UIManager;\n+\n+final class MenuItemTestHelper {\n+\n+    public static JFrame getMenuItemTestFrame(boolean isLeft, String lafName) {\n+        boolean applyLookAndFeel = lafName != null;\n+        if (applyLookAndFeel) {\n+            try {\n+                UIManager.setLookAndFeel(lafName);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        Icon myIcon = new ColoredIcon(Color.RED, 10, 10);\n+        Icon myIcon2 = new ColoredIcon(Color.GREEN, 15, 10);\n+\n+        JMenuBar menuBar = new JMenuBar();\n+        menuBar.add(createViewMenu(myIcon, myIcon2));\n+        menuBar.add(createNoNothingMenu());\n+        menuBar.add(createSomeIconsMenu(myIcon, myIcon2));\n+\n+        String title = (isLeft ? \"(Left-to-right)\" : \"(Right-to-left)\") + \" - Menu Item Test\";\n+        JFrame frame = new JFrame(title);\n+        frame.setJMenuBar(menuBar);\n+        frame.applyComponentOrientation(isLeft\n+                ? ComponentOrientation.LEFT_TO_RIGHT\n+                : ComponentOrientation.RIGHT_TO_LEFT);\n+\n+        if (applyLookAndFeel) {\n+            String shortName = lafName.substring(lafName.lastIndexOf('.') + 1);\n+            JLabel label = new JLabel(\"<HTML><H2>\" + shortName + \"<\/H2><\/HTML>\");\n+            frame.setLayout(new BorderLayout());\n+            frame.add(label, BorderLayout.CENTER);\n+        }\n+\n+        frame.setSize(300, 300);\n+        return frame;\n+    }\n+\n+    public static JFrame getMenuItemTestFrame(boolean isLeft) {\n+        return getMenuItemTestFrame(isLeft, null);\n+    }\n+\n+    private static JMenu createViewMenu(Icon myIcon, Icon myIcon2) {\n+        JMenu menu = new JMenu(\"View\");\n+        menu.setMnemonic('V');\n+        menu.add(new JMenuItem(\"Refresh\"));\n+        menu.add(new JMenuItem(\"Customize...\"));\n+        menu.add(new JCheckBoxMenuItem(\"Show Toolbar\"));\n+        menu.addSeparator();\n+        menu.add(new JRadioButtonMenuItem(\"List\"));\n+        menu.add(new JRadioButtonMenuItem(\"Icons\"));\n+\n+        JRadioButtonMenuItem rm2 = new JRadioButtonMenuItem(\"And icon.\");\n+        rm2.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F1, KeyEvent.SHIFT_DOWN_MASK));\n+        rm2.setIcon(myIcon2);\n+        menu.add(rm2);\n+\n+        JRadioButtonMenuItem mi3 = new JRadioButtonMenuItem(\"Radio w\/icon\");\n+        mi3.setIcon(myIcon);\n+        menu.add(mi3);\n+\n+        menu.add(new JMenuItem(myIcon2));\n+\n+        JMenuItem mi4 = new JMenuItem(\"Item with icon\");\n+        mi4.setIcon(myIcon);\n+        menu.addSeparator();\n+        menu.add(mi4);\n+\n+        return menu;\n+    }\n+\n+    private static JMenu createNoNothingMenu() {\n+        final JMenu noMenu = new JMenu(\"No nothing\");\n+\n+        for (String label : new String[]{\"One\", \"Two\", \"Threeee\"}) {\n+            JMenuItem item = new JMenuItem(label);\n+            item.addActionListener((e) ->\n+                    PassFailJFrame.log(\"menu.width = \"\n+                            + noMenu.getPopupMenu().getWidth()));\n+            noMenu.add(item);\n+        }\n+\n+        return noMenu;\n+    }\n+\n+    private static JMenu createSomeIconsMenu(Icon myIcon, Icon myIcon2) {\n+        JMenu someIcons = new JMenu(\"Some icons\");\n+\n+        JMenuItem imi1 = new JMenuItem(\"Icon!\");\n+        imi1.setIcon(myIcon);\n+        someIcons.add(imi1);\n+\n+        JMenuItem imi2 = new JMenuItem(\"Wide icon!\");\n+        imi2.setIcon(myIcon2);\n+        someIcons.add(imi2);\n+\n+        someIcons.add(new JCheckBoxMenuItem(\"CheckBox\"));\n+        someIcons.add(new JRadioButtonMenuItem(\"RadioButton\"));\n+\n+        return someIcons;\n+    }\n+\n+    private record ColoredIcon(Color color, int width, int height)\n+            implements Icon {\n+        @Override\n+        public void paintIcon(Component c, Graphics g, int x, int y) {\n+            Color oldColor = g.getColor();\n+            g.setColor(color);\n+            g.fillRect(x, y, width, height);\n+            g.setColor(oldColor);\n+        }\n+\n+        @Override\n+        public int getIconWidth() {\n+            return width;\n+        }\n+\n+        @Override\n+        public int getIconHeight() {\n+            return height;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/MenuItemTest\/MenuItemTestHelper.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4729669\n+ * @summary 1.4 REGRESSION: Text edge of different types of JMenuItems are not aligned\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual bug4729669\n+ *\/\n+\n+import java.util.List;\n+import javax.swing.JFrame;\n+\n+public class bug4729669 {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        Two windows should appear: Left-to-right and Right-to-left.\n+        Check that text on all the menu items of all menus\n+        is properly vertically aligned.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"bug4729669 Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(bug4729669::createTestUI)\n+                .positionTestUIRightColumn()\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static List<JFrame> createTestUI() {\n+        JFrame f1 = MenuItemTestHelper.getMenuItemTestFrame(true);\n+        JFrame f2 = MenuItemTestHelper.getMenuItemTestFrame(false);\n+        return List.of(f1, f2);\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/MenuItemTest\/bug4729669.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6197830\n+ * @requires (os.family == \"linux\")\n+ * @summary Fix for 4729669 does not work on Motif and GTK look and feels\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual bug6197830\n+ *\/\n+\n+import java.util.List;\n+import javax.swing.JFrame;\n+\n+public class bug6197830 {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Four windows should appear: Left-to-right and Right-to-left for\n+            the two different Look and Feels (Motif and GTK).\n+            Check that text on all the menu items of all menus is properly\n+            vertically aligned.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"bug6197830 Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(bug6197830::createTestUI)\n+                .positionTestUIBottomRowCentered()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static List<JFrame> createTestUI() {\n+        JFrame frame1 = MenuItemTestHelper.getMenuItemTestFrame(true,\n+                \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\");\n+        JFrame frame2 = MenuItemTestHelper.getMenuItemTestFrame(false,\n+                \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\");\n+        JFrame frame3 = MenuItemTestHelper.getMenuItemTestFrame(true,\n+                \"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        JFrame frame4 = MenuItemTestHelper.getMenuItemTestFrame(false,\n+                \"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        return List.of(frame1, frame2, frame3, frame4);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/MenuItemTest\/bug6197830.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4729669\n- * @summary 1.4 REGRESSION: Text edge of different types of JMenuItems are not aligned\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @run main\/manual bug4729669\n- *\/\n-\n-import java.awt.Color;\n-import java.awt.ComponentOrientation;\n-import java.awt.Component;\n-import java.awt.Graphics;\n-import java.awt.event.ActionEvent;\n-import java.awt.event.KeyEvent;\n-\n-import javax.swing.AbstractAction;\n-import javax.swing.Icon;\n-import javax.swing.JCheckBoxMenuItem;\n-import javax.swing.JFrame;\n-import javax.swing.JMenu;\n-import javax.swing.JMenuBar;\n-import javax.swing.JMenuItem;\n-import javax.swing.JRadioButtonMenuItem;\n-import javax.swing.KeyStroke;\n-\n-import java.util.List;\n-\n-public class bug4729669 {\n-\n-    private static final String INSTRUCTIONS = \"\"\"\n-        Two windows should appear: Left-to-right and Right-to-left.\n-        Check that text on all the menu items of all menus\n-        is properly vertically aligned.\"\"\";\n-\n-    public static void main(String[] args) throws Exception {\n-        PassFailJFrame.builder()\n-                .title(\"bug4729669 Instructions\")\n-                .instructions(INSTRUCTIONS)\n-                .columns(35)\n-                .testUI(bug4729669::createTestUI)\n-                .position(PassFailJFrame.Position.TOP_LEFT_CORNER)\n-                .logArea()\n-                .build()\n-                .awaitAndCheck();\n-    }\n-\n-    private static List<JFrame> createTestUI() {\n-        JFrame f1 = MenuItemTest.doMenuItemTest(true);\n-        f1.setLocation(300, 300);\n-        JFrame f2 = MenuItemTest.doMenuItemTest(false);\n-        f2.setLocation(500, 300);\n-        return List.of(f1, f2);\n-    }\n-}\n-\n-class MenuItemTest {\n-    public static JFrame doMenuItemTest(boolean isLeft) {\n-        JMenu menu = new JMenu(\"View\");\n-        menu.setMnemonic('V');\n-\n-        menu.add(new JMenuItem(\"Refresh\"));\n-        menu.add(new JMenuItem(\"Customize...\"));\n-        menu.add(new JCheckBoxMenuItem(\"Show Toolbar\"));\n-        menu.addSeparator();\n-        menu.add(new JRadioButtonMenuItem(\"List\"));\n-        menu.add(new JRadioButtonMenuItem(\"Icons\"));\n-        JRadioButtonMenuItem rm2 = new JRadioButtonMenuItem(\"And icon.\");\n-        rm2.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F1,\n-                                                  KeyEvent.SHIFT_MASK));\n-        menu.add(rm2);\n-        JRadioButtonMenuItem mi3 = new JRadioButtonMenuItem(\"Radio w\/icon\");\n-\n-        Icon myIcon = new Icon() { \/\/ 10 pixel red\n-            public void paintIcon(Component c, Graphics g, int x, int y) {\n-                Color color = g.getColor();\n-                g.setColor(Color.RED);\n-                g.fillRect(x, y, 10, 10);\n-                g.setColor(color);\n-            }\n-\n-            public int getIconWidth() {\n-                return 10;\n-            }\n-\n-            public int getIconHeight() {\n-                return 10;\n-            }\n-        };\n-\n-        Icon myIcon2 = new Icon() { \/\/ 15 pixel green\n-            public void paintIcon(Component c, Graphics g, int x, int y) {\n-                Color color = g.getColor();\n-                g.setColor(Color.GREEN);\n-                g.fillRect(x, y, 15, 10);\n-                g.setColor(color);\n-            }\n-\n-            public int getIconWidth() {\n-                return 15;\n-            }\n-\n-            public int getIconHeight() {\n-                return 10;\n-            }\n-        };\n-\n-        rm2.setIcon(myIcon2);\n-\n-        mi3.setIcon(myIcon);\n-        menu.add(mi3);\n-        menu.add(new JMenuItem(myIcon2));\n-\n-        final JMenu menu2 = new JMenu(\"No nothing\");\n-        menu2.add(\"One\").addActionListener(new AbstractAction() {\n-            public void actionPerformed(ActionEvent e) {\n-                PassFailJFrame.log(\"menu.width = \" + menu2.getPopupMenu().getWidth());\n-            }\n-        });\n-        menu2.add(\"Two\").addActionListener(new AbstractAction() {\n-            public void actionPerformed(ActionEvent e) {\n-                PassFailJFrame.log(\"menu.width = \" + menu2.getPopupMenu().getWidth());\n-            }\n-        });\n-        menu2.add(\"Threeee\").addActionListener(new AbstractAction() {\n-            public void actionPerformed(ActionEvent e) {\n-                PassFailJFrame.log(\"menu.width = \" + menu2.getPopupMenu().getWidth());\n-            }\n-        });\n-\n-        JMenuItem mi4 = new JMenuItem(\"Item with icon\");\n-        mi4.setIcon(myIcon);\n-        menu.addSeparator();\n-        menu.add(mi4);\n-        String title = \"Menu Item Test \" + (isLeft ? \"(Left-to-right)\" : \"(Right-to-left)\");\n-        JFrame frame = new JFrame(title);\n-\n-        JMenuBar menuBar = new JMenuBar();\n-        menuBar.add(menu);\n-        menuBar.add(menu2);\n-\n-        JMenu someIcons = new JMenu(\"Some icons\");\n-        JMenuItem imi1 = new JMenuItem(\"Icon!\");\n-        imi1.setIcon(myIcon);\n-        someIcons.add(imi1);\n-        JMenuItem imi2 = new JMenuItem(\"Wide icon!\");\n-        imi2.setIcon(myIcon2);\n-        someIcons.add(imi2);\n-        someIcons.add(new JCheckBoxMenuItem(\"CheckBox\"));\n-        someIcons.add(new JRadioButtonMenuItem(\"RadioButton\"));\n-        menuBar.add(someIcons);\n-        frame.setJMenuBar(menuBar);\n-        ComponentOrientation co = (isLeft ?\n-                ComponentOrientation.LEFT_TO_RIGHT :\n-                ComponentOrientation.RIGHT_TO_LEFT);\n-        frame.applyComponentOrientation(co);\n-        frame.setSize(300, 300);\n-        int frameX = isLeft ? 0 : 600;\n-        frame.setLocation(frameX, 20);\n-        return frame;\n-    }\n-\n-}\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/bug4729669.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6197830\n- * @requires (os.family == \"linux\")\n- * @summary Fix for 4729669 does not work on Motif and GTK look and feels\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @run main\/manual bug6197830\n- *\/\n-\n-public class bug6197830 {\n-\n-    private static final String INSTRUCTIONS = \"\"\"\n-        Four windows should appear: Left-to-right and Right-to-left for\n-        the two different Look and Feels (Motif and GTK).\n-        Check that text on all the menu items of all menus is properly\n-        vertically aligned.\"\"\";\n-\n-    public static void main(String[] args) throws Exception {\n-        PassFailJFrame.builder()\n-                .title(\"bug6197830 Instructions\")\n-                .instructions(INSTRUCTIONS)\n-                .columns(35)\n-                .testUI(bug6197830::createTestUI)\n-                .position(PassFailJFrame.Position.TOP_LEFT_CORNER)\n-                .build()\n-                .awaitAndCheck();\n-    }\n-\n-    private static List<JFrame> createTestUI() {\n-        JFrame frame1 = MenuItemTest.doMenuItemTest(true,\n-                            \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\",\n-                             20);\n-        frame1.setLocation(300, 300);\n-        JFrame frame2 = MenuItemTest.doMenuItemTest(false,\n-                            \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\",\n-                             20);\n-        frame2.setLocation((int)(frame1.getLocation().getX() + frame1.getWidth()\n-                            + 100), 300);\n-        JFrame frame3 = MenuItemTest.doMenuItemTest(true,\n-                             \"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\", 420);\n-        frame3.setLocation(300, (int)(frame1.getLocation().getY()\n-                                 + frame1.getHeight() + 100));\n-        JFrame frame4 = MenuItemTest.doMenuItemTest(false,\n-                             \"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\", 420);\n-        frame4.setLocation((int)(frame3.getLocation().getX() + frame3.getWidth()\n-                            + 100),\n-                           (int)frame3.getLocation().getY());\n-        return List.of(frame1, frame2, frame3, frame4);\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/bug6197830.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte128VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte128VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte128VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte128VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte128VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte256VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte256VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte256VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte256VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte256VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte512VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte512VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte512VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte512VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte512VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2910,0 +2936,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByte64VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte64VectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByte64VectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, Byte64VectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByte64VectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, Byte64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -424,0 +424,11 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -463,0 +474,15 @@\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(byte[] r, byte[] a, byte b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2915,0 +2941,106 @@\n+    static ByteVector bv_MIN = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MINByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_min = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void minByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::min);\n+    }\n+\n+    static ByteVector bv_MIN_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MINByteMaxVectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, ByteMaxVectorTests::MIN);\n+    }\n+\n+    static ByteVector bv_MAX = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void MAXByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::MAX);\n+    }\n+\n+    static ByteVector bv_max = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void maxByteMaxVectorTestsWithMemOp(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, ByteMaxVectorTests::max);\n+    }\n+\n+    static ByteVector bv_MAX_M = ByteVector.broadcast(SPECIES, (byte)10);\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void MAXByteMaxVectorTestsMaskedWithMemOp(IntFunction<byte[]> fa, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (byte)10, mask, ByteMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble128VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double128VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble128VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double128VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble128VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble256VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double256VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble256VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double256VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble256VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble512VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double512VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble512VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double512VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble512VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2027,0 +2053,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDouble64VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double64VectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDouble64VectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, Double64VectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDouble64VectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, Double64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -442,0 +442,11 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -481,0 +492,15 @@\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(double[] r, double[] a, double b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2032,0 +2058,106 @@\n+    static DoubleVector bv_MIN = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MINDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_min = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void minDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::min);\n+    }\n+\n+    static DoubleVector bv_MIN_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MINDoubleMaxVectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, DoubleMaxVectorTests::MIN);\n+    }\n+\n+    static DoubleVector bv_MAX = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void MAXDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::MAX);\n+    }\n+\n+    static DoubleVector bv_max = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpProvider\")\n+    static void maxDoubleMaxVectorTestsWithMemOp(IntFunction<double[]> fa) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, DoubleMaxVectorTests::max);\n+    }\n+\n+    static DoubleVector bv_MAX_M = DoubleVector.broadcast(SPECIES, (double)10);\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void MAXDoubleMaxVectorTestsMaskedWithMemOp(IntFunction<double[]> fa, IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (double)10, mask, DoubleMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat128VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float128VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat128VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float128VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat128VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat256VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float256VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat256VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float256VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat256VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat512VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float512VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat512VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float512VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat512VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -437,0 +437,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -476,0 +487,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2038,0 +2064,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloat64VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float64VectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloat64VectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, Float64VectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloat64VectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, Float64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -442,0 +442,11 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -481,0 +492,15 @@\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(float[] r, float[] a, float b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2043,0 +2069,106 @@\n+    static FloatVector bv_MIN = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MINFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_min = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void minFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::min);\n+    }\n+\n+    static FloatVector bv_MIN_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MINFloatMaxVectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, FloatMaxVectorTests::MIN);\n+    }\n+\n+    static FloatVector bv_MAX = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void MAXFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::MAX);\n+    }\n+\n+    static FloatVector bv_max = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpProvider\")\n+    static void maxFloatMaxVectorTestsWithMemOp(IntFunction<float[]> fa) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, FloatMaxVectorTests::max);\n+    }\n+\n+    static FloatVector bv_MAX_M = FloatVector.broadcast(SPECIES, (float)10);\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void MAXFloatMaxVectorTestsMaskedWithMemOp(IntFunction<float[]> fa, IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (float)10, mask, FloatMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2954,0 +2980,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt128VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int128VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt128VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int128VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt128VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2954,0 +2980,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt256VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int256VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt256VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int256VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt256VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2954,0 +2980,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt512VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int512VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt512VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int512VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt512VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2953,0 +2979,106 @@\n+\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINInt64VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int64VectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxInt64VectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, Int64VectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXInt64VectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, Int64VectorTests::MAX);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -424,0 +424,11 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -463,0 +474,15 @@\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(int[] r, int[] a, int b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2959,0 +2985,106 @@\n+    static IntVector bv_MIN = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MINIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::MIN);\n+    }\n+\n+    static IntVector bv_min = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void minIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::min);\n+    }\n+\n+    static IntVector bv_MIN_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MINIntMaxVectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, IntMaxVectorTests::MIN);\n+    }\n+\n+    static IntVector bv_MAX = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void MAXIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::MAX);\n+    }\n+\n+    static IntVector bv_max = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void maxIntMaxVectorTestsWithMemOp(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, IntMaxVectorTests::max);\n+    }\n+\n+    static IntVector bv_MAX_M = IntVector.broadcast(SPECIES, (int)10);\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void MAXIntMaxVectorTestsMaskedWithMemOp(IntFunction<int[]> fa, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (int)10, mask, IntMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong128VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long128VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong128VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long128VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong128VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong256VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long256VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong256VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long256VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong256VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong512VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long512VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong512VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long512VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong512VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -376,0 +376,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -415,0 +426,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2976,0 +3002,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLong64VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long64VectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLong64VectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, Long64VectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLong64VectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, Long64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -381,0 +381,11 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -420,0 +431,15 @@\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(long[] r, long[] a, long b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2981,0 +3007,106 @@\n+    static LongVector bv_MIN = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MINLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::MIN);\n+    }\n+\n+    static LongVector bv_min = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void minLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::min);\n+    }\n+\n+    static LongVector bv_MIN_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MINLongMaxVectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, LongMaxVectorTests::MIN);\n+    }\n+\n+    static LongVector bv_MAX = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void MAXLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::MAX);\n+    }\n+\n+    static LongVector bv_max = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void maxLongMaxVectorTestsWithMemOp(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, LongMaxVectorTests::max);\n+    }\n+\n+    static LongVector bv_MAX_M = LongVector.broadcast(SPECIES, (long)10);\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void MAXLongMaxVectorTestsMaskedWithMemOp(IntFunction<long[]> fa, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (long)10, mask, LongMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort128VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short128VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort128VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short128VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort128VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short128VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort256VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short256VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort256VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short256VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort256VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short256VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort512VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short512VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort512VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short512VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort512VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short512VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -419,0 +419,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -458,0 +469,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2901,0 +2927,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShort64VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short64VectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShort64VectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, Short64VectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShort64VectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, Short64VectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -424,0 +424,11 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -463,0 +474,15 @@\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n@@ -2906,0 +2932,106 @@\n+    static ShortVector bv_MIN = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MINShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_min = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void minShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.min(bv_min).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::min);\n+    }\n+\n+    static ShortVector bv_MIN_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MINShortMaxVectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MIN, bv_MIN_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, ShortMaxVectorTests::MIN);\n+    }\n+\n+    static ShortVector bv_MAX = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void MAXShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::MAX);\n+    }\n+\n+    static ShortVector bv_max = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void maxShortMaxVectorTestsWithMemOp(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.max(bv_max).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, ShortMaxVectorTests::max);\n+    }\n+\n+    static ShortVector bv_MAX_M = ShortVector.broadcast(SPECIES, (short)10);\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void MAXShortMaxVectorTestsMaskedWithMemOp(IntFunction<short[]> fa, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.MAX, bv_MAX_M, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, (short)10, mask, ShortMaxVectorTests::MAX);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+binary_memop=\"Binary-mem-op\"\n+binary_masked_memop=\"Binary-Masked-mem-op\"\n@@ -258,0 +260,6 @@\n+function gen_binary_alu_mem_op {\n+  echo \"Generating binary op $1 ($2)...\"\n+  gen_op_tmpl $binary_memop \"$@\"\n+  gen_op_tmpl $binary_masked_memop \"$@\"\n+}\n+\n@@ -467,0 +475,4 @@\n+# Binary operation with one memory operand\n+gen_binary_alu_mem_op \"MIN+min+withMask\", \"Math.min(a, b)\"\n+gen_binary_alu_mem_op \"MAX+max+withMask\", \"Math.max(a, b)\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,11 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.[[TEST]], bv_[[TEST]]_M, vmask).intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-Masked-mem-op.template","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.[[TEST]], bv_[[TEST]]).intoArray(r, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-mem-op.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+\n+    static $abstractvectortype$ bv_[[TEST]]_M = $abstractvectortype$.broadcast(SPECIES, ($type$)10);\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$MaskedWithMemOp(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, ($type$)10, mask, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-Masked-mem-op.template","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+\n+    static $abstractvectortype$ bv_[[TEST]] = $abstractvectortype$.broadcast(SPECIES, ($type$)10);\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$WithMemOp(IntFunction<$type$[]> fa) {\n+[[KERNEL]]\n+        assertArraysEquals(r, a, ($type$)10, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-mem-op.template","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -516,0 +516,11 @@\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$ b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b), \"(\" + a[i] + \", \" + b + \") at index #\" + i);\n+        }\n+    }\n+\n@@ -555,0 +566,15 @@\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$ b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$ b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b, mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8331535 8351435\n+ * @bug 8331535 8351435 8347050\n@@ -41,0 +41,2 @@\n+    private static final String NL = System.getProperty(\"line.separator\");\n+\n@@ -57,0 +59,6 @@\n+    void testEvenExpansionDisabled() throws Exception {\n+        doRunConsoleTest(\"readAndPrint\", \"a\\\\b\\n\", \"'a\\\\b'\" + NL);\n+        doRunConsoleTest(\"readAndPrint2\", \"a\\n!!\\n\", \"1: 'a'\" + NL +\n+                                                     \"2: '!!'\" + NL);\n+    }\n+\n@@ -98,0 +106,6 @@\n+                case \"readAndPrint\" ->\n+                    System.out.println(\"'\" + System.console().readLine() + \"'\");\n+                case \"readAndPrint2\" -> {\n+                    System.out.println(\"1: '\" +System.console().readLine() + \"'\");\n+                    System.out.println(\"2: '\" + System.console().readLine() + \"'\");\n+                }\n","filename":"test\/jdk\/jdk\/internal\/jline\/JLineConsoleProviderTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.containers.docker.ContainerRuntimeVersionTestUtils;\n@@ -62,0 +63,3 @@\n+\n+        ContainerRuntimeVersionTestUtils.checkContainerVersionSupported();\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetricsSubgroup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.Random;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestSafepointLatency\n+ *\/\n+public class TestSafepointLatency {\n+    \/\/ The SafepointLatency event is parasitic on the ExecutionSample mechanism.\n+    final static String EXECUTION_SAMPLE_EVENT = EventNames.ExecutionSample;\n+    final static String SAFEPOINT_LATENCY_EVENT = EventNames.SafepointLatency;\n+    final static CountDownLatch latch = new CountDownLatch(10);\n+    final static Random random = new Random();\n+    public static int publicizedValue = 4711;\n+\n+    public static void main(String[] args) throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(EXECUTION_SAMPLE_EVENT).withPeriod(Duration.ofMillis(1));\n+            rs.enable(SAFEPOINT_LATENCY_EVENT);\n+            rs.onEvent(SAFEPOINT_LATENCY_EVENT, e -> latch.countDown());\n+            rs.startAsync();\n+            Thread t = new Thread(TestSafepointLatency::callMethods);\n+            t.setDaemon(true);\n+            t.start();\n+            latch.await();\n+        }\n+    }\n+\n+    public static void callMethods() {\n+        while (latch.getCount() > 0) {\n+            publicizedValue += bar(publicizedValue);\n+        }\n+    }\n+\n+    private static int bar(int value) {\n+        return baz(value);\n+    }\n+\n+    private static int baz(int value) {\n+        return qux(value);\n+    }\n+\n+    private static int qux(int value) {\n+        return (value << 4) * random.nextInt();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestSafepointLatency.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -56,0 +56,1 @@\n+import java.util.stream.IntStream;\n@@ -129,2 +130,2 @@\n-    public PackageTest setExpectedInstallExitCode(int v) {\n-        expectedInstallExitCode = v;\n+    public PackageTest setExpectedInstallExitCode(int... v) {\n+        expectedInstallExitCodes = IntStream.of(v).mapToObj(Integer::valueOf).collect(Collectors.toSet());\n@@ -486,1 +487,1 @@\n-            int expectedInstallExitCode, PackageHandlers packageHandlers, Handler handler,\n+            Set<Integer> expectedInstallExitCodes, PackageHandlers packageHandlers, Handler handler,\n@@ -491,0 +492,4 @@\n+            Objects.requireNonNull(expectedInstallExitCodes);\n+            if (expectedInstallExitCodes.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n@@ -498,1 +503,1 @@\n-                int expectedInstallExitCode, PackageHandlers packageHandlers,\n+                Set<Integer> expectedInstallExitCodes, PackageHandlers packageHandlers,\n@@ -500,1 +505,1 @@\n-            this(type, expectedJPackageExitCode, expectedInstallExitCode,\n+            this(type, expectedJPackageExitCode, expectedInstallExitCodes,\n@@ -535,3 +540,4 @@\n-                    final int installExitCode = packageHandlers.install(cmd);\n-                    TKit.assertEquals(expectedInstallExitCode, installExitCode,\n-                            String.format(\"Check installer exited with %d code\", expectedInstallExitCode));\n+                    final int actualInstallExitCode = packageHandlers.install(cmd);\n+                    state.actualInstallExitCode = Optional.of(actualInstallExitCode);\n+                    TKit.assertTrue(expectedInstallExitCodes.contains(actualInstallExitCode),\n+                            String.format(\"Check installer exit code %d is one of %s\", actualInstallExitCode, expectedInstallExitCodes));\n@@ -627,1 +633,1 @@\n-            return processed(Action.INSTALL) && expectedInstallExitCode != 0;\n+            return processed(Action.INSTALL) && state.actualInstallExitCode.orElseThrow() != 0;\n@@ -639,0 +645,1 @@\n+            private Optional<Integer> actualInstallExitCode = Optional.empty();\n@@ -652,1 +659,1 @@\n-                expectedInstallExitCode, getPackageHandlers(type), handler.copy(), cmd);\n+                expectedInstallExitCodes, getPackageHandlers(type), handler.copy(), cmd);\n@@ -932,1 +939,1 @@\n-    private int expectedInstallExitCode;\n+    private Set<Integer> expectedInstallExitCodes;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -65,0 +65,11 @@\n+            \/\/ Installation could have ended up with 1603 or 1625 error codes.\n+            \/\/ MSI error code 1625 indicates the test is being executed in an environment\n+            \/\/ that doesn't allow per-user installations. This means the test should be skipped.\n+            try (final var lines = cmd.winMsiLogFileContents().orElseThrow()) {\n+                if (lines.anyMatch(line -> {\n+                    return line.endsWith(\"Installation success or error status: 1625.\");\n+                })) {\n+                    TKit.throwSkippedException(\"Installation of per-user packages by the current user is forbidden by system policy\");\n+                }\n+            }\n+\n@@ -75,1 +86,1 @@\n-        .setExpectedInstallExitCode(1603)\n+        .setExpectedInstallExitCode(1603, 1625)\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinOSConditionTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+import jdk.jshell.JShell;\n+\n+import static org.testng.Assert.fail;\n+\n+public abstract class AbstractStopExecutionTest extends KullaTesting {\n+\n+    private final Object lock = new Object();\n+    private boolean isStopped;\n+\n+    protected void scheduleStop(String src) throws InterruptedException {\n+        JShell state = getState();\n+        isStopped = false;\n+        StringWriter writer = new StringWriter();\n+        PrintWriter out = new PrintWriter(writer);\n+        Thread t = new Thread(() -> {\n+            int i = 1;\n+            int n = 30;\n+            synchronized (lock) {\n+                do {\n+                    state.stop();\n+                    if (!isStopped) {\n+                        out.println(\"Not stopped. Try again: \" + i);\n+                        try {\n+                            lock.wait(1000);\n+                        } catch (InterruptedException ignored) {\n+                        }\n+                    }\n+                } while (i++ < n && !isStopped);\n+                if (!isStopped) {\n+                    System.err.println(writer.toString());\n+                    fail(\"Evaluation was not stopped: '\" + src + \"'\");\n+                }\n+            }\n+        });\n+        t.start();\n+        assertEval(src);\n+        synchronized (lock) {\n+            out.println(\"Evaluation was stopped successfully: '\" + src + \"'\");\n+            isStopped = true;\n+            lock.notify();\n+        }\n+        \/\/ wait until the background thread finishes to prevent from calling 'stop' on closed state.\n+        t.join();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/AbstractStopExecutionTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8131025 8141092 8153761 8145263 8131019 8175886 8176184 8176241 8176110 8177466 8197439 8221759 8234896 8240658 8278039 8286206 8296789 8314662 8326333 8326333\n+ * @bug 8131025 8141092 8153761 8145263 8131019 8175886 8176184 8176241 8176110 8177466 8197439 8221759 8234896 8240658 8278039 8286206 8296789 8314662 8326333 8326333 8353581\n@@ -827,0 +827,10 @@\n+\n+    \/\/JDK-8353581: completion for module imports:\n+    public void testModuleImport() {\n+        assertCompletionIncludesExcludes(\"import |\", Set.of(\"module \"), Set.of());\n+        assertCompletionIncludesExcludes(\"import module |\", Set.of(\"java.base\"), Set.of(\"java.\", \"module\"));\n+        assertCompletionIncludesExcludes(\"import module java.|\", Set.of(\"java.base\"), Set.of());\n+        assertCompletion(\"import module java.ba|\", \"java.base\");\n+        assertCompletionIncludesExcludes(\"import module ja|\", Set.of(\"java.base\"), Set.of(\"jdk.compiler\"));\n+        assertCompletion(\"import module java\/*c*\/.\/*c*\/ba|\", \"java.base\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run testng InputUITest\n+ * @run testng\/othervm -Dstderr.encoding=UTF-8 -Dstdin.encoding=UTF-8 -Dstdout.encoding=UTF-8 InputUITest\n","filename":"test\/langtools\/jdk\/jshell\/InputUITest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8355323\n+ * @summary Verify local execution can stop execution when there are no backward branches\n+ * @modules jdk.jshell\/jdk.internal.jshell.tool\n+ * @build KullaTesting TestingInputStream\n+ * @run testng LocalStopExecutionTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.internal.jshell.tool.StopDetectingInputStream;\n+import jdk.internal.jshell.tool.StopDetectingInputStream.State;\n+import jdk.jshell.JShell;\n+\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class LocalStopExecutionTest extends AbstractStopExecutionTest {\n+\n+    @BeforeMethod\n+    @Override\n+    public void setUp() {\n+        setUp(b -> b.executionEngine(\"local\"));\n+    }\n+\n+    @Test\n+    public void testVeryLongRecursion() throws InterruptedException {\n+        scheduleStop(\n+            \"\"\"\n+            \/\/ Note: there are no backward branches in this class\n+            new Runnable() {\n+                public void run() {\n+                    recurse(1);\n+                    recurse(10);\n+                    recurse(100);\n+                    recurse(1000);\n+                    recurse(10000);\n+                    recurse(100000);\n+                    recurse(1000000);\n+                }\n+                public void recurse(int depth) {\n+                    if (depth == 0)\n+                        return;\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                    recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1); recurse(depth - 1);\n+                }\n+            }.run();\n+            \"\"\"\n+        );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/LocalStopExecutionTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n@@ -44,1 +42,0 @@\n-import jdk.jshell.JShell;\n@@ -48,1 +45,0 @@\n-import static org.testng.Assert.fail;\n@@ -51,4 +47,1 @@\n-public class StopExecutionTest extends KullaTesting {\n-\n-    private final Object lock = new Object();\n-    private boolean isStopped;\n+public class StopExecutionTest extends AbstractStopExecutionTest {\n@@ -71,36 +64,0 @@\n-    private void scheduleStop(String src) throws InterruptedException {\n-        JShell state = getState();\n-        isStopped = false;\n-        StringWriter writer = new StringWriter();\n-        PrintWriter out = new PrintWriter(writer);\n-        Thread t = new Thread(() -> {\n-            int i = 1;\n-            int n = 30;\n-            synchronized (lock) {\n-                do {\n-                    state.stop();\n-                    if (!isStopped) {\n-                        out.println(\"Not stopped. Try again: \" + i);\n-                        try {\n-                            lock.wait(1000);\n-                        } catch (InterruptedException ignored) {\n-                        }\n-                    }\n-                } while (i++ < n && !isStopped);\n-                if (!isStopped) {\n-                    System.err.println(writer.toString());\n-                    fail(\"Evaluation was not stopped: '\" + src + \"'\");\n-                }\n-            }\n-        });\n-        t.start();\n-        assertEval(src);\n-        synchronized (lock) {\n-            out.println(\"Evaluation was stopped successfully: '\" + src + \"'\");\n-            isStopped = true;\n-            lock.notify();\n-        }\n-        \/\/ wait until the background thread finishes to prevent from calling 'stop' on closed state.\n-        t.join();\n-    }\n-\n","filename":"test\/langtools\/jdk\/jshell\/StopExecutionTest.java","additions":2,"deletions":45,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8356894\n+ * @summary Verify source level checks are performed properly\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RequiresIdentityTest\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class RequiresIdentityTest extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new RequiresIdentityTest().runTests();\n+    }\n+\n+    RequiresIdentityTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testReleaseWorksAsCurrentVersion(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          import java.util.WeakHashMap;\n+                          import java.util.Optional;\n+\n+                          public class Test {\n+                              void test() {\n+                                  WeakHashMap<Optional<Integer>, Object> m = null;\n+                                  m.put(Optional.empty(), 1);\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        var expectedErrors = List.of(\n+            \"Test.java:6:20: compiler.warn.attempt.to.use.value.based.where.identity.expected\",\n+            \"Test.java:7:29: compiler.warn.attempt.to.use.value.based.where.identity.expected\",\n+            \"2 warnings\"\n+        );\n+\n+        {\n+            var actualErrors =\n+                    new JavacTask(tb)\n+                        .options(\"-XDrawDiagnostics\")\n+                        .outdir(classes)\n+                        .files(tb.findJavaFiles(src))\n+                        .run()\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!expectedErrors.equals(actualErrors)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                          \", actual: \" + actualErrors);\n+            }\n+        }\n+\n+        {\n+            var actualErrors =\n+                    new JavacTask(tb)\n+                        .options(\"--release\", System.getProperty(\"java.specification.version\"),\n+                                 \"-XDrawDiagnostics\")\n+                        .outdir(classes)\n+                        .files(tb.findJavaFiles(src))\n+                        .run()\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!expectedErrors.equals(actualErrors)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                          \", actual: \" + actualErrors);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testModel(Path base) throws Exception {\n+        {\n+            List<String> printed =\n+                new JavacTask(tb)\n+                    .options(\"-Xprint\")\n+                    .classes(\"java.util.WeakHashMap\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            printed.removeIf(l -> !l.contains(\"put(\") && !l.contains(\"class WeakHashMap<\"));\n+\n+            List<String> expected = List.of(\n+                \"public class WeakHashMap<@jdk.internal.RequiresIdentity K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {\",\n+                \"  public V put(@jdk.internal.RequiresIdentity sealed K key,\"\n+            );\n+            if (!expected.equals(printed)) {\n+                throw new AssertionError(\"Expected: \" + expected +\n+                                         \", but got: \" + printed);\n+            }\n+        }\n+\n+        {\n+            List<String> printed =\n+                new JavacTask(tb)\n+                    .options(\"--release\", System.getProperty(\"java.specification.version\"),\n+                             \"-Xprint\")\n+                    .classes(\"java.util.WeakHashMap\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            printed.removeIf(l -> !l.contains(\"put(\") && !l.contains(\"class WeakHashMap<\"));\n+\n+            List<String> expected = List.of(\n+                \"public class WeakHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {\",\n+                \"  public V put(sealed K arg0,\"\n+            );\n+            if (!expected.equals(printed)) {\n+                throw new AssertionError(\"Expected: \" + expected +\n+                                         \", but got: \" + printed);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/RequiresIdentityTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+RequiresIdentityTest.java:16:18: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+- compiler.err.warnings.and.werror\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/platform\/RequiresIdentityTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -24,13 +24,0 @@\n-\/**\n- * @test\n- * @bug 8072480 8277106 8331027\n- * @summary Unit test for CreateSymbols\n- * @modules java.compiler\n- *          jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.jvm\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.javac.util\n- * @clean *\n- * @run main\/othervm CreateSymbolsTest\n- *\/\n-\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTest.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,13 @@\n+\/**\n+ * @test\n+ * @bug 8072480 8277106 8331027\n+ * @summary Unit test for CreateSymbols\n+ * @modules java.compiler\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @clean *\n+ * @run main\/othervm CreateSymbolsTest\n+ *\/\n+\n@@ -911,0 +924,103 @@\n+    @Test\n+    void testTypeAnnotations() throws Exception {\n+        doPrintElementTest(\"\"\"\n+                           package t;\n+                           public class T {\n+                           }\n+                           \"\"\",\n+                           \"\"\"\n+                           package t;\n+                           import java.lang.annotation.*;\n+                           import java.util.*;\n+                           public class T<@AnnInvisible @AnnVisible E extends @AnnInvisible @AnnVisible ArrayList<@AnnInvisible @AnnVisible ArrayList>> extends @AnnInvisible @AnnVisible ArrayList {\n+                               public @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible E> field;\n+                               public <@AnnInvisible @AnnVisible M extends @AnnInvisible @AnnVisible ArrayList<@AnnInvisible @AnnVisible ArrayList>> @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible M> convert(@AnnInvisible @AnnVisible T<E> this, @AnnInvisible @AnnVisible M e1, @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible E> e2) throws @AnnInvisible @AnnVisible IllegalStateException, @AnnInvisible @AnnVisible IllegalArgumentException {\n+                                   return null;\n+                               }\n+                           }\n+                           @Retention(RetentionPolicy.RUNTIME)\n+                           @Target(ElementType.TYPE_USE)\n+                           @interface AnnVisible {\n+                           }\n+                           @Retention(RetentionPolicy.CLASS)\n+                           @Target(ElementType.TYPE_USE)\n+                           @interface AnnInvisible {\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T<@t.AnnInvisible @t.AnnVisible E extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList<java.util.@t.AnnInvisible @t.AnnVisible ArrayList>> extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList {\n+                             public java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible E> field;\n+\n+                             public T();\n+\n+                             public <@t.AnnInvisible @t.AnnVisible M extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList<java.util.@t.AnnInvisible @t.AnnVisible ArrayList>> java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible M> convert(@t.AnnInvisible @t.AnnVisible M arg0,\n+                               java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible E> arg1) throws java.lang.@t.AnnInvisible @t.AnnVisible IllegalStateException,\\s\n+                               java.lang.@t.AnnInvisible @t.AnnVisible IllegalArgumentException;\n+                           }\n+                           \"\"\");\n+    }\n+\n+    @Test\n+    void testParameterAnnotations() throws Exception {\n+        doPrintElementTest(\"\"\"\n+                           package t;\n+                           public class T {\n+                               public void test(int p1, int p2) {\n+                               }\n+                           }\n+                           \"\"\",\n+                           \"\"\"\n+                           package t;\n+                           import java.lang.annotation.*;\n+                           import java.util.*;\n+                           public class T {\n+                               public void test(@AnnVisible int p1, @AnnInvisible int p2) {\n+                               }\n+                           }\n+                           @Retention(RetentionPolicy.RUNTIME)\n+                           @Target(ElementType.PARAMETER)\n+                           @interface AnnVisible {\n+                           }\n+                           @Retention(RetentionPolicy.CLASS)\n+                           @Target(ElementType.PARAMETER)\n+                           @interface AnnInvisible {\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+\n+                             public void test(int arg0,\n+                               int arg1);\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+\n+                             public void test(@t.AnnVisible int arg0,\n+                               @t.AnnInvisible int arg1);\n+                           }\n+                           \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":117,"deletions":1,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8214031\n+ * @bug 8214031 8357361\n@@ -32,0 +32,2 @@\n+import java.util.Objects;\n+\n@@ -46,0 +48,2 @@\n+        new ExpressionSwitchBugsInGen().testSwitchExpressionTypeErased(0);\n+        new ExpressionSwitchBugsInGen().testSwitchExpressionTypeErased(1);\n@@ -94,0 +98,17 @@\n+    \/\/JDK-8357361:\n+    private void testSwitchExpressionTypeErased(int i) {\n+        interface Readable<R extends String> {\n+            R getReader();\n+        }\n+        Readable<?> readable = () -> \"\";\n+        var v = switch (i) {\n+            case 0 -> readable.getReader();\n+            default -> null;\n+        };\n+        var expected = i == 0 ? \"\" : null;\n+        if (!Objects.equals(v, expected)) {\n+            throw new IllegalStateException(\"Expected: \" + expected +\n+                                            \", got: \" + v);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchBugsInGen.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Methods and definitions related to container runtime version to test container in this directory\n+ *\/\n+\n+package jdk.test.lib.containers.docker;\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jtreg.SkippedException;\n+\n+public class ContainerRuntimeVersionTestUtils implements Comparable<ContainerRuntimeVersionTestUtils> {\n+    private final int major;\n+    private final int minor;\n+    private final int micro;\n+    private static final boolean IS_DOCKER = Container.ENGINE_COMMAND.contains(\"docker\");\n+    private static final boolean IS_PODMAN = Container.ENGINE_COMMAND.contains(\"podman\");\n+    public static final ContainerRuntimeVersionTestUtils DOCKER_MINIMAL_SUPPORTED_VERSION_CGROUPNS = new ContainerRuntimeVersionTestUtils(20, 10, 0);\n+    public static final ContainerRuntimeVersionTestUtils PODMAN_MINIMAL_SUPPORTED_VERSION_CGROUPNS = new ContainerRuntimeVersionTestUtils(1, 5, 0);\n+\n+    private ContainerRuntimeVersionTestUtils(int major, int minor, int micro) {\n+        this.major = major;\n+        this.minor = minor;\n+        this.micro = micro;\n+    }\n+\n+    public static void checkContainerVersionSupported() {\n+        if (IS_DOCKER && ContainerRuntimeVersionTestUtils.DOCKER_MINIMAL_SUPPORTED_VERSION_CGROUPNS.compareTo(ContainerRuntimeVersionTestUtils.getContainerRuntimeVersion()) > 0) {\n+            throw new SkippedException(\"Docker version too old for this test. Expected >= 20.10.0\");\n+        }\n+        if (IS_PODMAN && ContainerRuntimeVersionTestUtils.PODMAN_MINIMAL_SUPPORTED_VERSION_CGROUPNS.compareTo(ContainerRuntimeVersionTestUtils.getContainerRuntimeVersion()) > 0) {\n+            throw new SkippedException(\"Podman version too old for this test. Expected >= 1.5.0\");\n+        }\n+    }\n+\n+    @Override\n+    public int compareTo(ContainerRuntimeVersionTestUtils other) {\n+        if (this.major > other.major) {\n+            return 1;\n+        } else if (this.major < other.major) {\n+            return -1;\n+        } else if (this.minor > other.minor) {\n+            return 1;\n+        } else if (this.minor < other.minor) {\n+            return -1;\n+        } else if (this.micro > other.micro) {\n+            return 1;\n+        } else if (this.micro < other.micro) {\n+            return -1;\n+        } else {\n+            \/\/ equal majors, minors, micro\n+            return 0;\n+        }\n+    }\n+\n+    public static ContainerRuntimeVersionTestUtils fromVersionString(String version) {\n+        try {\n+            \/\/ Example 'docker version 20.10.0 or podman version 4.9.4-rhel'\n+            String versNums = version.split(\"\\\\s+\", 3)[2];\n+            String[] numbers = versNums.split(\"-\")[0].split(\"\\\\.\", 3);\n+            return new ContainerRuntimeVersionTestUtils(Integer.parseInt(numbers[0]),\n+                    Integer.parseInt(numbers[1]),\n+                    Integer.parseInt(numbers[2]));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to parse container runtime version: \" + version);\n+        }\n+    }\n+\n+    public static String getContainerRuntimeVersionStr() {\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(Container.ENGINE_COMMAND, \"--version\");\n+            OutputAnalyzer out = new OutputAnalyzer(pb.start())\n+                    .shouldHaveExitValue(0);\n+            String result = out.asLines().get(0);\n+            System.out.println(Container.ENGINE_COMMAND + \" --version returning: \" + result);\n+            return result;\n+        } catch (Exception e) {\n+            throw new RuntimeException(Container.ENGINE_COMMAND + \" --version command failed.\");\n+        }\n+    }\n+\n+    public static ContainerRuntimeVersionTestUtils getContainerRuntimeVersion() {\n+        return ContainerRuntimeVersionTestUtils.fromVersionString(getContainerRuntimeVersionStr());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/ContainerRuntimeVersionTestUtils.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -93,0 +93,1 @@\n+    public static final String SafepointLatency = PREFIX + \"SafepointLatency\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -833,0 +833,1 @@\n+  public native long hostAvailableMemory();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}