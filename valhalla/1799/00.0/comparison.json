{"files":[{"patch":"@@ -177,14 +177,3 @@\n-  ifeq ($(call isCompiler, gcc), true)\n-    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing \\\n-        -fno-fat-lto-objects\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n-        -fuse-linker-plugin -fno-strict-aliasing\n-  else ifeq ($(call isCompiler, clang), true)\n-    JVM_CFLAGS_FEATURES += -flto -fno-strict-aliasing\n-    ifeq ($(call isBuildOs, aix), true)\n-      JVM_CFLAGS_FEATURES += -ffat-lto-objects\n-    endif\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto -fno-strict-aliasing\n-  else ifeq ($(call isCompiler, microsoft), true)\n-    JVM_CFLAGS_FEATURES += -GL\n-    JVM_LDFLAGS_FEATURES += -LTCG:INCREMENTAL\n+  JVM_LTO := true\n+  ifneq ($(call isCompiler, microsoft), true)\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM)\n@@ -193,0 +182,1 @@\n+  JVM_LTO := false\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+\/\/ Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1197,1 +1198,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1200,5 +1200,1 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_codestub_branch_size();\n-  }\n-\n-    \/\/ count one adr and one far branch instruction\n+    \/\/ count one branch instruction and one far call instruction sequence\n@@ -2255,19 +2251,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ mov rscratch1 #exception_blob_entry_point\n-  \/\/ br rscratch1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2284,0 +2261,1 @@\n+\n@@ -2285,0 +2263,3 @@\n+  Label start;\n+  __ bind(start);\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2286,2 +2267,2 @@\n-  __ adr(lr, __ pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -2290,0 +2271,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2291,1 +2274,1 @@\n-  return offset;\n+  return entry_offset;\n@@ -3382,1 +3365,1 @@\n-  enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{\n+  enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegL oldval, iRegL newval) %{\n@@ -3389,1 +3372,1 @@\n-  enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n+  enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegI oldval, iRegI newval) %{\n@@ -3396,1 +3379,1 @@\n-  enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n+  enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegI oldval, iRegI newval) %{\n@@ -3403,1 +3386,1 @@\n-  enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n+  enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegI oldval, iRegI newval) %{\n@@ -3411,1 +3394,1 @@\n-  enc_class aarch64_enc_cset_eq(iRegINoSp res) %{\n+  enc_class aarch64_enc_cset_eq(iRegI res) %{\n@@ -8458,1 +8441,1 @@\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8476,1 +8459,1 @@\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8494,1 +8477,1 @@\n-instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8512,1 +8495,1 @@\n-instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegLNoSp oldval, iRegLNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n@@ -8549,1 +8532,1 @@\n-instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n@@ -8570,1 +8553,1 @@\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8589,1 +8572,1 @@\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8608,1 +8591,1 @@\n-instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8627,1 +8610,1 @@\n-instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegLNoSp oldval, iRegLNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n@@ -8665,1 +8648,1 @@\n-instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":26,"deletions":43,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -455,2 +455,8 @@\n-  __ adr(lr, pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ b(start);\n+\n@@ -458,0 +464,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -460,1 +468,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _deopt_handler_size = 7 * NativeInstruction::instruction_size\n+    _deopt_handler_size = 4 * NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,0 +275,6 @@\n+  Label start;\n+  __ bind(start);\n+\n+  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+\n+  int entry_offset = __ offset();\n@@ -277,1 +283,1 @@\n-  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+  __ b(start);\n@@ -280,0 +286,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -282,1 +290,1 @@\n-  return offset;\n+  return entry_offset;\n@@ -2638,1 +2646,1 @@\n-    if (src_lo < src_hi) {\n+    if (src_lo->encoding() < src_hi->encoding()) {\n@@ -2642,1 +2650,1 @@\n-      assert(src_lo < Rtemp, \"Rtemp is higher than any allocatable register\");\n+      assert(src_lo->encoding() < Rtemp->encoding(), \"Rtemp is higher than any allocatable register\");\n@@ -2655,1 +2663,1 @@\n-    if (dest_lo < dest_hi) {\n+    if (dest_lo->encoding() < dest_hi->encoding()) {\n@@ -2658,1 +2666,1 @@\n-      assert(dest_lo < Rtemp, \"Rtemp is higher than any allocatable register\");\n+      assert(dest_lo->encoding() < Rtemp->encoding(), \"Rtemp is higher than any allocatable register\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -267,0 +267,3 @@\n+  Label start;\n+\n+  __ bind(start);\n@@ -268,0 +271,2 @@\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -270,0 +275,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -272,1 +279,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -275,1 +275,7 @@\n-  }  int offset = code_offset();\n+  }\n+\n+  int offset = code_offset();\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -279,0 +285,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -280,0 +291,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -282,1 +295,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -456,3 +456,9 @@\n-  InternalAddress here(__ pc());\n-  __ pushptr(here.addr(), rscratch1);\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n+\n@@ -461,0 +467,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -463,1 +471,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    _deopt_handler_size = 17\n+    _deopt_handler_size = 7\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_entry(), \"unexpected sender pc\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1425,0 +1425,1 @@\n+  using Assembler::evpcmpeqd;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1274,2 +1274,1 @@\n-  \/\/ Currently we only have them for AVX512\n-  if (supports_evex() && supports_avx512bw()) {\n+  if (UseAVX > 1) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2781,1 +2781,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2784,11 +2783,2 @@\n-  static uint size_exception_handler() {\n-    \/\/ NativeCall instruction size is the same as NativeJump.\n-    \/\/ exception handler starts out as jump and can be patched to\n-    \/\/ a call be deoptimization.  (4932387)\n-    \/\/ Note that this value is also credited (in output.cpp) to\n-    \/\/ the size of the code section.\n-    return NativeJump::instruction_size;\n-  }\n-\n-    \/\/ three 5 byte instructions plus one move for unreachable address.\n-    return 15+3;\n+    \/\/ one call and one jmp.\n+    return 7;\n@@ -2887,18 +2877,0 @@\n-\/\/ Emit exception handler code.\n-\/\/ Stuff framesize into a register and call a VM stub routine.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2917,4 +2889,4 @@\n-  address the_pc = (address) __ pc();\n-  Label next;\n-  \/\/ push a \"the_pc\" on the stack without destroying any registers\n-  \/\/ as they all may be live.\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2922,5 +2894,3 @@\n-  \/\/ push address of \"next\"\n-  __ call(next, relocInfo::none); \/\/ reloc none is fine since it is a disp32\n-  __ bind(next);\n-  \/\/ adjust it so it matches \"the_pc\"\n-  __ subptr(Address(rsp, 0), __ offset() - offset);\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n@@ -2928,1 +2898,2 @@\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2931,1 +2902,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":41,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+int volatile AOTMetaspace::_preimage_static_archive_dumped = 0;\n@@ -1061,0 +1062,5 @@\n+bool AOTMetaspace::preimage_static_archive_dumped() {\n+  assert(CDSConfig::is_dumping_preimage_static_archive(), \"Required\");\n+  return AtomicAccess::load_acquire(&_preimage_static_archive_dumped) == 1;\n+}\n+\n@@ -1062,0 +1068,9 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    \/\/ When dumping to the AOT configuration file ensure this function is only executed once.\n+    \/\/ Multiple invocations may happen via JCmd, during VM exit or other means (in the future)\n+    \/\/ from different threads and possibly concurrently.\n+    if (AtomicAccess::cmpxchg(&_preimage_static_archive_dumped, 0, 1) != 0) {\n+      return;\n+    }\n+  }\n+\n@@ -1360,2 +1375,5 @@\n-      aot_log_warning(aot)(\"Preload Warning: Verification failed for %s\",\n-                    ik->external_name());\n+      oop message = java_lang_Throwable::message(current->pending_exception());\n+      aot_log_warning(aot)(\"Preload Warning: Verification failed for %s because a %s was thrown: %s\",\n+                            ik->external_name(),\n+                            current->pending_exception()->klass()->external_name(),\n+                            message == nullptr ? \"(no message)\" : java_lang_String::as_utf8_string(message));\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1066,1 +1066,3 @@\n-    assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n+\n+    assert(compiler->type() == compiler_c2 ||\n+           offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -3452,0 +3453,1 @@\n+  const int cp_size = cp->length();\n@@ -3453,1 +3455,1 @@\n-  const u1* const current_start = cfs->current();\n+  const u1* const current_before_parsing = cfs->current();\n@@ -3462,1 +3464,1 @@\n-  const int attribute_array_length = cfs->get_u2_fast();\n+  const int num_bootstrap_methods = cfs->get_u2_fast();\n@@ -3464,1 +3466,1 @@\n-  guarantee_property(_max_bootstrap_specifier_index < attribute_array_length,\n+  guarantee_property(_max_bootstrap_specifier_index < num_bootstrap_methods,\n@@ -3468,0 +3470,1 @@\n+  const u4 bootstrap_methods_u2_len = (attribute_byte_length - sizeof(u2)) \/ sizeof(u2);\n@@ -3469,14 +3472,1 @@\n-  \/\/ The attribute contains a counted array of counted tuples of shorts,\n-  \/\/ represending bootstrap specifiers:\n-  \/\/    length*{bootstrap_method_index, argument_count*{argument_index}}\n-  const unsigned int operand_count = (attribute_byte_length - (unsigned)sizeof(u2)) \/ (unsigned)sizeof(u2);\n-  \/\/ operand_count = number of shorts in attr, except for leading length\n-\n-  \/\/ The attribute is copied into a short[] array.\n-  \/\/ The array begins with a series of short[2] pairs, one for each tuple.\n-  const int index_size = (attribute_array_length * 2);\n-\n-  Array<u2>* const operands =\n-    MetadataFactory::new_array<u2>(_loader_data, index_size + operand_count, CHECK);\n-\n-  \/\/ Eagerly assign operands so they will be deallocated with the constant\n+  \/\/ Eagerly assign the arrays so that they will be deallocated with the constant\n@@ -3484,8 +3474,5 @@\n-  cp->set_operands(operands);\n-\n-  int operand_fill_index = index_size;\n-  const int cp_size = cp->length();\n-\n-  for (int n = 0; n < attribute_array_length; n++) {\n-    \/\/ Store a 32-bit offset into the header of the operand array.\n-    ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);\n+  BSMAttributeEntries::InsertionIterator iter =\n+    cp->bsm_entries().start_extension(num_bootstrap_methods,\n+                                      bootstrap_methods_u2_len,\n+                                      _loader_data,\n+                                      CHECK);\n@@ -3493,1 +3480,1 @@\n-    \/\/ Read a bootstrap specifier.\n+  for (int i = 0; i < num_bootstrap_methods; i++) {\n@@ -3495,2 +3482,2 @@\n-    const u2 bootstrap_method_index = cfs->get_u2_fast();\n-    const u2 argument_count = cfs->get_u2_fast();\n+    u2 bootstrap_method_ref = cfs->get_u2_fast();\n+    u2 num_bootstrap_arguments = cfs->get_u2_fast();\n@@ -3498,15 +3485,13 @@\n-      valid_cp_range(bootstrap_method_index, cp_size) &&\n-      cp->tag_at(bootstrap_method_index).is_method_handle(),\n-      \"bootstrap_method_index %u has bad constant type in class file %s\",\n-      bootstrap_method_index,\n-      CHECK);\n-\n-    guarantee_property((operand_fill_index + 1 + argument_count) < operands->length(),\n-      \"Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s\",\n-      CHECK);\n-\n-    operands->at_put(operand_fill_index++, bootstrap_method_index);\n-    operands->at_put(operand_fill_index++, argument_count);\n-\n-    cfs->guarantee_more(sizeof(u2) * argument_count, CHECK);  \/\/ argv[argc]\n-    for (int j = 0; j < argument_count; j++) {\n+       valid_cp_range(bootstrap_method_ref, cp_size) &&\n+       cp->tag_at(bootstrap_method_ref).is_method_handle(),\n+       \"bootstrap_method_index %u has bad constant type in class file %s\",\n+       bootstrap_method_ref,\n+       CHECK);\n+    cfs->guarantee_more(sizeof(u2) * num_bootstrap_arguments, CHECK); \/\/ argv[argc]\n+\n+    BSMAttributeEntry* entry = iter.reserve_new_entry(bootstrap_method_ref, num_bootstrap_arguments);\n+    guarantee_property(entry != nullptr,\n+                       \"Invalid BootstrapMethods num_bootstrap_methods.\"\n+                       \" The total amount of space reserved for the BootstrapMethod attribute was not sufficient\", CHECK);\n+\n+    for (int argi = 0; argi < num_bootstrap_arguments; argi++) {\n@@ -3520,1 +3505,1 @@\n-      operands->at_put(operand_fill_index++, argument_index);\n+      entry->set_argument(argi, argument_index);\n@@ -3523,1 +3508,2 @@\n-  guarantee_property(current_start + attribute_byte_length == cfs->current(),\n+  cp->bsm_entries().end_extension(iter, _loader_data, CHECK);\n+  guarantee_property(current_before_parsing + attribute_byte_length == cfs->current(),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":31,"deletions":45,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -471,21 +471,19 @@\n-  JImageLocationRef location = jimage_find_resource(\"\", name, is_preview, &size);\n-\n-  if (location == 0) {\n-    TempNewSymbol class_name = SymbolTable::new_symbol(name);\n-    TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n-\n-    if (pkg_name != nullptr) {\n-      if (!Universe::is_module_initialized()) {\n-        location = jimage_find_resource(JAVA_BASE_NAME, name, is_preview, &size);\n-      } else {\n-        PackageEntry* package_entry = ClassLoader::get_package_entry(pkg_name, loader_data);\n-        if (package_entry != nullptr) {\n-          ResourceMark rm(current);\n-          \/\/ Get the module name\n-          ModuleEntry* module = package_entry->module();\n-          assert(module != nullptr, \"Boot classLoader package missing module\");\n-          assert(module->is_named(), \"Boot classLoader package is in unnamed module\");\n-          const char* module_name = module->name()->as_C_string();\n-          if (module_name != nullptr) {\n-            location = jimage_find_resource(module_name, name, is_preview, &size);\n-          }\n+  JImageLocationRef location = 0;\n+\n+  TempNewSymbol class_name = SymbolTable::new_symbol(name);\n+  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n+\n+  if (pkg_name != nullptr) {\n+    if (!Universe::is_module_initialized()) {\n+      location = jimage_find_resource(JAVA_BASE_NAME, name, is_preview, &size);\n+    } else {\n+      PackageEntry* package_entry = ClassLoader::get_package_entry(pkg_name, loader_data);\n+      if (package_entry != nullptr) {\n+        ResourceMark rm(current);\n+        \/\/ Get the module name\n+        ModuleEntry* module = package_entry->module();\n+        assert(module != nullptr, \"Boot classLoader package missing module\");\n+        assert(module->is_named(), \"Boot classLoader package is in unnamed module\");\n+        const char* module_name = module->name()->as_C_string();\n+        if (module_name != nullptr) {\n+          location = jimage_find_resource(module_name, name, is_preview, &size);\n@@ -496,0 +494,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1320,1 +1320,1 @@\n-    _deopt_handler_offset    = 0;\n+    _deopt_handler_entry_offset    = 0;\n@@ -1460,1 +1460,1 @@\n-  _deopt_handler_offset         = nm._deopt_handler_offset;\n+  _deopt_handler_entry_offset   = nm._deopt_handler_entry_offset;\n@@ -1722,1 +1722,1 @@\n-        _deopt_handler_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n+        _deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -1724,1 +1724,1 @@\n-        _deopt_handler_offset    = -1;\n+        _deopt_handler_entry_offset    = -1;\n@@ -1730,1 +1730,0 @@\n-      assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must be set\");\n@@ -1733,2 +1732,10 @@\n-      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n-      _deopt_handler_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      bool has_exception_handler = (offsets->value(CodeOffsets::Exceptions) != -1);\n+      assert(has_exception_handler == (compiler->type() != compiler_c2),\n+             \"C2 compiler doesn't provide exception handler stub code.\");\n+      if (has_exception_handler) {\n+        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      } else {\n+        _exception_offset = -1;\n+      }\n+\n+      _deopt_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -4049,1 +4056,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_offset != -1 &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-  int _deopt_handler_offset;\n+  int _deopt_handler_entry_offset;\n@@ -625,1 +625,1 @@\n-  address deopt_handler_begin   () const { return           header_begin() + _deopt_handler_offset    ; }\n+  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+  static bool _is_shutting_down;\n+\n@@ -212,0 +214,1 @@\n+ public:\n@@ -215,2 +218,0 @@\n- public:\n-\n@@ -248,6 +249,1 @@\n-  bool is_shutting_down() const;\n-\n-  \/\/ If the VM is shutting down, we may have skipped VM_CollectForAllocation.\n-  \/\/ In this case, stall the allocation request briefly in the hope that\n-  \/\/ the VM shutdown completes before the allocation request returns.\n-  void stall_for_vm_shutdown();\n+  static bool is_shutting_down();\n@@ -255,1 +251,1 @@\n-  void before_exit();\n+  void initiate_shutdown();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n+  inline void arraycopy_marking(T* dst, size_t count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,4 +391,2 @@\n-  \/\/ may have forwarded objects. In this case, the `arraycopy_work` is first called with HAS_FWD=true and\n-  \/\/ ENQUEUE=false.\n-  assert(HAS_FWD == _heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(),\n-         \"Forwarded object status is sane\");\n+  \/\/ may have forwarded objects.\n+  assert(HAS_FWD == _heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded object status is sane\");\n@@ -397,1 +395,1 @@\n-  assert((HAS_FWD || EVAC) != ENQUEUE, \"Cannot evacuate and mark both sides of copy.\");\n+  static_assert((HAS_FWD || EVAC) != ENQUEUE, \"Cannot evacuate and mark both sides of copy.\");\n@@ -416,1 +414,1 @@\n-      if (ENQUEUE && !ctx->is_marked_strong_or_old(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n@@ -430,1 +428,8 @@\n-  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n+  const char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n+  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+    \/\/ If marking old or young, we must evaluate the SATB barrier. This will be the only\n+    \/\/ action if we are not marking old. If we are marking old, we must still evaluate the\n+    \/\/ load reference barrier for a young collection.\n+    arraycopy_marking(dst, count);\n+  }\n+\n@@ -432,0 +437,1 @@\n+    assert((gc_state & ShenandoahHeap::YOUNG_MARKING) == 0, \"Cannot be marking young during evacuation\");\n@@ -434,0 +440,1 @@\n+    assert((gc_state & ShenandoahHeap::YOUNG_MARKING) == 0, \"Cannot be marking young during update-refs\");\n@@ -436,12 +443,0 @@\n-\n-  if (_heap->mode()->is_generational()) {\n-    assert(ShenandoahSATBBarrier, \"Generational mode assumes SATB mode\");\n-    if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, false);\n-    }\n-    if ((gc_state & ShenandoahHeap::OLD_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, true);\n-    }\n-  } else if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    arraycopy_marking(src, dst, count, false);\n-  }\n@@ -451,1 +446,1 @@\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* dst, size_t count) {\n@@ -453,38 +448,2 @@\n-  \/*\n-   * Note that an old-gen object is considered live if it is live at the start of OLD marking or if it is promoted\n-   * following the start of OLD marking.\n-   *\n-   * 1. Every object promoted following the start of OLD marking will be above TAMS within its old-gen region\n-   * 2. Every object live at the start of OLD marking will be referenced from a \"root\" or it will be referenced from\n-   *    another live OLD-gen object.  With regards to old-gen, roots include stack locations and all of live young-gen.\n-   *    All root references to old-gen are identified during a bootstrap young collection.  All references from other\n-   *    old-gen objects will be marked during the traversal of all old objects, or will be marked by the SATB barrier.\n-   *\n-   * During old-gen marking (which is interleaved with young-gen collections), call arraycopy_work() if:\n-   *\n-   * 1. The overwritten array resides in old-gen and it is below TAMS within its old-gen region\n-   * 2. Do not call arraycopy_work for any array residing in young-gen because young-gen collection is idle at this time\n-   *\n-   * During young-gen marking, call arraycopy_work() if:\n-   *\n-   * 1. The overwritten array resides in young-gen and is below TAMS within its young-gen region\n-   * 2. Additionally, if array resides in old-gen, regardless of its relationship to TAMS because this old-gen array\n-   *    may hold references to young-gen\n-   *\/\n-    T* array = dst;\n-    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n-    ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n-    if (is_old_marking) {\n-      \/\/ Generational, old marking\n-      assert(_heap->mode()->is_generational(), \"Invariant\");\n-      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (_heap->mode()->is_generational()) {\n-      \/\/ Generational, young marking\n-      if (r->is_old() || (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n-      \/\/ Non-generational, marking\n-      arraycopy_work<T, false, false, true>(array, count);\n+    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(dst))) {\n+      arraycopy_work<T, false, false, true>(dst, count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":17,"deletions":58,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-            top_frame = frame(synthetic_sp, synthetic_sp, sender_sp, pc_desc->real_pc(sampled_nm), sampled_nm);\n+            top_frame = frame(synthetic_sp, synthetic_sp, sender_sp - 2, pc_desc->real_pc(sampled_nm), sampled_nm);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-volatile bool   Universe::_is_shutting_down = false;\n@@ -1405,7 +1404,5 @@\n-  {\n-    \/\/ Acquire the Heap_lock to synchronize with VM_Heap_Sync_Operations,\n-    \/\/ which may depend on the value of _is_shutting_down flag.\n-    MutexLocker hl(Heap_lock);\n-    log_cpu_time();\n-    AtomicAccess::release_store(&_is_shutting_down, true);\n-  }\n+  \/\/ Tell the GC that it is time to shutdown and to block requests for new GC pauses.\n+  heap()->initiate_shutdown();\n+\n+  \/\/ Log CPU time statistics before stopping the GC threads.\n+  log_cpu_time();\n@@ -1413,1 +1410,2 @@\n-  heap()->before_exit();\n+  \/\/ Stop the GC threads.\n+  heap()->stop();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -131,3 +131,0 @@\n-  \/\/ Shutdown\n-  static volatile bool _is_shutting_down;\n-\n@@ -336,2 +333,0 @@\n-  static bool is_shutting_down()                  { return  AtomicAccess::load_acquire(&_is_shutting_down); }\n-\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -136,2 +136,1 @@\n-  MetadataFactory::free_array<jushort>(loader_data, operands());\n-  set_operands(nullptr);\n+  bsm_entries().deallocate_contents(loader_data);\n@@ -157,1 +156,2 @@\n-  it->push(&_operands);\n+  it->push(&bsm_entries().offsets());\n+  it->push(&bsm_entries().bootstrap_methods());\n@@ -793,1 +793,1 @@\n-    log_debug(class, resolve)(\"bad operand %d in:\", which); cpool->print();\n+    log_debug(class, resolve)(\"bad BSM %d in:\", which); cpool->print();\n@@ -1594,2 +1594,2 @@\n-    bool match_operand = compare_operand_to(i1, cp2, i2);\n-    return (match_entry && match_operand);\n+    bool match_bsm = compare_bootstrap_entry_to(i1, cp2, i2);\n+    return (match_entry && match_bsm);\n@@ -1605,2 +1605,2 @@\n-    bool match_operand = compare_operand_to(i1, cp2, i2);\n-    return (match_entry && match_operand);\n+    bool match_bsm = compare_bootstrap_entry_to(i1, cp2, i2);\n+    return (match_entry && match_bsm);\n@@ -1640,34 +1640,1 @@\n-\n-\/\/ Resize the operands array with delta_len and delta_size.\n-\/\/ Used in RedefineClasses for CP merge.\n-void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {\n-  int old_len  = operand_array_length(operands());\n-  int new_len  = old_len + delta_len;\n-  int min_len  = (delta_len > 0) ? old_len : new_len;\n-\n-  int old_size = operands()->length();\n-  int new_size = old_size + delta_size;\n-  int min_size = (delta_size > 0) ? old_size : new_size;\n-\n-  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-  Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, new_size, CHECK);\n-\n-  \/\/ Set index in the resized array for existing elements only\n-  for (int idx = 0; idx < min_len; idx++) {\n-    int offset = operand_offset_at(idx);                       \/\/ offset in original array\n-    operand_offset_at_put(new_ops, idx, offset + 2*delta_len); \/\/ offset in resized array\n-  }\n-  \/\/ Copy the bootstrap specifiers only\n-  Copy::conjoint_memory_atomic(operands()->adr_at(2*old_len),\n-                               new_ops->adr_at(2*new_len),\n-                               (min_size - 2*min_len) * sizeof(u2));\n-  \/\/ Explicitly deallocate old operands array.\n-  \/\/ Note, it is not needed for 7u backport.\n-  if ( operands() != nullptr) { \/\/ the safety check\n-    MetadataFactory::free_array<u2>(loader_data, operands());\n-  }\n-  set_operands(new_ops);\n-} \/\/ end resize_operands()\n-\n-\n-\/\/ Extend the operands array with the length and size of the ext_cp operands.\n+\/\/ Extend the BSMAttributeEntries with the length and size of the ext_cp BSMAttributeEntries.\n@@ -1675,18 +1642,7 @@\n-void ConstantPool::extend_operands(const constantPoolHandle& ext_cp, TRAPS) {\n-  int delta_len = operand_array_length(ext_cp->operands());\n-  if (delta_len == 0) {\n-    return; \/\/ nothing to do\n-  }\n-  int delta_size = ext_cp->operands()->length();\n-\n-  assert(delta_len  > 0 && delta_size > 0, \"extended operands array must be bigger\");\n-\n-  if (operand_array_length(operands()) == 0) {\n-    ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-    Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, delta_size, CHECK);\n-    \/\/ The first element index defines the offset of second part\n-    operand_offset_at_put(new_ops, 0, 2*delta_len); \/\/ offset in new array\n-    set_operands(new_ops);\n-  } else {\n-    resize_operands(delta_len, delta_size, CHECK);\n-  }\n+BSMAttributeEntries::InsertionIterator\n+ConstantPool::start_extension(const constantPoolHandle& ext_cp, TRAPS) {\n+  BSMAttributeEntries::InsertionIterator iter =\n+    bsm_entries().start_extension(ext_cp->bsm_entries(), pool_holder()->class_loader_data(),\n+                                  CHECK_(BSMAttributeEntries::InsertionIterator()));\n+  return iter;\n+}\n@@ -1694,1 +1650,3 @@\n-} \/\/ end extend_operands()\n+void ConstantPool::end_extension(BSMAttributeEntries::InsertionIterator iter, TRAPS) {\n+  bsm_entries().end_extension(iter, pool_holder()->class_loader_data(), THREAD);\n+}\n@@ -1697,76 +1655,7 @@\n-\/\/ Shrink the operands array to a smaller array with new_len length.\n-\/\/ Used in RedefineClasses for CP merge.\n-void ConstantPool::shrink_operands(int new_len, TRAPS) {\n-  int old_len = operand_array_length(operands());\n-  if (new_len == old_len) {\n-    return; \/\/ nothing to do\n-  }\n-  assert(new_len < old_len, \"shrunken operands array must be smaller\");\n-\n-  int free_base  = operand_next_offset_at(new_len - 1);\n-  int delta_len  = new_len - old_len;\n-  int delta_size = 2*delta_len + free_base - operands()->length();\n-\n-  resize_operands(delta_len, delta_size, CHECK);\n-\n-} \/\/ end shrink_operands()\n-\n-\n-void ConstantPool::copy_operands(const constantPoolHandle& from_cp,\n-                                 const constantPoolHandle& to_cp,\n-                                 TRAPS) {\n-\n-  int from_oplen = operand_array_length(from_cp->operands());\n-  int old_oplen  = operand_array_length(to_cp->operands());\n-  if (from_oplen != 0) {\n-    ClassLoaderData* loader_data = to_cp->pool_holder()->class_loader_data();\n-    \/\/ append my operands to the target's operands array\n-    if (old_oplen == 0) {\n-      \/\/ Can't just reuse from_cp's operand list because of deallocation issues\n-      int len = from_cp->operands()->length();\n-      Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, len, CHECK);\n-      Copy::conjoint_memory_atomic(\n-          from_cp->operands()->adr_at(0), new_ops->adr_at(0), len * sizeof(u2));\n-      to_cp->set_operands(new_ops);\n-    } else {\n-      int old_len  = to_cp->operands()->length();\n-      int from_len = from_cp->operands()->length();\n-      int old_off  = old_oplen * sizeof(u2);\n-      int from_off = from_oplen * sizeof(u2);\n-      \/\/ Use the metaspace for the destination constant pool\n-      Array<u2>* new_operands = MetadataFactory::new_array<u2>(loader_data, old_len + from_len, CHECK);\n-      int fillp = 0, len = 0;\n-      \/\/ first part of dest\n-      Copy::conjoint_memory_atomic(to_cp->operands()->adr_at(0),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = old_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ first part of src\n-      Copy::conjoint_memory_atomic(from_cp->operands()->adr_at(0),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = from_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ second part of dest\n-      Copy::conjoint_memory_atomic(to_cp->operands()->adr_at(old_off),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = old_len - old_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ second part of src\n-      Copy::conjoint_memory_atomic(from_cp->operands()->adr_at(from_off),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = from_len - from_off) * sizeof(u2));\n-      fillp += len;\n-      assert(fillp == new_operands->length(), \"\");\n-\n-      \/\/ Adjust indexes in the first part of the copied operands array.\n-      for (int j = 0; j < from_oplen; j++) {\n-        int offset = operand_offset_at(new_operands, old_oplen + j);\n-        assert(offset == operand_offset_at(from_cp->operands(), j), \"correct copy\");\n-        offset += old_len;  \/\/ every new tuple is preceded by old_len extra u2's\n-        operand_offset_at_put(new_operands, old_oplen + j, offset);\n-      }\n-      \/\/ replace target operands array with combined array\n-      to_cp->set_operands(new_operands);\n-    }\n-  }\n-} \/\/ end copy_operands()\n+void ConstantPool::copy_bsm_entries(const constantPoolHandle& from_cp,\n+                                    const constantPoolHandle& to_cp,\n+                                    TRAPS) {\n+  to_cp->bsm_entries().append(from_cp->bsm_entries(),\n+                              to_cp->pool_holder()->class_loader_data(),\n+                              THREAD);\n+}\n@@ -1803,1 +1692,1 @@\n-  copy_operands(from_cp, to_cp, CHECK);\n+  copy_bsm_entries(from_cp, to_cp, THREAD);\n@@ -1927,1 +1816,1 @@\n-    k1 += operand_array_length(to_cp->operands());  \/\/ to_cp might already have operands\n+    k1 += to_cp->bsm_entries().array_length();  \/\/ to_cp might already have a BSM attribute\n@@ -1935,1 +1824,1 @@\n-    k1 += operand_array_length(to_cp->operands());  \/\/ to_cp might already have operands\n+    k1 += to_cp->bsm_entries().array_length();  \/\/ to_cp might already have a BSM attribute\n@@ -1971,3 +1860,3 @@\n-bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle& cp2, int idx2) {\n-  BSMAttributeEntry* e1 = bsm_attribute_entry(idx1);\n-  BSMAttributeEntry* e2 = cp2->bsm_attribute_entry(idx2);\n+bool ConstantPool::compare_bootstrap_entry_to(int idx1, const constantPoolHandle& cp2, int idx2) {\n+  const BSMAttributeEntry* const e1 = bsm_attribute_entry(idx1);\n+  const BSMAttributeEntry* const e2 = cp2->bsm_attribute_entry(idx2);\n@@ -1981,9 +1870,12 @@\n-  int argc = e1->argument_count();\n-  if (argc == e2->argument_count()) {\n-    for (int j = 0; j < argc; j++) {\n-      k1 = e1->argument_index(j);\n-      k2 = e2->argument_index(j);\n-      match = compare_entry_to(k1, cp2, k2);\n-      if (!match) {\n-        return false;\n-      }\n+\n+  const int argc = e1->argument_count();\n+  if (argc != e2->argument_count()) {\n+    return false;\n+  }\n+\n+  for (int j = 0; j < argc; j++) {\n+    k1 = e1->argument(j);\n+    k2 = e2->argument(j);\n+    match = compare_entry_to(k1, cp2, k2);\n+    if (!match) {\n+      return false;\n@@ -1991,3 +1883,3 @@\n-    return true;           \/\/ got through loop; all elements equal\n-  return false;\n-} \/\/ end compare_operand_to()\n+\n+  return true; \/\/ got through loop; all elements equal\n+} \/\/ end compare_bootstrap_entry_to()\n@@ -1999,4 +1891,4 @@\n-int ConstantPool::find_matching_operand(int pattern_i,\n-                    const constantPoolHandle& search_cp, int search_len) {\n-  for (int i = 0; i < search_len; i++) {\n-    bool found = compare_operand_to(pattern_i, search_cp, i);\n+int ConstantPool::find_matching_bsm_entry(int pattern_i,\n+                                          const constantPoolHandle& search_cp, int offset_limit) {\n+  for (int i = 0; i < offset_limit; i++) {\n+    bool found = compare_bootstrap_entry_to(pattern_i, search_cp, i);\n@@ -2008,1 +1900,1 @@\n-} \/\/ end find_matching_operand()\n+} \/\/ end find_matching_bsm_entry()\n@@ -2443,1 +2335,1 @@\n-  if (operands() != nullptr)  st->print(\"\/operands[%d]\", operands()->length());\n+  if (!bsm_entries().is_empty())  st->print(\"\/BSMs[%d]\", bsm_entries().bootstrap_methods()->length());\n@@ -2478,0 +2370,84 @@\n+\n+void BSMAttributeEntries::deallocate_contents(ClassLoaderData* loader_data) {\n+  MetadataFactory::free_array<u4>(loader_data, this->_offsets);\n+  MetadataFactory::free_array<u2>(loader_data, this->_bootstrap_methods);\n+  this->_offsets = nullptr;\n+  this->_bootstrap_methods = nullptr;\n+}\n+\n+void BSMAttributeEntries::copy_into(InsertionIterator& iter, int num_entries) const {\n+  assert(num_entries + iter._cur_offset <= iter._insert_into->_offsets->length(), \"must\");\n+  for (int i = 0; i < num_entries; i++) {\n+    const BSMAttributeEntry* e = entry(i);\n+    BSMAttributeEntry* e_new = iter.reserve_new_entry(e->bootstrap_method_index(), e->argument_count());\n+    assert(e_new != nullptr, \"must be\");\n+    e->copy_args_into(e_new);\n+  }\n+}\n+\n+BSMAttributeEntries::InsertionIterator\n+BSMAttributeEntries::start_extension(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS) {\n+  InsertionIterator iter = start_extension(other.number_of_entries(), other.array_length(),\n+                                           loader_data, CHECK_(BSMAttributeEntries::InsertionIterator()));\n+  return iter;\n+}\n+\n+BSMAttributeEntries::InsertionIterator\n+BSMAttributeEntries::start_extension(int number_of_entries, int array_length,\n+                                     ClassLoaderData* loader_data, TRAPS) {\n+  InsertionIterator extension_iterator(this, this->number_of_entries(), this->array_length());\n+  int new_number_of_entries = this->number_of_entries() + number_of_entries;\n+  int new_array_length = this->array_length() + array_length;\n+  int invalid_index = new_array_length;\n+\n+  Array<u4>* new_offsets =\n+    MetadataFactory::new_array<u4>(loader_data, new_number_of_entries, invalid_index, CHECK_(InsertionIterator()));\n+  Array<u2>* new_array = MetadataFactory::new_array<u2>(loader_data, new_array_length, CHECK_(InsertionIterator()));\n+  { \/\/ Copy over all the old BSMAEntry's and their respective offsets\n+    BSMAttributeEntries carrier(new_offsets, new_array);\n+    InsertionIterator copy_iter(&carrier, 0, 0);\n+    copy_into(copy_iter, this->number_of_entries());\n+  }\n+  \/\/ Replace content\n+  deallocate_contents(loader_data);\n+  _offsets = new_offsets;\n+  _bootstrap_methods = new_array;\n+  return extension_iterator;\n+}\n+\n+\n+void BSMAttributeEntries::append(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS) {\n+  if (other.number_of_entries() == 0) {\n+    return; \/\/ Done!\n+  }\n+  InsertionIterator iter = start_extension(other, loader_data, CHECK);\n+  other.copy_into(iter, other.number_of_entries());\n+  end_extension(iter, loader_data, THREAD);\n+}\n+\n+void BSMAttributeEntries::end_extension(InsertionIterator& iter, ClassLoaderData* loader_data, TRAPS) {\n+  assert(iter._insert_into == this, \"must be\");\n+  assert(iter._cur_offset <= this->_offsets->length(), \"must be\");\n+  assert(iter._cur_array <= this->_bootstrap_methods->length(), \"must be\");\n+\n+  \/\/ Did we fill up all of the available space? If so, do nothing.\n+  if (iter._cur_offset == this->_offsets->length() &&\n+      iter._cur_array == this->_bootstrap_methods->length()) {\n+    return;\n+  }\n+\n+  \/\/ We used less, truncate by allocating new arrays\n+  Array<u4>* new_offsets =\n+      MetadataFactory::new_array<u4>(loader_data, iter._cur_offset, 0, CHECK);\n+  Array<u2>* new_array =\n+    MetadataFactory::new_array<u2>(loader_data, iter._cur_array, CHECK);\n+  { \/\/ Copy over the constructed BSMAEntry's\n+    BSMAttributeEntries carrier(new_offsets, new_array);\n+    InsertionIterator copy_iter(&carrier, 0, 0);\n+    copy_into(copy_iter, iter._cur_offset);\n+  }\n+\n+  deallocate_contents(loader_data);\n+  _offsets = new_offsets;\n+  _bootstrap_methods = new_array;\n+}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":137,"deletions":161,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -80,37 +81,0 @@\n-class BSMAttributeEntry {\n-  friend class ConstantPool;\n-  u2 _bootstrap_method_index;\n-  u2 _argument_count;\n-\n-  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n-  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n-  \/\/ So in order to find the argument array, jump over ourselves.\n-  const u2* argument_indexes() const {\n-    return reinterpret_cast<const u2*>(this + 1);\n-  }\n-  u2* argument_indexes() {\n-    return reinterpret_cast<u2*>(this + 1);\n-  }\n-  \/\/ These are overlays on top of the operands array. Do not construct.\n-  BSMAttributeEntry() = delete;\n-\n-public:\n-  \/\/ Offsets for SA\n-  enum {\n-    _bsmi_offset = 0,\n-    _argc_offset = 1,\n-    _argv_offset = 2\n-  };\n-\n-  int bootstrap_method_index() const {\n-    return _bootstrap_method_index;\n-  }\n-  int argument_count() const {\n-    return _argument_count;\n-  }\n-  int argument_index(int n) const {\n-    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n-    return argument_indexes()[n];\n-  }\n-};\n-\n@@ -129,1 +93,2 @@\n-  Array<u2>*           _operands;    \/\/ for variable-sized (InvokeDynamic) nodes, usually empty\n+\n+  BSMAttributeEntries _bsm_entries;\n@@ -170,2 +135,0 @@\n-  void set_operands(Array<u2>* operands)       { _operands = operands; }\n-\n@@ -211,1 +174,7 @@\n-  Array<u2>* operands() const               { return _operands; }\n+\n+  BSMAttributeEntries& bsm_entries() {\n+    return _bsm_entries;\n+  }\n+  const BSMAttributeEntries& bsm_entries() const {\n+    return _bsm_entries;\n+  }\n@@ -559,46 +528,0 @@\n-  \/\/ The first part of the operands array consists of an index into the second part.\n-  \/\/ Extract a 32-bit index value from the first part.\n-  static int operand_offset_at(Array<u2>* operands, int bsms_attribute_index) {\n-    int n = (bsms_attribute_index * 2);\n-    assert(n >= 0 && n+2 <= operands->length(), \"oob\");\n-    \/\/ The first 32-bit index points to the beginning of the second part\n-    \/\/ of the operands array.  Make sure this index is in the first part.\n-    DEBUG_ONLY(int second_part = build_int_from_shorts(operands->at(0),\n-                                                       operands->at(1)));\n-    assert(second_part == 0 || n+2 <= second_part, \"oob (2)\");\n-    int offset = build_int_from_shorts(operands->at(n+0),\n-                                       operands->at(n+1));\n-    \/\/ The offset itself must point into the second part of the array.\n-    assert(offset == 0 || (offset >= second_part && offset <= operands->length()), \"oob (3)\");\n-    return offset;\n-  }\n-  static void operand_offset_at_put(Array<u2>* operands, int bsms_attribute_index, int offset) {\n-    int n = bsms_attribute_index * 2;\n-    assert(n >= 0 && n+2 <= operands->length(), \"oob\");\n-    operands->at_put(n+0, extract_low_short_from_int(offset));\n-    operands->at_put(n+1, extract_high_short_from_int(offset));\n-  }\n-  static int operand_array_length(Array<u2>* operands) {\n-    if (operands == nullptr || operands->length() == 0)  return 0;\n-    int second_part = operand_offset_at(operands, 0);\n-    return (second_part \/ 2);\n-  }\n-\n-#ifdef ASSERT\n-  \/\/ operand tuples fit together exactly, end to end\n-  static int operand_limit_at(Array<u2>* operands, int bsms_attribute_index) {\n-    int nextidx = bsms_attribute_index + 1;\n-    if (nextidx == operand_array_length(operands))\n-      return operands->length();\n-    else\n-      return operand_offset_at(operands, nextidx);\n-  }\n-#endif \/\/ASSERT\n-\n-  \/\/ These functions are used in RedefineClasses for CP merge\n-  int operand_offset_at(int bsms_attribute_index) {\n-    assert(0 <= bsms_attribute_index &&\n-           bsms_attribute_index < operand_array_length(operands()),\n-           \"Corrupted CP operands\");\n-    return operand_offset_at(operands(), bsms_attribute_index);\n-  }\n@@ -607,22 +530,13 @@\n-    int offset = operand_offset_at(bsms_attribute_index);\n-    return reinterpret_cast<BSMAttributeEntry*>(operands()->adr_at(offset));\n-  }\n-\n-  int operand_next_offset_at(int bsms_attribute_index) {\n-    BSMAttributeEntry* bsme = bsm_attribute_entry(bsms_attribute_index);\n-    u2* argv_start = bsme->argument_indexes();\n-    int offset = argv_start - operands()->data();\n-    return offset + bsme->argument_count();\n-  }\n-  \/\/ Compare a bootstrap specifier data in the operands arrays\n-  bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle& cp2,\n-                          int bsms_attribute_index2);\n-  \/\/ Find a bootstrap specifier data in the operands array\n-  int find_matching_operand(int bsms_attribute_index, const constantPoolHandle& search_cp,\n-                            int operands_cur_len);\n-  \/\/ Resize the operands array with delta_len and delta_size\n-  void resize_operands(int delta_len, int delta_size, TRAPS);\n-  \/\/ Extend the operands array with the length and size of the ext_cp operands\n-  void extend_operands(const constantPoolHandle& ext_cp, TRAPS);\n-  \/\/ Shrink the operands array to a smaller array with new_len length\n-  void shrink_operands(int new_len, TRAPS);\n+    return _bsm_entries.entry(bsms_attribute_index);\n+  }\n+\n+  bool compare_bootstrap_entry_to(int bsms_attribute_index1, const constantPoolHandle& cp2,\n+                                  int bsms_attribute_index2);\n+  \/\/ Find a BSM entry in search_cp that matches the BSM at bsm_attribute_index.\n+  \/\/ Return -1 if not found.\n+  int find_matching_bsm_entry(int bsms_attribute_index, const constantPoolHandle& search_cp,\n+                              int offset_limit);\n+  \/\/ Extend the BSM attribute storage to fit both the current data and the BSM data in ext_cp.\n+  \/\/ Use the returned InsertionIterator to fill out the newly allocated space.\n+  BSMAttributeEntries::InsertionIterator start_extension(const constantPoolHandle& ext_cp, TRAPS);\n+  void end_extension(BSMAttributeEntries::InsertionIterator iter, TRAPS);\n@@ -644,1 +558,1 @@\n-    return bsm_attribute_entry(bsmai)->argument_index(j);\n+    return bsm_attribute_entry(bsmai)->argument(j);\n@@ -851,1 +765,1 @@\n-  static void copy_operands(const constantPoolHandle& from_cp, const constantPoolHandle& to_cp, TRAPS);\n+  static void copy_bsm_entries(const constantPoolHandle& from_cp, const constantPoolHandle& to_cp, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":25,"deletions":111,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-          \"as well by using CompileCommand=PrintPhaseLevel.\")                        \\\n+          \"as well by using CompileCommand=PhasePrintLevel.\")               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5823,1 +5823,1 @@\n-  return PrintPhaseLevel > 0 && directive()->PhasePrintLevelOption >= level &&\n+  return PrintPhaseLevel >= 0 && directive()->PhasePrintLevelOption >= level &&\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1982,0 +1982,2 @@\n+  Node* new_assertion_predicate_opaque_init(Node* entry_control, Node* init, Node* int_zero);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4363,0 +4363,27 @@\n+#ifdef ASSERT\n+\n+\/\/ Moves Template Assertion Predicates to a target loop by cloning and killing the old ones. The target loop is the\n+\/\/ original, not-cloned loop. This is currently only used with StressLoopBackedge which is a develop flag only and\n+\/\/ false with product builds. We can therefore guard it with an ifdef. More details can be found at the use-site.\n+class MoveAssertionPredicatesVisitor : public PredicateVisitor {\n+  ClonePredicateToTargetLoop _clone_predicate_to_loop;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  MoveAssertionPredicatesVisitor(LoopNode* target_loop_head,\n+                                 const NodeInSingleLoopBody &node_in_loop_body,\n+                                 PhaseIdealLoop* phase)\n+    : _clone_predicate_to_loop(target_loop_head, node_in_loop_body, phase),\n+      _phase(phase) {\n+  }\n+  NONCOPYABLE(MoveAssertionPredicatesVisitor);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    template_assertion_predicate.kill(_phase->igvn());\n+  }\n+};\n+#endif \/\/ ASSERT\n+\n@@ -4431,0 +4458,1 @@\n+#ifdef ASSERT\n@@ -4449,1 +4477,3 @@\n-  } else {\n+  } else\n+#endif \/\/ASSERT\n+  {\n@@ -4640,0 +4670,13 @@\n+#ifdef ASSERT\n+  if (StressDuplicateBackedge && head->is_CountedLoop()) {\n+    \/\/ The Template Assertion Predicates from the old counted loop are now at the new outer loop - clone them to\n+    \/\/ the inner counted loop and kill the old ones. We only need to do this with debug builds because\n+    \/\/ StressDuplicateBackedge is a devlop flag and false by default. Without StressDuplicateBackedge 'head' will be a\n+    \/\/ non-counted loop, and thus we have no Template Assertion Predicates above the old loop to move down.\n+    PredicateIterator predicate_iterator(outer_head->in(LoopNode::EntryControl));\n+    NodeInSingleLoopBody node_in_body(this, loop);\n+    MoveAssertionPredicatesVisitor move_assertion_predicates_visitor(head, node_in_body, this);\n+    predicate_iterator.for_each(move_assertion_predicates_visitor);\n+  }\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2199,1 +2199,4 @@\n-  virtual void target_node_action(Node* target_node) = 0;\n+  \/\/ To give more freedom, we pass the direct child node to the target node such that\n+  \/\/ child->in(i) == target node. This allows to also directly replace the target node instead\n+  \/\/ of only updating its inputs.\n+  virtual void target_node_action(Node* child, uint i) = 0;\n@@ -2221,1 +2224,1 @@\n-          _bfs_actions.target_node_action(input);\n+          _bfs_actions.target_node_action(next, j);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1443,1 +1443,0 @@\n-  int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; \/\/ add marginal slop for handler\n@@ -1449,1 +1448,1 @@\n-    code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  \/\/ force expansion\n+    code_req = const_req = stub_req = deopt_handler_req = 0x10;  \/\/ force expansion\n@@ -1456,1 +1455,0 @@\n-          exception_handler_req +\n@@ -1886,2 +1884,0 @@\n-    \/\/ Emit the exception handler code.\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1135,1 +1135,1 @@\n-bool PhaseIterGVN::verify_Value_for(Node* n) {\n+bool PhaseIterGVN::verify_Value_for(Node* n, bool strict) {\n@@ -1155,1 +1155,1 @@\n-  if (n->is_Load() && !told->singleton()) {\n+  if (!strict && n->is_Load() && !told->singleton()) {\n@@ -1163,1 +1163,1 @@\n-  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+  if (!strict && n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n@@ -2852,0 +2852,1 @@\n+  Unique_Node_List worklist_revisit(&local_arena);\n@@ -2860,2 +2861,3 @@\n-  \/\/ Pull from worklist; compute new value; push changes out.\n-  \/\/ This loop is the meat of CCP.\n+  \/\/ This is the meat of CCP: pull from worklist; compute new value; push changes out.\n+\n+  \/\/ Do the first round. Since all initial types are TOP, this will visit all alive nodes.\n@@ -2865,0 +2867,3 @@\n+    if (needs_revisit(n)) {\n+      worklist_revisit.push(n);\n+    }\n@@ -2870,6 +2875,10 @@\n-    const Type* new_type = n->Value(this);\n-    if (new_type != type(n)) {\n-      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n-      dump_type_and_node(n, new_type);\n-      set_type(n, new_type);\n-      push_child_nodes_to_worklist(worklist, n);\n+    analyze_step(worklist, n);\n+  }\n+\n+  \/\/ More rounds to catch updates far in the graph.\n+  \/\/ Revisit nodes that might be able to refine their types at the end of the round.\n+  \/\/ If so, process these nodes. If there is remaining work, start another round.\n+  do {\n+    while (worklist.size() != 0) {\n+      Node* n = fetch_next_node(worklist);\n+      analyze_step(worklist, n);\n@@ -2877,4 +2886,3 @@\n-    if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n-      \/\/ Keep track of Type nodes to kill CFG paths that use Type\n-      \/\/ nodes that become dead.\n-      _maybe_top_type_nodes.push(n);\n+    for (uint t = 0; t < worklist_revisit.size(); t++) {\n+      Node* n = worklist_revisit.at(t);\n+      analyze_step(worklist, n);\n@@ -2882,1 +2890,2 @@\n-  }\n+  } while (worklist.size() != 0);\n+\n@@ -2886,0 +2895,31 @@\n+void PhaseCCP::analyze_step(Unique_Node_List& worklist, Node* n) {\n+  const Type* new_type = n->Value(this);\n+  if (new_type != type(n)) {\n+    DEBUG_ONLY(verify_type(n, new_type, type(n));)\n+    dump_type_and_node(n, new_type);\n+    set_type(n, new_type);\n+    push_child_nodes_to_worklist(worklist, n);\n+  }\n+  if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n+    \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+    \/\/ nodes that become dead.\n+    _maybe_top_type_nodes.push(n);\n+  }\n+}\n+\n+\/\/ Some nodes can refine their types due to type change somewhere deep\n+\/\/ in the graph. We will need to revisit them before claiming convergence.\n+\/\/ Add nodes here if particular *Node::Value is doing deep graph traversals\n+\/\/ not handled by PhaseCCP::push_more_uses().\n+bool PhaseCCP::needs_revisit(Node* n) const {\n+  \/\/ LoadNode performs deep traversals. Load is not notified for changes far away.\n+  if (n->is_Load()) {\n+    return true;\n+  }\n+  \/\/ CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2888,1 +2928,2 @@\n-\/\/ We have a list of exceptions, see comments in verify_Value_for.\n+\/\/ Note for CCP the non-convergence can lead to unsound analysis and mis-compilation.\n+\/\/ Therefore, we are verifying Value convergence strictly.\n@@ -2893,1 +2934,1 @@\n-    failure |= verify_Value_for(n);\n+    failure |= verify_Value_for(n, \/* strict = *\/ true);\n@@ -2897,2 +2938,3 @@\n-  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n-  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type in the same round,\n+  \/\/ or that they are added in PhaseCCP::needs_revisit() so that analysis revisits\n+  \/\/ them at the end of the round.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":62,"deletions":20,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-  bool verify_Value_for(Node* n);\n+  bool verify_Value_for(Node* n, bool strict = false);\n@@ -665,0 +665,2 @@\n+  void analyze_step(Unique_Node_List& worklist, Node* n);\n+  bool needs_revisit(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -3175,3 +3177,2 @@\n-  if( _ptr == Null ) st->print(\"null\");\n-  else st->print(\"%s *\", ptr_msg[_ptr]);\n-  _offset.dump2(st);\n+  st->print(\"ptr:%s\", ptr_msg[_ptr]);\n+  dump_offset(st);\n@@ -3182,0 +3183,4 @@\n+void TypePtr::dump_offset(outputStream* st) const {\n+  _offset.dump2(st);\n+}\n+\n@@ -3369,4 +3374,4 @@\n-void TypeRawPtr::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  if( _ptr == Constant )\n-    st->print(INTPTR_FORMAT, p2i(_bits));\n-  else\n+void TypeRawPtr::dump2(Dict& d, uint depth, outputStream* st) const {\n+  if (_ptr == Constant) {\n+    st->print(\"rawptr:Constant:\" INTPTR_FORMAT, p2i(_bits));\n+  } else {\n@@ -3374,0 +3379,1 @@\n+  }\n@@ -4081,1 +4087,1 @@\n-void TypeOopPtr::dump2( Dict &d, uint depth, outputStream *st ) const {\n+void TypeOopPtr::dump2(Dict& d, uint depth, outputStream* st) const {\n@@ -4083,8 +4089,8 @@\n-  if( _klass_is_exact ) st->print(\":exact\");\n-  if( const_oop() ) st->print(INTPTR_FORMAT, p2i(const_oop()));\n-  _offset.dump2(st);\n-  if (_instance_id == InstanceTop)\n-    st->print(\",iid=top\");\n-  else if (_instance_id != InstanceBot)\n-    st->print(\",iid=%d\",_instance_id);\n-\n+  if (_klass_is_exact) {\n+    st->print(\":exact\");\n+  }\n+  if (const_oop() != nullptr) {\n+    st->print(\":\" INTPTR_FORMAT, p2i(const_oop()));\n+  }\n+  dump_offset(st);\n+  dump_instance_id(st);\n@@ -4094,0 +4100,10 @@\n+\n+void TypeOopPtr::dump_instance_id(outputStream* st) const {\n+  if (_instance_id == InstanceTop) {\n+    st->print(\",iid=top\");\n+  } else if (_instance_id == InstanceBot) {\n+    st->print(\",iid=bot\");\n+  } else {\n+    st->print(\",iid=%d\", _instance_id);\n+  }\n+}\n@@ -4782,0 +4798,1 @@\n+  st->print(\"instptr:\");\n@@ -4785,27 +4802,11 @@\n-  switch( _ptr ) {\n-  case Constant:\n-    if (WizardMode || Verbose) {\n-      ResourceMark rm;\n-      stringStream ss;\n-\n-      st->print(\" \");\n-      const_oop()->print_oop(&ss);\n-      \/\/ 'const_oop->print_oop()' may emit newlines('\\n') into ss.\n-      \/\/ suppress newlines from it so -XX:+Verbose -XX:+PrintIdeal dumps one-liner for each node.\n-      char* buf = ss.as_string(\/* c_heap= *\/false);\n-      StringUtils::replace_no_expand(buf, \"\\n\", \"\");\n-      st->print_raw(buf);\n-    }\n-  case BotPTR:\n-    if (!WizardMode && !Verbose) {\n-      if( _klass_is_exact ) st->print(\":exact\");\n-      break;\n-    }\n-  case TopPTR:\n-  case AnyNull:\n-  case NotNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if( _klass_is_exact ) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n+  if (_ptr == Constant && (WizardMode || Verbose)) {\n+    ResourceMark rm;\n+    stringStream ss;\n+\n+    st->print(\" \");\n+    const_oop()->print_oop(&ss);\n+    \/\/ 'const_oop->print_oop()' may emit newlines('\\n') into ss.\n+    \/\/ suppress newlines from it so -XX:+Verbose -XX:+PrintIdeal dumps one-liner for each node.\n+    char* buf = ss.as_string(\/* c_heap= *\/false);\n+    StringUtils::replace_no_expand(buf, \"\\n\", \"\");\n+    st->print_raw(buf);\n@@ -4814,1 +4815,4 @@\n-  _offset.dump2(st);\n+  st->print(\":%s\", ptr_msg[_ptr]);\n+  if (_klass_is_exact) {\n+    st->print(\":exact\");\n+  }\n@@ -4818,7 +4822,2 @@\n-  dump_flat_in_array(_flat_in_array, st);\n-\n-  if (_instance_id == InstanceTop)\n-    st->print(\",iid=top\");\n-  else if (_instance_id != InstanceBot)\n-    st->print(\",iid=%d\",_instance_id);\n-\n+  dump_offset(st);\n+  dump_instance_id(st);\n@@ -4827,0 +4826,1 @@\n+  dump_flat_in_array(_flat_in_array, st);\n@@ -5581,1 +5581,2 @@\n-  _ary->dump2(d,depth,st);\n+  st->print(\"aryptr:\");\n+  _ary->dump2(d, depth, st);\n@@ -5584,2 +5585,1 @@\n-  switch( _ptr ) {\n-  case Constant:\n+  if (_ptr == Constant) {\n@@ -5587,14 +5587,5 @@\n-    break;\n-  case BotPTR:\n-    if (!WizardMode && !Verbose) {\n-      if( _klass_is_exact ) st->print(\":exact\");\n-      break;\n-    }\n-  case TopPTR:\n-  case AnyNull:\n-  case NotNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if( _klass_is_exact ) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n+  }\n+\n+  st->print(\":%s\", ptr_msg[_ptr]);\n+  if (_klass_is_exact) {\n+    st->print(\":exact\");\n@@ -5640,5 +5631,1 @@\n-  st->print(\" *\");\n-  if (_instance_id == InstanceTop)\n-    st->print(\",iid=top\");\n-  else if (_instance_id != InstanceBot)\n-    st->print(\",iid=%d\",_instance_id);\n+  dump_instance_id(st);\n@@ -6064,6 +6051,2 @@\n-  if( metadata() ) st->print(INTPTR_FORMAT, p2i(metadata()));\n-  switch (offset()) {\n-  case OffsetTop: st->print(\"+top\"); break;\n-  case OffsetBot: st->print(\"+any\"); break;\n-  case         0: break;\n-  default:        st->print(\"+%d\",offset()); break;\n+  if (metadata() != nullptr) {\n+    st->print(\":\" INTPTR_FORMAT, p2i(metadata()));\n@@ -6071,0 +6054,1 @@\n+  dump_offset(st);\n@@ -6221,33 +6205,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump Klass Type\n-#ifndef PRODUCT\n-void TypeKlassPtr::dump2(Dict & d, uint depth, outputStream *st) const {\n-  switch(_ptr) {\n-  case Constant:\n-    st->print(\"precise \");\n-  case NotNull:\n-    {\n-      const char *name = klass()->name()->as_utf8();\n-      if (name) {\n-        st->print(\"%s: \" INTPTR_FORMAT, name, p2i(klass()));\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-      _interfaces->dump(st);\n-    }\n-  case BotPTR:\n-    if (!WizardMode && !Verbose && _ptr != Constant) break;\n-  case TopPTR:\n-  case AnyNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if (_ptr == Constant) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n-  }\n-\n-  _offset.dump2(st);\n-  st->print(\" *\");\n-}\n-#endif\n-\n@@ -6635,0 +6586,11 @@\n+#ifndef PRODUCT\n+void TypeInstKlassPtr::dump2(Dict& d, uint depth, outputStream* st) const {\n+  st->print(\"instklassptr:\");\n+  klass()->print_name_on(st);\n+  _interfaces->dump(st);\n+  st->print(\":%s\", ptr_msg[_ptr]);\n+  dump_offset(st);\n+  dump_flat_in_array(_flat_in_array, st);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -7232,2 +7194,3 @@\n-void TypeInstKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n-  klass()->print_name_on(st);\n+void TypeAryKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n+  st->print(\"aryklassptr:[\");\n+  _elem->dump2(d, depth, st);\n@@ -7236,24 +7199,0 @@\n-  dump_flat_in_array(_flat_in_array, st);\n-}\n-\n-void TypeAryKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n-  switch( _ptr ) {\n-  case Constant:\n-    st->print(\"precise \");\n-  case NotNull:\n-    {\n-      st->print(\"[\");\n-      _elem->dump2(d, depth, st);\n-      _interfaces->dump(st);\n-      st->print(\": \");\n-    }\n-  case BotPTR:\n-    if( !WizardMode && !Verbose && _ptr != Constant ) break;\n-  case TopPTR:\n-  case AnyNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if( _ptr == Constant ) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n-  }\n@@ -7268,4 +7207,1 @@\n-\n-  _offset.dump2(st);\n-\n-  st->print(\" *\");\n+  dump_offset(st);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":78,"deletions":142,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -1236,3 +1236,0 @@\n-#ifndef PRODUCT\n-  void dump_speculative(outputStream *st) const;\n-#endif\n@@ -1243,0 +1240,1 @@\n+\n@@ -1244,1 +1242,3 @@\n-  void dump_inline_depth(outputStream *st) const;\n+  void dump_speculative(outputStream* st) const;\n+  void dump_inline_depth(outputStream* st) const;\n+  void dump_offset(outputStream* st) const;\n@@ -1444,0 +1444,4 @@\n+#ifndef PRODUCT\n+  void dump_instance_id(outputStream* st) const;\n+#endif \/\/ PRODUCT\n+\n@@ -1972,3 +1976,0 @@\n-#ifndef PRODUCT\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n-#endif\n@@ -2071,0 +2072,5 @@\n+\n+#ifndef PRODUCT\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+#endif \/\/ PRODUCT\n+\n@@ -2073,2 +2079,0 @@\n-\n-  NOT_PRODUCT(virtual void dump2(Dict& d, uint depth, outputStream* st) const;) \/\/ Specialized per-Type dumping\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -393,11 +394,3 @@\n-  Array<u2>* operands = cpool()->operands();\n-  int num_bootstrap_methods = ConstantPool::operand_array_length(operands);\n-\n-  \/\/ calculate length of attribute\n-  u4 length = sizeof(u2); \/\/ num_bootstrap_methods\n-  for (int n = 0; n < num_bootstrap_methods; n++) {\n-    u2 num_bootstrap_arguments = cpool()->bsm_attribute_entry(n)->argument_count();\n-    length += sizeof(u2); \/\/ bootstrap_method_ref\n-    length += sizeof(u2); \/\/ num_bootstrap_arguments\n-    length += (u4)sizeof(u2) * num_bootstrap_arguments; \/\/ bootstrap_arguments[num_bootstrap_arguments]\n-  }\n+  u4 length = sizeof(u2) + \/\/ Size of num_bootstrap_methods\n+              \/\/ The rest of the data for the attribute is exactly the u2s in the data array.\n+              sizeof(u2) * cpool()->bsm_entries().array_length();\n@@ -407,0 +400,1 @@\n+  int num_bootstrap_methods = cpool()->bsm_entries().number_of_entries();\n@@ -415,1 +409,1 @@\n-      u2 bootstrap_argument = bsme->argument_index(arg);\n+      u2 bootstrap_argument = bsme->argument(arg);\n@@ -827,1 +821,1 @@\n-  if (cpool()->operands() != nullptr) {\n+  if (!cpool()->bsm_entries().is_empty()) {\n@@ -878,1 +872,1 @@\n-  if (cpool()->operands() != nullptr) {\n+  if (!cpool()->bsm_entries().is_empty()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-#include \"oops\/constantPool.hpp\"\n+#include \"oops\/bsmAttribute.inline.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -576,1 +577,1 @@\n-      \/\/ Index of the bootstrap specifier in the operands array\n+      \/\/ Index of the bootstrap specifier in the BSM array\n@@ -578,1 +579,1 @@\n-      int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,\n+      int new_bs_i = find_or_append_bsm_entry(scratch_cp, old_bs_i, merge_cp_p,\n@@ -594,1 +595,1 @@\n-      if (scratch_cp->tag_at(scratch_i).is_dynamic_constant())\n+      if (scratch_cp->tag_at(scratch_i).is_dynamic_constant()) {\n@@ -596,1 +597,1 @@\n-      else\n+      } else {\n@@ -598,0 +599,1 @@\n+      }\n@@ -662,2 +664,2 @@\n-\/\/ Append a bootstrap specifier into the merge_cp operands that is semantically equal\n-\/\/ to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.\n+\/\/ Append a bootstrap specifier into the merge_cp BSM entries that is semantically equal\n+\/\/ to the scratch_cp BSM entries' bootstrap specifier passed by the old_bs_i index.\n@@ -665,1 +667,1 @@\n-void VM_RedefineClasses::append_operand(const constantPoolHandle& scratch_cp, const int old_bs_i,\n+int VM_RedefineClasses::append_bsm_entry(const constantPoolHandle& scratch_cp, const int old_bs_i,\n@@ -674,1 +676,1 @@\n-      (\"operands entry@%d bootstrap method ref_index change: %d to %d\", _operands_cur_length, old_ref_i, new_ref_i);\n+      (\"BSM attribute entry@%d bootstrap method ref_index change: %d to %d\", _bsmae_iter.current_offset() - 1, old_ref_i, new_ref_i);\n@@ -677,14 +679,6 @@\n-  Array<u2>* merge_ops = (*merge_cp_p)->operands();\n-  int new_bs_i = _operands_cur_length;\n-  \/\/ We have _operands_cur_length == 0 when the merge_cp operands is empty yet.\n-  \/\/ However, the operand_offset_at(0) was set in the extend_operands() call.\n-  int new_base = (new_bs_i == 0) ? (*merge_cp_p)->operand_offset_at(0)\n-                                 : (*merge_cp_p)->operand_next_offset_at(new_bs_i - 1);\n-  u2 argc      = old_bsme->argument_count();\n-\n-  ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);\n-  merge_ops->at_put(new_base++, new_ref_i);\n-  merge_ops->at_put(new_base++, argc);\n-\n-  for (int i = 0; i < argc; i++) {\n-    u2 old_arg_ref_i = old_bsme->argument_index(i);\n+  const int new_bs_i = _bsmae_iter.current_offset();\n+  BSMAttributeEntry* new_bsme =\n+    _bsmae_iter.reserve_new_entry(new_ref_i, old_bsme->argument_count());\n+  assert(new_bsme != nullptr, \"must be\");\n+  for (int i = 0; i < new_bsme->argument_count(); i++) {\n+    u2 old_arg_ref_i = old_bsme->argument(i);\n@@ -693,1 +687,2 @@\n-    merge_ops->at_put(new_base++, new_arg_ref_i);\n+    new_bsme->set_argument(i, new_arg_ref_i);\n+\n@@ -696,2 +691,2 @@\n-        (\"operands entry@%d bootstrap method argument ref_index change: %d to %d\",\n-         _operands_cur_length, old_arg_ref_i, new_arg_ref_i);\n+        (\"BSM attribute entry@%d bootstrap method argument ref_index change: %d to %d\",\n+         _bsmae_iter.current_offset() - 1, old_arg_ref_i, new_arg_ref_i);\n@@ -700,7 +695,4 @@\n-  if (old_bs_i != _operands_cur_length) {\n-    \/\/ The bootstrap specifier in *merge_cp_p is at a different index than\n-    \/\/ that in scratch_cp so we need to map the index values.\n-    map_operand_index(old_bs_i, new_bs_i);\n-  }\n-  _operands_cur_length++;\n-} \/\/ end append_operand()\n+  \/\/ This is only for the logging\n+  map_bsm_index(old_bs_i, new_bs_i);\n+  return new_bs_i;\n+} \/\/ end append_bsm_entry()\n@@ -709,1 +701,1 @@\n-int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle& scratch_cp,\n+int VM_RedefineClasses::find_or_append_bsm_entry(const constantPoolHandle& scratch_cp,\n@@ -712,0 +704,1 @@\n+  const int max_offset_in_merge = _bsmae_iter.current_offset();\n@@ -713,2 +706,4 @@\n-  bool match = (old_bs_i < _operands_cur_length) &&\n-               scratch_cp->compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i);\n+  \/\/ Has the old_bs_i index been used already? Check if it's the same so we know\n+  \/\/ whether or not a remapping is required.\n+  bool match = (old_bs_i < max_offset_in_merge) &&\n+               scratch_cp->compare_bootstrap_entry_to(old_bs_i, *merge_cp_p, old_bs_i);\n@@ -718,2 +713,2 @@\n-    int found_i = scratch_cp->find_matching_operand(old_bs_i, *merge_cp_p,\n-                                                    _operands_cur_length);\n+    int found_i = scratch_cp->find_matching_bsm_entry(old_bs_i, *merge_cp_p,\n+                                                      max_offset_in_merge);\n@@ -721,2 +716,2 @@\n-      guarantee(found_i != old_bs_i, \"compare_operand_to() and find_matching_operand() disagree\");\n-      \/\/ found a matching operand somewhere else in *merge_cp_p so just need a mapping\n+      guarantee(found_i != old_bs_i, \"compare_bootstrap_entry_to() and find_matching_bsm_entry() disagree\");\n+      \/\/ found a matching BSM entry somewhere else in *merge_cp_p so just need a mapping\n@@ -724,1 +719,1 @@\n-      map_operand_index(old_bs_i, found_i);\n+      map_bsm_index(old_bs_i, found_i);\n@@ -727,2 +722,1 @@\n-      append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p);\n-      new_bs_i = _operands_cur_length - 1;\n+      new_bs_i = append_bsm_entry(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p);\n@@ -732,1 +726,1 @@\n-} \/\/ end find_or_append_operand()\n+} \/\/ end find_or_append_bsm_entry()\n@@ -735,2 +729,2 @@\n-void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle& merge_cp, TRAPS) {\n-  if (merge_cp->operands() == nullptr) {\n+void VM_RedefineClasses::finalize_bsm_entries_merge(const constantPoolHandle& merge_cp, TRAPS) {\n+  if (merge_cp->bsm_entries().number_of_entries() == 0) {\n@@ -739,2 +733,2 @@\n-  \/\/ Shrink the merge_cp operands\n-  merge_cp->shrink_operands(_operands_cur_length, CHECK);\n+  \/\/ Finished extending the BSMAEs\n+  merge_cp->end_extension(_bsmae_iter, CHECK);\n@@ -745,2 +739,2 @@\n-    for (int i = 1; i < _operands_index_map_p->length(); i++) {\n-      int value = _operands_index_map_p->at(i);\n+    for (int i = 1; i < _bsm_index_map_p->length(); i++) {\n+      int value = _bsm_index_map_p->at(i);\n@@ -748,1 +742,1 @@\n-        log_trace(redefine, class, constantpool)(\"operands_index_map[%d]: old=%d new=%d\", count, i, value);\n+        log_trace(redefine, class, constantpool)(\"bsm_index_map[%d]: old=%d new=%d\", count, i, value);\n@@ -754,4 +748,4 @@\n-  _operands_index_map_p = nullptr;\n-  _operands_cur_length = 0;\n-  _operands_index_map_count = 0;\n-} \/\/ end finalize_operands_merge()\n+  _bsm_index_map_p = nullptr;\n+  _bsm_index_map_count = 0;\n+  _bsmae_iter = BSMAttributeEntries::InsertionIterator();\n+} \/\/ end finalize_bsmentries_merge()\n@@ -1274,2 +1268,2 @@\n-int VM_RedefineClasses::find_new_operand_index(int old_index) {\n-  if (_operands_index_map_count == 0) {\n+int VM_RedefineClasses::find_new_bsm_index(int old_index) {\n+  if (_bsm_index_map_count == 0) {\n@@ -1280,1 +1274,1 @@\n-  if (old_index == -1 || old_index >= _operands_index_map_p->length()) {\n+  if (old_index == -1 || old_index >= _bsm_index_map_p->length()) {\n@@ -1286,1 +1280,1 @@\n-  int value = _operands_index_map_p->at(old_index);\n+  int value = _bsm_index_map_p->at(old_index);\n@@ -1293,1 +1287,1 @@\n-} \/\/ end find_new_operand_index()\n+} \/\/ end find_new_bsm_index()\n@@ -1562,6 +1556,1 @@\n-void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {\n-  if (find_new_operand_index(old_index) != -1) {\n-    \/\/ old_index is already mapped\n-    return;\n-  }\n-\n+void VM_RedefineClasses::map_bsm_index(int old_index, int new_index) {\n@@ -1572,4 +1561,2 @@\n-\n-  _operands_index_map_p->at_put(old_index, new_index);\n-  _operands_index_map_count++;\n-\n+  _bsm_index_map_p->at_put(old_index, new_index);\n+  _bsm_index_map_count++;\n@@ -1577,1 +1564,1 @@\n-} \/\/ end map_index()\n+} \/\/ end map_bsm_index()\n@@ -1641,2 +1628,2 @@\n-    ConstantPool::copy_operands(old_cp, merge_cp_p, CHECK_false);\n-    merge_cp_p->extend_operands(scratch_cp, CHECK_false);\n+    ConstantPool::copy_bsm_entries(old_cp, merge_cp_p, CHECK_false);\n+    _bsmae_iter = merge_cp_p->start_extension(scratch_cp, CHECK_false);\n@@ -1739,1 +1726,1 @@\n-  finalize_operands_merge(merge_cp_p, CHECK_false);\n+  finalize_bsm_entries_merge(merge_cp_p, CHECK_false);\n@@ -1809,4 +1796,3 @@\n-  _operands_cur_length = ConstantPool::operand_array_length(old_cp->operands());\n-  _operands_index_map_count = 0;\n-  int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp->operands());\n-  _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);\n+  _bsm_index_map_count = 0;\n+  int bsm_data_len = scratch_cp->bsm_entries().array_length();\n+  _bsm_index_map_p = new intArray(bsm_data_len, bsm_data_len, -1);\n@@ -1814,1 +1800,1 @@\n-  \/\/ reference to the cp holder is needed for copy_operands()\n+  \/\/ reference to the cp holder is needed for reallocating the BSM attribute\n@@ -3552,1 +3538,1 @@\n-  \/\/ reference to the cp holder is needed for copy_operands()\n+  \/\/ reference to the cp holder is needed for reallocating the BSM attribute\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":66,"deletions":80,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -366,5 +366,10 @@\n-  \/\/ _operands_index_map_count is just an optimization for knowing if\n-  \/\/ _operands_index_map_p contains any entries.\n-  int                         _operands_cur_length;\n-  int                         _operands_index_map_count;\n-  intArray *                  _operands_index_map_p;\n+  \/\/ _bsm_index_map_count is just an optimization for knowing if\n+  \/\/ _bsm_index_map_p contains any entries.\n+  int                         _bsm_index_map_count;\n+  intArray *                  _bsm_index_map_p;\n+\n+  \/\/ After merge_constant_pools \"Pass 0\", the BSMAttribute entries of merge_cp_p will have been expanded to fit\n+  \/\/ scratch_cp's BSMAttribute entries as well.\n+  \/\/ However, the newly acquired space will not have been filled in yet.\n+  \/\/ To append to this new space, the iterator is used.\n+  BSMAttributeEntries::InsertionIterator _bsmae_iter;\n@@ -432,1 +437,2 @@\n-  void append_operand(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n+  \/\/ Returns the index of the appended BSM\n+  int append_bsm_entry(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n@@ -434,1 +440,1 @@\n-  void finalize_operands_merge(const constantPoolHandle& merge_cp, TRAPS);\n+  void finalize_bsm_entries_merge(const constantPoolHandle& merge_cp, TRAPS);\n@@ -437,1 +443,1 @@\n-  int find_or_append_operand(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n+  int find_or_append_bsm_entry(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n@@ -440,1 +446,1 @@\n-  int find_new_operand_index(int old_bootstrap_spec_index);\n+  int find_new_bsm_index(int old_bootstrap_spec_index);\n@@ -442,1 +448,1 @@\n-  void map_operand_index(int old_bootstrap_spec_index, int new_bootstrap_spec_index);\n+  void map_bsm_index(int old_bootstrap_spec_index, int new_bootstrap_spec_index);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1499,0 +1499,1 @@\n+  assert(is_power_of_2(_conservative_max_heap_alignment), \"Expected to be a power-of-2\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -548,0 +548,3 @@\n+  if (exec_mode == Unpack_deopt) {\n+    assert(deoptee.is_deoptimized_frame(), \"frame is not marked for deoptimization\");\n+  }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_entry() - pc_return_offset;\n@@ -362,1 +362,1 @@\n-  address deopt = nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -610,0 +613,5 @@\n+#ifdef COMPILER2\n+      if (nm->compiler_type() == compiler_c2) {\n+        return OptoRuntime::exception_blob()->entry_point();\n+      }\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"oops\/bsmAttribute.hpp\"\n@@ -171,0 +172,3 @@\n+  nonstatic_field(BSMAttributeEntries,         _offsets,                                      Array<u4>*)                            \\\n+  nonstatic_field(BSMAttributeEntries,         _bootstrap_methods,                            Array<u2>*)                            \\\n+  nonstatic_field(ConstantPool,                _bsm_entries,                                  BSMAttributeEntries)                   \\\n@@ -174,1 +178,0 @@\n-  nonstatic_field(ConstantPool,                _operands,                                     Array<u2>*)                            \\\n@@ -539,1 +542,1 @@\n-  nonstatic_field(nmethod,                     _deopt_handler_offset,                         int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_handler_entry_offset,                   int)                                   \\\n@@ -738,0 +741,1 @@\n+  unchecked_nonstatic_field(Array<u4>,                 _data,                                 sizeof(u4))                            \\\n@@ -972,0 +976,1 @@\n+  declare_toplevel_type(BSMAttributeEntries)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -169,0 +170,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<AOTEndRecordingDCmd>(full_export, true, false));\n@@ -1014,0 +1016,22 @@\n+#if INCLUDE_CDS\n+void AOTEndRecordingDCmd::execute(DCmdSource source, TRAPS) {\n+  if (!CDSConfig::is_dumping_preimage_static_archive()) {\n+    output()->print_cr(\"AOT.end_recording is unsupported when VM flags -XX:AOTMode=record or -XX:AOTCacheOutput=<file> are missing.\");\n+    return;\n+  }\n+\n+  if (AOTMetaspace::preimage_static_archive_dumped()) {\n+    output()->print_cr(\"Recording has already ended.\");\n+    return;\n+  }\n+\n+  AOTMetaspace::dump_static_archive(THREAD);\n+  if (!AOTMetaspace::preimage_static_archive_dumped()) {\n+    output()->print_cr(\"Error: Failed to end recording.\");\n+    return;\n+  }\n+\n+  output()->print_cr(\"Recording ended successfully.\");\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -348,0 +348,15 @@\n+#if INCLUDE_CDS\n+class AOTEndRecordingDCmd : public DCmd {\n+public:\n+  AOTEndRecordingDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"AOT.end_recording\"; }\n+    static const char* description() {\n+      return \"End AOT recording.\";\n+    }\n+    static const char* impact() {\n+      return \"Medium: Pause time depends on number of loaded classes\";\n+    }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -756,1 +756,2 @@\n-         * NUM_ENTITIES should match the total number of UnicodeBlocks.\n+         * NUM_ENTITIES should match the total number of UnicodeBlock identifier\n+         * names plus their aliases.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.reflect.GenericSignatureFormatError;\n@@ -166,0 +167,4 @@\n+ * <p> Unless otherwise specified, methods in this class throw a\n+ * {@link NullPointerException} when they are called with {@code null}\n+ * or an array that contains {@code null} as an argument.\n+ *\n@@ -544,1 +549,2 @@\n-     * @param loader     class loader from which the class must be loaded\n+     * @param loader     class loader from which the class must be loaded,\n+     *                   may be {@code null}\n@@ -603,2 +609,0 @@\n-     * @throws NullPointerException if the given module or name is {@code null}\n-     *\n@@ -682,2 +686,0 @@\n-     * @throws NullPointerException if the argument is {@code null}\n-     *\n@@ -819,1 +821,1 @@\n-     * @param   obj the object to check\n+     * @param   obj the object to check, may be {@code null}\n@@ -849,2 +851,0 @@\n-     * @throws    NullPointerException if the specified Class parameter is\n-     *            null.\n@@ -1522,1 +1522,0 @@\n-            \/\/ Descriptor already validated by VM\n@@ -1610,2 +1609,9 @@\n-        String getDescriptor() { return descriptor; }\n-\n+        String getDescriptor() {\n+            \/\/ hotspot validates this descriptor to be either a field or method\n+            \/\/ descriptor as the \"type\" in a NameAndType in verification.\n+            \/\/ So this can still be a field descriptor\n+            if (descriptor.isEmpty() || descriptor.charAt(0) != '(') {\n+                throw new GenericSignatureFormatError(\"Bad method signature: \" + descriptor);\n+            }\n+            return descriptor;\n+        }\n@@ -1644,1 +1650,0 @@\n-            \/\/ Descriptor already validated by VM\n@@ -2128,1 +2133,0 @@\n-     * @throws NullPointerException if {@code name} is {@code null}\n@@ -2219,1 +2223,1 @@\n-     * @param parameterTypes the list of parameters\n+     * @param parameterTypes the list of parameters, may be {@code null}\n@@ -2222,1 +2226,2 @@\n-     * @throws NoSuchMethodException if a matching method is not found\n+     * @throws NoSuchMethodException if a matching method is not found,\n+     *         if {@code parameterTypes} contains {@code null},\n@@ -2224,2 +2229,1 @@\n-     *         {@value ConstantDescs#CLASS_INIT_NAME}.\n-     * @throws NullPointerException if {@code name} is {@code null}\n+     *         {@value ConstantDescs#CLASS_INIT_NAME}\n@@ -2256,1 +2260,1 @@\n-     * @param parameterTypes the parameter array\n+     * @param parameterTypes the parameter array, may be {@code null}\n@@ -2260,2 +2264,3 @@\n-     *         including when this {@code Class} object represents\n-     *         an interface, a primitive type, an array class, or void.\n+     *         if this {@code Class} object represents an interface, a primitive\n+     *         type, an array class, or void, or if {@code parameterTypes}\n+     *         contains {@code null}\n@@ -2442,1 +2447,0 @@\n-     * @throws  NullPointerException if {@code name} is {@code null}\n@@ -2477,5 +2481,7 @@\n-     * @param parameterTypes the parameter array\n-     * @return  the {@code Method} object for the method of this class\n-     *          matching the specified name and parameters\n-     * @throws  NoSuchMethodException if a matching method is not found.\n-     * @throws  NullPointerException if {@code name} is {@code null}\n+     * @param parameterTypes the parameter array, may be {@code null}\n+     * @return the {@code Method} object for the method of this class\n+     *         matching the specified name and parameters\n+     * @throws NoSuchMethodException if a matching method is not found,\n+     *         if {@code parameterTypes} contains {@code null},\n+     *         or if the name is {@value ConstantDescs#INIT_NAME} or\n+     *         {@value ConstantDescs#CLASS_INIT_NAME}\n@@ -2548,1 +2554,1 @@\n-     * @param parameterTypes the parameter array\n+     * @param parameterTypes the parameter array, may be {@code null}\n@@ -2552,2 +2558,3 @@\n-     *          including when this {@code Class} object represents\n-     *          an interface, a primitive type, an array class, or void.\n+     *          if this {@code Class} object represents an interface, a\n+     *          primitive type, an array class, or void, or if\n+     *          {@code parameterTypes} contains {@code null}\n@@ -2612,1 +2619,0 @@\n-     * @throws  NullPointerException If {@code name} is {@code null}\n@@ -2708,1 +2714,0 @@\n-     * @throws NullPointerException If {@code name} is {@code null}\n@@ -3550,1 +3555,1 @@\n-     * @param obj the object to be cast\n+     * @param obj the object to be cast, may be {@code null}\n@@ -3605,1 +3610,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3618,1 +3622,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3631,1 +3634,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3661,1 +3663,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3677,1 +3678,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3908,0 +3908,1 @@\n+        Objects.requireNonNull(c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":38,"deletions":37,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -253,6 +253,0 @@\n- * <p>\n- * Unless otherwise noted, passing a {@code null} argument to a constructor\n- * or method of any Class-File API class or interface will cause a {@link\n- * NullPointerException} to be thrown. Additionally,\n- * invoking a method with an array or collection containing a {@code null} element\n- * will cause a {@code NullPointerException}, unless otherwise specified.\n@@ -275,8 +269,16 @@\n- * <h3>Consistency checks, syntax checks and verification<\/h3>\n- * The Class-File API performs checks to ensure arguments are representable in\n- * the {@code class} file format.  A value that is lost when it is built to a\n- * {@code class} file and re-parsed to a model is rejected with an {@link\n- * IllegalArgumentException}.  For example, a negative value or a value over\n- * {@code 65535} is lost when built to a {@link ##u2 u2} item, with\n- * the range {@code [0, 65535]}.  In particular, any variable-sized table\n- * exceeding its maximum representable size is rejected.\n+ * <h3 id=\"checks\">Consistency checks, syntax checks and verification<\/h3>\n+ * The Class-File API performs checks to ensure arguments to construct {@code\n+ * class} file structures are representable in the {@code class} file format.\n+ * An argument value that cannot be representable by its data type is rejected\n+ * with an {@link IllegalArgumentException}.  For example, an {@code int} value\n+ * cannot be out of the range of its {@linkplain java.lang.classfile##data-types\n+ * data type}; a {@code List} cannot exceed the maximum representable size of\n+ * its table data type, or contain an unrepresentable element.  Restrictions\n+ * based on underlying data type, such as the {@code int} and {@code List} ones\n+ * before, are specified on the corresponding APIs.  Unless otherwise noted, in\n+ * all structures, a {@code String} cannot exceed {@code 65535} bytes when\n+ * represented in modified UTF-8 format.\n+ * <p>\n+ * Unless otherwise noted, passing null or an array or collection that contains\n+ * null as an element to a constructor or method of any Class-File API class or\n+ * interface will cause a {@link NullPointerException} to be thrown.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -443,0 +443,1 @@\n+     * @throws NullPointerException if {@code rv} is {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -900,1 +900,2 @@\n-     * @param   loader the class loader to define the proxy class\n+     * @param   loader the class loader to define the proxy class, may be\n+     *          {@code null} to represent the bootstrap class loader\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -775,4 +777,6 @@\n-        return new StringBuilder(10).append(\"--\")\n-            .append(month < 10 ? \"0\" : \"\").append(month)\n-            .append(day < 10 ? \"-0\" : \"-\").append(day)\n-            .toString();\n+        StringBuilder buf = new StringBuilder(10);\n+        buf.append(\"--\");\n+        DecimalDigits.appendPair(buf, month);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, day);\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/MonthDay.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,0 +104,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -1224,1 +1226,1 @@\n-        if (absYear < 1000) {\n+        if (absYear < 10000) {\n@@ -1226,3 +1228,1 @@\n-                buf.append(year - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(year + 10000).deleteCharAt(0);\n+                buf.append('-');\n@@ -1230,0 +1230,1 @@\n+            DecimalDigits.appendQuad(buf, absYear);\n@@ -1233,3 +1234,3 @@\n-        return buf.append(month < 10 ? \"-0\" : \"-\")\n-            .append(month)\n-            .toString();\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, month);\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/YearMonth.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -430,4 +432,6 @@\n-        \/\/ getLong() reduces chances of exceptions in toString()\n-        long yoe = getLong(YEAR_OF_ERA);\n-        long moy = getLong(MONTH_OF_YEAR);\n-        long dom = getLong(DAY_OF_MONTH);\n+        \/\/ Using get() instead of getLong() for performance reasons,\n+        \/\/ as the values of YEAR_OF_ERA, MONTH_OF_YEAR, and DAY_OF_MONTH\n+        \/\/ are guaranteed to be within the int range for all chronologies.\n+        int yoe = get(YEAR_OF_ERA);\n+        int moy = get(MONTH_OF_YEAR);\n+        int dom = get(DAY_OF_MONTH);\n@@ -440,2 +444,4 @@\n-                .append(moy < 10 ? \"-0\" : \"-\").append(moy)\n-                .append(dom < 10 ? \"-0\" : \"-\").append(dom);\n+                .append('-');\n+        DecimalDigits.appendPair(buf, moy);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, dom);\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateImpl.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1374,5 +1374,12 @@\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                V val = p.val;\n-                Object v = m.get(p.key);\n-                if (!Objects.equals(val, v))\n-                    return false;\n+\n+            try {\n+                for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                    V val = p.val;\n+                    Object v = m.get(p.key);\n+                    if (!Objects.equals(val, v))\n+                        return false;\n+                }\n+            } catch (ClassCastException | NullPointerException _) {\n+                \/\/ m.get(p.key) is contractually allowed to throw CCE or NPE\n+                \/\/ but CHM doesn't allow null keys, so NPE shouldn't occur in practice\n+                return false;\n@@ -1380,0 +1387,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -323,4 +323,3 @@\n-        if (!ExactConversionsSupport.isLongToCharExact(utflenLong)) {\n-            throw new IllegalArgumentException(\"utf8 length out of range of u2: \" + utflenLong);\n-        }\n-        int utflen = (int)utflenLong;\n+        \/\/ Utf8Entry should always be writable\n+        assert ExactConversionsSupport.isLongToCharExact(utflenLong) : utflenLong;\n+        int utflen = (int) utflenLong;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,3 +113,2 @@\n-\n-    \/\/ TBD:   assert(module_name_len > 0, \"module name must be non-empty\");\n-    assert(name_len > 0 && \"resource name must be non-empty\");\n+    assert(module_name_len > 0 && \"module name must be non-empty\");\n+    assert(name_len > 0 && \"name must non-empty\");\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        captureMRefReturnType = Source.Feature.ERASE_POLY_SIG_RETURN_TYPE.allowedInSource(source);\n+        captureMRefReturnType = Source.Feature.CAPTURE_MREF_RETURN_TYPE.allowedInSource(source);\n@@ -369,1 +369,1 @@\n-                if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)\n+                if (site == null || site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2816,1 +2816,6 @@\n-        return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);\n+        try {\n+            return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return methodNotFound.access(name, site.tsym);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -669,0 +669,5 @@\n+        if (endPosTable == null) {\n+            \/\/ fall back on limited info in the tree\n+            return endPos(tree);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t006\/TestDescription.java 8372206 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3268,1 +3268,3 @@\n-    \/\/ @fully\/qualified\/package\/name\/to\/TheClass+12 *\n+    \/\/ @ptrtype:fully\/qualified\/package\/name\/to\/TheClass:ptrlattice+12\n+    \/\/ with ptrtype being the kind of the type such as instptr, aryptr, etc, and ptrlattice being\n+    \/\/ the kind of the value such as BotPTR, NotNull, etc.\n@@ -3270,2 +3272,2 @@\n-    \/\/ - after @, we can have \"stable:\" or other labels, with optional space after ':'\n-    \/\/ - the class can actually be a subclass, with $ separator (and it must be ok to give only the deepest one\n+    \/\/ - after ptrtype, we can have \"stable:\" or other labels, with optional space after ':'\n+    \/\/ - the class can actually be a nested class, with $ separator (and it must be ok to give only the deepest one\n@@ -3273,4 +3275,12 @@\n-    \/\/ - before the offset, we can have something like \":NotNull\", either way, seeing \"+\" or \":\" means the end of the type\n-    \/\/ @bla: bli:a\/b\/c$d$e (f\/g,h\/i\/j):NotNull+24 *\n-    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)*[\\\\w\/\\\\$]*\\\\b\";\n-    private static final String LOAD_STORE_SUFFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\";\n+    \/\/ @bla: bli:a\/b\/c$d$e (f\/g,h\/i\/j):NotNull+24\n+\n+    \/\/ @ matches the start character of the pattern\n+    \/\/ (\\w+: ?)+ tries to match the pattern 'ptrtype:' or 'stable:' with optional trailing whitespaces\n+    \/\/ (\\w\/)* tries to match the pattern 'a\/b\/`\n+    \/\/ (\\w$)* tries to match the pattern 'c$d$'\n+    \/\/ \\b asserts that the next character is a word character\n+    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)+(\\\\w\/)*(\\\\w$)*\\\\b\";\n+    \/\/ ( \\([^\\)]+\\))? tries to match the pattern ' (f\/g,h\/i\/j)'\n+    \/\/ :\\w+ tries to match the pattern ':NotNull'\n+    \/\/ .* tries to match the remaining of the pattern\n+    private static final String LOAD_STORE_SUFFIX = \"( \\\\([^\\\\)]+\\\\))?:\\\\w+.*\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8335935 8336588\n+ * @bug 8335935 8336588 8372047\n@@ -32,14 +32,4 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeModel;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.FieldModel;\n-import java.lang.classfile.FieldTransform;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n@@ -58,0 +48,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -60,0 +51,1 @@\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -338,0 +330,50 @@\n+\n+    @Test\n+    void testFilteringTransformChaining() {\n+        var cf = ClassFile.of();\n+        var clazz = cf.parse(cf.build(ClassDesc.of(\"Test\"), clb -> clb\n+                .withField(\"one\", CD_int, fb -> fb.with(ConstantValueAttribute.of(1)))\n+                .withField(\"two\", CD_int, fb -> fb.with(ConstantValueAttribute.of(2)))\n+                .withMethod(\"one\", MTD_void, 0, mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))).withCode(CodeBuilder::return_))\n+                .withMethod(\"two\", MTD_void, 0, mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(2))).withCode(CodeBuilder::return_))));\n+\n+        AtomicBoolean oneFieldCalled = new AtomicBoolean(false);\n+        var oneFieldTransform = new TransformImpl.ClassFieldTransform((fb, fe) -> {\n+            if (fe instanceof ConstantValueAttribute cv) {\n+                assertEquals(1, ((Integer) cv.constant().constantValue()), \"Should only transform one\");\n+            }\n+            oneFieldCalled.set(true);\n+            fb.with(fe);\n+        }, fm -> fm.fieldName().equalsString(\"one\"));\n+        AtomicBoolean twoFieldCalled = new AtomicBoolean(false);\n+        var twoFieldTransform = new TransformImpl.ClassFieldTransform((fb, fe) -> {\n+            if (fe instanceof ConstantValueAttribute cv) {\n+                assertEquals(2, ((Integer) cv.constant().constantValue()), \"Should only transform two\");\n+            }\n+            twoFieldCalled.set(true);\n+            fb.with(fe);\n+        }, fm -> fm.fieldName().equalsString(\"two\"));\n+        cf.transformClass(clazz, oneFieldTransform.andThen(twoFieldTransform));\n+        assertTrue(oneFieldCalled.get(), \"Field one not transformed\");\n+        assertTrue(twoFieldCalled.get(), \"Field two not transformed\");\n+\n+        AtomicBoolean oneMethodCalled = new AtomicBoolean(false);\n+        var oneMethodTransform = ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(\"one\"), (mb, me) -> {\n+            if (me instanceof AnnotationDefaultAttribute ada) {\n+                assertEquals(1, ((AnnotationValue.OfInt) ada.defaultValue()).intValue(), \"Should only transform one\");\n+            }\n+            oneMethodCalled.set(true);\n+            mb.with(me);\n+        });\n+        AtomicBoolean twoMethodCalled = new AtomicBoolean(false);\n+        var twoMethodTransform = ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(\"two\"), (mb, me) -> {\n+            if (me instanceof AnnotationDefaultAttribute ada) {\n+                assertEquals(2, ((AnnotationValue.OfInt) ada.defaultValue()).intValue(), \"Should only transform two\");\n+            }\n+            twoMethodCalled.set(true);\n+            mb.with(me);\n+        });\n+        cf.transformClass(clazz, oneMethodTransform.andThen(twoMethodTransform));\n+        assertTrue(oneMethodCalled.get(), \"Method one not transformed\");\n+        assertTrue(twoMethodCalled.get(), \"Method two not transformed\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":58,"deletions":16,"binary":false,"changes":74,"status":"modified"}]}